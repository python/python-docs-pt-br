# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-17 14:14+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/asyncio-queue.rst:7
msgid "Queues"
msgstr "Filas"

#: ../../library/asyncio-queue.rst:9
msgid "**Source code:** :source:`Lib/asyncio/queues.py`"
msgstr "**Código-fonte:** :source:`Lib/asyncio/queues.py`"

#: ../../library/asyncio-queue.rst:13
msgid ""
"asyncio queues are designed to be similar to classes of the :mod:`queue` "
"module.  Although asyncio queues are not thread-safe, they are designed to "
"be used specifically in async/await code."
msgstr ""
"Filas asyncio são projetadas para serem similar a classes do módulo :mod:"
"`queue`. Apesar de filas asyncio não serem seguras para thread, elas são "
"projetadas para serem usadas especificamente em código async/await."

#: ../../library/asyncio-queue.rst:17
msgid ""
"Note that methods of asyncio queues don't have a *timeout* parameter; use :"
"func:`asyncio.wait_for` function to do queue operations with a timeout."
msgstr ""
"Perceba que métodos de filas asyncio não possuem um parâmetro *timeout*; use "
"a função :func:`asyncio.wait_for` para realizar operações de fila com um "
"tempo limite timeout."

#: ../../library/asyncio-queue.rst:21
msgid "See also the `Examples`_ section below."
msgstr "Veja também a seção `Exemplos`_ abaixo."

#: ../../library/asyncio-queue.rst:24
msgid "Queue"
msgstr "Queue"

#: ../../library/asyncio-queue.rst:28
msgid "A first in, first out (FIFO) queue."
msgstr ""
"Uma fila onde o primeiro a entrar, é o primeiro a sair (FIFO - First In "
"First Out)."

#: ../../library/asyncio-queue.rst:30
msgid ""
"If *maxsize* is less than or equal to zero, the queue size is infinite.  If "
"it is an integer greater than ``0``, then ``await put()`` blocks when the "
"queue reaches *maxsize* until an item is removed by :meth:`get`."
msgstr ""
"Se *maxsize* for menor que ou igual a zero, o tamanho da fila é infinito. Se "
"ele for um inteiro maior que ``0``, então ``await put()`` bloqueia quando a "
"fila atingir *maxsize* até que um item seja removido por :meth:`get`."

#: ../../library/asyncio-queue.rst:35
msgid ""
"Unlike the standard library threading :mod:`queue`, the size of the queue is "
"always known and can be returned by calling the :meth:`qsize` method."
msgstr ""
"Ao contrário da biblioteca padrão de threading :mod:`queue`, o tamanho da "
"fila é sempre conhecido e pode ser obtido através da chamada do método :meth:"
"`qsize`."

#: ../../library/asyncio-queue.rst:39
msgid "Removed the *loop* parameter."
msgstr "Removido o parâmetro *loop*."

#: ../../library/asyncio-queue.rst:43
msgid "This class is :ref:`not thread safe <asyncio-multithreading>`."
msgstr "Esta classe :ref:`não é segura para thread <asyncio-multithreading>`."

#: ../../library/asyncio-queue.rst:47
msgid "Number of items allowed in the queue."
msgstr "Número de itens permitidos na fila."

#: ../../library/asyncio-queue.rst:51
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "Retorna ``True`` se a fila estiver vazia, ``False`` caso contrário."

#: ../../library/asyncio-queue.rst:55
msgid "Return ``True`` if there are :attr:`maxsize` items in the queue."
msgstr "Retorna ``True`` se existem :attr:`maxsize` itens na fila."

#: ../../library/asyncio-queue.rst:57
msgid ""
"If the queue was initialized with ``maxsize=0`` (the default), then :meth:"
"`full` never returns ``True``."
msgstr ""
"Se a fila foi inicializada com ``maxsize=0`` (o padrão), então :meth:`full` "
"nunca retorna ``True``."

#: ../../library/asyncio-queue.rst:63
msgid ""
"Remove and return an item from the queue. If queue is empty, wait until an "
"item is available."
msgstr ""
"Remove e retorna um item da fila. Se a fila estiver vazia, aguarda até que "
"um item esteja disponível."

#: ../../library/asyncio-queue.rst:66
msgid ""
"Raises :exc:`QueueShutDown` if the queue has been shut down and is empty, or "
"if the queue has been shut down immediately."
msgstr ""
"Levanta :exc:`QueueShutDown` se a fila foi encerrada e está vazia, ou se a "
"fila foi encerrada imediatamente."

#: ../../library/asyncio-queue.rst:71
msgid ""
"Return an item if one is immediately available, else raise :exc:`QueueEmpty`."
msgstr ""
"Retorna um item se houver um imediatamente disponível, caso contrário "
"levanta :exc:`QueueEmpty`."

#: ../../library/asyncio-queue.rst:77
msgid "Block until all items in the queue have been received and processed."
msgstr ""
"Bloqueia até que todos os itens na fila tenham sido recebidos e processados."

#: ../../library/asyncio-queue.rst:79
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue. The count goes down whenever a consumer coroutine calls :meth:"
"`task_done` to indicate that the item was retrieved and all work on it is "
"complete.  When the count of unfinished tasks drops to zero, :meth:`join` "
"unblocks."
msgstr ""
"A contagem de tarefas inacabadas aumenta sempre que um item é adicionado à "
"fila. A contagem diminui sempre que uma corrotina consumidora chama :meth:"
"`task_done` para indicar que o item foi recuperado e todo o trabalho nele "
"foi concluído. Quando a contagem de tarefas inacabadas chega a zero, :meth:"
"`join` desbloqueia."

#: ../../library/asyncio-queue.rst:88
msgid ""
"Put an item into the queue. If the queue is full, wait until a free slot is "
"available before adding the item."
msgstr ""
"Coloca um item na fila. Se a fila estiver cheia, aguarda até que uma posição "
"livre esteja disponível antes de adicionar o item."

#: ../../library/asyncio-queue.rst:91
msgid "Raises :exc:`QueueShutDown` if the queue has been shut down."
msgstr "Levanta :exc:`QueueShutDown` se a fila foi encerrada."

#: ../../library/asyncio-queue.rst:95
msgid "Put an item into the queue without blocking."
msgstr "Coloca um item na fila sem bloqueá-la."

#: ../../library/asyncio-queue.rst:97
msgid "If no free slot is immediately available, raise :exc:`QueueFull`."
msgstr ""
"Se nenhuma posição livre estiver imediatamente disponível, levanta :exc:"
"`QueueFull`."

#: ../../library/asyncio-queue.rst:101
msgid "Return the number of items in the queue."
msgstr "Retorna o número de itens na fila."

#: ../../library/asyncio-queue.rst:105
msgid "Put a :class:`Queue` instance into a shutdown mode."
msgstr "Coloca uma instância de :class:`Queue` em modo de desligamento."

#: ../../library/asyncio-queue.rst:107
msgid ""
"The queue can no longer grow. Future calls to :meth:`~Queue.put` raise :exc:"
"`QueueShutDown`. Currently blocked callers of :meth:`~Queue.put` will be "
"unblocked and will raise :exc:`QueueShutDown` in the formerly blocked thread."
msgstr ""
"A fila não pode mais crescer. Chamadas futuras a :meth:`~Queue.put` "
"levantarão :exc:`QueueShutDown`. Chamadores atualmente bloqueados de :meth:"
"`~Queue.put` serão desbloqueados e levantarão :exc:`QueueShutDown` na thread "
"anteriormente bloqueada."

#: ../../library/asyncio-queue.rst:112
msgid ""
"If *immediate* is false (the default), the queue can be wound down normally "
"with :meth:`~Queue.get` calls to extract tasks that have already been loaded."
msgstr ""
"Se *immediate* for falso (o padrão), a fila pode ser encerrada normalmente "
"com chamadas :meth:`~Queue.get` para extrair tarefas que já foram carregadas."

#: ../../library/asyncio-queue.rst:116
msgid ""
"And if :meth:`~Queue.task_done` is called for each remaining task, a "
"pending :meth:`~Queue.join` will be unblocked normally."
msgstr ""
"E se :meth:`~Queue.task_done` for chamado para cada tarefa restante, um :"
"meth:`~Queue.join` pendente será desbloqueado normalmente."

#: ../../library/asyncio-queue.rst:119
msgid ""
"Once the queue is empty, future calls to :meth:`~Queue.get` will raise :exc:"
"`QueueShutDown`."
msgstr ""
"Assim que a fila estiver vazia, chamadas futuras para :meth:`~Queue.get` vão "
"levantar :exc:`QueueShutDown`."

#: ../../library/asyncio-queue.rst:122
msgid ""
"If *immediate* is true, the queue is terminated immediately. The queue is "
"drained to be completely empty and the count of unfinished tasks is reduced "
"by the number of tasks drained. If unfinished tasks is zero, callers of :"
"meth:`~Queue.join` are unblocked.  Also, blocked callers of :meth:`~Queue."
"get` are unblocked and will raise :exc:`QueueShutDown` because the queue is "
"empty."
msgstr ""
"Se *immediate* for verdadeiro, a fila é encerrada imediatamente. A fila é "
"esvaziada completamente e a contagem de tarefas não concluídas é reduzida "
"pelo número de tarefas concluídas. Se o número de tarefas não concluídas for "
"zero, as chamadas de :meth:`~Queue.join` são desbloqueadas. Além disso, as "
"chamadas bloqueadas de :meth:`~Queue.get` são desbloqueadas e levantarão uma "
"exceção :exc:`QueueShutDown` porque a fila está vazia."

#: ../../library/asyncio-queue.rst:130
msgid ""
"Use caution when using :meth:`~Queue.join` with *immediate* set to true. "
"This unblocks the join even when no work has been done on the tasks, "
"violating the usual invariant for joining a queue."
msgstr ""
"Tenha cuidado ao usar :meth:`~Queue.join` com a opção *immediate* definida "
"como verdadeiro. Isso desbloqueia a junção mesmo quando nenhuma tarefa foi "
"executada, violando a invariante usual para a junção de uma fila."

#: ../../library/asyncio-queue.rst:138
msgid "Indicate that a formerly enqueued work item is complete."
msgstr ""
"Indica que o item de trabalho anteriormente enfileirado está concluído."

#: ../../library/asyncio-queue.rst:140
msgid ""
"Used by queue consumers. For each :meth:`~Queue.get` used to fetch a work "
"item, a subsequent call to :meth:`task_done` tells the queue that the "
"processing on the work item is complete."
msgstr ""
"Usada por consumidores de fila. Para cada :meth:`~Queue.get` usado para "
"buscar um item de trabalho, uma chamada subsequente para :meth:`task_done` "
"avisa à fila, que o processamento no item de trabalho está concluído."

#: ../../library/asyncio-queue.rst:144
msgid ""
"If a :meth:`join` is currently blocking, it will resume when all items have "
"been processed (meaning that a :meth:`task_done` call was received for every "
"item that had been :meth:`~Queue.put` into the queue)."
msgstr ""
"Se um :meth:`join` estiver sendo bloqueado no momento, ele irá continuar "
"quando todos os itens tiverem sido processados (significando que uma "
"chamada :meth:`task_done` foi recebida para cada item que foi chamado o "
"método :meth:`~Queue.put` para colocar na fila)."

#: ../../library/asyncio-queue.rst:149
msgid ""
"Raises :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Levanta :exc:`ValueError` se chamada mais vezes do que a quantidade de itens "
"existentes na fila."

#: ../../library/asyncio-queue.rst:154
msgid "Priority Queue"
msgstr "Fila de prioridade"

#: ../../library/asyncio-queue.rst:158
msgid ""
"A variant of :class:`Queue`; retrieves entries in priority order (lowest "
"first)."
msgstr ""
"Uma variante de :class:`Queue`; recupera entradas em ordem de prioridade "
"(mais baixas primeiro)."

#: ../../library/asyncio-queue.rst:161
msgid "Entries are typically tuples of the form ``(priority_number, data)``."
msgstr ""
"Entradas são tipicamente tuplas no formato ``(priority_number, data)``."

#: ../../library/asyncio-queue.rst:166
msgid "LIFO Queue"
msgstr "Filas LIFO (último a entrar, primeiro a sair)"

#: ../../library/asyncio-queue.rst:170
msgid ""
"A variant of :class:`Queue` that retrieves most recently added entries first "
"(last in, first out)."
msgstr ""
"Uma variante de :class:`Queue` que recupera as entradas adicionadas mais "
"recentemente primeiro (último a entrar, primeiro a sair)."

#: ../../library/asyncio-queue.rst:175
msgid "Exceptions"
msgstr "Exceções"

#: ../../library/asyncio-queue.rst:179
msgid ""
"This exception is raised when the :meth:`~Queue.get_nowait` method is called "
"on an empty queue."
msgstr ""
"Esta exceção é levantada quando o método :meth:`~Queue.get_nowait` é chamado "
"em uma fila vazia."

#: ../../library/asyncio-queue.rst:185
msgid ""
"Exception raised when the :meth:`~Queue.put_nowait` method is called on a "
"queue that has reached its *maxsize*."
msgstr ""
"Exceção levantada quando o método :meth:`~Queue.put_nowait` é chamado em uma "
"fila que atingiu seu *maxsize*."

#: ../../library/asyncio-queue.rst:191
msgid ""
"Exception raised when :meth:`~Queue.put` or :meth:`~Queue.get` is called on "
"a queue which has been shut down."
msgstr ""
"Exceção levantada quando :meth:`~Queue.put` ou :meth:`~Queue.get` é chamado "
"em uma fila que foi desligada."

#: ../../library/asyncio-queue.rst:198
msgid "Examples"
msgstr "Exemplos"

#: ../../library/asyncio-queue.rst:202
msgid ""
"Queues can be used to distribute workload between several concurrent tasks::"
msgstr ""
"Filas podem ser usadas para distribuir cargas de trabalho entre diversas "
"tarefas concorrentes::"

#: ../../library/asyncio-queue.rst:205
msgid ""
"import asyncio\n"
"import random\n"
"import time\n"
"\n"
"\n"
"async def worker(name, queue):\n"
"    while True:\n"
"        # Get a \"work item\" out of the queue.\n"
"        sleep_for = await queue.get()\n"
"\n"
"        # Sleep for the \"sleep_for\" seconds.\n"
"        await asyncio.sleep(sleep_for)\n"
"\n"
"        # Notify the queue that the \"work item\" has been processed.\n"
"        queue.task_done()\n"
"\n"
"        print(f'{name} has slept for {sleep_for:.2f} seconds')\n"
"\n"
"\n"
"async def main():\n"
"    # Create a queue that we will use to store our \"workload\".\n"
"    queue = asyncio.Queue()\n"
"\n"
"    # Generate random timings and put them into the queue.\n"
"    total_sleep_time = 0\n"
"    for _ in range(20):\n"
"        sleep_for = random.uniform(0.05, 1.0)\n"
"        total_sleep_time += sleep_for\n"
"        queue.put_nowait(sleep_for)\n"
"\n"
"    # Create three worker tasks to process the queue concurrently.\n"
"    tasks = []\n"
"    for i in range(3):\n"
"        task = asyncio.create_task(worker(f'worker-{i}', queue))\n"
"        tasks.append(task)\n"
"\n"
"    # Wait until the queue is fully processed.\n"
"    started_at = time.monotonic()\n"
"    await queue.join()\n"
"    total_slept_for = time.monotonic() - started_at\n"
"\n"
"    # Cancel our worker tasks.\n"
"    for task in tasks:\n"
"        task.cancel()\n"
"    # Wait until all worker tasks are cancelled.\n"
"    await asyncio.gather(*tasks, return_exceptions=True)\n"
"\n"
"    print('====')\n"
"    print(f'3 workers slept in parallel for {total_slept_for:.2f} seconds')\n"
"    print(f'total expected sleep time: {total_sleep_time:.2f} seconds')\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import random\n"
"import time\n"
"\n"
"\n"
"async def worker(nome, fila):\n"
"    while True:\n"
"        # Retira um \"item de trabalho\" da fila.\n"
"        dormir_por = await queue.get()\n"
"\n"
"        # Dorme por \"dormir_por\" segundos.\n"
"        await asyncio.sleep(dormir_por)\n"
"\n"
"        # Notifica a fila de que o \"item de trabalho\" foi processado.\n"
"        fila.task_done()\n"
"\n"
"        print(f'{nome} dormiu por {dormir_por:.2f} segundos')\n"
"\n"
"\n"
"async def main():\n"
"    # Cria uma fila para armazenar nossa \"carga de trabalho\".\n"
"    fila = asyncio.Queue()\n"
"\n"
"    # Gera tempos aleatórios e os insere na fila.\n"
"    tempo_total_de_sono = 0\n"
"    for _ in range(20):\n"
"        dormir_por = random.uniform(0.05, 1.0)\n"
"        tempo_total_de_sono += dormir_por\n"
"        fila.put_nowait(dormir_por)\n"
"\n"
"    # Cria três tarefas \"worker\" para processarem a fila "
"concorrentemente.\n"
"    tarefas = []\n"
"    for i in range(3):\n"
"        tarefa = asyncio.create_task(worker(f'worker-{i}', fila))\n"
"        tarefas.append(tarefa)\n"
"\n"
"    # Espera até a fila ser completamente processada.\n"
"    comecou_em = time.monotonic()\n"
"    await fila.join()\n"
"    tempo_dormido = time.monotonic() - comecou_em\n"
"\n"
"    # Cancela nossas tarefas.\n"
"    for tarefa in tarefas:\n"
"        tarefa.cancel()\n"
"    # Espera até todas as tarefas serem canceladas.\n"
"    await asyncio.gather(*tarefas, return_exceptions=True)\n"
"\n"
"    print('====')\n"
"    print(f'3 trabalhadoras dormiram em paralelo por {tempo_dormido:.2f} "
"segundos')\n"
"    print(f'Tempo total de sono esperado: {tempo_total_de_sono:.2f} "
"segundos')\n"
"\n"
"\n"
"asyncio.run(main())"

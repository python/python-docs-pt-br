# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-31 14:20+0000\n"
"PO-Revision-Date: 2025-07-18 18:48+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/bisect.rst:2
msgid ":mod:`!bisect` --- Array bisection algorithm"
msgstr ":mod:`!bisect` --- Algoritmo de bisseção de vetor"

#: ../../library/bisect.rst:10
msgid "**Source code:** :source:`Lib/bisect.py`"
msgstr "**Código-fonte:** :source:`Lib/bisect.py`"

#: ../../library/bisect.rst:14
msgid ""
"This module provides support for maintaining a list in sorted order without "
"having to sort the list after each insertion.  For long lists of items with "
"expensive comparison operations, this can be an improvement over linear "
"searches or frequent resorting."
msgstr ""
"Este módulo fornece suporte para manter uma lista em ordem de classificação "
"sem ter que classificar a lista após cada inserção. Para longas listas de "
"itens com operações de comparação caras, isso pode ser uma melhoria em "
"relação a pesquisas lineares ou recorrência frequente."

#: ../../library/bisect.rst:19
msgid ""
"The module is called :mod:`bisect` because it uses a basic bisection "
"algorithm to do its work.  Unlike other bisection tools that search for a "
"specific value, the functions in this module are designed to locate an "
"insertion point. Accordingly, the functions never call an :meth:`~object."
"__eq__` method to determine whether a value has been found.  Instead, the "
"functions only call the :meth:`~object.__lt__` method and will return an "
"insertion point between values in an array."
msgstr ""
"O módulo é chamado de :mod:`bisect` porque usa um algoritmo básico de "
"bisseção para fazer seu trabalho. Ao contrário de outras ferramentas de "
"bisseção que buscam um valor específico, as funções neste módulo são "
"projetadas para localizar um ponto de inserção. Da mesma forma, as funções "
"nunca chamam um método :meth:`~object.__eq__` para determinar se um valor "
"foi encontrado. Em vez disso, as funções apenas chamam o método :meth:"
"`~object.__lt__` e retornarão um ponto de inserção entre valores em um vetor."

#: ../../library/bisect.rst:29
msgid ""
"The functions in this module are not thread-safe. If multiple threads "
"concurrently use :mod:`bisect` functions on the same sequence, this may "
"result in undefined behaviour. Likewise, if the provided sequence is mutated "
"by a different thread while a :mod:`bisect` function is operating on it, the "
"result is undefined. For example, using :py:func:`~bisect.insort_left` on "
"the same list from multiple threads may result in the list becoming unsorted."
msgstr ""

#: ../../library/bisect.rst:39
msgid "The following functions are provided:"
msgstr "As seguintes funções são fornecidas:"

#: ../../library/bisect.rst:44
msgid ""
"Locate the insertion point for *x* in *a* to maintain sorted order. The "
"parameters *lo* and *hi* may be used to specify a subset of the list which "
"should be considered; by default the entire list is used.  If *x* is already "
"present in *a*, the insertion point will be before (to the left of) any "
"existing entries.  The return value is suitable for use as the first "
"parameter to ``list.insert()`` assuming that *a* is already sorted."
msgstr ""
"Localiza o ponto de inserção de *x* em *a* para manter a ordem de "
"classificação. Os parâmetros *lo* e *hi* podem ser usados para especificar "
"um subconjunto da lista que deve ser considerado; por padrão, toda a lista é "
"usada. Se *x* já estiver presente em *a*, o ponto de inserção estará antes "
"(à esquerda) de qualquer entrada existente. O valor de retorno é adequado "
"para uso como o primeiro parâmetro para ``list.insert()`` supondo que *a* já "
"esteja ordenado."

#: ../../library/bisect.rst:51
msgid ""
"The returned insertion point *ip* partitions the array *a* into two slices "
"such that ``all(elem < x for elem in a[lo : ip])`` is true for the left "
"slice and ``all(elem >= x for elem in a[ip : hi])`` is true for the right "
"slice."
msgstr ""
"O ponto de inserção retornado *ip* particiona o vetor *a* em duas fatias de "
"forma que ``all(elem < x for elem in a[lo : ip])`` seja verdadeiro para a "
"fatia esquerda e ``all(elem >= x for elem in a[ip : hi])`` é verdadeiro para "
"a fatia certa."

#: ../../library/bisect.rst:56
msgid ""
"*key* specifies a :term:`key function` of one argument that is used to "
"extract a comparison key from each element in the array.  To support "
"searching complex records, the key function is not applied to the *x* value."
msgstr ""
"*key* especifica uma :term:`função chave` de um argumento que é usado para "
"extrair uma chave de comparação de cada elemento no vetor. Para oferecer "
"suporte à pesquisa de registros complexos, a função chave não é aplicada ao "
"valor *x*."

#: ../../library/bisect.rst:60
msgid ""
"If *key* is ``None``, the elements are compared directly and no key function "
"is called."
msgstr ""
"Se *key* for ``None``, os elementos serão comparados diretamente e nenhuma "
"função chave será chamada."

#: ../../library/bisect.rst:63 ../../library/bisect.rst:77
#: ../../library/bisect.rst:95 ../../library/bisect.rst:115
msgid "Added the *key* parameter."
msgstr "Adicionado o  parâmetro *key*."

#: ../../library/bisect.rst:70
msgid ""
"Similar to :py:func:`~bisect.bisect_left`, but returns an insertion point "
"which comes after (to the right of) any existing entries of *x* in *a*."
msgstr ""
"Semelhante a :py:func:`~bisect.bisect_left`, mas retorna um ponto de "
"inserção que vem depois (à direita de) qualquer entrada existente de *x* em "
"*a*."

#: ../../library/bisect.rst:73
msgid ""
"The returned insertion point *ip* partitions the array *a* into two slices "
"such that ``all(elem <= x for elem in a[lo : ip])`` is true for the left "
"slice and ``all(elem > x for elem in a[ip : hi])`` is true for the right "
"slice."
msgstr ""
"O ponto de inserção retornado *ip* particiona o vetor *a* em duas fatias de "
"forma que ``all(elem <= x for elem in a[lo : ip])`` seja verdadeiro para a "
"fatia esquerda e ``all(elem > x for elem in a[ip : hi])`` é verdadeiro para "
"a fatia certa."

#: ../../library/bisect.rst:83
msgid "Insert *x* in *a* in sorted order."
msgstr "Insere *x* em *a* na ordem de classificação."

#: ../../library/bisect.rst:85
msgid ""
"This function first runs :py:func:`~bisect.bisect_left` to locate an "
"insertion point. Next, it runs the :meth:`!insert` method on *a* to insert "
"*x* at the appropriate position to maintain sort order."
msgstr ""
"Esta função primeiro executa :py:func:`~bisect.bisect_left` para localizar "
"um ponto de inserção. Em seguida, ele executa o método :meth:`!insert` em "
"*a* para inserir *x* na posição apropriada para manter a ordem de "
"classificação."

#: ../../library/bisect.rst:89 ../../library/bisect.rst:109
msgid ""
"To support inserting records in a table, the *key* function (if any) is "
"applied to *x* for the search step but not for the insertion step."
msgstr ""
"Para oferecer suporte à inserção de registros em uma tabela, a função *key* "
"(se houver) é aplicada a *x* para a etapa de pesquisa, mas não para a etapa "
"de inserção."

#: ../../library/bisect.rst:92 ../../library/bisect.rst:112
msgid ""
"Keep in mind that the *O*\\ (log *n*) search is dominated by the slow *O*\\ "
"(*n*) insertion step."
msgstr ""
"Tenha em mente que a busca *O*\\ (log *n*) é dominada pelo etapa de inserção "
"lenta O(n)."

#: ../../library/bisect.rst:102
msgid ""
"Similar to :py:func:`~bisect.insort_left`, but inserting *x* in *a* after "
"any existing entries of *x*."
msgstr ""
"Semelhante a :py:func:`~bisect.insort_left`, mas inserindo *x* em *a* após "
"qualquer entrada existente de *x*."

#: ../../library/bisect.rst:105
msgid ""
"This function first runs :py:func:`~bisect.bisect_right` to locate an "
"insertion point. Next, it runs the :meth:`!insert` method on *a* to insert "
"*x* at the appropriate position to maintain sort order."
msgstr ""
"Esta função primeiro executa :py:func:`~bisect.bisect_right` para localizar "
"um ponto de inserção. Em seguida, ele executa o método :meth:`!insert` em "
"*a* para inserir *x* na posição apropriada para manter a ordem de "
"classificação."

#: ../../library/bisect.rst:120
msgid "Performance Notes"
msgstr "Observações sobre desempenho"

#: ../../library/bisect.rst:122
msgid ""
"When writing time sensitive code using *bisect()* and *insort()*, keep these "
"thoughts in mind:"
msgstr ""
"Ao escrever um código sensível ao tempo usando *bisect()* e *insort()*, "
"lembre-se do seguinte:"

#: ../../library/bisect.rst:125
msgid ""
"Bisection is effective for searching ranges of values. For locating specific "
"values, dictionaries are more performant."
msgstr ""
"A bisseção é eficaz para pesquisar intervalos de valores. Para localizar "
"valores específicos, os dicionários são mais eficientes."

#: ../../library/bisect.rst:128
msgid ""
"The *insort()* functions are *O*\\ (*n*) because the logarithmic search step "
"is dominated by the linear time insertion step."
msgstr ""
"As funções *insort()* são *O*\\ (*n*) porque a etapa de busca logarítmica é "
"dominada pela etapa de inserção de tempo linear."

#: ../../library/bisect.rst:131
msgid ""
"The search functions are stateless and discard key function results after "
"they are used.  Consequently, if the search functions are used in a loop, "
"the key function may be called again and again on the same array elements. "
"If the key function isn't fast, consider wrapping it with :py:func:"
"`functools.cache` to avoid duplicate computations.  Alternatively, consider "
"searching an array of precomputed keys to locate the insertion point (as "
"shown in the examples section below)."
msgstr ""
"As funções de busca são stateless e descartam os resultados da função chave "
"depois que são usadas. Consequentemente, se as funções de busca forem usadas "
"em um laço, a função chave pode ser chamada repetidamente nos mesmos "
"elementos do vetor. Se a função chave não for rápida, considere envolvê-la "
"com :py:func:`functools.cache` para evitar cálculos duplicados. Como "
"alternativa, considere buscar um vetor de chaves pré-calculadas para "
"localizar o ponto de inserção (conforme mostrado na seção de exemplos "
"abaixo)."

#: ../../library/bisect.rst:141
msgid ""
"`Sorted Collections <https://grantjenks.com/docs/sortedcollections/>`_ is a "
"high performance module that uses *bisect* to managed sorted collections of "
"data."
msgstr ""
"`Sorted Collections <https://grantjenks.com/docs/sortedcollections/>`_ é um "
"módulo de alto desempenho que usa bisseção para gerenciar coleções de dados "
"classificadas."

#: ../../library/bisect.rst:145
msgid ""
"The `SortedCollection recipe <https://code.activestate.com/recipes/577197-"
"sortedcollection/>`_ uses bisect to build a full-featured collection class "
"with straight-forward search methods and support for a key-function.  The "
"keys are precomputed to save unnecessary calls to the key function during "
"searches."
msgstr ""
"A `receita de SortedCollection <https://code.activestate.com/recipes/577197-"
"sortedcollection/>`_ usa bisseção para construir uma classe de coleção "
"completa com métodos de busca diretos e suporte para uma função chave. As "
"chaves são pré-calculadas para economizar em chamadas desnecessárias para a "
"função chave durante as buscas."

#: ../../library/bisect.rst:153
msgid "Searching Sorted Lists"
msgstr "Buscando em listas ordenadas"

#: ../../library/bisect.rst:155
msgid ""
"The above `bisect functions`_ are useful for finding insertion points but "
"can be tricky or awkward to use for common searching tasks. The following "
"five functions show how to transform them into the standard lookups for "
"sorted lists::"
msgstr ""
"As `funções de bisseção`_ acima são úteis para encontrar pontos de inserção, "
"mas podem ser complicadas ou difíceis de usar para tarefas comuns de busca. "
"As cinco funções a seguir mostram como transformá-las nas buscas padrão para "
"listas ordenadas::"

#: ../../library/bisect.rst:160
msgid ""
"def index(a, x):\n"
"    'Locate the leftmost value exactly equal to x'\n"
"    i = bisect_left(a, x)\n"
"    if i != len(a) and a[i] == x:\n"
"        return i\n"
"    raise ValueError\n"
"\n"
"def find_lt(a, x):\n"
"    'Find rightmost value less than x'\n"
"    i = bisect_left(a, x)\n"
"    if i:\n"
"        return a[i-1]\n"
"    raise ValueError\n"
"\n"
"def find_le(a, x):\n"
"    'Find rightmost value less than or equal to x'\n"
"    i = bisect_right(a, x)\n"
"    if i:\n"
"        return a[i-1]\n"
"    raise ValueError\n"
"\n"
"def find_gt(a, x):\n"
"    'Find leftmost value greater than x'\n"
"    i = bisect_right(a, x)\n"
"    if i != len(a):\n"
"        return a[i]\n"
"    raise ValueError\n"
"\n"
"def find_ge(a, x):\n"
"    'Find leftmost item greater than or equal to x'\n"
"    i = bisect_left(a, x)\n"
"    if i != len(a):\n"
"        return a[i]\n"
"    raise ValueError"
msgstr ""
"def index(a, x):\n"
"    'Encontra o valor mais à esquerda exatamente igual a x'\n"
"    i = bisect_left(a, x)\n"
"    if i != len(a) and a[i] == x:\n"
"        return i\n"
"    raise ValueError\n"
"\n"
"def find_lt(a, x):\n"
"    'Encontra o valor mais à direita menor que x'\n"
"    i = bisect_left(a, x)\n"
"    if i:\n"
"        return a[i-1]\n"
"    raise ValueError\n"
"\n"
"def find_le(a, x):\n"
"    'Encontra o valor mais à direita menor ou igual a x'\n"
"    i = bisect_right(a, x)\n"
"    if i:\n"
"        return a[i-1]\n"
"    raise ValueError\n"
"\n"
"def find_gt(a, x):\n"
"    'Encontra o valor mais à esquerda maior que x'\n"
"    i = bisect_right(a, x)\n"
"    if i != len(a):\n"
"        return a[i]\n"
"    raise ValueError\n"
"\n"
"def find_ge(a, x):\n"
"    'Encontra o item mais à esquerda maior ou igual a x'\n"
"    i = bisect_left(a, x)\n"
"    if i != len(a):\n"
"        return a[i]\n"
"    raise ValueError"

#: ../../library/bisect.rst:197
msgid "Examples"
msgstr "Exemplos"

#: ../../library/bisect.rst:201
msgid ""
"The :py:func:`~bisect.bisect` function can be useful for numeric table "
"lookups. This example uses :py:func:`~bisect.bisect` to look up a letter "
"grade for an exam score (say) based on a set of ordered numeric breakpoints: "
"90 and up is an 'A', 80 to 89 is a 'B', and so on::"
msgstr ""
"A função :py:func:`~bisect.bisect` pode ser útil para buscas em tabelas "
"numéricas. Este exemplo usa :py:func:`~bisect.bisect` para buscar uma nota "
"em letra para uma pontuação de exame (digamos) com base em um conjunto de "
"pontos de interrupção numéricos ordenados: 90 e acima é um \"A\", 80 a 89 é "
"um \"B\" e por aí vai::"

#: ../../library/bisect.rst:206
msgid ""
">>> def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):\n"
"...     i = bisect(breakpoints, score)\n"
"...     return grades[i]\n"
"...\n"
">>> [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]\n"
"['F', 'A', 'C', 'C', 'B', 'A', 'A']"
msgstr ""
">>> def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):\n"
"...     i = bisect(breakpoints, score)\n"
"...     return grades[i]\n"
"...\n"
">>> [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]\n"
"['F', 'A', 'C', 'C', 'B', 'A', 'A']"

#: ../../library/bisect.rst:213
msgid ""
"The :py:func:`~bisect.bisect` and :py:func:`~bisect.insort` functions also "
"work with lists of tuples.  The *key* argument can serve to extract the "
"field used for ordering records in a table::"
msgstr ""
"As funções :py:func:`~bisect.bisect` e :py:func:`~bisect.insort` também "
"funcionam com listas de tuplas. O argumento *key* pode servir para extrair o "
"campo usado para ordenar registros em uma tabela::"

#: ../../library/bisect.rst:217
msgid ""
">>> from collections import namedtuple\n"
">>> from operator import attrgetter\n"
">>> from bisect import bisect, insort\n"
">>> from pprint import pprint\n"
"\n"
">>> Movie = namedtuple('Movie', ('name', 'released', 'director'))\n"
"\n"
">>> movies = [\n"
"...     Movie('Jaws', 1975, 'Spielberg'),\n"
"...     Movie('Titanic', 1997, 'Cameron'),\n"
"...     Movie('The Birds', 1963, 'Hitchcock'),\n"
"...     Movie('Aliens', 1986, 'Cameron')\n"
"... ]\n"
"\n"
">>> # Find the first movie released after 1960\n"
">>> by_year = attrgetter('released')\n"
">>> movies.sort(key=by_year)\n"
">>> movies[bisect(movies, 1960, key=by_year)]\n"
"Movie(name='The Birds', released=1963, director='Hitchcock')\n"
"\n"
">>> # Insert a movie while maintaining sort order\n"
">>> romance = Movie('Love Story', 1970, 'Hiller')\n"
">>> insort(movies, romance, key=by_year)\n"
">>> pprint(movies)\n"
"[Movie(name='The Birds', released=1963, director='Hitchcock'),\n"
" Movie(name='Love Story', released=1970, director='Hiller'),\n"
" Movie(name='Jaws', released=1975, director='Spielberg'),\n"
" Movie(name='Aliens', released=1986, director='Cameron'),\n"
" Movie(name='Titanic', released=1997, director='Cameron')]"
msgstr ""
">>> from collections import namedtuple\n"
">>> from operator import attrgetter\n"
">>> from bisect import bisect, insort\n"
">>> from pprint import pprint\n"
"\n"
">>> Movie = namedtuple('Movie', ('name', 'released', 'director'))\n"
"\n"
">>> movies = [\n"
"...     Movie('Jaws', 1975, 'Spielberg'),\n"
"...     Movie('Titanic', 1997, 'Cameron'),\n"
"...     Movie('The Birds', 1963, 'Hitchcock'),\n"
"...     Movie('Aliens', 1986, 'Cameron')\n"
"... ]\n"
"\n"
">>> # Encontra o primeiro filme lançado após 1960\n"
">>> by_year = attrgetter('released')\n"
">>> movies.sort(key=by_year)\n"
">>> movies[bisect(movies, 1960, key=by_year)]\n"
"Movie(name='The Birds', released=1963, director='Hitchcock')\n"
"\n"
">>> # Insere um filme enquanto mantém a ordem de classificação\n"
">>> romance = Movie('Love Story', 1970, 'Hiller')\n"
">>> insort(movies, romance, key=by_year)\n"
">>> pprint(movies)\n"
"[Movie(name='The Birds', released=1963, director='Hitchcock'),\n"
" Movie(name='Love Story', released=1970, director='Hiller'),\n"
" Movie(name='Jaws', released=1975, director='Spielberg'),\n"
" Movie(name='Aliens', released=1986, director='Cameron'),\n"
" Movie(name='Titanic', released=1997, director='Cameron')]"

#: ../../library/bisect.rst:247
msgid ""
"If the key function is expensive, it is possible to avoid repeated function "
"calls by searching a list of precomputed keys to find the index of a record::"
msgstr ""
"Se a função chave for custosa, é possível evitar chamadas de função "
"repetidas buscando uma lista de chaves pré-calculadas para encontrar o "
"índice de um registro::"

#: ../../library/bisect.rst:250
msgid ""
">>> data = [('red', 5), ('blue', 1), ('yellow', 8), ('black', 0)]\n"
">>> data.sort(key=lambda r: r[1])       # Or use operator.itemgetter(1).\n"
">>> keys = [r[1] for r in data]         # Precompute a list of keys.\n"
">>> data[bisect_left(keys, 0)]\n"
"('black', 0)\n"
">>> data[bisect_left(keys, 1)]\n"
"('blue', 1)\n"
">>> data[bisect_left(keys, 5)]\n"
"('red', 5)\n"
">>> data[bisect_left(keys, 8)]\n"
"('yellow', 8)"
msgstr ""
">>> data = [('red', 5), ('blue', 1), ('yellow', 8), ('black', 0)]\n"
">>> data.sort(key=lambda r: r[1])       # Ou use operator.itemgetter(1).\n"
">>> keys = [r[1] for r in data]         # Pré-calcula uma lista de chaves.\n"
">>> data[bisect_left(keys, 0)]\n"
"('black', 0)\n"
">>> data[bisect_left(keys, 1)]\n"
"('blue', 1)\n"
">>> data[bisect_left(keys, 5)]\n"
"('red', 5)\n"
">>> data[bisect_left(keys, 8)]\n"
"('yellow', 8)"

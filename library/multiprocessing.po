# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Raphael Mendonça, 2017
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2017
# Hugo Santos Piauilino <hugos94@gmail.com>, 2019
# Vinicius Gubiani Ferreira <vini.g.fer@gmail.com>, 2020
# i17obot <i17obot@rougeth.com>, 2021
# Caio Fauza, 2021
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-03-28 17:02+0000\n"
"PO-Revision-Date: 2017-02-16 23:19+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/multiprocessing.rst:2
msgid ":mod:`multiprocessing` --- Process-based parallelism"
msgstr ":mod:`multiprocessing` --- Paralelismo baseado em processo"

#: ../../library/multiprocessing.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/`"
msgstr "**Código-fonte:** :source:`Lib/multiprocessing/`"

#: ../../library/multiprocessing.rst:12
msgid "Introduction"
msgstr "Introdução"

#: ../../library/multiprocessing.rst:14
msgid ""
":mod:`multiprocessing` is a package that supports spawning processes using "
"an API similar to the :mod:`threading` module.  The :mod:`multiprocessing` "
"package offers both local and remote concurrency, effectively side-stepping "
"the :term:`Global Interpreter Lock <global interpreter lock>` by using "
"subprocesses instead of threads.  Due to this, the :mod:`multiprocessing` "
"module allows the programmer to fully leverage multiple processors on a "
"given machine.  It runs on both Unix and Windows."
msgstr ""
":mod:`multiprocessing` é um pacote que suporta invocação de processos "
"utilizando uma API semelhante ao módulo :mod:`threading`. O pacote :mod:"
"`multiprocessing` oferece simultaneamente concorrência local e remota, "
"efetivamente contornando o :term:`Bloqueio Global do Interpretador <global "
"interpreter lock>`, ao utilizar subprocessos ao invés de threads. Devido a "
"isso, o módulo :mod:`multiprocessing` permite ao programador aproveitar "
"totalmente os múltiplos processadores de uma máquina. Ele funciona tanto em "
"Unix como em Windows."

#: ../../library/multiprocessing.rst:23
msgid ""
"The :mod:`multiprocessing` module also introduces APIs which do not have "
"analogs in the :mod:`threading` module.  A prime example of this is the :"
"class:`~multiprocessing.pool.Pool` object which offers a convenient means of "
"parallelizing the execution of a function across multiple input values, "
"distributing the input data across processes (data parallelism).  The "
"following example demonstrates the common practice of defining such "
"functions in a module so that child processes can successfully import that "
"module.  This basic example of data parallelism using :class:"
"`~multiprocessing.pool.Pool`, ::"
msgstr ""
"O módulo :mod:`multiprocessing` também introduz APIs que não têm análogos no "
"módulo :mod:`threading`. Um exemplo principal disso é o objeto :class:"
"`~multiprocessing.pool.Pool` que oferece um meio conveniente de paralelizar "
"a execução de uma função em vários valores de entrada, distribuindo os dados "
"de entrada entre processos (paralelismo de dados). O exemplo a seguir "
"demonstra a prática comum de definir tais funções em um módulo para que os "
"processos filhos possam importar esse módulo com sucesso. Este exemplo "
"básico de paralelismo de dados usando :class:`~multiprocessing.pool.Pool`, ::"

#: ../../library/multiprocessing.rst:41
msgid "will print to standard output ::"
msgstr "vai exibir na saída padrão ::"

#: ../../library/multiprocessing.rst:47
msgid "The :class:`Process` class"
msgstr "A classe :class:`Process`"

#: ../../library/multiprocessing.rst:49
msgid ""
"In :mod:`multiprocessing`, processes are spawned by creating a :class:"
"`Process` object and then calling its :meth:`~Process.start` method.  :class:"
"`Process` follows the API of :class:`threading.Thread`.  A trivial example "
"of a multiprocess program is ::"
msgstr ""
"Em :mod:`multiprocessing`, os processos são gerados criando um objeto :class:"
"`Process` e então chamando seu método :meth:`~Process.start`. :class:"
"`Process` segue a API de :class:`threading.Thread`. Um exemplo trivial de um "
"programa multiprocesso é ::"

#: ../../library/multiprocessing.rst:64
msgid ""
"To show the individual process IDs involved, here is an expanded example::"
msgstr ""
"Para mostrar os IDs de processo individuais envolvidos, aqui está um exemplo "
"expandido::"

#: ../../library/multiprocessing.rst:85
msgid ""
"For an explanation of why the ``if __name__ == '__main__'`` part is "
"necessary, see :ref:`multiprocessing-programming`."
msgstr ""
"Para uma explicação do porquê a parte ``if __name__ == '__main__'`` é "
"necessária, veja :ref:`multiprocessing-programming`."

#: ../../library/multiprocessing.rst:91
msgid "Contexts and start methods"
msgstr "Contextos e métodos de inicialização"

#: ../../library/multiprocessing.rst:95
msgid ""
"Depending on the platform, :mod:`multiprocessing` supports three ways to "
"start a process.  These *start methods* are"
msgstr ""
"Dependendo da plataforma, :mod:`multiprocessing` suporta três maneiras de "
"iniciar um processo. Estes *métodos de início* são"

#: ../../library/multiprocessing.rst:106
msgid "*spawn*"
msgstr "*spawn*"

#: ../../library/multiprocessing.rst:99
msgid ""
"The parent process starts a fresh python interpreter process.  The child "
"process will only inherit those resources necessary to run the process "
"object's :meth:`~Process.run` method.  In particular, unnecessary file "
"descriptors and handles from the parent process will not be inherited.  "
"Starting a process using this method is rather slow compared to using *fork* "
"or *forkserver*."
msgstr ""

#: ../../library/multiprocessing.rst:106
msgid "Available on Unix and Windows.  The default on Windows and macOS."
msgstr "Disponível para Unix e Windows. O padrão no Windows e macOS."

#: ../../library/multiprocessing.rst:115
msgid "*fork*"
msgstr "*fork*"

#: ../../library/multiprocessing.rst:109
msgid ""
"The parent process uses :func:`os.fork` to fork the Python interpreter.  The "
"child process, when it begins, is effectively identical to the parent "
"process.  All resources of the parent are inherited by the child process.  "
"Note that safely forking a multithreaded process is problematic."
msgstr ""
"O processo pai usa :func:`os.fork` para fazer um fork do interpretador "
"Python. O processo filho, quando começa, é efetivamente idêntico ao processo "
"pai. Todos os recursos do pai são herdados pelo processo filho. Observe que "
"fazer um fork com segurança de um processo multithread é problemático."

#: ../../library/multiprocessing.rst:115
msgid "Available on Unix only.  The default on Unix."
msgstr "Disponível apenas para Unix. O padrão no Unix."

#: ../../library/multiprocessing.rst:126
msgid "*forkserver*"
msgstr "*forkserver*"

#: ../../library/multiprocessing.rst:118
msgid ""
"When the program starts and selects the *forkserver* start method, a server "
"process is started.  From then on, whenever a new process is needed, the "
"parent process connects to the server and requests that it fork a new "
"process.  The fork server process is single threaded so it is safe for it to "
"use :func:`os.fork`.  No unnecessary resources are inherited."
msgstr ""
"Quando o programa é inicializado e seleciona o método de início "
"*forkserver*, um processo de servidor é inicializado. A partir disso, sempre "
"que um novo processo é necessário, o processo pai conecta-se ao servidor e "
"solicita que um novo processo seja feito im fork. O fork do processo do "
"servidor é de thread único, então é seguro utilizar :func:`os.fork`. Nenhum "
"recurso desnecessário é herdado."

#: ../../library/multiprocessing.rst:125
msgid ""
"Available on Unix platforms which support passing file descriptors over Unix "
"pipes."
msgstr ""
"Disponível em plataformas Unix que suportam a passagem de descritores de "
"arquivo em Unix pipes."

#: ../../library/multiprocessing.rst:130 ../../library/multiprocessing.rst:1044
msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess. See :issue:`33725`."
msgstr ""
"No macOS, o método de início *spawn* agora é o padrão. O método de início "
"*fork* deve ser considerado inseguro, pois pode levar a travamentos do "
"subprocesso. Veja :issue:`33725`."

#: ../../library/multiprocessing.rst:134
msgid ""
"*spawn* added on all unix platforms, and *forkserver* added for some unix "
"platforms. Child processes no longer inherit all of the parents inheritable "
"handles on Windows."
msgstr ""

#: ../../library/multiprocessing.rst:140
msgid ""
"On Unix using the *spawn* or *forkserver* start methods will also start a "
"*resource tracker* process which tracks the unlinked named system resources "
"(such as named semaphores or :class:`~multiprocessing.shared_memory."
"SharedMemory` objects) created by processes of the program.  When all "
"processes have exited the resource tracker unlinks any remaining tracked "
"object. Usually there should be none, but if a process was killed by a "
"signal there may be some \"leaked\" resources.  (Neither leaked semaphores "
"nor shared memory segments will be automatically unlinked until the next "
"reboot. This is problematic for both objects because the system allows only "
"a limited number of named semaphores, and shared memory segments occupy some "
"space in the main memory.)"
msgstr ""

#: ../../library/multiprocessing.rst:153
msgid ""
"To select a start method you use the :func:`set_start_method` in the ``if "
"__name__ == '__main__'`` clause of the main module.  For example::"
msgstr ""
"Para selecionar um método de início, você usa :func:`set_start_method` na "
"cláusula ``if __name__ == '__main__'`` do módulo principal. Por exemplo::"

#: ../../library/multiprocessing.rst:170
msgid ""
":func:`set_start_method` should not be used more than once in the program."
msgstr ""
":func:`set_start_method` não deve ser usada mais de uma vez no programa."

#: ../../library/multiprocessing.rst:173
msgid ""
"Alternatively, you can use :func:`get_context` to obtain a context object.  "
"Context objects have the same API as the multiprocessing module, and allow "
"one to use multiple start methods in the same program. ::"
msgstr ""
"Alternativamente, você pode usar :func:`get_context` para obter um objeto de "
"contexto. Objetos de contexto têm a mesma API que o módulo multiprocessing e "
"permitem que se usem vários métodos de início no mesmo programa. ::"

#: ../../library/multiprocessing.rst:191
msgid ""
"Note that objects related to one context may not be compatible with "
"processes for a different context.  In particular, locks created using the "
"*fork* context cannot be passed to processes started using the *spawn* or "
"*forkserver* start methods."
msgstr ""
"Note que objetos relacionados a um contexto podem não ser compatíveis com "
"processos para um contexto diferente. Em particular, travas criadas usando o "
"contexto *fork* não podem ser passados para processos iniciados usando os "
"métodos de início *spawn* ou *forkserver*."

#: ../../library/multiprocessing.rst:196
msgid ""
"A library which wants to use a particular start method should probably use :"
"func:`get_context` to avoid interfering with the choice of the library user."
msgstr ""
"Uma biblioteca que deseja utilizar um método de início específico "
"provavelmente deve utilizar :func:`get_context` para evitar interferir na "
"escolha do usuário."

#: ../../library/multiprocessing.rst:202
msgid ""
"The ``'spawn'`` and ``'forkserver'`` start methods cannot currently be used "
"with \"frozen\" executables (i.e., binaries produced by packages like "
"**PyInstaller** and **cx_Freeze**) on Unix. The ``'fork'`` start method does "
"work."
msgstr ""

#: ../../library/multiprocessing.rst:209
msgid "Exchanging objects between processes"
msgstr "Trocando objetos entre processos"

#: ../../library/multiprocessing.rst:211
msgid ""
":mod:`multiprocessing` supports two types of communication channel between "
"processes:"
msgstr ""
":mod:`multiprocessing` tem suporte a dois tipos de canal de comunicação "
"entre processos:"

#: ../../library/multiprocessing.rst:214
msgid "**Queues**"
msgstr "**Filas**"

#: ../../library/multiprocessing.rst:216
msgid ""
"The :class:`Queue` class is a near clone of :class:`queue.Queue`.  For "
"example::"
msgstr ""
"A classe :class:`Queue` é quase um clone de :class:`queue.Queue`. Por "
"exemplo::"

#: ../../library/multiprocessing.rst:231
msgid "Queues are thread and process safe."
msgstr ""

#: ../../library/multiprocessing.rst:233
msgid "**Pipes**"
msgstr "**Encadeamentos**"

#: ../../library/multiprocessing.rst:235
msgid ""
"The :func:`Pipe` function returns a pair of connection objects connected by "
"a pipe which by default is duplex (two-way).  For example::"
msgstr ""
"A função :func:`Pipe` retorna um par de objetos de conexão conectados por um "
"encadeamento que por padrão é duplex (bidirecional). Por exemplo::"

#: ../../library/multiprocessing.rst:251
msgid ""
"The two connection objects returned by :func:`Pipe` represent the two ends "
"of the pipe.  Each connection object has :meth:`~Connection.send` and :meth:"
"`~Connection.recv` methods (among others).  Note that data in a pipe may "
"become corrupted if two processes (or threads) try to read from or write to "
"the *same* end of the pipe at the same time.  Of course there is no risk of "
"corruption from processes using different ends of the pipe at the same time."
msgstr ""
"Os dois objetos de conexão retornados por :func:`Pipe` representam as duas "
"extremidades do encadeamento. Cada objeto de conexão tem os métodos :meth:"
"`~Connection.send` e :meth:`~Connection.recv` (entre outros). Observe que os "
"dados em um encadeamento podem ser corrompidos se dois processos (ou "
"threads) tentarem ler ou gravar na *mesma* extremidade do encadeamento ao "
"mesmo tempo. Claro que não há risco de corrupção de processos usando "
"extremidades diferentes do encadeamento ao mesmo tempo."

#: ../../library/multiprocessing.rst:261
msgid "Synchronization between processes"
msgstr "Sincronização entre processos"

#: ../../library/multiprocessing.rst:263
msgid ""
":mod:`multiprocessing` contains equivalents of all the synchronization "
"primitives from :mod:`threading`.  For instance one can use a lock to ensure "
"that only one process prints to standard output at a time::"
msgstr ""
":mod:`multiprocessing` contém equivalentes de todas as primitivas de "
"sincronização de :mod:`threading`. Por exemplo, pode-se usar uma trava para "
"garantir que apenas um processo exiba na saída padrão por vez::"

#: ../../library/multiprocessing.rst:282
msgid ""
"Without using the lock output from the different processes is liable to get "
"all mixed up."
msgstr ""
"Sem utilizar a saída da trava dos diferentes processos, é possível que tudo "
"fique confuso."

#: ../../library/multiprocessing.rst:287
msgid "Sharing state between processes"
msgstr "Compartilhando estado entre processos"

#: ../../library/multiprocessing.rst:289
msgid ""
"As mentioned above, when doing concurrent programming it is usually best to "
"avoid using shared state as far as possible.  This is particularly true when "
"using multiple processes."
msgstr ""
"Conforme mencionado acima, ao fazer programação concorrente, geralmente é "
"melhor evitar o uso de estado compartilhado, tanto quanto possível. Isso é "
"particularmente verdadeiro ao utilizar múltiplos processos."

#: ../../library/multiprocessing.rst:293
msgid ""
"However, if you really do need to use some shared data then :mod:"
"`multiprocessing` provides a couple of ways of doing so."
msgstr ""
"No entanto, se você realmente precisa utilizar algum compartilhamento de "
"dados, então :mod:`multiprocessing` fornece algumas maneiras de se fazer "
"isso."

#: ../../library/multiprocessing.rst:296
msgid "**Shared memory**"
msgstr "**Memória compartilhada**"

#: ../../library/multiprocessing.rst:298
msgid ""
"Data can be stored in a shared memory map using :class:`Value` or :class:"
"`Array`.  For example, the following code ::"
msgstr ""
"Os dados podem ser armazenados em um mapa de memória compartilhado "
"utilizando :class:`Value` ou :class:`Array`. Por exemplo, o código a "
"seguir ::"

#: ../../library/multiprocessing.rst:319 ../../library/multiprocessing.rst:365
msgid "will print ::"
msgstr "vai exibir ::"

#: ../../library/multiprocessing.rst:324
msgid ""
"The ``'d'`` and ``'i'`` arguments used when creating ``num`` and ``arr`` are "
"typecodes of the kind used by the :mod:`array` module: ``'d'`` indicates a "
"double precision float and ``'i'`` indicates a signed integer.  These shared "
"objects will be process and thread-safe."
msgstr ""
"Os argumentos ``'d'`` e ``'i'`` usados ao criar ``num`` e ``arr`` são "
"typecodes do tipo usado pelo módulo :mod:`array`: ``'d'`` indica um ponto "
"flutuante de precisão dupla e ``'i'`` indica um inteiro com sinal. Esses "
"objetos compartilhados serão seguros para thread e processo."

#: ../../library/multiprocessing.rst:329
msgid ""
"For more flexibility in using shared memory one can use the :mod:"
"`multiprocessing.sharedctypes` module which supports the creation of "
"arbitrary ctypes objects allocated from shared memory."
msgstr ""
"Para mais flexibilidade no uso de memória compartilhada, pode-se utilizar o "
"módulo :mod:`multiprocessing.sharedctypes`, que suporta a criação de objetos "
"ctypes arbritários alocados da memória compartilhada."

#: ../../library/multiprocessing.rst:333
msgid "**Server process**"
msgstr "**Processo de servidor**"

#: ../../library/multiprocessing.rst:335
msgid ""
"A manager object returned by :func:`Manager` controls a server process which "
"holds Python objects and allows other processes to manipulate them using "
"proxies."
msgstr ""
"Um objeto gerenciador retornado por :func:`Manager` controla um processo de "
"servidor que contém objetos Python e permite que outros processos os "
"manipulem usando proxies."

#: ../../library/multiprocessing.rst:339
msgid ""
"A manager returned by :func:`Manager` will support types :class:`list`, :"
"class:`dict`, :class:`~managers.Namespace`, :class:`Lock`, :class:`RLock`, :"
"class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, :class:"
"`Event`, :class:`Barrier`, :class:`Queue`, :class:`Value` and :class:"
"`Array`.  For example, ::"
msgstr ""
"Um gerenciador retornado por :func:`Manager` vai oferecer suporte aos tipos :"
"class:`list`, :class:`dict`, :class:`~managers.Namespace`, :class:`Lock`, :"
"class:`RLock`, :class:`Semaphore`, :class:`BoundedSemaphore`, :class:"
"`Condition`, :class:`Event`, :class:`Barrier`, :class:`Queue`, :class:"
"`Value` e :class:`Array`. Por exemplo, ::"

#: ../../library/multiprocessing.rst:370
msgid ""
"Server process managers are more flexible than using shared memory objects "
"because they can be made to support arbitrary object types.  Also, a single "
"manager can be shared by processes on different computers over a network. "
"They are, however, slower than using shared memory."
msgstr ""
"Os gerenciadores de processos de servidor são mais flexíveis do que usar "
"objetos de memória compartilhada porque podem ser feitos para oferecer "
"suporte a tipos de objetos arbitrários. Além disso, um único gerenciador "
"pode ser compartilhado por processos em diferentes computadores em uma rede. "
"Eles são, no entanto, mais lentos do que usar memória compartilhada."

#: ../../library/multiprocessing.rst:377
msgid "Using a pool of workers"
msgstr "Usando um pool de workers"

#: ../../library/multiprocessing.rst:379
msgid ""
"The :class:`~multiprocessing.pool.Pool` class represents a pool of worker "
"processes.  It has methods which allows tasks to be offloaded to the worker "
"processes in a few different ways."
msgstr ""
"A classe :class:`~multiprocessing.pool.Pool` representa um pool de processos "
"de worker. Ela tem métodos que permitem que tarefas sejam descarregadas para "
"os processos de worker de algumas maneiras diferentes."

#: ../../library/multiprocessing.rst:383
msgid "For example::"
msgstr "Por exemplo::"

#: ../../library/multiprocessing.rst:427
msgid ""
"Note that the methods of a pool should only ever be used by the process "
"which created it."
msgstr ""
"Observe que os métodos de um pool só devem ser usados pelo processo que o "
"criou."

#: ../../library/multiprocessing.rst:432
msgid ""
"Functionality within this package requires that the ``__main__`` module be "
"importable by the children. This is covered in :ref:`multiprocessing-"
"programming` however it is worth pointing out here. This means that some "
"examples, such as the :class:`multiprocessing.pool.Pool` examples will not "
"work in the interactive interpreter. For example::"
msgstr ""
"A funcionalidade dentro deste pacote requer que o módulo ``__main__`` seja "
"importável pelos filhos. Isso é abordado em :ref:`multiprocessing-"
"programming`, mas vale a pena apontar aqui. Isso significa que alguns "
"exemplos, como os exemplos :class:`multiprocessing.pool.Pool` não "
"funcionarão no interpretador interativo. Por exemplo::"

#: ../../library/multiprocessing.rst:455
msgid ""
"(If you try this it will actually output three full tracebacks interleaved "
"in a semi-random fashion, and then you may have to stop the parent process "
"somehow.)"
msgstr ""
"(Se você tentar isso, na verdade, serão gerados três tracebacks completos "
"intercalados de forma semi-aleatória, e então você pode ter que interromper "
"o processo pai de alguma forma.)"

#: ../../library/multiprocessing.rst:461
msgid "Reference"
msgstr "Referência"

#: ../../library/multiprocessing.rst:463
msgid ""
"The :mod:`multiprocessing` package mostly replicates the API of the :mod:"
"`threading` module."
msgstr ""
"O pacote :mod:`multiprocessing` replica principalmente a API do módulo :mod:"
"`threading`."

#: ../../library/multiprocessing.rst:468
msgid ":class:`Process` and exceptions"
msgstr ":class:`Process` e exceções"

#: ../../library/multiprocessing.rst:473
msgid ""
"Process objects represent activity that is run in a separate process. The :"
"class:`Process` class has equivalents of all the methods of :class:"
"`threading.Thread`."
msgstr ""
"Objetos processo representam atividades que são executadas em um processo "
"separado. A classe :class:`Process` possui equivalentes de todos os métodos "
"de :class:`threading.Thread`."

#: ../../library/multiprocessing.rst:477
msgid ""
"The constructor should always be called with keyword arguments. *group* "
"should always be ``None``; it exists solely for compatibility with :class:"
"`threading.Thread`.  *target* is the callable object to be invoked by the :"
"meth:`run()` method.  It defaults to ``None``, meaning nothing is called. "
"*name* is the process name (see :attr:`name` for more details). *args* is "
"the argument tuple for the target invocation.  *kwargs* is a dictionary of "
"keyword arguments for the target invocation.  If provided, the keyword-only "
"*daemon* argument sets the process :attr:`daemon` flag to ``True`` or "
"``False``.  If ``None`` (the default), this flag will be inherited from the "
"creating process."
msgstr ""

#: ../../library/multiprocessing.rst:488
msgid "By default, no arguments are passed to *target*."
msgstr "Por padrão, nenhum argumento é passado para *target*."

#: ../../library/multiprocessing.rst:490
msgid ""
"If a subclass overrides the constructor, it must make sure it invokes the "
"base class constructor (:meth:`Process.__init__`) before doing anything else "
"to the process."
msgstr ""
"Se uma subclasse substitui o construtor, ela deve certificar-se de invocar o "
"construtor da classe base (:meth:`Process.__init__`) antes de fazer qualquer "
"outra coisa no processo."

#: ../../library/multiprocessing.rst:494
msgid "Added the *daemon* argument."
msgstr "Adicionado o argumento *daemon*."

#: ../../library/multiprocessing.rst:499
msgid "Method representing the process's activity."
msgstr "Método que representa a atividade do processo."

#: ../../library/multiprocessing.rst:501
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the target "
"argument, if any, with sequential and keyword arguments taken from the "
"*args* and *kwargs* arguments, respectively."
msgstr ""
"Você pode substituir esse método em uma subclasse. O método padrão :meth:"
"`run` invoca o objeto chamável passado ao construtor do objeto como o "
"argumento alvo, se houver, com argumentos nomeados e sequenciais retirados "
"dos argumentos *args* e *kwargs*, respectivamente."

#: ../../library/multiprocessing.rst:508
msgid "Start the process's activity."
msgstr "Inicia a atividade do processo."

#: ../../library/multiprocessing.rst:510
msgid ""
"This must be called at most once per process object.  It arranges for the "
"object's :meth:`run` method to be invoked in a separate process."
msgstr ""
"Isso deve ser chamado no máximo uma vez por objeto processo. Ele organiza "
"para que o método :meth:`run` do objeto seja invocado em um processo "
"separado."

#: ../../library/multiprocessing.rst:515
msgid ""
"If the optional argument *timeout* is ``None`` (the default), the method "
"blocks until the process whose :meth:`join` method is called terminates. If "
"*timeout* is a positive number, it blocks at most *timeout* seconds. Note "
"that the method returns ``None`` if its process terminates or if the method "
"times out.  Check the process's :attr:`exitcode` to determine if it "
"terminated."
msgstr ""
"Se o argumento opcional *timeout* for ``None`` (o padrão), o método bloqueia "
"até que o processo cujo método :meth:`join` é chamado termine. Se *timeout* "
"for um número positivo, ele bloqueia no máximo *timeout* segundos. Observe "
"que o método retorna ``None`` se seu processo terminar ou se o método tiver "
"tempo limite. Verifique o :attr:`exitcode` do processo para determinar se "
"ele terminou."

#: ../../library/multiprocessing.rst:522
msgid "A process can be joined many times."
msgstr "Um processo pode ser usar \"join\" muitas vezes."

#: ../../library/multiprocessing.rst:524
msgid ""
"A process cannot join itself because this would cause a deadlock.  It is an "
"error to attempt to join a process before it has been started."
msgstr ""
"Um processo não pode se unir porque isso causaria um impasse. É um erro "
"tentar se unir a um processo antes que ele tenha sido iniciado."

#: ../../library/multiprocessing.rst:529
msgid ""
"The process's name.  The name is a string used for identification purposes "
"only.  It has no semantics.  Multiple processes may be given the same name."
msgstr ""
"O nome do processo. O nome é uma string usada apenas para fins de "
"identificação. Não tem semântica. Vários processos podem receber o mesmo "
"nome."

#: ../../library/multiprocessing.rst:533
msgid ""
"The initial name is set by the constructor.  If no explicit name is provided "
"to the constructor, a name of the form 'Process-N\\ :sub:`1`:N\\ :sub:"
"`2`:...:N\\ :sub:`k`' is constructed, where each N\\ :sub:`k` is the N-th "
"child of its parent."
msgstr ""
"O nome inicial é definido pelo construtor. Se nenhum nome explícito for "
"fornecido ao construtor, um nome do formato 'Processo-N\\ :sub:`1`:N\\ :sub:"
"`2`:...:N\\ :sub:`k`' é construído, onde cada N\\ :sub:`k` é o N-ésimo filho "
"de seu pai."

#: ../../library/multiprocessing.rst:540
msgid "Return whether the process is alive."
msgstr "Retorna se o processo está ativo."

#: ../../library/multiprocessing.rst:542
msgid ""
"Roughly, a process object is alive from the moment the :meth:`start` method "
"returns until the child process terminates."
msgstr ""
"Em termos gerais, um objeto processo está ativo desde o momento em que o "
"método :meth:`start` retorna até o término do processo filho."

#: ../../library/multiprocessing.rst:547
msgid ""
"The process's daemon flag, a Boolean value.  This must be set before :meth:"
"`start` is called."
msgstr ""
"O sinalizador daemon do processo, um valor Booleano. Isso deve ser definido "
"antes de :meth:`start` ser chamado."

#: ../../library/multiprocessing.rst:550
msgid "The initial value is inherited from the creating process."
msgstr "O valor inicial é herdado do processo de criação."

#: ../../library/multiprocessing.rst:552
msgid ""
"When a process exits, it attempts to terminate all of its daemonic child "
"processes."
msgstr ""
"Quando um processo sai, ele tenta encerrar todos os seus processos filhos "
"daemônicos."

#: ../../library/multiprocessing.rst:555
msgid ""
"Note that a daemonic process is not allowed to create child processes. "
"Otherwise a daemonic process would leave its children orphaned if it gets "
"terminated when its parent process exits. Additionally, these are **not** "
"Unix daemons or services, they are normal processes that will be terminated "
"(and not joined) if non-daemonic processes have exited."
msgstr ""
"Note que um processo daemônico não tem permissão para criar processos "
"filhos. Caso contrário, um processo daemônico deixaria seus filhos órfãos se "
"ele fosse encerrado quando seu processo pai saísse. Além disso, esses "
"**não** são daemons ou serviços Unix, eles são processos normais que serão "
"encerrados (e em vez de usar \"join\") se processos não daemônicos tiverem "
"saído."

#: ../../library/multiprocessing.rst:561
msgid ""
"In addition to the  :class:`threading.Thread` API, :class:`Process` objects "
"also support the following attributes and methods:"
msgstr ""
"Além da API :class:`threading.Thread`, os objetos :class:`Process` também "
"oferecem suporte aos seguintes atributos e métodos:"

#: ../../library/multiprocessing.rst:566
msgid ""
"Return the process ID.  Before the process is spawned, this will be ``None``."
msgstr ""
"Retorna o ID do processo. Antes do processo ser gerado, este será ``None``."

#: ../../library/multiprocessing.rst:571
msgid ""
"The child's exit code.  This will be ``None`` if the process has not yet "
"terminated."
msgstr ""
"O código de saída da criança. Este será ``None`` se o processo ainda não "
"tiver terminado."

#: ../../library/multiprocessing.rst:574
msgid ""
"If the child's :meth:`run` method returned normally, the exit code will be "
"0.  If it terminated via :func:`sys.exit` with an integer argument *N*, the "
"exit code will be *N*."
msgstr ""
"Se o método :meth:`run` da criança retornar normalmente, o código de saída "
"será 0. Se ele terminar via :func:`sys.exit` com um argumento inteiro *N*, o "
"código de saída será *N*."

#: ../../library/multiprocessing.rst:578
msgid ""
"If the child terminated due to an exception not caught within :meth:`run`, "
"the exit code will be 1.  If it was terminated by signal *N*, the exit code "
"will be the negative value *-N*."
msgstr ""
"Se a criança for encerrada devido a uma exceção não capturada em :meth:"
"`run`, o código de saída será 1. Se ela for encerrada pelo sinal *N*, o "
"código de saída será o valor negativo *-N*."

#: ../../library/multiprocessing.rst:584
msgid "The process's authentication key (a byte string)."
msgstr "A chave de autenticação do processo (uma string de bytes)."

#: ../../library/multiprocessing.rst:586
msgid ""
"When :mod:`multiprocessing` is initialized the main process is assigned a "
"random string using :func:`os.urandom`."
msgstr ""
"Quando :mod:`multiprocessing` é inicializado, o processo principal recebe "
"uma string aleatória usando :func:`os.urandom`."

#: ../../library/multiprocessing.rst:589
msgid ""
"When a :class:`Process` object is created, it will inherit the "
"authentication key of its parent process, although this may be changed by "
"setting :attr:`authkey` to another byte string."
msgstr ""
"Quando um objeto :class:`Process` é criado, ele herda a chave de "
"autenticação do seu processo pai, embora isso possa ser alterado definindo :"
"attr:`authkey` para outra sequência de bytes."

#: ../../library/multiprocessing.rst:593
msgid "See :ref:`multiprocessing-auth-keys`."
msgstr "Veja :ref:`multiprocessing-auth-keys`."

#: ../../library/multiprocessing.rst:597
msgid ""
"A numeric handle of a system object which will become \"ready\" when the "
"process ends."
msgstr ""
"Um identificador numérico de um objeto do sistema que ficará \"pronto\" "
"quando o processo terminar."

#: ../../library/multiprocessing.rst:600
msgid ""
"You can use this value if you want to wait on several events at once using :"
"func:`multiprocessing.connection.wait`.  Otherwise calling :meth:`join()` is "
"simpler."
msgstr ""

#: ../../library/multiprocessing.rst:604
msgid ""
"On Windows, this is an OS handle usable with the ``WaitForSingleObject`` and "
"``WaitForMultipleObjects`` family of API calls.  On Unix, this is a file "
"descriptor usable with primitives from the :mod:`select` module."
msgstr ""

#: ../../library/multiprocessing.rst:612
msgid ""
"Terminate the process.  On Unix this is done using the ``SIGTERM`` signal; "
"on Windows :c:func:`TerminateProcess` is used.  Note that exit handlers and "
"finally clauses, etc., will not be executed."
msgstr ""

#: ../../library/multiprocessing.rst:616
msgid ""
"Note that descendant processes of the process will *not* be terminated -- "
"they will simply become orphaned."
msgstr ""
"Observe que os processos descendentes do processo *não* serão encerrados — "
"eles simplesmente ficarão órfãos."

#: ../../library/multiprocessing.rst:621
msgid ""
"If this method is used when the associated process is using a pipe or queue "
"then the pipe or queue is liable to become corrupted and may become unusable "
"by other process.  Similarly, if the process has acquired a lock or "
"semaphore etc. then terminating it is liable to cause other processes to "
"deadlock."
msgstr ""
"Se esse método for usado quando o processo associado estiver usando um "
"encadeamento ou fila, então o encadeamento ou fila é passível de ser "
"corrompido e pode se tornar inutilizável por outro processo. Similarmente, "
"se o processo adquiriu um trava ou semáforo etc., então encerrá-lo é "
"passível de causar impasse em outros processos."

#: ../../library/multiprocessing.rst:629
msgid "Same as :meth:`terminate()` but using the ``SIGKILL`` signal on Unix."
msgstr ""

#: ../../library/multiprocessing.rst:635
msgid ""
"Close the :class:`Process` object, releasing all resources associated with "
"it.  :exc:`ValueError` is raised if the underlying process is still "
"running.  Once :meth:`close` returns successfully, most other methods and "
"attributes of the :class:`Process` object will raise :exc:`ValueError`."
msgstr ""
"Fecha o objeto :class:`Process`, liberando todos os recursos associados a "
"ele. :exc:`ValueError` é levantado se o processo subjacente ainda estiver em "
"execução. Uma vez que :meth:`close` retorne com sucesso, a maioria dos "
"outros métodos e atributos do objeto :class:`Process` levantará :exc:"
"`ValueError`."

#: ../../library/multiprocessing.rst:643
msgid ""
"Note that the :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:"
"`terminate` and :attr:`exitcode` methods should only be called by the "
"process that created the process object."
msgstr ""
"Observe que os métodos :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:"
"`terminate` e :attr:`exitcode` devem ser chamados somente pelo processo que "
"criou o objeto processo."

#: ../../library/multiprocessing.rst:647
msgid "Example usage of some of the methods of :class:`Process`:"
msgstr "Exemplo de uso de alguns dos métodos de :class:`Process`:"

#: ../../library/multiprocessing.rst:668
msgid "The base class of all :mod:`multiprocessing` exceptions."
msgstr "A classe base de todas as exceções de :mod:`multiprocessing`."

#: ../../library/multiprocessing.rst:672
msgid ""
"Exception raised by :meth:`Connection.recv_bytes_into()` when the supplied "
"buffer object is too small for the message read."
msgstr ""

#: ../../library/multiprocessing.rst:675
msgid ""
"If ``e`` is an instance of :exc:`BufferTooShort` then ``e.args[0]`` will "
"give the message as a byte string."
msgstr ""
"Se ``e`` for uma instância de :exc:`BufferTooShort`, então ``e.args[0]`` "
"retornará a mensagem como uma string de bytes."

#: ../../library/multiprocessing.rst:680
msgid "Raised when there is an authentication error."
msgstr "Levantada quando há um erro de autenticação."

#: ../../library/multiprocessing.rst:684
msgid "Raised by methods with a timeout when the timeout expires."
msgstr ""
"Levantada por métodos com um tempo limite quando o tempo limite expira."

#: ../../library/multiprocessing.rst:687
msgid "Pipes and Queues"
msgstr "Encadeamentos e filas"

#: ../../library/multiprocessing.rst:689
msgid ""
"When using multiple processes, one generally uses message passing for "
"communication between processes and avoids having to use any synchronization "
"primitives like locks."
msgstr ""
"Ao usar vários processos, geralmente é usada a passagem de mensagens para "
"comunicação entre processos e evita-se ter que usar quaisquer primitivas de "
"sincronização, como travas."

#: ../../library/multiprocessing.rst:693
msgid ""
"For passing messages one can use :func:`Pipe` (for a connection between two "
"processes) or a queue (which allows multiple producers and consumers)."
msgstr ""
"Para passar mensagens, pode-se usar :func:`Pipe` (para uma conexão entre "
"dois processos) ou uma fila (que permite múltiplos produtores e "
"consumidores)."

#: ../../library/multiprocessing.rst:696
msgid ""
"The :class:`Queue`, :class:`SimpleQueue` and :class:`JoinableQueue` types "
"are multi-producer, multi-consumer :abbr:`FIFO (first-in, first-out)` queues "
"modelled on the :class:`queue.Queue` class in the standard library.  They "
"differ in that :class:`Queue` lacks the :meth:`~queue.Queue.task_done` and :"
"meth:`~queue.Queue.join` methods introduced into Python 2.5's :class:`queue."
"Queue` class."
msgstr ""
"Os tipos :class:`Queue`, :class:`SimpleQueue` e :class:`JoinableQueue` são "
"filas :abbr:`FIFO (first-in, first-out)` multiprodutoras e multiconsumidoras "
"modeladas na classe :class:`queue.Queue` da biblioteca padrão. Elas diferem "
"porque :class:`Queue` não tem os métodos :meth:`~queue.Queue.task_done` e :"
"meth:`~queue.Queue.join` introduzidos na classe :class:`queue.Queue` do "
"Python 2.5."

#: ../../library/multiprocessing.rst:703
msgid ""
"If you use :class:`JoinableQueue` then you **must** call :meth:"
"`JoinableQueue.task_done` for each task removed from the queue or else the "
"semaphore used to count the number of unfinished tasks may eventually "
"overflow, raising an exception."
msgstr ""
"Se você usar :class:`JoinableQueue`, então você **deve** chamar :meth:"
"`JoinableQueue.task_done` para cada tarefa removida da fila, caso contrário, "
"o semáforo usado para contar o número de tarefas não concluídas pode "
"eventualmente transbordar, levantando uma exceção."

#: ../../library/multiprocessing.rst:708
msgid ""
"Note that one can also create a shared queue by using a manager object -- "
"see :ref:`multiprocessing-managers`."
msgstr ""
"Observe que também é possível criar uma fila compartilhada usando um objeto "
"gerenciador — veja :ref:`multiprocessing-managers`."

#: ../../library/multiprocessing.rst:713
msgid ""
":mod:`multiprocessing` uses the usual :exc:`queue.Empty` and :exc:`queue."
"Full` exceptions to signal a timeout.  They are not available in the :mod:"
"`multiprocessing` namespace so you need to import them from :mod:`queue`."
msgstr ""
":mod:`multiprocessing` usa as exceções usuais :exc:`queue.Empty` e :exc:"
"`queue.Full` para sinalizar um tempo limite. Elas não estão disponíveis no "
"espaço de nomes do :mod:`multiprocessing`, então você precisa importá-las "
"de :mod:`queue`."

#: ../../library/multiprocessing.rst:720
msgid ""
"When an object is put on a queue, the object is pickled and a background "
"thread later flushes the pickled data to an underlying pipe.  This has some "
"consequences which are a little surprising, but should not cause any "
"practical difficulties -- if they really bother you then you can instead use "
"a queue created with a :ref:`manager <multiprocessing-managers>`."
msgstr ""
"Quando um objeto é colocado em uma fila, o objeto é serializado com pickle e "
"uma thread em segundo plano depois descarrega os dados serializados com "
"pickle para um encadeamento subjacente. Isso tem algumas consequências que "
"são um pouco surpreendentes, mas não devem causar nenhuma dificuldade "
"prática -- se elas realmente o incomodam, então você pode usar uma fila "
"criada com um :ref:`gerenciador <multiprocessing-managers>`."

#: ../../library/multiprocessing.rst:727
msgid ""
"After putting an object on an empty queue there may be an infinitesimal "
"delay before the queue's :meth:`~Queue.empty` method returns :const:`False` "
"and :meth:`~Queue.get_nowait` can return without raising :exc:`queue.Empty`."
msgstr ""
"Depois de colocar um objeto em uma fila vazia, pode haver um atraso "
"infinitesimal antes que o método :meth:`~Queue.empty` da fila retorne :const:"
"`False` e :meth:`~Queue.get_nowait` possa retornar sem levantar :exc:`queue."
"Empty`."

#: ../../library/multiprocessing.rst:732
msgid ""
"If multiple processes are enqueuing objects, it is possible for the objects "
"to be received at the other end out-of-order. However, objects enqueued by "
"the same process will always be in the expected order with respect to each "
"other."
msgstr ""
"Se vários processos estiverem enfileirando objetos, é possível que os "
"objetos sejam recebidos na outra extremidade fora de ordem. No entanto, "
"objetos enfileirados pelo mesmo processo sempre estarão na ordem esperada em "
"relação uns aos outros."

#: ../../library/multiprocessing.rst:739
msgid ""
"If a process is killed using :meth:`Process.terminate` or :func:`os.kill` "
"while it is trying to use a :class:`Queue`, then the data in the queue is "
"likely to become corrupted.  This may cause any other process to get an "
"exception when it tries to use the queue later on."
msgstr ""
"Se um processo for morto usando :meth:`Process.terminate` ou :func:`os.kill` "
"enquanto estiver tentando usar uma :class:`Queue`, os dados na fila "
"provavelmente serão corrompidos. Isso pode fazer com que qualquer outro "
"processo obtenha uma exceção quando tentar usar a fila mais tarde."

#: ../../library/multiprocessing.rst:746
msgid ""
"As mentioned above, if a child process has put items on a queue (and it has "
"not used :meth:`JoinableQueue.cancel_join_thread <multiprocessing.Queue."
"cancel_join_thread>`), then that process will not terminate until all "
"buffered items have been flushed to the pipe."
msgstr ""
"Conforme mencionado acima, se um processo filho tiver colocado itens em uma "
"fila (e não tiver usado :meth:`JoinableQueue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>`), esse processo não será "
"encerrado até que todos os itens armazenados em buffer tenham sido liberados "
"para o encadeamento."

#: ../../library/multiprocessing.rst:751
msgid ""
"This means that if you try joining that process you may get a deadlock "
"unless you are sure that all items which have been put on the queue have "
"been consumed.  Similarly, if the child process is non-daemonic then the "
"parent process may hang on exit when it tries to join all its non-daemonic "
"children."
msgstr ""
"Isso significa que se você tentar juntar esse processo, poderá obter um "
"impasse, a menos que tenha certeza de que todos os itens que foram colocados "
"na fila foram consumidos. Da mesma forma, se o processo filho não for "
"daemônico, o processo pai pode travar na saída quando tentar juntar todos os "
"seus filhos não daemônicos."

#: ../../library/multiprocessing.rst:756
msgid ""
"Note that a queue created using a manager does not have this issue.  See :"
"ref:`multiprocessing-programming`."
msgstr ""
"Note que uma fila criada usando um gerenciador não tem esse problema. Veja :"
"ref:`multiprocessing-programming`."

#: ../../library/multiprocessing.rst:759
msgid ""
"For an example of the usage of queues for interprocess communication see :"
"ref:`multiprocessing-examples`."
msgstr ""
"Para um exemplo do uso de filas para comunicação entre processos, veja :ref:"
"`multiprocessing-examples`."

#: ../../library/multiprocessing.rst:765
msgid ""
"Returns a pair ``(conn1, conn2)`` of :class:`~multiprocessing.connection."
"Connection` objects representing the ends of a pipe."
msgstr ""
"Retorna um par ``(conn1, conn2)`` de objetos :class:`~multiprocessing."
"connection.Connection` representando as extremidades de um encadeamento."

#: ../../library/multiprocessing.rst:769
msgid ""
"If *duplex* is ``True`` (the default) then the pipe is bidirectional.  If "
"*duplex* is ``False`` then the pipe is unidirectional: ``conn1`` can only be "
"used for receiving messages and ``conn2`` can only be used for sending "
"messages."
msgstr ""
"Se *duplex* for ``True`` (o padrão), então o encadeamento é bidirecional. Se "
"*duplex* for ``False``, então o encadeamento é unidirecional: ``conn1`` pode "
"ser usado somente para receber mensagens e ``conn2`` pode ser usado somente "
"para enviar mensagens."

#: ../../library/multiprocessing.rst:777
msgid ""
"Returns a process shared queue implemented using a pipe and a few locks/"
"semaphores.  When a process first puts an item on the queue a feeder thread "
"is started which transfers objects from a buffer into the pipe."
msgstr ""
"Retorna uma fila compartilhada de processo implementada usando um "
"encadeamento e algumas travas/semáforos. Quando um processo coloca um item "
"na fila pela primeira vez, uma thread alimentadora é iniciada, a qual "
"transfere objetos de um buffer para o encadeamento."

#: ../../library/multiprocessing.rst:781
msgid ""
"The usual :exc:`queue.Empty` and :exc:`queue.Full` exceptions from the "
"standard library's :mod:`queue` module are raised to signal timeouts."
msgstr ""
"As exceções usuais :exc:`queue.Empty` e :exc:`queue.Full` do módulo :mod:"
"`queue` da biblioteca padrão são levantadas para sinalizar tempos limite."

#: ../../library/multiprocessing.rst:784
msgid ""
":class:`Queue` implements all the methods of :class:`queue.Queue` except "
"for :meth:`~queue.Queue.task_done` and :meth:`~queue.Queue.join`."
msgstr ""
":class:`Queue` implementa todos os métodos de :class:`queue.Queue`, exceto :"
"meth:`~queue.Queue.task_done` e :meth:`~queue.Queue.join`."

#: ../../library/multiprocessing.rst:789
msgid ""
"Return the approximate size of the queue.  Because of multithreading/"
"multiprocessing semantics, this number is not reliable."
msgstr ""
"Retorna o tamanho aproximado da fila. Devido à semântica de multithreading/"
"multiprocessamento, esse número não é confiável."

#: ../../library/multiprocessing.rst:792
msgid ""
"Note that this may raise :exc:`NotImplementedError` on Unix platforms like "
"macOS where ``sem_getvalue()`` is not implemented."
msgstr ""

#: ../../library/multiprocessing.rst:797
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"Retorna ``True`` se a fila estiver vazia, ``False`` caso contrário. Devido à "
"semântica de multithreading/multiprocessamento, isso não é confiável."

#: ../../library/multiprocessing.rst:802
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"Retorna ``True`` se a fila estiver cheia, ``False`` caso contrário. Devido à "
"semântica de multithreading/multiprocessamento, isso não é confiável."

#: ../../library/multiprocessing.rst:807
msgid ""
"Put obj into the queue.  If the optional argument *block* is ``True`` (the "
"default) and *timeout* is ``None`` (the default), block if necessary until a "
"free slot is available.  If *timeout* is a positive number, it blocks at "
"most *timeout* seconds and raises the :exc:`queue.Full` exception if no free "
"slot was available within that time.  Otherwise (*block* is ``False``), put "
"an item on the queue if a free slot is immediately available, else raise "
"the :exc:`queue.Full` exception (*timeout* is ignored in that case)."
msgstr ""
"Coloca *obj* na fila. Se o argumento opcional *block* for ``True`` (o "
"padrão) e *timeout* for ``None`` (o padrão), bloqueia se necessário até que "
"um slot livre esteja disponível. Se *timeout* for um número positivo, ele "
"bloqueia no máximo *timeout* segundos e levanta a exceção :exc:`queue.Full` "
"se nenhum slot livre estiver disponível dentro desse tempo. Caso contrário "
"(*block* é ``False``), coloca um item na fila se um slot livre estiver "
"imediatamente disponível, senão levanta a exceção :exc:`queue.Full` "
"(*timeout* é ignorado nesse caso)."

#: ../../library/multiprocessing.rst:816
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr ""
"Se a fila for fechada, :exc:`ValueError` será levantada em vez de :exc:"
"`AssertionError`."

#: ../../library/multiprocessing.rst:822
msgid "Equivalent to ``put(obj, False)``."
msgstr "Equivalente  a ``put(obj, False)``."

#: ../../library/multiprocessing.rst:826
msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"``True`` (the default) and *timeout* is ``None`` (the default), block if "
"necessary until an item is available.  If *timeout* is a positive number, it "
"blocks at most *timeout* seconds and raises the :exc:`queue.Empty` exception "
"if no item was available within that time.  Otherwise (block is ``False``), "
"return an item if one is immediately available, else raise the :exc:`queue."
"Empty` exception (*timeout* is ignored in that case)."
msgstr ""
"Remove e retorna um item da fila. Se os argumentos opcionais *block* forem "
"``True`` (o padrão) e *timeout* forem ``None`` (o padrão), bloqueia se "
"necessário até que um item esteja disponível. Se *timeout* for um número "
"positivo, ele bloqueia no máximo *timeout* segundos e levantada a exceção :"
"exc:`queue.Empty` se nenhum item estiver disponível dentro desse tempo. Caso "
"contrário (block for ``False``), retorna um item se um estiver imediatamente "
"disponível, senão levantada a exceção :exc:`queue.Empty` (*timeout* é "
"ignorado nesse caso)."

#: ../../library/multiprocessing.rst:834
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`OSError`."
msgstr ""
"Se a fila for fechada, :exc:`ValueError` será levantada em vez de :exc:"
"`OSError`."

#: ../../library/multiprocessing.rst:840
msgid "Equivalent to ``get(False)``."
msgstr "Equivalente a ``get(False)``."

#: ../../library/multiprocessing.rst:842
msgid ""
":class:`multiprocessing.Queue` has a few additional methods not found in :"
"class:`queue.Queue`.  These methods are usually unnecessary for most code:"
msgstr ""
":class:`multiprocessing.Queue` tem alguns métodos adicionais não encontrados "
"em :class:`queue.Queue`. Esses métodos geralmente são desnecessários para a "
"maioria dos códigos:"

#: ../../library/multiprocessing.rst:848
msgid ""
"Indicate that no more data will be put on this queue by the current "
"process.  The background thread will quit once it has flushed all buffered "
"data to the pipe.  This is called automatically when the queue is garbage "
"collected."
msgstr ""
"Indica que nenhum dado adicional será colocado nesta fila pelo processo "
"atual. O thread em segundo plano será encerrado assim que tiver descarregado "
"todos os dados armazenados em buffer para o encadeamento. Isso é chamado "
"automaticamente quando a fila é coletada como lixo."

#: ../../library/multiprocessing.rst:855
msgid ""
"Join the background thread.  This can only be used after :meth:`close` has "
"been called.  It blocks until the background thread exits, ensuring that all "
"data in the buffer has been flushed to the pipe."
msgstr ""
"Junta a thread de segundo plano. Isso só pode ser usado depois que :meth:"
"`close` for chamado. Isso bloqueia até que a thread de segundo plano saia, "
"garantindo que todos os dados no buffer tenham sido liberados para o "
"encadeamento."

#: ../../library/multiprocessing.rst:859
msgid ""
"By default if a process is not the creator of the queue then on exit it will "
"attempt to join the queue's background thread.  The process can call :meth:"
"`cancel_join_thread` to make :meth:`join_thread` do nothing."
msgstr ""
"Por padrão, se um processo não for o criador da fila, ao sair, ele tentará "
"se juntar ao thread de segundo plano da fila. O processo pode chamar :meth:"
"`cancel_join_thread` para fazer :meth:`join_thread` não fazer nada."

#: ../../library/multiprocessing.rst:865
msgid ""
"Prevent :meth:`join_thread` from blocking.  In particular, this prevents the "
"background thread from being joined automatically when the process exits -- "
"see :meth:`join_thread`."
msgstr ""
"Impede que :meth:`join_thread` bloqueie. Em particular, isso impede que o "
"thread de segundo plano seja unido automaticamente quando o processo sai -- "
"veja :meth:`join_thread`."

#: ../../library/multiprocessing.rst:869
msgid ""
"A better name for this method might be ``allow_exit_without_flush()``.  It "
"is likely to cause enqueued data to lost, and you almost certainly will not "
"need to use it. It is really only there if you need the current process to "
"exit immediately without waiting to flush enqueued data to the underlying "
"pipe, and you don't care about lost data."
msgstr ""

#: ../../library/multiprocessing.rst:878
msgid ""
"This class's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the functionality "
"in this class will be disabled, and attempts to instantiate a :class:`Queue` "
"will result in an :exc:`ImportError`. See :issue:`3770` for additional "
"information.  The same holds true for any of the specialized queue types "
"listed below."
msgstr ""
"A funcionalidade desta classe requer uma implementação de semáforo "
"compartilhado funcional no sistema operacional host. Sem uma, a "
"funcionalidade nesta classe será desabilitada, e as tentativas de instanciar "
"uma :class:`Queue` resultarão em um :exc:`ImportError`. Veja :issue:`3770` "
"para informações adicionais. O mesmo vale para qualquer um dos tipos de fila "
"especializados listados abaixo."

#: ../../library/multiprocessing.rst:887
msgid ""
"It is a simplified :class:`Queue` type, very close to a locked :class:`Pipe`."
msgstr ""
"É um tipo :class:`Queue` simplificado, muito próximo de um :class:`Pipe` "
"travado."

#: ../../library/multiprocessing.rst:891
msgid "Close the queue: release internal resources."
msgstr "Fecha a fila: libera recursos internos."

#: ../../library/multiprocessing.rst:893
msgid ""
"A queue must not be used anymore after it is closed. For example, :meth:"
"`get`, :meth:`put` and :meth:`empty` methods must no longer be called."
msgstr ""
"Uma fila não deve mais ser usada depois de fechada. Por exemplo, os métodos :"
"meth:`get`, :meth:`put` e :meth:`empty` não devem mais ser chamados."

#: ../../library/multiprocessing.rst:901
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "Retorna ``True`` se a fila estiver vazia, ``False`` caso contrário."

#: ../../library/multiprocessing.rst:905
msgid "Remove and return an item from the queue."
msgstr "Remove e retorna um item da fila."

#: ../../library/multiprocessing.rst:909
msgid "Put *item* into the queue."
msgstr "Coloca *item* na fila."

#: ../../library/multiprocessing.rst:914
msgid ""
":class:`JoinableQueue`, a :class:`Queue` subclass, is a queue which "
"additionally has :meth:`task_done` and :meth:`join` methods."
msgstr ""
":class:`JoinableQueue`, uma subclasse de :class:`Queue`, é uma fila que "
"também possui os métodos :meth:`task_done` e :meth:`join`."

#: ../../library/multiprocessing.rst:919
msgid ""
"Indicate that a formerly enqueued task is complete. Used by queue "
"consumers.  For each :meth:`~Queue.get` used to fetch a task, a subsequent "
"call to :meth:`task_done` tells the queue that the processing on the task is "
"complete."
msgstr ""
"Indica que a tarefa anteriormente enfileirado está concluída. Para cada :"
"meth:`~Queue.get` usado para buscar uma tarefa, uma chamada subsequente "
"para :meth:`task_done` avisa à fila, que o processamento na tarefa está "
"concluído."

#: ../../library/multiprocessing.rst:924
msgid ""
"If a :meth:`~queue.Queue.join` is currently blocking, it will resume when "
"all items have been processed (meaning that a :meth:`task_done` call was "
"received for every item that had been :meth:`~Queue.put` into the queue)."
msgstr ""
"Se um :meth:`~queue.Queue.join` estiver causando bloqueio no momento, ele "
"irá continuar quando todos os itens tiverem sido processados (significando "
"que uma chamada :meth:`task_done` foi recebida para cada item que foi "
"chamado o método :meth:`~Queue.put` para colocar na fila)."

#: ../../library/multiprocessing.rst:928
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Levanta :exc:`ValueError` se for chamado mais vezes do que o número de itens "
"colocados na fila."

#: ../../library/multiprocessing.rst:934
msgid "Block until all items in the queue have been gotten and processed."
msgstr ""
"Bloqueia até que todos os itens na fila tenham sido obtidos e processados."

#: ../../library/multiprocessing.rst:936
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue.  The count goes down whenever a consumer calls :meth:`task_done` to "
"indicate that the item was retrieved and all work on it is complete.  When "
"the count of unfinished tasks drops to zero, :meth:`~queue.Queue.join` "
"unblocks."
msgstr ""
"A contagem de tarefas inacabadas aumenta sempre que um item é adicionado à "
"fila. A contagem diminui sempre que uma consumidora chama :meth:`task_done` "
"para indicar que o item foi recuperado e todo o trabalho nele foi concluído. "
"Quando a contagem de tarefas inacabadas chega a zero, :meth:`~queue.Queue."
"join` desbloqueia."

#: ../../library/multiprocessing.rst:944
msgid "Miscellaneous"
msgstr "Diversos"

#: ../../library/multiprocessing.rst:948
msgid "Return list of all live children of the current process."
msgstr "Retorna a lista de todos os filhos ativos do processo atual."

#: ../../library/multiprocessing.rst:950
msgid ""
"Calling this has the side effect of \"joining\" any processes which have "
"already finished."
msgstr ""
"Chamar isso tem o efeito colateral de \"juntar\" quaisquer processos que já "
"tenham sido concluídos."

#: ../../library/multiprocessing.rst:955
msgid "Return the number of CPUs in the system."
msgstr "Retorna o número de CPUs no sistema."

#: ../../library/multiprocessing.rst:957
msgid ""
"This number is not equivalent to the number of CPUs the current process can "
"use.  The number of usable CPUs can be obtained with ``len(os."
"sched_getaffinity(0))``"
msgstr ""
"Este número não é equivalente ao número de CPUs que o processo atual pode "
"usar. O número de CPUs utilizáveis ​​pode ser obtido com ``len(os."
"sched_getaffinity(0))``"

#: ../../library/multiprocessing.rst:961
msgid ""
"When the number of CPUs cannot be determined a :exc:`NotImplementedError` is "
"raised."
msgstr ""
"Quando o número de CPUs não pode ser determinado, uma :exc:"
"`NotImplementedError` é levantada."

#: ../../library/multiprocessing.rst:965
msgid ":func:`os.cpu_count`"
msgstr ":func:`os.cpu_count`"

#: ../../library/multiprocessing.rst:969
msgid ""
"Return the :class:`Process` object corresponding to the current process."
msgstr "Retorna o objeto :class:`Process` correspondente ao processo atual."

#: ../../library/multiprocessing.rst:971
msgid "An analogue of :func:`threading.current_thread`."
msgstr "Um análogo de :func:`threading.current_thread`."

#: ../../library/multiprocessing.rst:975
msgid ""
"Return the :class:`Process` object corresponding to the parent process of "
"the :func:`current_process`. For the main process, ``parent_process`` will "
"be ``None``."
msgstr ""
"Retorna o objeto :class:`Process` correspondente ao processo pai do :func:"
"`current_process`. Para o processo principal, ``parent_process`` será "
"``None``."

#: ../../library/multiprocessing.rst:983
msgid ""
"Add support for when a program which uses :mod:`multiprocessing` has been "
"frozen to produce a Windows executable.  (Has been tested with **py2exe**, "
"**PyInstaller** and **cx_Freeze**.)"
msgstr ""
"Adiciona suporte para quando um programa que usa :mod:`multiprocessing` for "
"congelado para produzir um executável do Windows. (Foi testado com "
"**py2exe**, **PyInstaller** e **cx_Freeze**.)"

#: ../../library/multiprocessing.rst:987
msgid ""
"One needs to call this function straight after the ``if __name__ == "
"'__main__'`` line of the main module.  For example::"
msgstr ""
"É preciso chamar esta função logo após a linha ``if __name__ == '__main__'`` "
"do módulo principal. Por exemplo::"

#: ../../library/multiprocessing.rst:999
msgid ""
"If the ``freeze_support()`` line is omitted then trying to run the frozen "
"executable will raise :exc:`RuntimeError`."
msgstr ""
"Se a linha ``freeze_support()`` for omitida, tentar executar o executável "
"congelado levantará :exc:`RuntimeError`."

#: ../../library/multiprocessing.rst:1002
msgid ""
"Calling ``freeze_support()`` has no effect when invoked on any operating "
"system other than Windows.  In addition, if the module is being run normally "
"by the Python interpreter on Windows (the program has not been frozen), then "
"``freeze_support()`` has no effect."
msgstr ""
"Chamar ``freeze_support()`` não tem efeito quando invocado em qualquer "
"sistema operacional que não seja o Windows. Além disso, se o módulo estiver "
"sendo executado normalmente pelo interpretador Python no Windows (o programa "
"não foi congelado), então ``freeze_support()`` não tem efeito."

#: ../../library/multiprocessing.rst:1009
msgid ""
"Returns a list of the supported start methods, the first of which is the "
"default.  The possible start methods are ``'fork'``, ``'spawn'`` and "
"``'forkserver'``.  On Windows only ``'spawn'`` is available.  On Unix "
"``'fork'`` and ``'spawn'`` are always supported, with ``'fork'`` being the "
"default."
msgstr ""

#: ../../library/multiprocessing.rst:1019
msgid ""
"Return a context object which has the same attributes as the :mod:"
"`multiprocessing` module."
msgstr ""
"Retorna um objeto de contexto que possui os mesmos atributos do módulo :mod:"
"`multiprocessing`."

#: ../../library/multiprocessing.rst:1022
msgid ""
"If *method* is ``None`` then the default context is returned. Otherwise "
"*method* should be ``'fork'``, ``'spawn'``, ``'forkserver'``.  :exc:"
"`ValueError` is raised if the specified start method is not available."
msgstr ""

#: ../../library/multiprocessing.rst:1031
msgid "Return the name of start method used for starting processes."
msgstr "Retorna o nome do método de início usado para iniciar processos."

#: ../../library/multiprocessing.rst:1033
msgid ""
"If the start method has not been fixed and *allow_none* is false, then the "
"start method is fixed to the default and the name is returned.  If the start "
"method has not been fixed and *allow_none* is true then ``None`` is returned."
msgstr ""
"Se o método de início não tiver sido corrigido e *allow_none* for falso, "
"então o método de início será corrigido para o padrão e o nome será "
"retornado. Se o método de início não tiver sido corrigido e *allow_none* for "
"verdadeiro, então ``None`` será retornado."

#: ../../library/multiprocessing.rst:1038
msgid ""
"The return value can be ``'fork'``, ``'spawn'``, ``'forkserver'`` or "
"``None``.  ``'fork'`` is the default on Unix, while ``'spawn'`` is the "
"default on Windows and macOS."
msgstr ""

#: ../../library/multiprocessing.rst:1052
msgid ""
"Set the path of the Python interpreter to use when starting a child process. "
"(By default :data:`sys.executable` is used).  Embedders will probably need "
"to do some thing like ::"
msgstr ""
"Define o caminho do interpretador Python a ser usado ao iniciar um processo "
"filho. (Por padrão, :data:`sys.executable` é usado). Os incorporadores "
"provavelmente precisarão fazer algo como ::"

#: ../../library/multiprocessing.rst:1058
msgid "before they can create child processes."
msgstr "antes que eles possam criar processos filho."

#: ../../library/multiprocessing.rst:1060
msgid "Now supported on Unix when the ``'spawn'`` start method is used."
msgstr ""

#: ../../library/multiprocessing.rst:1065
msgid ""
"Set the method which should be used to start child processes. *method* can "
"be ``'fork'``, ``'spawn'`` or ``'forkserver'``."
msgstr ""

#: ../../library/multiprocessing.rst:1068
msgid ""
"Note that this should be called at most once, and it should be protected "
"inside the ``if __name__ == '__main__'`` clause of the main module."
msgstr ""
"Observe que isso deve ser chamado no máximo uma vez e deve ser protegido "
"dentro da cláusula ``if __name__ == '__main__'`` do módulo principal."

#: ../../library/multiprocessing.rst:1076
msgid ""
":mod:`multiprocessing` contains no analogues of :func:`threading."
"active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :"
"func:`threading.setprofile`, :class:`threading.Timer`, or :class:`threading."
"local`."
msgstr ""
":mod:`multiprocessing` contém nenhum análogo de :func:`threading."
"active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :"
"func:`threading.setprofile`, :class:`threading.Timer` ou :class:`threading."
"local`."

#: ../../library/multiprocessing.rst:1083
msgid "Connection Objects"
msgstr "Objetos de conexão"

#: ../../library/multiprocessing.rst:1087
msgid ""
"Connection objects allow the sending and receiving of picklable objects or "
"strings.  They can be thought of as message oriented connected sockets."
msgstr ""
"Objetos de conexão permitem o envio e recebimento de strings e objetos que "
"podem ser serializados com pickle. Eles podem ser pensados como sockets "
"conectados orientados a mensagens."

#: ../../library/multiprocessing.rst:1090
msgid ""
"Connection objects are usually created using :func:`Pipe <multiprocessing."
"Pipe>` -- see also :ref:`multiprocessing-listeners-clients`."
msgstr ""
"Objetos de conexão geralmente são criados usando :func:`Pipe "
"<multiprocessing.Pipe>` -- veja também :ref:`multiprocessing-listeners-"
"clients`."

#: ../../library/multiprocessing.rst:1098
msgid ""
"Send an object to the other end of the connection which should be read "
"using :meth:`recv`."
msgstr ""
"Envia um objeto para a outra extremidade da conexão que deve ser lido "
"usando :meth:`recv`."

#: ../../library/multiprocessing.rst:1101
msgid ""
"The object must be picklable.  Very large pickles (approximately 32 MiB+, "
"though it depends on the OS) may raise a :exc:`ValueError` exception."
msgstr ""
"O objeto deve poder ser serializado com pickle. Serializações muito grandes "
"com pickles (aproximadamente 32 MiB+, embora isso dependa do sistema "
"operacional) podem levantar uma exceção :exc:`ValueError`."

#: ../../library/multiprocessing.rst:1106
msgid ""
"Return an object sent from the other end of the connection using :meth:"
"`send`.  Blocks until there is something to receive.  Raises :exc:`EOFError` "
"if there is nothing left to receive and the other end was closed."
msgstr ""
"Retorna um objeto enviado a partir da outra extremidade da conexão usando :"
"meth:`send`. Bloqueia até que haja algo para receber. Levanta :exc:"
"`EOFError` se não houver mais nada para receber e a outra extremidade tenha "
"sido fechada."

#: ../../library/multiprocessing.rst:1113
msgid "Return the file descriptor or handle used by the connection."
msgstr "Retorna o descritor de arquivo ou identificador usado pela conexão."

#: ../../library/multiprocessing.rst:1117
msgid "Close the connection."
msgstr "Fecha a conexão."

#: ../../library/multiprocessing.rst:1119
msgid "This is called automatically when the connection is garbage collected."
msgstr "Isso é chamado automaticamente quando a conexão é coletada como lixo."

#: ../../library/multiprocessing.rst:1123
msgid "Return whether there is any data available to be read."
msgstr "Retorna se há algum dado disponível para leitura."

#: ../../library/multiprocessing.rst:1125
msgid ""
"If *timeout* is not specified then it will return immediately.  If *timeout* "
"is a number then this specifies the maximum time in seconds to block.  If "
"*timeout* is ``None`` then an infinite timeout is used."
msgstr ""
"Se *timeout* não for especificado, ele retornará imediatamente. Se *timeout* "
"for um número, isso especificará o tempo máximo em segundos para bloquear. "
"Se *timeout* for ``None``, um tempo limite infinito será usado."

#: ../../library/multiprocessing.rst:1129
msgid ""
"Note that multiple connection objects may be polled at once by using :func:"
"`multiprocessing.connection.wait`."
msgstr ""
"Observe que vários objetos de conexão podem ser pesquisados ao mesmo tempo "
"usando :func:`multiprocessing.connection.wait`."

#: ../../library/multiprocessing.rst:1134
msgid "Send byte data from a :term:`bytes-like object` as a complete message."
msgstr ""
"Enviar dados de bytes de um :term:`objeto byte ou similar` como uma mensagem "
"completa."

#: ../../library/multiprocessing.rst:1136
msgid ""
"If *offset* is given then data is read from that position in *buffer*.  If "
"*size* is given then that many bytes will be read from buffer.  Very large "
"buffers (approximately 32 MiB+, though it depends on the OS) may raise a :"
"exc:`ValueError` exception"
msgstr ""
"Se *offset* for fornecido, os dados serão lidos daquela posição em *buffer*. "
"Se *size* for fornecido, essa quantidade de bytes será lida do buffer. "
"Buffers muito grandes (aproximadamente 32 MiB+, embora isso dependa do "
"sistema operacional) podem levantar uma exceção :exc:`ValueError`"

#: ../../library/multiprocessing.rst:1143
msgid ""
"Return a complete message of byte data sent from the other end of the "
"connection as a string.  Blocks until there is something to receive. Raises :"
"exc:`EOFError` if there is nothing left to receive and the other end has "
"closed."
msgstr ""
"Retorna uma mensagem completa de dados como bytes enviados a partir da outra "
"extremidade da conexão como uma string. Bloqueia até que haja algo para "
"receber. Levanta :exc:`EOFError` se não houver mais nada para receber e a "
"outra extremidade tenha sido fechada."

#: ../../library/multiprocessing.rst:1148
msgid ""
"If *maxlength* is specified and the message is longer than *maxlength* then :"
"exc:`OSError` is raised and the connection will no longer be readable."
msgstr ""
"Se *maxlength* for especificado e a mensagem for maior que *maxlength*, :exc:"
"`OSError` será levantada e a conexão não será mais legível."

#: ../../library/multiprocessing.rst:1152
msgid ""
"This function used to raise :exc:`IOError`, which is now an alias of :exc:"
"`OSError`."
msgstr ""
"Esta função costumava levantada :exc:`IOError`, que agora é um apelido de :"
"exc:`OSError`."

#: ../../library/multiprocessing.rst:1159
msgid ""
"Read into *buffer* a complete message of byte data sent from the other end "
"of the connection and return the number of bytes in the message.  Blocks "
"until there is something to receive.  Raises :exc:`EOFError` if there is "
"nothing left to receive and the other end was closed."
msgstr ""
"Lê para *buffer* uma mensagem completa de dados como bytes enviados a partir "
"da outra extremidade da conexão e retorna o número de bytes na mensagem. "
"Bloqueia até que haja algo para receber. Levanta :exc:`EOFError` se não "
"houver mais nada para receber e a outra extremidade tenha sido fechada."

#: ../../library/multiprocessing.rst:1165
msgid ""
"*buffer* must be a writable :term:`bytes-like object`.  If *offset* is given "
"then the message will be written into the buffer from that position.  Offset "
"must be a non-negative integer less than the length of *buffer* (in bytes)."
msgstr ""
"*buffer* deve ser um :term:`objeto byte ou similar` gravável. Se *offset* "
"for fornecido, a mensagem será escrita no buffer a partir dessa posição. A "
"posição deve ser um inteiro não negativo menor que o comprimento de *buffer* "
"(em bytes)."

#: ../../library/multiprocessing.rst:1170
msgid ""
"If the buffer is too short then a :exc:`BufferTooShort` exception is raised "
"and the complete message is available as ``e.args[0]`` where ``e`` is the "
"exception instance."
msgstr ""
"Se o buffer for muito curto, uma exceção :exc:`BufferTooShort` será "
"levantada e a mensagem completa estará disponível como ``e.args[0]``, onde "
"``e`` é a instância da exceção."

#: ../../library/multiprocessing.rst:1174
msgid ""
"Connection objects themselves can now be transferred between processes "
"using :meth:`Connection.send` and :meth:`Connection.recv`."
msgstr ""
"Os próprios objetos de conexão agora podem ser transferidos entre processos "
"usando :meth:`Connection.send` e :meth:`Connection.recv`."

#: ../../library/multiprocessing.rst:1178
msgid ""
"Connection objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"connection object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""

#: ../../library/multiprocessing.rst:1183
msgid "For example:"
msgstr "Por exemplo:"

#: ../../library/multiprocessing.rst:1208
msgid ""
"The :meth:`Connection.recv` method automatically unpickles the data it "
"receives, which can be a security risk unless you can trust the process "
"which sent the message."
msgstr ""
"O método :meth:`Connection.recv` deserializa com picke automaticamente os "
"dados recebidos, o que pode ser um risco à segurança, a menos que você possa "
"confiar no processo que enviou a mensagem."

#: ../../library/multiprocessing.rst:1212
msgid ""
"Therefore, unless the connection object was produced using :func:`Pipe` you "
"should only use the :meth:`~Connection.recv` and :meth:`~Connection.send` "
"methods after performing some sort of authentication.  See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""
"Portanto, a menos que o objeto de conexão tenha sido produzido usando :func:"
"`Pipe`, você deve usar apenas os métodos :meth:`~Connection.recv` e :meth:"
"`~Connection.send` após executar algum tipo de autenticação. Veja :ref:"
"`multiprocessing-auth-keys`."

#: ../../library/multiprocessing.rst:1219
msgid ""
"If a process is killed while it is trying to read or write to a pipe then "
"the data in the pipe is likely to become corrupted, because it may become "
"impossible to be sure where the message boundaries lie."
msgstr ""
"Se um processo for encerrado enquanto estiver tentando ler ou escrever em um "
"encadeamento, os dados no encadeameto provavelmente serão corrompidos, "
"porque pode se tornar impossível ter certeza de onde estão os limites do "
"encadeamento da mensagem."

#: ../../library/multiprocessing.rst:1225
msgid "Synchronization primitives"
msgstr "Primitivas de sincronização"

#: ../../library/multiprocessing.rst:1229
msgid ""
"Generally synchronization primitives are not as necessary in a multiprocess "
"program as they are in a multithreaded program.  See the documentation for :"
"mod:`threading` module."
msgstr ""
"Geralmente, primitivas de sincronização não são tão necessárias em um "
"programa multiprocesso quanto em um programa multithread. Veja a "
"documentação do módulo :mod:`threading`."

#: ../../library/multiprocessing.rst:1233
msgid ""
"Note that one can also create synchronization primitives by using a manager "
"object -- see :ref:`multiprocessing-managers`."
msgstr ""
"Observe que também é possível criar primitivas de sincronização usando um "
"objeto gerenciador — veja :ref:`multiprocessing-managers`."

#: ../../library/multiprocessing.rst:1238
msgid "A barrier object: a clone of :class:`threading.Barrier`."
msgstr "Um objeto de barreira: um clone de :class:`threading.Barrier`."

#: ../../library/multiprocessing.rst:1244
msgid ""
"A bounded semaphore object: a close analog of :class:`threading."
"BoundedSemaphore`."
msgstr ""
"Um objeto semáforo delimitado: um análogo próximo de :class:`threading."
"BoundedSemaphore`."

#: ../../library/multiprocessing.rst:1247
#: ../../library/multiprocessing.rst:1385
msgid ""
"A solitary difference from its close analog exists: its ``acquire`` method's "
"first argument is named *block*, as is consistent with :meth:`Lock.acquire`."
msgstr ""
"Existe uma única diferença em relação ao seu análogo próximo: o primeiro "
"argumento do método ``acquire`` é chamado *block*, como é consistente com :"
"meth:`Lock.acquire`."

#: ../../library/multiprocessing.rst:1251
msgid ""
"On macOS, this is indistinguishable from :class:`Semaphore` because "
"``sem_getvalue()`` is not implemented on that platform."
msgstr ""
"No macOS, isso é indistinguível de :class:`Semaphore` porque "
"``sem_getvalue()`` não está implementado nessa plataforma."

#: ../../library/multiprocessing.rst:1256
msgid "A condition variable: an alias for :class:`threading.Condition`."
msgstr ""
"Uma variável de condição: um apelido para :class:`threading.Condition`."

#: ../../library/multiprocessing.rst:1258
msgid ""
"If *lock* is specified then it should be a :class:`Lock` or :class:`RLock` "
"object from :mod:`multiprocessing`."
msgstr ""
"Se *lock* for especificado, ele deverá ser um objeto :class:`Lock` ou :class:"
"`RLock` de :mod:`multiprocessing`."

#: ../../library/multiprocessing.rst:1261
#: ../../library/multiprocessing.rst:1796
msgid "The :meth:`~threading.Condition.wait_for` method was added."
msgstr "O método :meth:`~threading.Condition.wait_for` foi adicionado."

#: ../../library/multiprocessing.rst:1266
msgid "A clone of :class:`threading.Event`."
msgstr "Um clone de :class:`threading.Event`."

#: ../../library/multiprocessing.rst:1271
msgid ""
"A non-recursive lock object: a close analog of :class:`threading.Lock`. Once "
"a process or thread has acquired a lock, subsequent attempts to acquire it "
"from any process or thread will block until it is released; any process or "
"thread may release it.  The concepts and behaviors of :class:`threading."
"Lock` as it applies to threads are replicated here in :class:"
"`multiprocessing.Lock` as it applies to either processes or threads, except "
"as noted."
msgstr ""
"Um objeto de trava não recursivo: um análogo próximo de :class:`threading."
"Lock`. Uma vez que um processo ou thread tenha adquirido um trava, "
"tentativas subsequentes de adquiri-la de qualquer processo ou thread "
"bloquearão até que ele seja liberada; qualquer processo ou thread pode "
"liberá-la. Os conceitos e comportamentos de :class:`threading.Lock` conforme "
"se aplica a threads são replicados aqui em :class:`multiprocessing.Lock` "
"conforme se aplica a processos ou threads, exceto conforme observado."

#: ../../library/multiprocessing.rst:1279
msgid ""
"Note that :class:`Lock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.Lock`` initialized with a default "
"context."
msgstr ""
"Observe que :class:`Lock` é na verdade uma função de fábrica que retorna uma "
"instância de ``multiprocessing.synchronize.Lock`` inicializada com um "
"contexto padrão."

#: ../../library/multiprocessing.rst:1283
msgid ""
":class:`Lock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`Lock` oferece suporte ao protocolo :term:`gerenciador de contexto` "
"e, portanto, pode ser usado em instruções :keyword:`with`."

#: ../../library/multiprocessing.rst:1288
#: ../../library/multiprocessing.rst:1339
msgid "Acquire a lock, blocking or non-blocking."
msgstr "Adquire uma trava, bloqueante ou não."

#: ../../library/multiprocessing.rst:1290
msgid ""
"With the *block* argument set to ``True`` (the default), the method call "
"will block until the lock is in an unlocked state, then set it to locked and "
"return ``True``.  Note that the name of this first argument differs from "
"that in :meth:`threading.Lock.acquire`."
msgstr ""
"Com o argumento *block* definido como ``True`` (o padrão), a chamada do "
"método bloqueará até que a trava esteja em um estado destravado, então o "
"definirá como travada e retornará ``True``. Observe que o nome deste "
"primeiro argumento difere daquele em :meth:`threading.Lock.acquire`."

#: ../../library/multiprocessing.rst:1295
msgid ""
"With the *block* argument set to ``False``, the method call does not block.  "
"If the lock is currently in a locked state, return ``False``; otherwise set "
"the lock to a locked state and return ``True``."
msgstr ""
"Com o argumento *block* definido como ``False``, a chamada do método não "
"bloqueia. Se a trava estiver atualmente em um estado travado, retorna "
"``False``; caso contrário, defina a trava para um estado travado e retorna "
"``True``."

#: ../../library/multiprocessing.rst:1299
msgid ""
"When invoked with a positive, floating-point value for *timeout*, block for "
"at most the number of seconds specified by *timeout* as long as the lock can "
"not be acquired.  Invocations with a negative value for *timeout* are "
"equivalent to a *timeout* of zero.  Invocations with a *timeout* value of "
"``None`` (the default) set the timeout period to infinite.  Note that the "
"treatment of negative or ``None`` values for *timeout* differs from the "
"implemented behavior in :meth:`threading.Lock.acquire`.  The *timeout* "
"argument has no practical implications if the *block* argument is set to "
"``False`` and is thus ignored.  Returns ``True`` if the lock has been "
"acquired or ``False`` if the timeout period has elapsed."
msgstr ""
"Quando invocado com um valor positivo de ponto flutuante para *timeout*, "
"bloqueie por no máximo o número de segundos especificado por *timeout* "
"enquanto a trava não puder ser adquirida. Invocações com um valor negativo "
"para *timeout* são equivalentes a um *timeout* de zero. Invocações com um "
"valor *timeout* de ``None`` (o padrão) definem o período de tempo limite "
"como infinito. Observe que o tratamento de valores negativos ou ``None`` "
"para *timeout* difere do comportamento implementado em :meth:`threading.Lock."
"acquire`. O argumento *timeout* não tem implicações práticas se o argumento "
"*block* for definido como ``False`` e, portanto, for ignorado. Retorna "
"``True`` se a trava tiver sido adquirida ou ``False`` se o período de tempo "
"limite tiver decorrido."

#: ../../library/multiprocessing.rst:1314
msgid ""
"Release a lock.  This can be called from any process or thread, not only the "
"process or thread which originally acquired the lock."
msgstr ""
"Libera uma trava. Isso pode ser chamado de qualquer processo ou thread, não "
"apenas do processo ou thread que originalmente adquiriu a trava."

#: ../../library/multiprocessing.rst:1317
msgid ""
"Behavior is the same as in :meth:`threading.Lock.release` except that when "
"invoked on an unlocked lock, a :exc:`ValueError` is raised."
msgstr ""
"O comportamento é o mesmo de :meth:`threading.Lock.release`, exceto que "
"quando invocado em uma trava desatravada, uma :exc:`ValueError` é levantada."

#: ../../library/multiprocessing.rst:1323
msgid ""
"A recursive lock object: a close analog of :class:`threading.RLock`.  A "
"recursive lock must be released by the process or thread that acquired it. "
"Once a process or thread has acquired a recursive lock, the same process or "
"thread may acquire it again without blocking; that process or thread must "
"release it once for each time it has been acquired."
msgstr ""
"Um objeto de trava recursiva: um análogo próximo de :class:`threading."
"RLock`. Uma trava recursiva deve ser liberada pelo processo ou thread que o "
"adquiriu. Uma vez que um processo ou thread tenha adquirido uma trava "
"recursiva, o mesmo processo ou thread pode adquiri-la novamente sem trava; "
"esse processo ou thread deve liberá-la uma vez para cada vez que ela foi "
"adquirida."

#: ../../library/multiprocessing.rst:1329
msgid ""
"Note that :class:`RLock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.RLock`` initialized with a default "
"context."
msgstr ""
"Observe que :class:`RLock` é na verdade uma função de fábrica que retorna "
"uma instância de ``multiprocessing.synchronize.RLock`` inicializada com um "
"contexto padrão."

#: ../../library/multiprocessing.rst:1333
msgid ""
":class:`RLock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`RLock` oferece suporte ao protocolo :term:`gerenciador de contexto` "
"e, portanto, pode ser usado em instruções :keyword:`with`."

#: ../../library/multiprocessing.rst:1341
msgid ""
"When invoked with the *block* argument set to ``True``, block until the lock "
"is in an unlocked state (not owned by any process or thread) unless the lock "
"is already owned by the current process or thread.  The current process or "
"thread then takes ownership of the lock (if it does not already have "
"ownership) and the recursion level inside the lock increments by one, "
"resulting in a return value of ``True``.  Note that there are several "
"differences in this first argument's behavior compared to the implementation "
"of :meth:`threading.RLock.acquire`, starting with the name of the argument "
"itself."
msgstr ""
"Quando invocado com o argumento *block* definido como ``True``, bloqueia até "
"que a trava esteja em um estado destravado (não pertencente a nenhum "
"processo ou thread), a menos que a trava já seja de propriedade do processo "
"ou thread atual. O processo ou thread atual então assume a propriedade da "
"trava (se ainda não tiver propriedade) e o nível de recursão dentro de "
"incrementos por um da trava, resultando em um valor de retorno de ``True``. "
"Observe que há várias diferenças no comportamento deste primeiro argumento "
"em comparação com a implementação de :meth:`threading.RLock.acquire`, "
"começando pelo nome do argumento em si."

#: ../../library/multiprocessing.rst:1351
msgid ""
"When invoked with the *block* argument set to ``False``, do not block. If "
"the lock has already been acquired (and thus is owned) by another process or "
"thread, the current process or thread does not take ownership and the "
"recursion level within the lock is not changed, resulting in a return value "
"of ``False``.  If the lock is in an unlocked state, the current process or "
"thread takes ownership and the recursion level is incremented, resulting in "
"a return value of ``True``."
msgstr ""
"Quando invocado com o argumento *block* definido como ``False``, não "
"bloqueie. Se a trava já tiver sido adquirida (e, portanto, for de "
"propriedade) por outro processo ou thread, o processo ou thread atual não "
"assume a propriedade e o nível de recursão dentro da trava não é alterada, "
"resultando em um valor de retorno de ``False``. Se a trava estiver em um "
"estado destravado, o processo ou thread atual assume a propriedade e o nível "
"de recursão é incrementado, resultando em um valor de retorno de ``True``."

#: ../../library/multiprocessing.rst:1359
msgid ""
"Use and behaviors of the *timeout* argument are the same as in :meth:`Lock."
"acquire`.  Note that some of these behaviors of *timeout* differ from the "
"implemented behaviors in :meth:`threading.RLock.acquire`."
msgstr ""
"O uso e os comportamentos do argumento *timeout* são os mesmos que em :meth:"
"`Lock.acquire`. Observe que alguns desses comportamentos de *timeout* "
"diferem dos comportamentos implementados em :meth:`threading.RLock.acquire`."

#: ../../library/multiprocessing.rst:1366
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement "
"the recursion level is zero, reset the lock to unlocked (not owned by any "
"process or thread) and if any other processes or threads are blocked waiting "
"for the lock to become unlocked, allow exactly one of them to proceed.  If "
"after the decrement the recursion level is still nonzero, the lock remains "
"locked and owned by the calling process or thread."
msgstr ""
"Libera uma trava, decrementando o nível de recursão. Se após o decremento o "
"nível de recursão for zero, redefine a trava para destravada (não "
"pertencente a nenhum processo ou thread) e se quaisquer outros processos ou "
"threads estiverem bloqueados esperando a trava ser destravada, permita que "
"exatamente um deles prossiga. Se após o decremento o nível de recursão ainda "
"for diferente de zero, o trava permanece travada e pertencente ao processo "
"ou thread de chamada."

#: ../../library/multiprocessing.rst:1374
msgid ""
"Only call this method when the calling process or thread owns the lock. An :"
"exc:`AssertionError` is raised if this method is called by a process or "
"thread other than the owner or if the lock is in an unlocked (unowned) "
"state.  Note that the type of exception raised in this situation differs "
"from the implemented behavior in :meth:`threading.RLock.release`."
msgstr ""
"Somente chame esse método quando o processo ou thread de chamada for "
"proprietária da trava. Uma :exc:`AssertionError` é levantada se esse método "
"for chamado por um processo ou thread diferente do proprietário ou se a "
"trava estiver em um estado destravado (sem proprietário). Observe que o tipo "
"de exceção levantada nessa situação difere do comportamento implementado em :"
"meth:`threading.RLock.release`."

#: ../../library/multiprocessing.rst:1383
msgid "A semaphore object: a close analog of :class:`threading.Semaphore`."
msgstr ""
"Um objeto semáforo: um análogo próximo de :class:`threading.Semaphore`."

#: ../../library/multiprocessing.rst:1390
msgid ""
"On macOS, ``sem_timedwait`` is unsupported, so calling ``acquire()`` with a "
"timeout will emulate that function's behavior using a sleeping loop."
msgstr ""
"No macOS, não há suporte a ``sem_timedwait``, então chamar ``acquire()`` com "
"um tempo limite emulará o comportamento dessa função usando um laço de "
"suspensão."

#: ../../library/multiprocessing.rst:1395
msgid ""
"If the SIGINT signal generated by :kbd:`Ctrl-C` arrives while the main "
"thread is blocked by a call to :meth:`BoundedSemaphore.acquire`, :meth:`Lock."
"acquire`, :meth:`RLock.acquire`, :meth:`Semaphore.acquire`, :meth:`Condition."
"acquire` or :meth:`Condition.wait` then the call will be immediately "
"interrupted and :exc:`KeyboardInterrupt` will be raised."
msgstr ""

#: ../../library/multiprocessing.rst:1401
msgid ""
"This differs from the behaviour of :mod:`threading` where SIGINT will be "
"ignored while the equivalent blocking calls are in progress."
msgstr ""

#: ../../library/multiprocessing.rst:1406
msgid ""
"Some of this package's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the :mod:"
"`multiprocessing.synchronize` module will be disabled, and attempts to "
"import it will result in an :exc:`ImportError`. See :issue:`3770` for "
"additional information."
msgstr ""
"Algumas das funcionalidades deste pacote exibem uma implementação de "
"semáforo compartilhado funcional no sistema operacional host. Sem uma, o "
"módulo :mod:`multiprocessing.synchronize` será desabilitado e as tentativas "
"de importação dele resultarão em um :exc:`ImportError`. Veja :issue:`3770` "
"para informações adicionais."

#: ../../library/multiprocessing.rst:1414
msgid "Shared :mod:`ctypes` Objects"
msgstr "Objetos :mod:`ctypes` compartilhados"

#: ../../library/multiprocessing.rst:1416
msgid ""
"It is possible to create shared objects using shared memory which can be "
"inherited by child processes."
msgstr ""
"É possível criar objetos compartilhados usando memória compartilhada que "
"pode ser herdada por processos filhos."

#: ../../library/multiprocessing.rst:1421
msgid ""
"Return a :mod:`ctypes` object allocated from shared memory.  By default the "
"return value is actually a synchronized wrapper for the object.  The object "
"itself can be accessed via the *value* attribute of a :class:`Value`."
msgstr ""
"Retorna um objeto :mod:`ctypes` alocado da memória compartilhada. Por "
"padrão, o valor de retorno é, na verdade, um invólucro sincronizado para o "
"objeto. O objeto em si pode ser acessado por meio do atributo *value* de um :"
"class:`Value`."

#: ../../library/multiprocessing.rst:1425
#: ../../library/multiprocessing.rst:1512
msgid ""
"*typecode_or_type* determines the type of the returned object: it is either "
"a ctypes type or a one character typecode of the kind used by the :mod:"
"`array` module.  *\\*args* is passed on to the constructor for the type."
msgstr ""
"*typecode_or_type* determina o tipo do objeto retornado: é um tipo ctypes ou "
"um typecode de um caractere do tipo usado pelo módulo :mod:`array`. "
"*\\*args* é passado para o construtor para o tipo."

#: ../../library/multiprocessing.rst:1429
msgid ""
"If *lock* is ``True`` (the default) then a new recursive lock object is "
"created to synchronize access to the value.  If *lock* is a :class:`Lock` "
"or :class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr ""
"Se *lock* for ``True`` (o padrão), então um novo objeto de trava recursiva é "
"criado para sincronizar o acesso ao valor. Se *lock* for um objeto :class:"
"`Lock` ou :class:`RLock`, então ele será usado para sincronizar o acesso ao "
"valor. Se *lock* for ``False``, então o acesso ao objeto retornado não será "
"protegido automaticamente por uma trava, então ele não será necessariamente "
"\"seguro para processo\"."

#: ../../library/multiprocessing.rst:1436
msgid ""
"Operations like ``+=`` which involve a read and write are not atomic.  So "
"if, for instance, you want to atomically increment a shared value it is "
"insufficient to just do ::"
msgstr ""
"Operações como ``+=`` que envolvem uma leitura e escrita não são atômicas. "
"Então se, por exemplo, você quiser incrementar atomicamente um valor "
"compartilhado, não é suficiente apenas fazer ::"

#: ../../library/multiprocessing.rst:1442
msgid ""
"Assuming the associated lock is recursive (which it is by default) you can "
"instead do ::"
msgstr ""
"Supondo que a trava associada seja recursiva (o que é por padrão), você pode "
"fazer ::"

#: ../../library/multiprocessing.rst:1448
#: ../../library/multiprocessing.rst:1538
#: ../../library/multiprocessing.rst:1553
msgid "Note that *lock* is a keyword-only argument."
msgstr "Observe que *lock* é um argumento somente-nomeado."

#: ../../library/multiprocessing.rst:1452
msgid ""
"Return a ctypes array allocated from shared memory.  By default the return "
"value is actually a synchronized wrapper for the array."
msgstr ""
"Retorna um vetor de ctypes alocado da memória compartilhada. Por padrão, o "
"valor de retorno é, na verdade, um invólucro sincronizado para o vetor."

#: ../../library/multiprocessing.rst:1455
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer, "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise, *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* determina o tipo dos elementos do vetor retornado: é um "
"tipo ctypes ou um typecode de um caractere do tipo usado pelo módulo :mod:"
"`array`. Se *size_or_initializer* for um inteiro, então ele determina o "
"comprimento do vetor, e o vetor será inicialmente zerado. Caso contrário, "
"*size_or_initializer* é uma sequência que é usada para inicializar o vetor e "
"cujo comprimento determina o comprimento do vetor."

#: ../../library/multiprocessing.rst:1462
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`Lock` or :class:"
"`RLock` object then that will be used to synchronize access to the value.  "
"If *lock* is ``False`` then access to the returned object will not be "
"automatically protected by a lock, so it will not necessarily be \"process-"
"safe\"."
msgstr ""
"Se *lock* for ``True`` (o padrão), então um novo objeto de trava é criado "
"para sincronizar o acesso ao valor. Se *lock* for um objeto :class:`Lock` "
"ou :class:`RLock`, então ele será usado para sincronizar o acesso ao valor. "
"Se *lock* for ``False``, então o acesso ao objeto retornado não será "
"protegido automaticamente por uma trava, então ele não será necessariamente "
"\"seguro para processo\"."

#: ../../library/multiprocessing.rst:1469
msgid "Note that *lock* is a keyword only argument."
msgstr "Observe que *lock* é um argumento somente-nomeado."

#: ../../library/multiprocessing.rst:1471
msgid ""
"Note that an array of :data:`ctypes.c_char` has *value* and *raw* attributes "
"which allow one to use it to store and retrieve strings."
msgstr ""
"Observe que um vetor de :data:`ctypes.c_char` tem atributos *value* e *raw* "
"que permitem usá-lo para armazenar e recuperar strings."

#: ../../library/multiprocessing.rst:1476
msgid "The :mod:`multiprocessing.sharedctypes` module"
msgstr "O módulo :mod:`multiprocessing.sharedctypes`"

#: ../../library/multiprocessing.rst:1481
msgid ""
"The :mod:`multiprocessing.sharedctypes` module provides functions for "
"allocating :mod:`ctypes` objects from shared memory which can be inherited "
"by child processes."
msgstr ""
"O módulo :mod:`multiprocessing.sharedctypes` fornece funções para alocar "
"objetos :mod:`ctypes` da memória compartilhada que podem ser herdados por "
"processos filhos."

#: ../../library/multiprocessing.rst:1487
msgid ""
"Although it is possible to store a pointer in shared memory remember that "
"this will refer to a location in the address space of a specific process. "
"However, the pointer is quite likely to be invalid in the context of a "
"second process and trying to dereference the pointer from the second process "
"may cause a crash."
msgstr ""
"Embora seja possível armazenar um ponteiro na memória compartilhada, lembre-"
"se de que isso se referirá a um local no espaço de endereço de um processo "
"específico. No entanto, é bem provável que o ponteiro seja inválido no "
"contexto de um segundo processo e tentar desreferenciar o ponteiro do "
"segundo processo pode causar um travamento."

#: ../../library/multiprocessing.rst:1495
msgid "Return a ctypes array allocated from shared memory."
msgstr "Retorna um vetor de ctypes alocado da memória compartilhada."

#: ../../library/multiprocessing.rst:1497
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* determina o tipo dos elementos do vetor retornado: é um "
"tipo ctypes ou um typecode de um caractere do tipo usado pelo módulo :mod:"
"`array`. Se *size_or_initializer* for um inteiro, então ele determina o "
"comprimento do vetor, e o vetor será inicialmente zerado. Caso contrário, "
"*size_or_initializer* é uma sequência que é usada para inicializar o vetor e "
"cujo comprimento determina o comprimento do vetor."

#: ../../library/multiprocessing.rst:1504
msgid ""
"Note that setting and getting an element is potentially non-atomic -- use :"
"func:`Array` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"Observe que definir e obter um elemento é potencialmente não atômico -- use :"
"func:`Array` para garantir que o acesso seja sincronizado automaticamente "
"usando uma trava."

#: ../../library/multiprocessing.rst:1510
msgid "Return a ctypes object allocated from shared memory."
msgstr "Retorna um objeto ctypes alocado da memória compartilhada."

#: ../../library/multiprocessing.rst:1516
msgid ""
"Note that setting and getting the value is potentially non-atomic -- use :"
"func:`Value` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"Observe que definir e obter o valor é potencialmente não atômico -- use :"
"func:`Value` para garantir que o acesso seja sincronizado automaticamente "
"usando uma trava."

#: ../../library/multiprocessing.rst:1520
msgid ""
"Note that an array of :data:`ctypes.c_char` has ``value`` and ``raw`` "
"attributes which allow one to use it to store and retrieve strings -- see "
"documentation for :mod:`ctypes`."
msgstr ""
"Observe que um vetor de :data:`ctypes.c_char` tem atributos ``value`` e "
"``raw`` que permitem usá-la para armazenar e recuperar strings -- veja a "
"documentação de :mod:`ctypes`."

#: ../../library/multiprocessing.rst:1526
msgid ""
"The same as :func:`RawArray` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"array."
msgstr ""
"O mesmo que :func:`RawArray`, exceto que dependendo do valor de *lock*, um "
"invólucro de sincronização seguro para processo pode ser retornado em vez de "
"um vetor de ctypes brutos."

#: ../../library/multiprocessing.rst:1530
#: ../../library/multiprocessing.rst:1546
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`~multiprocessing."
"Lock` or :class:`~multiprocessing.RLock` object then that will be used to "
"synchronize access to the value.  If *lock* is ``False`` then access to the "
"returned object will not be automatically protected by a lock, so it will "
"not necessarily be \"process-safe\"."
msgstr ""
"Se *lock* for ``True`` (o padrão), então um novo objeto de trava é criado "
"para sincronizar o acesso ao valor. Se *lock* for um objeto :class:"
"`~multiprocessing.Lock` ou :class:`~multiprocessing.RLock`, então ele será "
"usado para sincronizar o acesso ao valor. Se *lock* for ``False``, então o "
"acesso ao objeto retornado não será protegido automaticamente por uma trava, "
"então ele não será necessariamente \"seguro para processo\"."

#: ../../library/multiprocessing.rst:1542
msgid ""
"The same as :func:`RawValue` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"object."
msgstr ""
"O mesmo que :func:`RawValue`, exceto que dependendo do valor de *lock*, um "
"invólucro de sincronização seguro para processo pode ser retornado em vez de "
"um objeto ctypes brutos."

#: ../../library/multiprocessing.rst:1557
msgid ""
"Return a ctypes object allocated from shared memory which is a copy of the "
"ctypes object *obj*."
msgstr ""
"Retorna um objeto ctypes alocado da memória compartilhada que é uma cópia do "
"objeto ctypes *obj*."

#: ../../library/multiprocessing.rst:1562
msgid ""
"Return a process-safe wrapper object for a ctypes object which uses *lock* "
"to synchronize access.  If *lock* is ``None`` (the default) then a :class:"
"`multiprocessing.RLock` object is created automatically."
msgstr ""
"Retorna um objeto invólucro seguro para o processo para um objeto ctypes que "
"usa *lock* para sincronizar o acesso. Se *lock* for ``None`` (o padrão), "
"então um objeto :class:`multiprocessing.RLock` é criado automaticamente."

#: ../../library/multiprocessing.rst:1566
msgid ""
"A synchronized wrapper will have two methods in addition to those of the "
"object it wraps: :meth:`get_obj` returns the wrapped object and :meth:"
"`get_lock` returns the lock object used for synchronization."
msgstr ""

#: ../../library/multiprocessing.rst:1570
msgid ""
"Note that accessing the ctypes object through the wrapper can be a lot "
"slower than accessing the raw ctypes object."
msgstr ""

#: ../../library/multiprocessing.rst:1573
msgid "Synchronized objects support the :term:`context manager` protocol."
msgstr ""

#: ../../library/multiprocessing.rst:1577
msgid ""
"The table below compares the syntax for creating shared ctypes objects from "
"shared memory with the normal ctypes syntax.  (In the table ``MyStruct`` is "
"some subclass of :class:`ctypes.Structure`.)"
msgstr ""

#: ../../library/multiprocessing.rst:1582
msgid "ctypes"
msgstr "ctypes"

#: ../../library/multiprocessing.rst:1582
msgid "sharedctypes using type"
msgstr "sharedctypes using type"

#: ../../library/multiprocessing.rst:1582
msgid "sharedctypes using typecode"
msgstr "sharedctypes using typecode"

#: ../../library/multiprocessing.rst:1584
msgid "c_double(2.4)"
msgstr "c_double(2.4)"

#: ../../library/multiprocessing.rst:1584
msgid "RawValue(c_double, 2.4)"
msgstr "RawValue(c_double, 2.4)"

#: ../../library/multiprocessing.rst:1584
msgid "RawValue('d', 2.4)"
msgstr "RawValue('d', 2.4)"

#: ../../library/multiprocessing.rst:1585
msgid "MyStruct(4, 6)"
msgstr "MyStruct(4, 6)"

#: ../../library/multiprocessing.rst:1585
msgid "RawValue(MyStruct, 4, 6)"
msgstr "RawValue(MyStruct, 4, 6)"

#: ../../library/multiprocessing.rst:1586
msgid "(c_short * 7)()"
msgstr "(c_short * 7)()"

#: ../../library/multiprocessing.rst:1586
msgid "RawArray(c_short, 7)"
msgstr "RawArray(c_short, 7)"

#: ../../library/multiprocessing.rst:1586
msgid "RawArray('h', 7)"
msgstr "RawArray('h', 7)"

#: ../../library/multiprocessing.rst:1587
msgid "(c_int * 3)(9, 2, 8)"
msgstr "(c_int * 3)(9, 2, 8)"

#: ../../library/multiprocessing.rst:1587
msgid "RawArray(c_int, (9, 2, 8))"
msgstr "RawArray(c_int, (9, 2, 8))"

#: ../../library/multiprocessing.rst:1587
msgid "RawArray('i', (9, 2, 8))"
msgstr "RawArray('i', (9, 2, 8))"

#: ../../library/multiprocessing.rst:1591
msgid ""
"Below is an example where a number of ctypes objects are modified by a child "
"process::"
msgstr ""

#: ../../library/multiprocessing.rst:1629
msgid "The results printed are ::"
msgstr ""

#: ../../library/multiprocessing.rst:1642
msgid "Managers"
msgstr "Gerenciadores"

#: ../../library/multiprocessing.rst:1644
msgid ""
"Managers provide a way to create data which can be shared between different "
"processes, including sharing over a network between processes running on "
"different machines. A manager object controls a server process which manages "
"*shared objects*.  Other processes can access the shared objects by using "
"proxies."
msgstr ""

#: ../../library/multiprocessing.rst:1653
msgid ""
"Returns a started :class:`~multiprocessing.managers.SyncManager` object "
"which can be used for sharing objects between processes.  The returned "
"manager object corresponds to a spawned child process and has methods which "
"will create shared objects and return corresponding proxies."
msgstr ""

#: ../../library/multiprocessing.rst:1661
msgid ""
"Manager processes will be shutdown as soon as they are garbage collected or "
"their parent process exits.  The manager classes are defined in the :mod:"
"`multiprocessing.managers` module:"
msgstr ""

#: ../../library/multiprocessing.rst:1667
msgid "Create a BaseManager object."
msgstr "Criando um objeto BaseManager."

#: ../../library/multiprocessing.rst:1669
msgid ""
"Once created one should call :meth:`start` or ``get_server()."
"serve_forever()`` to ensure that the manager object refers to a started "
"manager process."
msgstr ""

#: ../../library/multiprocessing.rst:1672
msgid ""
"*address* is the address on which the manager process listens for new "
"connections.  If *address* is ``None`` then an arbitrary one is chosen."
msgstr ""

#: ../../library/multiprocessing.rst:1675
msgid ""
"*authkey* is the authentication key which will be used to check the validity "
"of incoming connections to the server process.  If *authkey* is ``None`` "
"then ``current_process().authkey`` is used. Otherwise *authkey* is used and "
"it must be a byte string."
msgstr ""

#: ../../library/multiprocessing.rst:1682
msgid ""
"Start a subprocess to start the manager.  If *initializer* is not ``None`` "
"then the subprocess will call ``initializer(*initargs)`` when it starts."
msgstr ""

#: ../../library/multiprocessing.rst:1687
msgid ""
"Returns a :class:`Server` object which represents the actual server under "
"the control of the Manager. The :class:`Server` object supports the :meth:"
"`serve_forever` method::"
msgstr ""

#: ../../library/multiprocessing.rst:1696
msgid ":class:`Server` additionally has an :attr:`address` attribute."
msgstr ""

#: ../../library/multiprocessing.rst:1700
msgid "Connect a local manager object to a remote manager process::"
msgstr ""

#: ../../library/multiprocessing.rst:1708
msgid ""
"Stop the process used by the manager.  This is only available if :meth:"
"`start` has been used to start the server process."
msgstr ""

#: ../../library/multiprocessing.rst:1711
msgid "This can be called multiple times."
msgstr ""

#: ../../library/multiprocessing.rst:1715
msgid ""
"A classmethod which can be used for registering a type or callable with the "
"manager class."
msgstr ""

#: ../../library/multiprocessing.rst:1718
msgid ""
"*typeid* is a \"type identifier\" which is used to identify a particular "
"type of shared object.  This must be a string."
msgstr ""

#: ../../library/multiprocessing.rst:1721
msgid ""
"*callable* is a callable used for creating objects for this type "
"identifier.  If a manager instance will be connected to the server using "
"the :meth:`connect` method, or if the *create_method* argument is ``False`` "
"then this can be left as ``None``."
msgstr ""

#: ../../library/multiprocessing.rst:1727
msgid ""
"*proxytype* is a subclass of :class:`BaseProxy` which is used to create "
"proxies for shared objects with this *typeid*.  If ``None`` then a proxy "
"class is created automatically."
msgstr ""

#: ../../library/multiprocessing.rst:1731
msgid ""
"*exposed* is used to specify a sequence of method names which proxies for "
"this typeid should be allowed to access using :meth:`BaseProxy."
"_callmethod`.  (If *exposed* is ``None`` then :attr:`proxytype._exposed_` is "
"used instead if it exists.)  In the case where no exposed list is specified, "
"all \"public methods\" of the shared object will be accessible.  (Here a "
"\"public method\" means any attribute which has a :meth:`~object.__call__` "
"method and whose name does not begin with ``'_'``.)"
msgstr ""

#: ../../library/multiprocessing.rst:1740
msgid ""
"*method_to_typeid* is a mapping used to specify the return type of those "
"exposed methods which should return a proxy.  It maps method names to typeid "
"strings.  (If *method_to_typeid* is ``None`` then :attr:`proxytype."
"_method_to_typeid_` is used instead if it exists.)  If a method's name is "
"not a key of this mapping or if the mapping is ``None`` then the object "
"returned by the method will be copied by value."
msgstr ""

#: ../../library/multiprocessing.rst:1747
msgid ""
"*create_method* determines whether a method should be created with name "
"*typeid* which can be used to tell the server process to create a new shared "
"object and return a proxy for it.  By default it is ``True``."
msgstr ""

#: ../../library/multiprocessing.rst:1751
msgid ":class:`BaseManager` instances also have one read-only property:"
msgstr ""

#: ../../library/multiprocessing.rst:1755
msgid "The address used by the manager."
msgstr ""

#: ../../library/multiprocessing.rst:1757
msgid ""
"Manager objects support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` starts the server "
"process (if it has not already started) and then returns the manager "
"object.  :meth:`~contextmanager.__exit__` calls :meth:`shutdown`."
msgstr ""

#: ../../library/multiprocessing.rst:1763
msgid ""
"In previous versions :meth:`~contextmanager.__enter__` did not start the "
"manager's server process if it was not already started."
msgstr ""

#: ../../library/multiprocessing.rst:1768
msgid ""
"A subclass of :class:`BaseManager` which can be used for the synchronization "
"of processes.  Objects of this type are returned by :func:`multiprocessing."
"Manager`."
msgstr ""

#: ../../library/multiprocessing.rst:1772
msgid ""
"Its methods create and return :ref:`multiprocessing-proxy_objects` for a "
"number of commonly used data types to be synchronized across processes. This "
"notably includes shared lists and dictionaries."
msgstr ""

#: ../../library/multiprocessing.rst:1778
msgid ""
"Create a shared :class:`threading.Barrier` object and return a proxy for it."
msgstr ""

#: ../../library/multiprocessing.rst:1785
msgid ""
"Create a shared :class:`threading.BoundedSemaphore` object and return a "
"proxy for it."
msgstr ""

#: ../../library/multiprocessing.rst:1790
msgid ""
"Create a shared :class:`threading.Condition` object and return a proxy for "
"it."
msgstr ""

#: ../../library/multiprocessing.rst:1793
msgid ""
"If *lock* is supplied then it should be a proxy for a :class:`threading."
"Lock` or :class:`threading.RLock` object."
msgstr ""

#: ../../library/multiprocessing.rst:1801
msgid ""
"Create a shared :class:`threading.Event` object and return a proxy for it."
msgstr ""

#: ../../library/multiprocessing.rst:1805
msgid ""
"Create a shared :class:`threading.Lock` object and return a proxy for it."
msgstr ""

#: ../../library/multiprocessing.rst:1809
msgid "Create a shared :class:`Namespace` object and return a proxy for it."
msgstr ""

#: ../../library/multiprocessing.rst:1813
msgid "Create a shared :class:`queue.Queue` object and return a proxy for it."
msgstr ""

#: ../../library/multiprocessing.rst:1817
msgid ""
"Create a shared :class:`threading.RLock` object and return a proxy for it."
msgstr ""

#: ../../library/multiprocessing.rst:1821
msgid ""
"Create a shared :class:`threading.Semaphore` object and return a proxy for "
"it."
msgstr ""

#: ../../library/multiprocessing.rst:1826
msgid "Create an array and return a proxy for it."
msgstr ""

#: ../../library/multiprocessing.rst:1830
msgid ""
"Create an object with a writable ``value`` attribute and return a proxy for "
"it."
msgstr ""

#: ../../library/multiprocessing.rst:1837
msgid "Create a shared :class:`dict` object and return a proxy for it."
msgstr ""

#: ../../library/multiprocessing.rst:1842
msgid "Create a shared :class:`list` object and return a proxy for it."
msgstr ""

#: ../../library/multiprocessing.rst:1844
msgid ""
"Shared objects are capable of being nested.  For example, a shared container "
"object such as a shared list can contain other shared objects which will all "
"be managed and synchronized by the :class:`SyncManager`."
msgstr ""

#: ../../library/multiprocessing.rst:1851
msgid "A type that can register with :class:`SyncManager`."
msgstr ""

#: ../../library/multiprocessing.rst:1853
msgid ""
"A namespace object has no public methods, but does have writable attributes. "
"Its representation shows the values of its attributes."
msgstr ""

#: ../../library/multiprocessing.rst:1856
msgid ""
"However, when using a proxy for a namespace object, an attribute beginning "
"with ``'_'`` will be an attribute of the proxy and not an attribute of the "
"referent:"
msgstr ""

#: ../../library/multiprocessing.rst:1872
msgid "Customized managers"
msgstr ""

#: ../../library/multiprocessing.rst:1874
msgid ""
"To create one's own manager, one creates a subclass of :class:`BaseManager` "
"and uses the :meth:`~BaseManager.register` classmethod to register new types "
"or callables with the manager class.  For example::"
msgstr ""

#: ../../library/multiprocessing.rst:1899
msgid "Using a remote manager"
msgstr ""

#: ../../library/multiprocessing.rst:1901
msgid ""
"It is possible to run a manager server on one machine and have clients use "
"it from other machines (assuming that the firewalls involved allow it)."
msgstr ""

#: ../../library/multiprocessing.rst:1904
msgid ""
"Running the following commands creates a server for a single shared queue "
"which remote clients can access::"
msgstr ""

#: ../../library/multiprocessing.rst:1916
msgid "One client can access the server as follows::"
msgstr ""

#: ../../library/multiprocessing.rst:1926
msgid "Another client can also use it::"
msgstr ""

#: ../../library/multiprocessing.rst:1937
msgid ""
"Local processes can also access that queue, using the code from above on the "
"client to access it remotely::"
msgstr ""

#: ../../library/multiprocessing.rst:1962
msgid "Proxy Objects"
msgstr ""

#: ../../library/multiprocessing.rst:1964
msgid ""
"A proxy is an object which *refers* to a shared object which lives "
"(presumably) in a different process.  The shared object is said to be the "
"*referent* of the proxy.  Multiple proxy objects may have the same referent."
msgstr ""

#: ../../library/multiprocessing.rst:1968
msgid ""
"A proxy object has methods which invoke corresponding methods of its "
"referent (although not every method of the referent will necessarily be "
"available through the proxy).  In this way, a proxy can be used just like "
"its referent can:"
msgstr ""

#: ../../library/multiprocessing.rst:1986
msgid ""
"Notice that applying :func:`str` to a proxy will return the representation "
"of the referent, whereas applying :func:`repr` will return the "
"representation of the proxy."
msgstr ""

#: ../../library/multiprocessing.rst:1990
msgid ""
"An important feature of proxy objects is that they are picklable so they can "
"be passed between processes.  As such, a referent can contain :ref:"
"`multiprocessing-proxy_objects`.  This permits nesting of these managed "
"lists, dicts, and other :ref:`multiprocessing-proxy_objects`:"
msgstr ""

#: ../../library/multiprocessing.rst:2006
msgid "Similarly, dict and list proxies may be nested inside one another::"
msgstr ""

#: ../../library/multiprocessing.rst:2019
msgid ""
"If standard (non-proxy) :class:`list` or :class:`dict` objects are contained "
"in a referent, modifications to those mutable values will not be propagated "
"through the manager because the proxy has no way of knowing when the values "
"contained within are modified.  However, storing a value in a container "
"proxy (which triggers a ``__setitem__`` on the proxy object) does propagate "
"through the manager and so to effectively modify such an item, one could re-"
"assign the modified value to the container proxy::"
msgstr ""

#: ../../library/multiprocessing.rst:2038
msgid ""
"This approach is perhaps less convenient than employing nested :ref:"
"`multiprocessing-proxy_objects` for most use cases but also demonstrates a "
"level of control over the synchronization."
msgstr ""

#: ../../library/multiprocessing.rst:2044
msgid ""
"The proxy types in :mod:`multiprocessing` do nothing to support comparisons "
"by value.  So, for instance, we have:"
msgstr ""

#: ../../library/multiprocessing.rst:2052
msgid ""
"One should just use a copy of the referent instead when making comparisons."
msgstr ""

#: ../../library/multiprocessing.rst:2056
msgid "Proxy objects are instances of subclasses of :class:`BaseProxy`."
msgstr ""

#: ../../library/multiprocessing.rst:2060
msgid "Call and return the result of a method of the proxy's referent."
msgstr ""

#: ../../library/multiprocessing.rst:2062
msgid ""
"If ``proxy`` is a proxy whose referent is ``obj`` then the expression ::"
msgstr ""

#: ../../library/multiprocessing.rst:2066
msgid "will evaluate the expression ::"
msgstr ""

#: ../../library/multiprocessing.rst:2070
msgid "in the manager's process."
msgstr ""

#: ../../library/multiprocessing.rst:2072
msgid ""
"The returned value will be a copy of the result of the call or a proxy to a "
"new shared object -- see documentation for the *method_to_typeid* argument "
"of :meth:`BaseManager.register`."
msgstr ""

#: ../../library/multiprocessing.rst:2076
msgid ""
"If an exception is raised by the call, then is re-raised by :meth:"
"`_callmethod`.  If some other exception is raised in the manager's process "
"then this is converted into a :exc:`RemoteError` exception and is raised by :"
"meth:`_callmethod`."
msgstr ""

#: ../../library/multiprocessing.rst:2081
msgid ""
"Note in particular that an exception will be raised if *methodname* has not "
"been *exposed*."
msgstr ""

#: ../../library/multiprocessing.rst:2084
msgid "An example of the usage of :meth:`_callmethod`:"
msgstr ""

#: ../../library/multiprocessing.rst:2100
msgid "Return a copy of the referent."
msgstr ""

#: ../../library/multiprocessing.rst:2102
msgid "If the referent is unpicklable then this will raise an exception."
msgstr ""

#: ../../library/multiprocessing.rst:2106
msgid "Return a representation of the proxy object."
msgstr ""

#: ../../library/multiprocessing.rst:2110
msgid "Return the representation of the referent."
msgstr ""

#: ../../library/multiprocessing.rst:2114
msgid "Cleanup"
msgstr "Limpeza"

#: ../../library/multiprocessing.rst:2116
msgid ""
"A proxy object uses a weakref callback so that when it gets garbage "
"collected it deregisters itself from the manager which owns its referent."
msgstr ""

#: ../../library/multiprocessing.rst:2119
msgid ""
"A shared object gets deleted from the manager process when there are no "
"longer any proxies referring to it."
msgstr ""

#: ../../library/multiprocessing.rst:2124
msgid "Process Pools"
msgstr ""

#: ../../library/multiprocessing.rst:2129
msgid ""
"One can create a pool of processes which will carry out tasks submitted to "
"it with the :class:`Pool` class."
msgstr ""

#: ../../library/multiprocessing.rst:2134
msgid ""
"A process pool object which controls a pool of worker processes to which "
"jobs can be submitted.  It supports asynchronous results with timeouts and "
"callbacks and has a parallel map implementation."
msgstr ""

#: ../../library/multiprocessing.rst:2138
msgid ""
"*processes* is the number of worker processes to use.  If *processes* is "
"``None`` then the number returned by :func:`os.cpu_count` is used."
msgstr ""

#: ../../library/multiprocessing.rst:2141
#: ../../library/multiprocessing.rst:2702
msgid ""
"If *initializer* is not ``None`` then each worker process will call "
"``initializer(*initargs)`` when it starts."
msgstr ""

#: ../../library/multiprocessing.rst:2144
msgid ""
"*maxtasksperchild* is the number of tasks a worker process can complete "
"before it will exit and be replaced with a fresh worker process, to enable "
"unused resources to be freed. The default *maxtasksperchild* is ``None``, "
"which means worker processes will live as long as the pool."
msgstr ""

#: ../../library/multiprocessing.rst:2149
msgid ""
"*context* can be used to specify the context used for starting the worker "
"processes.  Usually a pool is created using the function :func:"
"`multiprocessing.Pool` or the :meth:`Pool` method of a context object.  In "
"both cases *context* is set appropriately."
msgstr ""

#: ../../library/multiprocessing.rst:2155
msgid ""
"Note that the methods of the pool object should only be called by the "
"process which created the pool."
msgstr ""

#: ../../library/multiprocessing.rst:2159
msgid ""
":class:`multiprocessing.pool` objects have internal resources that need to "
"be properly managed (like any other resource) by using the pool as a context "
"manager or by calling :meth:`close` and :meth:`terminate` manually. Failure "
"to do this can lead to the process hanging on finalization."
msgstr ""

#: ../../library/multiprocessing.rst:2164
msgid ""
"Note that is **not correct** to rely on the garbage colletor to destroy the "
"pool as CPython does not assure that the finalizer of the pool will be "
"called (see :meth:`object.__del__` for more information)."
msgstr ""

#: ../../library/multiprocessing.rst:2168
msgid "*maxtasksperchild*"
msgstr "*maxtasksperchild*"

#: ../../library/multiprocessing.rst:2171
msgid "*context*"
msgstr "*context*"

#: ../../library/multiprocessing.rst:2176
msgid ""
"Worker processes within a :class:`Pool` typically live for the complete "
"duration of the Pool's work queue. A frequent pattern found in other systems "
"(such as Apache, mod_wsgi, etc) to free resources held by workers is to "
"allow a worker within a pool to complete only a set amount of work before "
"being exiting, being cleaned up and a new process spawned to replace the old "
"one. The *maxtasksperchild* argument to the :class:`Pool` exposes this "
"ability to the end user."
msgstr ""

#: ../../library/multiprocessing.rst:2186
msgid ""
"Call *func* with arguments *args* and keyword arguments *kwds*.  It blocks "
"until the result is ready. Given this blocks, :meth:`apply_async` is better "
"suited for performing work in parallel. Additionally, *func* is only "
"executed in one of the workers of the pool."
msgstr ""

#: ../../library/multiprocessing.rst:2193
msgid ""
"A variant of the :meth:`apply` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ""

#: ../../library/multiprocessing.rst:2196
#: ../../library/multiprocessing.rst:2227
msgid ""
"If *callback* is specified then it should be a callable which accepts a "
"single argument.  When the result becomes ready *callback* is applied to it, "
"that is unless the call failed, in which case the *error_callback* is "
"applied instead."
msgstr ""

#: ../../library/multiprocessing.rst:2201
#: ../../library/multiprocessing.rst:2232
msgid ""
"If *error_callback* is specified then it should be a callable which accepts "
"a single argument.  If the target function fails, then the *error_callback* "
"is called with the exception instance."
msgstr ""

#: ../../library/multiprocessing.rst:2205
#: ../../library/multiprocessing.rst:2236
msgid ""
"Callbacks should complete immediately since otherwise the thread which "
"handles the results will get blocked."
msgstr ""

#: ../../library/multiprocessing.rst:2210
msgid ""
"A parallel equivalent of the :func:`map` built-in function (it supports only "
"one *iterable* argument though, for multiple iterables see :meth:`starmap`). "
"It blocks until the result is ready."
msgstr ""

#: ../../library/multiprocessing.rst:2214
msgid ""
"This method chops the iterable into a number of chunks which it submits to "
"the process pool as separate tasks.  The (approximate) size of these chunks "
"can be specified by setting *chunksize* to a positive integer."
msgstr ""

#: ../../library/multiprocessing.rst:2218
msgid ""
"Note that it may cause high memory usage for very long iterables. Consider "
"using :meth:`imap` or :meth:`imap_unordered` with explicit *chunksize* "
"option for better efficiency."
msgstr ""

#: ../../library/multiprocessing.rst:2224
msgid ""
"A variant of the :meth:`.map` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ""

#: ../../library/multiprocessing.rst:2241
msgid "A lazier version of :meth:`.map`."
msgstr ""

#: ../../library/multiprocessing.rst:2243
msgid ""
"The *chunksize* argument is the same as the one used by the :meth:`.map` "
"method.  For very long iterables using a large value for *chunksize* can "
"make the job complete **much** faster than using the default value of ``1``."
msgstr ""

#: ../../library/multiprocessing.rst:2248
msgid ""
"Also if *chunksize* is ``1`` then the :meth:`!next` method of the iterator "
"returned by the :meth:`imap` method has an optional *timeout* parameter: "
"``next(timeout)`` will raise :exc:`multiprocessing.TimeoutError` if the "
"result cannot be returned within *timeout* seconds."
msgstr ""

#: ../../library/multiprocessing.rst:2255
msgid ""
"The same as :meth:`imap` except that the ordering of the results from the "
"returned iterator should be considered arbitrary.  (Only when there is only "
"one worker process is the order guaranteed to be \"correct\".)"
msgstr ""

#: ../../library/multiprocessing.rst:2261
msgid ""
"Like :meth:`~multiprocessing.pool.Pool.map` except that the elements of the "
"*iterable* are expected to be iterables that are unpacked as arguments."
msgstr ""

#: ../../library/multiprocessing.rst:2265
msgid ""
"Hence an *iterable* of ``[(1,2), (3, 4)]`` results in ``[func(1,2), "
"func(3,4)]``."
msgstr ""

#: ../../library/multiprocessing.rst:2272
msgid ""
"A combination of :meth:`starmap` and :meth:`map_async` that iterates over "
"*iterable* of iterables and calls *func* with the iterables unpacked. "
"Returns a result object."
msgstr ""

#: ../../library/multiprocessing.rst:2280
msgid ""
"Prevents any more tasks from being submitted to the pool.  Once all the "
"tasks have been completed the worker processes will exit."
msgstr ""

#: ../../library/multiprocessing.rst:2285
msgid ""
"Stops the worker processes immediately without completing outstanding work.  "
"When the pool object is garbage collected :meth:`terminate` will be called "
"immediately."
msgstr ""

#: ../../library/multiprocessing.rst:2291
msgid ""
"Wait for the worker processes to exit.  One must call :meth:`close` or :meth:"
"`terminate` before using :meth:`join`."
msgstr ""

#: ../../library/multiprocessing.rst:2294
msgid ""
"Pool objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the pool "
"object, and :meth:`~contextmanager.__exit__` calls :meth:`terminate`."
msgstr ""

#: ../../library/multiprocessing.rst:2302
msgid ""
"The class of the result returned by :meth:`Pool.apply_async` and :meth:`Pool."
"map_async`."
msgstr ""

#: ../../library/multiprocessing.rst:2307
msgid ""
"Return the result when it arrives.  If *timeout* is not ``None`` and the "
"result does not arrive within *timeout* seconds then :exc:`multiprocessing."
"TimeoutError` is raised.  If the remote call raised an exception then that "
"exception will be reraised by :meth:`get`."
msgstr ""

#: ../../library/multiprocessing.rst:2314
msgid "Wait until the result is available or until *timeout* seconds pass."
msgstr ""

#: ../../library/multiprocessing.rst:2318
msgid "Return whether the call has completed."
msgstr ""

#: ../../library/multiprocessing.rst:2322
msgid ""
"Return whether the call completed without raising an exception.  Will raise :"
"exc:`ValueError` if the result is not ready."
msgstr ""

#: ../../library/multiprocessing.rst:2325
msgid ""
"If the result is not ready, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr ""

#: ../../library/multiprocessing.rst:2329
msgid "The following example demonstrates the use of a pool::"
msgstr ""

#: ../../library/multiprocessing.rst:2356
msgid "Listeners and Clients"
msgstr ""

#: ../../library/multiprocessing.rst:2361
msgid ""
"Usually message passing between processes is done using queues or by using :"
"class:`~Connection` objects returned by :func:`~multiprocessing.Pipe`."
msgstr ""

#: ../../library/multiprocessing.rst:2365
msgid ""
"However, the :mod:`multiprocessing.connection` module allows some extra "
"flexibility.  It basically gives a high level message oriented API for "
"dealing with sockets or Windows named pipes.  It also has support for "
"*digest authentication* using the :mod:`hmac` module, and for polling "
"multiple connections at the same time."
msgstr ""

#: ../../library/multiprocessing.rst:2374
msgid ""
"Send a randomly generated message to the other end of the connection and "
"wait for a reply."
msgstr ""

#: ../../library/multiprocessing.rst:2377
msgid ""
"If the reply matches the digest of the message using *authkey* as the key "
"then a welcome message is sent to the other end of the connection.  "
"Otherwise :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""

#: ../../library/multiprocessing.rst:2383
msgid ""
"Receive a message, calculate the digest of the message using *authkey* as "
"the key, and then send the digest back."
msgstr ""

#: ../../library/multiprocessing.rst:2386
msgid ""
"If a welcome message is not received, then :exc:`~multiprocessing."
"AuthenticationError` is raised."
msgstr ""

#: ../../library/multiprocessing.rst:2391
msgid ""
"Attempt to set up a connection to the listener which is using address "
"*address*, returning a :class:`~Connection`."
msgstr ""

#: ../../library/multiprocessing.rst:2394
msgid ""
"The type of the connection is determined by *family* argument, but this can "
"generally be omitted since it can usually be inferred from the format of "
"*address*. (See :ref:`multiprocessing-address-formats`)"
msgstr ""

#: ../../library/multiprocessing.rst:2398
#: ../../library/multiprocessing.rst:2433
msgid ""
"If *authkey* is given and not None, it should be a byte string and will be "
"used as the secret key for an HMAC-based authentication challenge. No "
"authentication is done if *authkey* is None. :exc:`~multiprocessing."
"AuthenticationError` is raised if authentication fails. See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""

#: ../../library/multiprocessing.rst:2406
msgid ""
"A wrapper for a bound socket or Windows named pipe which is 'listening' for "
"connections."
msgstr ""

#: ../../library/multiprocessing.rst:2409
msgid ""
"*address* is the address to be used by the bound socket or named pipe of the "
"listener object."
msgstr ""

#: ../../library/multiprocessing.rst:2414
msgid ""
"If an address of '0.0.0.0' is used, the address will not be a connectable "
"end point on Windows. If you require a connectable end-point, you should use "
"'127.0.0.1'."
msgstr ""

#: ../../library/multiprocessing.rst:2418
msgid ""
"*family* is the type of socket (or named pipe) to use.  This can be one of "
"the strings ``'AF_INET'`` (for a TCP socket), ``'AF_UNIX'`` (for a Unix "
"domain socket) or ``'AF_PIPE'`` (for a Windows named pipe).  Of these only "
"the first is guaranteed to be available.  If *family* is ``None`` then the "
"family is inferred from the format of *address*.  If *address* is also "
"``None`` then a default is chosen.  This default is the family which is "
"assumed to be the fastest available.  See :ref:`multiprocessing-address-"
"formats`.  Note that if *family* is ``'AF_UNIX'`` and address is ``None`` "
"then the socket will be created in a private temporary directory created "
"using :func:`tempfile.mkstemp`."
msgstr ""

#: ../../library/multiprocessing.rst:2429
msgid ""
"If the listener object uses a socket then *backlog* (1 by default) is passed "
"to the :meth:`~socket.socket.listen` method of the socket once it has been "
"bound."
msgstr ""

#: ../../library/multiprocessing.rst:2441
msgid ""
"Accept a connection on the bound socket or named pipe of the listener object "
"and return a :class:`~Connection` object. If authentication is attempted and "
"fails, then :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""

#: ../../library/multiprocessing.rst:2448
msgid ""
"Close the bound socket or named pipe of the listener object.  This is called "
"automatically when the listener is garbage collected.  However it is "
"advisable to call it explicitly."
msgstr ""

#: ../../library/multiprocessing.rst:2452
msgid "Listener objects have the following read-only properties:"
msgstr ""

#: ../../library/multiprocessing.rst:2456
msgid "The address which is being used by the Listener object."
msgstr ""

#: ../../library/multiprocessing.rst:2460
msgid ""
"The address from which the last accepted connection came.  If this is "
"unavailable then it is ``None``."
msgstr ""

#: ../../library/multiprocessing.rst:2463
msgid ""
"Listener objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"listener object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""

#: ../../library/multiprocessing.rst:2470
msgid ""
"Wait till an object in *object_list* is ready.  Returns the list of those "
"objects in *object_list* which are ready.  If *timeout* is a float then the "
"call blocks for at most that many seconds.  If *timeout* is ``None`` then it "
"will block for an unlimited period. A negative timeout is equivalent to a "
"zero timeout."
msgstr ""

#: ../../library/multiprocessing.rst:2476
msgid ""
"For both Unix and Windows, an object can appear in *object_list* if it is"
msgstr ""

#: ../../library/multiprocessing.rst:2479
msgid "a readable :class:`~multiprocessing.connection.Connection` object;"
msgstr ""

#: ../../library/multiprocessing.rst:2480
msgid "a connected and readable :class:`socket.socket` object; or"
msgstr ""

#: ../../library/multiprocessing.rst:2481
msgid ""
"the :attr:`~multiprocessing.Process.sentinel` attribute of a :class:"
"`~multiprocessing.Process` object."
msgstr ""

#: ../../library/multiprocessing.rst:2484
msgid ""
"A connection or socket object is ready when there is data available to be "
"read from it, or the other end has been closed."
msgstr ""

#: ../../library/multiprocessing.rst:2487
msgid ""
"**Unix**: ``wait(object_list, timeout)`` almost equivalent ``select."
"select(object_list, [], [], timeout)``.  The difference is that, if :func:"
"`select.select` is interrupted by a signal, it can raise :exc:`OSError` with "
"an error number of ``EINTR``, whereas :func:`wait` will not."
msgstr ""

#: ../../library/multiprocessing.rst:2493
msgid ""
"**Windows**: An item in *object_list* must either be an integer handle which "
"is waitable (according to the definition used by the documentation of the "
"Win32 function ``WaitForMultipleObjects()``) or it can be an object with a :"
"meth:`fileno` method which returns a socket handle or pipe handle.  (Note "
"that pipe handles and socket handles are **not** waitable handles.)"
msgstr ""

#: ../../library/multiprocessing.rst:2503
msgid "**Examples**"
msgstr ""

#: ../../library/multiprocessing.rst:2505
msgid ""
"The following server code creates a listener which uses ``'secret "
"password'`` as an authentication key.  It then waits for a connection and "
"sends some data to the client::"
msgstr ""

#: ../../library/multiprocessing.rst:2524
msgid ""
"The following code connects to the server and receives some data from the "
"server::"
msgstr ""

#: ../../library/multiprocessing.rst:2541
msgid ""
"The following code uses :func:`~multiprocessing.connection.wait` to wait for "
"messages from multiple processes at once::"
msgstr ""

#: ../../library/multiprocessing.rst:2580
msgid "Address Formats"
msgstr "Formatos de Endereços"

#: ../../library/multiprocessing.rst:2582
msgid ""
"An ``'AF_INET'`` address is a tuple of the form ``(hostname, port)`` where "
"*hostname* is a string and *port* is an integer."
msgstr ""
"Um endereço ``'AF_INET'`` é uma tupla na forma de ``(hostname, port)`` sendo "
"*hostname* uma string e *port* um inteiro."

#: ../../library/multiprocessing.rst:2585
msgid ""
"An ``'AF_UNIX'`` address is a string representing a filename on the "
"filesystem."
msgstr ""

#: ../../library/multiprocessing.rst:2588
msgid ""
"An ``'AF_PIPE'`` address is a string of the form :samp:`r'\\\\\\\\.\\\\pipe\\"
"\\{PipeName}'`.  To use :func:`Client` to connect to a named pipe on a "
"remote computer called *ServerName* one should use an address of the form :"
"samp:`r'\\\\\\\\{ServerName}\\\\pipe\\\\{PipeName}'` instead."
msgstr ""

#: ../../library/multiprocessing.rst:2593
msgid ""
"Note that any string beginning with two backslashes is assumed by default to "
"be an ``'AF_PIPE'`` address rather than an ``'AF_UNIX'`` address."
msgstr ""

#: ../../library/multiprocessing.rst:2600
msgid "Authentication keys"
msgstr ""

#: ../../library/multiprocessing.rst:2602
msgid ""
"When one uses :meth:`Connection.recv <Connection.recv>`, the data received "
"is automatically unpickled. Unfortunately unpickling data from an untrusted "
"source is a security risk. Therefore :class:`Listener` and :func:`Client` "
"use the :mod:`hmac` module to provide digest authentication."
msgstr ""

#: ../../library/multiprocessing.rst:2608
msgid ""
"An authentication key is a byte string which can be thought of as a "
"password: once a connection is established both ends will demand proof that "
"the other knows the authentication key.  (Demonstrating that both ends are "
"using the same key does **not** involve sending the key over the connection.)"
msgstr ""

#: ../../library/multiprocessing.rst:2614
msgid ""
"If authentication is requested but no authentication key is specified then "
"the return value of ``current_process().authkey`` is used (see :class:"
"`~multiprocessing.Process`).  This value will be automatically inherited by "
"any :class:`~multiprocessing.Process` object that the current process "
"creates. This means that (by default) all processes of a multi-process "
"program will share a single authentication key which can be used when "
"setting up connections between themselves."
msgstr ""

#: ../../library/multiprocessing.rst:2622
msgid ""
"Suitable authentication keys can also be generated by using :func:`os."
"urandom`."
msgstr ""

#: ../../library/multiprocessing.rst:2626
msgid "Logging"
msgstr "Gerando logs"

#: ../../library/multiprocessing.rst:2628
msgid ""
"Some support for logging is available.  Note, however, that the :mod:"
"`logging` package does not use process shared locks so it is possible "
"(depending on the handler type) for messages from different processes to get "
"mixed up."
msgstr ""

#: ../../library/multiprocessing.rst:2635
msgid ""
"Returns the logger used by :mod:`multiprocessing`.  If necessary, a new one "
"will be created."
msgstr ""

#: ../../library/multiprocessing.rst:2638
msgid ""
"When first created the logger has level :data:`logging.NOTSET` and no "
"default handler. Messages sent to this logger will not by default propagate "
"to the root logger."
msgstr ""

#: ../../library/multiprocessing.rst:2642
msgid ""
"Note that on Windows child processes will only inherit the level of the "
"parent process's logger -- any other customization of the logger will not be "
"inherited."
msgstr ""

#: ../../library/multiprocessing.rst:2649
msgid ""
"This function performs a call to :func:`get_logger` but in addition to "
"returning the logger created by get_logger, it adds a handler which sends "
"output to :data:`sys.stderr` using format ``'[%(levelname)s/%(processName)s] "
"%(message)s'``. You can modify ``levelname`` of the logger by passing a "
"``level`` argument."
msgstr ""

#: ../../library/multiprocessing.rst:2655
msgid "Below is an example session with logging turned on::"
msgstr ""

#: ../../library/multiprocessing.rst:2670
msgid "For a full table of logging levels, see the :mod:`logging` module."
msgstr ""

#: ../../library/multiprocessing.rst:2674
msgid "The :mod:`multiprocessing.dummy` module"
msgstr ""

#: ../../library/multiprocessing.rst:2679
msgid ""
":mod:`multiprocessing.dummy` replicates the API of :mod:`multiprocessing` "
"but is no more than a wrapper around the :mod:`threading` module."
msgstr ""

#: ../../library/multiprocessing.rst:2684
msgid ""
"In particular, the ``Pool`` function provided by :mod:`multiprocessing."
"dummy` returns an instance of :class:`ThreadPool`, which is a subclass of :"
"class:`Pool` that supports all the same method calls but uses a pool of "
"worker threads rather than worker processes."
msgstr ""

#: ../../library/multiprocessing.rst:2692
msgid ""
"A thread pool object which controls a pool of worker threads to which jobs "
"can be submitted.  :class:`ThreadPool` instances are fully interface "
"compatible with :class:`Pool` instances, and their resources must also be "
"properly managed, either by using the pool as a context manager or by "
"calling :meth:`~multiprocessing.pool.Pool.close` and :meth:`~multiprocessing."
"pool.Pool.terminate` manually."
msgstr ""

#: ../../library/multiprocessing.rst:2699
msgid ""
"*processes* is the number of worker threads to use.  If *processes* is "
"``None`` then the number returned by :func:`os.cpu_count` is used."
msgstr ""

#: ../../library/multiprocessing.rst:2705
msgid ""
"Unlike :class:`Pool`, *maxtasksperchild* and *context* cannot be provided."
msgstr ""

#: ../../library/multiprocessing.rst:2709
msgid ""
"A :class:`ThreadPool` shares the same interface as :class:`Pool`, which is "
"designed around a pool of processes and predates the introduction of the :"
"class:`concurrent.futures` module.  As such, it inherits some operations "
"that don't make sense for a pool backed by threads, and it has its own type "
"for representing the status of asynchronous jobs, :class:`AsyncResult`, that "
"is not understood by any other libraries."
msgstr ""

#: ../../library/multiprocessing.rst:2716
msgid ""
"Users should generally prefer to use :class:`concurrent.futures."
"ThreadPoolExecutor`, which has a simpler interface that was designed around "
"threads from the start, and which returns :class:`concurrent.futures.Future` "
"instances that are compatible with many other libraries, including :mod:"
"`asyncio`."
msgstr ""

#: ../../library/multiprocessing.rst:2726
msgid "Programming guidelines"
msgstr ""

#: ../../library/multiprocessing.rst:2728
msgid ""
"There are certain guidelines and idioms which should be adhered to when "
"using :mod:`multiprocessing`."
msgstr ""

#: ../../library/multiprocessing.rst:2733
msgid "All start methods"
msgstr ""

#: ../../library/multiprocessing.rst:2735
msgid "The following applies to all start methods."
msgstr ""

#: ../../library/multiprocessing.rst:2737
msgid "Avoid shared state"
msgstr ""

#: ../../library/multiprocessing.rst:2739
msgid ""
"As far as possible one should try to avoid shifting large amounts of data "
"between processes."
msgstr ""

#: ../../library/multiprocessing.rst:2742
msgid ""
"It is probably best to stick to using queues or pipes for communication "
"between processes rather than using the lower level synchronization "
"primitives."
msgstr ""

#: ../../library/multiprocessing.rst:2746
msgid "Picklability"
msgstr ""

#: ../../library/multiprocessing.rst:2748
msgid "Ensure that the arguments to the methods of proxies are picklable."
msgstr ""

#: ../../library/multiprocessing.rst:2750
msgid "Thread safety of proxies"
msgstr ""

#: ../../library/multiprocessing.rst:2752
msgid ""
"Do not use a proxy object from more than one thread unless you protect it "
"with a lock."
msgstr ""

#: ../../library/multiprocessing.rst:2755
msgid ""
"(There is never a problem with different processes using the *same* proxy.)"
msgstr ""

#: ../../library/multiprocessing.rst:2757
msgid "Joining zombie processes"
msgstr ""

#: ../../library/multiprocessing.rst:2759
msgid ""
"On Unix when a process finishes but has not been joined it becomes a zombie. "
"There should never be very many because each time a new process starts (or :"
"func:`~multiprocessing.active_children` is called) all completed processes "
"which have not yet been joined will be joined.  Also calling a finished "
"process's :meth:`Process.is_alive <multiprocessing.Process.is_alive>` will "
"join the process.  Even so it is probably good practice to explicitly join "
"all the processes that you start."
msgstr ""

#: ../../library/multiprocessing.rst:2767
msgid "Better to inherit than pickle/unpickle"
msgstr ""

#: ../../library/multiprocessing.rst:2769
msgid ""
"When using the *spawn* or *forkserver* start methods many types from :mod:"
"`multiprocessing` need to be picklable so that child processes can use "
"them.  However, one should generally avoid sending shared objects to other "
"processes using pipes or queues. Instead you should arrange the program so "
"that a process which needs access to a shared resource created elsewhere can "
"inherit it from an ancestor process."
msgstr ""

#: ../../library/multiprocessing.rst:2777
msgid "Avoid terminating processes"
msgstr ""

#: ../../library/multiprocessing.rst:2779
msgid ""
"Using the :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"method to stop a process is liable to cause any shared resources (such as "
"locks, semaphores, pipes and queues) currently being used by the process to "
"become broken or unavailable to other processes."
msgstr ""

#: ../../library/multiprocessing.rst:2785
msgid ""
"Therefore it is probably best to only consider using :meth:`Process."
"terminate <multiprocessing.Process.terminate>` on processes which never use "
"any shared resources."
msgstr ""

#: ../../library/multiprocessing.rst:2789
msgid "Joining processes that use queues"
msgstr ""

#: ../../library/multiprocessing.rst:2791
msgid ""
"Bear in mind that a process that has put items in a queue will wait before "
"terminating until all the buffered items are fed by the \"feeder\" thread to "
"the underlying pipe.  (The child process can call the :meth:`Queue."
"cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` method of the "
"queue to avoid this behaviour.)"
msgstr ""

#: ../../library/multiprocessing.rst:2797
msgid ""
"This means that whenever you use a queue you need to make sure that all "
"items which have been put on the queue will eventually be removed before the "
"process is joined.  Otherwise you cannot be sure that processes which have "
"put items on the queue will terminate.  Remember also that non-daemonic "
"processes will be joined automatically."
msgstr ""

#: ../../library/multiprocessing.rst:2803
msgid "An example which will deadlock is the following::"
msgstr ""

#: ../../library/multiprocessing.rst:2817
msgid ""
"A fix here would be to swap the last two lines (or simply remove the ``p."
"join()`` line)."
msgstr ""

#: ../../library/multiprocessing.rst:2820
msgid "Explicitly pass resources to child processes"
msgstr ""

#: ../../library/multiprocessing.rst:2822
msgid ""
"On Unix using the *fork* start method, a child process can make use of a "
"shared resource created in a parent process using a global resource.  "
"However, it is better to pass the object as an argument to the constructor "
"for the child process."
msgstr ""

#: ../../library/multiprocessing.rst:2827
msgid ""
"Apart from making the code (potentially) compatible with Windows and the "
"other start methods this also ensures that as long as the child process is "
"still alive the object will not be garbage collected in the parent process.  "
"This might be important if some resource is freed when the object is garbage "
"collected in the parent process."
msgstr ""

#: ../../library/multiprocessing.rst:2834
msgid "So for instance ::"
msgstr ""

#: ../../library/multiprocessing.rst:2846
msgid "should be rewritten as ::"
msgstr ""

#: ../../library/multiprocessing.rst:2858
msgid "Beware of replacing :data:`sys.stdin` with a \"file like object\""
msgstr ""

#: ../../library/multiprocessing.rst:2860
msgid ":mod:`multiprocessing` originally unconditionally called::"
msgstr ""

#: ../../library/multiprocessing.rst:2864
msgid ""
"in the :meth:`multiprocessing.Process._bootstrap` method --- this resulted "
"in issues with processes-in-processes. This has been changed to::"
msgstr ""

#: ../../library/multiprocessing.rst:2870
msgid ""
"Which solves the fundamental issue of processes colliding with each other "
"resulting in a bad file descriptor error, but introduces a potential danger "
"to applications which replace :func:`sys.stdin` with a \"file-like object\" "
"with output buffering.  This danger is that if multiple processes call :meth:"
"`~io.IOBase.close()` on this file-like object, it could result in the same "
"data being flushed to the object multiple times, resulting in corruption."
msgstr ""

#: ../../library/multiprocessing.rst:2877
msgid ""
"If you write a file-like object and implement your own caching, you can make "
"it fork-safe by storing the pid whenever you append to the cache, and "
"discarding the cache when the pid changes. For example::"
msgstr ""

#: ../../library/multiprocessing.rst:2889
msgid ""
"For more information, see :issue:`5155`, :issue:`5313` and :issue:`5331`"
msgstr ""

#: ../../library/multiprocessing.rst:2892
msgid "The *spawn* and *forkserver* start methods"
msgstr ""

#: ../../library/multiprocessing.rst:2894
msgid ""
"There are a few extra restriction which don't apply to the *fork* start "
"method."
msgstr ""

#: ../../library/multiprocessing.rst:2897
msgid "More picklability"
msgstr ""

#: ../../library/multiprocessing.rst:2899
msgid ""
"Ensure that all arguments to :meth:`Process.__init__` are picklable. Also, "
"if you subclass :class:`~multiprocessing.Process` then make sure that "
"instances will be picklable when the :meth:`Process.start <multiprocessing."
"Process.start>` method is called."
msgstr ""

#: ../../library/multiprocessing.rst:2904
msgid "Global variables"
msgstr ""

#: ../../library/multiprocessing.rst:2906
msgid ""
"Bear in mind that if code run in a child process tries to access a global "
"variable, then the value it sees (if any) may not be the same as the value "
"in the parent process at the time that :meth:`Process.start <multiprocessing."
"Process.start>` was called."
msgstr ""

#: ../../library/multiprocessing.rst:2911
msgid ""
"However, global variables which are just module level constants cause no "
"problems."
msgstr ""

#: ../../library/multiprocessing.rst:2914
msgid "Safe importing of main module"
msgstr ""

#: ../../library/multiprocessing.rst:2916
msgid ""
"Make sure that the main module can be safely imported by a new Python "
"interpreter without causing unintended side effects (such a starting a new "
"process)."
msgstr ""

#: ../../library/multiprocessing.rst:2920
msgid ""
"For example, using the *spawn* or *forkserver* start method running the "
"following module would fail with a :exc:`RuntimeError`::"
msgstr ""

#: ../../library/multiprocessing.rst:2932
msgid ""
"Instead one should protect the \"entry point\" of the program by using ``if "
"__name__ == '__main__':`` as follows::"
msgstr ""

#: ../../library/multiprocessing.rst:2946
msgid ""
"(The ``freeze_support()`` line can be omitted if the program will be run "
"normally instead of frozen.)"
msgstr ""

#: ../../library/multiprocessing.rst:2949
msgid ""
"This allows the newly spawned Python interpreter to safely import the module "
"and then run the module's ``foo()`` function."
msgstr ""

#: ../../library/multiprocessing.rst:2952
msgid ""
"Similar restrictions apply if a pool or manager is created in the main "
"module."
msgstr ""

#: ../../library/multiprocessing.rst:2959
msgid "Examples"
msgstr "Exemplos"

#: ../../library/multiprocessing.rst:2961
msgid "Demonstration of how to create and use customized managers and proxies:"
msgstr ""

#: ../../library/multiprocessing.rst:2967
msgid "Using :class:`~multiprocessing.pool.Pool`:"
msgstr ""

#: ../../library/multiprocessing.rst:2973
msgid ""
"An example showing how to use queues to feed tasks to a collection of worker "
"processes and collect the results:"
msgstr ""

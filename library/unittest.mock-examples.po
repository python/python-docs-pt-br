# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 16:41+0000\n"
"PO-Revision-Date: 2023-05-24 02:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/unittest.mock-examples.rst:2
msgid ":mod:`unittest.mock` --- getting started"
msgstr ":mod:`unittest.mock` --- primeiros passos"

#: ../../library/unittest.mock-examples.rst:27
msgid "Using Mock"
msgstr "Usando Mock"

#: ../../library/unittest.mock-examples.rst:30
msgid "Mock Patching Methods"
msgstr "Métodos de aplicação de patches em Mock"

#: ../../library/unittest.mock-examples.rst:32
msgid "Common uses for :class:`Mock` objects include:"
msgstr "Usos comuns para objetos :class:`Mock` incluem:"

#: ../../library/unittest.mock-examples.rst:34
msgid "Patching methods"
msgstr "Métodos de aplicação de patches"

#: ../../library/unittest.mock-examples.rst:35
msgid "Recording method calls on objects"
msgstr "Método de gravação que invoca objetos"

#: ../../library/unittest.mock-examples.rst:37
msgid ""
"You might want to replace a method on an object to check that it is called "
"with the correct arguments by another part of the system:"
msgstr ""
"Talvez você queira substituir um método em um objeto para verificar se ele "
"foi chamado com os argumentos corretos por outra parte do sistema:"

#: ../../library/unittest.mock-examples.rst:45
msgid ""
"Once our mock has been used (``real.method`` in this example) it has methods "
"and attributes that allow you to make assertions about how it has been used."
msgstr ""
"Depois que nosso mock for usado (``real.method`` neste exemplo), ele terá "
"métodos e atributos que permitem que você faça afirmações sobre como ele foi "
"usado."

#: ../../library/unittest.mock-examples.rst:50
msgid ""
"In most of these examples the :class:`Mock` and :class:`MagicMock` classes "
"are interchangeable. As the ``MagicMock`` is the more capable class it makes "
"a sensible one to use by default."
msgstr ""
"Na maioria desses exemplos, as classes :class:`Mock` e :class:`MagicMock` "
"são intercambiáveis. Como a ``MagicMock`` é a classe mais capaz, ela faz "
"sentido para ser usada por padrão."

#: ../../library/unittest.mock-examples.rst:54
msgid ""
"Once the mock has been called its :attr:`~Mock.called` attribute is set to "
"``True``. More importantly we can use the :meth:`~Mock.assert_called_with` "
"or :meth:`~Mock.assert_called_once_with` method to check that it was called "
"with the correct arguments."
msgstr ""
"Uma vez que o mock foi chamado, seu atributo :attr:`~Mock.called` é definido "
"como ``True``. Mais importante, podemos usar o método :meth:`~Mock."
"assert_called_with` ou :meth:`~Mock.assert_called_once_with` para verificar "
"se ele foi chamado com os argumentos corretos."

#: ../../library/unittest.mock-examples.rst:59
msgid ""
"This example tests that calling ``ProductionClass().method`` results in a "
"call to the ``something`` method:"
msgstr ""
"Este exemplo testa se a chamada de ``ProductionClass().method`` resulta em "
"uma chamada para o método ``something``:"

#: ../../library/unittest.mock-examples.rst:76
msgid "Mock for Method Calls on an Object"
msgstr "Mock de chamadas de métodos em um objeto"

#: ../../library/unittest.mock-examples.rst:78
msgid ""
"In the last example we patched a method directly on an object to check that "
"it was called correctly. Another common use case is to pass an object into a "
"method (or some part of the system under test) and then check that it is "
"used in the correct way."
msgstr ""
"No último exemplo, aplicamos um patch em um método diretamente em um objeto "
"para verificar se ele foi chamado corretamente. Outro caso de uso comum é "
"passar um objeto para um método (ou alguma parte do sistema em teste) e "
"então verificar se ele é usado da maneira correta."

#: ../../library/unittest.mock-examples.rst:83
msgid ""
"The simple ``ProductionClass`` below has a ``closer`` method. If it is "
"called with an object then it calls ``close`` on it."
msgstr ""
"O ``ProductionClass`` simples abaixo tem um método ``closer``. Se ele for "
"chamado com um objeto, então ele chama ``close`` nele."

#: ../../library/unittest.mock-examples.rst:91
msgid ""
"So to test it we need to pass in an object with a ``close`` method and check "
"that it was called correctly."
msgstr ""
"Então, para testá-lo, precisamos passar um objeto com um método ``close`` e "
"verificar se ele foi chamado corretamente."

#: ../../library/unittest.mock-examples.rst:99
msgid ""
"We don't have to do any work to provide the 'close' method on our mock. "
"Accessing close creates it. So, if 'close' hasn't already been called then "
"accessing it in the test will create it, but :meth:`~Mock."
"assert_called_with` will raise a failure exception."
msgstr ""
"Não precisamos fazer nenhum trabalho para fornecer o método 'close' em nosso "
"mock. Acessar close o cria. Então, se 'close' ainda não foi chamado, acessá-"
"lo no teste o criará, mas :meth:`~Mock.assert_called_with` levantará uma "
"exceção de falha."

#: ../../library/unittest.mock-examples.rst:106
msgid "Mocking Classes"
msgstr "Знущальні класи"

#: ../../library/unittest.mock-examples.rst:108
msgid ""
"A common use case is to mock out classes instantiated by your code under "
"test. When you patch a class, then that class is replaced with a mock. "
"Instances are created by *calling the class*. This means you access the "
"\"mock instance\" by looking at the return value of the mocked class."
msgstr ""
"Поширений випадок використання - це макетування класів, створених вашим "
"тестованим кодом. Коли ви виправляєте клас, цей клас замінюється макетом. "
"Екземпляри створюються шляхом *виклику класу*. Це означає, що ви отримуєте "
"доступ до \"макетного екземпляра\", дивлячись на значення, що повертається "
"імітованим класом."

#: ../../library/unittest.mock-examples.rst:113
msgid ""
"In the example below we have a function ``some_function`` that instantiates "
"``Foo`` and calls a method on it. The call to :func:`patch` replaces the "
"class ``Foo`` with a mock. The ``Foo`` instance is the result of calling the "
"mock, so it is configured by modifying the mock :attr:`~Mock."
"return_value`. ::"
msgstr ""
"У наведеному нижче прикладі ми маємо функцію ``some_function``, яка створює "
"екземпляр ``Foo`` і викликає на ньому метод. Виклик :func:`patch` замінює "
"клас ``Foo`` на макет. Екземпляр ``Foo`` є результатом виклику mock, тому "
"він налаштовується шляхом модифікації mock :attr:`~Mock.return_value`. ::"

#: ../../library/unittest.mock-examples.rst:130
msgid "Naming your mocks"
msgstr "Nomeando os mocks"

#: ../../library/unittest.mock-examples.rst:132
msgid ""
"It can be useful to give your mocks a name. The name is shown in the repr of "
"the mock and can be helpful when the mock appears in test failure messages. "
"The name is also propagated to attributes or methods of the mock:"
msgstr ""
"Може бути корисно дати своїм макетам назву. Ім’я відображається у "
"відображенні макета та може бути корисним, коли макет з’являється в "
"повідомленнях про помилку тесту. Назва також поширюється на атрибути або "
"методи макета:"

#: ../../library/unittest.mock-examples.rst:144
msgid "Tracking all Calls"
msgstr "Rastreando todas as chamadas"

#: ../../library/unittest.mock-examples.rst:146
msgid ""
"Often you want to track more than a single call to a method. The :attr:"
"`~Mock.mock_calls` attribute records all calls to child attributes of the "
"mock - and also to their children."
msgstr ""
"Frequentemente você quer rastrear mais de uma chamada para um método. O "
"atributo :attr:`~Mock.mock_calls` registra todas as chamadas para atributos "
"filhos do mock - e também para seus filhos."

#: ../../library/unittest.mock-examples.rst:158
msgid ""
"If you make an assertion about ``mock_calls`` and any unexpected methods "
"have been called, then the assertion will fail. This is useful because as "
"well as asserting that the calls you expected have been made, you are also "
"checking that they were made in the right order and with no additional calls:"
msgstr ""
"Якщо ви робите твердження щодо ``mock_calls`` і були викликані будь-які "
"неочікувані методи, тоді твердження не вдасться. Це корисно, оскільки ви не "
"тільки стверджуєте, що дзвінки, які ви очікували, були здійснені, але й "
"перевіряєте, що вони були здійснені в правильному порядку та без додаткових "
"дзвінків:"

#: ../../library/unittest.mock-examples.rst:163
msgid ""
"You use the :data:`call` object to construct lists for comparing with "
"``mock_calls``:"
msgstr ""
"Ви використовуєте об’єкт :data:`call` для створення списків для порівняння з "
"``mock_calls``:"

#: ../../library/unittest.mock-examples.rst:170
msgid ""
"However, parameters to calls that return mocks are not recorded, which means "
"it is not possible to track nested calls where the parameters used to create "
"ancestors are important:"
msgstr ""
"Однак параметри викликів, які повертають імітації, не записуються, що "
"означає, що неможливо відстежувати вкладені виклики, де важливі параметри, "
"які використовуються для створення предків:"

#: ../../library/unittest.mock-examples.rst:181
msgid "Setting Return Values and Attributes"
msgstr "Налаштування повернених значень і атрибутів"

#: ../../library/unittest.mock-examples.rst:183
msgid "Setting the return values on a mock object is trivially easy:"
msgstr ""
"Встановлення повернених значень для макетного об’єкта тривіально легко:"

#: ../../library/unittest.mock-examples.rst:190
msgid "Of course you can do the same for methods on the mock:"
msgstr "Звичайно, ви можете зробити те саме для методів на mock:"

#: ../../library/unittest.mock-examples.rst:197
msgid "The return value can also be set in the constructor:"
msgstr "Повернене значення також можна встановити в конструкторі:"

#: ../../library/unittest.mock-examples.rst:203
msgid "If you need an attribute setting on your mock, just do it:"
msgstr "Якщо вам потрібне налаштування атрибута на макеті, просто зробіть це:"

#: ../../library/unittest.mock-examples.rst:210
msgid ""
"Sometimes you want to mock up a more complex situation, like for example "
"``mock.connection.cursor().execute(\"SELECT 1\")``. If we wanted this call "
"to return a list, then we have to configure the result of the nested call."
msgstr ""
"Іноді потрібно змакувати складнішу ситуацію, як, наприклад, ``mock."
"connection.cursor().execute(\"SELECT 1\")``. Якщо ми хочемо, щоб цей виклик "
"повертав список, ми повинні налаштувати результат вкладеного виклику."

#: ../../library/unittest.mock-examples.rst:214
msgid ""
"We can use :data:`call` to construct the set of calls in a \"chained call\" "
"like this for easy assertion afterwards:"
msgstr ""
"Ми можемо використовувати :data:`call`, щоб створити набір викликів у "
"\"ланцюжковому виклику\", подібному до цього для легкого твердження згодом:"

#: ../../library/unittest.mock-examples.rst:228
msgid ""
"It is the call to ``.call_list()`` that turns our call object into a list of "
"calls representing the chained calls."
msgstr ""
"Саме виклик ``.call_list()`` перетворює наш об’єкт виклику на список "
"викликів, що представляють ланцюгові виклики."

#: ../../library/unittest.mock-examples.rst:233
msgid "Raising exceptions with mocks"
msgstr "Створення винятків за допомогою моків"

#: ../../library/unittest.mock-examples.rst:235
msgid ""
"A useful attribute is :attr:`~Mock.side_effect`. If you set this to an "
"exception class or instance then the exception will be raised when the mock "
"is called."
msgstr ""
"Корисним атрибутом є :attr:`~Mock.side_effect`. Якщо ви встановите це як "
"клас винятку або екземпляр, тоді виняток буде викликано під час виклику "
"макета."

#: ../../library/unittest.mock-examples.rst:247
msgid "Side effect functions and iterables"
msgstr "Функції побічних ефектів та ітерації"

#: ../../library/unittest.mock-examples.rst:249
msgid ""
"``side_effect`` can also be set to a function or an iterable. The use case "
"for ``side_effect`` as an iterable is where your mock is going to be called "
"several times, and you want each call to return a different value. When you "
"set ``side_effect`` to an iterable every call to the mock returns the next "
"value from the iterable:"
msgstr ""
"``side_effect`` також може бути встановлено як функція або iterable. Варіант "
"використання ``side_effect`` як ітерації полягає в тому, що ваш макет буде "
"викликатися кілька разів, і ви хочете, щоб кожен виклик повертав інше "
"значення. Коли ви встановлюєте ``side_effect`` на iterable, кожен виклик "
"mock повертає наступне значення з iterable:"

#: ../../library/unittest.mock-examples.rst:264
msgid ""
"For more advanced use cases, like dynamically varying the return values "
"depending on what the mock is called with, ``side_effect`` can be a "
"function. The function will be called with the same arguments as the mock. "
"Whatever the function returns is what the call returns:"
msgstr ""
"Для більш складних випадків використання, як-от динамічне змінення "
"повернених значень залежно від того, з чим викликається макет, "
"``side_effect`` може бути функцією. Функція буде викликана з тими самими "
"аргументами, що й макет. Усе, що повертає функція, повертає виклик:"

#: ../../library/unittest.mock-examples.rst:281
msgid "Mocking asynchronous iterators"
msgstr "Знущання над асинхронними ітераторами"

#: ../../library/unittest.mock-examples.rst:283
msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock :ref:"
"`async-iterators` through ``__aiter__``. The :attr:`~Mock.return_value` "
"attribute of ``__aiter__`` can be used to set the return values to be used "
"for iteration."
msgstr ""
"Починаючи з Python 3.8, ``AsyncMock`` і ``MagicMock`` підтримують імітацію :"
"ref:`async-iterators` через ``__aiter__``. Атрибут :attr:`~Mock."
"return_value` ``__aiter__`` можна використовувати для встановлення "
"повернених значень, які будуть використовуватися для ітерації."

#: ../../library/unittest.mock-examples.rst:298
msgid "Mocking asynchronous context manager"
msgstr "Знущання над асинхронним контекстним менеджером"

#: ../../library/unittest.mock-examples.rst:300
msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock :ref:"
"`async-context-managers` through ``__aenter__`` and ``__aexit__``. By "
"default, ``__aenter__`` and ``__aexit__`` are ``AsyncMock`` instances that "
"return an async function."
msgstr ""
"Починаючи з Python 3.8, ``AsyncMock`` і ``MagicMock`` підтримують імітацію :"
"ref:`async-context-managers` через ``__aenter__`` і ``__aexit__``. За "
"замовчуванням ``__aenter__`` і ``__aexit__`` є екземплярами ``AsyncMock``, "
"які повертають асинхронну функцію."

#: ../../library/unittest.mock-examples.rst:322
msgid "Creating a Mock from an Existing Object"
msgstr "Створення макету з існуючого об’єкта"

#: ../../library/unittest.mock-examples.rst:324
msgid ""
"One problem with over use of mocking is that it couples your tests to the "
"implementation of your mocks rather than your real code. Suppose you have a "
"class that implements ``some_method``. In a test for another class, you "
"provide a mock of this object that *also* provides ``some_method``. If later "
"you refactor the first class, so that it no longer has ``some_method`` - "
"then your tests will continue to pass even though your code is now broken!"
msgstr ""
"Однією з проблем із надмірним використанням mocking є те, що воно поєднує "
"ваші тести з реалізацією ваших mocks, а не з вашим реальним кодом. "
"Припустімо, у вас є клас, який реалізує ``some_method``. У тесті для іншого "
"класу ви надаєте макет цього об’єкта, який *також* надає ``some_method``. "
"Якщо пізніше ви переробите перший клас, щоб він більше не мав "
"``some_method``, тоді ваші тести продовжуватимуть проходити, навіть якщо ваш "
"код зараз зламаний!"

#: ../../library/unittest.mock-examples.rst:331
msgid ""
":class:`Mock` allows you to provide an object as a specification for the "
"mock, using the *spec* keyword argument. Accessing methods / attributes on "
"the mock that don't exist on your specification object will immediately "
"raise an attribute error. If you change the implementation of your "
"specification, then tests that use that class will start failing immediately "
"without you having to instantiate the class in those tests."
msgstr ""
":class:`Mock` дозволяє вам надати об’єкт як специфікацію для mock, "
"використовуючи аргумент ключового слова *spec*. Доступ до методів/атрибутів "
"у макеті, які не існують у вашому об’єкті специфікації, негайно призведе до "
"помилки атрибута. Якщо ви зміните реалізацію вашої специфікації, тоді тести, "
"які використовують цей клас, негайно почнуть виходити з ладу без "
"необхідності створення екземпляра класу в цих тестах."

#: ../../library/unittest.mock-examples.rst:344
msgid ""
"Using a specification also enables a smarter matching of calls made to the "
"mock, regardless of whether some parameters were passed as positional or "
"named arguments::"
msgstr ""
"Використання специфікації також дає змогу розумніше зіставляти виклики, "
"зроблені для mock, незалежно від того, чи були деякі параметри передані як "
"позиційні чи іменовані аргументи:"

#: ../../library/unittest.mock-examples.rst:355
msgid ""
"If you want this smarter matching to also work with method calls on the "
"mock, you can use :ref:`auto-speccing <auto-speccing>`."
msgstr ""
"Якщо ви бажаєте, щоб ця розумніша відповідність також працювала з викликами "
"методів на mock, ви можете використовувати :ref:`auto-speccing <auto-"
"speccing>`."

#: ../../library/unittest.mock-examples.rst:358
msgid ""
"If you want a stronger form of specification that prevents the setting of "
"arbitrary attributes as well as the getting of them then you can use "
"*spec_set* instead of *spec*."
msgstr ""
"Якщо вам потрібна сильніша форма специфікації, яка запобігає встановленню "
"довільних атрибутів, а також їх отриманню, ви можете використовувати "
"*spec_set* замість *spec*."

#: ../../library/unittest.mock-examples.rst:364
msgid "Using side_effect to return per file content"
msgstr "Использование Side_effect для возврата содержимого файла"

#: ../../library/unittest.mock-examples.rst:366
msgid ""
":func:`mock_open` is used to patch :func:`open` method. :attr:`~Mock."
"side_effect` can be used to return a new Mock object per call. This can be "
"used to return different contents per file stored in a dictionary::"
msgstr ""
":func:`mock_open` используется для исправления метода :func:`open`. :attr:"
"`~Mock.side_effect` можно использовать для возврата нового объекта Mock при "
"каждом вызове. Это можно использовать для возврата различного содержимого "
"для каждого файла, хранящегося в словаре::"

#: ../../library/unittest.mock-examples.rst:389
msgid "Patch Decorators"
msgstr "Декоратори патчів"

#: ../../library/unittest.mock-examples.rst:393
msgid ""
"With :func:`patch` it matters that you patch objects in the namespace where "
"they are looked up. This is normally straightforward, but for a quick guide "
"read :ref:`where to patch <where-to-patch>`."
msgstr ""
"Com :func:`patch`, é importante que você faça o patch de objetos no espaço "
"de nomes onde eles são procurados. Normalmente, isso é simples, mas para um "
"guia rápido, leia :ref:`onde fazer o patch <where-to-patch>`."

#: ../../library/unittest.mock-examples.rst:398
msgid ""
"A common need in tests is to patch a class attribute or a module attribute, "
"for example patching a builtin or patching a class in a module to test that "
"it is instantiated. Modules and classes are effectively global, so patching "
"on them has to be undone after the test or the patch will persist into other "
"tests and cause hard to diagnose problems."
msgstr ""
"Загальною потребою в тестах є виправлення атрибута класу або атрибута "
"модуля, наприклад, виправлення вбудованого модуля або виправлення класу в "
"модулі, щоб перевірити, чи створено його екземпляр. Модулі та класи фактично "
"є глобальними, тому після тесту потрібно скасувати їх виправлення, інакше "
"виправлення збережеться в інших тестах і спричинить проблеми, які важко "
"діагностувати."

#: ../../library/unittest.mock-examples.rst:404
msgid ""
"mock provides three convenient decorators for this: :func:`patch`, :func:"
"`patch.object` and :func:`patch.dict`. ``patch`` takes a single string, of "
"the form ``package.module.Class.attribute`` to specify the attribute you are "
"patching. It also optionally takes a value that you want the attribute (or "
"class or whatever) to be replaced with. 'patch.object' takes an object and "
"the name of the attribute you would like patched, plus optionally the value "
"to patch it with."
msgstr ""
"mock надає для цього три зручні декоратори: :func:`patch`, :func:`patch."
"object` і :func:`patch.dict`. ``patch`` приймає один рядок у формі ``package."
"module.Class.attribute``, щоб визначити атрибут, який ви виправляєте. Він "
"також необов’язково приймає значення, яким ви бажаєте замінити атрибут (або "
"клас чи щось інше). 'patch.object' приймає об'єкт і ім'я атрибута, який ви "
"бажаєте виправити, а також необов'язково значення, з яким його потрібно "
"виправити."

#: ../../library/unittest.mock-examples.rst:412
msgid "``patch.object``::"
msgstr "``patch.object``::"

#: ../../library/unittest.mock-examples.rst:429
msgid ""
"If you are patching a module (including :mod:`builtins`) then use :func:"
"`patch` instead of :func:`patch.object`:"
msgstr ""
"Якщо ви виправляєте модуль (включаючи :mod:`builtins`), використовуйте :func:"
"`patch` замість :func:`patch.object`:"

#: ../../library/unittest.mock-examples.rst:439
msgid ""
"The module name can be 'dotted', in the form ``package.module`` if needed::"
msgstr ""
"Ім’я модуля може бути розділене крапкою у формі ``package.module``, якщо "
"необхідно:"

#: ../../library/unittest.mock-examples.rst:448
msgid "A nice pattern is to actually decorate test methods themselves:"
msgstr "Хороший зразок — це фактично прикрасити самі методи тестування:"

#: ../../library/unittest.mock-examples.rst:459
msgid ""
"If you want to patch with a Mock, you can use :func:`patch` with only one "
"argument (or :func:`patch.object` with two arguments). The mock will be "
"created for you and passed into the test function / method:"
msgstr ""
"Якщо ви хочете виправити за допомогою Mock, ви можете використовувати :func:"
"`patch` лише з одним аргументом (або :func:`patch.object` з двома "
"аргументами). Макет буде створено для вас і передано в тестову функцію/метод:"

#: ../../library/unittest.mock-examples.rst:471
msgid "You can stack up multiple patch decorators using this pattern::"
msgstr ""
"Ви можете скласти кілька декораторів патчів, використовуючи цей шаблон:"

#: ../../library/unittest.mock-examples.rst:482
msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example "
"above the mock for ``test_module.ClassName2`` is passed in first."
msgstr ""
"Коли ви вкладаєте декоратори латок, макети передаються до декорованої "
"функції в тому ж порядку, в якому вони застосовані (звичайний *Python* "
"порядок застосування декораторів). Це означає знизу вгору, тому у наведеному "
"вище прикладі спочатку передається макет для ``test_module.ClassName2``."

#: ../../library/unittest.mock-examples.rst:487
msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when the "
"test ends:"
msgstr ""
"Também existe :func:`patch.dict` para definir valores em um dicionário "
"apenas durante um escopo e restaurar o dicionário ao seu estado original "
"quando o teste termina:"

#: ../../library/unittest.mock-examples.rst:498
msgid ""
"``patch``, ``patch.object`` and ``patch.dict`` can all be used as context "
"managers."
msgstr ""
"``patch``, ``patch.object`` і ``patch.dict`` можна використовувати як "
"контекстні менеджери."

#: ../../library/unittest.mock-examples.rst:500
msgid ""
"Where you use :func:`patch` to create a mock for you, you can get a "
"reference to the mock using the \"as\" form of the with statement:"
msgstr ""
"Там, де ви використовуєте :func:`patch` для створення макету, ви можете "
"отримати посилання на макет за допомогою форми \"as\" оператора with:"

#: ../../library/unittest.mock-examples.rst:515
msgid ""
"As an alternative ``patch``, ``patch.object`` and ``patch.dict`` can be used "
"as class decorators. When used in this way it is the same as applying the "
"decorator individually to every method whose name starts with \"test\"."
msgstr ""
"Як альтернативу ``patch``, ``patch.object`` і ``patch.dict`` можна "
"використовувати як декоратори класів. При такому використанні це те саме, що "
"застосувати декоратор окремо до кожного методу, назва якого починається з "
"\"test\"."

#: ../../library/unittest.mock-examples.rst:523
msgid "Further Examples"
msgstr "Подальші приклади"

#: ../../library/unittest.mock-examples.rst:526
msgid "Here are some more examples for some slightly more advanced scenarios."
msgstr "Ось ще кілька прикладів для деяких трохи складніших сценаріїв."

#: ../../library/unittest.mock-examples.rst:530
msgid "Mocking chained calls"
msgstr "Знущальні ланцюгові дзвінки"

#: ../../library/unittest.mock-examples.rst:532
msgid ""
"Mocking chained calls is actually straightforward with mock once you "
"understand the :attr:`~Mock.return_value` attribute. When a mock is called "
"for the first time, or you fetch its ``return_value`` before it has been "
"called, a new :class:`Mock` is created."
msgstr ""
"Висмішувати ланцюгові виклики насправді просто за допомогою mock, коли ви "
"розумієте атрибут :attr:`~Mock.return_value`. Коли макет викликається вперше "
"або ви отримуєте його ``return_value`` до його виклику, створюється новий :"
"class:`Mock`."

#: ../../library/unittest.mock-examples.rst:537
msgid ""
"This means that you can see how the object returned from a call to a mocked "
"object has been used by interrogating the ``return_value`` mock:"
msgstr ""
"Це означає, що ви можете побачити, як об’єкт, повернутий викликом "
"імітованого об’єкта, використовувався, запитуючи макет ``return_value``:"

#: ../../library/unittest.mock-examples.rst:545
msgid ""
"From here it is a simple step to configure and then make assertions about "
"chained calls. Of course another alternative is writing your code in a more "
"testable way in the first place..."
msgstr ""
"Звідси це простий крок, щоб налаштувати та зробити твердження щодо "
"ланцюжкових викликів. Звісно, іншою альтернативою є написання коду більш "
"придатним для перевірки способом..."

#: ../../library/unittest.mock-examples.rst:549
msgid "So, suppose we have some code that looks a little bit like this:"
msgstr "Отже, припустімо, що ми маємо код, який виглядає приблизно так:"

#: ../../library/unittest.mock-examples.rst:558
msgid ""
"Assuming that ``BackendProvider`` is already well tested, how do we test "
"``method()``? Specifically, we want to test that the code section ``# more "
"code`` uses the response object in the correct way."
msgstr ""
"Якщо припустити, що ``BackendProvider`` вже добре перевірено, як ми "
"перевіримо ``method()``? Зокрема, ми хочемо перевірити, чи розділ коду ``# "
"more code`` правильно використовує об’єкт відповіді."

#: ../../library/unittest.mock-examples.rst:562
msgid ""
"As this chain of calls is made from an instance attribute we can monkey "
"patch the ``backend`` attribute on a ``Something`` instance. In this "
"particular case we are only interested in the return value from the final "
"call to ``start_call`` so we don't have much configuration to do. Let's "
"assume the object it returns is 'file-like', so we'll ensure that our "
"response object uses the builtin :func:`open` as its ``spec``."
msgstr ""
"Оскільки цей ланцюжок викликів здійснюється з атрибута екземпляра, ми можемо "
"виправити атрибут ``backend`` на екземплярі ``Something``. У цьому "
"конкретному випадку нас цікавить лише значення, яке повертає останній виклик "
"``start_call``, тому нам не потрібно робити багато налаштувань. Припустімо, "
"що об’єкт, який він повертає, є \"файлоподібним\", тому ми переконаємося, що "
"наш об’єкт відповіді використовує вбудований :func:`open` як свою "
"``специфікацію``."

#: ../../library/unittest.mock-examples.rst:569
msgid ""
"To do this we create a mock instance as our mock backend and create a mock "
"response object for it. To set the response as the return value for that "
"final ``start_call`` we could do this::"
msgstr ""
"Для цього ми створюємо макет екземпляра як наш макет бекенда та створюємо "
"для нього об’єкт імітації відповіді. Щоб встановити відповідь як значення, "
"що повертається для цього останнього ``start_call``, ми можемо зробити так:"

#: ../../library/unittest.mock-examples.rst:575
msgid ""
"We can do that in a slightly nicer way using the :meth:`~Mock."
"configure_mock` method to directly set the return value for us::"
msgstr ""
"Ми можемо зробити це трохи зручнішим способом, використовуючи метод :meth:"
"`~Mock.configure_mock`, щоб напряму встановити значення, що повертається:"

#: ../../library/unittest.mock-examples.rst:584
msgid ""
"With these we monkey patch the \"mock backend\" in place and can make the "
"real call::"
msgstr ""
"За допомогою них ми, як мавпи, виправляємо \"імітацію бекенда\" на місці та "
"можемо зробити справжній виклик:"

#: ../../library/unittest.mock-examples.rst:590
msgid ""
"Using :attr:`~Mock.mock_calls` we can check the chained call with a single "
"assert. A chained call is several calls in one line of code, so there will "
"be several entries in ``mock_calls``. We can use :meth:`call.call_list` to "
"create this list of calls for us::"
msgstr ""
"Використовуючи :attr:`~Mock.mock_calls`, ми можемо перевірити ланцюжковий "
"виклик за допомогою одного твердження. Зв’язаний виклик — це кілька викликів "
"в одному рядку коду, тому в ``mock_calls`` буде кілька записів. Ми можемо "
"використовувати :meth:`call.call_list`, щоб створити цей список дзвінків для "
"нас::"

#: ../../library/unittest.mock-examples.rst:601
msgid "Partial mocking"
msgstr "Часткове глузування"

#: ../../library/unittest.mock-examples.rst:603
msgid ""
"In some tests I wanted to mock out a call to :meth:`datetime.date.today` to "
"return a known date, but I didn't want to prevent the code under test from "
"creating new date objects. Unfortunately :class:`datetime.date` is written "
"in C, and so I couldn't just monkey-patch out the static :meth:`datetime."
"date.today` method."
msgstr ""
"В некоторых тестах я хотел имитировать вызов :meth:`datetime.date.today` для "
"возврата известной даты, но я не хотел препятствовать тестируемому коду "
"создавать новые объекты даты. К сожалению, :class:`datetime.date` написан на "
"C, и поэтому я не мог просто исправить статический :meth:`datetime.date."
"today` метод."

#: ../../library/unittest.mock-examples.rst:608
msgid ""
"I found a simple way of doing this that involved effectively wrapping the "
"date class with a mock, but passing through calls to the constructor to the "
"real class (and returning real instances)."
msgstr ""
"Я знайшов простий спосіб зробити це, який передбачав ефективне обгортання "
"класу дати макетом, але передачу викликів конструктору до реального класу (і "
"повернення реальних екземплярів)."

#: ../../library/unittest.mock-examples.rst:612
msgid ""
"The :func:`patch decorator <patch>` is used here to mock out the ``date`` "
"class in the module under test. The :attr:`~Mock.side_effect` attribute on "
"the mock date class is then set to a lambda function that returns a real "
"date. When the mock date class is called a real date will be constructed and "
"returned by ``side_effect``. ::"
msgstr ""
"Декоратор :func:`patch <patch>` используется здесь для макетирования класса "
"``date`` в тестируемом модуле. Атрибут :attr:`~Mock.side_effect` в классе "
"ложной даты затем устанавливается в лямбда-функцию, которая возвращает "
"реальную дату. Когда вызывается класс ложной даты, реальная дата будет "
"создана и возвращена ``side_effect``. ::"

#: ../../library/unittest.mock-examples.rst:626
msgid ""
"Note that we don't patch :class:`datetime.date` globally, we patch ``date`` "
"in the module that *uses* it. See :ref:`where to patch <where-to-patch>`."
msgstr ""
"Зверніть увагу, що ми не виправляємо :class:`datetime.date` глобально, ми "
"виправляємо ``date`` в модулі, який *використовує* його. Дивіться :ref:`де "
"виправити <where-to-patch>`."

#: ../../library/unittest.mock-examples.rst:629
msgid ""
"When ``date.today()`` is called a known date is returned, but calls to the "
"``date(...)`` constructor still return normal dates. Without this you can "
"find yourself having to calculate an expected result using exactly the same "
"algorithm as the code under test, which is a classic testing anti-pattern."
msgstr ""
"Коли викликається ``date.today()``, повертається відома дата, але виклики "
"конструктора ``date(...)`` повертають звичайні дати. Без цього вам може "
"знадобитися розрахувати очікуваний результат, використовуючи точно такий "
"самий алгоритм, як і тестовий код, який є класичним тестовим антишаблоном."

#: ../../library/unittest.mock-examples.rst:634
msgid ""
"Calls to the date constructor are recorded in the ``mock_date`` attributes "
"(``call_count`` and friends) which may also be useful for your tests."
msgstr ""
"Виклики конструктора дат записуються в атрибутах mock_date (call_count і "
"friends), що також може бути корисним для ваших тестів."

#: ../../library/unittest.mock-examples.rst:637
msgid ""
"An alternative way of dealing with mocking dates, or other builtin classes, "
"is discussed in `this blog entry <https://williambert.online/2011/07/how-to-"
"unit-testing-in-django-with-mocking-and-patching/>`_."
msgstr ""
"Uma forma alternativa de lidar com datas de mock, ou outras classes "
"embutidas, é discutida `nesta entrada de blog <https://williambert."
"online/2011/07/how-to-unit-testing-in-django-with-mocking-and-patching/>`_."

#: ../../library/unittest.mock-examples.rst:643
msgid "Mocking a Generator Method"
msgstr "Висміювання методу генератора"

#: ../../library/unittest.mock-examples.rst:645
msgid ""
"A Python generator is a function or method that uses the :keyword:`yield` "
"statement to return a series of values when iterated over [#]_."
msgstr ""
"Генератор Python — це функція або метод, який використовує оператор :keyword:"
"`yield` для повернення ряду значень під час ітерації [#]_."

#: ../../library/unittest.mock-examples.rst:648
msgid ""
"A generator method / function is called to return the generator object. It "
"is the generator object that is then iterated over. The protocol method for "
"iteration is :meth:`~container.__iter__`, so we can mock this using a :class:"
"`MagicMock`."
msgstr ""
"Метод/функція генератора викликається для повернення об’єкта генератора. Це "
"об’єкт генератора, який потім повторюється. Методом протоколу для ітерації "
"є :meth:`~container.__iter__`, тому ми можемо імітувати це за допомогою :"
"class:`MagicMock`."

#: ../../library/unittest.mock-examples.rst:653
msgid ""
"Here's an example class with an \"iter\" method implemented as a generator:"
msgstr "Ось приклад класу з методом \"iter\", реалізованим як генератор:"

#: ../../library/unittest.mock-examples.rst:665
msgid "How would we mock this class, and in particular its \"iter\" method?"
msgstr "Як би ми висміювали цей клас, і зокрема його метод \"iter\"?"

#: ../../library/unittest.mock-examples.rst:667
msgid ""
"To configure the values returned from the iteration (implicit in the call "
"to :class:`list`), we need to configure the object returned by the call to "
"``foo.iter()``."
msgstr ""
"Щоб налаштувати значення, що повертаються з ітерації (неявно у виклику :"
"class:`list`), нам потрібно налаштувати об’єкт, що повертається викликом "
"``foo.iter()``."

#: ../../library/unittest.mock-examples.rst:675
msgid ""
"There are also generator expressions and more `advanced uses <http://www."
"dabeaz.com/coroutines/index.html>`_ of generators, but we aren't concerned "
"about them here. A very good introduction to generators and how powerful "
"they are is: `Generator Tricks for Systems Programmers <http://www.dabeaz."
"com/generators/>`_."
msgstr ""
"Існують також вирази-генератори та більш `просунуті способи використання "
"<http://www.dabeaz.com/coroutines/index.html>`_ генераторів, але вони тут "
"нас не хвилюють. Дуже гарний вступ до генераторів і їхньої потужності: "
"`Трюки генераторів для системних програмістів <http://www.dabeaz.com/"
"generators/>`_."

#: ../../library/unittest.mock-examples.rst:683
msgid "Applying the same patch to every test method"
msgstr "Застосування того самого патча до кожного методу тестування"

#: ../../library/unittest.mock-examples.rst:685
msgid ""
"If you want several patches in place for multiple test methods the obvious "
"way is to apply the patch decorators to every method. This can feel like "
"unnecessary repetition. Instead, you can use :func:`patch` (in all its "
"various forms) as a class decorator. This applies the patches to all test "
"methods on the class. A test method is identified by methods whose names "
"start with ``test``::"
msgstr ""
"Если вам нужно несколько патчей для нескольких методов тестирования, "
"очевидный способ — применить декораторы патчей к каждому методу. Это может "
"показаться ненужным повторением. Вместо этого вы можете использовать :func:"
"`patch` (во всех его различных формах) в качестве декоратора класса. При "
"этом исправления применяются ко всем методам тестирования в классе. Метод "
"тестирования идентифицируется методами, имена которых начинаются с ``test``::"

#: ../../library/unittest.mock-examples.rst:709
msgid ""
"An alternative way of managing patches is to use the :ref:`start-and-stop`. "
"These allow you to move the patching into your ``setUp`` and ``tearDown`` "
"methods. ::"
msgstr ""
"Альтернативним способом керування патчами є використання :ref:`start-and-"
"stop`. Це дозволяє вам перемістити виправлення у ваші методи ``setUp`` і "
"``tearDown``. ::"

#: ../../library/unittest.mock-examples.rst:726
msgid ""
"If you use this technique you must ensure that the patching is \"undone\" by "
"calling ``stop``. This can be fiddlier than you might think, because if an "
"exception is raised in the setUp then tearDown is not called. :meth:"
"`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"Якщо ви використовуєте цю техніку, ви повинні переконатися, що виправлення "
"\"скасовано\", викликавши ``stop``. Це може бути складніше, ніж ви могли б "
"подумати, тому що якщо виняток виникає в SetUp, tearDown не викликається. :"
"meth:`unittest.TestCase.addCleanup` полегшує це::"

#: ../../library/unittest.mock-examples.rst:744
msgid "Mocking Unbound Methods"
msgstr "Висміювання незв'язаних методів"

#: ../../library/unittest.mock-examples.rst:746
msgid ""
"Whilst writing tests today I needed to patch an *unbound method* (patching "
"the method on the class rather than on the instance). I needed self to be "
"passed in as the first argument because I want to make asserts about which "
"objects were calling this particular method. The issue is that you can't "
"patch with a mock for this, because if you replace an unbound method with a "
"mock it doesn't become a bound method when fetched from the instance, and so "
"it doesn't get self passed in. The workaround is to patch the unbound method "
"with a real function instead. The :func:`patch` decorator makes it so simple "
"to patch out methods with a mock that having to create a real function "
"becomes a nuisance."
msgstr ""
"Сьогодні під час написання тестів мені потрібно було виправити *незв’язаний "
"метод* (виправити метод у класі, а не в екземплярі). Мені потрібно було "
"передати self як перший аргумент, оскільки я хочу зробити твердження про те, "
"які об’єкти викликають цей конкретний метод. Проблема полягає в тому, що ви "
"не можете виправити за допомогою макету для цього, тому що якщо ви заміните "
"неприв’язаний метод на макет, він не стане зв’язаним методом під час "
"отримання з примірника, і тому він не передається самостійно. Обхідним "
"шляхом є заміна незв’язаного методу реальною функцією. Декоратор :func:"
"`patch` робить так простим виправлення методів за допомогою макету, що "
"створення справжньої функції стає незручністю."

#: ../../library/unittest.mock-examples.rst:757
msgid ""
"If you pass ``autospec=True`` to patch then it does the patching with a "
"*real* function object. This function object has the same signature as the "
"one it is replacing, but delegates to a mock under the hood. You still get "
"your mock auto-created in exactly the same way as before. What it means "
"though, is that if you use it to patch out an unbound method on a class the "
"mocked function will be turned into a bound method if it is fetched from an "
"instance. It will have ``self`` passed in as the first argument, which is "
"exactly what I wanted:"
msgstr ""
"Якщо ви передаєте ``autospec=True`` для виправлення, тоді він виконує "
"виправлення за допомогою *реального* функціонального об’єкта. Цей "
"функціональний об’єкт має таку саму сигнатуру, як і той, який він замінює, "
"але делегує макет під капотом. Ви все ще автоматично створюєте свій макет "
"точно так само, як і раніше. Однак це означає, що якщо ви використовуєте "
"його для виправлення незв’язаного методу в класі, імітована функція буде "
"перетворена на зв’язаний метод, якщо її буде отримано з екземпляра. Першим "
"аргументом буде передано ``self``, а це саме те, що я хотів:"

#: ../../library/unittest.mock-examples.rst:778
msgid ""
"If we don't use ``autospec=True`` then the unbound method is patched out "
"with a Mock instance instead, and isn't called with ``self``."
msgstr ""
"Якщо ми не використовуємо ``autospec=True``, тоді неприв’язаний метод "
"замість цього виправляється за допомогою екземпляра Mock і не викликається "
"за допомогою ``self``."

#: ../../library/unittest.mock-examples.rst:783
msgid "Checking multiple calls with mock"
msgstr "Перевірка кількох викликів за допомогою імітації"

#: ../../library/unittest.mock-examples.rst:785
msgid ""
"mock has a nice API for making assertions about how your mock objects are "
"used."
msgstr ""
"mock має гарний API для створення тверджень про те, як використовуються ваші "
"макетні об’єкти."

#: ../../library/unittest.mock-examples.rst:792
msgid ""
"If your mock is only being called once you can use the :meth:`~Mock."
"assert_called_once_with` method that also asserts that the :attr:`~Mock."
"call_count` is one."
msgstr ""
"Если ваш макет вызывается только один раз, вы можете использовать метод :"
"meth:`~Mock.assert_known_once_with`, который также утверждает, что :attr:"
"`~Mock.call_count` является таковым."

#: ../../library/unittest.mock-examples.rst:803
msgid ""
"Both ``assert_called_with`` and ``assert_called_once_with`` make assertions "
"about the *most recent* call. If your mock is going to be called several "
"times, and you want to make assertions about *all* those calls you can use :"
"attr:`~Mock.call_args_list`:"
msgstr ""
"І ``assert_ called_with``, і ``assert_ called_once_with`` створюють "
"твердження щодо *останнього* виклику. Якщо ваш макет буде викликано кілька "
"разів, і ви хочете зробити твердження щодо *всіх* цих викликів, ви можете "
"використовувати :attr:`~Mock.call_args_list`:"

#: ../../library/unittest.mock-examples.rst:815
msgid ""
"The :data:`call` helper makes it easy to make assertions about these calls. "
"You can build up a list of expected calls and compare it to "
"``call_args_list``. This looks remarkably similar to the repr of the "
"``call_args_list``:"
msgstr ""
"Помічник :data:`call` полегшує створення тверджень щодо цих викликів. Ви "
"можете створити список очікуваних викликів і порівняти його з "
"``call_args_list``. Це виглядає надзвичайно схожим на відображення ``списку "
"викликів_аргів``:"

#: ../../library/unittest.mock-examples.rst:825
msgid "Coping with mutable arguments"
msgstr "Робота зі змінними аргументами"

#: ../../library/unittest.mock-examples.rst:827
msgid ""
"Another situation is rare, but can bite you, is when your mock is called "
"with mutable arguments. ``call_args`` and ``call_args_list`` store "
"*references* to the arguments. If the arguments are mutated by the code "
"under test then you can no longer make assertions about what the values were "
"when the mock was called."
msgstr ""
"Інша ситуація рідкісна, але може вас вкусити, коли вашу імітацію викликають "
"зі змінними аргументами. ``call_args`` і ``call_args_list`` зберігають "
"*посилання* на аргументи. Якщо аргументи змінено кодом, що тестується, ви "
"більше не зможете робити твердження про те, якими були значення під час "
"виклику макету."

#: ../../library/unittest.mock-examples.rst:832
msgid ""
"Here's some example code that shows the problem. Imagine the following "
"functions defined in 'mymodule'::"
msgstr ""
"Ось приклад коду, який показує проблему. Уявіть собі такі функції, визначені "
"в 'mymodule'::"

#: ../../library/unittest.mock-examples.rst:843
msgid ""
"When we try to test that ``grob`` calls ``frob`` with the correct argument "
"look what happens::"
msgstr ""
"Коли ми намагаємося перевірити, що ``grob`` викликає ``frob`` з правильним "
"аргументом, подивіться, що відбувається:"

#: ../../library/unittest.mock-examples.rst:858
msgid ""
"One possibility would be for mock to copy the arguments you pass in. This "
"could then cause problems if you do assertions that rely on object identity "
"for equality."
msgstr ""
"Однією з можливостей було б імітаційне копіювання аргументів, які ви "
"передаєте. Це може спричинити проблеми, якщо ви робите твердження, які "
"покладаються на ідентичність об’єкта для рівності."

#: ../../library/unittest.mock-examples.rst:862
msgid ""
"Here's one solution that uses the :attr:`~Mock.side_effect` functionality. "
"If you provide a ``side_effect`` function for a mock then ``side_effect`` "
"will be called with the same args as the mock. This gives us an opportunity "
"to copy the arguments and store them for later assertions. In this example "
"I'm using *another* mock to store the arguments so that I can use the mock "
"methods for doing the assertion. Again a helper function sets this up for "
"me. ::"
msgstr ""
"Вот одно решение, использующее функциональность :attr:`~Mock.side_effect`. "
"Если вы предоставите функцию Side_effect для макета, то Side_effect будет "
"вызываться с теми же аргументами, что и макет. Это дает нам возможность "
"скопировать аргументы и сохранить их для последующих утверждений. В этом "
"примере я использую *другой* макет для хранения аргументов, чтобы можно было "
"использовать методы макета для выполнения утверждения. Опять же, "
"вспомогательная функция устанавливает это для меня. ::"

#: ../../library/unittest.mock-examples.rst:891
msgid ""
"``copy_call_args`` is called with the mock that will be called. It returns a "
"new mock that we do the assertion on. The ``side_effect`` function makes a "
"copy of the args and calls our ``new_mock`` with the copy."
msgstr ""
"``copy_call_args`` викликається з макетом, який буде викликано. Він повертає "
"новий макет, на основі якого ми виконуємо твердження. Функція "
"``side_effect`` створює копію аргументів і викликає наш ``new_mock`` разом "
"із копією."

#: ../../library/unittest.mock-examples.rst:897
msgid ""
"If your mock is only going to be used once there is an easier way of "
"checking arguments at the point they are called. You can simply do the "
"checking inside a ``side_effect`` function."
msgstr ""
"Якщо ваш макет використовуватиметься лише один раз, є простіший спосіб "
"перевірити аргументи в момент їх виклику. Ви можете просто зробити перевірку "
"всередині функції ``side_effect``."

#: ../../library/unittest.mock-examples.rst:911
msgid ""
"An alternative approach is to create a subclass of :class:`Mock` or :class:"
"`MagicMock` that copies (using :func:`copy.deepcopy`) the arguments. Here's "
"an example implementation:"
msgstr ""
"Альтернативним підходом є створення підкласу :class:`Mock` або :class:"
"`MagicMock`, який копіює (за допомогою :func:`copy.deepcopy`) аргументи. Ось "
"приклад реалізації:"

#: ../../library/unittest.mock-examples.rst:935
msgid ""
"When you subclass ``Mock`` or ``MagicMock`` all dynamically created "
"attributes, and the ``return_value`` will use your subclass automatically. "
"That means all children of a ``CopyingMock`` will also have the type "
"``CopyingMock``."
msgstr ""
"Коли ви створюєте підклас ``Mock`` або ``MagicMock``, усі динамічно створені "
"атрибути та ``return_value`` автоматично використовуватимуть ваш підклас. Це "
"означає, що всі нащадки ``CopyingMock`` також матимуть тип ``CopyingMock``."

#: ../../library/unittest.mock-examples.rst:941
msgid "Nesting Patches"
msgstr "Патчі гніздування"

#: ../../library/unittest.mock-examples.rst:943
msgid ""
"Using patch as a context manager is nice, but if you do multiple patches you "
"can end up with nested with statements indenting further and further to the "
"right::"
msgstr ""
"Використовувати patch як менеджер контексту добре, але якщо ви робите кілька "
"патчів, ви можете отримати вкладені з операторами відступи все далі й далі "
"праворуч::"

#: ../../library/unittest.mock-examples.rst:961
msgid ""
"With unittest ``cleanup`` functions and the :ref:`start-and-stop` we can "
"achieve the same effect without the nested indentation. A simple helper "
"method, ``create_patch``, puts the patch in place and returns the created "
"mock for us::"
msgstr ""
"За допомогою функцій очищення unittest і :ref:`start-and-stop` ми можемо "
"досягти того самого ефекту без вкладеного відступу. Простий допоміжний "
"метод, ``create_patch``, ставить патч на місце та повертає створений макет "
"для нас::"

#: ../../library/unittest.mock-examples.rst:989
msgid "Mocking a dictionary with MagicMock"
msgstr "Знущання над словником за допомогою MagicMock"

#: ../../library/unittest.mock-examples.rst:991
msgid ""
"You may want to mock a dictionary, or other container object, recording all "
"access to it whilst having it still behave like a dictionary."
msgstr ""
"Можливо, ви захочете імітувати словник або інший об’єкт-контейнер, записуючи "
"всі доступи до нього, водночас залишаючи його поведінку як словник."

#: ../../library/unittest.mock-examples.rst:994
msgid ""
"We can do this with :class:`MagicMock`, which will behave like a dictionary, "
"and using :data:`~Mock.side_effect` to delegate dictionary access to a real "
"underlying dictionary that is under our control."
msgstr ""
"Ми можемо зробити це за допомогою :class:`MagicMock`, який поводитиметься як "
"словник, і за допомогою :data:`~Mock.side_effect` для делегування доступу до "
"словника справжньому базовому словнику, який знаходиться під нашим контролем."

#: ../../library/unittest.mock-examples.rst:998
msgid ""
"When the :meth:`~object.__getitem__` and :meth:`~object.__setitem__` methods "
"of our ``MagicMock`` are called (normal dictionary access) then "
"``side_effect`` is called with the key (and in the case of ``__setitem__`` "
"the value too). We can also control what is returned."
msgstr ""
"Когда вызываются методы :meth:`~object.__getitem__` и :meth:`~object."
"__setitem__` нашего ``MagicMock`` (обычный доступ к словарю), тогда "
"``side_effect`` вызывается с ключом (и в в случае ``__setitem__`` значение "
"тоже). Мы также можем контролировать то, что возвращается."

#: ../../library/unittest.mock-examples.rst:1003
msgid ""
"After the ``MagicMock`` has been used we can use attributes like :data:"
"`~Mock.call_args_list` to assert about how the dictionary was used:"
msgstr ""
"Після використання ``MagicMock`` ми можемо використовувати такі атрибути, "
"як :data:`~Mock.call_args_list`, щоб підтвердити, як використовувався "
"словник:"

#: ../../library/unittest.mock-examples.rst:1019
msgid ""
"An alternative to using ``MagicMock`` is to use ``Mock`` and *only* provide "
"the magic methods you specifically want:"
msgstr ""
"Альтернативою використанню ``MagicMock`` є використання ``Mock`` і *лише* "
"надання магічних методів, які вам потрібні:"

#: ../../library/unittest.mock-examples.rst:1026
msgid ""
"A *third* option is to use ``MagicMock`` but passing in ``dict`` as the "
"*spec* (or *spec_set*) argument so that the ``MagicMock`` created only has "
"dictionary magic methods available:"
msgstr ""
"*Третій* варіант — використовувати ``MagicMock``, але передаючи ``dict`` як "
"аргумент *spec* (або *spec_set*), щоб створений ``MagicMock`` мав доступні "
"лише магічні методи словника:"

#: ../../library/unittest.mock-examples.rst:1034
msgid ""
"With these side effect functions in place, the ``mock`` will behave like a "
"normal dictionary but recording the access. It even raises a :exc:`KeyError` "
"if you try to access a key that doesn't exist."
msgstr ""
"З цими функціями побічних ефектів ``мокет`` поводитиметься як звичайний "
"словник, але записуватиме доступ. Він навіть викликає :exc:`KeyError`, якщо "
"ви намагаєтеся отримати доступ до ключа, якого не існує."

#: ../../library/unittest.mock-examples.rst:1053
msgid ""
"After it has been used you can make assertions about the access using the "
"normal mock methods and attributes:"
msgstr ""
"Після його використання ви можете робити твердження щодо доступу за "
"допомогою звичайних методів і атрибутів:"

#: ../../library/unittest.mock-examples.rst:1065
msgid "Mock subclasses and their attributes"
msgstr "Макетні підкласи та їхні атрибути"

#: ../../library/unittest.mock-examples.rst:1067
msgid ""
"There are various reasons why you might want to subclass :class:`Mock`. One "
"reason might be to add helper methods. Here's a silly example:"
msgstr ""
"Існують різні причини, чому ви можете створити підклас :class:`Mock`. Однією "
"з причин може бути додавання допоміжних методів. Ось дурний приклад:"

#: ../../library/unittest.mock-examples.rst:1083
msgid ""
"The standard behaviour for ``Mock`` instances is that attributes and the "
"return value mocks are of the same type as the mock they are accessed on. "
"This ensures that ``Mock`` attributes are ``Mocks`` and ``MagicMock`` "
"attributes are ``MagicMocks`` [#]_. So if you're subclassing to add helper "
"methods then they'll also be available on the attributes and return value "
"mock of instances of your subclass."
msgstr ""
"Стандартна поведінка екземплярів ``Mock`` полягає в тому, що атрибути та "
"значення, що повертаються mocks, мають той самий тип, що й макет, з якого до "
"них здійснюється доступ. Це гарантує, що атрибути ``Mock`` є ``Mocks``, а "
"``MagicMock`` атрибути ``MagicMocks`` [#]_. Отже, якщо ви створюєте підкласи "
"для додавання допоміжних методів, вони також будуть доступні в атрибутах і "
"повертаються значеннях екземплярів вашого підкласу."

#: ../../library/unittest.mock-examples.rst:1099
msgid ""
"Sometimes this is inconvenient. For example, `one user <https://code.google."
"com/archive/p/mock/issues/105>`_ is subclassing mock to created a `Twisted "
"adaptor <https://twisted.org/documents/11.0.0/api/twisted.python.components."
"html>`_. Having this applied to attributes too actually causes errors."
msgstr ""
"Иногда это неудобно. Например, `один пользователь <https://code.google.com/"
"archive/p/mock/issues/105>`_ создает подкласс подкласса для создания "
"`Twisted адаптера <https://twisted.org/documents/11.0 .0/api/twisted.python."
"comComponents.html>`_. Применение этого и к атрибутам фактически приводит к "
"ошибкам."

#: ../../library/unittest.mock-examples.rst:1105
msgid ""
"``Mock`` (in all its flavours) uses a method called ``_get_child_mock`` to "
"create these \"sub-mocks\" for attributes and return values. You can prevent "
"your subclass being used for attributes by overriding this method. The "
"signature is that it takes arbitrary keyword arguments (``**kwargs``) which "
"are then passed onto the mock constructor:"
msgstr ""
"``Mock`` (у всіх його варіантах) використовує метод під назвою "
"``_get_child_mock``, щоб створити ці \"під-моки\" для атрибутів і "
"повертаються значень. Ви можете запобігти використанню вашого підкласу для "
"атрибутів, замінивши цей метод. Підпис полягає в тому, що він приймає "
"довільні аргументи ключового слова (``**kwargs``), які потім передаються в "
"макетний конструктор:"

#: ../../library/unittest.mock-examples.rst:1122
msgid ""
"An exception to this rule are the non-callable mocks. Attributes use the "
"callable variant because otherwise non-callable mocks couldn't have callable "
"methods."
msgstr ""
"Винятком із цього правила є невикликані моки. Атрибути використовують "
"викликаючий варіант, оскільки інакше невикликані макети не могли б мати "
"викликані методи."

#: ../../library/unittest.mock-examples.rst:1128
msgid "Mocking imports with patch.dict"
msgstr "Знущання над імпортом за допомогою patch.dict"

#: ../../library/unittest.mock-examples.rst:1130
msgid ""
"One situation where mocking can be hard is where you have a local import "
"inside a function. These are harder to mock because they aren't using an "
"object from the module namespace that we can patch out."
msgstr ""
"Одна ситуація, коли насмішка може бути важкою, це коли у вас є локальний "
"імпорт всередині функції. Їх важче висміяти, оскільки вони не використовують "
"об’єкт із простору імен модуля, який ми можемо виправити."

#: ../../library/unittest.mock-examples.rst:1134
msgid ""
"Generally local imports are to be avoided. They are sometimes done to "
"prevent circular dependencies, for which there is *usually* a much better "
"way to solve the problem (refactor the code) or to prevent \"up front "
"costs\" by delaying the import. This can also be solved in better ways than "
"an unconditional local import (store the module as a class or module "
"attribute and only do the import on first use)."
msgstr ""
"Загалом слід уникати місцевого імпорту. Іноді їх роблять, щоб запобігти "
"циклічним залежностям, для яких *зазвичай* існує набагато кращий спосіб "
"вирішити проблему (рефакторити код) або запобігти \"попереднім витратам\" "
"шляхом затримки імпорту. Це також можна вирішити кращим способом, ніж "
"безумовний локальний імпорт (зберігайте модуль як клас або атрибут модуля та "
"виконуйте імпорт лише під час першого використання)."

#: ../../library/unittest.mock-examples.rst:1141
msgid ""
"That aside there is a way to use ``mock`` to affect the results of an "
"import. Importing fetches an *object* from the :data:`sys.modules` "
"dictionary. Note that it fetches an *object*, which need not be a module. "
"Importing a module for the first time results in a module object being put "
"in ``sys.modules``, so usually when you import something you get a module "
"back. This need not be the case however."
msgstr ""
"Помимо этого, есть способ использовать «mock», чтобы повлиять на результаты "
"импорта. При импорте извлекается *объект* из словаря :data:`sys.modules`. "
"Обратите внимание, что он извлекает *объект*, который не обязательно должен "
"быть модулем. Импорт модуля в первый раз приводит к тому, что объект модуля "
"помещается в ``sys.modules``, поэтому обычно, когда вы что-то импортируете, "
"вы получаете модуль обратно. Однако это не обязательно так."

#: ../../library/unittest.mock-examples.rst:1148
msgid ""
"This means you can use :func:`patch.dict` to *temporarily* put a mock in "
"place in :data:`sys.modules`. Any imports whilst this patch is active will "
"fetch the mock. When the patch is complete (the decorated function exits, "
"the with statement body is complete or ``patcher.stop()`` is called) then "
"whatever was there previously will be restored safely."
msgstr ""
"Це означає, що ви можете використовувати :func:`patch.dict`, щоб *тимчасово* "
"розмістити макет на місці в :data:`sys.modules`. Будь-який імпорт, поки цей "
"патч активний, отримуватиме макет. Коли виправлення завершено (декорована "
"функція завершує роботу, тіло оператора with завершено або викликається "
"``patcher.stop()``), тоді все, що було раніше, буде безпечно відновлено."

#: ../../library/unittest.mock-examples.rst:1154
msgid "Here's an example that mocks out the 'fooble' module."
msgstr "Ось приклад, який висміює модуль \"fooble\"."

#: ../../library/unittest.mock-examples.rst:1166
msgid ""
"As you can see the ``import fooble`` succeeds, but on exit there is no "
"'fooble' left in :data:`sys.modules`."
msgstr ""
"Як ви бачите, ``імпорт fooble`` вдається, але після виходу в :data:`sys."
"modules` не залишилося жодного 'fooble'."

#: ../../library/unittest.mock-examples.rst:1169
msgid "This also works for the ``from module import name`` form:"
msgstr "Це також працює для форми ``from module import name``:"

#: ../../library/unittest.mock-examples.rst:1179
msgid "With slightly more work you can also mock package imports:"
msgstr ""
"Доклавши трохи більше зусиль, ви також можете імітувати імпорт пакетів:"

#: ../../library/unittest.mock-examples.rst:1192
msgid "Tracking order of calls and less verbose call assertions"
msgstr "Відстеження порядку викликів і менш докладні підтвердження викликів"

#: ../../library/unittest.mock-examples.rst:1194
msgid ""
"The :class:`Mock` class allows you to track the *order* of method calls on "
"your mock objects through the :attr:`~Mock.method_calls` attribute. This "
"doesn't allow you to track the order of calls between separate mock objects, "
"however we can use :attr:`~Mock.mock_calls` to achieve the same effect."
msgstr ""
"Клас :class:`Mock` дозволяє вам відстежувати *порядок* викликів методів "
"ваших фіктивних об’єктів за допомогою атрибута :attr:`~Mock.method_calls`. "
"Це не дозволяє відстежувати порядок викликів між окремими макетними "
"об’єктами, однак ми можемо використовувати :attr:`~Mock.mock_calls` для "
"досягнення того самого ефекту."

#: ../../library/unittest.mock-examples.rst:1199
msgid ""
"Because mocks track calls to child mocks in ``mock_calls``, and accessing an "
"arbitrary attribute of a mock creates a child mock, we can create our "
"separate mocks from a parent one. Calls to those child mock will then all be "
"recorded, in order, in the ``mock_calls`` of the parent:"
msgstr ""
"Оскільки mocks відстежують виклики дочірніх mocks у ``mock_calls``, а доступ "
"до довільного атрибута mock створює дочірній mock, ми можемо створювати "
"окремі моки від батьківського. Виклики цих дочірніх маніпуляцій будуть "
"записані по порядку в ``mock_calls`` батьківського:"

#: ../../library/unittest.mock-examples.rst:1216
msgid ""
"We can then assert about the calls, including the order, by comparing with "
"the ``mock_calls`` attribute on the manager mock:"
msgstr ""
"Потім ми можемо стверджувати про виклики, включаючи порядок, порівнюючи з "
"атрибутом ``mock_calls`` макет менеджера:"

#: ../../library/unittest.mock-examples.rst:1223
msgid ""
"If ``patch`` is creating, and putting in place, your mocks then you can "
"attach them to a manager mock using the :meth:`~Mock.attach_mock` method. "
"After attaching calls will be recorded in ``mock_calls`` of the manager. ::"
msgstr ""
"Якщо ``patch`` створює та розміщує ваші макети, ви можете прикріпити їх до "
"макета менеджера за допомогою методу :meth:`~Mock.attach_mock`. Після "
"прикріплення виклики будуть записані в ``mock_calls`` менеджера. ::"

#: ../../library/unittest.mock-examples.rst:1242
msgid ""
"If many calls have been made, but you're only interested in a particular "
"sequence of them then an alternative is to use the :meth:`~Mock."
"assert_has_calls` method. This takes a list of calls (constructed with the :"
"data:`call` object). If that sequence of calls are in :attr:`~Mock."
"mock_calls` then the assert succeeds."
msgstr ""
"Якщо було зроблено багато викликів, але вас цікавить лише певна їх "
"послідовність, альтернативою є використання методу :meth:`~Mock."
"assert_has_calls`. Це бере список викликів (створений за допомогою об’єкта :"
"data:`call`). Якщо ця послідовність викликів міститься в :attr:`~Mock."
"mock_calls`, тоді твердження буде успішним."

#: ../../library/unittest.mock-examples.rst:1256
msgid ""
"Even though the chained call ``m.one().two().three()`` aren't the only calls "
"that have been made to the mock, the assert still succeeds."
msgstr ""
"Незважаючи на те, що зв’язаний виклик ``m.one().two().three()`` не єдиний "
"виклик, який було зроблено для mock, твердження все одно успішне."

#: ../../library/unittest.mock-examples.rst:1259
msgid ""
"Sometimes a mock may have several calls made to it, and you are only "
"interested in asserting about *some* of those calls. You may not even care "
"about the order. In this case you can pass ``any_order=True`` to "
"``assert_has_calls``:"
msgstr ""
"Іноді макет може мати кілька звернень до нього, і ви зацікавлені лише в "
"підтвердженні *деяких* із цих викликів. Ви можете навіть не дбати про "
"порядок. У цьому випадку ви можете передати ``any_order=True`` до "
"``assert_has_calls``:"

#: ../../library/unittest.mock-examples.rst:1271
msgid "More complex argument matching"
msgstr "Складніше зіставлення аргументів"

#: ../../library/unittest.mock-examples.rst:1273
msgid ""
"Using the same basic concept as :data:`ANY` we can implement matchers to do "
"more complex assertions on objects used as arguments to mocks."
msgstr ""
"Використовуючи ту саму основну концепцію, що й :data:`ANY`, ми можемо "
"реалізувати збіги для більш складних тверджень щодо об’єктів, які "
"використовуються як аргументи для імітації."

#: ../../library/unittest.mock-examples.rst:1276
msgid ""
"Suppose we expect some object to be passed to a mock that by default "
"compares equal based on object identity (which is the Python default for "
"user defined classes). To use :meth:`~Mock.assert_called_with` we would need "
"to pass in the exact same object. If we are only interested in some of the "
"attributes of this object then we can create a matcher that will check these "
"attributes for us."
msgstr ""
"Припустімо, ми очікуємо, що якийсь об’єкт буде передано макету, який за "
"замовчуванням порівнює рівність на основі ідентичності об’єкта (що є "
"стандартним значенням Python для визначених користувачем класів). Щоб "
"використовувати :meth:`~Mock.assert_ called_with`, нам потрібно буде "
"передати той самий об’єкт. Якщо нас цікавлять лише деякі атрибути цього "
"об’єкта, ми можемо створити відповідник, який перевірить ці атрибути для нас."

#: ../../library/unittest.mock-examples.rst:1283
msgid ""
"You can see in this example how a 'standard' call to ``assert_called_with`` "
"isn't sufficient:"
msgstr ""
"У цьому прикладі ви можете побачити, як \"стандартного\" виклику ``assert_ "
"called_with`` недостатньо:"

#: ../../library/unittest.mock-examples.rst:1298
msgid ""
"A comparison function for our ``Foo`` class might look something like this:"
msgstr ""
"Функція порівняння для нашого класу ``Foo`` може виглядати приблизно так:"

#: ../../library/unittest.mock-examples.rst:1310
msgid ""
"And a matcher object that can use comparison functions like this for its "
"equality operation would look something like this:"
msgstr ""
"І об’єкт відповідності, який може використовувати такі функції порівняння "
"для своєї операції рівності, виглядатиме приблизно так:"

#: ../../library/unittest.mock-examples.rst:1321
msgid "Putting all this together:"
msgstr "Зібравши все це разом:"

#: ../../library/unittest.mock-examples.rst:1326
msgid ""
"The ``Matcher`` is instantiated with our compare function and the ``Foo`` "
"object we want to compare against. In ``assert_called_with`` the ``Matcher`` "
"equality method will be called, which compares the object the mock was "
"called with against the one we created our matcher with. If they match then "
"``assert_called_with`` passes, and if they don't an :exc:`AssertionError` is "
"raised:"
msgstr ""
"Екземпляр ``Matcher`` створюється нашою функцією порівняння та об’єктом "
"``Foo``, з яким ми хочемо порівняти. У ``assert_ called_with`` буде "
"викликаний метод рівності ``Matcher``, який порівнює об’єкт, з яким було "
"викликано макет, з тим, з яким ми створили наш збігувач. Якщо вони "
"збігаються, ``assert_ called_with`` пропускається, а якщо вони не "
"збігаються, виникає :exc:`AssertionError`:"

#: ../../library/unittest.mock-examples.rst:1339
msgid ""
"With a bit of tweaking you could have the comparison function raise the :exc:"
"`AssertionError` directly and provide a more useful failure message."
msgstr ""
"Трохи налаштувавши функцію порівняння, ви могли б безпосередньо викликати :"
"exc:`AssertionError` і надавати більш корисне повідомлення про помилку."

#: ../../library/unittest.mock-examples.rst:1342
msgid ""
"As of version 1.5, the Python testing library `PyHamcrest <https://"
"pyhamcrest.readthedocs.io/>`_ provides similar functionality, that may be "
"useful here, in the form of its equality matcher (`hamcrest.library."
"integration.match_equality <https://pyhamcrest.readthedocs.io/en/release-1.8/"
"integration/#module-hamcrest.library.integration.match_equality>`_)."
msgstr ""
"Починаючи з версії 1.5, тестова бібліотека Python `PyHamcrest <https://"
"pyhamcrest.readthedocs.io/>`_ надає подібну функціональність, яка може бути "
"корисною тут, у формі її відповідника рівності (`hamcrest.library."
"integration.match_equality <https://pyhamcrest.readthedocs.io/en/release-1.8/"
"integration/#module-hamcrest.library.integration.match_equality>`_)."

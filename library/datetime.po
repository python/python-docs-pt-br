# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-16 14:19+0000\n"
"PO-Revision-Date: 2025-07-18 18:48+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/datetime.rst:2
msgid ":mod:`!datetime` --- Basic date and time types"
msgstr ":mod:`!datetime` --- Tipos básicos de data e hora"

#: ../../library/datetime.rst:11
msgid "**Source code:** :source:`Lib/datetime.py`"
msgstr "**Código-fonte:** :source:`Lib/datetime.py`"

#: ../../library/datetime.rst:17
msgid ""
"The :mod:`!datetime` module supplies classes for manipulating dates and "
"times."
msgstr ""
"O módulo :mod:`!datetime` fornece as classes para manipulação de datas e "
"horas."

#: ../../library/datetime.rst:19
msgid ""
"While date and time arithmetic is supported, the focus of the implementation "
"is on efficient attribute extraction for output formatting and manipulation."
msgstr ""
"Ainda que a aritmética de data e hora seja suportada, o foco da "
"implementação é na extração eficiente do atributo para formatação da saída e "
"manipulação."

#: ../../library/datetime.rst:24
msgid "Skip to :ref:`the format codes <format-codes>`."
msgstr "Pular para :ref:`os códigos de formatação <format-codes>`."

#: ../../library/datetime.rst:28
msgid "Module :mod:`calendar`"
msgstr "Módulo :mod:`calendar`"

#: ../../library/datetime.rst:29
msgid "General calendar related functions."
msgstr "Funções gerais relacionadas ao calendário."

#: ../../library/datetime.rst:31
msgid "Module :mod:`time`"
msgstr "Módulo :mod:`time`"

#: ../../library/datetime.rst:32
msgid "Time access and conversions."
msgstr "Acesso de hora e conversões."

#: ../../library/datetime.rst:34
msgid "Module :mod:`zoneinfo`"
msgstr "Módulo :mod:`zoneinfo`"

#: ../../library/datetime.rst:35
msgid "Concrete time zones representing the IANA time zone database."
msgstr ""
"Fusos horários concretos representando o banco de dados de fusos horários "
"IANA."

#: ../../library/datetime.rst:37
msgid "Package `dateutil <https://dateutil.readthedocs.io/en/stable/>`_"
msgstr "Pacote `dateutil <https://dateutil.readthedocs.io/en/stable/>`_"

#: ../../library/datetime.rst:38
msgid "Third-party library with expanded time zone and parsing support."
msgstr ""
"Biblioteca de terceiros com fuso horário expandido e suporte à análise."

#: ../../library/datetime.rst:40
msgid "Package :pypi:`DateType`"
msgstr "Pacote :pypi:`DateType`"

#: ../../library/datetime.rst:41
msgid ""
"Third-party library that introduces distinct static types to e.g. allow :"
"term:`static type checkers <static type checker>` to differentiate between "
"naive and aware datetimes."
msgstr ""
"Biblioteca de terceiros que apresenta tipos estáticos distintos para, por "
"exemplo, permitir que :term:`verificadores de tipo estático <static type "
"checker>` diferenciem datas ingênuas e conscientes."

#: ../../library/datetime.rst:48
msgid "Aware and Naive Objects"
msgstr "Objetos Conscientes e Ingênuos"

#: ../../library/datetime.rst:50
msgid ""
"Date and time objects may be categorized as \"aware\" or \"naive\" depending "
"on whether or not they include time zone information."
msgstr ""
"Objetos de data e hora podem ser categorizados como \"consciente\" ou "
"\"ingênuo\" dependendo se eles incluem ou não informação sobre fuso horário."

#: ../../library/datetime.rst:53
msgid ""
"With sufficient knowledge of applicable algorithmic and political time "
"adjustments, such as time zone and daylight saving time information, an "
"**aware** object can locate itself relative to other aware objects. An aware "
"object represents a specific moment in time that is not open to "
"interpretation. [#]_"
msgstr ""
"Com conhecimento suficiente dos ajustes de tempo algorítmicos e políticos "
"aplicáveis, como informações de fuso horário e horário de verão, um objeto "
"**consciente** pode se localizar em relação a outros objetos conscientes. Um "
"objeto consciente representa um momento específico no tempo que não está "
"aberto à interpretação. [#]_"

#: ../../library/datetime.rst:59
msgid ""
"A **naive** object does not contain enough information to unambiguously "
"locate itself relative to other date/time objects. Whether a naive object "
"represents Coordinated Universal Time (UTC), local time, or time in some "
"other time zone is purely up to the program, just like it is up to the "
"program whether a particular number represents metres, miles, or mass. Naive "
"objects are easy to understand and to work with, at the cost of ignoring "
"some aspects of reality."
msgstr ""
"Um objeto **ingênuo** não contém informações suficientes para se localizar "
"inequivocamente em relação a outros objetos de data/hora. Se um objeto "
"ingênuo representa o Coordinated Universal Time (UTC), a hora local, ou a "
"hora em algum outro fuso horário, isso depende exclusivamente do programa, "
"assim como é tarefa do programa decidir se um número específico representa "
"metros, milhas ou massa. Objetos ingênuos são fáceis de entender e "
"trabalhar, com o custo de ignorar alguns aspectos da realidade."

#: ../../library/datetime.rst:66
msgid ""
"For applications requiring aware objects, :class:`.datetime` and :class:`."
"time` objects have an optional time zone information attribute, :attr:`!"
"tzinfo`, that can be set to an instance of a subclass of the abstract :class:"
"`tzinfo` class. These :class:`tzinfo` objects capture information about the "
"offset from UTC time, the time zone name, and whether daylight saving time "
"is in effect."
msgstr ""
"Para aplicativos que requerem objetos conscientes, os objetos :class:`."
"datetime` e :class:`.time` possuem um atributo opcional de informações do "
"fuso horário, :attr:`!tzinfo`, que pode ser definido como uma instância de "
"uma subclasse da classe abstrata :class:`tzinfo`. Esses objetos :class:"
"`tzinfo` capturam informações sobre a diferença da hora UTC, o nome do fuso "
"horário e se o horário de verão está em vigor."

#: ../../library/datetime.rst:72
msgid ""
"Only one concrete :class:`tzinfo` class, the :class:`timezone` class, is "
"supplied by the :mod:`!datetime` module. The :class:`!timezone` class can "
"represent simple time zones with fixed offsets from UTC, such as UTC itself "
"or North American EST and EDT time zones. Supporting time zones at deeper "
"levels of detail is up to the application. The rules for time adjustment "
"across the world are more political than rational, change frequently, and "
"there is no standard suitable for every application aside from UTC."
msgstr ""
"Somente uma classe concreta :class:`tzinfo`, a classe :class:`timezone`, é "
"fornecida pelo módulo :mod:`!datetime`. A classe :class:`!timezone` pode "
"representar fusos horários simples com diferenças fixas do UTC, como o "
"próprio UTC, ou os fusos horários norte-americanos EST e EDT. O suporte a "
"fusos horários em níveis mais detalhados depende da aplicação. As regras "
"para ajuste de tempo em todo o mundo são mais políticas do que racionais, "
"mudam com frequência e não há um padrão adequado para todas as aplicações "
"além da UTC."

#: ../../library/datetime.rst:81
msgid "Constants"
msgstr "Constantes"

#: ../../library/datetime.rst:83
msgid "The :mod:`!datetime` module exports the following constants:"
msgstr "O módulo :mod:`!datetime` exporta as seguintes constantes:"

#: ../../library/datetime.rst:87
msgid ""
"The smallest year number allowed in a :class:`date` or :class:`.datetime` "
"object. :const:`MINYEAR` is 1."
msgstr ""
"O menor número de ano permitido em um objeto :class:`date` ou :class:`."
"datetime`. :const:`MINYEAR` é 1."

#: ../../library/datetime.rst:93
msgid ""
"The largest year number allowed in a :class:`date` or :class:`.datetime` "
"object. :const:`MAXYEAR` is 9999."
msgstr ""
"O maior número de ano permitido no objeto :class:`date` ou :class:`."
"datetime`. :const:`MAXYEAR` é 9999."

#: ../../library/datetime.rst:98
msgid "Alias for the UTC time zone singleton :attr:`datetime.timezone.utc`."
msgstr ""
"Apelido para o singleton de fuso horário UTC :attr:`datetime.timezone.utc`."

#: ../../library/datetime.rst:103
msgid "Available Types"
msgstr "Tipos disponíveis"

#: ../../library/datetime.rst:108
msgid ""
"An idealized naive date, assuming the current Gregorian calendar always was, "
"and always will be, in effect. Attributes: :attr:`year`, :attr:`month`, and :"
"attr:`day`."
msgstr ""
"Uma data ingênua idealizada, presumindo que o atual calendário Gregoriano "
"sempre foi, e sempre estará em vigor. Atributos: :attr:`year`, :attr:`month` "
"e :attr:`day`."

#: ../../library/datetime.rst:116
msgid ""
"An idealized time, independent of any particular day, assuming that every "
"day has exactly 24\\*60\\*60 seconds.  (There is no notion of \"leap "
"seconds\" here.) Attributes: :attr:`hour`, :attr:`minute`, :attr:`second`, :"
"attr:`microsecond`, and :attr:`.tzinfo`."
msgstr ""
"Um horário ideal, independente de qualquer dia em particular, presumindo que "
"todos os dias tenham exatamente 24\\*60\\*60 segundos. (Não há noção de "
"\"segundos bissextos\" aqui.) Atributos: :attr:`hour`, :attr:`minute`, :attr:"
"`second`, :attr:`microsecond` e :attr:`.tzinfo`."

#: ../../library/datetime.rst:125
msgid ""
"A combination of a date and a time. Attributes: :attr:`year`, :attr:"
"`month`, :attr:`day`, :attr:`hour`, :attr:`minute`, :attr:`second`, :attr:"
"`microsecond`, and :attr:`.tzinfo`."
msgstr ""
"Uma combinação de uma data e uma hora. Atributos: :attr:`year`, :attr:"
"`month`, :attr:`day`, :attr:`hour`, :attr:`minute`, :attr:`second`, :attr:"
"`microsecond` e :attr:`.tzinfo`."

#: ../../library/datetime.rst:133
msgid ""
"A duration expressing the difference between two :class:`.datetime` or :"
"class:`date` instances to microsecond resolution."
msgstr ""
"Uma duração que expressa a diferença entre duas instâncias :class:`."
"datetime` ou :class:`date` para resolução de microssegundos."

#: ../../library/datetime.rst:140
msgid ""
"An abstract base class for time zone information objects. These are used by "
"the :class:`.datetime` and :class:`.time` classes to provide a customizable "
"notion of time adjustment (for example, to account for time zone and/or "
"daylight saving time)."
msgstr ""
"Uma classe base abstrata para objetos de informações de fuso horário. Eles "
"são usados pelas classes :class:`.datetime` e :class:`.time` para fornecer "
"uma noção personalizável de ajuste de horário (por exemplo, para considerar "
"o fuso horário e/ou o horário de verão)."

#: ../../library/datetime.rst:148
msgid ""
"A class that implements the :class:`tzinfo` abstract base class as a fixed "
"offset from the UTC."
msgstr ""
"Uma classe que implementa a classe base abstrata :class:`tzinfo` como uma "
"diferença fixa do UTC."

#: ../../library/datetime.rst:153 ../../library/datetime.rst:171
msgid "Objects of these types are immutable."
msgstr "Objetos desse tipo são imutáveis."

#: ../../library/datetime.rst:155
msgid "Subclass relationships::"
msgstr "Relacionamentos de subclasse::"

#: ../../library/datetime.rst:157
msgid ""
"object\n"
"    timedelta\n"
"    tzinfo\n"
"        timezone\n"
"    time\n"
"    date\n"
"        datetime"
msgstr ""
"object\n"
"    timedelta\n"
"    tzinfo\n"
"        timezone\n"
"    time\n"
"    date\n"
"        datetime"

#: ../../library/datetime.rst:166
msgid "Common Properties"
msgstr "Propriedades Comuns"

#: ../../library/datetime.rst:168
msgid ""
"The :class:`date`, :class:`.datetime`, :class:`.time`, and :class:`timezone` "
"types share these common features:"
msgstr ""
"Os tipos :class:`date`, :class:`.datetime`, :class:`.time` e :class:"
"`timezone` compartilham esses recursos comuns:"

#: ../../library/datetime.rst:172
msgid ""
"Objects of these types are :term:`hashable`, meaning that they can be used "
"as dictionary keys."
msgstr ""
"Objetos desses tipos são :term:`hasheáveis <hasheável>`, o que significa que "
"podem ser usados como chaves de dicionário."

#: ../../library/datetime.rst:174
msgid ""
"Objects of these types support efficient pickling via the :mod:`pickle` "
"module."
msgstr ""
"Objetos desse tipo suportam decapagem eficiente através do módulo :mod:"
"`pickle`."

#: ../../library/datetime.rst:177
msgid "Determining if an Object is Aware or Naive"
msgstr "Determinando se um Objeto é Consciente ou Ingênuo"

#: ../../library/datetime.rst:179
msgid "Objects of the :class:`date` type are always naive."
msgstr "Objetos do tipo :class:`date` são sempre ingênuos."

#: ../../library/datetime.rst:181
msgid ""
"An object of type :class:`.time` or :class:`.datetime` may be aware or naive."
msgstr ""
"Um objeto do tipo :class:`.time` ou :class:`.datetime` pode ser consciente "
"ou ingênuo."

#: ../../library/datetime.rst:183
msgid ""
"A :class:`.datetime` object ``d`` is aware if both of the following hold:"
msgstr ""
"O objeto :class:`.datetime` ``d`` é consciente se ambos os seguintes itens "
"forem verdadeiros:"

#: ../../library/datetime.rst:185
msgid "``d.tzinfo`` is not ``None``"
msgstr "``d.tzinfo`` não é ``None``"

#: ../../library/datetime.rst:186
msgid "``d.tzinfo.utcoffset(d)`` does not return ``None``"
msgstr "``d.tzinfo.utcoffset(d)`` não retorna ``None``"

#: ../../library/datetime.rst:188
msgid "Otherwise, ``d`` is naive."
msgstr "Caso contrário, ``d`` é ingênuo."

#: ../../library/datetime.rst:190
msgid "A :class:`.time` object ``t`` is aware if both of the following hold:"
msgstr ""
"O objeto :class:`.time` ``t`` é consciente, se os seguintes itens são "
"verdadeiros:"

#: ../../library/datetime.rst:192
msgid "``t.tzinfo`` is not ``None``"
msgstr "``t.tzinfo`` não é ``None``"

#: ../../library/datetime.rst:193
msgid "``t.tzinfo.utcoffset(None)`` does not return ``None``."
msgstr "``t.tzinfo.utcoffset(None)`` não retorna ``None``."

#: ../../library/datetime.rst:195
msgid "Otherwise, ``t`` is naive."
msgstr "Caso contrário, ``t`` é ingênuo."

#: ../../library/datetime.rst:197
msgid ""
"The distinction between aware and naive doesn't apply to :class:`timedelta` "
"objects."
msgstr ""
"A distinção entre consciente e ingênuo não se aplica a objetos :class:"
"`timedelta`."

#: ../../library/datetime.rst:203
msgid ":class:`timedelta` Objects"
msgstr "Objetos :class:`timedelta`"

#: ../../library/datetime.rst:205
msgid ""
"A :class:`timedelta` object represents a duration, the difference between "
"two :class:`.datetime` or :class:`date` instances."
msgstr ""
"O objeto :class:`timedelta` representa uma duração, a diferença entre duas "
"instâncias :class:`.datetime` ou :class:`date`."

#: ../../library/datetime.rst:210
msgid ""
"All arguments are optional and default to 0. Arguments may be integers or "
"floats, and may be positive or negative."
msgstr ""
"Todos os argumentos são opcionais e o padrão é 0. Os argumentos podem ser "
"números inteiros ou ponto flutuantes, e podem ser positivos ou negativos."

#: ../../library/datetime.rst:213
msgid ""
"Only *days*, *seconds* and *microseconds* are stored internally. Arguments "
"are converted to those units:"
msgstr ""
"Apenas *days*, *seconds* e *microseconds* são armazenados internamente. Os "
"argumentos são convertidos para essas unidades:"

#: ../../library/datetime.rst:216
msgid "A millisecond is converted to 1000 microseconds."
msgstr "Um milissegundo é convertido em 1000 microssegundos."

#: ../../library/datetime.rst:217
msgid "A minute is converted to 60 seconds."
msgstr "Um minuto é convertido em 60 segundos."

#: ../../library/datetime.rst:218
msgid "An hour is converted to 3600 seconds."
msgstr "Uma hora é convertida em 3600 segundos."

#: ../../library/datetime.rst:219
msgid "A week is converted to 7 days."
msgstr "Uma semana é convertida para 7 dias."

#: ../../library/datetime.rst:221
msgid ""
"and days, seconds and microseconds are then normalized so that the "
"representation is unique, with"
msgstr ""
"e dias, segundos e microssegundos são normalizados para que a representação "
"seja única, com"

#: ../../library/datetime.rst:224
msgid "``0 <= microseconds < 1000000``"
msgstr "``0 <= microseconds < 1000000``"

#: ../../library/datetime.rst:225
msgid "``0 <= seconds < 3600*24`` (the number of seconds in one day)"
msgstr "``0 <= seconds < 3600*24`` (o número de segundos em um dia)"

#: ../../library/datetime.rst:226
msgid "``-999999999 <= days <= 999999999``"
msgstr "``-999999999 <= days <= 999999999``"

#: ../../library/datetime.rst:228
msgid ""
"The following example illustrates how any arguments besides *days*, "
"*seconds* and *microseconds* are \"merged\" and normalized into those three "
"resulting attributes::"
msgstr ""
"O exemplo a seguir ilustra como quaisquer argumentos além de *days*, "
"*seconds* e *microseconds* são \"mesclados\" e normalizados nos três "
"atributos resultantes::"

#: ../../library/datetime.rst:232
msgid ""
">>> from datetime import timedelta\n"
">>> delta = timedelta(\n"
"...     days=50,\n"
"...     seconds=27,\n"
"...     microseconds=10,\n"
"...     milliseconds=29000,\n"
"...     minutes=5,\n"
"...     hours=8,\n"
"...     weeks=2\n"
"... )\n"
">>> # Only days, seconds, and microseconds remain\n"
">>> delta\n"
"datetime.timedelta(days=64, seconds=29156, microseconds=10)"
msgstr ""
">>> from datetime import timedelta\n"
">>> delta = timedelta(\n"
"...     days=50,\n"
"...     seconds=27,\n"
"...     microseconds=10,\n"
"...     milliseconds=29000,\n"
"...     minutes=5,\n"
"...     hours=8,\n"
"...     weeks=2\n"
"... )\n"
">>> # sá restam dias, segundos e microssegundos\n"
">>> delta\n"
"datetime.timedelta(days=64, seconds=29156, microseconds=10)"

#: ../../library/datetime.rst:246
msgid ""
"If any argument is a float and there are fractional microseconds, the "
"fractional microseconds left over from all arguments are combined and their "
"sum is rounded to the nearest microsecond using round-half-to-even "
"tiebreaker. If no argument is a float, the conversion and normalization "
"processes are exact (no information is lost)."
msgstr ""
"Se qualquer argumento for um ponto flutuante e houver microssegundos "
"fracionários, os microssegundos fracionários restantes de todos os "
"argumentos serão combinados e sua soma será arredondada para o microssegundo "
"mais próximo usando o desempatador de metade da metade para o par. Se nenhum "
"argumento é ponto flutuante, os processos de conversão e normalização são "
"exatos (nenhuma informação é perdida)."

#: ../../library/datetime.rst:253
msgid ""
"If the normalized value of days lies outside the indicated range, :exc:"
"`OverflowError` is raised."
msgstr ""
"Se o valor normalizado de dias estiver fora do intervalo indicado, a "
"exceção :exc:`OverflowError` é levantada."

#: ../../library/datetime.rst:256
msgid ""
"Note that normalization of negative values may be surprising at first. For "
"example::"
msgstr ""
"Observe que a normalização de valores negativos pode ser surpreendente a "
"princípio. Por exemplo::"

#: ../../library/datetime.rst:259
msgid ""
">>> from datetime import timedelta\n"
">>> d = timedelta(microseconds=-1)\n"
">>> (d.days, d.seconds, d.microseconds)\n"
"(-1, 86399, 999999)"
msgstr ""
">>> from datetime import timedelta\n"
">>> d = timedelta(microseconds=-1)\n"
">>> (d.days, d.seconds, d.microseconds)\n"
"(-1, 86399, 999999)"

#: ../../library/datetime.rst:264
msgid ""
"Since the string representation of :class:`!timedelta` objects can be "
"confusing, use the following recipe to produce a more readable format:"
msgstr ""
"Como a representação de string dos objetos :class:`!timedelta` pode ser "
"confusa, use a seguinte receita para produzir um formato mais legível:"

#: ../../library/datetime.rst:267
msgid ""
">>> def pretty_timedelta(td):\n"
"...     if td.days >= 0:\n"
"...         return str(td)\n"
"...     return f'-({-td!s})'\n"
"...\n"
">>> d = timedelta(hours=-1)\n"
">>> str(d)  # not human-friendly\n"
"'-1 day, 23:00:00'\n"
">>> pretty_timedelta(d)\n"
"'-(1:00:00)'"
msgstr ""
">>> def pretty_timedelta(td):\n"
"...     if td.days >= 0:\n"
"...         return str(td)\n"
"...     return f'-({-td!s})'\n"
"...\n"
">>> d = timedelta(hours=-1)\n"
">>> str(d)  # not human-friendly\n"
"'-1 day, 23:00:00'\n"
">>> pretty_timedelta(d)\n"
"'-(1:00:00)'"

#: ../../library/datetime.rst:281 ../../library/datetime.rst:615
#: ../../library/datetime.rst:1175 ../../library/datetime.rst:1813
#: ../../library/datetime.rst:2434
msgid "Class attributes:"
msgstr "Atributos de classe:"

#: ../../library/datetime.rst:285
msgid "The most negative :class:`timedelta` object, ``timedelta(-999999999)``."
msgstr "O mais negativo objeto :class:`timedelta`, ``timedelta(-999999999)``."

#: ../../library/datetime.rst:290
msgid ""
"The most positive :class:`timedelta` object, ``timedelta(days=999999999, "
"hours=23, minutes=59, seconds=59, microseconds=999999)``."
msgstr ""
"O mais positivo objeto :class:`timedelta`, ``timedelta(days=999999999, "
"hours=23, minutes=59, seconds=59, microseconds=999999)``."

#: ../../library/datetime.rst:296
msgid ""
"The smallest possible difference between non-equal :class:`timedelta` "
"objects, ``timedelta(microseconds=1)``."
msgstr ""
"A menor diferença possível entre objetos não iguais :class:`timedelta`, "
"``timedelta(microseconds=1)``."

#: ../../library/datetime.rst:299
msgid ""
"Note that, because of normalization, ``timedelta.max`` is greater than ``-"
"timedelta.min``. ``-timedelta.max`` is not representable as a :class:"
"`timedelta` object."
msgstr ""
"Observe que, devido à normalização, ``timedelta.max`` é maior que ``-"
"timedelta.min``. ``-timedelta.max`` não é representável como um objeto :"
"class:`timedelta`."

#: ../../library/datetime.rst:303 ../../library/datetime.rst:633
#: ../../library/datetime.rst:1195 ../../library/datetime.rst:1833
msgid "Instance attributes (read-only):"
msgstr "Atributos de instância (somente leitura):"

#: ../../library/datetime.rst:307
msgid "Between -999,999,999 and 999,999,999 inclusive."
msgstr "Entre -999.999.999 e 999.999.999 inclusive"

#: ../../library/datetime.rst:312
msgid "Between 0 and 86,399 inclusive."
msgstr "Entre 0 e 86.399 inclusive."

#: ../../library/datetime.rst:316
msgid ""
"It is a somewhat common bug for code to unintentionally use this attribute "
"when it is actually intended to get a :meth:`~timedelta.total_seconds` value "
"instead:"
msgstr ""
"É um bug relativamente comum utilizar este atributo de forma não intencional "
"quando, na verdade, o objetivo é obter o valor de :meth:`~timedelta."
"total_seconds`:"

#: ../../library/datetime.rst:320
msgid ""
">>> from datetime import timedelta\n"
">>> duration = timedelta(seconds=11235813)\n"
">>> duration.days, duration.seconds\n"
"(130, 3813)\n"
">>> duration.total_seconds()\n"
"11235813.0"
msgstr ""
">>> from datetime import timedelta\n"
">>> duration = timedelta(seconds=11235813)\n"
">>> duration.days, duration.seconds\n"
"(130, 3813)\n"
">>> duration.total_seconds()\n"
"11235813.0"

#: ../../library/datetime.rst:331
msgid "Between 0 and 999,999 inclusive."
msgstr "Entre 0 e 999.999 inclusive."

#: ../../library/datetime.rst:334 ../../library/datetime.rst:650
#: ../../library/datetime.rst:1248
msgid "Supported operations:"
msgstr "Operações suportadas:"

#: ../../library/datetime.rst:339 ../../library/datetime.rst:653
#: ../../library/datetime.rst:1251
msgid "Operation"
msgstr "Operação"

#: ../../library/datetime.rst:339 ../../library/datetime.rst:653
#: ../../library/datetime.rst:1251
msgid "Result"
msgstr "Resultado"

#: ../../library/datetime.rst:341
msgid "``t1 = t2 + t3``"
msgstr "``t1 = t2 + t3``"

#: ../../library/datetime.rst:341
msgid ""
"Sum of ``t2`` and ``t3``. Afterwards ``t1 - t2 == t3`` and ``t1 - t3 == t2`` "
"are true. (1)"
msgstr ""
"Soma de ``t2`` e ``t3``. Depois ``t1 - t2 == t3`` e ``t1 - t3 == t2`` são "
"verdadeiros. (1)"

#: ../../library/datetime.rst:345
msgid "``t1 = t2 - t3``"
msgstr "``t1 = t2 - t3``"

#: ../../library/datetime.rst:345
msgid ""
"Difference of ``t2``  and ``t3``. Afterwards ``t1 == t2 - t3`` and ``t2 == "
"t1 + t3`` are true. (1)(6)"
msgstr ""
"Diferença de ``t2`` e ``t3``. Depois ``t1 == t2 - t3`` e ``t2 == t1 + t3`` "
"são verdadeiros (1)(6)"

#: ../../library/datetime.rst:349
msgid "``t1 = t2 * i or t1 = i * t2``"
msgstr "``t1 = t2 * i or t1 = i * t2``"

#: ../../library/datetime.rst:349
msgid ""
"Delta multiplied by an integer. Afterwards ``t1 // i == t2`` is true, "
"provided ``i != 0``."
msgstr ""
"Delta multiplicado por um número inteiro. Depois ``t1 // i == t2`` é "
"verdadeiro, desde que ``i != 0``."

#: ../../library/datetime.rst:353
msgid "In general, ``t1  * i == t1 * (i-1) + t1`` is true. (1)"
msgstr "Em geral, ``t1 * i == t1 * (i-1) + t1`` é verdadeiro. (1)"

#: ../../library/datetime.rst:356
msgid "``t1 = t2 * f or t1 = f * t2``"
msgstr "``t1 = t2 * f or t1 = f * t2``"

#: ../../library/datetime.rst:356
msgid ""
"Delta multiplied by a float. The result is rounded to the nearest multiple "
"of timedelta.resolution using round-half-to-even."
msgstr ""
"Delta multiplicado por um float, ponto flutuante. O resultado é arredondado "
"para o múltiplo mais próximo de timedelta.resolution usando a metade da "
"metade para o par."

#: ../../library/datetime.rst:360
msgid "``f = t2 / t3``"
msgstr "``f = t2 / t3``"

#: ../../library/datetime.rst:360
msgid ""
"Division (3) of overall duration ``t2`` by interval unit ``t3``. Returns a :"
"class:`float` object."
msgstr ""
"Divisão (3) da duração total ``t2`` por unidade de intervalo ``t3``. Retorna "
"um objeto :class:`float`."

#: ../../library/datetime.rst:364
msgid "``t1 = t2 / f or t1 = t2 / i``"
msgstr "``t1 = t2 / f or t1 = t2 / i``"

#: ../../library/datetime.rst:364
msgid ""
"Delta divided by a float or an int. The result is rounded to the nearest "
"multiple of timedelta.resolution using round-half-to-even."
msgstr ""
"Delta dividido por um float ou um int. O resultado é arredondado para o "
"múltiplo mais próximo de timedelta.resolution usando a metade da metade para "
"o par."

#: ../../library/datetime.rst:368
msgid "``t1 = t2 // i`` or ``t1 = t2 // t3``"
msgstr "``t1 = t2 // i`` ou ``t1 = t2 // t3``"

#: ../../library/datetime.rst:368
msgid ""
"The floor is computed and the remainder (if any) is thrown away. In the "
"second case, an integer is returned. (3)"
msgstr ""
"O piso é calculado e o restante (se houver) é jogado fora. No segundo caso, "
"um número inteiro é retornado. (3)"

#: ../../library/datetime.rst:372
msgid "``t1 = t2 % t3``"
msgstr "``t1 = t2 % t3``"

#: ../../library/datetime.rst:372
msgid "The remainder is computed as a :class:`timedelta` object. (3)"
msgstr "O restante é calculado como um objeto :class:`timedelta`. (3)"

#: ../../library/datetime.rst:375
msgid "``q, r = divmod(t1, t2)``"
msgstr "``q, r = divmod(t1, t2)``"

#: ../../library/datetime.rst:375
msgid ""
"Computes the quotient and the remainder: ``q = t1 // t2`` (3) and ``r = t1 % "
"t2``. ``q`` is an integer and ``r`` is a :class:`timedelta` object."
msgstr ""
"Calcula o quociente e o resto: ``q = t1 // t2`` (3) e ``r = t1 % t2``. ``q`` "
"é um inteiro e ``r`` é um objeto :class:`timedelta`."

#: ../../library/datetime.rst:380
msgid "``+t1``"
msgstr "``+t1``"

#: ../../library/datetime.rst:380
msgid "Returns a :class:`timedelta` object with the same value. (2)"
msgstr "Retorna um objeto :class:`timedelta` com o mesmo valor. (2)"

#: ../../library/datetime.rst:383
msgid "``-t1``"
msgstr "``-t1``"

#: ../../library/datetime.rst:383
msgid ""
"Equivalent to ``timedelta(-t1.days, -t1.seconds, -t1.microseconds)``, and to "
"``t1 * -1``. (1)(4)"
msgstr ""
"Equivalente a ``timedelta(-t1.days, -t1.seconds, -t1.microseconds)`` e a "
"``t1 * -1``. (1)(4)"

#: ../../library/datetime.rst:387
msgid "``abs(t)``"
msgstr "``abs(t)``"

#: ../../library/datetime.rst:387
msgid ""
"Equivalent to ``+t`` when ``t.days >= 0``, and to ``-t`` when ``t.days < "
"0``. (2)"
msgstr ""
"Equivalente a ``+t`` quando ``t.days >= 0`` e a ``-t`` quando ``t.days < "
"0``. (2)"

#: ../../library/datetime.rst:390
msgid "``str(t)``"
msgstr "``str(t)``"

#: ../../library/datetime.rst:390
msgid ""
"Returns a string in the form ``[D day[s], ][H]H:MM:SS[.UUUUUU]``, where D is "
"negative for negative ``t``. (5)"
msgstr ""
"Retorna uma string no formato ``[D day[s], ][H]H:MM:SS[.UUUUUU]``, onde D é "
"negativo para ``t`` negativo. (5)"

#: ../../library/datetime.rst:394
msgid "``repr(t)``"
msgstr "``repr(t)``"

#: ../../library/datetime.rst:394
msgid ""
"Returns a string representation of the :class:`timedelta` object as a "
"constructor call with canonical attribute values."
msgstr ""
"Retorna uma representação em string do objeto :class:`timedelta` como uma "
"chamada do construtor com valores de atributos canônicos."

#: ../../library/datetime.rst:400 ../../library/datetime.rst:672
#: ../../library/datetime.rst:2663
msgid "Notes:"
msgstr "Notas:"

#: ../../library/datetime.rst:403
msgid "This is exact but may overflow."
msgstr "Isso é exato, mas pode transbordar."

#: ../../library/datetime.rst:406
msgid "This is exact and cannot overflow."
msgstr "Isso é exato e não pode transbordar."

#: ../../library/datetime.rst:409
msgid "Division by zero raises :exc:`ZeroDivisionError`."
msgstr "A divisão por zero levanta :exc:`ZeroDivisionError`."

#: ../../library/datetime.rst:412
msgid "``-timedelta.max`` is not representable as a :class:`timedelta` object."
msgstr ""
"``-timedelta.max`` não é representável como um objeto :class:`timedelta`."

#: ../../library/datetime.rst:415
msgid ""
"String representations of :class:`timedelta` objects are normalized "
"similarly to their internal representation. This leads to somewhat unusual "
"results for negative timedeltas. For example::"
msgstr ""
"As representações de string de objetos :class:`timedelta` são normalizadas "
"de maneira semelhante à sua representação interna. Isso leva a resultados um "
"tanto incomuns para timedeltas negativos. Por exemplo::"

#: ../../library/datetime.rst:419
msgid ""
">>> timedelta(hours=-5)\n"
"datetime.timedelta(days=-1, seconds=68400)\n"
">>> print(_)\n"
"-1 day, 19:00:00"
msgstr ""
">>> timedelta(hours=-5)\n"
"datetime.timedelta(days=-1, seconds=68400)\n"
">>> print(_)\n"
"-1 day, 19:00:00"

#: ../../library/datetime.rst:425
msgid ""
"The expression ``t2 - t3`` will always be equal to the expression ``t2 + (-"
"t3)`` except when t3 is equal to ``timedelta.max``; in that case the former "
"will produce a result while the latter will overflow."
msgstr ""
"A expressão ``t2 - t3`` sempre será igual à expressão ``t2 + (-t3)`` exceto "
"quando t3 for igual a ``timedelta.max``; nesse caso, o primeiro produzirá um "
"resultado enquanto o último transbordará."

#: ../../library/datetime.rst:429
msgid ""
"In addition to the operations listed above, :class:`timedelta` objects "
"support certain additions and subtractions with :class:`date` and :class:`."
"datetime` objects (see below)."
msgstr ""
"Além das operações listadas acima, os objetos :class:`timedelta` suportam "
"certas adições e subtrações com os objetos :class:`date` e :class:`."
"datetime` (veja abaixo)."

#: ../../library/datetime.rst:433
msgid ""
"Floor division and true division of a :class:`timedelta` object by another :"
"class:`timedelta` object are now supported, as are remainder operations and "
"the :func:`divmod` function. True division and multiplication of a :class:"
"`timedelta` object by a :class:`float` object are now supported."
msgstr ""
"A divisão pelo piso e a divisão verdadeira de um objeto :class:`timedelta` "
"por outro objeto :class:`timedelta` agora são suportadas, assim como as "
"operações restantes e a função :func:`divmod`. A divisão verdadeira e "
"multiplicação de um objeto :class:`timedelta` por um objeto :class:`float` "
"agora são suportadas."

#: ../../library/datetime.rst:439
msgid ":class:`timedelta` objects support equality and order comparisons."
msgstr ""
"Objetos :class:`timedelta` dão suporte a comparações de igualdade e ordem."

#: ../../library/datetime.rst:441
msgid ""
"In Boolean contexts, a :class:`timedelta` object is considered to be true if "
"and only if it isn't equal to ``timedelta(0)``."
msgstr ""
"Em contexto booleano, um objeto :class:`timedelta` é considerado verdadeiro "
"se, e somente se, não for igual a ``timedelta(0)``."

#: ../../library/datetime.rst:444 ../../library/datetime.rst:714
#: ../../library/datetime.rst:1338 ../../library/datetime.rst:1956
msgid "Instance methods:"
msgstr "Métodos de instância:"

#: ../../library/datetime.rst:448
msgid ""
"Return the total number of seconds contained in the duration. Equivalent to "
"``td / timedelta(seconds=1)``. For interval units other than seconds, use "
"the division form directly (e.g. ``td / timedelta(microseconds=1)``)."
msgstr ""
"Retorna o número total de segundos contidos na duração. Equivalente a ``td / "
"timedelta(seconds=1)``. Para unidades de intervalo diferentes de segundos, "
"use a forma de divisão diretamente (por exemplo ``td / "
"timedelta(microseconds=1)``)."

#: ../../library/datetime.rst:452
msgid ""
"Note that for very large time intervals (greater than 270 years on most "
"platforms) this method will lose microsecond accuracy."
msgstr ""
"Observe que, em intervalos de tempo muito grandes (mais de 270 anos na "
"maioria das plataformas), esse método perde a precisão de microssegundos."

#: ../../library/datetime.rst:458
msgid "Examples of usage: :class:`timedelta`"
msgstr "Exemplos de uso: :class:`.timedelta`"

#: ../../library/datetime.rst:460
msgid "An additional example of normalization::"
msgstr "Um exemplo adicional de normalização::"

#: ../../library/datetime.rst:462
msgid ""
">>> # Components of another_year add up to exactly 365 days\n"
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> another_year = timedelta(weeks=40, days=84, hours=23,\n"
"...                          minutes=50, seconds=600)\n"
">>> year == another_year\n"
"True\n"
">>> year.total_seconds()\n"
"31536000.0"
msgstr ""
">>> # Os componentes de outro_ano somam exatamente 365 dias\n"
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> outro_ano = timedelta(weeks=40, days=84, hours=23,\n"
"...                       minutes=50, seconds=600)\n"
">>> year == outro_ano\n"
"True\n"
">>> year.total_seconds()\n"
"31536000.0"

#: ../../library/datetime.rst:472
msgid "Examples of :class:`timedelta` arithmetic::"
msgstr "Exemplos de aritmética com :class:`timedelta`::"

#: ../../library/datetime.rst:474
msgid ""
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> ten_years = 10 * year\n"
">>> ten_years\n"
"datetime.timedelta(days=3650)\n"
">>> ten_years.days // 365\n"
"10\n"
">>> nine_years = ten_years - year\n"
">>> nine_years\n"
"datetime.timedelta(days=3285)\n"
">>> three_years = nine_years // 3\n"
">>> three_years, three_years.days // 365\n"
"(datetime.timedelta(days=1095), 3)"
msgstr ""
">>> from datetime import timedelta\n"
">>> ano = timedelta(days=365)\n"
">>> dez_anos = 10 * ano\n"
">>> dez_anos\n"
"datetime.timedelta(days=3650)\n"
">>> dez_anos.days // 365\n"
"10\n"
">>> nove_anos = dez_anos - ano\n"
">>> nove_anos\n"
"datetime.timedelta(days=3285)\n"
">>> três_anos = nove_anos // 3\n"
">>> três_anos, três_anos.days // 365\n"
"(datetime.timedelta(days=1095), 3)"

#: ../../library/datetime.rst:491
msgid ":class:`date` Objects"
msgstr "Objetos :class:`date`"

#: ../../library/datetime.rst:493
msgid ""
"A :class:`date` object represents a date (year, month and day) in an "
"idealized calendar, the current Gregorian calendar indefinitely extended in "
"both directions."
msgstr ""
"O objeto :class:`date` representa uma data (ano, mês e dia) em um calendário "
"idealizado, o atual calendário Gregoriano estendido indefinidamente em ambas "
"as direções."

#: ../../library/datetime.rst:497
msgid ""
"January 1 of year 1 is called day number 1, January 2 of year 1 is called "
"day number 2, and so on. [#]_"
msgstr ""
"1º de janeiro do ano 1 é chamado de dia número 1, 2º de janeiro do ano 1 é "
"chamado de dia número 2, e assim por diante. [#]_"

#: ../../library/datetime.rst:502
msgid ""
"All arguments are required. Arguments must be integers, in the following "
"ranges:"
msgstr ""
"Todos os argumentos são obrigatórios. Os argumentos devem ser números "
"inteiros, nos seguintes intervalos:"

#: ../../library/datetime.rst:505
msgid "``MINYEAR <= year <= MAXYEAR``"
msgstr "``MINYEAR <= year <= MAXYEAR``"

#: ../../library/datetime.rst:506
msgid "``1 <= month <= 12``"
msgstr "``1 <= month <= 12``"

#: ../../library/datetime.rst:507
msgid "``1 <= day <= number of days in the given month and year``"
msgstr "``1 <= day <= número de dias no mês e ano fornecidos``"

#: ../../library/datetime.rst:509 ../../library/datetime.rst:932
msgid ""
"If an argument outside those ranges is given, :exc:`ValueError` is raised."
msgstr ""
"Se um argumento fora desses intervalos for fornecido, a exceção :exc:"
"`ValueError` é levantada."

#: ../../library/datetime.rst:512 ../../library/datetime.rst:937
msgid "Other constructors, all class methods:"
msgstr "Outros construtores, todos os métodos de classe."

#: ../../library/datetime.rst:516
msgid "Return the current local date."
msgstr "Retorna a data local atual."

#: ../../library/datetime.rst:518
msgid "This is equivalent to ``date.fromtimestamp(time.time())``."
msgstr "Isso é equivalente a ``date.fromtimestamp(time.time())``."

#: ../../library/datetime.rst:522
msgid ""
"Return the local date corresponding to the POSIX timestamp, such as is "
"returned by :func:`time.time`."
msgstr ""
"Retorna a data local correspondente ao registro de data e hora do POSIX, "
"como é retornado por :func:`time.time`."

#: ../../library/datetime.rst:525
msgid ""
"This may raise :exc:`OverflowError`, if the timestamp is out of the range of "
"values supported by the platform C :c:func:`localtime` function, and :exc:"
"`OSError` on :c:func:`localtime` failure. It's common for this to be "
"restricted to years from 1970 through 2038. Note that on non-POSIX systems "
"that include leap seconds in their notion of a timestamp, leap seconds are "
"ignored by :meth:`fromtimestamp`."
msgstr ""
"Isso pode levantar :exc:`OverflowError`, se o registro de data e hora "
"estiver fora do intervalo de valores suportados pela função C :c:func:"
"`localtime` da plataforma, e em caso de falha :exc:`OSError` em :c:func:"
"`localtime`. É comum que isso seja restrito a anos de 1970 a 2038. Observe "
"que, em sistemas não POSIX que incluem segundos bissextos na sua notação de "
"registro de data e hora, os segundos bissextos são ignorados por :meth:"
"`fromtimestamp`."

#: ../../library/datetime.rst:532
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp is "
"out of the range of values supported by the platform C :c:func:`localtime` "
"function. Raise :exc:`OSError` instead of :exc:`ValueError` on :c:func:"
"`localtime` failure."
msgstr ""
"Levanta :exc:`OverflowError` ao invés de :exc:`ValueError` se o registro de "
"data e hora estiver fora do intervalo de valores suportados pela plataforma "
"C :c:func:`localtime` função. Levanta :exc:`OSError` ao invés de :exc:"
"`ValueError` em falha de :c:func:`localtime` ."

#: ../../library/datetime.rst:541
msgid ""
"Return the date corresponding to the proleptic Gregorian ordinal, where "
"January 1 of year 1 has ordinal 1."
msgstr ""
"Retorna a data correspondente ao ordinal proléptico gregoriano, considerando "
"que 1º de janeiro do ano 1 tem o ordinal 1."

#: ../../library/datetime.rst:544
msgid ""
":exc:`ValueError` is raised unless ``1 <= ordinal <= date.max.toordinal()``. "
"For any date ``d``, ``date.fromordinal(d.toordinal()) == d``."
msgstr ""
":exc:`ValueError` é levantado a menos que ``1 <= ordinal <= date.max."
"toordinal()``. Para qualquer data ``d``, ``date.fromordinal(d.toordinal()) "
"== d``."

#: ../../library/datetime.rst:551
msgid ""
"Return a :class:`date` corresponding to a *date_string* given in any valid "
"ISO 8601 format, with the following exceptions:"
msgstr ""
"Retorna um :class:`date` correspondendo a *date_string* dada em qualquer "
"formato válido de ISO 8601, com as seguintes exceções:"

#: ../../library/datetime.rst:554 ../../library/datetime.rst:1097
msgid ""
"Reduced precision dates are not currently supported (``YYYY-MM``, ``YYYY``)."
msgstr ""
"Datas de precisão reduzida não são atualmente suportadas (``YYYY-MM``, "
"``YYYY``)."

#: ../../library/datetime.rst:556 ../../library/datetime.rst:1099
msgid ""
"Extended date representations are not currently supported (``±YYYYYY-MM-"
"DD``)."
msgstr ""
"Representações de data estendidas não são atualmente suportadas (``±YYYYYY-"
"MM-DD``)."

#: ../../library/datetime.rst:558 ../../library/datetime.rst:1101
msgid "Ordinal dates are not currently supported (``YYYY-OOO``)."
msgstr "Atualmente, as datas ordinais não são suportadas (``YYYY-OOO``)."

#: ../../library/datetime.rst:560 ../../library/datetime.rst:1103
#: ../../library/datetime.rst:1569
msgid "Examples::"
msgstr "Exemplos::"

#: ../../library/datetime.rst:562
msgid ""
">>> from datetime import date\n"
">>> date.fromisoformat('2019-12-04')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('20191204')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('2021-W01-1')\n"
"datetime.date(2021, 1, 4)"
msgstr ""
">>> from datetime import date\n"
">>> date.fromisoformat('2019-12-04')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('20191204')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('2021-W01-1')\n"
"datetime.date(2021, 1, 4)"

#: ../../library/datetime.rst:571
msgid "Previously, this method only supported the format ``YYYY-MM-DD``."
msgstr ""
"Anteriormente, este método tinha suporte apenas ao formato ``YYYY-MM-DD``."

#: ../../library/datetime.rst:576
msgid ""
"Return a :class:`date` corresponding to the ISO calendar date specified by "
"year, week and day. This is the inverse of the function :meth:`date."
"isocalendar`."
msgstr ""
"Retorna um objeto :class:`date` correspondendo a data em calendário ISO "
"especificada por year, week e day. Esta é o inverso da função :meth:`date."
"isocalendar`."

#: ../../library/datetime.rst:583
msgid ""
"Return a :class:`.date` corresponding to *date_string*, parsed according to "
"*format*. This is equivalent to::"
msgstr ""
"Retorna um :class:`.date` correspondente ao *date_string*, analisado de "
"acordo com *format*. Isso equivale a::"

#: ../../library/datetime.rst:586
msgid "date(*(time.strptime(date_string, format)[0:3]))"
msgstr "date(*(time.strptime(date_string, format)[0:3]))"

#: ../../library/datetime.rst:588
msgid ""
":exc:`ValueError` is raised if the date_string and format can't be parsed "
"by :func:`time.strptime` or if it returns a value which isn't a time tuple.  "
"See also :ref:`strftime-strptime-behavior` and :meth:`date.fromisoformat`."
msgstr ""
":exc:`ValueError` é levantado se o date_string e o format não puderem ser "
"interpretados por :func:`time.strptime` ou se ele retorna um valor o qual "
"não é uma tupla temporal. Veja também :ref:`strftime-strptime-behavior` e :"
"meth:`date.fromisoformat`."

#: ../../library/datetime.rst:595
msgid ""
"If *format* specifies a day of month without a year a :exc:"
"`DeprecationWarning` is emitted.  This is to avoid a quadrennial leap year "
"bug in code seeking to parse only a month and day as the default year used "
"in absence of one in the format is not a leap year. Such *format* values may "
"raise an error as of Python 3.15.  The workaround is to always include a "
"year in your *format*.  If parsing *date_string* values that do not have a "
"year, explicitly add a year that is a leap year before parsing:"
msgstr ""
"Se *format* especificar um dia do mês sem um ano, um :exc:"
"`DeprecationWarning` é emitido. Isso é para evitar um bug de ano bissexto "
"quadrienal no código que busca analisar apenas um mês e dia, pois o ano "
"padrão usado na ausência de um no formato não é um ano bissexto. Esses "
"valores de *format* podem gerar um erro a partir do Python 3.15. A solução "
"alternativa é sempre incluir um ano em seu *format*. Se estiver analisando "
"valores de *date_string* que não têm um ano, adicione explicitamente um ano "
"que seja um ano bissexto antes da análise:"

#: ../../library/datetime.rst:604
msgid ""
">>> from datetime import date\n"
">>> date_string = \"02/29\"\n"
">>> when = date.strptime(f\"{date_string};1984\", \"%m/%d;%Y\")  # Avoids "
"leap year bug.\n"
">>> when.strftime(\"%B %d\")\n"
"'February 29'"
msgstr ""
">>> from datetime import date\n"
">>> date_string = \"02/29\"\n"
">>> when = date.strptime(f\"{date_string};1984\", \"%m/%d;%Y\")  # Evita bug "
"do ano  bissexto.\n"
">>> when.strftime(\"%B %d\")\n"
"'February 29'"

#: ../../library/datetime.rst:619
msgid "The earliest representable date, ``date(MINYEAR, 1, 1)``."
msgstr "A data representável mais antiga, ``date(MINYEAR, 1, 1)``."

#: ../../library/datetime.rst:624
msgid "The latest representable date, ``date(MAXYEAR, 12, 31)``."
msgstr "A data representável mais tardia, ``date(MAXYEAR, 12, 31)``."

#: ../../library/datetime.rst:629
msgid ""
"The smallest possible difference between non-equal date objects, "
"``timedelta(days=1)``."
msgstr ""
"A menor diferença possível entre objetos date não iguais, "
"``timedelta(days=1)``."

#: ../../library/datetime.rst:637 ../../library/datetime.rst:1199
msgid "Between :const:`MINYEAR` and :const:`MAXYEAR` inclusive."
msgstr "Entre :const:`MINYEAR` e :const:`MAXYEAR` incluindo extremos."

#: ../../library/datetime.rst:642 ../../library/datetime.rst:1204
msgid "Between 1 and 12 inclusive."
msgstr "Entre 1 e 12 incluindo extremos."

#: ../../library/datetime.rst:647 ../../library/datetime.rst:1209
msgid "Between 1 and the number of days in the given month of the given year."
msgstr "Entre 1 e o número de dias no mês especificado do ano especificado."

#: ../../library/datetime.rst:655
msgid "``date2 = date1 + timedelta``"
msgstr "``date2 = date1 + timedelta``"

#: ../../library/datetime.rst:655
msgid "``date2`` will be ``timedelta.days`` days after ``date1``. (1)"
msgstr "``date2`` terá ``timedelta.days`` dias após ``date1``. (1)"

#: ../../library/datetime.rst:658
msgid "``date2 = date1 - timedelta``"
msgstr "``date2 = date1 - timedelta``"

#: ../../library/datetime.rst:658
msgid "Computes ``date2`` such that ``date2 + timedelta == date1``. (2)"
msgstr "Calcula ``date2`` de modo que ``date2 + timedelta == date1``. (2)"

#: ../../library/datetime.rst:661
msgid "``timedelta = date1 - date2``"
msgstr "``timedelta = date1 - date2``"

#: ../../library/datetime.rst:661 ../../library/datetime.rst:1257
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/datetime.rst:0
msgid "``date1 == date2``"
msgstr "``date1 == date2``"

#: ../../library/datetime.rst:0
msgid "``date1 != date2``"
msgstr "``date1 != date2``"

#: ../../library/datetime.rst:663 ../../library/datetime.rst:1259
msgid "Equality comparison. (4)"
msgstr "Comparação de igualdade. (4)"

#: ../../library/datetime.rst:0
msgid "``date1 < date2``"
msgstr "``date1 < date2``"

#: ../../library/datetime.rst:0
msgid "``date1 > date2``"
msgstr "``date1 > date2``"

#: ../../library/datetime.rst:0
msgid "``date1 <= date2``"
msgstr "``date1 <= date2``"

#: ../../library/datetime.rst:0
msgid "``date1 >= date2``"
msgstr "``date1 >= date2``"

#: ../../library/datetime.rst:666 ../../library/datetime.rst:1262
msgid "Order comparison. (5)"
msgstr "Comparação de ordem. (5)"

#: ../../library/datetime.rst:675
msgid ""
"*date2* is moved forward in time if ``timedelta.days > 0``, or backward if "
"``timedelta.days < 0``. Afterward ``date2 - date1 == timedelta.days``. "
"``timedelta.seconds`` and ``timedelta.microseconds`` are ignored. :exc:"
"`OverflowError` is raised if ``date2.year`` would be smaller than :const:"
"`MINYEAR` or larger than :const:`MAXYEAR`."
msgstr ""
"*date2* é movida para frente no tempo se ``timedelta.days > 0``, ou para "
"trás se ``timedelta.days < 0``. Posteriormente ``date2 - date1 == timedelta."
"days``. ``timedelta.seconds`` e ``timedelta.microseconds`` são ignorados. A "
"exceção :exc:`OverflowError` é levantada se ``date2.year`` for menor que :"
"const:`MINYEAR` ou maior que :const:`MAXYEAR`."

#: ../../library/datetime.rst:682
msgid "``timedelta.seconds`` and ``timedelta.microseconds`` are ignored."
msgstr "``timedelta.seconds`` e ``timedelta.microseconds`` são ignoradas."

#: ../../library/datetime.rst:685
msgid ""
"This is exact, and cannot overflow. ``timedelta.seconds`` and ``timedelta."
"microseconds`` are 0, and ``date2 + timedelta == date1`` after."
msgstr ""
"Isso é exato e não pode estourar. ``timedelta.seconds`` e ``timedelta."
"microseconds`` são 0, e ``date2 + timedelta == date1`` depois."

#: ../../library/datetime.rst:689
msgid ":class:`date` objects are equal if they represent the same date."
msgstr "Objetos :class:`date` são iguais se representam a mesma data."

#: ../../library/datetime.rst:691
msgid ""
":class:`!date` objects that are not also :class:`.datetime` instances are "
"never equal to :class:`!datetime` objects, even if they represent the same "
"date."
msgstr ""
"Objetos :class:`!date` que não são também instâncias :class:`.datetime` "
"nunca são iguais a objetos :class:`!datetime`, mesmo que representem a mesma "
"data."

#: ../../library/datetime.rst:696
msgid ""
"*date1* is considered less than *date2* when *date1* precedes *date2* in "
"time. In other words, ``date1 < date2`` if and only if ``date1.toordinal() < "
"date2.toordinal()``."
msgstr ""
"*date1* é considerado menor que *date2* quando *date1* preceder *date2* no "
"tempo. Em outras palavras, ``date1 < date2`` se e somente se ``date1."
"toordinal() < date2.toordinal()``."

#: ../../library/datetime.rst:700
msgid ""
"Order comparison between a :class:`!date` object that is not also a :class:`."
"datetime` instance and a :class:`!datetime` object raises :exc:`TypeError`."
msgstr ""
"A comparação de ordem entre um objeto :class:`!date` que não é também uma "
"instância :class:`.datetime` e um objeto :class:`!datetime` levanta :exc:"
"`TypeError`."

#: ../../library/datetime.rst:704 ../../library/datetime.rst:1330
msgid ""
"Comparison between :class:`.datetime` object and an instance of the :class:"
"`date` subclass that is not a :class:`!datetime` subclass no longer converts "
"the latter to :class:`!date`, ignoring the time part and the time zone. The "
"default behavior can be changed by overriding the special comparison methods "
"in subclasses."
msgstr ""
"A comparação entre o objeto :class:`.datetime` e uma instância da subclasse :"
"class:`date` que não é uma subclasse :class:`!datetime` não converte mais a "
"última para :class:`!date`, ignorando o parte horária e o fuso horário. O "
"comportamento padrão pode ser alterado substituindo os métodos especiais de "
"comparação nas subclasses."

#: ../../library/datetime.rst:712
msgid ""
"In Boolean contexts, all :class:`date` objects are considered to be true."
msgstr ""
"Em contextos booleanos, todo objeto :class:`date` é considerado verdadeiro."

#: ../../library/datetime.rst:718
msgid ""
"Return a new :class:`date` object with the same values, but with specified "
"parameters updated."
msgstr ""
"Retorna um novo objeto :class:`date` com os mesmos valores, mas com os "
"parâmetros especificados atualizados."

#: ../../library/datetime.rst:721 ../../library/datetime.rst:2002
msgid "Example::"
msgstr "Exemplo::"

#: ../../library/datetime.rst:723
msgid ""
">>> from datetime import date\n"
">>> d = date(2002, 12, 31)\n"
">>> d.replace(day=26)\n"
"datetime.date(2002, 12, 26)"
msgstr ""
">>> from datetime import date\n"
">>> d = date(2002, 12, 31)\n"
">>> d.replace(day=26)\n"
"datetime.date(2002, 12, 26)"

#: ../../library/datetime.rst:728
msgid ""
"The generic function :func:`copy.replace` also supports :class:`date` "
"objects."
msgstr ""
"A função genérica :func:`copy.replace` também oferece suporte a objetos :"
"class:`date`."

#: ../../library/datetime.rst:734 ../../library/datetime.rst:1454
msgid ""
"Return a :class:`time.struct_time` such as returned by :func:`time."
"localtime`."
msgstr ""
"Retorna uma :class:`time.struct_time` tal como retornado por :func:`time."
"localtime`."

#: ../../library/datetime.rst:736
msgid "The hours, minutes and seconds are 0, and the DST flag is -1."
msgstr ""
"As horas, minutos e segundos são 0, e o sinalizador de horário de verão é -1."

#: ../../library/datetime.rst:738 ../../library/datetime.rst:1456
msgid "``d.timetuple()`` is equivalent to::"
msgstr "``d.timetuple()`` é equivalente a::"

#: ../../library/datetime.rst:740
msgid ""
"time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, -1))"
msgstr ""
"time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, -1))"

#: ../../library/datetime.rst:742
msgid ""
"where ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` is the "
"day number within the current year starting with 1 for January 1st."
msgstr ""
"sendo ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` o número "
"do dia no ano atual, começando com 1 para 1º de janeiro."

#: ../../library/datetime.rst:748
msgid ""
"Return the proleptic Gregorian ordinal of the date, where January 1 of year "
"1 has ordinal 1. For any :class:`date` object ``d``, ``date.fromordinal(d."
"toordinal()) == d``."
msgstr ""
"Retorna o ordinal proléptico gregoriano da data, considerando que 1º de "
"janeiro do ano 1 tem o ordinal 1. Para qualquer objeto :class:`date` ``d``, "
"``date.fromordinal(d.toordinal()) == d``."

#: ../../library/datetime.rst:755
msgid ""
"Return the day of the week as an integer, where Monday is 0 and Sunday is 6. "
"For example, ``date(2002, 12, 4).weekday() == 2``, a Wednesday. See also :"
"meth:`isoweekday`."
msgstr ""
"Retorna o dia da semana como um inteiro, onde Segunda é 0 e Domingo é 6. Por "
"exemplo, ``date(2002, 12, 4).weekday() == 2``, uma Quarta-feira. Veja "
"também :meth:`isoweekday`."

#: ../../library/datetime.rst:762
msgid ""
"Return the day of the week as an integer, where Monday is 1 and Sunday is 7. "
"For example, ``date(2002, 12, 4).isoweekday() == 3``, a Wednesday. See also :"
"meth:`weekday`, :meth:`isocalendar`."
msgstr ""
"Retorna o dia da semana como um inteiro, onde Segunda é 1 e Domingo é 7. Por "
"exemplo, ``date(2002, 12, 4).isoweekday() == 3``, uma Quarta-feira. Veja "
"também :meth:`weekday`, :meth:`isocalendar`."

#: ../../library/datetime.rst:769
msgid ""
"Return a :term:`named tuple` object with three components: ``year``, "
"``week`` and ``weekday``."
msgstr ""
"Retorna um objeto :term:`tupla nomeada <named tuple>` com três componentes: "
"``year``, ``week`` e ``weekday``."

#: ../../library/datetime.rst:772
msgid ""
"The ISO calendar is a widely used variant of the Gregorian calendar. [#]_"
msgstr ""
"O calendário ISO é uma variação amplamente usada do calendário gregoriano. "
"[#]_"

#: ../../library/datetime.rst:774
msgid ""
"The ISO year consists of 52 or 53 full weeks, and where a week starts on a "
"Monday and ends on a Sunday. The first week of an ISO year is the first "
"(Gregorian) calendar week of a year containing a Thursday. This is called "
"week number 1, and the ISO year of that Thursday is the same as its "
"Gregorian year."
msgstr ""
"O ano ISO consiste de 52 ou 53 semanas completas, e onde uma semana começa "
"na segunda-feira e termina no domingo. A primeira semana de um ano ISO é a "
"primeira semana no calendário (Gregoriano) de um ano contendo uma quinta-"
"feira. Isso é chamado de semana número 1, e o ano ISO dessa quinta-feira é o "
"mesmo que o seu ano Gregoriano."

#: ../../library/datetime.rst:779
msgid ""
"For example, 2004 begins on a Thursday, so the first week of ISO year 2004 "
"begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan 2004::"
msgstr ""
"Por exemplo, 2004 começa em uma quinta-feira, então a primeira semana do ano "
"ISO 2004 começa na segunda-feira, 29 de dezembro de 2003, e termina no "
"domingo, 4 de janeiro de 2004::"

#: ../../library/datetime.rst:782
msgid ""
">>> from datetime import date\n"
">>> date(2003, 12, 29).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=1)\n"
">>> date(2004, 1, 4).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=7)"
msgstr ""
">>> from datetime import date\n"
">>> date(2003, 12, 29).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=1)\n"
">>> date(2004, 1, 4).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=7)"

#: ../../library/datetime.rst:788
msgid "Result changed from a tuple to a :term:`named tuple`."
msgstr ""
"Resultado alterado de uma tupla para uma :term:`tupla nomeada <named tuple>`."

#: ../../library/datetime.rst:793
msgid ""
"Return a string representing the date in ISO 8601 format, ``YYYY-MM-DD``::"
msgstr ""
"Retorna uma string representando a data no formato ISO 8601, ``YYYY-MM-DD``::"

#: ../../library/datetime.rst:795
msgid ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).isoformat()\n"
"'2002-12-04'"
msgstr ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).isoformat()\n"
"'2002-12-04'"

#: ../../library/datetime.rst:801
msgid "For a date ``d``, ``str(d)`` is equivalent to ``d.isoformat()``."
msgstr "Para um data ``d``, ``str(d)`` é equivalente a ``d.isoformat()``."

#: ../../library/datetime.rst:806
msgid "Return a string representing the date::"
msgstr "Retorna uma string representando a data::"

#: ../../library/datetime.rst:808
msgid ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).ctime()\n"
"'Wed Dec  4 00:00:00 2002'"
msgstr ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).ctime()\n"
"'Wed Dec  4 00:00:00 2002'"

#: ../../library/datetime.rst:812 ../../library/datetime.rst:1640
msgid "``d.ctime()`` is equivalent to::"
msgstr "``d.ctime()`` é equivalente a::"

#: ../../library/datetime.rst:814 ../../library/datetime.rst:1642
msgid "time.ctime(time.mktime(d.timetuple()))"
msgstr "time.ctime(time.mktime(d.timetuple()))"

#: ../../library/datetime.rst:816
msgid ""
"on platforms where the native C :c:func:`ctime` function (which :func:`time."
"ctime` invokes, but which :meth:`date.ctime` does not invoke) conforms to "
"the C standard."
msgstr ""
"em plataformas em que a função C nativa :c:func:`ctime` (que é invocada pela "
"função :func:`time.ctime`, mas não pelo método :meth:`.date.ctime`) se "
"conforma com o padrão C."

#: ../../library/datetime.rst:823
msgid ""
"Return a string representing the date, controlled by an explicit format "
"string. Format codes referring to hours, minutes or seconds will see 0 "
"values. See also :ref:`strftime-strptime-behavior` and :meth:`date."
"isoformat`."
msgstr ""
"Retorna uma string representando a data, controlado por uma string explícita "
"de formatação. Códigos de formatação referenciando horas, minutos ou "
"segundos irão ver valores 0. Veja também :ref:`strftime-strptime-behavior` "
"e :meth:`date.isoformat`."

#: ../../library/datetime.rst:830
msgid ""
"Same as :meth:`.date.strftime`. This makes it possible to specify a format "
"string for a :class:`.date` object in :ref:`formatted string literals <f-"
"strings>` and when using :meth:`str.format`. See also :ref:`strftime-"
"strptime-behavior` and :meth:`date.isoformat`."
msgstr ""
"O mesmo que :meth:`.date.strftime`. Isso torna possível especificar uma "
"string de formatação para o objeto :class:`.date` em :ref:`literais de "
"string formatados <f-strings>` e ao usar :meth:`str.format`. Veja também :"
"ref:`strftime-strptime-behavior` e :meth:`date.isoformat`."

#: ../../library/datetime.rst:836
msgid "Examples of Usage: :class:`date`"
msgstr "Exemplos de uso: :class:`.date`"

#: ../../library/datetime.rst:838
msgid "Example of counting days to an event::"
msgstr "Exemplo de contagem de dias para um evento::"

#: ../../library/datetime.rst:840
msgid ""
">>> import time\n"
">>> from datetime import date\n"
">>> today = date.today()\n"
">>> today\n"
"datetime.date(2007, 12, 5)\n"
">>> today == date.fromtimestamp(time.time())\n"
"True\n"
">>> my_birthday = date(today.year, 6, 24)\n"
">>> if my_birthday < today:\n"
"...     my_birthday = my_birthday.replace(year=today.year + 1)\n"
"...\n"
">>> my_birthday\n"
"datetime.date(2008, 6, 24)\n"
">>> time_to_birthday = abs(my_birthday - today)\n"
">>> time_to_birthday.days\n"
"202"
msgstr ""
">>> import time\n"
">>> from datetime import date\n"
">>> hoje = date.today()\n"
">>> hoje\n"
"datetime.date(2007, 12, 5)\n"
">>> hoje == date.fromtimestamp(time.time())\n"
"True\n"
">>> meu_aniversário = date(hoje.year, 6, 24)\n"
">>> if meu_aniversário < hoje:\n"
"...     meu_aniversário = meu_aniversário.replace(year=hoje.year + 1)\n"
"...\n"
">>> meu_aniversário\n"
"datetime.date(2008, 6, 24)\n"
">>> tempo_até_aniversário = abs(meu_aniversário - hoje)\n"
">>> tempo_até_aniversário.days\n"
"202"

#: ../../library/datetime.rst:857
msgid "More examples of working with :class:`date`:"
msgstr "Mais exemplos de uso da classe :class:`.date`:"

#: ../../library/datetime.rst:859
msgid ""
">>> from datetime import date\n"
">>> d = date.fromordinal(730920) # 730920th day after 1. 1. 0001\n"
">>> d\n"
"datetime.date(2002, 3, 11)\n"
"\n"
">>> # Methods related to formatting string output\n"
">>> d.isoformat()\n"
"'2002-03-11'\n"
">>> d.strftime(\"%d/%m/%y\")\n"
"'11/03/02'\n"
">>> d.strftime(\"%A %d. %B %Y\")\n"
"'Monday 11. March 2002'\n"
">>> d.ctime()\n"
"'Mon Mar 11 00:00:00 2002'\n"
">>> 'The {1} is {0:%d}, the {2} is {0:%B}.'.format(d, \"day\", \"month\")\n"
"'The day is 11, the month is March.'\n"
"\n"
">>> # Methods for to extracting 'components' under different calendars\n"
">>> t = d.timetuple()\n"
">>> for i in t:\n"
"...     print(i)\n"
"2002                # year\n"
"3                   # month\n"
"11                  # day\n"
"0\n"
"0\n"
"0\n"
"0                   # weekday (0 = Monday)\n"
"70                  # 70th day in the year\n"
"-1\n"
">>> ic = d.isocalendar()\n"
">>> for i in ic:\n"
"...     print(i)\n"
"2002                # ISO year\n"
"11                  # ISO week number\n"
"1                   # ISO day number ( 1 = Monday )\n"
"\n"
">>> # A date object is immutable; all operations produce a new object\n"
">>> d.replace(year=2005)\n"
"datetime.date(2005, 3, 11)"
msgstr ""
">>> from datetime import date\n"
">>> d = date.fromordinal(730920) # 730920th day after 1. 1. 0001\n"
">>> d\n"
"datetime.date(2002, 3, 11)\n"
"\n"
">>> # Methods related to formatting string output\n"
">>> d.isoformat()\n"
"'2002-03-11'\n"
">>> d.strftime(\"%d/%m/%y\")\n"
"'11/03/02'\n"
">>> d.strftime(\"%A %d. %B %Y\")\n"
"'Monday 11. March 2002'\n"
">>> d.ctime()\n"
"'Mon Mar 11 00:00:00 2002'\n"
">>> 'The {1} is {0:%d}, the {2} is {0:%B}.'.format(d, \"day\", \"month\")\n"
"'The day is 11, the month is March.'\n"
"\n"
">>> # Methods for to extracting 'components' under different calendars\n"
">>> t = d.timetuple()\n"
">>> for i in t:\n"
"...     print(i)\n"
"2002                # year\n"
"3                   # month\n"
"11                  # day\n"
"0\n"
"0\n"
"0\n"
"0                   # weekday (0 = Monday)\n"
"70                  # 70th day in the year\n"
"-1\n"
">>> ic = d.isocalendar()\n"
">>> for i in ic:\n"
"...     print(i)\n"
"2002                # ISO year\n"
"11                  # ISO week number\n"
"1                   # ISO day number ( 1 = Monday )\n"
"\n"
">>> # A date object is immutable; all operations produce a new object\n"
">>> d.replace(year=2005)\n"
"datetime.date(2005, 3, 11)"

#: ../../library/datetime.rst:906
msgid ":class:`.datetime` Objects"
msgstr "Objetos :class:`.datetime`"

#: ../../library/datetime.rst:908
msgid ""
"A :class:`.datetime` object is a single object containing all the "
"information from a :class:`date` object and a :class:`.time` object."
msgstr ""
"Um objeto :class:`.datetime` é um único objeto contendo todas as informações "
"de um objeto :class:`.date` e um objeto :class:`.time`."

#: ../../library/datetime.rst:911
msgid ""
"Like a :class:`date` object, :class:`.datetime` assumes the current "
"Gregorian calendar extended in both directions; like a :class:`.time` "
"object, :class:`.datetime` assumes there are exactly 3600\\*24 seconds in "
"every day."
msgstr ""
"Assim como um objeto :class:`date`, :class:`.datetime` presume o atual "
"calendário Gregoriano estendido em ambas as direções; assim como um objeto :"
"class:`.time`, :class:`.datetime` presume que existem exatamente 3600\\*24 "
"segundos em cada dia."

#: ../../library/datetime.rst:915
msgid "Constructor:"
msgstr "Construtor:"

#: ../../library/datetime.rst:919
msgid ""
"The *year*, *month* and *day* arguments are required. *tzinfo* may be "
"``None``, or an instance of a :class:`tzinfo` subclass. The remaining "
"arguments must be integers in the following ranges:"
msgstr ""
"Os argumentos *year*, *month* e *day* são obrigatórios. *tzinfo* pode ser "
"``None``, ou uma instância de subclasse de :class:`tzinfo`. Os argumentos "
"remanescentes devem ser inteiros nos seguintes intervalos:"

#: ../../library/datetime.rst:923
msgid "``MINYEAR <= year <= MAXYEAR``,"
msgstr "``MINYEAR <= year <= MAXYEAR``,"

#: ../../library/datetime.rst:924
msgid "``1 <= month <= 12``,"
msgstr "``1 <= month <= 12``,"

#: ../../library/datetime.rst:925
msgid "``1 <= day <= number of days in the given month and year``,"
msgstr "``1 <= day <= número de dias no mês e ano fornecidos``,"

#: ../../library/datetime.rst:926 ../../library/datetime.rst:1804
msgid "``0 <= hour < 24``,"
msgstr "``0 <= hour < 24``,"

#: ../../library/datetime.rst:927 ../../library/datetime.rst:1805
msgid "``0 <= minute < 60``,"
msgstr "``0 <= minute < 60``,"

#: ../../library/datetime.rst:928 ../../library/datetime.rst:1806
msgid "``0 <= second < 60``,"
msgstr "``0 <= second < 60``,"

#: ../../library/datetime.rst:929 ../../library/datetime.rst:1807
msgid "``0 <= microsecond < 1000000``,"
msgstr "``0 <= microsecond < 1000000``,"

#: ../../library/datetime.rst:930 ../../library/datetime.rst:1808
msgid "``fold in [0, 1]``."
msgstr "``fold in [0, 1]``."

#: ../../library/datetime.rst:934 ../../library/datetime.rst:1375
#: ../../library/datetime.rst:1969
msgid "Added the *fold* parameter."
msgstr "Adicionado o parâmetro *fold*."

#: ../../library/datetime.rst:941
msgid "Return the current local date and time, with :attr:`.tzinfo` ``None``."
msgstr ""
"Retorna a data e hora local atual, com o atributo :attr:`.tzinfo` definido "
"para ``None``."

#: ../../library/datetime.rst:943
msgid "Equivalent to::"
msgstr "Equivalente a::"

#: ../../library/datetime.rst:945
msgid "datetime.fromtimestamp(time.time())"
msgstr "datetime.fromtimestamp(time.time())"

#: ../../library/datetime.rst:947
msgid "See also :meth:`now`, :meth:`fromtimestamp`."
msgstr "Veja também :meth:`now`, :meth:`fromtimestamp`."

#: ../../library/datetime.rst:949
msgid ""
"This method is functionally equivalent to :meth:`now`, but without a ``tz`` "
"parameter."
msgstr ""
"Este método é funcionalmente equivalente a :meth:`now`, mas sem um parâmetro "
"``tz``."

#: ../../library/datetime.rst:954
msgid "Return the current local date and time."
msgstr "Retorna a data e hora local atual."

#: ../../library/datetime.rst:956
msgid ""
"If optional argument *tz* is ``None`` or not specified, this is like :meth:"
"`today`, but, if possible, supplies more precision than can be gotten from "
"going through a :func:`time.time` timestamp (for example, this may be "
"possible on platforms supplying the C :c:func:`gettimeofday` function)."
msgstr ""
"Se o argumento opcional *tz* é ``None`` ou não especificado, isto é o mesmo "
"que :meth:`today`, mas, se possível, fornece mais precisão do que pode ser "
"obtido indo por um registro de data e hora da função :func:`time.time` (por "
"exemplo, isto pode ser possível em plataformas que fornecem a função C :c:"
"func:`gettimeofday`)."

#: ../../library/datetime.rst:962
msgid ""
"If *tz* is not ``None``, it must be an instance of a :class:`tzinfo` "
"subclass, and the current date and time are converted to *tz*’s time zone."
msgstr ""
"Se *tz* não for ``None``, ele deve ser uma instância de uma subclasse de :"
"class:`tzinfo`, e a data e hora local atual são convertidas para o fuso "
"horário de *tz*."

#: ../../library/datetime.rst:965
msgid "This function is preferred over :meth:`today` and :meth:`utcnow`."
msgstr "Esta função é preferida ao invés de :meth:`today` e :meth:`utcnow`."

#: ../../library/datetime.rst:969
msgid ""
"Subsequent calls to :meth:`!datetime.now` may return the same instant "
"depending on the precision of the underlying clock."
msgstr ""
"Chamadas subsequentes para :meth:`!datetime.now` podem retornar o mesmo "
"instante, dependendo da precisão do relógio subjacente."

#: ../../library/datetime.rst:974
msgid "Return the current UTC date and time, with :attr:`.tzinfo` ``None``."
msgstr "Retorna a data e hora atual em UTC, com :attr:`.tzinfo` como ``None``."

#: ../../library/datetime.rst:976
msgid ""
"This is like :meth:`now`, but returns the current UTC date and time, as a "
"naive :class:`.datetime` object. An aware current UTC datetime can be "
"obtained by calling ``datetime.now(timezone.utc)``. See also :meth:`now`."
msgstr ""
"Este é similar a :meth:`now`, mas retorna a data e hora atual em UTC, como "
"um objeto :class:`.datetime` ingênuo. Um datetime UTC consciente pode ser "
"obtido chamando ``datetime.now(timezone.utc)``. Veja também :meth:`now`."

#: ../../library/datetime.rst:982
msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` methods "
"as local times, it is preferred to use aware datetimes to represent times in "
"UTC. As such, the recommended way to create an object representing the "
"current time in UTC is by calling ``datetime.now(timezone.utc)``."
msgstr ""
"Devido ao fato de objetos ``datetime`` ingênuos serem tratados por muitos "
"métodos ``datetime`` como hora local, é preferível usar datetimes "
"conscientes para representar horas em UTC. De tal forma, a maneira "
"recomendada para criar um objeto representando a hora local em UTC é "
"chamando ``datetime.now(timezone.utc)``."

#: ../../library/datetime.rst:989
msgid "Use :meth:`datetime.now` with :const:`UTC` instead."
msgstr "Use :meth:`datetime.now` com :const:`UTC`."

#: ../../library/datetime.rst:994
msgid ""
"Return the local date and time corresponding to the POSIX timestamp, such as "
"is returned by :func:`time.time`. If optional argument *tz* is ``None`` or "
"not specified, the timestamp is converted to the platform's local date and "
"time, and the returned :class:`.datetime` object is naive."
msgstr ""
"Retorna a data e hora local correspondente ao registro de data e hora POSIX, "
"como é retornado por :func:`time.time`. Se o argumento opcional *tz* é "
"``None`` ou não especificado, o registro de data e hora é convertido para a "
"data e hora local da plataforma, e o objeto :class:`.datetime` retornado é "
"ingênuo."

#: ../../library/datetime.rst:999
msgid ""
"If *tz* is not ``None``, it must be an instance of a :class:`tzinfo` "
"subclass, and the timestamp is converted to *tz*’s time zone."
msgstr ""
"Se *tz* não for ``None``, ela deve ser uma instância de uma subclasse de :"
"class:`tzinfo`, e o registro de data e hora é convertido para o fuso horário "
"de *tz*."

#: ../../library/datetime.rst:1002
msgid ""
":meth:`fromtimestamp` may raise :exc:`OverflowError`, if the timestamp is "
"out of the range of values supported by the platform C :c:func:`localtime` "
"or :c:func:`gmtime` functions, and :exc:`OSError` on :c:func:`localtime` or :"
"c:func:`gmtime` failure. It's common for this to be restricted to years in "
"1970 through 2038. Note that on non-POSIX systems that include leap seconds "
"in their notion of a timestamp, leap seconds are ignored by :meth:"
"`fromtimestamp`, and then it's possible to have two timestamps differing by "
"a second that yield identical :class:`.datetime` objects. This method is "
"preferred over :meth:`utcfromtimestamp`."
msgstr ""
":meth:`fromtimestamp` pode levantar :exc:`OverflowError`, se o registro de "
"data e hora estiver fora do intervalo de valores suportados pelas funções em "
"C :c:func:`localtime` ou :c:func:`gmtime` da plataforma, e ocorrer uma falha "
"de :exc:`OSError` em :c:func:`localtime` ou :c:func:`gmtime`. É comum para "
"isso ser restrito aos anos 1970 até 2038. Perceba que em sistemas não-POSIX "
"que incluem segundos bissextos na sua notação de registro de data e hora, "
"segundos bissextos são ignorados por :meth:`fromtimestamp`, e então é "
"possível ter dois registros de data e hora com diferença de um segundo que "
"apresentam objetos :class:`.datetime` idênticos. Este método é preferido "
"sobre :meth:`utcfromtimestamp`."

#: ../../library/datetime.rst:1013
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp is "
"out of the range of values supported by the platform C :c:func:`localtime` "
"or :c:func:`gmtime` functions. Raise :exc:`OSError` instead of :exc:"
"`ValueError` on :c:func:`localtime` or :c:func:`gmtime` failure."
msgstr ""
"Levanta um :exc:`OverflowError` ao invés de :exc:`ValueError` se o registro "
"de data e hora estiver fora do intervalo dos valores suportados pelas "
"funções C :c:func:`localtime` ou :c:func:`gmtime` da plataforma. Levanta :"
"exc:`OSError` ao invés de :exc:`ValueError` em falhas de :c:func:`localtime` "
"ou :c:func:`gmtime`."

#: ../../library/datetime.rst:1020
msgid ":meth:`fromtimestamp` may return instances with :attr:`.fold` set to 1."
msgstr ""
":meth:`fromtimestamp` pode retornar instâncias com :attr:`.fold` igual a 1."

#: ../../library/datetime.rst:1025
msgid ""
"Return the UTC :class:`.datetime` corresponding to the POSIX timestamp, "
"with :attr:`.tzinfo` ``None``.  (The resulting object is naive.)"
msgstr ""
"Retorna o :class:`.datetime` UTC correspondente ao registro de data e hora "
"POSIX, com :attr:`.tzinfo` setado para ``None``. (O objeto resultante é "
"ingênuo.)"

#: ../../library/datetime.rst:1028
msgid ""
"This may raise :exc:`OverflowError`, if the timestamp is out of the range of "
"values supported by the platform C :c:func:`gmtime` function, and :exc:"
"`OSError` on :c:func:`gmtime` failure. It's common for this to be restricted "
"to years in 1970 through 2038."
msgstr ""
"Isso pode levantar :exc:`OverflowError`, se o registro de data e hora "
"estiver fora do intervalo de valores suportados pela função C :c:func:"
"`gmtime` da plataforma, e em caso de falha :exc:`OSError` em :c:func:"
"`gmtime`. É comum que isso seja restrito a anos de 1970 a 2038."

#: ../../library/datetime.rst:1033
msgid "To get an aware :class:`.datetime` object, call :meth:`fromtimestamp`::"
msgstr ""
"Para conseguir um objeto :class:`.datetime` consciente, chame :meth:"
"`fromtimestamp`::"

#: ../../library/datetime.rst:1035
msgid "datetime.fromtimestamp(timestamp, timezone.utc)"
msgstr "datetime.fromtimestamp(timestamp, timezone.utc)"

#: ../../library/datetime.rst:1037
msgid ""
"On the POSIX compliant platforms, it is equivalent to the following "
"expression::"
msgstr ""
"Nas plataformas compatíveis com POSIX, é equivalente à seguinte expressão::"

#: ../../library/datetime.rst:1040
msgid ""
"datetime(1970, 1, 1, tzinfo=timezone.utc) + timedelta(seconds=timestamp)"
msgstr ""
"datetime(1970, 1, 1, tzinfo=timezone.utc) + timedelta(seconds=timestamp)"

#: ../../library/datetime.rst:1042
msgid ""
"except the latter formula always supports the full years range: between :"
"const:`MINYEAR` and :const:`MAXYEAR` inclusive."
msgstr ""
"com a exceção de que a última fórmula sempre dá suporte ao intervalo "
"completo de anos: entre :const:`MINYEAR` e :const:`MAXYEAR` inclusive."

#: ../../library/datetime.rst:1047
msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` methods "
"as local times, it is preferred to use aware datetimes to represent times in "
"UTC. As such, the recommended way to create an object representing a "
"specific timestamp in UTC is by calling ``datetime.fromtimestamp(timestamp, "
"tz=timezone.utc)``."
msgstr ""
"Devido ao fato de objetos ``datetime`` ingênuos serem tratados por muitos "
"métodos ``datetime`` como hora local, é preferível usar datetimes "
"conscientes para representar horas em UTC. De tal forma, a maneira "
"recomendada para criar um objeto representando um registro de data e hora "
"específico em UTC é chamando ``datetime.fromtimestamp(timestamp, tz=timezone."
"utc)``."

#: ../../library/datetime.rst:1053
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp is "
"out of the range of values supported by the platform C :c:func:`gmtime` "
"function. Raise :exc:`OSError` instead of :exc:`ValueError` on :c:func:"
"`gmtime` failure."
msgstr ""
"Levanta :exc:`OverflowError` ao invés de :exc:`ValueError` se o registro de "
"data e hora estiver fora do intervalo de valores suportados pela função C :c:"
"func:`gmtime` da plataforma. Levanta :exc:`OSError` ao invés de :exc:"
"`ValueError` em caso de falha :c:func:`gmtime`."

#: ../../library/datetime.rst:1061
msgid "Use :meth:`datetime.fromtimestamp` with :const:`UTC` instead."
msgstr "Use :meth:`datetime.fromtimestamp` com :const:`UTC`."

#: ../../library/datetime.rst:1066
msgid ""
"Return the :class:`.datetime` corresponding to the proleptic Gregorian "
"ordinal, where January 1 of year 1 has ordinal 1. :exc:`ValueError` is "
"raised unless ``1 <= ordinal <= datetime.max.toordinal()``. The hour, "
"minute, second and microsecond of the result are all 0, and :attr:`.tzinfo` "
"is ``None``."
msgstr ""
"Retorna um :class:`.datetime` correspondente ao ordinal proléptico "
"Gregoriano, onde 1º de janeiro do ano 1 tem ordinal 1. :exc:`ValueError` é "
"levantado a não ser que ``1 <= ordinal <= datetime.max.toordinal()``. As "
"horas, minutos, segundos e micro segundos do resultado são todos 0, e :attr:"
"`.tzinfo` é ``None``."

#: ../../library/datetime.rst:1074
msgid ""
"Return a new :class:`.datetime` object whose date components are equal to "
"the given :class:`date` object's, and whose time components are equal to the "
"given :class:`.time` object's. If the *tzinfo* argument is provided, its "
"value is used to set the :attr:`.tzinfo` attribute of the result, otherwise "
"the :attr:`~.time.tzinfo` attribute of the *time* argument is used.  If the "
"*date* argument is a :class:`.datetime` object, its time components and :"
"attr:`.tzinfo` attributes are ignored."
msgstr ""
"Retorna um novo objeto :class:`.datetime` no qual os componentes de data são "
"iguais ao objeto :class:`date` fornecido, e nos quais os componentes de hora "
"são iguais ao do objeto :class:`.time` fornecido. Se o argumento *tzinfo* é "
"fornecido, seu valor é usado para definir o atributo :attr:`.tzinfo` do "
"resultado, caso contrário o atributo :attr:`~.time.tzinfo` do argumento "
"*time* é usado. Se o argumento *date* é um objeto :class:`.datetime`, seus "
"componentes de hora e atributos :attr:`.tzinfo` são ignorados."

#: ../../library/datetime.rst:1082
msgid ""
"For any :class:`.datetime` object ``d``, ``d == datetime.combine(d.date(), d."
"time(), d.tzinfo)``."
msgstr ""
"Para qualquer objeto :class:`.datetime` ``d``, ``d == datetime.combine(d."
"date(), d.time(), d.tzinfo)``."

#: ../../library/datetime.rst:1085
msgid "Added the *tzinfo* argument."
msgstr "Adicionado o argumento *tzinfo*."

#: ../../library/datetime.rst:1091
msgid ""
"Return a :class:`.datetime` corresponding to a *date_string* in any valid "
"ISO 8601 format, with the following exceptions:"
msgstr ""
"Retorna um :class:`.datetime` correspondendo a *date_string* em qualquer "
"formato válido de ISO 8601, com as seguintes exceções:"

#: ../../library/datetime.rst:1094 ../../library/datetime.rst:1904
msgid "Time zone offsets may have fractional seconds."
msgstr "Os deslocamentos de fuso horário podem ter segundos fracionários."

#: ../../library/datetime.rst:1095
msgid "The ``T`` separator may be replaced by any single unicode character."
msgstr ""
"O separador ``T`` pode ser substituído por qualquer caractere unicode único."

#: ../../library/datetime.rst:1096 ../../library/datetime.rst:1909
msgid "Fractional hours and minutes are not supported."
msgstr "Horas e minutos fracionários não são suportados."

#: ../../library/datetime.rst:1105
msgid ""
">>> from datetime import datetime\n"
">>> datetime.fromisoformat('2011-11-04')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('20111104')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23Z')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, tzinfo=datetime.timezone.utc)\n"
">>> datetime.fromisoformat('20111104T000523')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-W01-2T00:05:23.283')\n"
"datetime.datetime(2011, 1, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283+00:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000, tzinfo=datetime.timezone."
"utc)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23+04:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23,\n"
"    tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))"
msgstr ""
">>> from datetime import datetime\n"
">>> datetime.fromisoformat('2011-11-04')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('20111104')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23Z')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, tzinfo=datetime.timezone.utc)\n"
">>> datetime.fromisoformat('20111104T000523')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-W01-2T00:05:23.283')\n"
"datetime.datetime(2011, 1, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283+00:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000, tzinfo=datetime.timezone."
"utc)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23+04:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23,\n"
"    tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))"

#: ../../library/datetime.rst:1127
msgid ""
"Previously, this method only supported formats that could be emitted by :"
"meth:`date.isoformat` or :meth:`datetime.isoformat`."
msgstr ""
"Anteriormente, este método suportava apenas formatos que podiam ser emitidos "
"por :meth:`date.isoformat` ou :meth:`datetime.isoformat`."

#: ../../library/datetime.rst:1134
msgid ""
"Return a :class:`.datetime` corresponding to the ISO calendar date specified "
"by year, week and day. The non-date components of the datetime are populated "
"with their normal default values. This is the inverse of the function :meth:"
"`datetime.isocalendar`."
msgstr ""
"Retorna um :class:`.datetime` correspondente à data no calendário ISO "
"especificada por *year*, *week* e *day*. Os componentes não-data do datetime "
"são preenchidos normalmente com seus valores padrões. Isso é o inverso da "
"função :meth:`datetime.isocalendar`."

#: ../../library/datetime.rst:1143
msgid ""
"Return a :class:`.datetime` corresponding to *date_string*, parsed according "
"to *format*."
msgstr ""
"Retorna um :class:`.datetime` correspondente ao *date_string*, analisado de "
"acordo com *format*."

#: ../../library/datetime.rst:1146
msgid ""
"If *format* does not contain microseconds or time zone information, this is "
"equivalent to::"
msgstr ""
"Se *format* não contiver microssegundos ou informações de fuso horário, isso "
"é equivalente a::"

#: ../../library/datetime.rst:1148 ../../library/datetime.rst:2643
msgid "datetime(*(time.strptime(date_string, format)[0:6]))"
msgstr "datetime(*(time.strptime(date_string, format)[0:6]))"

#: ../../library/datetime.rst:1150
msgid ""
":exc:`ValueError` is raised if the date_string and format can't be parsed "
"by :func:`time.strptime` or if it returns a value which isn't a time tuple.  "
"See also :ref:`strftime-strptime-behavior` and :meth:`datetime."
"fromisoformat`."
msgstr ""
":exc:`ValueError` é levantado se o date_string e o format não puderem ser "
"interpretados por :func:`time.strptime` ou se ele retorna um valor o qual "
"não é uma tupla temporal. Veja também :ref:`strftime-strptime-behavior` e :"
"meth:`datetime.fromisoformat`."

#: ../../library/datetime.rst:1157
msgid ""
"If *format* specifies a day of month without a year a :exc:"
"`DeprecationWarning` is now emitted.  This is to avoid a quadrennial leap "
"year bug in code seeking to parse only a month and day as the default year "
"used in absence of one in the format is not a leap year. Such *format* "
"values may raise an error as of Python 3.15.  The workaround is to always "
"include a year in your *format*.  If parsing *date_string* values that do "
"not have a year, explicitly add a year that is a leap year before parsing:"
msgstr ""
"Se *format* especificar um dia do mês sem um ano, um :exc:"
"`DeprecationWarning` agora é emitido. Isso é para evitar um bug de ano "
"bissexto quadrienal no código que busca analisar apenas um mês e dia, pois o "
"ano padrão usado na ausência de um no formato não é um ano bissexto. Esses "
"valores de *format* podem gerar um erro a partir do Python 3.15. A solução "
"alternativa é sempre incluir um ano em seu *format*. Se estiver analisando "
"valores de *date_string* que não têm um ano, adicione explicitamente um ano "
"que seja um ano bissexto antes da análise:"

#: ../../library/datetime.rst:1166
msgid ""
">>> from datetime import datetime\n"
">>> date_string = \"02/29\"\n"
">>> when = datetime.strptime(f\"{date_string};1984\", \"%m/%d;%Y\")  # "
"Avoids leap year bug.\n"
">>> when.strftime(\"%B %d\")\n"
"'February 29'"
msgstr ""
">>> from datetime import datetime\n"
">>> date_string = \"02/29\"\n"
">>> when = datetime.strptime(f\"{date_string};1984\", \"%m/%d;%Y\")  # "
"Avoids leap year bug.\n"
">>> when.strftime(\"%B %d\")\n"
"'February 29'"

#: ../../library/datetime.rst:1179
msgid ""
"The earliest representable :class:`.datetime`, ``datetime(MINYEAR, 1, 1, "
"tzinfo=None)``."
msgstr ""
"O primeiro :class:`.datetime` representável, ``datetime(MINYEAR, 1, 1, "
"tzinfo=None)``."

#: ../../library/datetime.rst:1185
msgid ""
"The latest representable :class:`.datetime`, ``datetime(MAXYEAR, 12, 31, 23, "
"59, 59, 999999, tzinfo=None)``."
msgstr ""
"O último :class:`.datetime` representável, ``datetime(MAXYEAR, 12, 31, 23, "
"59, 59, 999999, tzinfo=None)``."

#: ../../library/datetime.rst:1191
msgid ""
"The smallest possible difference between non-equal :class:`.datetime` "
"objects, ``timedelta(microseconds=1)``."
msgstr ""
"A menor diferença possível entre objetos :class:`.datetime` diferentes, "
"``timedelta(microseconds=1)``."

#: ../../library/datetime.rst:1214 ../../library/datetime.rst:1837
msgid "In ``range(24)``."
msgstr "No intervalo ``range(24)``."

#: ../../library/datetime.rst:1219 ../../library/datetime.rst:1224
#: ../../library/datetime.rst:1842 ../../library/datetime.rst:1847
msgid "In ``range(60)``."
msgstr "No intervalo ``range(60)``."

#: ../../library/datetime.rst:1229 ../../library/datetime.rst:1852
msgid "In ``range(1000000)``."
msgstr "No intervalo ``range(1000000)``."

#: ../../library/datetime.rst:1234
msgid ""
"The object passed as the *tzinfo* argument to the :class:`.datetime` "
"constructor, or ``None`` if none was passed."
msgstr ""
"O objeto passado como o argumento *tzinfo* do construtor :class:`.datetime`, "
"ou ``None`` se nada foi passado."

#: ../../library/datetime.rst:1240 ../../library/datetime.rst:1863
msgid ""
"In ``[0, 1]``. Used to disambiguate wall times during a repeated interval. "
"(A repeated interval occurs when clocks are rolled back at the end of "
"daylight saving time or when the UTC offset for the current zone is "
"decreased for political reasons.) The values 0 and 1 represent, "
"respectively, the earlier and later of the two moments with the same wall "
"time representation."
msgstr ""
"Entre ``[0, 1]``. Usado para desambiguar tempos reais durante um intervalo "
"repetido. (Um intervalo repetido ocorre quando relógios são atrasados ao "
"final do horário de verão ou quando a diferença UTC para o fuso horário "
"atual é reduzida por razões políticas.) Os valores 0 e 1 representam, "
"respectivamente, o primeiro e o segundo dos dois momentos com a mesma "
"representação de tempo real."

#: ../../library/datetime.rst:1253
msgid "``datetime2 = datetime1 + timedelta``"
msgstr "``datetime2 = datetime1 + timedelta``"

#: ../../library/datetime.rst:1253 ../../library/datetime.rst:2490
#: ../../library/datetime.rst:2495 ../../library/datetime.rst:2507
#: ../../library/datetime.rst:2512 ../../library/datetime.rst:2572
#: ../../library/datetime.rst:2577 ../../library/datetime.rst:2581
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/datetime.rst:1255
msgid "``datetime2 = datetime1 - timedelta``"
msgstr "``datetime2 = datetime1 - timedelta``"

#: ../../library/datetime.rst:1255 ../../library/datetime.rst:2523
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/datetime.rst:1257
msgid "``timedelta = datetime1 - datetime2``"
msgstr "``timedelta = datetime1 - datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 == datetime2``"
msgstr "``datetime1 == datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 != datetime2``"
msgstr "``datetime1 != datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 < datetime2``"
msgstr "``datetime1 < datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 > datetime2``"
msgstr "``datetime1 > datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 <= datetime2``"
msgstr "``datetime1 <= datetime2``"

#: ../../library/datetime.rst:0
msgid "``datetime1 >= datetime2``"
msgstr "``datetime1 >= datetime2``"

#: ../../library/datetime.rst:1269
msgid ""
"``datetime2`` is a duration of ``timedelta`` removed from ``datetime1``, "
"moving forward in time if ``timedelta.days > 0``, or backward if ``timedelta."
"days < 0``. The result has the same :attr:`~.datetime.tzinfo` attribute as "
"the input datetime, and ``datetime2 - datetime1 == timedelta`` after. :exc:"
"`OverflowError` is raised if ``datetime2.year`` would be smaller than :const:"
"`MINYEAR` or larger than :const:`MAXYEAR`. Note that no time zone "
"adjustments are done even if the input is an aware object."
msgstr ""
"``datetime2`` representa a duração de ``timedelta`` removido de "
"``datetime1``, movendo o tempo para frente se ``timedelta.days > 0``, ou "
"para trás se ``timedelta.days < 0``. O resultado tem o mesmo atributo :attr:"
"`~.datetime.tzinfo` que o datetime de entrada, e ``datetime2 - datetime1 == "
"timedelta`` após. :exc:`OverflowError` é levantada se ``datetime2.year`` "
"fosse menor que :const:`MINYEAR` ou maior que :const:`MAXYEAR`. Perceba que "
"nenhum ajuste no fuso horário é feito mesmo se a entrada é um objeto "
"consciente disso."

#: ../../library/datetime.rst:1278
msgid ""
"Computes the ``datetime2`` such that ``datetime2 + timedelta == datetime1``. "
"As for addition, the result has the same :attr:`~.datetime.tzinfo` attribute "
"as the input datetime, and no time zone adjustments are done even if the "
"input is aware."
msgstr ""
"Computa o ``datetime2`` tal que ``datetime2 + timedelta == datetime1``. "
"Assim como para adição, o resultado tem o mesmo atributo :attr:`~.datetime."
"tzinfo` que datetime de entrada, e nenhum ajuste de fuso horário é feito "
"mesmo que a entrada seja consciente disso."

#: ../../library/datetime.rst:1283
msgid ""
"Subtraction of a :class:`.datetime` from a :class:`.datetime` is defined "
"only if both operands are naive, or if both are aware. If one is aware and "
"the other is naive, :exc:`TypeError` is raised."
msgstr ""
"Subtração de um :class:`.datetime` de outro :class:`.datetime` é definido "
"apenas se ambos os operandos são ingênuos, ou se ambos são conscientes. Se "
"um deles é consciente e o outro é ingênuo, :exc:`TypeError` é levantado."

#: ../../library/datetime.rst:1287
msgid ""
"If both are naive, or both are aware and have the same :attr:`~.datetime."
"tzinfo` attribute, the :attr:`~.datetime.tzinfo` attributes are ignored, and "
"the result is a :class:`timedelta` object ``t`` such that ``datetime2 + t == "
"datetime1``. No time zone adjustments are done in this case."
msgstr ""
"Se ambos são ingênuos, ou ambos são conscientes e tiverem o mesmo atributo :"
"attr:`~.datetime.tzinfo`, os atributos :attr:`~.datetime.tzinfo` são "
"ignorados, e o resultado é um objeto ``t`` do tipo :class:`timedelta`, tal "
"que ``datetime2 + t == datetime1``. Nenhum ajuste de fuso horário é feito "
"neste caso."

#: ../../library/datetime.rst:1292
msgid ""
"If both are aware and have different :attr:`~.datetime.tzinfo` attributes, "
"``a-b`` acts as if ``a`` and ``b`` were first converted to naive UTC "
"datetimes. The result is ``(a.replace(tzinfo=None) - a.utcoffset()) - (b."
"replace(tzinfo=None) - b.utcoffset())`` except that the implementation never "
"overflows."
msgstr ""
"Se ambas são conscientes e têm atributos :attr:`~.datetime.tzinfo` "
"diferentes, ``a-b`` age como se ``a`` e ``b`` tivessem sido primeiro "
"convertidos para datetimes ingênuas em UTC. O resultado é ``(a."
"replace(tzinfo=None) - a.utcoffset()) - (b.replace(tzinfo=None) - b."
"utcoffset())`` exceto que a implementação nunca estoura."

#: ../../library/datetime.rst:1298
msgid ""
":class:`.datetime` objects are equal if they represent the same date and "
"time, taking into account the time zone."
msgstr ""
"Objetos :class:`.datetime` são iguais se representarem a mesma data e hora, "
"levando em consideração o fuso horário."

#: ../../library/datetime.rst:1301
msgid "Naive and aware :class:`!datetime` objects are never equal."
msgstr "Objetos :class:`!datetime` ingênuos e conscientes nunca são iguais."

#: ../../library/datetime.rst:1303
msgid ""
"If both comparands are aware, and have the same :attr:`!tzinfo` attribute, "
"the :attr:`!tzinfo` and :attr:`~.datetime.fold` attributes are ignored and "
"the base datetimes are compared. If both comparands are aware and have "
"different :attr:`~.datetime.tzinfo` attributes, the comparison acts as "
"comparands were first converted to UTC datetimes except that the "
"implementation never overflows. :class:`!datetime` instances in a repeated "
"interval are never equal to :class:`!datetime` instances in other time zone."
msgstr ""
"Se ambos os comparandos forem conscientes e tiverem o mesmo atributo :attr:`!"
"tzinfo`, os atributos :attr:`!tzinfo` e :attr:`~.datetime.fold` serão "
"ignorados e os datetimes base serão comparados. Se ambos os comparandos "
"forem conscientes e tiverem atributos :attr:`~.datetime.tzinfo` diferentes, "
"a comparação atua como se os comparandos fossem primeiro convertidos para "
"datetimes UTC, exceto que a implementação nunca estoura. Instâncias :class:`!"
"datetime` em um intervalo repetido nunca são iguais a instâncias :class:`!"
"datetime` em outro fuso horário."

#: ../../library/datetime.rst:1313
msgid ""
"*datetime1* is considered less than *datetime2* when *datetime1* precedes "
"*datetime2* in time, taking into account the time zone."
msgstr ""
"*datetime1* é considerado menor que *datetime2* quando *datetime1* precede "
"*datetime2* no tempo. levando em consideração o fuso horário."

#: ../../library/datetime.rst:1316
msgid ""
"Order comparison between naive and aware :class:`.datetime` objects raises :"
"exc:`TypeError`."
msgstr ""
"A comparação de ordens entre objetos :class:`.datetime` ingênuos e "
"conscientes levanta :exc:`TypeError`."

#: ../../library/datetime.rst:1319
msgid ""
"If both comparands are aware, and have the same :attr:`!tzinfo` attribute, "
"the :attr:`!tzinfo` and :attr:`~.datetime.fold` attributes are ignored and "
"the base datetimes are compared. If both comparands are aware and have "
"different :attr:`~.datetime.tzinfo` attributes, the comparison acts as "
"comparands were first converted to UTC datetimes except that the "
"implementation never overflows."
msgstr ""
"Se ambos os comparandos forem conscientes e tiverem o mesmo atributo :attr:`!"
"tzinfo`, os atributos :attr:`!tzinfo` e :attr:`~.datetime.fold` serão "
"ignorados e os datetimes base serão comparados. Se ambos os comparandos "
"forem conscientes e tiverem atributos :attr:`~.datetime.tzinfo` diferentes, "
"a comparação atua como se os comparandos fossem primeiro convertidos para "
"datetimes UTC, exceto que a implementação nunca estoura."

#: ../../library/datetime.rst:1326
msgid ""
"Equality comparisons between aware and naive :class:`.datetime` instances "
"don't raise :exc:`TypeError`."
msgstr ""
"Comparações de igualdade entre instâncias de :class:`.datetime` conscientes "
"e nativas não levantam :exc:`TypeError`."

#: ../../library/datetime.rst:1342
msgid "Return :class:`date` object with same year, month and day."
msgstr "Retorna um objeto :class:`date` com o mesmo ano, mês e dia."

#: ../../library/datetime.rst:1347
msgid ""
"Return :class:`.time` object with same hour, minute, second, microsecond and "
"fold. :attr:`.tzinfo` is ``None``. See also method :meth:`timetz`."
msgstr ""
"Retorna um objeto :class:`.time` com a mesma hora, minuto, segundo, "
"microssegundo e fold. O atributo :attr:`.tzinfo` é ``None``. Veja também o "
"método :meth:`.timetz`."

#: ../../library/datetime.rst:1350 ../../library/datetime.rst:1359
msgid "The fold value is copied to the returned :class:`.time` object."
msgstr "O valor fold é copiado para o objeto :class:`.time` retornado."

#: ../../library/datetime.rst:1356
msgid ""
"Return :class:`.time` object with same hour, minute, second, microsecond, "
"fold, and tzinfo attributes. See also method :meth:`time`."
msgstr ""
"Retorna um objeto :class:`.time` com os mesmos atributos de hora, minuto, "
"segundo, microssegundo, fold e tzinfo. Veja também o método :meth:`time`."

#: ../../library/datetime.rst:1367
msgid ""
"Return a new :class:`datetime` object with the same attributes, but with "
"specified parameters updated. Note that ``tzinfo=None`` can be specified to "
"create a naive datetime from an aware datetime with no conversion of date "
"and time data."
msgstr ""
"Retorna um novo objeto :class:`datetime` com os mesmos atributos, mas com os "
"parâmetros especificados atualizados. Perceba que ``tzinfo=None`` pode ser "
"especificado para criar um datetime ingênuo a partir de um datetime "
"consciente, sem conversão de dados da data ou hora."

#: ../../library/datetime.rst:1372
msgid ""
":class:`.datetime` objects are also supported by generic function :func:"
"`copy.replace`."
msgstr ""
"Objetos :class:`.datetime` também são suportados pela função genérica :func:"
"`copy.replace`."

#: ../../library/datetime.rst:1381
msgid ""
"Return a :class:`.datetime` object with new :attr:`.tzinfo` attribute *tz*, "
"adjusting the date and time data so the result is the same UTC time as "
"*self*, but in *tz*'s local time."
msgstr ""
"Retorna um objeto :class:`.datetime` com novo atributo :attr:`.tzinfo` "
"definido por *tz*, ajustando a data e hora de forma que o resultado seja o "
"mesmo horário UTC que *self*, mas na hora local de *tz*."

#: ../../library/datetime.rst:1385
msgid ""
"If provided, *tz* must be an instance of a :class:`tzinfo` subclass, and "
"its :meth:`utcoffset` and :meth:`dst` methods must not return ``None``. If "
"*self* is naive, it is presumed to represent time in the system time zone."
msgstr ""
"Se fornecido, *tz* deve ser uma instância de uma subclasse :class:`tzinfo`, "
"e seus métodos :meth:`utcoffset` e :meth:`dst` não devem retornar ``None``. "
"Se *self* for ingênuo, é presumido que ele representa o tempo no fuso "
"horário do sistema."

#: ../../library/datetime.rst:1389
msgid ""
"If called without arguments (or with ``tz=None``) the system local time zone "
"is assumed for the target time zone. The ``.tzinfo`` attribute of the "
"converted datetime instance will be set to an instance of :class:`timezone` "
"with the zone name and offset obtained from the OS."
msgstr ""
"Se for chamado sem argumentos (ou com ``tz=None``) o fuso horário do sistema "
"local é presumido como o fuso horário desejado. O atributo ``.tzinfo`` da "
"instância datetime convertida será definido para uma instância de :class:"
"`timezone` com o nome da zona e um deslocamento obtido a partir do sistema "
"operacional."

#: ../../library/datetime.rst:1394
msgid ""
"If ``self.tzinfo`` is *tz*, ``self.astimezone(tz)`` is equal to *self*:  no "
"adjustment of date or time data is performed. Else the result is local time "
"in the time zone *tz*, representing the same UTC time as *self*:  after "
"``astz = dt.astimezone(tz)``, ``astz - astz.utcoffset()`` will have the same "
"date and time data as ``dt - dt.utcoffset()``."
msgstr ""
"Se ``self.tzinfo`` for *tz*, ``self.astimezone(tz)`` é igual a *self*: "
"nenhum ajuste nos dados de data ou hora é realizado. Caso contrário o "
"resultado é a hora local no fuso horário *tz*, representando a mesma hora "
"UTC que *self*: depois ``astz = dt.astimezone(tz)``, ``astz - astz."
"utcoffset()`` terá os mesmos dados de data e hora que ``dt - dt."
"utcoffset()``."

#: ../../library/datetime.rst:1400
msgid ""
"If you merely want to attach a :class:`timezone` object *tz* to a datetime "
"*dt* without adjustment of date and time data, use ``dt."
"replace(tzinfo=tz)``. If you merely want to remove the :class:`!timezone` "
"object from an aware datetime *dt* without conversion of date and time data, "
"use ``dt.replace(tzinfo=None)``."
msgstr ""
"Se você quer meramente anexar um objeto :class:`timezone` *tz* a um datetime "
"*dt* sem ajustes de dados de data e hora, use ``dt.replace(tzinfo=tz)``. Se "
"você meramente quer remover o objeto :class:`!timezone` de um datetime "
"consciente *dt* sem conversão de dados de data e hora, use ``dt."
"replace(tzinfo=None)``."

#: ../../library/datetime.rst:1405
msgid ""
"Note that the default :meth:`tzinfo.fromutc` method can be overridden in a :"
"class:`tzinfo` subclass to affect the result returned by :meth:`astimezone`. "
"Ignoring error cases, :meth:`astimezone` acts like::"
msgstr ""
"Perceba que o método padrão :meth:`tzinfo.fromutc` pode ser substituído em "
"uma subclasse :class:`tzinfo` para afetar o resultado retornado por :meth:"
"`astimezone`. Ignorando erros de letras maiúsculas/minúsculas, :meth:"
"`astimezone` funciona como::"

#: ../../library/datetime.rst:1409
msgid ""
"def astimezone(self, tz):\n"
"    if self.tzinfo is tz:\n"
"        return self\n"
"    # Convert self to UTC, and attach the new timezone object.\n"
"    utc = (self - self.utcoffset()).replace(tzinfo=tz)\n"
"    # Convert from UTC to tz's local time.\n"
"    return tz.fromutc(utc)"
msgstr ""
"def astimezone(self, tz):\n"
"    if self.tzinfo is tz:\n"
"        return self\n"
"    # Converte self para UTC e anexa o novo objeto timezone.\n"
"    utc = (self - self.utcoffset()).replace(tzinfo=tz)\n"
"    # Converte o horário local de UTC para tz.\n"
"    return tz.fromutc(utc)"

#: ../../library/datetime.rst:1417
msgid "*tz* now can be omitted."
msgstr "*tz* agora pode ser omitido."

#: ../../library/datetime.rst:1420
msgid ""
"The :meth:`astimezone` method can now be called on naive instances that are "
"presumed to represent system local time."
msgstr ""
"O método :meth:`astimezone` agora pode ser chamado em instâncias ingênuas "
"que presumidamente representam a hora local do sistema."

#: ../../library/datetime.rst:1427
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"utcoffset(self)``, and raises an exception if the latter doesn't return "
"``None`` or a :class:`timedelta` object with magnitude less than one day."
msgstr ""
"Se :attr:`.tzinfo` for ``None``, retorna ``None``, caso contrário retorna "
"``self.tzinfo.utcoffset(self)``, e levanta uma exceção se o segundo não "
"retornar ``None`` ou um objeto :class:`timedelta` com magnitude menor que um "
"dia."

#: ../../library/datetime.rst:1431 ../../library/datetime.rst:2042
#: ../../library/datetime.rst:2149 ../../library/datetime.rst:2394
#: ../../library/datetime.rst:2406 ../../library/datetime.rst:2716
msgid "The UTC offset is not restricted to a whole number of minutes."
msgstr "A diferença UTC não é restrita a um número completo de minutos."

#: ../../library/datetime.rst:1437
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"dst(self)``, and raises an exception if the latter doesn't return ``None`` "
"or a :class:`timedelta` object with magnitude less than one day."
msgstr ""
"Se :attr:`.tzinfo` for ``None``, retorna ``None``, caso contrário retorna "
"``self.tzinfo.dst(self)``, e levanta uma exceção se o segundo não retornar "
"``None`` ou um objeto :class:`timedelta` com magnitude menor que um dia."

#: ../../library/datetime.rst:1441 ../../library/datetime.rst:2052
#: ../../library/datetime.rst:2203
msgid "The DST offset is not restricted to a whole number of minutes."
msgstr ""
"A diferença de horário de verão não é restrita a um número completo de "
"minutos."

#: ../../library/datetime.rst:1447
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"tzname(self)``, raises an exception if the latter doesn't return ``None`` or "
"a string object,"
msgstr ""
"Se :attr:`.tzinfo` for ``None``, retorna ``None``, caso contrário retorna "
"``self.tzinfo.tzname(self)``, levanta uma exceção se o segundo não retornar "
"``None`` ou um objeto string."

#: ../../library/datetime.rst:1458
msgid ""
"time.struct_time((d.year, d.month, d.day,\n"
"                  d.hour, d.minute, d.second,\n"
"                  d.weekday(), yday, dst))"
msgstr ""
"time.struct_time((d.year, d.month, d.day,\n"
"                  d.hour, d.minute, d.second,\n"
"                  d.weekday(), yday, dst))"

#: ../../library/datetime.rst:1462
msgid ""
"where ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` is the "
"day number within the current year starting with 1 for January 1st. The :"
"attr:`~time.struct_time.tm_isdst` flag of the result is set according to "
"the :meth:`dst` method: :attr:`.tzinfo` is ``None`` or :meth:`dst` returns "
"``None``, :attr:`!tm_isdst` is set to ``-1``; else if :meth:`dst` returns a "
"non-zero value, :attr:`!tm_isdst` is set to 1; else :attr:`!tm_isdst` is set "
"to 0."
msgstr ""
"onde ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` é o "
"número de dias dentro do ano atual, começando com 1 para 1º de janeiro. O "
"sinalizador :attr:`~time.struct_time.tm_isdst` do resultado é definido "
"conforme o método :meth:`dst`: :attr:`.tzinfo` é ``None`` ou :meth:`dst` "
"retorna ``None``, :attr:`!tm_isdst` é definido para ``-1``; caso contrário "
"se :meth:`dst` retornar um valor diferente de zero, :attr:`!tm_isdst` é "
"definido para 1; caso contrário :attr:`!tm_isdst` é definido para 0."

#: ../../library/datetime.rst:1473
msgid ""
"If :class:`.datetime` instance ``d`` is naive, this is the same as ``d."
"timetuple()`` except that :attr:`~.time.struct_time.tm_isdst` is forced to 0 "
"regardless of what ``d.dst()`` returns. DST is never in effect for a UTC "
"time."
msgstr ""
"Se a instância :class:`.datetime` ``d`` é ingênua, isto é o mesmo que ``d."
"timetuple()``, exceto que :attr:`~.time.struct_time.tm_isdst` é forçado para "
"0, independentemente do que ``d.dst()`` retornar. O horário de verão nunca é "
"afetado por um horário UTC."

#: ../../library/datetime.rst:1477
msgid ""
"If ``d`` is aware, ``d`` is normalized to UTC time, by subtracting ``d."
"utcoffset()``, and a :class:`time.struct_time` for the normalized time is "
"returned. :attr:`!tm_isdst` is forced to 0. Note that an :exc:"
"`OverflowError` may be raised if ``d.year`` was ``MINYEAR`` or ``MAXYEAR`` "
"and UTC adjustment spills over a year boundary."
msgstr ""
"Se ``d`` é consciente, ``d`` é normalizado para horário UTC, subtraindo ``d."
"utcoffset()``, e um :class:`time.struct_time` para o horário normalizado é "
"retornado. :attr:`!tm_isdst` é forçado para 0. Observe que uma exceção :exc:"
"`OverflowError` pode ser levantada se ``d.year`` for ``MINYEAR`` ou "
"``MAXYEAR`` e os ajustes UTC ultrapassar o limite de um ano."

#: ../../library/datetime.rst:1486
msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` methods "
"as local times, it is preferred to use aware datetimes to represent times in "
"UTC; as a result, using :meth:`datetime.utctimetuple` may give misleading "
"results. If you have a naive ``datetime`` representing UTC, use ``datetime."
"replace(tzinfo=timezone.utc)`` to make it aware, at which point you can use :"
"meth:`.datetime.timetuple`."
msgstr ""
"Por causa que objetos ``datetime`` ingênuos são tratados por muitos métodos "
"``datetime`` como hora local, é preferido usar datetimes conscientes para "
"representar horários em UTC; como resultado, usar :meth:`datetime."
"utctimetuple` pode dar resultados enganosos. Se você tem um ``datetime`` "
"ingênuo representando UTC, use ``datetime.replace(tzinfo=timezone.utc)`` "
"para torná-lo consciente, ponto no qual você pode usar :meth:`.datetime."
"timetuple`."

#: ../../library/datetime.rst:1495
msgid ""
"Return the proleptic Gregorian ordinal of the date. The same as ``self."
"date().toordinal()``."
msgstr ""
"Retorna o ordinal proléptico gregoriano da data. o mesmo que ``self.date()."
"toordinal()``."

#: ../../library/datetime.rst:1500
msgid ""
"Return POSIX timestamp corresponding to the :class:`.datetime` instance. The "
"return value is a :class:`float` similar to that returned by :func:`time."
"time`."
msgstr ""
"Retorna o registro de data e hora POSIX correspondente a instância :class:`."
"datetime`. O valor de retorno é um :class:`float` similar aquele retornado "
"por :func:`time.time`."

#: ../../library/datetime.rst:1504
msgid ""
"Naive :class:`.datetime` instances are assumed to represent local time and "
"this method relies on the platform C :c:func:`mktime` function to perform "
"the conversion. Since :class:`.datetime` supports wider range of values "
"than :c:func:`mktime` on many platforms, this method may raise :exc:"
"`OverflowError` or :exc:`OSError` for times far in the past or far in the "
"future."
msgstr ""
"Presume-se que instâncias :class:`.datetime` ingênuas representam a hora "
"local e este método depende da função C :c:func:`mktime` da plataforma para "
"realizar a conversão. Como :class:`.datetime` suporta um intervalo maior de "
"valores que :c:func:`mktime` em muitas plataformas, este método pode "
"levantar :exc:`OverflowError` ou :exc:`OSError` para horários longe no "
"passado ou longe no futuro."

#: ../../library/datetime.rst:1511
msgid ""
"For aware :class:`.datetime` instances, the return value is computed as::"
msgstr ""
"Para instâncias conscientes de :class:`.datetime`, o valor retornado é "
"computado como::"

#: ../../library/datetime.rst:1514
msgid "(dt - datetime(1970, 1, 1, tzinfo=timezone.utc)).total_seconds()"
msgstr "(dt - datetime(1970, 1, 1, tzinfo=timezone.utc)).total_seconds()"

#: ../../library/datetime.rst:1518
msgid ""
"The :meth:`timestamp` method uses the :attr:`.fold` attribute to "
"disambiguate the times during a repeated interval."
msgstr ""
"O método :meth:`timestamp` usa o atributo :attr:`.fold` para desambiguar os "
"tempos durante um intervalo repetido."

#: ../../library/datetime.rst:1524
msgid ""
"There is no method to obtain the POSIX timestamp directly from a naive :"
"class:`.datetime` instance representing UTC time. If your application uses "
"this convention and your system time zone is not set to UTC, you can obtain "
"the POSIX timestamp by supplying ``tzinfo=timezone.utc``::"
msgstr ""
"Não existe método para obter o timestamp POSIX diretamente de uma instância :"
"class:`.datetime` ingênua representando tempo em UTC. Se a sua aplicação usa "
"esta convenção e o fuso horário do seu sistema não está setado para UTC, "
"você pode obter o registro de data e hora POSIX fornecendo ``tzinfo=timezone."
"utc``::"

#: ../../library/datetime.rst:1530
msgid "timestamp = dt.replace(tzinfo=timezone.utc).timestamp()"
msgstr "timestamp = dt.replace(tzinfo=timezone.utc).timestamp()"

#: ../../library/datetime.rst:1532
msgid "or by calculating the timestamp directly::"
msgstr "ou calculando o registro de data e hora diretamente::"

#: ../../library/datetime.rst:1534
msgid "timestamp = (dt - datetime(1970, 1, 1)) / timedelta(seconds=1)"
msgstr "timestamp = (dt - datetime(1970, 1, 1)) / timedelta(seconds=1)"

#: ../../library/datetime.rst:1538
msgid ""
"Return the day of the week as an integer, where Monday is 0 and Sunday is 6. "
"The same as ``self.date().weekday()``. See also :meth:`isoweekday`."
msgstr ""
"Retorna o dia da semana como um inteiro, em que segunda-feira é 0 e domingo "
"é 6. O mesmo que ``self.date().weekday()``. Veja também :meth:`isoweekday`."

#: ../../library/datetime.rst:1544
msgid ""
"Return the day of the week as an integer, where Monday is 1 and Sunday is 7. "
"The same as ``self.date().isoweekday()``. See also :meth:`weekday`, :meth:"
"`isocalendar`."
msgstr ""
"Retorna o dia da semana como um inteiro, em que segunda-feira é 1 e domingo "
"é 7. O mesmo que ``self.date().isoweekday()``. Veja também :meth:`weekday`, :"
"meth:`isocalendar`."

#: ../../library/datetime.rst:1551
msgid ""
"Return a :term:`named tuple` with three components: ``year``, ``week`` and "
"``weekday``. The same as ``self.date().isocalendar()``."
msgstr ""
"Retorna uma :term:`tupla nomeada <named tuple>` com três componentes: "
"``year``, ``week`` e ``weekday``. O mesmo que  ``self.date().isocalendar()``."

#: ../../library/datetime.rst:1557
msgid "Return a string representing the date and time in ISO 8601 format:"
msgstr "Retorna uma string representando a data e o tempo no formato ISO 8601:"

#: ../../library/datetime.rst:1559
msgid "``YYYY-MM-DDTHH:MM:SS.ffffff``, if :attr:`microsecond` is not 0"
msgstr "``YYYY-MM-DDTHH:MM:SS.ffffff``, se :attr:`microsecond` não é 0"

#: ../../library/datetime.rst:1560
msgid "``YYYY-MM-DDTHH:MM:SS``, if :attr:`microsecond` is 0"
msgstr "``YYYY-MM-DDTHH:MM:SS``, se :attr:`microsecond` é 0"

#: ../../library/datetime.rst:1562
msgid ""
"If :meth:`utcoffset` does not return ``None``, a string is appended, giving "
"the UTC offset:"
msgstr ""
"Se :meth:`utcoffset` não retorna ``None``, uma string é adicionada com a "
"diferença UTC:"

#: ../../library/datetime.rst:1565
msgid ""
"``YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, if :attr:`microsecond` "
"is not 0"
msgstr ""
"``YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, se :attr:`microsecond` "
"não é 0"

#: ../../library/datetime.rst:1567
msgid ""
"``YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]]``,  if :attr:`microsecond` is 0"
msgstr ""
"``YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]]``,  se :attr:`microsecond` é 0"

#: ../../library/datetime.rst:1571
msgid ""
">>> from datetime import datetime, timezone\n"
">>> datetime(2019, 5, 18, 15, 17, 8, 132263).isoformat()\n"
"'2019-05-18T15:17:08.132263'\n"
">>> datetime(2019, 5, 18, 15, 17, tzinfo=timezone.utc).isoformat()\n"
"'2019-05-18T15:17:00+00:00'"
msgstr ""
">>> from datetime import datetime, timezone\n"
">>> datetime(2019, 5, 18, 15, 17, 8, 132263).isoformat()\n"
"'2019-05-18T15:17:08.132263'\n"
">>> datetime(2019, 5, 18, 15, 17, tzinfo=timezone.utc).isoformat()\n"
"'2019-05-18T15:17:00+00:00'"

#: ../../library/datetime.rst:1577
msgid ""
"The optional argument *sep* (default ``'T'``) is a one-character separator, "
"placed between the date and time portions of the result. For example::"
msgstr ""
"O argumento opcional *sep* (por padrão, ``'T'``) é um separador de caractere "
"único, colocado entre as porções de data e tempo do resultado. Por exemplo::"

#: ../../library/datetime.rst:1580
msgid ""
">>> from datetime import tzinfo, timedelta, datetime\n"
">>> class TZ(tzinfo):\n"
"...     \"\"\"A time zone with an arbitrary, constant -06:39 offset.\"\"\"\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=-6, minutes=-39)\n"
"...\n"
">>> datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')\n"
"'2002-12-25 00:00:00-06:39'\n"
">>> datetime(2009, 11, 27, microsecond=100, tzinfo=TZ()).isoformat()\n"
"'2009-11-27T00:00:00.000100-06:39'"
msgstr ""
">>> from datetime import tzinfo, timedelta, datetime\n"
">>> class TZ(tzinfo):\n"
"...     \"\"\"Um fuso horário com uma posição arbitrária constante de -06:39."
"\"\"\"\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=-6, minutes=-39)\n"
"...\n"
">>> datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')\n"
"'2002-12-25 00:00:00-06:39'\n"
">>> datetime(2009, 11, 27, microsecond=100, tzinfo=TZ()).isoformat()\n"
"'2009-11-27T00:00:00.000100-06:39'"

#: ../../library/datetime.rst:1591 ../../library/datetime.rst:1982
msgid ""
"The optional argument *timespec* specifies the number of additional "
"components of the time to include (the default is ``'auto'``). It can be one "
"of the following:"
msgstr ""
"O argumento opcional *timespec* especifica o número de componentes "
"adicionais do tempo a incluir (o padrão é ``'auto'``). Pode ser uma das "
"seguintes strings:"

#: ../../library/datetime.rst:1595 ../../library/datetime.rst:1986
msgid ""
"``'auto'``: Same as ``'seconds'`` if :attr:`microsecond` is 0, same as "
"``'microseconds'`` otherwise."
msgstr ""
"``'auto'``: O mesmo que ``'seconds'`` se :attr:`microsecond` é 0, o mesmo "
"que ``'microseconds'`` caso contrário."

#: ../../library/datetime.rst:1597 ../../library/datetime.rst:1988
msgid "``'hours'``: Include the :attr:`hour` in the two-digit ``HH`` format."
msgstr ""
"``'hours'``: Inclui o atributo :attr:`hour` no formato de dois dígitos "
"``HH``."

#: ../../library/datetime.rst:1598 ../../library/datetime.rst:1989
msgid ""
"``'minutes'``: Include :attr:`hour` and :attr:`minute` in ``HH:MM`` format."
msgstr ""
"``'minutes'``: Inclui os atributos :attr:`hour` e :attr:`minute` no formato "
"``HH:MM``."

#: ../../library/datetime.rst:1599 ../../library/datetime.rst:1990
msgid ""
"``'seconds'``: Include :attr:`hour`, :attr:`minute`, and :attr:`second` in "
"``HH:MM:SS`` format."
msgstr ""
"``'seconds'``: Inclui os atributos  :attr:`hour`, :attr:`minute` e :attr:"
"`second` no formato ``HH:MM:SS``."

#: ../../library/datetime.rst:1601 ../../library/datetime.rst:1992
msgid ""
"``'milliseconds'``: Include full time, but truncate fractional second part "
"to milliseconds. ``HH:MM:SS.sss`` format."
msgstr ""
"``'milliseconds'``: Inclui o tempo completo, mas trunca a parte fracional "
"dos segundos em milissegundos. Formato ``HH:MM:SS.sss``."

#: ../../library/datetime.rst:1603 ../../library/datetime.rst:1994
msgid "``'microseconds'``: Include full time in ``HH:MM:SS.ffffff`` format."
msgstr ""
"``'microseconds'``: Inclui o tempo completo no formato ``HH:MM:SS.ffffff``."

#: ../../library/datetime.rst:1607 ../../library/datetime.rst:1998
msgid "Excluded time components are truncated, not rounded."
msgstr "Componentes do tempo excluídos são truncados, não arredondados."

#: ../../library/datetime.rst:1609
msgid ":exc:`ValueError` will be raised on an invalid *timespec* argument::"
msgstr ""
"A exceção :exc:`ValueError` vai ser levantada no caso de um argumento "
"*timespec* inválido::"

#: ../../library/datetime.rst:1612
msgid ""
">>> from datetime import datetime\n"
">>> datetime.now().isoformat(timespec='minutes')\n"
"'2002-12-25T00:00'\n"
">>> dt = datetime(2015, 1, 1, 12, 30, 59, 0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'2015-01-01T12:30:59.000000'"
msgstr ""
">>> from datetime import datetime\n"
">>> datetime.now().isoformat(timespec='minutes')\n"
"'2002-12-25T00:00'\n"
">>> dt = datetime(2015, 1, 1, 12, 30, 59, 0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'2015-01-01T12:30:59.000000'"

#: ../../library/datetime.rst:1619 ../../library/datetime.rst:2013
msgid "Added the *timespec* parameter."
msgstr "Adicionado o  parâmetro *timespec*."

#: ../../library/datetime.rst:1625
msgid ""
"For a :class:`.datetime` instance ``d``, ``str(d)`` is equivalent to ``d."
"isoformat(' ')``."
msgstr ""
"Para uma instância :class:`.datetime` ``d``, ``str(d)`` é equivalente a ``d."
"isoformat(' ')``."

#: ../../library/datetime.rst:1631
msgid "Return a string representing the date and time::"
msgstr "Retorna uma string representando a data e hora::"

#: ../../library/datetime.rst:1633
msgid ""
">>> from datetime import datetime\n"
">>> datetime(2002, 12, 4, 20, 30, 40).ctime()\n"
"'Wed Dec  4 20:30:40 2002'"
msgstr ""
">>> from datetime import datetime\n"
">>> datetime(2002, 12, 4, 20, 30, 40).ctime()\n"
"'Wed Dec  4 20:30:40 2002'"

#: ../../library/datetime.rst:1637
msgid ""
"The output string will *not* include time zone information, regardless of "
"whether the input is aware or naive."
msgstr ""
"A string de saída *não* irá incluir informações de fuso horário, "
"independente de a entrada ser consciente ou ingênua."

#: ../../library/datetime.rst:1644
msgid ""
"on platforms where the native C :c:func:`ctime` function (which :func:`time."
"ctime` invokes, but which :meth:`datetime.ctime` does not invoke) conforms "
"to the C standard."
msgstr ""
"em plataformas onde a função nativa em C :c:func:`ctime` (a qual :func:`time."
"ctime` invoca, mas a qual :meth:`datetime.ctime` não invoca) conforma com o "
"padrão C."

#: ../../library/datetime.rst:1651
msgid ""
"Return a string representing the date and time, controlled by an explicit "
"format string. See also :ref:`strftime-strptime-behavior` and :meth:"
"`datetime.isoformat`."
msgstr ""
"Retorna uma string representando a data e hora, controladas por uma string "
"com formato explícito. Veja também :ref:`strftime-strptime-behavior` e :meth:"
"`datetime.isoformat`."

#: ../../library/datetime.rst:1658
msgid ""
"Same as :meth:`.datetime.strftime`. This makes it possible to specify a "
"format string for a :class:`.datetime` object in :ref:`formatted string "
"literals <f-strings>` and when using :meth:`str.format`. See also :ref:"
"`strftime-strptime-behavior` and :meth:`datetime.isoformat`."
msgstr ""
"O mesmo que :meth:`.datetime.strftime`. Isso torna possível especificar uma "
"string de formatação para o objeto :class:`.datetime` em :ref:`literais de "
"string formatados <f-strings>` e ao usar :meth:`str.format`. Veja também :"
"ref:`strftime-strptime-behavior` e :meth:`datetime.isoformat`."

#: ../../library/datetime.rst:1665
msgid "Examples of Usage: :class:`.datetime`"
msgstr "Exemplos de uso: :class:`.datetime`"

#: ../../library/datetime.rst:1667
msgid "Examples of working with :class:`.datetime` objects:"
msgstr "Exemplos para trabalhar com objetos :class:`.datetime`:"

#: ../../library/datetime.rst:1669
msgid ""
">>> from datetime import datetime, date, time, timezone\n"
"\n"
">>> # Using datetime.combine()\n"
">>> d = date(2005, 7, 14)\n"
">>> t = time(12, 30)\n"
">>> datetime.combine(d, t)\n"
"datetime.datetime(2005, 7, 14, 12, 30)\n"
"\n"
">>> # Using datetime.now()\n"
">>> datetime.now()\n"
"datetime.datetime(2007, 12, 6, 16, 29, 43, 79043)   # GMT +1\n"
">>> datetime.now(timezone.utc)\n"
"datetime.datetime(2007, 12, 6, 15, 29, 43, 79060, tzinfo=datetime.timezone."
"utc)\n"
"\n"
">>> # Using datetime.strptime()\n"
">>> dt = datetime.strptime(\"21/11/06 16:30\", \"%d/%m/%y %H:%M\")\n"
">>> dt\n"
"datetime.datetime(2006, 11, 21, 16, 30)\n"
"\n"
">>> # Using datetime.timetuple() to get tuple of all attributes\n"
">>> tt = dt.timetuple()\n"
">>> for it in tt:\n"
"...     print(it)\n"
"...\n"
"2006    # year\n"
"11      # month\n"
"21      # day\n"
"16      # hour\n"
"30      # minute\n"
"0       # second\n"
"1       # weekday (0 = Monday)\n"
"325     # number of days since 1st January\n"
"-1      # dst - method tzinfo.dst() returned None\n"
"\n"
">>> # Date in ISO format\n"
">>> ic = dt.isocalendar()\n"
">>> for it in ic:\n"
"...     print(it)\n"
"...\n"
"2006    # ISO year\n"
"47      # ISO week\n"
"2       # ISO weekday\n"
"\n"
">>> # Formatting a datetime\n"
">>> dt.strftime(\"%A, %d. %B %Y %I:%M%p\")\n"
"'Tuesday, 21. November 2006 04:30PM'\n"
">>> 'The {1} is {0:%d}, the {2} is {0:%B}, the {3} is {0:%I:%M%p}.'."
"format(dt, \"day\", \"month\", \"time\")\n"
"'The day is 21, the month is November, the time is 04:30PM.'"
msgstr ""
">>> from datetime import datetime, date, time, timezone\n"
"\n"
">>> # Usando datetime.combine()\n"
">>> d = date(2005, 7, 14)\n"
">>> t = time(12, 30)\n"
">>> datetime.combine(d, t)\n"
"datetime.datetime(2005, 7, 14, 12, 30)\n"
"\n"
">>> # Usando datetime.now()\n"
">>> datetime.now()\n"
"datetime.datetime(2007, 12, 6, 16, 29, 43, 79043)   # GMT +1\n"
">>> datetime.now(timezone.utc)\n"
"datetime.datetime(2007, 12, 6, 15, 29, 43, 79060, tzinfo=datetime.timezone."
"utc)\n"
"\n"
">>> # Usando datetime.strptime()\n"
">>> dt = datetime.strptime(\"21/11/06 16:30\", \"%d/%m/%y %H:%M\")\n"
">>> dt\n"
"datetime.datetime(2006, 11, 21, 16, 30)\n"
"\n"
">>> # Usando datetime.timetuple() para obter uma tupla de todos os "
"atributos\n"
">>> tt = dt.timetuple()\n"
">>> for it in tt:\n"
"...     print(it)\n"
"...\n"
"2006    # ano\n"
"11      # mês\n"
"21      # dia\n"
"16      # hora\n"
"30      # minuto\n"
"0       # segundo\n"
"1       # dia da semana (0 = Segunda-feira)\n"
"325     # número de dias desde 1º de janeiro\n"
"-1      # dst - método tzinfo.dst() retornou None\n"
"\n"
">>> # Data em formato ISO\n"
">>> ic = dt.isocalendar()\n"
">>> for it in ic:\n"
"...     print(it)\n"
"...\n"
"2006    # ano ISO\n"
"47      # semana ISO\n"
"2       # dia da semana ISO\n"
"\n"
">>> # Formatando um datetime\n"
">>> dt.strftime(\"%A, %d. %B %Y %I:%M%p\")\n"
"'Tuesday, 21. November 2006 04:30PM'\n"
">>> 'O {1} é {0:%d}, o {2} é {0:%B}, a {3} é {0:%I:%M%p}.'.format(dt, "
"\"dia\", \"mês\", \"hora\")\n"
"'O dia é 21, o mês é November, a hora é 04:30PM.'"

#: ../../library/datetime.rst:1720
msgid ""
"The example below defines a :class:`tzinfo` subclass capturing time zone "
"information for Kabul, Afghanistan, which used +4 UTC until 1945 and then "
"+4:30 UTC thereafter::"
msgstr ""
"O exemplo abaixo define uma subclasse :class:`tzinfo` capturando informações "
"de fuso horário para Kabul, Afeganistão, o qual usou +4 UTC até 1945 e "
"depois +4:30 UTC após esse período::"

#: ../../library/datetime.rst:1724
msgid ""
"from datetime import timedelta, datetime, tzinfo, timezone\n"
"\n"
"class KabulTz(tzinfo):\n"
"    # Kabul used +4 until 1945, when they moved to +4:30\n"
"    UTC_MOVE_DATE = datetime(1944, 12, 31, 20, tzinfo=timezone.utc)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if dt.year < 1945:\n"
"            return timedelta(hours=4)\n"
"        elif (1945, 1, 1, 0, 0) <= dt.timetuple()[:5] < (1945, 1, 1, 0, "
"30):\n"
"            # An ambiguous (\"imaginary\") half-hour range representing\n"
"            # a 'fold' in time due to the shift from +4 to +4:30.\n"
"            # If dt falls in the imaginary range, use fold to decide how\n"
"            # to resolve. See PEP495.\n"
"            return timedelta(hours=4, minutes=(30 if dt.fold else 0))\n"
"        else:\n"
"            return timedelta(hours=4, minutes=30)\n"
"\n"
"    def fromutc(self, dt):\n"
"        # Follow same validations as in datetime.tzinfo\n"
"        if not isinstance(dt, datetime):\n"
"            raise TypeError(\"fromutc() requires a datetime argument\")\n"
"        if dt.tzinfo is not self:\n"
"            raise ValueError(\"dt.tzinfo is not self\")\n"
"\n"
"        # A custom implementation is required for fromutc as\n"
"        # the input to this function is a datetime with utc values\n"
"        # but with a tzinfo set to self.\n"
"        # See datetime.astimezone or fromtimestamp.\n"
"        if dt.replace(tzinfo=timezone.utc) >= self.UTC_MOVE_DATE:\n"
"            return dt + timedelta(hours=4, minutes=30)\n"
"        else:\n"
"            return dt + timedelta(hours=4)\n"
"\n"
"    def dst(self, dt):\n"
"        # Kabul does not observe daylight saving time.\n"
"        return timedelta(0)\n"
"\n"
"    def tzname(self, dt):\n"
"        if dt >= self.UTC_MOVE_DATE:\n"
"            return \"+04:30\"\n"
"        return \"+04\""
msgstr ""
"from datetime import timedelta, datetime, tzinfo, timezone\n"
"\n"
"class KabulTz(tzinfo):\n"
"    # Kabul usou +4 até 1945, quando eles moveram para +4:30\n"
"    UTC_MOVE_DATE = datetime(1944, 12, 31, 20, tzinfo=timezone.utc)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if dt.year < 1945:\n"
"            return timedelta(hours=4)\n"
"        elif (1945, 1, 1, 0, 0) <= dt.timetuple()[:5] < (1945, 1, 1, 0, "
"30):\n"
"            # Um intervalo de meia hora ambíguo (\"imaginário\") "
"representando\n"
"            # um 'fold' no tempo por causa da troca de +4 para +4:30.\n"
"            # Se dt cair no intervalo imaginário, usa a fold para decidir "
"como\n"
"            # para resolver. Veja PEP495.\n"
"            return timedelta(hours=4, minutes=(30 if dt.fold else 0))\n"
"        else:\n"
"            return timedelta(hours=4, minutes=30)\n"
"\n"
"    def fromutc(self, dt):\n"
"        # Segue as mesmas validações como em datetime.tzinfo\n"
"        if not isinstance(dt, datetime):\n"
"            raise TypeError(\"fromutc() requer um argumento datetime\")\n"
"        if dt.tzinfo is not self:\n"
"            raise ValueError(\"dt.tzinfo não é self\")\n"
"\n"
"        # Uma implementação personalizada é necessária para fromutc\n"
"        # como a entrada para esta função é um datetime com valores utc\n"
"        # mas com um tzinfo definido para self.\n"
"        # Veja datetime.astimezone ou fromtimestamp.\n"
"        if dt.replace(tzinfo=timezone.utc) >= self.UTC_MOVE_DATE:\n"
"            return dt + timedelta(hours=4, minutes=30)\n"
"        else:\n"
"            return dt + timedelta(hours=4)\n"
"\n"
"    def dst(self, dt):\n"
"        # Kabul não tem horário de verão.\n"
"        return timedelta(0)\n"
"\n"
"    def tzname(self, dt):\n"
"        if dt >= self.UTC_MOVE_DATE:\n"
"            return \"+04:30\"\n"
"        return \"+04\""

#: ../../library/datetime.rst:1767
msgid "Usage of ``KabulTz`` from above::"
msgstr "Uso de ``KabulTz`` mostrado acima::"

#: ../../library/datetime.rst:1769
msgid ""
">>> tz1 = KabulTz()\n"
"\n"
">>> # Datetime before the change\n"
">>> dt1 = datetime(1900, 11, 21, 16, 30, tzinfo=tz1)\n"
">>> print(dt1.utcoffset())\n"
"4:00:00\n"
"\n"
">>> # Datetime after the change\n"
">>> dt2 = datetime(2006, 6, 14, 13, 0, tzinfo=tz1)\n"
">>> print(dt2.utcoffset())\n"
"4:30:00\n"
"\n"
">>> # Convert datetime to another time zone\n"
">>> dt3 = dt2.astimezone(timezone.utc)\n"
">>> dt3\n"
"datetime.datetime(2006, 6, 14, 8, 30, tzinfo=datetime.timezone.utc)\n"
">>> dt2\n"
"datetime.datetime(2006, 6, 14, 13, 0, tzinfo=KabulTz())\n"
">>> dt2 == dt3\n"
"True"
msgstr ""
">>> tz1 = KabulTz()\n"
"\n"
">>> # Datetime antes da alteração\n"
">>> dt1 = datetime(1900, 11, 21, 16, 30, tzinfo=tz1)\n"
">>> print(dt1.utcoffset())\n"
"4:00:00\n"
"\n"
">>> # Datetime após a alteração\n"
">>> dt2 = datetime(2006, 6, 14, 13, 0, tzinfo=tz1)\n"
">>> print(dt2.utcoffset())\n"
"4:30:00\n"
"\n"
">>> # Converte datetime para outro fuso horário\n"
">>> dt3 = dt2.astimezone(timezone.utc)\n"
">>> dt3\n"
"datetime.datetime(2006, 6, 14, 8, 30, tzinfo=datetime.timezone.utc)\n"
">>> dt2\n"
"datetime.datetime(2006, 6, 14, 13, 0, tzinfo=KabulTz())\n"
">>> dt2 == dt3\n"
"True"

#: ../../library/datetime.rst:1793
msgid ":class:`.time` Objects"
msgstr "Objetos :class:`.time`"

#: ../../library/datetime.rst:1795
msgid ""
"A :class:`.time` object represents a (local) time of day, independent of any "
"particular day, and subject to adjustment via a :class:`tzinfo` object."
msgstr ""
"Um objeto :class:`.time` representa a hora (local) do dia, independente de "
"qualquer dia em particular, e sujeito a ajustes através de um objeto :class:"
"`tzinfo`."

#: ../../library/datetime.rst:1800
msgid ""
"All arguments are optional. *tzinfo* may be ``None``, or an instance of a :"
"class:`tzinfo` subclass. The remaining arguments must be integers in the "
"following ranges:"
msgstr ""
"Todos os argumentos são opcionais. *tzinfo* pode ser ``None``, ou uma "
"instância de uma subclasse de :class:`tzinfo`. Os argumentos remanescentes "
"devem ser inteiros nos seguintes intervalos:"

#: ../../library/datetime.rst:1810
msgid ""
"If an argument outside those ranges is given, :exc:`ValueError` is raised. "
"All default to 0 except *tzinfo*, which defaults to ``None``."
msgstr ""
"Se um argumento fora desses intervalos é fornecido, :exc:`ValueError` é "
"levantada. Todos tem como padrão o valor 0 exceto *tzinfo*, o qual tem o "
"valor padrão ``None``."

#: ../../library/datetime.rst:1818
msgid "The earliest representable :class:`.time`, ``time(0, 0, 0, 0)``."
msgstr ""
"O :class:`.time` mais cedo que pode ser representado, ``time(0, 0, 0, 0)``."

#: ../../library/datetime.rst:1823
msgid "The latest representable :class:`.time`, ``time(23, 59, 59, 999999)``."
msgstr ""
"O :class:`.time` mais tardio que pode ser representado, ``time(23, 59, 59, "
"999999)``."

#: ../../library/datetime.rst:1828
msgid ""
"The smallest possible difference between non-equal :class:`.time` objects, "
"``timedelta(microseconds=1)``, although note that arithmetic on :class:`."
"time` objects is not supported."
msgstr ""
"A menor diferença possível entre objetos :class:`.time` diferentes, "
"``timedelta(microseconds=1)``, embora perceba que aritmética sobre objetos :"
"class:`.time` não é suportada."

#: ../../library/datetime.rst:1857
msgid ""
"The object passed as the tzinfo argument to the :class:`.time` constructor, "
"or ``None`` if none was passed."
msgstr ""
"O objeto passado como argumento tzinfo para o construtor da classe :class:`."
"time`, ou ``None`` se nada foi passado."

#: ../../library/datetime.rst:1871
msgid ""
":class:`.time` objects support equality and order comparisons, where ``a`` "
"is considered less than ``b`` when ``a`` precedes ``b`` in time."
msgstr ""
"Objetos :class:`.time` oferecem suporte para comparações de igualdade e "
"ordem, onde ``a`` é considerado menor que ``b`` quando ``a`` precede ``b`` "
"no tempo."

#: ../../library/datetime.rst:1874
msgid ""
"Naive and aware :class:`!time` objects are never equal. Order comparison "
"between naive and aware :class:`!time` objects raises :exc:`TypeError`."
msgstr ""
"Objetos :class:`!time` ingênuos e conscientes nunca são iguais. A comparação "
"de ordem entre objetos :class:`!time` ingênuos e conscientes levanta :exc:"
"`TypeError`."

#: ../../library/datetime.rst:1878
msgid ""
"If both comparands are aware, and have the same :attr:`~.time.tzinfo` "
"attribute, the :attr:`!tzinfo` and :attr:`!fold` attributes are ignored and "
"the base times are compared. If both comparands are aware and have "
"different :attr:`!tzinfo` attributes, the comparands are first adjusted by "
"subtracting their UTC offsets (obtained from ``self.utcoffset()``)."
msgstr ""
"Se ambos os comparandos são conscientes, e tem o mesmo atributo :attr:`~."
"time.tzinfo`, os atributos :attr:`!tzinfo` e :attr:`!fold` são ignorados e "
"os tempos base são comparados. Se ambos os comparandos são conscientes e tem "
"atributos :attr:`!tzinfo` diferentes, os comparandos são primeiro ajustados "
"subtraindo sua diferença em UTC (obtida através de ``self.utcoffset()``)."

#: ../../library/datetime.rst:1884
msgid ""
"Equality comparisons between aware and naive :class:`.time` instances don't "
"raise :exc:`TypeError`."
msgstr ""
"Comparações de igualdade entre instâncias de :class:`.time` conscientes e "
"nativas não levantam :exc:`TypeError`."

#: ../../library/datetime.rst:1888
msgid ""
"In Boolean contexts, a :class:`.time` object is always considered to be true."
msgstr ""
"Em contextos Booleanos, um objeto :class:`.time` é sempre considerado como "
"verdadeiro."

#: ../../library/datetime.rst:1890
msgid ""
"Before Python 3.5, a :class:`.time` object was considered to be false if it "
"represented midnight in UTC. This behavior was considered obscure and error-"
"prone and has been removed in Python 3.5. See :issue:`13936` for full "
"details."
msgstr ""
"Antes do Python 3.5, um objeto :class:`.time` era considerado falso se ele "
"representava meia-noite em UTC. Este comportamento era considerado obscuro e "
"suscetível a erros, e foi removido no Python 3.5. Veja :issue:`13936` para "
"todos os detalhes."

#: ../../library/datetime.rst:1897
msgid "Other constructors:"
msgstr "Outros construtores:"

#: ../../library/datetime.rst:1901
msgid ""
"Return a :class:`.time` corresponding to a *time_string* in any valid ISO "
"8601 format, with the following exceptions:"
msgstr ""
"Retorna um :class:`.time` correspondendo a *time_string* em qualquer formato "
"válido de ISO 8601, com as seguintes exceções:"

#: ../../library/datetime.rst:1905
msgid ""
"The leading ``T``, normally required in cases where there may be ambiguity "
"between a date and a time, is not required."
msgstr ""
"O ``T`` inicial, normalmente exigido nos casos em que pode haver ambiguidade "
"entre uma data e uma hora, não é necessário."

#: ../../library/datetime.rst:1907
msgid ""
"Fractional seconds may have any number of digits (anything beyond 6 will be "
"truncated)."
msgstr ""
"Segundos fracionários podem ter qualquer número de dígitos (algo além de 6 "
"será truncado)."

#: ../../library/datetime.rst:1911
msgid "Examples:"
msgstr "Exemplos:"

#: ../../library/datetime.rst:1913
msgid ""
">>> from datetime import time\n"
">>> time.fromisoformat('04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T042301')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('04:23:01.000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01,000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01+04:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone(datetime."
"timedelta(seconds=14400)))\n"
">>> time.fromisoformat('04:23:01Z')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)\n"
">>> time.fromisoformat('04:23:01+00:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)"
msgstr ""
">>> from datetime import time\n"
">>> time.fromisoformat('04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T042301')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('04:23:01.000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01,000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01+04:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone(datetime."
"timedelta(seconds=14400)))\n"
">>> time.fromisoformat('04:23:01Z')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)\n"
">>> time.fromisoformat('04:23:01+00:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)"

#: ../../library/datetime.rst:1935
msgid ""
"Previously, this method only supported formats that could be emitted by :"
"meth:`time.isoformat`."
msgstr ""
"Anteriormente, este método suportava apenas formatos que podiam ser emitidos "
"por :meth:`time.isoformat`."

#: ../../library/datetime.rst:1941
msgid ""
"Return a :class:`.time` corresponding to *date_string*, parsed according to "
"*format*."
msgstr ""
"Retorna um :class:`.time` correspondente ao *date_string*, analisado de "
"acordo com *format*."

#: ../../library/datetime.rst:1944
msgid ""
"If *format* does not contain microseconds or timezone information, this is "
"equivalent to::"
msgstr ""
"Se *format* não contiver microssegundos ou informações de fuso horário, isso "
"é equivalente a::"

#: ../../library/datetime.rst:1946
msgid "time(*(time.strptime(date_string, format)[3:6]))"
msgstr "time(*(time.strptime(date_string, format)[3:6]))"

#: ../../library/datetime.rst:1948
msgid ""
":exc:`ValueError` is raised if the *date_string* and *format* cannot be "
"parsed by :func:`time.strptime` or if it returns a value which is not a time "
"tuple.  See also :ref:`strftime-strptime-behavior` and :meth:`time."
"fromisoformat`."
msgstr ""
":exc:`ValueError` é levantado se o *date_string* e o *format* não puderem "
"ser interpretados por :func:`time.strptime` ou se ele retorna um valor o "
"qual não é uma tupla temporal. Veja também :ref:`strftime-strptime-behavior` "
"e :meth:`time.fromisoformat`."

#: ../../library/datetime.rst:1961
msgid ""
"Return a new :class:`.time` with the same values, but with specified "
"parameters updated. Note that ``tzinfo=None`` can be specified to create a "
"naive :class:`.time` from an aware :class:`.time`, without conversion of the "
"time data."
msgstr ""
"Retorna um novo :class:`.time` com os mesmos valores, mas com os parâmetros "
"especificados atualizados. Perceba que ``tzinfo=None`` pode ser especificado "
"para criar um :class:`.time` ingênuo a partir de um :class:`.time` "
"consciente, sem conversão de dados do tempo."

#: ../../library/datetime.rst:1966
msgid ""
":class:`.time` objects are also supported by generic function :func:`copy."
"replace`."
msgstr ""
"Objetos :class:`.time` também são suportados pela função genérica :func:"
"`copy.replace`."

#: ../../library/datetime.rst:1975
msgid "Return a string representing the time in ISO 8601 format, one of:"
msgstr ""
"Retorna uma string representando a hora em formato ISO 8601, um destes:"

#: ../../library/datetime.rst:1977
msgid "``HH:MM:SS.ffffff``, if :attr:`microsecond` is not 0"
msgstr "``HH:MM:SS.ffffff``, se :attr:`microsecond` não é 0"

#: ../../library/datetime.rst:1978
msgid "``HH:MM:SS``, if :attr:`microsecond` is 0"
msgstr "``HH:MM:SS``, se :attr:`microsecond` é 0"

#: ../../library/datetime.rst:1979
msgid ""
"``HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, if :meth:`utcoffset` does not "
"return ``None``"
msgstr ""
"``HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, se :meth:`utcoffset` não retorna "
"``None``"

#: ../../library/datetime.rst:1980
msgid ""
"``HH:MM:SS+HH:MM[:SS[.ffffff]]``, if :attr:`microsecond` is 0 and :meth:"
"`utcoffset` does not return ``None``"
msgstr ""
"``HH:MM:SS+HH:MM[:SS[.ffffff]]``, se :attr:`microsecond` é 0 e :meth:"
"`utcoffset` não retorna ``None``"

#: ../../library/datetime.rst:2000
msgid ":exc:`ValueError` will be raised on an invalid *timespec* argument."
msgstr ":exc:`ValueError` será levantado com um argumento *timespec* inválido."

#: ../../library/datetime.rst:2004
msgid ""
">>> from datetime import time\n"
">>> time(hour=12, minute=34, second=56, microsecond=123456)."
"isoformat(timespec='minutes')\n"
"'12:34'\n"
">>> dt = time(hour=12, minute=34, second=56, microsecond=0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'12:34:56.000000'\n"
">>> dt.isoformat(timespec='auto')\n"
"'12:34:56'"
msgstr ""
">>> from datetime import time\n"
">>> time(hour=12, minute=34, second=56, microsecond=123456)."
"isoformat(timespec='minutes')\n"
"'12:34'\n"
">>> dt = time(hour=12, minute=34, second=56, microsecond=0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'12:34:56.000000'\n"
">>> dt.isoformat(timespec='auto')\n"
"'12:34:56'"

#: ../../library/datetime.rst:2019
msgid "For a time ``t``, ``str(t)`` is equivalent to ``t.isoformat()``."
msgstr "Para um tempo ``t``, ``str(t)`` é equivalente a ``t.isoformat()``."

#: ../../library/datetime.rst:2024
msgid ""
"Return a string representing the time, controlled by an explicit format "
"string.  See also :ref:`strftime-strptime-behavior` and :meth:`time."
"isoformat`."
msgstr ""
"Retorna uma string representando a hora, controladas por uma string com "
"formato explícito. Veja também :ref:`strftime-strptime-behavior` e :meth:"
"`time.isoformat`."

#: ../../library/datetime.rst:2030
msgid ""
"Same as :meth:`.time.strftime`. This makes it possible to specify a format "
"string for a :class:`.time` object in :ref:`formatted string literals <f-"
"strings>` and when using :meth:`str.format`. See also :ref:`strftime-"
"strptime-behavior` and :meth:`time.isoformat`."
msgstr ""
"O mesmo que :meth:`.time.strftime`. Isso torna possível especificar uma "
"string de formatação para o objeto :class:`.time` em :ref:`literais de "
"string formatados <f-strings>` e ao usar :meth:`str.format`. Veja também :"
"ref:`strftime-strptime-behavior` e :meth:`time.isoformat`."

#: ../../library/datetime.rst:2038
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"utcoffset(None)``, and raises an exception if the latter doesn't return "
"``None`` or a :class:`timedelta` object with magnitude less than one day."
msgstr ""
"Se :attr:`.tzinfo` for ``None``, retorna ``None``, caso contrário retorna "
"``self.tzinfo.utcoffset(None)``, e levanta uma exceção se o segundo não "
"retornar ``None`` ou um objeto :class:`timedelta` com magnitude menor que um "
"dia."

#: ../../library/datetime.rst:2048
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"dst(None)``, and raises an exception if the latter doesn't return ``None``, "
"or a :class:`timedelta` object with magnitude less than one day."
msgstr ""
"Se :attr:`.tzinfo` for ``None``, retorna ``None``, caso contrário retorna "
"``self.tzinfo.dst(None)``, e levanta uma exceção se o segundo não retornar "
"``None``, ou um objeto :class:`timedelta` com magnitude menor que um dia."

#: ../../library/datetime.rst:2057
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"tzname(None)``, or raises an exception if the latter doesn't return ``None`` "
"or a string object."
msgstr ""
"Se :attr:`.tzinfo` for ``None``, retorna ``None``, caso contrário retorna "
"``self.tzinfo.tzname(None)``, ou levanta uma exceção se o último caso não "
"retornar ``None`` ou um objeto string."

#: ../../library/datetime.rst:2062
msgid "Examples of Usage: :class:`.time`"
msgstr "Exemplos de uso: :class:`.time`"

#: ../../library/datetime.rst:2064
msgid "Examples of working with a :class:`.time` object::"
msgstr "Exemplos para trabalhar com um objeto :class:`.time`::"

#: ../../library/datetime.rst:2066
msgid ""
">>> from datetime import time, tzinfo, timedelta\n"
">>> class TZ1(tzinfo):\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=1)\n"
"...     def dst(self, dt):\n"
"...         return timedelta(0)\n"
"...     def tzname(self,dt):\n"
"...         return \"+01:00\"\n"
"...     def  __repr__(self):\n"
"...         return f\"{self.__class__.__name__}()\"\n"
"...\n"
">>> t = time(12, 10, 30, tzinfo=TZ1())\n"
">>> t\n"
"datetime.time(12, 10, 30, tzinfo=TZ1())\n"
">>> t.isoformat()\n"
"'12:10:30+01:00'\n"
">>> t.dst()\n"
"datetime.timedelta(0)\n"
">>> t.tzname()\n"
"'+01:00'\n"
">>> t.strftime(\"%H:%M:%S %Z\")\n"
"'12:10:30 +01:00'\n"
">>> 'The {} is {:%H:%M}.'.format(\"time\", t)\n"
"'The time is 12:10.'"
msgstr ""
">>> from datetime import time, tzinfo, timedelta\n"
">>> class TZ1(tzinfo):\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=1)\n"
"...     def dst(self, dt):\n"
"...         return timedelta(0)\n"
"...     def tzname(self,dt):\n"
"...         return \"+01:00\"\n"
"...     def  __repr__(self):\n"
"...         return f\"{self.__class__.__name__}()\"\n"
"...\n"
">>> t = time(12, 10, 30, tzinfo=TZ1())\n"
">>> t\n"
"datetime.time(12, 10, 30, tzinfo=TZ1())\n"
">>> t.isoformat()\n"
"'12:10:30+01:00'\n"
">>> t.dst()\n"
"datetime.timedelta(0)\n"
">>> t.tzname()\n"
"'+01:00'\n"
">>> t.strftime(\"%H:%M:%S %Z\")\n"
"'12:10:30 +01:00'\n"
">>> 'A {} é {:%H:%M}.'.format(\"hora\", t)\n"
"'A hora é 12:10.'"

#: ../../library/datetime.rst:2095
msgid ":class:`tzinfo` Objects"
msgstr "Objetos :class:`tzinfo`"

#: ../../library/datetime.rst:2099
msgid ""
"This is an abstract base class, meaning that this class should not be "
"instantiated directly.  Define a subclass of :class:`tzinfo` to capture "
"information about a particular time zone."
msgstr ""
"Esta é uma classe base abstrata, o que significa que esta classe não deve "
"ser instanciada diretamente. Defina uma subclasse de :class:`tzinfo` para "
"capturar informações sobre um fuso horário em particular."

#: ../../library/datetime.rst:2103
msgid ""
"An instance of (a concrete subclass of) :class:`tzinfo` can be passed to the "
"constructors for :class:`.datetime` and :class:`.time` objects. The latter "
"objects view their attributes as being in local time, and the :class:"
"`tzinfo` object supports methods revealing offset of local time from UTC, "
"the name of the time zone, and DST offset, all relative to a date or time "
"object passed to them."
msgstr ""
"Uma instância de (uma subclasse concreta de) :class:`tzinfo` pode ser "
"passada para os construtores de objetos :class:`.datetime` e :class:`.time`. "
"Os objetos time veem seus atributos como se estivessem em horário local, e o "
"objeto :class:`tzinfo` suporta métodos revelando a diferença da hora local a "
"partir de UTC, o nome do fuso horário, e diferença de horário em horário de "
"verão, todos relativos ao objeto date ou time passado para eles."

#: ../../library/datetime.rst:2109
msgid ""
"You need to derive a concrete subclass, and (at least) supply "
"implementations of the standard :class:`tzinfo` methods needed by the :class:"
"`.datetime` methods you use. The :mod:`!datetime` module provides :class:"
"`timezone`, a simple concrete subclass of :class:`tzinfo` which can "
"represent time zones with fixed offset from UTC such as UTC itself or North "
"American EST and EDT."
msgstr ""
"Você precisa derivar uma subclasse concreta, e (pelo menos) fornecer "
"implementações dos métodos padrões de :class:`tzinfo` necessários pelos "
"métodos :class:`.datetime` que você usa. O módulo :mod:`!datetime` fornece :"
"class:`timezone`, uma subclasse concreta simples de :class:`tzinfo`, que "
"pode representar fusos horários com diferença fixa a partir de UTC, tais "
"como o próprio UTC, ou EST (Eastern Standard Time ou Horário padrão "
"oriental) e EDT (Eastern Daylight Time ou Horário de verão oriental) na "
"América do Norte."

#: ../../library/datetime.rst:2116
msgid ""
"Special requirement for pickling:  A :class:`tzinfo` subclass must have an :"
"meth:`~object.__init__` method that can be called with no arguments, "
"otherwise it can be pickled but possibly not unpickled again. This is a "
"technical requirement that may be relaxed in the future."
msgstr ""
"Requisito especial para preservação: uma subclasse :class:`tzinfo` deve ter "
"um método :meth:`~object.__init__` que pode ser chamado sem nenhum "
"argumento, caso contrário ele pode ser conservado, mas não alterado "
"novamente. Isso é um requisito técnico que pode ser relaxado no futuro."

#: ../../library/datetime.rst:2122
msgid ""
"A concrete subclass of :class:`tzinfo` may need to implement the following "
"methods. Exactly which methods are needed depends on the uses made of aware :"
"mod:`!datetime` objects. If in doubt, simply implement all of them."
msgstr ""
"Uma subclasse concreta de :class:`tzinfo` pode precisar implementar os "
"seguintes métodos. Exatamente quais métodos são necessários depende do uso "
"feito de objetos :mod:`!datetime` conscientes. Se estiver em dúvida, "
"simplesmente implemente todos eles."

#: ../../library/datetime.rst:2129
msgid ""
"Return offset of local time from UTC, as a :class:`timedelta` object that is "
"positive east of UTC. If local time is west of UTC, this should be negative."
msgstr ""
"Retorna a diferença da hora local a partir do UTC, como um objeto :class:"
"`timedelta`, que é positivo a leste do UTC. Se a hora local está a oeste do "
"UTC, isto deve ser negativo."

#: ../../library/datetime.rst:2132
msgid ""
"This represents the *total* offset from UTC; for example, if a :class:"
"`tzinfo` object represents both time zone and DST adjustments, :meth:"
"`utcoffset` should return their sum. If the UTC offset isn't known, return "
"``None``. Else the value returned must be a :class:`timedelta` object "
"strictly between ``-timedelta(hours=24)`` and ``timedelta(hours=24)`` (the "
"magnitude of the offset must be less than one day). Most implementations of :"
"meth:`utcoffset` will probably look like one of these two::"
msgstr ""
"Isto representa a diferença *total* a partir de UTC; por exemplo, se um "
"objeto :class:`tzinfo` representa fuso horário e ajustes de horário de "
"verão, :meth:`utcoffset` deve retornar a soma deles. Se a diferença UTC não "
"é conhecida, retorna ``None``. Caso contrário o valor retornado deve ser um "
"objeto :class:`timedelta` estritamente contido entre ``-"
"timedelta(hours=24)`` e ``timedelta(hours=24)`` (a magnitude da diferença "
"deve ser menor que um dia). A maior parte das implementações de :meth:"
"`utcoffset` irá provavelmente parecer com um destes dois::"

#: ../../library/datetime.rst:2140
msgid ""
"return CONSTANT                 # fixed-offset class\n"
"return CONSTANT + self.dst(dt)  # daylight-aware class"
msgstr ""
"return CONSTANT                 # classe de posição fixa\n"
"return CONSTANT + self.dst(dt)  # classe consciente de horário de verão"

#: ../../library/datetime.rst:2143
msgid ""
"If :meth:`utcoffset` does not return ``None``, :meth:`dst` should not return "
"``None`` either."
msgstr ""
"Se :meth:`utcoffset` não retorna ``None``, :meth:`dst` também não deve "
"retornar ``None``."

#: ../../library/datetime.rst:2146
msgid ""
"The default implementation of :meth:`utcoffset` raises :exc:"
"`NotImplementedError`."
msgstr ""
"A implementação padrão de :meth:`utcoffset` levanta :exc:"
"`NotImplementedError`."

#: ../../library/datetime.rst:2155
msgid ""
"Return the daylight saving time (DST) adjustment, as a :class:`timedelta` "
"object or ``None`` if DST information isn't known."
msgstr ""
"Retorna o ajuste para o horário de verão (DST - daylight saving time), como "
"um objeto :class:`timedelta` ou ``None`` se informação para o horário de "
"verão é desconhecida."

#: ../../library/datetime.rst:2159
msgid ""
"Return ``timedelta(0)`` if DST is not in effect. If DST is in effect, return "
"the offset as a :class:`timedelta` object (see :meth:`utcoffset` for "
"details). Note that DST offset, if applicable, has already been added to the "
"UTC offset returned by :meth:`utcoffset`, so there's no need to consult :"
"meth:`dst` unless you're interested in obtaining DST info separately. For "
"example, :meth:`datetime.timetuple` calls its :attr:`~.datetime.tzinfo` "
"attribute's :meth:`dst` method to determine how the :attr:`~time.struct_time."
"tm_isdst` flag should be set, and :meth:`tzinfo.fromutc` calls :meth:`dst` "
"to account for DST changes when crossing time zones."
msgstr ""
"Retorna ``timedelta(0)`` se o horário de verão não estiver ativo. Se o "
"horário de verão estiver ativo, retorna a diferença como um objeto :class:"
"`timedelta` (veja :meth:`utcoffset` para detalhes). Perceba que a diferença "
"do horário de verão, se aplicável, já foi adicionada a diferença UTC "
"retornada por :meth:`utcoffset`, então não existe necessidade de consultar :"
"meth:`dst` a não ser que você esteja interessado em obter a informação de "
"horário de verão separadamente. Por exemplo, :meth:`datetime.timetuple` "
"chama o método :meth:`dst` do seu atributo :attr:`~.datetime.tzinfo` para "
"determinar como o flag :attr:`~time.struct_time.tm_isdst` deve ser definido, "
"e :meth:`tzinfo.fromutc` chama :meth:`dst` para contabilizar as mudanças de "
"horário de verão quando ocorrem mudanças de fuso horário."

#: ../../library/datetime.rst:2169
msgid ""
"An instance *tz* of a :class:`tzinfo` subclass that models both standard and "
"daylight times must be consistent in this sense:"
msgstr ""
"Uma instância *tz* de uma subclasse :class:`tzinfo` que modela tanto horário "
"padrão quanto horário de verão deve ser consistente neste sentido:"

#: ../../library/datetime.rst:2172
msgid "``tz.utcoffset(dt) - tz.dst(dt)``"
msgstr "``tz.utcoffset(dt) - tz.dst(dt)``"

#: ../../library/datetime.rst:2174
msgid ""
"must return the same result for every :class:`.datetime` *dt* with ``dt."
"tzinfo == tz``. For sane :class:`tzinfo` subclasses, this expression yields "
"the time zone's \"standard offset\", which should not depend on the date or "
"the time, but only on geographic location. The implementation of :meth:"
"`datetime.astimezone` relies on this, but cannot detect violations; it's the "
"programmer's responsibility to ensure it. If a :class:`tzinfo` subclass "
"cannot guarantee this, it may be able to override the default implementation "
"of :meth:`tzinfo.fromutc` to work correctly with :meth:`~.datetime."
"astimezone` regardless."
msgstr ""
"deve retornar o mesmo resultado para cada :class:`.datetime` *dt* com ``dt."
"tzinfo == tz`` para subclasses :class:`tzinfo` sãs, esta expressão produz a "
"\"diferença padrão\" do fuso horário, a qual não deve depender de data ou "
"hora, mas apenas de localização geográfica. A implementação de :meth:"
"`datetime.astimezone` depende disso, mas não pode detectar violações; é "
"responsabilidade do programador garantir isso. Se uma subclasse :class:"
"`tzinfo` não pode garantir isso, ele pode ser capaz de substituir a "
"implementação padrão de :meth:`tzinfo.fromutc` para funcionar corretamente "
"com :meth:`~.datetime.astimezone` independente disso."

#: ../../library/datetime.rst:2183
msgid ""
"Most implementations of :meth:`dst` will probably look like one of these "
"two::"
msgstr ""
"Maior parte das implementações de :meth:`dst` provavelmente irá parecer com "
"um destes dois::"

#: ../../library/datetime.rst:2185
msgid ""
"def dst(self, dt):\n"
"    # a fixed-offset class:  doesn't account for DST\n"
"    return timedelta(0)"
msgstr ""
"def dst(self, dt):\n"
"    # uma classe de posição fixa: não levam em conta DST\n"
"    return timedelta(0)"

#: ../../library/datetime.rst:2189
msgid "or::"
msgstr "ou::"

#: ../../library/datetime.rst:2191
msgid ""
"def dst(self, dt):\n"
"    # Code to set dston and dstoff to the time zone's DST\n"
"    # transition times based on the input dt.year, and expressed\n"
"    # in standard local time.\n"
"\n"
"    if dston <= dt.replace(tzinfo=None) < dstoff:\n"
"        return timedelta(hours=1)\n"
"    else:\n"
"        return timedelta(0)"
msgstr ""
"def dst(self, dt):\n"
"    # Código para definir dston e dstoff para os horários\n"
"    # de transição do horário de versão com base\n"
"    # no dt.year de entrada e expresso no horário local padrão.\n"
"\n"
"    if dston <= dt.replace(tzinfo=None) < dstoff:\n"
"        return timedelta(hours=1)\n"
"    else:\n"
"        return timedelta(0)"

#: ../../library/datetime.rst:2201
msgid ""
"The default implementation of :meth:`dst` raises :exc:`NotImplementedError`."
msgstr ""
"A implementação padrão de :meth:`dst` levanta :exc:`NotImplementedError`."

#: ../../library/datetime.rst:2209
msgid ""
"Return the time zone name corresponding to the :class:`.datetime` object "
"*dt*, as a string. Nothing about string names is defined by the :mod:`!"
"datetime` module, and there's no requirement that it mean anything in "
"particular. For example, ``\"GMT\"``, ``\"UTC\"``, ``\"-500\"``, "
"``\"-5:00\"``, ``\"EDT\"``, ``\"US/Eastern\"``, ``\"America/New York\"`` are "
"all valid replies. Return ``None`` if a string name isn't known. Note that "
"this is a method rather than a fixed string primarily because some :class:"
"`tzinfo` subclasses will wish to return different names depending on the "
"specific value of *dt* passed, especially if the :class:`tzinfo` class is "
"accounting for daylight time."
msgstr ""
"Retorna o nome do fuso horário correspondente ao objeto :class:`.datetime` "
"*dt*, como uma string. Nada sobre nomes de strings é definido pelo módulo :"
"mod:`!datetime`, e não há nenhuma exigência de que signifique algo em "
"particular. Por exemplo, ``\"GMT\"``, ``\"UTC\"``, ``\"-500\"``, "
"``\"-5:00\"``, ``\"EDT\"``, ``\"US/Eastern\"``, ``\"America/New York\"`` são "
"todas respostas válidas. Retorna ``None`` se um nome de string não for "
"conhecido. Observe que este é um método em vez de uma string fixa, "
"principalmente porque algumas subclasses :class:`tzinfo` desejarão retornar "
"nomes diferentes dependendo do valor específico de *dt* passado, "
"especialmente se a classe :class:`tzinfo` estiver contabilizando o horário "
"de verão."

#: ../../library/datetime.rst:2219
msgid ""
"The default implementation of :meth:`tzname` raises :exc:"
"`NotImplementedError`."
msgstr ""
"A implementação padrão de :meth:`tzname` levanta :exc:`NotImplementedError`."

#: ../../library/datetime.rst:2222
msgid ""
"These methods are called by a :class:`.datetime` or :class:`.time` object, "
"in response to their methods of the same names. A :class:`.datetime` object "
"passes itself as the argument, and a :class:`.time` object passes ``None`` "
"as the argument. A :class:`tzinfo` subclass's methods should therefore be "
"prepared to accept a *dt* argument of ``None``, or of class :class:`."
"datetime`."
msgstr ""
"Estes métodos são chamados por um objeto :class:`.datetime` ou :class:`."
"time`, em resposta aos seus métodos de mesmo nome. Um objeto :class:`."
"datetime` passa a si mesmo como argumento, e um objeto :class:`.time` passa "
"``None`` como o argumento. Os métodos de uma subclasse :class:`tzinfo` devem "
"portanto estar preparados para aceitar um argumento *dt* com valor ``None``, "
"ou uma classe :class:`.datetime`."

#: ../../library/datetime.rst:2228
msgid ""
"When ``None`` is passed, it's up to the class designer to decide the best "
"response. For example, returning ``None`` is appropriate if the class wishes "
"to say that time objects don't participate in the :class:`tzinfo` protocols. "
"It may be more useful for ``utcoffset(None)`` to return the standard UTC "
"offset, as there is no other convention for discovering the standard offset."
msgstr ""
"Quando ``None`` é passado, cabe ao projetista da classe decidir a melhor "
"resposta. Por exemplo, retornar ``None`` é apropriado se a classe deseja "
"dizer que objetos time não participam nos protocolos da classe :class:"
"`tzinfo`. Pode ser mais útil para ``utcoffset(None)`` retornar a diferença "
"UTC padrão, como não existe outra convenção para descobrir a diferença "
"padrão."

#: ../../library/datetime.rst:2234
msgid ""
"When a :class:`.datetime` object is passed in response to a :class:`."
"datetime` method, ``dt.tzinfo`` is the same object as *self*. :class:"
"`tzinfo` methods can rely on this, unless user code calls :class:`tzinfo` "
"methods directly. The intent is that the :class:`tzinfo` methods interpret "
"*dt* as being in local time, and not need worry about objects in other time "
"zones."
msgstr ""
"Quando um objeto :class:`.datetime` é passado em resposta a um método :class:"
"`.datetime`, ``dt.tzinfo`` é o mesmo objeto que *self*. Os métodos :class:"
"`tzinfo` podem confiar nisso, a menos que o código do usuário chame métodos :"
"class:`tzinfo` diretamente. A intenção é que os métodos :class:`tzinfo` "
"interpretem *dt* como estando no horário local, e não precisem se preocupar "
"com objetos em outros fusos horários."

#: ../../library/datetime.rst:2240
msgid ""
"There is one more :class:`tzinfo` method that a subclass may wish to "
"override:"
msgstr ""
"Existe mais um método :class:`tzinfo` que uma subclasse pode desejar "
"substituição:"

#: ../../library/datetime.rst:2245
msgid ""
"This is called from the default :meth:`datetime.astimezone` implementation. "
"When called from that, ``dt.tzinfo`` is *self*, and *dt*'s date and time "
"data are to be viewed as expressing a UTC time. The purpose of :meth:"
"`fromutc` is to adjust the date and time data, returning an equivalent "
"datetime in *self*'s local time."
msgstr ""
"Isto é chamado a partir do padrão implementação de :meth:`datetime."
"astimezone`. Quando chamado a partir dele, ``dt.tzinfo`` é *self*, e os "
"dados de data e hora de *dt* devem ser vistos como expressando um Horário "
"Universal Coordenado (UTC). O propósito de :meth:`fromutc` é ajustar os "
"dados de data e hora, retornando um *datetime* equivalente na hora local de "
"*self*."

#: ../../library/datetime.rst:2251
msgid ""
"Most :class:`tzinfo` subclasses should be able to inherit the default :meth:"
"`fromutc` implementation without problems. It's strong enough to handle "
"fixed-offset time zones, and time zones accounting for both standard and "
"daylight time, and the latter even if the DST transition times differ in "
"different years. An example of a time zone the default :meth:`fromutc` "
"implementation may not handle correctly in all cases is one where the "
"standard offset (from UTC) depends on the specific date and time passed, "
"which can happen for political reasons. The default implementations of :meth:"
"`~.datetime.astimezone` and :meth:`fromutc` may not produce the result you "
"want if the result is one of the hours straddling the moment the standard "
"offset changes."
msgstr ""
"A maioria das subclasses de :class:`tzinfo` deve ser capaz de herdar a "
"implementação padrão de :meth:`fromutc` sem problemas. Ela é robusta o "
"suficiente para lidar com fusos horários de deslocamento fixo, e fusos "
"horários que contabilizam tanto o horário padrão quanto o horário de verão, "
"sendo que este último é tratado mesmo que os horários de transição do "
"horário de verão sejam diferentes em anos distintos. Um exemplo de fuso "
"horário que a implementação padrão de :meth:`fromutc` pode não lidar "
"corretamente em todos os casos é aquele onde o deslocamento padrão (de UTC) "
"depende da data e hora específicas passadas, o que pode acontecer por razões "
"políticas. As implementações padrão de :meth:`~.datetime.astimezone` e :meth:"
"`fromutc` podem não produzir o resultado desejado se o resultado estiver "
"entre as horas que abrangem o momento em que o deslocamento padrão muda."

#: ../../library/datetime.rst:2262
msgid ""
"Skipping code for error cases, the default :meth:`fromutc` implementation "
"acts like::"
msgstr ""
"Ignorando o código para casos de erros, a implementação padrão :meth:"
"`fromutc` funciona como::"

#: ../../library/datetime.rst:2265
msgid ""
"def fromutc(self, dt):\n"
"    # raise ValueError error if dt.tzinfo is not self\n"
"    dtoff = dt.utcoffset()\n"
"    dtdst = dt.dst()\n"
"    # raise ValueError if dtoff is None or dtdst is None\n"
"    delta = dtoff - dtdst  # this is self's standard offset\n"
"    if delta:\n"
"        dt += delta   # convert to standard local time\n"
"        dtdst = dt.dst()\n"
"        # raise ValueError if dtdst is None\n"
"    if dtdst:\n"
"        return dt + dtdst\n"
"    else:\n"
"        return dt"
msgstr ""
"def fromutc(self, dt):\n"
"    # levanta o erro ValueError se dt.tzinfo não é o self\n"
"    dtoff = dt.utcoffset()\n"
"    dtdst = dt.dst()\n"
"    # levanta ValueError se dtoff é None ou dtdst é None\n"
"    delta = dtoff - dtdst  # este é o deslocamento padrão do self\n"
"    if delta:\n"
"        dt += delta   # converter para hora local padrão\n"
"        dtdst = dt.dst()\n"
"        # levanta ValueError se dtdst é None\n"
"    if dtdst:\n"
"        return dt + dtdst\n"
"    else:\n"
"        return dt"

#: ../../library/datetime.rst:2280
msgid ""
"In the following :download:`tzinfo_examples.py <../includes/tzinfo_examples."
"py>` file there are some examples of :class:`tzinfo` classes:"
msgstr ""
"No seguinte arquivo :download:`tzinfo_examples.py <../includes/"
"tzinfo_examples.py>` existem alguns exemplos de classes :class:`tzinfo`:"

#: ../../library/datetime.rst:2284
msgid ""
"from datetime import tzinfo, timedelta, datetime\n"
"\n"
"ZERO = timedelta(0)\n"
"HOUR = timedelta(hours=1)\n"
"SECOND = timedelta(seconds=1)\n"
"\n"
"# A class capturing the platform's idea of local time.\n"
"# (May result in wrong values on historical times in\n"
"#  timezones where UTC offset and/or the DST rules had\n"
"#  changed in the past.)\n"
"import time as _time\n"
"\n"
"STDOFFSET = timedelta(seconds = -_time.timezone)\n"
"if _time.daylight:\n"
"    DSTOFFSET = timedelta(seconds = -_time.altzone)\n"
"else:\n"
"    DSTOFFSET = STDOFFSET\n"
"\n"
"DSTDIFF = DSTOFFSET - STDOFFSET\n"
"\n"
"class LocalTimezone(tzinfo):\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        stamp = (dt - datetime(1970, 1, 1, tzinfo=self)) // SECOND\n"
"        args = _time.localtime(stamp)[:6]\n"
"        dst_diff = DSTDIFF // SECOND\n"
"        # Detect fold\n"
"        fold = (args == _time.localtime(stamp - dst_diff))\n"
"        return datetime(*args, microsecond=dt.microsecond,\n"
"                        tzinfo=self, fold=fold)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTOFFSET\n"
"        else:\n"
"            return STDOFFSET\n"
"\n"
"    def dst(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTDIFF\n"
"        else:\n"
"            return ZERO\n"
"\n"
"    def tzname(self, dt):\n"
"        return _time.tzname[self._isdst(dt)]\n"
"\n"
"    def _isdst(self, dt):\n"
"        tt = (dt.year, dt.month, dt.day,\n"
"              dt.hour, dt.minute, dt.second,\n"
"              dt.weekday(), 0, 0)\n"
"        stamp = _time.mktime(tt)\n"
"        tt = _time.localtime(stamp)\n"
"        return tt.tm_isdst > 0\n"
"\n"
"Local = LocalTimezone()\n"
"\n"
"\n"
"# A complete implementation of current DST rules for major US time zones.\n"
"\n"
"def first_sunday_on_or_after(dt):\n"
"    days_to_go = 6 - dt.weekday()\n"
"    if days_to_go:\n"
"        dt += timedelta(days_to_go)\n"
"    return dt\n"
"\n"
"\n"
"# US DST Rules\n"
"#\n"
"# This is a simplified (i.e., wrong for a few cases) set of rules for US\n"
"# DST start and end times. For a complete and up-to-date set of DST rules\n"
"# and timezone definitions, visit the Olson Database (or try pytz):\n"
"# http://www.twinsun.com/tz/tz-link.htm\n"
"# https://sourceforge.net/projects/pytz/ (might not be up-to-date)\n"
"#\n"
"# In the US, since 2007, DST starts at 2am (standard time) on the second\n"
"# Sunday in March, which is the first Sunday on or after Mar 8.\n"
"DSTSTART_2007 = datetime(1, 3, 8, 2)\n"
"# and ends at 2am (DST time) on the first Sunday of Nov.\n"
"DSTEND_2007 = datetime(1, 11, 1, 2)\n"
"# From 1987 to 2006, DST used to start at 2am (standard time) on the first\n"
"# Sunday in April and to end at 2am (DST time) on the last\n"
"# Sunday of October, which is the first Sunday on or after Oct 25.\n"
"DSTSTART_1987_2006 = datetime(1, 4, 1, 2)\n"
"DSTEND_1987_2006 = datetime(1, 10, 25, 2)\n"
"# From 1967 to 1986, DST used to start at 2am (standard time) on the last\n"
"# Sunday in April (the one on or after April 24) and to end at 2am (DST "
"time)\n"
"# on the last Sunday of October, which is the first Sunday\n"
"# on or after Oct 25.\n"
"DSTSTART_1967_1986 = datetime(1, 4, 24, 2)\n"
"DSTEND_1967_1986 = DSTEND_1987_2006\n"
"\n"
"def us_dst_range(year):\n"
"    # Find start and end times for US DST. For years before 1967, return\n"
"    # start = end for no DST.\n"
"    if 2006 < year:\n"
"        dststart, dstend = DSTSTART_2007, DSTEND_2007\n"
"    elif 1986 < year < 2007:\n"
"        dststart, dstend = DSTSTART_1987_2006, DSTEND_1987_2006\n"
"    elif 1966 < year < 1987:\n"
"        dststart, dstend = DSTSTART_1967_1986, DSTEND_1967_1986\n"
"    else:\n"
"        return (datetime(year, 1, 1), ) * 2\n"
"\n"
"    start = first_sunday_on_or_after(dststart.replace(year=year))\n"
"    end = first_sunday_on_or_after(dstend.replace(year=year))\n"
"    return start, end\n"
"\n"
"\n"
"class USTimeZone(tzinfo):\n"
"\n"
"    def __init__(self, hours, reprname, stdname, dstname):\n"
"        self.stdoffset = timedelta(hours=hours)\n"
"        self.reprname = reprname\n"
"        self.stdname = stdname\n"
"        self.dstname = dstname\n"
"\n"
"    def __repr__(self):\n"
"        return self.reprname\n"
"\n"
"    def tzname(self, dt):\n"
"        if self.dst(dt):\n"
"            return self.dstname\n"
"        else:\n"
"            return self.stdname\n"
"\n"
"    def utcoffset(self, dt):\n"
"        return self.stdoffset + self.dst(dt)\n"
"\n"
"    def dst(self, dt):\n"
"        if dt is None or dt.tzinfo is None:\n"
"            # An exception may be sensible here, in one or both cases.\n"
"            # It depends on how you want to treat them.  The default\n"
"            # fromutc() implementation (called by the default astimezone()\n"
"            # implementation) passes a datetime with dt.tzinfo is self.\n"
"            return ZERO\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        # Can't compare naive to aware objects, so strip the timezone from\n"
"        # dt first.\n"
"        dt = dt.replace(tzinfo=None)\n"
"        if start + HOUR <= dt < end - HOUR:\n"
"            # DST is in effect.\n"
"            return HOUR\n"
"        if end - HOUR <= dt < end:\n"
"            # Fold (an ambiguous hour): use dt.fold to disambiguate.\n"
"            return ZERO if dt.fold else HOUR\n"
"        if start <= dt < start + HOUR:\n"
"            # Gap (a non-existent hour): reverse the fold rule.\n"
"            return HOUR if dt.fold else ZERO\n"
"        # DST is off.\n"
"        return ZERO\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        start = start.replace(tzinfo=self)\n"
"        end = end.replace(tzinfo=self)\n"
"        std_time = dt + self.stdoffset\n"
"        dst_time = std_time + HOUR\n"
"        if end <= dst_time < end + HOUR:\n"
"            # Repeated hour\n"
"            return std_time.replace(fold=1)\n"
"        if std_time < start or dst_time >= end:\n"
"            # Standard time\n"
"            return std_time\n"
"        if start <= std_time < end - HOUR:\n"
"            # Daylight saving time\n"
"            return dst_time\n"
"\n"
"\n"
"Eastern  = USTimeZone(-5, \"Eastern\",  \"EST\", \"EDT\")\n"
"Central  = USTimeZone(-6, \"Central\",  \"CST\", \"CDT\")\n"
"Mountain = USTimeZone(-7, \"Mountain\", \"MST\", \"MDT\")\n"
"Pacific  = USTimeZone(-8, \"Pacific\",  \"PST\", \"PDT\")\n"
msgstr ""
"from datetime import tzinfo, timedelta, datetime\n"
"\n"
"ZERO = timedelta(0)\n"
"HOUR = timedelta(hours=1)\n"
"SECOND = timedelta(seconds=1)\n"
"\n"
"# Uma classe que captura a ideia da plataforma sobre o horário local.\n"
"# (Pode resultar em valores errados em horários históricos em fusos "
"horários\n"
"#  onde o deslocamento UTC e/ou as regras de horário de verão\n"
"#  foram alteradas no passado.)\n"
"import time as _time\n"
"\n"
"STDOFFSET = timedelta(seconds = -_time.timezone)\n"
"if _time.daylight:\n"
"    DSTOFFSET = timedelta(seconds = -_time.altzone)\n"
"else:\n"
"    DSTOFFSET = STDOFFSET\n"
"\n"
"DSTDIFF = DSTOFFSET - STDOFFSET\n"
"\n"
"class LocalTimezone(tzinfo):\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        stamp = (dt - datetime(1970, 1, 1, tzinfo=self)) // SECOND\n"
"        args = _time.localtime(stamp)[:6]\n"
"        dst_diff = DSTDIFF // SECOND\n"
"        # Detect fold\n"
"        fold = (args == _time.localtime(stamp - dst_diff))\n"
"        return datetime(*args, microsecond=dt.microsecond,\n"
"                        tzinfo=self, fold=fold)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTOFFSET\n"
"        else:\n"
"            return STDOFFSET\n"
"\n"
"    def dst(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTDIFF\n"
"        else:\n"
"            return ZERO\n"
"\n"
"    def tzname(self, dt):\n"
"        return _time.tzname[self._isdst(dt)]\n"
"\n"
"    def _isdst(self, dt):\n"
"        tt = (dt.year, dt.month, dt.day,\n"
"              dt.hour, dt.minute, dt.second,\n"
"              dt.weekday(), 0, 0)\n"
"        stamp = _time.mktime(tt)\n"
"        tt = _time.localtime(stamp)\n"
"        return tt.tm_isdst > 0\n"
"\n"
"Local = LocalTimezone()\n"
"\n"
"\n"
"# Uma implementação completa das regras atuais do horário de verão para os "
"principais fusos horários dos EUA.\n"
"\n"
"def first_sunday_on_or_after(dt):\n"
"    days_to_go = 6 - dt.weekday()\n"
"    if days_to_go:\n"
"        dt += timedelta(days_to_go)\n"
"    return dt\n"
"\n"
"\n"
"# Regras do horário de verão dos EUA\n"
"#\n"
"# Este é um conjunto simplificado (ou seja, incorreto em alguns casos)\n"
"# de regras para os horários de início e término do horário de verão dos "
"EUA.\n"
"# Para um conjunto completo e atualizado de regras de horário de verão\n"
"# e definições de fuso horário, visite o Olson Database (ou tente pytz):\n"
"# http://www.twinsun.com/tz/tz-link.htm\n"
"# https://sourceforge.net/projects/pytz/ (pode não estar atualizado)\n"
"#\n"
"# Nos EUA, desde 2007, o horário de verão começa às 2h (horário padrão) no\n"
"# segundo domingo de março, que é o primeiro domingo em ou após 8 de março.\n"
"DSTSTART_2007 = datetime(1, 3, 8, 2)\n"
"# e termina às 2h (horário de verão) no primeiro domingo de novembro.\n"
"DSTEND_2007 = datetime(1, 11, 1, 2)\n"
"# De 1987 a 2006, o horário de verão costumava começar às 2h\n"
"# (horário padrão) no primeiro domingo de abril e terminar às 2h\n"
"# (horário de verão) no último Domingo de outubro, que é o primeiro\n"
"# domingo em ou após 25 de outubro.\n"
"DSTSTART_1987_2006 = datetime(1, 4, 1, 2)\n"
"DSTEND_1987_2006 = datetime(1, 10, 25, 2)\n"
"# De 1967 a 1986, o horário de verão costumava começar às 2h\n"
"# (horário padrão) no último domingo de abril (aquele em ou após\n"
"# 24 de abril) e terminar às 2h (horário de verão) no último domingo\n"
"# de outubro, que é o primeiro domingo em ou após 25 de outubro.\n"
"DSTSTART_1967_1986 = datetime(1, 4, 24, 2)\n"
"DSTEND_1967_1986 = DSTEND_1987_2006\n"
"\n"
"def us_dst_range(year):\n"
"    # Encontra os horários de início e fim do horário de verão dos EUA.\n"
"    # Para anos anteriores a 1967, retorne start = end para nenhum horário\n"
"    # de verão.\n"
"    if 2006 < year:\n"
"        dststart, dstend = DSTSTART_2007, DSTEND_2007\n"
"    elif 1986 < year < 2007:\n"
"        dststart, dstend = DSTSTART_1987_2006, DSTEND_1987_2006\n"
"    elif 1966 < year < 1987:\n"
"        dststart, dstend = DSTSTART_1967_1986, DSTEND_1967_1986\n"
"    else:\n"
"        return (datetime(year, 1, 1), ) * 2\n"
"\n"
"    start = first_sunday_on_or_after(dststart.replace(year=year))\n"
"    end = first_sunday_on_or_after(dstend.replace(year=year))\n"
"    return start, end\n"
"\n"
"\n"
"class USTimeZone(tzinfo):\n"
"\n"
"    def __init__(self, hours, reprname, stdname, dstname):\n"
"        self.stdoffset = timedelta(hours=hours)\n"
"        self.reprname = reprname\n"
"        self.stdname = stdname\n"
"        self.dstname = dstname\n"
"\n"
"    def __repr__(self):\n"
"        return self.reprname\n"
"\n"
"    def tzname(self, dt):\n"
"        if self.dst(dt):\n"
"            return self.dstname\n"
"        else:\n"
"            return self.stdname\n"
"\n"
"    def utcoffset(self, dt):\n"
"        return self.stdoffset + self.dst(dt)\n"
"\n"
"    def dst(self, dt):\n"
"        if dt is None or dt.tzinfo is None:\n"
"            # Uma exceção pode ser sensata aqui, em um ou ambos os casos.\n"
"            # Depende de como você quer tratá-las. A implementação padrão\n"
"            # fromutc() (chamada pela implementação padrão astimezone()) "
"passa\n"
"            # um datetime com dt.tzinfo é self.\n"
"            return ZERO\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        # Não é possível comparar objetos ingênuos com objetos conscientes,\n"
"        # então retira o fuso horário de dt primeiro.\n"
"        dt = dt.replace(tzinfo=None)\n"
"        if start + HOUR <= dt < end - HOUR:\n"
"            # Horário de verão está em vigor.\n"
"            return HOUR\n"
"        if end - HOUR <= dt < end:\n"
"            # Fold (uma hora ambígua): usa dt.fold para desambiguar.\n"
"            return ZERO if dt.fold else HOUR\n"
"        if start <= dt < start + HOUR:\n"
"            # Intervalo (uma hora inexistente): inverta a regra da dobra.\n"
"            return HOUR if dt.fold else ZERO\n"
"        # DST is off.\n"
"        return ZERO\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        start = start.replace(tzinfo=self)\n"
"        end = end.replace(tzinfo=self)\n"
"        std_time = dt + self.stdoffset\n"
"        dst_time = std_time + HOUR\n"
"        if end <= dst_time < end + HOUR:\n"
"            # Hora repetida\n"
"            return std_time.replace(fold=1)\n"
"        if std_time < start or dst_time >= end:\n"
"            # Horário padrão\n"
"            return std_time\n"
"        if start <= std_time < end - HOUR:\n"
"            # Horário de verão\n"
"            return dst_time\n"
"\n"
"\n"
"Eastern  = USTimeZone(-5, \"Eastern\",  \"EST\", \"EDT\")\n"
"Central  = USTimeZone(-6, \"Central\",  \"CST\", \"CDT\")\n"
"Mountain = USTimeZone(-7, \"Mountain\", \"MST\", \"MDT\")\n"
"Pacific  = USTimeZone(-8, \"Pacific\",  \"PST\", \"PDT\")\n"

#: ../../library/datetime.rst:2286
msgid ""
"Note that there are unavoidable subtleties twice per year in a :class:"
"`tzinfo` subclass accounting for both standard and daylight time, at the DST "
"transition points. For concreteness, consider US Eastern (UTC -0500), where "
"EDT begins the minute after 1:59 (EST) on the second Sunday in March, and "
"ends the minute after 1:59 (EDT) on the first Sunday in November::"
msgstr ""
"Perceba que existem sutilezas inevitáveis duas vezes por ano em uma "
"subclasse :class:`tzinfo` contabilizando tanto hora normal e horário de "
"verão, nos pontos de transição do horário de verão. Para concretude, "
"considere a costa leste dos EUA (UTC -0500), onde o horário de verão EDT "
"começa no minuto após 1:59 (EST, hora padrão) no segundo domingo de Março, e "
"termina no minuto posterior a 1:59 (EDT, horário de verão) no primeiro "
"domingo de Novembro::"

#: ../../library/datetime.rst:2292
msgid ""
"  UTC   3:MM  4:MM  5:MM  6:MM  7:MM  8:MM\n"
"  EST  22:MM 23:MM  0:MM  1:MM  2:MM  3:MM\n"
"  EDT  23:MM  0:MM  1:MM  2:MM  3:MM  4:MM\n"
"\n"
"start  22:MM 23:MM  0:MM  1:MM  3:MM  4:MM\n"
"\n"
"  end  23:MM  0:MM  1:MM  1:MM  2:MM  3:MM"
msgstr ""
"  UTC   3:MM  4:MM  5:MM  6:MM  7:MM  8:MM\n"
"  EST  22:MM 23:MM  0:MM  1:MM  2:MM  3:MM\n"
"  EDT  23:MM  0:MM  1:MM  2:MM  3:MM  4:MM\n"
"\n"
"start  22:MM 23:MM  0:MM  1:MM  3:MM  4:MM\n"
"\n"
"  end  23:MM  0:MM  1:MM  1:MM  2:MM  3:MM"

#: ../../library/datetime.rst:2300
msgid ""
"When DST starts (the \"start\" line), the local wall clock leaps from 1:59 "
"to 3:00. A wall time of the form 2:MM doesn't really make sense on that day, "
"so ``astimezone(Eastern)`` won't deliver a result with ``hour == 2`` on the "
"day DST begins. For example, at the Spring forward transition of 2016, we "
"get::"
msgstr ""
"Quando o horário de verão inicia (a linha de \"início\"), o relógio de "
"parede local salta de 1:59 para 3:00. Um horário de parede da forma 2:MM "
"realmente não faz sentido nesse dia, então ``astimezone(Eastern)`` não irá "
"entregar um resultado com ``hour == 2`` no dia que o horário de verão "
"começar. Por exemplo, na primavera de transição para frente em 2016, nós "
"tivemos::"

#: ../../library/datetime.rst:2305
msgid ""
">>> from datetime import datetime, timezone\n"
">>> from tzinfo_examples import HOUR, Eastern\n"
">>> u0 = datetime(2016, 3, 13, 5, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname())\n"
"...\n"
"05:00:00 UTC = 00:00:00 EST\n"
"06:00:00 UTC = 01:00:00 EST\n"
"07:00:00 UTC = 03:00:00 EDT\n"
"08:00:00 UTC = 04:00:00 EDT"
msgstr ""
">>> from datetime import datetime, timezone\n"
">>> from tzinfo_examples import HOUR, Eastern\n"
">>> u0 = datetime(2016, 3, 13, 5, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname())\n"
"...\n"
"05:00:00 UTC = 00:00:00 EST\n"
"06:00:00 UTC = 01:00:00 EST\n"
"07:00:00 UTC = 03:00:00 EDT\n"
"08:00:00 UTC = 04:00:00 EDT"

#: ../../library/datetime.rst:2319
msgid ""
"When DST ends (the \"end\" line), there's a potentially worse problem: "
"there's an hour that can't be spelled unambiguously in local wall time: the "
"last hour of daylight time. In Eastern, that's times of the form 5:MM UTC on "
"the day daylight time ends. The local wall clock leaps from 1:59 (daylight "
"time) back to 1:00 (standard time) again. Local times of the form 1:MM are "
"ambiguous. :meth:`~.datetime.astimezone` mimics the local clock's behavior "
"by mapping two adjacent UTC hours into the same local hour then. In the "
"Eastern example, UTC times of the form 5:MM and 6:MM both map to 1:MM when "
"converted to Eastern, but earlier times have the :attr:`~.datetime.fold` "
"attribute set to 0 and the later times have it set to 1. For example, at the "
"Fall back transition of 2016, we get::"
msgstr ""
"Quando o horário de verão termina (a linha \"end\"), há um problema "
"potencialmente pior: existe uma hora que não pode ser expressa de forma "
"inequívoca no horário local: a última hora do horário de verão. No fuso "
"Eastern, isso corresponde a horários no formato 5:MM UTC no dia em que o "
"horário de verão termina. O relógio de parede local salta de 1:59 (horário "
"de verão) para 1:00 (horário padrão) novamente. Horários locais no formato 1:"
"MM são ambíguos. :meth:`~.datetime.astimezone` imita o comportamento do "
"relógio local mapeando então duas horas UTC adjacentes para a mesma hora "
"local. No exemplo do fuso Eastern, horários UTC no formato 5:MM e 6:MM ambos "
"se transformam em 1:MM quando convertidos para o fuso Eastern, mas os "
"horários anteriores têm o atributo :attr:`~.datetime.fold` definido como 0 e "
"os horários posteriores têm o atributo definido como 1. Por exemplo, na "
"transição de retorno de 2016, obtemos::"

#: ../../library/datetime.rst:2330
msgid ""
">>> u0 = datetime(2016, 11, 6, 4, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname(), t.fold)\n"
"...\n"
"04:00:00 UTC = 00:00:00 EDT 0\n"
"05:00:00 UTC = 01:00:00 EDT 0\n"
"06:00:00 UTC = 01:00:00 EST 1\n"
"07:00:00 UTC = 02:00:00 EST 0"
msgstr ""
">>> u0 = datetime(2016, 11, 6, 4, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname(), t.fold)\n"
"...\n"
"04:00:00 UTC = 00:00:00 EDT 0\n"
"05:00:00 UTC = 01:00:00 EDT 0\n"
"06:00:00 UTC = 01:00:00 EST 1\n"
"07:00:00 UTC = 02:00:00 EST 0"

#: ../../library/datetime.rst:2341
msgid ""
"Note that the :class:`.datetime` instances that differ only by the value of "
"the :attr:`~.datetime.fold` attribute are considered equal in comparisons."
msgstr ""
"Observe que as instâncias de :class:`.datetime` que diferem apenas pelo "
"valor do atributo :attr:`~.datetime.fold` são consideradas iguais nas "
"comparações."

#: ../../library/datetime.rst:2344
msgid ""
"Applications that can't bear wall-time ambiguities should explicitly check "
"the value of the :attr:`~.datetime.fold` attribute or avoid using hybrid :"
"class:`tzinfo` subclasses; there are no ambiguities when using :class:"
"`timezone`, or any other fixed-offset :class:`tzinfo` subclass (such as a "
"class representing only EST (fixed offset -5 hours), or only EDT (fixed "
"offset -4 hours))."
msgstr ""
"Aplicações que não suportam ambiguidades de tempo devem verificar "
"explicitamente o valor do atributo :attr:`~.datetime.fold` ou evitar "
"utilizar subclasses híbridas :class:`tzinfo`; não há ambiguidades ao usar :"
"class:`timezone` ou qualquer outra subclasse :class:`tzinfo` de deslocamento "
"fixo (como uma classe que representa apenas EST (deslocamento fixo de -5 "
"horas) ou apenas EDT (deslocamento fixo de -4 horas))."

#: ../../library/datetime.rst:2352
msgid ":mod:`zoneinfo`"
msgstr ":mod:`zoneinfo`"

#: ../../library/datetime.rst:2353
msgid ""
"The :mod:`!datetime` module has a basic :class:`timezone` class (for "
"handling arbitrary fixed offsets from UTC) and its :attr:`timezone.utc` "
"attribute (a UTC :class:`!timezone` instance)."
msgstr ""
"O módulo :mod:`!datetime` possui uma classe básica :class:`timezone` (para "
"lidar com deslocamentos fixos arbitrários do UTC) e seu atributo :attr:"
"`timezone.utc` (uma instância UTC :class:`!timezone` )."

#: ../../library/datetime.rst:2357
msgid ""
"``zoneinfo`` brings the *IANA time zone database* (also known as the Olson "
"database) to Python, and its usage is recommended."
msgstr ""
"``zoneinfo`` traz o *banco de dados de fuso horário IANA* (também conhecido "
"como banco de dados Olson) para Python, e seu uso é recomendado."

#: ../../library/datetime.rst:2360
msgid "`IANA time zone database <https://www.iana.org/time-zones>`_"
msgstr ""
"`Banco de dados de fuso horário da IANA <https://www.iana.org/time-zones>`_"

#: ../../library/datetime.rst:2361
msgid ""
"The Time Zone Database (often called tz, tzdata or zoneinfo) contains code "
"and data that represent the history of local time for many representative "
"locations around the globe. It is updated periodically to reflect changes "
"made by political bodies to time zone boundaries, UTC offsets, and daylight-"
"saving rules."
msgstr ""
"O banco de dados de fuso horário (comumente chamado de tz, tzdata ou "
"zoneinfo) contém código e dados que representam o histórico de hora local "
"para muitas localizações representativas ao redor do globo. Ele é atualizado "
"periodicamente para refletir mudanças feitas por corpos políticos para "
"limites de fuso horário, diferenças UTC, e regras de horário de verão."

#: ../../library/datetime.rst:2371
msgid ":class:`timezone` Objects"
msgstr "Objetos :class:`timezone`"

#: ../../library/datetime.rst:2373
msgid ""
"The :class:`timezone` class is a subclass of :class:`tzinfo`, each instance "
"of which represents a time zone defined by a fixed offset from UTC."
msgstr ""
"A classe :class:`timezone` é uma subclasse de :class:`tzinfo`, cada "
"instância da qual representa um fuso horário definido por um deslocamento "
"fixo do UTC."

#: ../../library/datetime.rst:2377
msgid ""
"Objects of this class cannot be used to represent time zone information in "
"the locations where different offsets are used in different days of the year "
"or where historical changes have been made to civil time."
msgstr ""
"Objetos desta classe não podem ser usados para representar informações de "
"fuso horário em locais onde diferentes deslocamentos são usados em "
"diferentes dias do ano ou onde mudanças históricas foram feitas no horário "
"civil."

#: ../../library/datetime.rst:2384
msgid ""
"The *offset* argument must be specified as a :class:`timedelta` object "
"representing the difference between the local time and UTC. It must be "
"strictly between ``-timedelta(hours=24)`` and ``timedelta(hours=24)``, "
"otherwise :exc:`ValueError` is raised."
msgstr ""
"O argumento *offset* deve ser especificado como um objeto :class:`timedelta` "
"representando a diferença entre o tempo local e o UTC. Ele deve estar "
"estritamente entre ``-timedelta(hours=24)`` e ``timedelta(hous=24)``, caso "
"contrário a exceção :exc:`ValueError` será provocada."

#: ../../library/datetime.rst:2389
msgid ""
"The *name* argument is optional. If specified it must be a string that will "
"be used as the value returned by the :meth:`datetime.tzname` method."
msgstr ""
"O argumento *name* é opcional. Se especificado, deve ser uma string que será "
"usada como o valor retornado pelo método :meth:`datetime.tzname`."

#: ../../library/datetime.rst:2400 ../../library/datetime.rst:2411
msgid ""
"Return the fixed value specified when the :class:`timezone` instance is "
"constructed."
msgstr ""
"Retorna o valor fixo especificado quando a instância :class:`timezone` é "
"construída."

#: ../../library/datetime.rst:2403
msgid ""
"The *dt* argument is ignored. The return value is a :class:`timedelta` "
"instance equal to the difference between the local time and UTC."
msgstr ""
"O argumento *dt* é ignorado. O valor de retorno é uma instância :class:"
"`timedelta` equivalente à diferença entre o tempo local e o UTC."

#: ../../library/datetime.rst:2414
msgid ""
"If *name* is not provided in the constructor, the name returned by "
"``tzname(dt)`` is generated from the value of the ``offset`` as follows. If "
"*offset* is ``timedelta(0)``, the name is \"UTC\", otherwise it is a string "
"in the format ``UTC±HH:MM``, where ± is the sign of ``offset``, HH and MM "
"are two digits of ``offset.hours`` and ``offset.minutes`` respectively."
msgstr ""
"Se *name* não é passado ao construtor, o nome retornado por ``tzname(dt)`` é "
"gerado a partir do valor de ``offset`` do seguinte modo: Se *offset* é "
"``timedelta(0)``, o nome é \"UTC\", caso contrário é uma string no formato "
"``UTC±HH:MM``, na qual ± é o sinal do ``offset``, HH e MM são dois dígitos "
"de ``offset.hours`` e ``offset.minutes`` respectivamente."

#: ../../library/datetime.rst:2420
msgid ""
"Name generated from ``offset=timedelta(0)`` is now plain ``'UTC'``, not "
"``'UTC+00:00'``."
msgstr ""
"Nome gerado de ``offset=timedelta(0)`` é agora simplesmente ``'UTC'``, não "
"``'UTC+00:00'``."

#: ../../library/datetime.rst:2427
msgid "Always returns ``None``."
msgstr "Sempre retorna ``None``."

#: ../../library/datetime.rst:2431
msgid ""
"Return ``dt + offset``. The *dt* argument must be an aware :class:`."
"datetime` instance, with ``tzinfo`` set to ``self``."
msgstr ""
"Retorna ``dt + offset``. O argumento *dt* deve ser uma instância :class:`."
"datetime` consciente, com ``tzinfo`` definida para ``self``."

#: ../../library/datetime.rst:2438
msgid "The UTC time zone, ``timezone(timedelta(0))``."
msgstr "O fuso horário UTC, ``timezone(timedelta(0))``."

#: ../../library/datetime.rst:2447
msgid ":meth:`~.datetime.strftime` and :meth:`~.datetime.strptime` Behavior"
msgstr ""
"Comportamento de :meth:`~.datetime.strftime` e :meth:`~.datetime.strptime`"

#: ../../library/datetime.rst:2449
msgid ""
":class:`date`, :class:`.datetime`, and :class:`.time` objects all support a "
"``strftime(format)`` method, to create a string representing the time under "
"the control of an explicit format string."
msgstr ""
"Todos os objetos :class:`date`, :class:`.datetime` e :class:`.time` dão "
"suporte ao método ``strftime(format)``, para criar uma string representando "
"o tempo sob o controle de uma string de formatação explícita."

#: ../../library/datetime.rst:2453
msgid ""
"Conversely, the :meth:`date.strptime`, :meth:`datetime.strptime` and :meth:"
"`time.strptime` class methods create an object from a string representing "
"the time and a corresponding format string."
msgstr ""
"Em recíproca, os métodos de classe :meth:`date.strptime`, :meth:`datetime."
"strptime` e :meth:`time.strptime` criam um objeto a partir de uma string "
"representando o tempo e uma string de formatação correspondente."

#: ../../library/datetime.rst:2457
msgid ""
"The table below provides a high-level comparison of :meth:`~.datetime."
"strftime` versus :meth:`~.datetime.strptime`:"
msgstr ""
"A tabela abaixo fornece uma comparação de alto nível entre :meth:`~.datetime."
"strftime` e :meth:`~.datetime.strptime`:"

#: ../../library/datetime.rst:2461
msgid "``strftime``"
msgstr "``strftime``"

#: ../../library/datetime.rst:2461
msgid "``strptime``"
msgstr "``strptime``"

#: ../../library/datetime.rst:2463
msgid "Usage"
msgstr "Uso"

#: ../../library/datetime.rst:2463
msgid "Convert object to a string according to a given format"
msgstr "Converte objeto para uma string conforme um formato fornecido"

#: ../../library/datetime.rst:2463
msgid "Parse a string into an object given a corresponding format"
msgstr "Interpreta uma string como um objeto dado um formato correspondente"

#: ../../library/datetime.rst:2465
msgid "Type of method"
msgstr "Tipo de método"

#: ../../library/datetime.rst:2465
msgid "Instance method"
msgstr "Método de instância"

#: ../../library/datetime.rst:2465
msgid "Class method"
msgstr "Método de classe"

#: ../../library/datetime.rst:2467
msgid "Signature"
msgstr "Assinatura"

#: ../../library/datetime.rst:2467
msgid "``strftime(format)``"
msgstr "``strftime(format)``"

#: ../../library/datetime.rst:2467
msgid "``strptime(date_string, format)``"
msgstr "``strptime(date_string, format)``"

#: ../../library/datetime.rst:2474
msgid ""
":meth:`~.datetime.strftime` and :meth:`~.datetime.strptime` Format Codes"
msgstr ""
"Códigos de formato :meth:`~.datetime.strftime` e :meth:`~.datetime.strptime`"

#: ../../library/datetime.rst:2476
msgid ""
"These methods accept format codes that can be used to parse and format "
"dates::"
msgstr ""
"Esses métodos aceitam códigos de formato que podem ser usados para analisar "
"e formatar datas::"

#: ../../library/datetime.rst:2478
msgid ""
">>> datetime.strptime('31/01/22 23:59:59.999999',\n"
"...                   '%d/%m/%y %H:%M:%S.%f')\n"
"datetime.datetime(2022, 1, 31, 23, 59, 59, 999999)\n"
">>> _.strftime('%a %d %b %Y, %I:%M%p')\n"
"'Mon 31 Jan 2022, 11:59PM'"
msgstr ""
">>> datetime.strptime('31/01/22 23:59:59.999999',\n"
"...                   '%d/%m/%y %H:%M:%S.%f')\n"
"datetime.datetime(2022, 1, 31, 23, 59, 59, 999999)\n"
">>> _.strftime('%a %d %b %Y, %I:%M%p')\n"
"'Mon 31 Jan 2022, 11:59PM'"

#: ../../library/datetime.rst:2484
msgid ""
"The following is a list of all the format codes that the 1989 C standard "
"requires, and these work on all platforms with a standard C implementation."
msgstr ""
"A seguir é exibida uma lista de todos os códigos de formatação que o padrão "
"C de 1989 requer, e eles funcionam em todas as plataformas com implementação "
"padrão C."

#: ../../library/datetime.rst:2488 ../../library/datetime.rst:2591
msgid "Directive"
msgstr "Diretiva"

#: ../../library/datetime.rst:2488 ../../library/datetime.rst:2591
msgid "Meaning"
msgstr "Significado"

#: ../../library/datetime.rst:2488 ../../library/datetime.rst:2591
msgid "Example"
msgstr "Exemplo"

#: ../../library/datetime.rst:2488 ../../library/datetime.rst:2591
msgid "Notes"
msgstr "Notas"

#: ../../library/datetime.rst:2490
msgid "``%a``"
msgstr "``%a``"

#: ../../library/datetime.rst:2490
msgid "Weekday as locale's abbreviated name."
msgstr "Dias da semana como nomes abreviados da localidade."

#: ../../library/datetime.rst:0
msgid "Sun, Mon, ..., Sat (en_US);"
msgstr "Sun, Mon, ..., Sat (en_US);"

#: ../../library/datetime.rst:0
msgid "So, Mo, ..., Sa (de_DE)"
msgstr "So, Mo, ..., Sa (de_DE)"

#: ../../library/datetime.rst:2495
msgid "``%A``"
msgstr "``%A``"

#: ../../library/datetime.rst:2495
msgid "Weekday as locale's full name."
msgstr "Dia da semana como nome completo da localidade."

#: ../../library/datetime.rst:0
msgid "Sunday, Monday, ..., Saturday (en_US);"
msgstr "Sunday, Monday, ..., Saturday (en_US);"

#: ../../library/datetime.rst:0
msgid "Sonntag, Montag, ..., Samstag (de_DE)"
msgstr "Sonntag, Montag, ..., Samstag (de_DE)"

#: ../../library/datetime.rst:2500
msgid "``%w``"
msgstr "``%w``"

#: ../../library/datetime.rst:2500
msgid "Weekday as a decimal number, where 0 is Sunday and 6 is Saturday."
msgstr "Dia da semana como um número decimal, onde 0 é domingo e 6 é sábado."

#: ../../library/datetime.rst:2500
msgid "0, 1, ..., 6"
msgstr "0, 1, ..., 6"

#: ../../library/datetime.rst:2504
msgid "``%d``"
msgstr "``%d``"

#: ../../library/datetime.rst:2504
msgid "Day of the month as a zero-padded decimal number."
msgstr "Dia do mês como um número decimal com zeros a esquerda."

#: ../../library/datetime.rst:2504
msgid "01, 02, ..., 31"
msgstr "01, 02, ..., 31"

#: ../../library/datetime.rst:2504 ../../library/datetime.rst:2517
#: ../../library/datetime.rst:2520 ../../library/datetime.rst:2526
#: ../../library/datetime.rst:2529 ../../library/datetime.rst:2535
#: ../../library/datetime.rst:2553
msgid "\\(9)"
msgstr "\\(9)"

#: ../../library/datetime.rst:2507
msgid "``%b``"
msgstr "``%b``"

#: ../../library/datetime.rst:2507
msgid "Month as locale's abbreviated name."
msgstr "Mês como nome da localidade abreviado."

#: ../../library/datetime.rst:0
msgid "Jan, Feb, ..., Dec (en_US);"
msgstr "Jan, Feb, ..., Dec (en_US);"

#: ../../library/datetime.rst:0
msgid "Jan, Feb, ..., Dez (de_DE)"
msgstr "Jan, Feb, ..., Dez (de_DE)"

#: ../../library/datetime.rst:2512
msgid "``%B``"
msgstr "``%B``"

#: ../../library/datetime.rst:2512
msgid "Month as locale's full name."
msgstr "Mês como nome completo da localidade."

#: ../../library/datetime.rst:0
msgid "January, February, ..., December (en_US);"
msgstr "January, February, ..., December (en_US);"

#: ../../library/datetime.rst:0
msgid "Januar, Februar, ..., Dezember (de_DE)"
msgstr "janeiro, fevereiro, ..., dezembro (pt_BR)"

#: ../../library/datetime.rst:2517
msgid "``%m``"
msgstr "``%m``"

#: ../../library/datetime.rst:2517
msgid "Month as a zero-padded decimal number."
msgstr "Mês como um número decimal com zeros a esquerda."

#: ../../library/datetime.rst:2517 ../../library/datetime.rst:2529
msgid "01, 02, ..., 12"
msgstr "01, 02, ..., 12"

#: ../../library/datetime.rst:2520
msgid "``%y``"
msgstr "``%y``"

#: ../../library/datetime.rst:2520
msgid "Year without century as a zero-padded decimal number."
msgstr "Ano sem século como um número decimal com zeros a esquerda."

#: ../../library/datetime.rst:2520
msgid "00, 01, ..., 99"
msgstr "00, 01, ..., 99"

#: ../../library/datetime.rst:2523
msgid "``%Y``"
msgstr "``%Y``"

#: ../../library/datetime.rst:2523
msgid "Year with century as a decimal number."
msgstr "Ano com século como um número decimal."

#: ../../library/datetime.rst:2523 ../../library/datetime.rst:2593
msgid "0001, 0002, ..., 2013, 2014, ..., 9998, 9999"
msgstr "0001, 0002, ..., 2013, 2014, ..., 9998, 9999"

#: ../../library/datetime.rst:2526
msgid "``%H``"
msgstr "``%H``"

#: ../../library/datetime.rst:2526
msgid "Hour (24-hour clock) as a zero-padded decimal number."
msgstr ""
"Hora (relógio de 24 horas) como um número decimal com zeros a esquerda."

#: ../../library/datetime.rst:2526
msgid "00, 01, ..., 23"
msgstr "00, 01, ..., 23"

#: ../../library/datetime.rst:2529
msgid "``%I``"
msgstr "``%I``"

#: ../../library/datetime.rst:2529
msgid "Hour (12-hour clock) as a zero-padded decimal number."
msgstr ""
"Hora (relógio de 12 horas) como um número decimal com zeros a esquerda."

#: ../../library/datetime.rst:2532
msgid "``%p``"
msgstr "``%p``"

#: ../../library/datetime.rst:2532
msgid "Locale's equivalent of either AM or PM."
msgstr "Equivalente da localidade a AM ou PM."

#: ../../library/datetime.rst:0
msgid "AM, PM (en_US);"
msgstr "AM, PM (en_US);"

#: ../../library/datetime.rst:0
msgid "am, pm (de_DE)"
msgstr "am, pm (de_DE)"

#: ../../library/datetime.rst:2532
msgid "\\(1), \\(3)"
msgstr "\\(1), \\(3)"

#: ../../library/datetime.rst:2535
msgid "``%M``"
msgstr "``%M``"

#: ../../library/datetime.rst:2535
msgid "Minute as a zero-padded decimal number."
msgstr "Minutos como um número decimal, com zeros a esquerda."

#: ../../library/datetime.rst:2535 ../../library/datetime.rst:2538
msgid "00, 01, ..., 59"
msgstr "00, 01, ..., 59"

#: ../../library/datetime.rst:2538
msgid "``%S``"
msgstr "``%S``"

#: ../../library/datetime.rst:2538
msgid "Second as a zero-padded decimal number."
msgstr "Segundos como um número decimal, com zeros a esquerda."

#: ../../library/datetime.rst:2538
msgid "\\(4), \\(9)"
msgstr "\\(4), \\(9)"

#: ../../library/datetime.rst:2541
msgid "``%f``"
msgstr "``%f``"

#: ../../library/datetime.rst:2541
msgid "Microsecond as a decimal number, zero-padded to 6 digits."
msgstr ""
"Microssegundos como um número decimal, com zeros à esquerda até completar 6 "
"dígitos."

#: ../../library/datetime.rst:2541
msgid "000000, 000001, ..., 999999"
msgstr "000000, 000001, ..., 999999"

#: ../../library/datetime.rst:2541
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/datetime.rst:2545 ../../library/datetime.rst:2704
msgid "``%z``"
msgstr "``%z``"

#: ../../library/datetime.rst:2545
msgid ""
"UTC offset in the form ``±HHMM[SS[.ffffff]]`` (empty string if the object is "
"naive)."
msgstr ""
"Diferença UTC no formato ``±HHMM[SS[.ffffff]]`` (string vazia se o objeto é "
"ingênuo)."

#: ../../library/datetime.rst:2545
msgid "(empty), +0000, -0400, +1030, +063415, -030712.345216"
msgstr "(vazio), +0000, -0400, +1030, +063415, -030712.345216"

#: ../../library/datetime.rst:2545 ../../library/datetime.rst:2550
#: ../../library/datetime.rst:2607
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/datetime.rst:2550 ../../library/datetime.rst:2730
msgid "``%Z``"
msgstr "``%Z``"

#: ../../library/datetime.rst:2550
msgid "Time zone name (empty string if the object is naive)."
msgstr "Nome do fuso horário (string vazia se o objeto é ingênuo)."

#: ../../library/datetime.rst:2550
msgid "(empty), UTC, GMT"
msgstr "(vazio), UTC, GMT"

#: ../../library/datetime.rst:2553
msgid "``%j``"
msgstr "``%j``"

#: ../../library/datetime.rst:2553
msgid "Day of the year as a zero-padded decimal number."
msgstr "Dia do ano como um número decimal, com zeros a esquerda."

#: ../../library/datetime.rst:2553
msgid "001, 002, ..., 366"
msgstr "001, 002, ..., 366"

#: ../../library/datetime.rst:2556
msgid "``%U``"
msgstr "``%U``"

#: ../../library/datetime.rst:2556
msgid ""
"Week number of the year (Sunday as the first day of the week) as a zero-"
"padded decimal number. All days in a new year preceding the first Sunday are "
"considered to be in week 0."
msgstr ""
"Número da semana do ano (Domingo como o primeiro dia da semana) como um "
"número decimal, com zeros a esquerda. Todos os dias em um ano novo "
"precedendo o primeiro domingo são considerados como estando na semana 0."

#: ../../library/datetime.rst:2556 ../../library/datetime.rst:2564
msgid "00, 01, ..., 53"
msgstr "00, 01, ..., 53"

#: ../../library/datetime.rst:2556 ../../library/datetime.rst:2564
msgid "\\(7), \\(9)"
msgstr "\\(7), \\(9)"

#: ../../library/datetime.rst:2564
msgid "``%W``"
msgstr "``%W``"

#: ../../library/datetime.rst:2564
msgid ""
"Week number of the year (Monday as the first day of the week) as a zero-"
"padded decimal number. All days in a new year preceding the first Monday are "
"considered to be in week 0."
msgstr ""
"Número da semana do ano (Segunda-feira como o primeiro dia da semana) como "
"um número decimal, com zeros a esquerda. Todos os dias em um ano novo "
"precedendo a primeira segunda-feira são considerados como estando na semana "
"0."

#: ../../library/datetime.rst:2572
msgid "``%c``"
msgstr "``%c``"

#: ../../library/datetime.rst:2572
msgid "Locale's appropriate date and time representation."
msgstr "Representação de data e hora apropriada da localidade."

#: ../../library/datetime.rst:0
msgid "Tue Aug 16 21:30:00 1988 (en_US);"
msgstr "Tue Aug 16 21:30:00 1988 (en_US);"

#: ../../library/datetime.rst:0
msgid "Di 16 Aug 21:30:00 1988 (de_DE)"
msgstr "Di 16 Aug 21:30:00 1988 (de_DE)"

#: ../../library/datetime.rst:2577
msgid "``%x``"
msgstr "``%x``"

#: ../../library/datetime.rst:2577
msgid "Locale's appropriate date representation."
msgstr "Representação de data apropriada de localidade."

#: ../../library/datetime.rst:0
msgid "08/16/88 (None);"
msgstr "08/16/88 (None);"

#: ../../library/datetime.rst:0
msgid "08/16/1988 (en_US);"
msgstr "08/16/1988 (en_US);"

#: ../../library/datetime.rst:0
msgid "16.08.1988 (de_DE)"
msgstr "16.08.1988 (de_DE)"

#: ../../library/datetime.rst:2581
msgid "``%X``"
msgstr "``%X``"

#: ../../library/datetime.rst:2581
msgid "Locale's appropriate time representation."
msgstr "Representação de hora apropriada da localidade."

#: ../../library/datetime.rst:0
msgid "21:30:00 (en_US);"
msgstr "21:30:00 (en_US);"

#: ../../library/datetime.rst:0
msgid "21:30:00 (de_DE)"
msgstr "21:30:00 (de_DE)"

#: ../../library/datetime.rst:2584
msgid "``%%``"
msgstr "``%%``"

#: ../../library/datetime.rst:2584
msgid "A literal ``'%'`` character."
msgstr "Um caractere literal ``'%'``."

#: ../../library/datetime.rst:2584
msgid "%"
msgstr "%"

#: ../../library/datetime.rst:2587
msgid ""
"Several additional directives not required by the C89 standard are included "
"for convenience. These parameters all correspond to ISO 8601 date values."
msgstr ""
"Diversas diretivas adicionais não necessárias pelo padrão C89 são incluídas "
"para conveniência. Estes parâmetros todos correspondem a valores de datas na "
"ISO 8601."

#: ../../library/datetime.rst:2593
msgid "``%G``"
msgstr "``%G``"

#: ../../library/datetime.rst:2593
msgid ""
"ISO 8601 year with century representing the year that contains the greater "
"part of the ISO week (``%V``)."
msgstr ""
"Ano ISO 8601 com o século representando o ano que a maior parte da semana "
"ISO (``%V``)."

#: ../../library/datetime.rst:2593
msgid "\\(8)"
msgstr "\\(8)"

#: ../../library/datetime.rst:2598
msgid "``%u``"
msgstr "``%u``"

#: ../../library/datetime.rst:2598
msgid "ISO 8601 weekday as a decimal number where 1 is Monday."
msgstr "Dia de semana ISO 8601 como um número decimal onde 1 é segunda-feira."

#: ../../library/datetime.rst:2598
msgid "1, 2, ..., 7"
msgstr "1, 2, ..., 7"

#: ../../library/datetime.rst:2601
msgid "``%V``"
msgstr "``%V``"

#: ../../library/datetime.rst:2601
msgid ""
"ISO 8601 week as a decimal number with Monday as the first day of the week. "
"Week 01 is the week containing Jan 4."
msgstr ""
"Semana ISO 8601 como um número decimal, com segunda-feira como o primeiro "
"dia da semana. A semana 01 é a semana contendo o dia 4 de Janeiro."

#: ../../library/datetime.rst:2601
msgid "01, 02, ..., 53"
msgstr "01, 02, ..., 53"

#: ../../library/datetime.rst:2601
msgid "\\(8), \\(9)"
msgstr "\\(8), \\(9)"

#: ../../library/datetime.rst:2607 ../../library/datetime.rst:2726
msgid "``%:z``"
msgstr "``%:z``"

#: ../../library/datetime.rst:2607
msgid ""
"UTC offset in the form ``±HH:MM[:SS[.ffffff]]`` (empty string if the object "
"is naive)."
msgstr ""
"Diferença UTC no formato ``±HH:MM[:SS[.ffffff]]`` (string vazia se o objeto "
"é ingênuo)."

#: ../../library/datetime.rst:2607
msgid "(empty), +00:00, -04:00, +10:30, +06:34:15, -03:07:12.345216"
msgstr "(vazio), +00:00, -04:00, +10:30, +06:34:15, -03:07:12.345216"

#: ../../library/datetime.rst:2613
msgid ""
"These may not be available on all platforms when used with the :meth:`~."
"datetime.strftime` method. The ISO 8601 year and ISO 8601 week directives "
"are not interchangeable with the year and week number directives above. "
"Calling :meth:`~.datetime.strptime` with incomplete or ambiguous ISO 8601 "
"directives will raise a :exc:`ValueError`."
msgstr ""
"Eles podem não estar disponíveis em todas as plataformas quando usados com o "
"método :meth:`~.datetime.strftime`. As diretivas de ano e semana da ISO 8601 "
"e ISO 8601 não são intercambiáveis com as diretivas ano e número da semana "
"acima. Chamar :meth:`~.datetime.strptime` com diretivas ISO 8601 incompletas "
"ou ambíguas levantará um :exc:`ValueError`."

#: ../../library/datetime.rst:2618
msgid ""
"The full set of format codes supported varies across platforms, because "
"Python calls the platform C library's :c:func:`strftime` function, and "
"platform variations are common. To see the full set of format codes "
"supported on your platform, consult the :manpage:`strftime(3)` "
"documentation. There are also differences between platforms in handling of "
"unsupported format specifiers."
msgstr ""
"O conjunto completo de códigos de formato suportados varia entre as "
"plataformas, porque o Python chama a função :c:func:`strftime` da biblioteca "
"C da plataforma, e variações de plataforma são comuns. Para ver o conjunto "
"completo de códigos de formato suportados em sua plataforma, consulte a "
"documentação :manpage:`strftime(3)`. Também existem diferenças entre "
"plataformas no tratamento de especificadores de formato não suportados."

#: ../../library/datetime.rst:2624
msgid "``%G``, ``%u`` and ``%V`` were added."
msgstr "``%G``, ``%u`` e ``%V`` foram adicionados."

#: ../../library/datetime.rst:2627
msgid "``%:z`` was added."
msgstr "``%:z`` foi adicionado."

#: ../../library/datetime.rst:2631
msgid "Technical Detail"
msgstr "Detalhes técnicos"

#: ../../library/datetime.rst:2633
msgid ""
"Broadly speaking, ``d.strftime(fmt)`` acts like the :mod:`time` module's "
"``time.strftime(fmt, d.timetuple())`` although not all objects support a :"
"meth:`~date.timetuple` method."
msgstr ""
"Em termos gerais, ``d.strftime(fmt)`` age como ``time.strftime(fmt, d."
"timetuple())`` do módulo :mod:`time`, embora nem todos os objetos suportem "
"um método :meth:`~date.timetuple`."

#: ../../library/datetime.rst:2637
msgid ""
"For the :meth:`.datetime.strptime` class method, the default value is "
"``1900-01-01T00:00:00.000``: any components not specified in the format "
"string will be pulled from the default value. [#]_"
msgstr ""
"Para o método de classe :meth:`.datetime.strptime`, o valor padrão é "
"``1900-01-01T00:00:00.000``: quaisquer componentes não especificados na "
"string de formato serão extraídos do valor padrão. [#]_"

#: ../../library/datetime.rst:2641
msgid "Using ``datetime.strptime(date_string, format)`` is equivalent to::"
msgstr "Usar ``datetime.strptime(date_string, format)`` é equivalente a::"

#: ../../library/datetime.rst:2645
msgid ""
"except when the format includes sub-second components or time zone offset "
"information, which are supported in ``datetime.strptime`` but are discarded "
"by ``time.strptime``."
msgstr ""
"exceto quando o formato inclui componentes de sub-segundos ou informações de "
"deslocamento de fuso horário, que são suportados em ``datetime.strptime`` "
"mas são descartados por ``time.strptime``."

#: ../../library/datetime.rst:2649
msgid ""
"For :class:`.time` objects, the format codes for year, month, and day should "
"not be used, as :class:`!time` objects have no such values. If they're used "
"anyway, 1900 is substituted for the year, and 1 for the month and day."
msgstr ""
"Para objetos :class:`.time`, os códigos de formato para ano, mês e dia não "
"devem ser usados, pois objetos :class:`!time` não têm tais valores. Se forem "
"usados de qualquer forma, o ano é substituído por 1900, e o mês e dia por 1."

#: ../../library/datetime.rst:2653
msgid ""
"For :class:`date` objects, the format codes for hours, minutes, seconds, and "
"microseconds should not be used, as :class:`date` objects have no such "
"values. If they're used anyway, 0 is substituted for them."
msgstr ""
"Para objetos :class:`date`, os códigos de formato para horas, minutos, "
"segundos e microssegundos não devem ser usados, pois objetos :class:`date` "
"não têm tais valores. Se forem usados de qualquer forma, são substituídos "
"por 0."

#: ../../library/datetime.rst:2657
msgid ""
"For the same reason, handling of format strings containing Unicode code "
"points that can't be represented in the charset of the current locale is "
"also platform-dependent. On some platforms such code points are preserved "
"intact in the output, while on others ``strftime`` may raise :exc:"
"`UnicodeError` or return an empty string instead."
msgstr ""
"Pela mesma razão, o tratamento de formato de strings contendo pontos de "
"código Unicode que não podem ser representados no conjunto de caracteres da "
"localidade atual também é dependente da plataforma. Em algumas plataformas, "
"tais pontos de código são preservados intactos na saída, enquanto em outros "
"``strftime`` pode levantar :exc:`UnicodeError` ou retornar uma string vazia "
"ao invés."

#: ../../library/datetime.rst:2666
msgid ""
"Because the format depends on the current locale, care should be taken when "
"making assumptions about the output value. Field orderings will vary (for "
"example, \"month/day/year\" versus \"day/month/year\"), and the output may "
"contain non-ASCII characters."
msgstr ""
"Como o formato depende da localidade atual, deve-se tomar cuidado ao fazer "
"suposições sobre o valor de saída. A ordenação dos campos irá variar (por "
"exemplo, \"mês/dia/ano\" versus \"dia/mês/ano\") e a saída pode conter "
"caracteres não ASCII."

#: ../../library/datetime.rst:2672
msgid ""
"The :meth:`~.datetime.strptime` method can parse years in the full [1, 9999] "
"range, but years < 1000 must be zero-filled to 4-digit width."
msgstr ""
"O método :meth:`~.datetime.strptime` pode analisar anos no intervalo "
"completo de [1, 9999], mas anos < 1000 devem ser preenchidos com zeros até "
"uma largura de 4 dígitos."

#: ../../library/datetime.rst:2675
msgid ""
"In previous versions, :meth:`~.datetime.strftime` method was restricted to "
"years >= 1900."
msgstr ""
"Em versões anteriores, o método :meth:`~.datetime.strftime` era limitado a "
"anos >= 1900."

#: ../../library/datetime.rst:2679
msgid ""
"In version 3.2, :meth:`~.datetime.strftime` method was restricted to years "
">= 1000."
msgstr ""
"Na versão 3.2, o método :meth:`~.datetime.strftime` era limitado a anos >= "
"1000."

#: ../../library/datetime.rst:2684
msgid ""
"When used with the :meth:`~.datetime.strptime` method, the ``%p`` directive "
"only affects the output hour field if the ``%I`` directive is used to parse "
"the hour."
msgstr ""
"Quando usado com o método :meth:`~.datetime.strptime`, a diretiva ``%p`` "
"afeta somente o campo de hora de saída se a diretiva ``%I`` for usada para "
"analisar a hora."

#: ../../library/datetime.rst:2688
msgid ""
"Unlike the :mod:`time` module, the :mod:`!datetime` module does not support "
"leap seconds."
msgstr ""
"Ao contrário do módulo :mod:`time`, o módulo :mod:`!datetime` não oferece "
"suporte para segundos intercalares."

#: ../../library/datetime.rst:2692
msgid ""
"When used with the :meth:`~.datetime.strptime` method, the ``%f`` directive "
"accepts from one to six digits and zero pads on the right. ``%f`` is an "
"extension to the set of format characters in the C standard (but implemented "
"separately in datetime objects, and therefore always available)."
msgstr ""
"Quando usado com o método :meth:`~.datetime.strptime`, a diretiva ``%f`` "
"aceita de um a seis dígitos e zeros à direita. ``%f`` é uma extensão do "
"conjunto de caracteres de formato no padrão do C (mas implementado "
"separadamente em objetos datetime e, portanto, sempre disponível)."

#: ../../library/datetime.rst:2699
msgid ""
"For a naive object, the ``%z``, ``%:z`` and ``%Z`` format codes are replaced "
"by empty strings."
msgstr ""
"Para um objeto ingênuo, os códigos de formatação ``%z``, ``%:z`` e ``%Z`` "
"são substituídos por strings vazias."

#: ../../library/datetime.rst:2702
msgid "For an aware object:"
msgstr "Para um objeto consciente:"

#: ../../library/datetime.rst:2705
msgid ""
":meth:`~.datetime.utcoffset` is transformed into a string of the form "
"``±HHMM[SS[.ffffff]]``, where ``HH`` is a 2-digit string giving the number "
"of UTC offset hours, ``MM`` is a 2-digit string giving the number of UTC "
"offset minutes, ``SS`` is a 2-digit string giving the number of UTC offset "
"seconds and ``ffffff`` is a 6-digit string giving the number of UTC offset "
"microseconds. The ``ffffff`` part is omitted when the offset is a whole "
"number of seconds and both the ``ffffff`` and the ``SS`` part is omitted "
"when the offset is a whole number of minutes. For example, if :meth:`~."
"datetime.utcoffset` returns ``timedelta(hours=-3, minutes=-30)``, ``%z`` is "
"replaced with the string ``'-0330'``."
msgstr ""
":meth:`~.datetime.utcoffset` é transformado em uma string do formato "
"``±HHMM[SS[.ffffff]]``, onde ``HH`` é uma string de 2 dígitos que fornece o "
"número de horas de deslocamento UTC, ``MM`` é uma string de 2 dígitos que "
"fornece o número de minutos de deslocamento UTC, ``SS`` é uma string de 2 "
"dígitos que fornece o número de segundos de deslocamento UTC e ``ffffff`` é "
"uma string de 6 dígitos que fornece o número de microssegundos de "
"deslocamento UTC. A parte ``ffffff`` é omitida quando o deslocamento é um "
"número inteiro de segundos e tanto a parte ``ffffff`` quanto a parte ``SS`` "
"são omitidas quando o deslocamento é um número inteiro de minutos. Por "
"exemplo, se :meth:`~.datetime.utcoffset` retornar ``timedelta(hours=-3, "
"minutes=-30)``, ``%z`` será substituído pela string ``'-0330'``."

#: ../../library/datetime.rst:2719
msgid ""
"When the ``%z`` directive is provided to the  :meth:`~.datetime.strptime` "
"method, the UTC offsets can have a colon as a separator between hours, "
"minutes and seconds. For example, ``'+01:00:00'`` will be parsed as an "
"offset of one hour. In addition, providing ``'Z'`` is identical to "
"``'+00:00'``."
msgstr ""
"Quando a diretiva ``%z`` é fornecida ao método :meth:`~.datetime.strptime`, "
"os deslocamentos UTC podem ter dois pontos como separador entre horas, "
"minutos e segundos. Por exemplo, ``'+01:00:00'`` será analisado como um "
"deslocamento de uma hora. Além disso, fornecer ``'Z'`` é idêntico a "
"``'+00:00'``."

#: ../../library/datetime.rst:2727
msgid ""
"Behaves exactly as ``%z``, but has a colon separator added between hours, "
"minutes and seconds."
msgstr ""
"Comporta-se exatamente como ``%z``, mas possui um separador de dois pontos "
"adicionado entre horas, minutos e segundos."

#: ../../library/datetime.rst:2731
msgid ""
"In :meth:`~.datetime.strftime`, ``%Z`` is replaced by an empty string if :"
"meth:`~.datetime.tzname` returns ``None``; otherwise ``%Z`` is replaced by "
"the returned value, which must be a string."
msgstr ""
"Em :meth:`~.datetime.strftime`, ``%Z`` é substituído por uma string vazia "
"se :meth:`~.datetime.tzname` retornar ``None``; caso contrário, ``%Z`` é "
"substituído pelo valor retornado, que deve ser uma string."

#: ../../library/datetime.rst:2735
msgid ":meth:`~.datetime.strptime` only accepts certain values for ``%Z``:"
msgstr ":meth:`~.datetime.strptime` aceita apenas certos valores para ``%Z``:"

#: ../../library/datetime.rst:2737
msgid "any value in ``time.tzname`` for your machine's locale"
msgstr "qualquer valor em ``time.tzname`` para a localidade da sua máquina"

#: ../../library/datetime.rst:2738
msgid "the hard-coded values ``UTC`` and ``GMT``"
msgstr "os valores codificados ``UTC`` e ``GMT``"

#: ../../library/datetime.rst:2740
msgid ""
"So someone living in Japan may have ``JST``, ``UTC``, and ``GMT`` as valid "
"values, but probably not ``EST``. It will raise ``ValueError`` for invalid "
"values."
msgstr ""
"Então alguém vivendo no Japão pode ter ``JST``, ``UTC``, e ``GMT`` como "
"valores válidos, mas provavelmente não ``EST``. Isso levantará "
"``ValueError`` para valores inválidos."

#: ../../library/datetime.rst:2744
msgid ""
"When the ``%z`` directive is provided to the :meth:`~.datetime.strptime` "
"method, an aware :class:`.datetime` object will be produced. The ``tzinfo`` "
"of the result will be set to a :class:`timezone` instance."
msgstr ""
"Quando a diretiva ``%z`` é fornecida ao método :meth:`~.datetime.strptime`, "
"um objeto :class:`.datetime` consciente será produzido. O ``tzinfo`` do "
"resultado será definido para uma instância :class:`timezone`."

#: ../../library/datetime.rst:2750
msgid ""
"When used with the :meth:`~.datetime.strptime` method, ``%U`` and ``%W`` are "
"only used in calculations when the day of the week and the calendar year "
"(``%Y``) are specified."
msgstr ""
"Quando utilizados com o método :meth:`~.datetime.strptime`, ``%U`` e ``%W`` "
"são usados somente em cálculos quando o dia da semana e o ano (``%Y``) são "
"especificados."

#: ../../library/datetime.rst:2755
msgid ""
"Similar to ``%U`` and ``%W``, ``%V`` is only used in calculations when the "
"day of the week and the ISO year (``%G``) are specified in a :meth:`~."
"datetime.strptime` format string. Also note that ``%G`` and ``%Y`` are not "
"interchangeable."
msgstr ""
"Semelhante a ``%U`` e ``%W``, ``%V`` é usado apenas em cálculos quando o dia "
"da semana e o ano ISO (``%G``) são especificados em um formato de string :"
"meth:`~.datetime.strptime`. Observe também que ``%G`` e ``%Y`` não são "
"intercambiáveis."

#: ../../library/datetime.rst:2761
msgid ""
"When used with the :meth:`~.datetime.strptime` method, the leading zero is "
"optional for  formats ``%d``, ``%m``, ``%H``, ``%I``, ``%M``, ``%S``, "
"``%j``, ``%U``, ``%W``, and ``%V``. Format ``%y`` does require a leading "
"zero."
msgstr ""
"Quando usado com o método :meth:`~.datetime.strptime`, o zero à esquerda é "
"opcional para os formatos ``%d``, ``%m``, ``%H``, ``%I``, ``%M``, ``%S``, "
"``%j``, ``%U``, ``%W`` e ``%V``. O formato ``%y`` requer um zero à esquerda."

#: ../../library/datetime.rst:2766
msgid ""
"When parsing a month and day using :meth:`~.datetime.strptime`, always "
"include a year in the format.  If the value you need to parse lacks a year, "
"append an explicit dummy leap year.  Otherwise your code will raise an "
"exception when it encounters leap day because the default year used by the "
"parser is not a leap year.  Users run into this bug every four years..."
msgstr ""
"Ao analisar um mês e dia usando :meth:`~.datetime.strptime`, sempre inclua "
"um ano no formato. Se o valor que você precisa analisar não possui um ano, "
"adicione um ano bissexto fictício de forma explícita. Caso contrário, seu "
"código levantará uma exceção ao encontrar o dia bissexto, porque o ano "
"padrão usado pelo analisador sintático não é um ano bissexto. Os usuários "
"encontram esse bug a cada quatro anos..."

#: ../../library/datetime.rst:2772
msgid ""
">>> month_day = \"02/29\"\n"
">>> datetime.strptime(f\"{month_day};1984\", \"%m/%d;%Y\")  # No leap year "
"bug.\n"
"datetime.datetime(1984, 2, 29, 0, 0)"
msgstr ""
">>> month_day = \"02/29\"\n"
">>> datetime.strptime(f\"{month_day};1984\", \"%m/%d;%Y\")  # Sem bug de ano "
"bissexto.\n"
"datetime.datetime(1984, 2, 29, 0, 0)"

#: ../../library/datetime.rst:2778
msgid ""
":meth:`~.datetime.strptime` calls using a format string containing a day of "
"month without a year now emit a :exc:`DeprecationWarning`. In 3.15 or later "
"we may change this into an error or change the default year to a leap year. "
"See :gh:`70647`."
msgstr ""
"Chamadas ao método :meth:`~.datetime.strptime` usando uma string de formato "
"contendo um dia do mês sem um ano agora emitem um :exc:`DeprecationWarning`. "
"Na versão 3.15 ou posterior, podemos mudar isso para um erro ou mudar o ano "
"padrão para um ano bissexto. Consulte :gh:`70647`."

#: ../../library/datetime.rst:2785
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../library/datetime.rst:2786
msgid "If, that is, we ignore the effects of Relativity"
msgstr "Se, isto é, nós ignoramos os efeitos da Relatividade"

#: ../../library/datetime.rst:2788
msgid ""
"This matches the definition of the \"proleptic Gregorian\" calendar in "
"Dershowitz and Reingold's book *Calendrical Calculations*, where it's the "
"base calendar for all computations. See the book for algorithms for "
"converting between proleptic Gregorian ordinals and many other calendar "
"systems."
msgstr ""
"Isso combina com a definição do calendário \"proléptico Gregoriano\" no "
"livro *Cálculos Calendáricos* de Dershowitz e Reingold, onde ele é o "
"calendário base para todas as computações. Veja o livro para algoritmos para "
"conversão entre ordinais proléptico Gregoriano e muitos outros sistemas de "
"calendário."

#: ../../library/datetime.rst:2794
msgid ""
"See R. H. van Gent's `guide to the mathematics of the ISO 8601 calendar "
"<https://web.archive.org/web/20220531051136/https://webspace.science.uu.nl/"
"~gent0113/calendar/isocalendar.htm>`_ for a good explanation."
msgstr ""
"Veja `O guia para a matemática de calendário ISO 8601 <https://web.archive."
"org/web/20220531051136/https://webspace.science.uu.nl/~gent0113/calendar/"
"isocalendar.htm>`_ de R. H. van Gent para uma boa explicação."

#: ../../library/datetime.rst:2798
msgid ""
"Passing ``datetime.strptime('Feb 29', '%b %d')`` will fail since 1900 is not "
"a leap year."
msgstr ""
"Passar ``datetime.strptime('Feb 29', '%b %d')`` irá falhar porque 1900 não é "
"um ano bissexto."

#: ../../library/datetime.rst:2441
msgid "% (percent)"
msgstr "% (porcentagem)"

#: ../../library/datetime.rst:2441
msgid "datetime format"
msgstr "datetime, formato"

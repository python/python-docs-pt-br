# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Raphael Mendonça, 2019
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2019
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-10 22:51+0000\n"
"PO-Revision-Date: 2019-09-01 03:21+0000\n"
"Last-Translator: Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2019\n"
"Language-Team: Portuguese (Brazil) (https://www.transifex.com/python-doc/teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../library/math.rst:2
msgid ":mod:`math` --- Mathematical functions"
msgstr ":mod:`math` --- Funções matemáticas"

#: ../../library/math.rst:13
msgid ""
"This module provides access to the mathematical functions defined by the C "
"standard."
msgstr ""
"Este módulo fornece acesso às funções matemáticas definidas pelo padrão C."

#: ../../library/math.rst:16
msgid ""
"These functions cannot be used with complex numbers; use the functions of "
"the same name from the :mod:`cmath` module if you require support for "
"complex numbers.  The distinction between functions which support complex "
"numbers and those which don't is made since most users do not want to learn "
"quite as much mathematics as required to understand complex numbers.  "
"Receiving an exception instead of a complex result allows earlier detection "
"of the unexpected complex number used as a parameter, so that the programmer"
" can determine how and why it was generated in the first place."
msgstr ""
"Essas funções não podem ser usadas com números complexos; use as funções de "
"mesmo nome do módulo :mod:`cmath` se você precisar de suporte para números "
"complexos. A distinção entre funções que suportam números complexos e "
"aquelas que não suportam é feita uma vez que a maioria dos usuários não quer"
" aprender a matemática necessária para entender números complexos. Receber "
"uma exceção em vez de um resultado complexo permite a detecção antecipada do"
" número complexo inesperado usado como parâmetro, para que o programador "
"possa determinar como e por que ele foi gerado em primeiro lugar."

#: ../../library/math.rst:25
msgid ""
"The following functions are provided by this module.  Except when explicitly"
" noted otherwise, all return values are floats."
msgstr ""
"As funções a seguir são fornecidas por este módulo. Exceto quando "
"explicitamente indicado de outra forma, todos os valores de retorno são "
"pontos flutuantes."

#: ../../library/math.rst:30
msgid "Number-theoretic and representation functions"
msgstr "Funções teóricas dos números e de representação"

#: ../../library/math.rst:34
msgid ""
"Return the ceiling of *x*, the smallest integer greater than or equal to "
"*x*. If *x* is not a float, delegates to ``x.__ceil__()``, which should "
"return an :class:`~numbers.Integral` value."
msgstr ""
"Retorna o teto de *x*, o menor inteiro maior ou igual a *x*. Se *x* não for "
"um ponto flutuante, delega para ``x.__ceil__()``, que deve retornar um valor"
" de :class:`~numbers.Integral`."

#: ../../library/math.rst:41
msgid ""
"Return a float with the magnitude (absolute value) of *x* but the sign of "
"*y*.  On platforms that support signed zeros, ``copysign(1.0, -0.0)`` "
"returns *-1.0*."
msgstr ""
"Retorna um ponto flutuante com a magnitude (valor absoluto) de *x*, mas o "
"sinal de *y*. Em plataformas que suportam zeros sem sinal, ``copysign(1.0, "
"-0.0)`` retorna *-1.0*."

#: ../../library/math.rst:48
msgid "Return the absolute value of *x*."
msgstr "Retorna o valor absoluto de *x*."

#: ../../library/math.rst:53
msgid ""
"Return *x* factorial as an integer.  Raises :exc:`ValueError` if *x* is not "
"integral or is negative."
msgstr ""
"Retorna *x* fatorial como um inteiro. Levanta :exc:`ValueError` se *x* não "
"for integral ou for negativo."

#: ../../library/math.rst:59
msgid ""
"Return the floor of *x*, the largest integer less than or equal to *x*. If "
"*x* is not a float, delegates to ``x.__floor__()``, which should return an "
":class:`~numbers.Integral` value."
msgstr ""
"Retorna o piso de *x*, o maior inteiro menor ou igual a *x*. Se *x* não for "
"um ponto flutuante, delega para ``x.__floor__()``, que deve retornar um "
"valor de :class:`~numbers.Integral`."

#: ../../library/math.rst:66
msgid ""
"Return ``fmod(x, y)``, as defined by the platform C library. Note that the "
"Python expression ``x % y`` may not return the same result.  The intent of "
"the C standard is that ``fmod(x, y)`` be exactly (mathematically; to "
"infinite precision) equal to ``x - n*y`` for some integer *n* such that the "
"result has the same sign as *x* and magnitude less than ``abs(y)``.  "
"Python's ``x % y`` returns a result with the sign of *y* instead, and may "
"not be exactly computable for float arguments. For example, ``fmod(-1e-100, "
"1e100)`` is ``-1e-100``, but the result of Python's ``-1e-100 % 1e100`` is "
"``1e100-1e-100``, which cannot be represented exactly as a float, and rounds"
" to the surprising ``1e100``.  For this reason, function :func:`fmod` is "
"generally preferred when working with floats, while Python's ``x % y`` is "
"preferred when working with integers."
msgstr ""
"Retorna ``fmod(x, y)``, conforme definido pela biblioteca C da plataforma. "
"Observe que a expressão Python ``x % y`` pode não retornar o mesmo "
"resultado. A intenção do padrão C é que ``fmod(x, y)`` seja exatamente "
"(matematicamente; com precisão infinita) igual a ``x - n*y`` para algum "
"inteiro *n* de modo que o resultado tenha o mesmo sinal que *x* e magnitude "
"menor que ``abs(y)``. O ``x % y`` do Python retorna um resultado com o sinal"
" de *y*, e pode não ser exatamente computável para argumentos de ponto "
"flutuante. Por exemplo, ``fmod(-1e-100, 1e100)`` é ``-1e-100``, mas o "
"resultado de ``-1e-100 % 1e100`` do Python é ``1e100-1e-100``, que não pode "
"ser representado exatamente como um ponto flutuante, e é arredondado para o "
"surpreendente ``1e100``. Por esta razão, a função :func:`fmod` é geralmente "
"preferida ao trabalhar com pontos flutuantes, enquanto o ``x % y`` do Python"
" é preferido ao trabalhar com inteiros."

#: ../../library/math.rst:81
msgid ""
"Return the mantissa and exponent of *x* as the pair ``(m, e)``.  *m* is a "
"float and *e* is an integer such that ``x == m * 2**e`` exactly. If *x* is "
"zero, returns ``(0.0, 0)``, otherwise ``0.5 <= abs(m) < 1``.  This is used "
"to \"pick apart\" the internal representation of a float in a portable way."
msgstr ""
"Retorna a mantissa e o expoente de *x* como o par ``(m, e)``. *m* é um ponto"
" flutuante e *e* é um inteiro tal que ``x == m * 2**e`` exatamente. Se *x* "
"for zero, retorna ``(0.0, 0)``, caso contrário, ``0.5 <= abs(m) < 1``. Isso "
"é usado para \"separar\" a representação interna de um ponto flutuante de "
"forma portátil."

#: ../../library/math.rst:89
msgid ""
"Return an accurate floating point sum of values in the iterable.  Avoids "
"loss of precision by tracking multiple intermediate partial sums::"
msgstr ""
"Retorna uma soma de valores de ponto flutuante precisa no iterável. Evita "
"perda de precisão rastreando várias somas parciais intermediárias::"

#: ../../library/math.rst:97
msgid ""
"The algorithm's accuracy depends on IEEE-754 arithmetic guarantees and the "
"typical case where the rounding mode is half-even.  On some non-Windows "
"builds, the underlying C library uses extended precision addition and may "
"occasionally double-round an intermediate sum causing it to be off in its "
"least significant bit."
msgstr ""
"A precisão do algoritmo depende das garantias aritméticas IEEE-754 e do caso"
" típico em que o modo de arredondamento é meio par. Em algumas compilações "
"que não são do Windows, a biblioteca C subjacente usa adição de precisão "
"estendida e pode ocasionalmente arredondar uma soma intermediária fazendo "
"com que ela fique fora do bit menos significativo."

#: ../../library/math.rst:103
msgid ""
"For further discussion and two alternative approaches, see the `ASPN "
"cookbook recipes for accurate floating point summation "
"<https://code.activestate.com/recipes/393090/>`_\\."
msgstr ""
"Para uma discussão mais aprofundada e duas abordagens alternativas, consulte"
" as `receitas do livro de receitas ASPN para soma de ponto flutuante preciso"
" <https://code.activestate.com/recipes/393090/>`_\\."

#: ../../library/math.rst:110
msgid ""
"Return the greatest common divisor of the integers *a* and *b*.  If either "
"*a* or *b* is nonzero, then the value of ``gcd(a, b)`` is the largest "
"positive integer that divides both *a* and *b*.  ``gcd(0, 0)`` returns "
"``0``."
msgstr ""

#: ../../library/math.rst:120
msgid ""
"Return ``True`` if the values *a* and *b* are close to each other and "
"``False`` otherwise."
msgstr ""
"Retorna ``True`` se os valores *a* e *b* estiverem próximos e ``False`` caso"
" contrário."

#: ../../library/math.rst:123
msgid ""
"Whether or not two values are considered close is determined according to "
"given absolute and relative tolerances."
msgstr ""
"Se dois valores são ou não considerados próximos, é determinado de acordo "
"com as tolerâncias absolutas e relativas fornecidas."

#: ../../library/math.rst:126
msgid ""
"*rel_tol* is the relative tolerance -- it is the maximum allowed difference "
"between *a* and *b*, relative to the larger absolute value of *a* or *b*. "
"For example, to set a tolerance of 5%, pass ``rel_tol=0.05``.  The default "
"tolerance is ``1e-09``, which assures that the two values are the same "
"within about 9 decimal digits.  *rel_tol* must be greater than zero."
msgstr ""
"*rel_tol* é a tolerância relativa -- é a diferença máxima permitida entre "
"*a* e *b*, em relação ao maior valor absoluto de *a* e *b*. Por exemplo, "
"para definir uma tolerância de 5%, passe ``rel_tol=0.05``. A tolerância "
"padrão é ``1e-09``, o que garante que os dois valores sejam iguais em cerca "
"de 9 dígitos decimais. *rel_tol* deve ser maior que zero."

#: ../../library/math.rst:132
msgid ""
"*abs_tol* is the minimum absolute tolerance -- useful for comparisons near "
"zero. *abs_tol* must be at least zero."
msgstr ""
"*abs_tol* é a tolerância absoluta mínima -- útil para comparações próximas a"
" zero. *abs_tol* deve ser pelo menos zero."

#: ../../library/math.rst:135
msgid ""
"If no errors occur, the result will be: ``abs(a-b) <= max(rel_tol * "
"max(abs(a), abs(b)), abs_tol)``."
msgstr ""
"Se nenhum erro ocorrer, o resultado será: ``abs(a-b) <= max(rel_tol * "
"max(abs(a), abs(b)), abs_tol)``."

#: ../../library/math.rst:138
msgid ""
"The IEEE 754 special values of ``NaN``, ``inf``, and ``-inf`` will be "
"handled according to IEEE rules.  Specifically, ``NaN`` is not considered "
"close to any other value, including ``NaN``.  ``inf`` and ``-inf`` are only "
"considered close to themselves."
msgstr ""
"Os valores especiais do IEEE 754 de ``NaN``, ``inf`` e ``-inf`` serão "
"tratados de acordo com as regras do IEEE. Especificamente, ``NaN`` não é "
"considerado próximo a qualquer outro valor, incluindo ``NaN``. ``inf`` e "
"``-inf`` são considerados apenas próximos a si mesmos."

#: ../../library/math.rst:147
msgid ":pep:`485` -- A function for testing approximate equality"
msgstr ":pep:`485` -- Uma função para testar igualdade aproximada"

#: ../../library/math.rst:152
msgid ""
"Return ``True`` if *x* is neither an infinity nor a NaN, and ``False`` "
"otherwise.  (Note that ``0.0`` *is* considered finite.)"
msgstr ""
"Retorna ``True`` se *x* não for um infinito nem um NaN, e ``False`` caso "
"contrário.  (Observe que ``0.0`` *é* considerado finito.)"

#: ../../library/math.rst:160
msgid ""
"Return ``True`` if *x* is a positive or negative infinity, and ``False`` "
"otherwise."
msgstr ""
"Retorna ``True`` se *x* for um infinito positivo ou negativo, e ``False`` "
"caso contrário."

#: ../../library/math.rst:166
msgid ""
"Return ``True`` if *x* is a NaN (not a number), and ``False`` otherwise."
msgstr ""
"Retorna ``True`` se *x* for um NaN (não um número), e ``False`` caso "
"contrário."

#: ../../library/math.rst:171
msgid ""
"Return ``x * (2**i)``.  This is essentially the inverse of function "
":func:`frexp`."
msgstr ""
"Retorna ``x * (2**i)``. Este é essencialmente o inverso da função "
":func:`frexp`."

#: ../../library/math.rst:177
msgid ""
"Return the fractional and integer parts of *x*.  Both results carry the sign"
" of *x* and are floats."
msgstr ""
"Retorna as partes fracionárias e inteiras de *x*. Ambos os resultados "
"carregam o sinal de *x* e são pontos flutuantes."

#: ../../library/math.rst:183
msgid ""
"Return the IEEE 754-style remainder of *x* with respect to *y*.  For finite "
"*x* and finite nonzero *y*, this is the difference ``x - n*y``, where ``n`` "
"is the closest integer to the exact value of the quotient ``x / y``.  If ``x"
" / y`` is exactly halfway between two consecutive integers, the nearest "
"*even* integer is used for ``n``.  The remainder ``r = remainder(x, y)`` "
"thus always satisfies ``abs(r) <= 0.5 * abs(y)``."
msgstr ""
"Retorna o resto no estilo IEEE 754 de *x* em relação a *y*. Para o finito "
"*x* e o finito diferente de zero *y*, esta é a diferença ``x - n*y``, onde "
"``n`` é o número inteiro mais próximo do valor exato do quociente ``x / y`` "
". Se ``x / y`` está exatamente no meio do caminho entre dois inteiros "
"consecutivos, o inteiro *even* mais próximo é usado para ``n``. O resto ``r "
"= remainder(x, y)`` assim sempre satisfaz ``abs(r) <= 0.5 * abs(y)``."

#: ../../library/math.rst:190
msgid ""
"Special cases follow IEEE 754: in particular, ``remainder(x, math.inf)`` is "
"*x* for any finite *x*, and ``remainder(x, 0)`` and ``remainder(math.inf, "
"x)`` raise :exc:`ValueError` for any non-NaN *x*. If the result of the "
"remainder operation is zero, that zero will have the same sign as *x*."
msgstr ""
"Casos especiais seguem IEEE 754: em particular, ``remainder(x, math.inf)`` é"
" *x* para qualquer *x* finito, e ``remainder(x, 0)`` e ``remainder(math.inf,"
" x)`` levantam :exc:`ValueError` para qualquer *x* não NaN. Se o resultado "
"da operação ``remainder`` for zero, esse zero terá o mesmo sinal de *x*."

#: ../../library/math.rst:196
msgid ""
"On platforms using IEEE 754 binary floating-point, the result of this "
"operation is always exactly representable: no rounding error is introduced."
msgstr ""
"Em plataformas que usam ponto flutuante binário do IEEE 754, o resultado "
"dessa operação é sempre exatamente representável: nenhum erro de "
"arredondamento é introduzido."

#: ../../library/math.rst:204
msgid ""
"Return the :class:`~numbers.Real` value *x* truncated to an "
":class:`~numbers.Integral` (usually an integer). Delegates to "
":meth:`x.__trunc__() <object.__trunc__>`."
msgstr ""
"Retorna o valor *x* :class:`~numbers.Real` truncado com um "
":class:`~numbers.Integral` (geralmente um inteiro). Delega para "
":meth:`x.__trunc__() <object.__trunc__>`."

#: ../../library/math.rst:209
msgid ""
"Note that :func:`frexp` and :func:`modf` have a different call/return "
"pattern than their C equivalents: they take a single argument and return a "
"pair of values, rather than returning their second return value through an "
"'output parameter' (there is no such thing in Python)."
msgstr ""
"Observe que :func:`frexp` e :func:`modf` têm um padrão de chamada/retorno "
"diferente de seus equivalentes C: elas pegam um único argumento e retornam "
"um par de valores, ao invés de retornar seu segundo valor de retorno por "
"meio de um \"parâmetro de saída\" (não existe tal coisa em Python)."

#: ../../library/math.rst:214
msgid ""
"For the :func:`ceil`, :func:`floor`, and :func:`modf` functions, note that "
"*all* floating-point numbers of sufficiently large magnitude are exact "
"integers. Python floats typically carry no more than 53 bits of precision "
"(the same as the platform C double type), in which case any float *x* with "
"``abs(x) >= 2**52`` necessarily has no fractional bits."
msgstr ""
"Para as funções :func:`ceil`, :func:`floor` e :func:`modf`, observe que "
"*todos* os números de ponto flutuante de magnitude suficientemente grande "
"são inteiros exatos. Os pontos flutuantes do Python normalmente não carregam"
" mais do que 53 bits de precisão (o mesmo que o tipo duplo da plataforma C),"
" caso em que qualquer flutuante *x* com ``abs(x) >= 2**52`` necessariamente "
"não tem bits fracionários."

#: ../../library/math.rst:222
msgid "Power and logarithmic functions"
msgstr "Funções de potência e logarítmicas"

#: ../../library/math.rst:226
msgid ""
"Return *e* raised to the power *x*, where *e* = 2.718281... is the base of "
"natural logarithms.  This is usually more accurate than ``math.e ** x`` or "
"``pow(math.e, x)``."
msgstr ""
"Retorna *e* elevado à potência *x*, onde *e* = 2.718281... é a base dos "
"logaritmos naturais. Isso geralmente é mais preciso do que ``math.e ** x`` "
"ou ``pow(math.e, x)``."

#: ../../library/math.rst:233
msgid ""
"Return *e* raised to the power *x*, minus 1.  Here *e* is the base of "
"natural logarithms.  For small floats *x*, the subtraction in ``exp(x) - 1``"
" can result in a `significant loss of precision "
"<https://en.wikipedia.org/wiki/Loss_of_significance>`_\\; the :func:`expm1` "
"function provides a way to compute this quantity to full precision::"
msgstr ""
"Retorna *e* elevado à potência *x*, menos 1. Aqui *e* é a base dos "
"logaritmos naturais. Para pequenos pontos flutuantes *x*, a subtração em "
"``exp(x) - 1`` pode resultar em uma `perda significativa de precisão "
"<https://en.wikipedia.org/wiki/Loss_of_significance>`_\\; a função "
":func:`expm1` fornece uma maneira de calcular essa quantidade com precisão "
"total::"

#: ../../library/math.rst:250
msgid "With one argument, return the natural logarithm of *x* (to base *e*)."
msgstr "Com um argumento, retorna o logaritmo natural de *x* (para base *e*)."

#: ../../library/math.rst:252
msgid ""
"With two arguments, return the logarithm of *x* to the given *base*, "
"calculated as ``log(x)/log(base)``."
msgstr ""
"Com dois argumentos, retorna o logaritmo de *x* para a *base* fornecida, "
"calculada como ``log(x)/log(base)``."

#: ../../library/math.rst:258
msgid ""
"Return the natural logarithm of *1+x* (base *e*). The result is calculated "
"in a way which is accurate for *x* near zero."
msgstr ""
"Retorna o logaritmo natural de *1+x* (base *e*). O resultado é calculado de "
"forma precisa para *x* próximo a zero."

#: ../../library/math.rst:264
msgid ""
"Return the base-2 logarithm of *x*. This is usually more accurate than "
"``log(x, 2)``."
msgstr ""
"Retorna o logaritmo de base 2 de *x*. Isso geralmente é mais preciso do que "
"``log(x, 2)``."

#: ../../library/math.rst:271
msgid ""
":meth:`int.bit_length` returns the number of bits necessary to represent an "
"integer in binary, excluding the sign and leading zeros."
msgstr ""
":meth:`int.bit_length` retorna o número de bits necessários para representar"
" um inteiro em binário, excluindo o sinal e os zeros à esquerda."

#: ../../library/math.rst:277
msgid ""
"Return the base-10 logarithm of *x*.  This is usually more accurate than "
"``log(x, 10)``."
msgstr ""
"Retorna o logaritmo de base 10 de *x*. Isso geralmente é mais preciso do que"
" ``log(x, 10)``."

#: ../../library/math.rst:283
msgid ""
"Return ``x`` raised to the power ``y``.  Exceptional cases follow Annex 'F' "
"of the C99 standard as far as possible.  In particular, ``pow(1.0, x)`` and "
"``pow(x, 0.0)`` always return ``1.0``, even when ``x`` is a zero or a NaN.  "
"If both ``x`` and ``y`` are finite, ``x`` is negative, and ``y`` is not an "
"integer then ``pow(x, y)`` is undefined, and raises :exc:`ValueError`."
msgstr ""
"Retorna ``x`` elevado à potência ``y``. Os casos excepcionais seguem o Anexo"
" 'F' da norma C99, tanto quanto possível. Em particular, ``pow(1.0, x)`` e "
"``pow(x, 0.0)`` sempre retornam ``1.0``, mesmo quando ``x`` é um zero ou um "
"NaN. Se ambos ``x`` e ``y`` são finitos, ``x`` é negativo, e ``y`` não é um "
"inteiro, então ``pow(x, y)`` é indefinido e levanta :exc:`ValueError`."

#: ../../library/math.rst:290
msgid ""
"Unlike the built-in ``**`` operator, :func:`math.pow` converts both its "
"arguments to type :class:`float`.  Use ``**`` or the built-in :func:`pow` "
"function for computing exact integer powers."
msgstr ""
"Ao contrário do operador embutido ``**``, :func:`math.pow` converte ambos os"
" seus argumentos para o tipo :class:`float`. Use ``**`` ou a função embutida"
" :func:`pow` para calcular potências inteiras exatas."

#: ../../library/math.rst:297
msgid "Return the square root of *x*."
msgstr "Retorna a raiz quadrada de *x*."

#: ../../library/math.rst:301
msgid "Trigonometric functions"
msgstr "Funções trigonométricas"

#: ../../library/math.rst:305
msgid "Return the arc cosine of *x*, in radians."
msgstr ""

#: ../../library/math.rst:310
msgid "Return the arc sine of *x*, in radians."
msgstr ""

#: ../../library/math.rst:315
msgid "Return the arc tangent of *x*, in radians."
msgstr ""

#: ../../library/math.rst:320
msgid ""
"Return ``atan(y / x)``, in radians. The result is between ``-pi`` and "
"``pi``. The vector in the plane from the origin to point ``(x, y)`` makes "
"this angle with the positive X axis. The point of :func:`atan2` is that the "
"signs of both inputs are known to it, so it can compute the correct quadrant"
" for the angle. For example, ``atan(1)`` and ``atan2(1, 1)`` are both "
"``pi/4``, but ``atan2(-1, -1)`` is ``-3*pi/4``."
msgstr ""
"Retorna ``atan(y / x)``, em radianos. O resultado está entre ``-pi`` e "
"``pi``. O vetor no plano da origem ao ponto ``(x, y)`` faz este ângulo com o"
" eixo X positivo. O ponto de :func:`atan2` é que os sinais de ambas as "
"entradas são conhecidos por ele, então ele pode calcular o quadrante correto"
" para o ângulo. Por exemplo, ``atan(1)`` e ``atan2(1, 1)`` são "
"ambos``pi/4``, mas ``atan2(-1, -1)`` é ``-3*pi/4``."

#: ../../library/math.rst:330
msgid "Return the cosine of *x* radians."
msgstr "Retorna o cosseno de *x* radianos."

#: ../../library/math.rst:335
msgid ""
"Return the Euclidean norm, ``sqrt(x*x + y*y)``. This is the length of the "
"vector from the origin to point ``(x, y)``."
msgstr ""

#: ../../library/math.rst:341
msgid "Return the sine of *x* radians."
msgstr "Retorna o seno de *x* radianos."

#: ../../library/math.rst:346
msgid "Return the tangent of *x* radians."
msgstr "Retorna o tangente de *x* radianos."

#: ../../library/math.rst:350
msgid "Angular conversion"
msgstr "Conversão angular"

#: ../../library/math.rst:354
msgid "Convert angle *x* from radians to degrees."
msgstr "Converte o ângulo *x* de radianos para graus."

#: ../../library/math.rst:359
msgid "Convert angle *x* from degrees to radians."
msgstr "Converte o ângulo *x* de graus para radianos."

#: ../../library/math.rst:363
msgid "Hyperbolic functions"
msgstr "Funções hiperbólicas"

#: ../../library/math.rst:365
msgid ""
"`Hyperbolic functions <https://en.wikipedia.org/wiki/Hyperbolic_function>`_ "
"are analogs of trigonometric functions that are based on hyperbolas instead "
"of circles."
msgstr ""
"`Funções hiperbólicas <https://pt.wikipedia.org/wiki/Função_hiperbólica>`_ "
"são análogos de funções trigonométricas baseadas em hipérboles em vez de "
"círculos."

#: ../../library/math.rst:371
msgid "Return the inverse hyperbolic cosine of *x*."
msgstr "Retorna o cosseno hiperbólico inverso de *x*."

#: ../../library/math.rst:376
msgid "Return the inverse hyperbolic sine of *x*."
msgstr "Retorna o seno hiperbólico inverso de *x*."

#: ../../library/math.rst:381
msgid "Return the inverse hyperbolic tangent of *x*."
msgstr "Retorna a tangente hiperbólica inversa de *x*."

#: ../../library/math.rst:386
msgid "Return the hyperbolic cosine of *x*."
msgstr "Retorna o cosseno hiperbólico de *x*."

#: ../../library/math.rst:391
msgid "Return the hyperbolic sine of *x*."
msgstr "Retorna o seno hiperbólico de *x*."

#: ../../library/math.rst:396
msgid "Return the hyperbolic tangent of *x*."
msgstr "Retorna a tangente hiperbólica de *x*."

#: ../../library/math.rst:400
msgid "Special functions"
msgstr "Funções especiais"

#: ../../library/math.rst:404
msgid ""
"Return the `error function <https://en.wikipedia.org/wiki/Error_function>`_ "
"at *x*."
msgstr ""
"Retorna a `função erro <https://pt.wikipedia.org/wiki/Função_erro>`_ em *x*."

#: ../../library/math.rst:407
msgid ""
"The :func:`erf` function can be used to compute traditional statistical "
"functions such as the `cumulative standard normal distribution "
"<https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function>`_::"
msgstr ""
"A função :func:`erf` pode ser usada para calcular funções estatísticas "
"tradicionais, como a `distribuição normal padrão cumulativa "
"<https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function>`_::"

#: ../../library/math.rst:420
msgid ""
"Return the complementary error function at *x*.  The `complementary error "
"function <https://en.wikipedia.org/wiki/Error_function>`_ is defined as "
"``1.0 - erf(x)``.  It is used for large values of *x* where a subtraction "
"from one would cause a `loss of significance "
"<https://en.wikipedia.org/wiki/Loss_of_significance>`_\\."
msgstr ""
"Retorna a função erro complementar em *x*. A `função erro complementar "
"<https://en.wikipedia.org/wiki/Error_function>`_ é definida como ``1.0 - "
"erf(x)``. É usado para grandes valores de *x* onde uma subtração de um "
"causaria uma `perda de significância "
"<https://en.wikipedia.org/wiki/Loss_of_significance>`_\\."

#: ../../library/math.rst:431
msgid ""
"Return the `Gamma function <https://en.wikipedia.org/wiki/Gamma_function>`_ "
"at *x*."
msgstr ""
"Retorna a `função gama <https://pt.wikipedia.org/wiki/Função_gama>`_ em *x*."

#: ../../library/math.rst:439
msgid ""
"Return the natural logarithm of the absolute value of the Gamma function at "
"*x*."
msgstr "Retorna o logaritmo natural do valor absoluto da função gama em *x*."

#: ../../library/math.rst:446
msgid "Constants"
msgstr "Constantes"

#: ../../library/math.rst:450
msgid "The mathematical constant *π* = 3.141592..., to available precision."
msgstr "A constante matemática *π* = 3.141592..., para a precisão disponível."

#: ../../library/math.rst:455
msgid "The mathematical constant *e* = 2.718281..., to available precision."
msgstr "A constante matemática *e* = 2.718281..., para a precisão disponível."

#: ../../library/math.rst:460
msgid ""
"The mathematical constant *τ* = 6.283185..., to available precision. Tau is "
"a circle constant equal to 2\\ *π*, the ratio of a circle's circumference to"
" its radius. To learn more about Tau, check out Vi Hart's video `Pi is "
"(still) Wrong <https://www.youtube.com/watch?v=jG7vhMMXagQ>`_, and start "
"celebrating `Tau day <https://tauday.com/>`_ by eating twice as much pie!"
msgstr ""
"A constante matemática *τ* = 6.283185..., para a precisão disponível. Tau é "
"uma constante de círculo igual a 2\\ *π*, a razão entre a circunferência de "
"um círculo e seu raio. Para saber mais sobre Tau, confira o vídeo `Pi is "
"(still) Wrong <https://www.youtube.com/watch?v=jG7vhMMXagQ>`_ de Vi Hart, e "
"comece a comemorar o `dia do Tau <https://tauday.com/>`_ comendo duas vezes "
"mais torta!"

#: ../../library/math.rst:471
msgid ""
"A floating-point positive infinity.  (For negative infinity, use "
"``-math.inf``.)  Equivalent to the output of ``float('inf')``."
msgstr ""
"Um infinito positivo de ponto flutuante. (Para infinito negativo, use "
"``-math.inf``.) Equivalente à saída de ``float('inf')``."

#: ../../library/math.rst:479
msgid ""
"A floating-point \"not a number\" (NaN) value.  Equivalent to the output of "
"``float('nan')``."
msgstr ""
"Um valor de ponto flutuante \"não um número\" (NaN). Equivalente à saída de "
"``float('nan')``."

#: ../../library/math.rst:487
msgid ""
"The :mod:`math` module consists mostly of thin wrappers around the platform "
"C math library functions.  Behavior in exceptional cases follows Annex F of "
"the C99 standard where appropriate.  The current implementation will raise "
":exc:`ValueError` for invalid operations like ``sqrt(-1.0)`` or ``log(0.0)``"
" (where C99 Annex F recommends signaling invalid operation or divide-by-"
"zero), and :exc:`OverflowError` for results that overflow (for example, "
"``exp(1000.0)``).  A NaN will not be returned from any of the functions "
"above unless one or more of the input arguments was a NaN; in that case, "
"most functions will return a NaN, but (again following C99 Annex F) there "
"are some exceptions to this rule, for example ``pow(float('nan'), 0.0)`` or "
"``hypot(float('nan'), float('inf'))``."
msgstr ""
"O módulo :mod:`math` consiste principalmente em O módulo: mod: `math` "
"consiste principalmente em invólucros finos em torno das funções da "
"biblioteca matemática C da plataforma. O comportamento em casos excepcionais"
" segue o Anexo F da norma C99 quando apropriado. A implementação atual "
"levantará :exc:`ValueError` para operações inválidas como ``sqrt(-1.0)`` ou "
"``log(0.0)`` (onde C99 Anexo F recomenda sinalizar operação inválida ou "
"divisão por zero), e :exc:`OverflowError` para resultados que estouram (por "
"exemplo,``exp(1000.0)``). Um NaN não será retornado de nenhuma das funções "
"acima, a menos que um ou mais dos argumentos de entrada sejam um NaN; nesse "
"caso, a maioria das funções retornará um NaN, mas (novamente seguindo C99 "
"Anexo F) há algumas exceções a esta regra, por exemplo, ``pow(float('nan'), "
"0.0)`` ou ``hypot(float('nan'), float('inf'))``."

#: ../../library/math.rst:499
msgid ""
"Note that Python makes no effort to distinguish signaling NaNs from quiet "
"NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior "
"is to treat all NaNs as though they were quiet."
msgstr ""
"Observe que o Python não faz nenhum esforço para distinguir NaNs de "
"sinalização de NaNs silenciosos, e o comportamento para NaNs de sinalização "
"permanece não especificado. O comportamento típico é tratar todos os NaNs "
"como se estivessem quietos."

#: ../../library/math.rst:506
msgid "Module :mod:`cmath`"
msgstr "Modulo :mod:`cmath`"

#: ../../library/math.rst:507
msgid "Complex number versions of many of these functions."
msgstr "Versões de números complexos de muitas dessas funções."

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-16 17:23+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/math.rst:2
msgid ":mod:`!math` --- Mathematical functions"
msgstr ":mod:`!math` --- Funções matemáticas"

#: ../../library/math.rst:13
msgid ""
"This module provides access to common mathematical functions and constants, "
"including those defined by the C standard."
msgstr ""
"Este módulo fornece acesso à constantes e funções matemáticas comuns, "
"incluindo aquelas definidas pelo padrão C."

#: ../../library/math.rst:16
msgid ""
"These functions cannot be used with complex numbers; use the functions of "
"the same name from the :mod:`cmath` module if you require support for "
"complex numbers.  The distinction between functions which support complex "
"numbers and those which don't is made since most users do not want to learn "
"quite as much mathematics as required to understand complex numbers.  "
"Receiving an exception instead of a complex result allows earlier detection "
"of the unexpected complex number used as a parameter, so that the programmer "
"can determine how and why it was generated in the first place."
msgstr ""
"Essas funções não podem ser usadas com números complexos; use as funções de "
"mesmo nome do módulo :mod:`cmath` se você precisar de suporte para números "
"complexos. A distinção entre funções que suportam números complexos e "
"aquelas que não suportam é feita uma vez que a maioria dos usuários não quer "
"aprender a matemática necessária para entender números complexos. Receber "
"uma exceção em vez de um resultado complexo permite a detecção antecipada do "
"número complexo inesperado usado como parâmetro, para que o programador "
"possa determinar como e por que ele foi gerado em primeiro lugar."

#: ../../library/math.rst:25
msgid ""
"The following functions are provided by this module.  Except when explicitly "
"noted otherwise, all return values are floats."
msgstr ""
"As funções a seguir são fornecidas por este módulo. Exceto quando "
"explicitamente indicado de outra forma, todos os valores de retorno são "
"pontos flutuantes."

#: ../../library/math.rst:30
msgid "**Number-theoretic functions**"
msgstr "**Funções de teoria dos números**"

#: ../../library/math.rst:32
msgid ":func:`comb(n, k) <comb>`"
msgstr ":func:`comb(n, k) <comb>`"

#: ../../library/math.rst:32
msgid ""
"Number of ways to choose *k* items from *n* items without repetition and "
"without order"
msgstr ""
"Número de maneiras de escolher *k* itens a partir de *n* itens sem repetição "
"e sem ordem"

#: ../../library/math.rst:33
msgid ":func:`factorial(n) <factorial>`"
msgstr ":func:`factorial(n) <factorial>`"

#: ../../library/math.rst:33
msgid "*n* factorial"
msgstr "Fatorial de *n*"

#: ../../library/math.rst:34
msgid ":func:`gcd(*integers) <gcd>`"
msgstr ":func:`gcd(*integers) <gcd>`"

#: ../../library/math.rst:34
msgid "Greatest common divisor of the integer arguments"
msgstr "Máximo divisor comum dos argumentos inteiros"

#: ../../library/math.rst:35
msgid ":func:`isqrt(n) <isqrt>`"
msgstr ":func:`isqrt(n) <isqrt>`"

#: ../../library/math.rst:35
msgid "Integer square root of a nonnegative integer *n*"
msgstr "Raiz quadrada inteira de um inteiro não negativo *n*"

#: ../../library/math.rst:36
msgid ":func:`lcm(*integers) <lcm>`"
msgstr ":func:`lcm(*integers) <lcm>`"

#: ../../library/math.rst:36
msgid "Least common multiple of the integer arguments"
msgstr "Mínimo múltiplo comum dos argumentos inteiros"

#: ../../library/math.rst:37
msgid ":func:`perm(n, k) <perm>`"
msgstr ":func:`perm(n, k) <perm>`"

#: ../../library/math.rst:37
msgid ""
"Number of ways to choose *k* items from *n* items without repetition and "
"with order"
msgstr ""
"Número de maneiras de escolher *k* itens de *n* itens sem repetição e com "
"ordem"

#: ../../library/math.rst:39
msgid "**Floating point arithmetic**"
msgstr "**Arimética de ponto flutuante**"

#: ../../library/math.rst:41
msgid ":func:`ceil(x) <ceil>`"
msgstr ":func:`ceil(x) <ceil>`"

#: ../../library/math.rst:41
msgid "Ceiling of *x*, the smallest integer greater than or equal to *x*"
msgstr "Teto de *x*, o menor número inteiro maior ou igual a *x*"

#: ../../library/math.rst:42
msgid ":func:`fabs(x) <fabs>`"
msgstr ":func:`fabs(x) <fabs>`"

#: ../../library/math.rst:42
msgid "Absolute value of *x*"
msgstr "Valor absoluto de *x*"

#: ../../library/math.rst:43
msgid ":func:`floor(x)  <floor>`"
msgstr ":func:`floor(x)  <floor>`"

#: ../../library/math.rst:43
msgid "Floor of *x*, the largest integer less than or equal to *x*"
msgstr "Piso de *x*, o maior inteiro menor ou igual a *x*"

#: ../../library/math.rst:44
msgid ":func:`fma(x, y, z) <fma>`"
msgstr ":func:`fma(x, y, z) <fma>`"

#: ../../library/math.rst:44
msgid "Fused multiply-add operation: ``(x * y) + z``"
msgstr "Operação de multiplicação e adição combinadas: ``(x * y) + z``"

#: ../../library/math.rst:45
msgid ":func:`fmod(x, y) <fmod>`"
msgstr ":func:`fmod(x, y) <fmod>`"

#: ../../library/math.rst:45
msgid "Remainder of division ``x / y``"
msgstr "Resto da divisão ``x / y``"

#: ../../library/math.rst:46
msgid ":func:`modf(x) <modf>`"
msgstr ":func:`modf(x) <modf>`"

#: ../../library/math.rst:46
msgid "Fractional and integer parts of *x*"
msgstr "Partes fracionárias e inteiras de *x*"

#: ../../library/math.rst:47
msgid ":func:`remainder(x, y) <remainder>`"
msgstr ":func:`remainder(x, y) <remainder>`"

#: ../../library/math.rst:47
msgid "Remainder of *x* with respect to *y*"
msgstr "Resto de *x* em relação a *y*"

#: ../../library/math.rst:48
msgid ":func:`trunc(x) <trunc>`"
msgstr ":func:`trunc(x) <trunc>`"

#: ../../library/math.rst:48
msgid "Integer part of *x*"
msgstr "Parte inteira de *x*"

#: ../../library/math.rst:50
msgid "**Floating point manipulation functions**"
msgstr "**Funções de manipulação de ponto flutuante**"

#: ../../library/math.rst:52
msgid ":func:`copysign(x, y) <copysign>`"
msgstr ":func:`copysign(x, y) <copysign>`"

#: ../../library/math.rst:52
msgid "Magnitude (absolute value) of *x* with the sign of *y*"
msgstr "Magnitude (valor absoluto) de *x* com o sinal de *y*"

#: ../../library/math.rst:53
msgid ":func:`frexp(x) <frexp>`"
msgstr ":func:`frexp(x) <frexp>`"

#: ../../library/math.rst:53
msgid "Mantissa and exponent of *x*"
msgstr "Mantissa e expoente de *x*"

#: ../../library/math.rst:54
msgid ":func:`isclose(a, b, rel_tol, abs_tol) <isclose>`"
msgstr ":func:`isclose(a, b, rel_tol, abs_tol) <isclose>`"

#: ../../library/math.rst:54
msgid "Check if the values *a* and *b* are close to each other"
msgstr "Verifica se os valores *a* e *b* estão próximos um do outro"

#: ../../library/math.rst:55
msgid ":func:`isfinite(x) <isfinite>`"
msgstr ":func:`isfinite(x) <isfinite>`"

#: ../../library/math.rst:55
msgid "Check if *x* is neither an infinity nor a NaN"
msgstr "Verifica se *x* não é infinito e nem um NaN"

#: ../../library/math.rst:56
msgid ":func:`isinf(x) <isinf>`"
msgstr ":func:`isinf(x) <isinf>`"

#: ../../library/math.rst:56
msgid "Check if *x* is a positive or negative infinity"
msgstr "Verifica se *x* é um infinito positivo ou negativo"

#: ../../library/math.rst:57
msgid ":func:`isnan(x) <isnan>`"
msgstr ":func:`isnan(x) <isnan>`"

#: ../../library/math.rst:57
msgid "Check if *x* is a NaN  (not a number)"
msgstr "Verifica se *x* é um NaN (não um número)"

#: ../../library/math.rst:58
msgid ":func:`ldexp(x, i) <ldexp>`"
msgstr ":func:`ldexp(x, i) <ldexp>`"

#: ../../library/math.rst:58
msgid "``x * (2**i)``, inverse of function :func:`frexp`"
msgstr "``x * (2**i)``, inverso da função :func:`frexp`"

#: ../../library/math.rst:59
msgid ":func:`nextafter(x, y, steps) <nextafter>`"
msgstr ":func:`nextafter(x, y, steps) <nextafter>`"

#: ../../library/math.rst:59
msgid "Floating-point value *steps* steps after *x* towards *y*"
msgstr ""
"Valor de ponto flutuante de *steps* passos depois de *x* em direção a *y*"

#: ../../library/math.rst:60
msgid ":func:`ulp(x) <ulp>`"
msgstr ":func:`ulp(x) <ulp>`"

#: ../../library/math.rst:60
msgid "Value of the least significant bit of *x*"
msgstr "Valor do bit menos significativo de *x*"

#: ../../library/math.rst:62
msgid "**Power, exponential and logarithmic functions**"
msgstr "**Funções de potências, exponenciais e logarítmicas**"

#: ../../library/math.rst:64
msgid ":func:`cbrt(x) <cbrt>`"
msgstr ":func:`cbrt(x) <cbrt>`"

#: ../../library/math.rst:64
msgid "Cube root of *x*"
msgstr "Raiz cúbica de *x*"

#: ../../library/math.rst:65
msgid ":func:`exp(x) <exp>`"
msgstr ":func:`exp(x) <exp>`"

#: ../../library/math.rst:65
msgid "*e* raised to the power *x*"
msgstr "*e* elevado à potência *x*"

#: ../../library/math.rst:66
msgid ":func:`exp2(x) <exp2>`"
msgstr ":func:`exp2(x) <exp2>`"

#: ../../library/math.rst:66
msgid "*2* raised to the power *x*"
msgstr "*2* elevado a potência de *x*"

#: ../../library/math.rst:67
msgid ":func:`expm1(x) <expm1>`"
msgstr ":func:`expm1(x) <expm1>`"

#: ../../library/math.rst:67
msgid "*e* raised to the power *x*, minus 1"
msgstr "*e* elevado a potência de *x*, menos 1"

#: ../../library/math.rst:68
msgid ":func:`log(x, base) <log>`"
msgstr ":func:`log(x, base) <log>`"

#: ../../library/math.rst:68
msgid "Logarithm of *x* to the given base (*e* by default)"
msgstr "Logaritmo de *x* para a base fornecida (*e* por padrão)"

#: ../../library/math.rst:69
msgid ":func:`log1p(x) <log1p>`"
msgstr ":func:`log1p(x) <log1p>`"

#: ../../library/math.rst:69
msgid "Natural logarithm of *1+x* (base *e*)"
msgstr "Logaritmo natural de *1+x* (base *e*)"

#: ../../library/math.rst:70
msgid ":func:`log2(x) <log2>`"
msgstr ":func:`log2(x) <log2>`"

#: ../../library/math.rst:70
msgid "Base-2 logarithm of *x*"
msgstr "Logaritmo de base 2 de *x*"

#: ../../library/math.rst:71
msgid ":func:`log10(x) <log10>`"
msgstr ":func:`log10(x) <log10>`"

#: ../../library/math.rst:71
msgid "Base-10 logarithm of *x*"
msgstr "Logaritmo de base 10 de *x*"

#: ../../library/math.rst:72
msgid ":func:`pow(x, y) <math.pow>`"
msgstr ":func:`pow(x, y) <math.pow>`"

#: ../../library/math.rst:72
msgid "*x* raised to the power *y*"
msgstr "*x* elevado à potência *y*"

#: ../../library/math.rst:73
msgid ":func:`sqrt(x) <sqrt>`"
msgstr ":func:`sqrt(x) <sqrt>`"

#: ../../library/math.rst:73
msgid "Square root of *x*"
msgstr "Raiz quadrada de *x*"

#: ../../library/math.rst:75
msgid "**Summation and product functions**"
msgstr "**Funções de soma e produto**"

#: ../../library/math.rst:77
msgid ":func:`dist(p, q) <dist>`"
msgstr ":func:`dist(p, q) <dist>`"

#: ../../library/math.rst:77
msgid ""
"Euclidean distance between two points *p* and *q* given as an iterable of "
"coordinates"
msgstr ""
"Distância euclidiana entre dois pontos *p* e *q* dada como um iterável de "
"coordenadas"

#: ../../library/math.rst:78
msgid ":func:`fsum(iterable) <fsum>`"
msgstr ":func:`fsum(iterable) <fsum>`"

#: ../../library/math.rst:78
msgid "Sum of values in the input *iterable*"
msgstr "Soma dos valores na entrada *iterable*"

#: ../../library/math.rst:79
msgid ":func:`hypot(*coordinates) <hypot>`"
msgstr ":func:`hypot(*coordinates) <hypot>`"

#: ../../library/math.rst:79
msgid "Euclidean norm of an iterable of coordinates"
msgstr "Norma euclidiana de um iterável de coordenadas"

#: ../../library/math.rst:80
msgid ":func:`prod(iterable, start) <prod>`"
msgstr ":func:`prod(iterable, start) <prod>`"

#: ../../library/math.rst:80
msgid "Product of elements in the input *iterable* with a *start* value"
msgstr "Produto de elementos da entrada *iterable* com um valor *start*"

#: ../../library/math.rst:81
msgid ":func:`sumprod(p, q) <sumprod>`"
msgstr ":func:`sumprod(p, q) <sumprod>`"

#: ../../library/math.rst:81
msgid "Sum of products from two iterables *p* and *q*"
msgstr "Soma dos produtos de dois iteráveis *p* e *q*"

#: ../../library/math.rst:83
msgid "**Angular conversion**"
msgstr "**Conversão angular**"

#: ../../library/math.rst:85
msgid ":func:`degrees(x) <degrees>`"
msgstr ":func:`degrees(x) <degrees>`"

#: ../../library/math.rst:85
msgid "Convert angle *x* from radians to degrees"
msgstr "Converte o ângulo *x* de radianos para graus"

#: ../../library/math.rst:86
msgid ":func:`radians(x) <radians>`"
msgstr ":func:`radians(x) <radians>`"

#: ../../library/math.rst:86
msgid "Convert angle *x* from degrees to radians"
msgstr "Converte o ângulo *x* de graus para radianos"

#: ../../library/math.rst:88
msgid "**Trigonometric functions**"
msgstr "**Funções trigonométricas**"

#: ../../library/math.rst:90
msgid ":func:`acos(x) <acos>`"
msgstr ":func:`acos(x) <acos>`"

#: ../../library/math.rst:90
msgid "Arc cosine of *x*"
msgstr "Arco cosseno de *x*"

#: ../../library/math.rst:91
msgid ":func:`asin(x) <asin>`"
msgstr ":func:`asin(x) <asin>`"

#: ../../library/math.rst:91
msgid "Arc sine of *x*"
msgstr "Arco seno de *x*/"

#: ../../library/math.rst:92
msgid ":func:`atan(x) <atan>`"
msgstr ":func:`atan(x) <atan>`"

#: ../../library/math.rst:92
msgid "Arc tangent of *x*"
msgstr "Arco tangente de *x*"

#: ../../library/math.rst:93
msgid ":func:`atan2(y, x) <atan2>`"
msgstr ":func:`atan2(y, x) <atan2>`"

#: ../../library/math.rst:93
msgid "``atan(y / x)``"
msgstr "``atan(y / x)``"

#: ../../library/math.rst:94
msgid ":func:`cos(x) <cos>`"
msgstr ":func:`cos(x) <cos>`"

#: ../../library/math.rst:94
msgid "Cosine of *x*"
msgstr "Cosseno de *x*"

#: ../../library/math.rst:95
msgid ":func:`sin(x) <sin>`"
msgstr ":func:`sin(x) <sin>`"

#: ../../library/math.rst:95
msgid "Sine of *x*"
msgstr "Seno de *x*"

#: ../../library/math.rst:96
msgid ":func:`tan(x) <tan>`"
msgstr ":func:`tan(x) <tan>`"

#: ../../library/math.rst:96
msgid "Tangent of *x*"
msgstr "Tangente de *x*"

#: ../../library/math.rst:98
msgid "**Hyperbolic functions**"
msgstr "**Funções hiperbólicas**"

#: ../../library/math.rst:100
msgid ":func:`acosh(x) <acosh>`"
msgstr ":func:`acosh(x) <acosh>`"

#: ../../library/math.rst:100
msgid "Inverse hyperbolic cosine of *x*"
msgstr "Cosseno hiperbólico inverso de *x*"

#: ../../library/math.rst:101
msgid ":func:`asinh(x) <asinh>`"
msgstr ":func:`asinh(x) <asinh>`"

#: ../../library/math.rst:101
msgid "Inverse hyperbolic sine of *x*"
msgstr "Seno hiperbólico inverso de *x*"

#: ../../library/math.rst:102
msgid ":func:`atanh(x) <atanh>`"
msgstr ":func:`atanh(x) <atanh>`"

#: ../../library/math.rst:102
msgid "Inverse hyperbolic tangent of *x*"
msgstr "Tangente hiperbólico inverso de *x*"

#: ../../library/math.rst:103
msgid ":func:`cosh(x) <cosh>`"
msgstr ":func:`cosh(x) <cosh>`"

#: ../../library/math.rst:103
msgid "Hyperbolic cosine of *x*"
msgstr "Cosseno hiperbólico de *x*"

#: ../../library/math.rst:104
msgid ":func:`sinh(x) <sinh>`"
msgstr ":func:`sinh(x) <sinh>`"

#: ../../library/math.rst:104
msgid "Hyperbolic sine of *x*"
msgstr "Seno hiperbólico de *x*"

#: ../../library/math.rst:105
msgid ":func:`tanh(x) <tanh>`"
msgstr ":func:`tanh(x) <tanh>`"

#: ../../library/math.rst:105
msgid "Hyperbolic tangent of *x*"
msgstr "Tangente hiperbólico de *x*"

#: ../../library/math.rst:107
msgid "**Special functions**"
msgstr "**Funções especiais**"

#: ../../library/math.rst:109
msgid ":func:`erf(x) <erf>`"
msgstr ":func:`erf(x) <erf>`"

#: ../../library/math.rst:109
msgid "`Error function <https://en.wikipedia.org/wiki/Error_function>`_ at *x*"
msgstr "`Função erro <https://pt.wikipedia.org/wiki/Função_erro>`_ em *x*"

#: ../../library/math.rst:110
msgid ":func:`erfc(x) <erfc>`"
msgstr ":func:`erfc(x) <erfc>`"

#: ../../library/math.rst:110
msgid ""
"`Complementary error function <https://en.wikipedia.org/wiki/"
"Error_function>`_ at *x*"
msgstr ""
"`Função erro complementar <https://pt.wikipedia.org/wiki/Função_erro>`_ em "
"*x*"

#: ../../library/math.rst:111
msgid ":func:`gamma(x) <gamma>`"
msgstr ":func:`gamma(x) <gamma>`"

#: ../../library/math.rst:111
msgid "`Gamma function <https://en.wikipedia.org/wiki/Gamma_function>`_ at *x*"
msgstr "`Função gama <https://pt.wikipedia.org/wiki/Função_gama>`_ em *x*"

#: ../../library/math.rst:112
msgid ":func:`lgamma(x) <lgamma>`"
msgstr ":func:`lgamma(x) <lgamma>`"

#: ../../library/math.rst:112
msgid ""
"Natural logarithm of the absolute value of the `Gamma function <https://en."
"wikipedia.org/wiki/Gamma_function>`_ at *x*"
msgstr ""
"Logaritmo natural do valor absoluto da `função gama <https://pt.wikipedia."
"org/wiki/Função_gama>`_ em *x*"

#: ../../library/math.rst:114
msgid "**Constants**"
msgstr "**Constantes**"

#: ../../library/math.rst:116
msgid ":data:`pi`"
msgstr ":data:`pi`"

#: ../../library/math.rst:116
msgid "*π* = 3.141592..."
msgstr "*π* = 3.141592..."

#: ../../library/math.rst:117
msgid ":data:`e`"
msgstr ":data:`e`"

#: ../../library/math.rst:117
msgid "*e* = 2.718281..."
msgstr "*e* = 2.718281..."

#: ../../library/math.rst:118
msgid ":data:`tau`"
msgstr ":data:`tau`"

#: ../../library/math.rst:118
msgid "*τ* = 2\\ *π* = 6.283185..."
msgstr "*τ* = 2\\ *π* = 6.283185..."

#: ../../library/math.rst:119
msgid ":data:`inf`"
msgstr ":data:`inf`"

#: ../../library/math.rst:119
msgid "Positive infinity"
msgstr "Infinito positivo"

#: ../../library/math.rst:120
msgid ":data:`nan`"
msgstr ":data:`nan`"

#: ../../library/math.rst:120
msgid "\"Not a number\" (NaN)"
msgstr "\"Not a number\" (NaN)"

#: ../../library/math.rst:125
msgid "Number-theoretic functions"
msgstr "Funções de teoria dos números"

#: ../../library/math.rst:129
msgid ""
"Return the number of ways to choose *k* items from *n* items without "
"repetition and without order."
msgstr ""
"Retorna o número de maneiras de escolher *k* itens de *n* itens sem "
"repetição e sem ordem."

#: ../../library/math.rst:132
msgid ""
"Evaluates to ``n! / (k! * (n - k)!)`` when ``k <= n`` and evaluates to zero "
"when ``k > n``."
msgstr ""
"Avalia para ``n! / (k! * (n - k)!)`` quando ``k <= n`` e avalia para zero "
"quando ``k > n``."

#: ../../library/math.rst:135
msgid ""
"Also called the binomial coefficient because it is equivalent to the "
"coefficient of k-th term in polynomial expansion of ``(1 + x)ⁿ``."
msgstr ""
"Também conhecido como coeficiente binomial pois equivale ao coeficiente do k-"
"ésimo termo na expansão polinomial ``(1 + x)ⁿ``"

#: ../../library/math.rst:139 ../../library/math.rst:204
msgid ""
"Raises :exc:`TypeError` if either of the arguments are not integers. Raises :"
"exc:`ValueError` if either of the arguments are negative."
msgstr ""
"Levanta :exc:`TypeError` se algum dos argumentos não for inteiro. Levanta :"
"exc:`ValueError` se algum dos argumentos for negativo."

#: ../../library/math.rst:147
msgid "Return factorial of the nonnegative integer *n*."
msgstr "Retorna fatorial do inteiro não negativo *n*."

#: ../../library/math.rst:149
msgid "Floats with integral values (like ``5.0``) are no longer accepted."
msgstr ""
"Números de ponto flutuate com valor integral (como ``5.0``) não são mais "
"aceitos."

#: ../../library/math.rst:155
msgid ""
"Return the greatest common divisor of the specified integer arguments. If "
"any of the arguments is nonzero, then the returned value is the largest "
"positive integer that is a divisor of all arguments.  If all arguments are "
"zero, then the returned value is ``0``.  ``gcd()`` without arguments returns "
"``0``."
msgstr ""
"Retorna o maior divisor comum dos argumentos inteiros especificados. Se "
"algum dos argumentos for diferente de zero, o valor retornado será o maior "
"inteiro positivo que é um divisor de todos os argumentos. Se todos os "
"argumentos forem zero, o valor retornado será ``0``. ``gcd()`` sem "
"argumentos retorna ``0``."

#: ../../library/math.rst:163
msgid ""
"Added support for an arbitrary number of arguments. Formerly, only two "
"arguments were supported."
msgstr ""
"Adicionado suporte para um número arbitrário de argumentos. Anteriormente, "
"apenas dois argumentos eram suportados."

#: ../../library/math.rst:170
msgid ""
"Return the integer square root of the nonnegative integer *n*. This is the "
"floor of the exact square root of *n*, or equivalently the greatest integer "
"*a* such that *a*\\ ² |nbsp| ≤ |nbsp| *n*."
msgstr ""
"Retorna a raiz quadrada inteira do inteiro não negativo *n*. Este é o piso "
"da raiz quadrada exata de *n*, ou equivalentemente o maior inteiro *a* tal "
"que *a*\\ ² |nbsp| ≤ |nbsp| *n*."

#: ../../library/math.rst:174
msgid ""
"For some applications, it may be more convenient to have the least integer "
"*a* such that *n* |nbsp| ≤ |nbsp| *a*\\ ², or in other words the ceiling of "
"the exact square root of *n*. For positive *n*, this can be computed using "
"``a = 1 + isqrt(n - 1)``."
msgstr ""
"Para algumas aplicações, pode ser mais conveniente ter o menor número "
"inteiro *a* tal que *n* |nbsp| ≤ |nbsp| *a*\\ ² ou, em outras palavras, o "
"teto da raiz quadrada exata de *n*. Para *n* positivo, isso pode ser "
"calculado usando ``a = 1 + isqrt(n - 1)``."

#: ../../library/math.rst:184
msgid ""
"Return the least common multiple of the specified integer arguments. If all "
"arguments are nonzero, then the returned value is the smallest positive "
"integer that is a multiple of all arguments.  If any of the arguments is "
"zero, then the returned value is ``0``.  ``lcm()`` without arguments returns "
"``1``."
msgstr ""
"Retorna o mínimo múltiplo comum dos argumentos inteiros especificados. Se "
"todos os argumentos forem diferentes de zero, o valor retornado será o menor "
"inteiro positivo que é um múltiplo de todos os argumentos. Se algum dos "
"argumentos for zero, o valor retornado será ``0``. ``lcm()`` sem argumentos "
"retorna ``1``."

#: ../../library/math.rst:195
msgid ""
"Return the number of ways to choose *k* items from *n* items without "
"repetition and with order."
msgstr ""
"Retorna o número de maneiras de escolher *k* itens de *n* itens sem "
"repetição e com ordem."

#: ../../library/math.rst:198
msgid ""
"Evaluates to ``n! / (n - k)!`` when ``k <= n`` and evaluates to zero when "
"``k > n``."
msgstr ""
"Avalia para ``n! / (n - k)!`` quando ``k <= n`` e avalia para zero quando "
"``k > n``."

#: ../../library/math.rst:201
msgid ""
"If *k* is not specified or is ``None``, then *k* defaults to *n* and the "
"function returns ``n!``."
msgstr ""
"Se *k* não for especificado ou for ``None``, *k* usará o padrão *n* e a "
"função retornará ``n!``."

#: ../../library/math.rst:211
msgid "Floating point arithmetic"
msgstr "Arimética de ponto flutuante"

#: ../../library/math.rst:215
msgid ""
"Return the ceiling of *x*, the smallest integer greater than or equal to "
"*x*. If *x* is not a float, delegates to :meth:`x.__ceil__ <object."
"__ceil__>`, which should return an :class:`~numbers.Integral` value."
msgstr ""
"Retorna o teto de *x*, o menor inteiro maior ou igual que *x*. Se *x* não é "
"um float, delega para :meth:`x.__ceil__ <object.__ceil__>`, que deve "
"retornar um valor do tipo :class:`~numbers.Integral`."

#: ../../library/math.rst:222
msgid "Return the absolute value of *x*."
msgstr "Retorna o valor absoluto de *x*."

#: ../../library/math.rst:227
msgid ""
"Return the floor of *x*, the largest integer less than or equal to *x*.  If "
"*x* is not a float, delegates to :meth:`x.__floor__ <object.__floor__>`, "
"which should return an :class:`~numbers.Integral` value."
msgstr ""
"Retorna o chão de *x*, o maior inteiro menor ou igual a *x*. Se *x* não é um "
"ponto flutuante, delega para :meth:`x.__floor__ <object.__floor__>`, que "
"deve retornar um valor do tipo :class:`~numbers.Integral`"

#: ../../library/math.rst:234
msgid ""
"Fused multiply-add operation. Return ``(x * y) + z``, computed as though "
"with infinite precision and range followed by a single round to the "
"``float`` format. This operation often provides better accuracy than the "
"direct expression ``(x * y) + z``."
msgstr ""
"Operação de multiplicação-adição combinada. Retorna ``(x * y) + z``, "
"calculado de forma a obter o mesmo resultado que seria obtido se o cálculo "
"desfrutasse de precisão e limites infinitos, seguido de um único "
"arredondamento para o formato ``float``. Esta operação frequentemente "
"oferece acurácia melhor do que a expressão direta ``(x * y) + z`` ofereceria."

#: ../../library/math.rst:239
msgid ""
"This function follows the specification of the fusedMultiplyAdd operation "
"described in the IEEE 754 standard. The standard leaves one case "
"implementation-defined, namely the result of ``fma(0, inf, nan)`` and "
"``fma(inf, 0, nan)``. In these cases, ``math.fma`` returns a NaN, and does "
"not raise any exception."
msgstr ""
"Esta função segue a especificação da operação fusedMultiplyAdd descrita no "
"padrão IEEE 754. O padrão deixa um caso a ser definido pela implementação, "
"que são os resultados de ``fma(0, inf, nan)`` e ``fma(inf, 0, nan)``. Nestes "
"casos, ``math.fma`` retorna NaN, e não levanta nenhuma exceção."

#: ../../library/math.rst:250
msgid ""
"Return the floating-point remainder of ``x / y``, as defined by the platform "
"C library function ``fmod(x, y)``. Note that the Python expression ``x % y`` "
"may not return the same result.  The intent of the C standard is that "
"``fmod(x, y)`` be exactly (mathematically; to infinite precision) equal to "
"``x - n*y`` for some integer *n* such that the result has the same sign as "
"*x* and magnitude less than ``abs(y)``.  Python's ``x % y`` returns a result "
"with the sign of *y* instead, and may not be exactly computable for float "
"arguments. For example, ``fmod(-1e-100, 1e100)`` is ``-1e-100``, but the "
"result of Python's ``-1e-100 % 1e100`` is ``1e100-1e-100``, which cannot be "
"represented exactly as a float, and rounds to the surprising ``1e100``.  For "
"this reason, function :func:`fmod` is generally preferred when working with "
"floats, while Python's ``x % y`` is preferred when working with integers."
msgstr ""
"Retorna o resto ponto flutuante de ``x / y``, conforme definido pela função "
"``fmod(x, y)`` da biblioteca C da plataforma. Observe que a expressão Python "
"``x % y`` pode não retornar o mesmo resultado. A intenção do padrão C é que "
"``fmod(x, y)`` seja exatamente (matematicamente; com precisão infinita) "
"igual a ``x - n*y`` para algum inteiro *n* de modo que o resultado tenha o "
"mesmo sinal que *x* e magnitude menor que ``abs(y)``. O ``x % y`` do Python "
"retorna um resultado com o sinal de *y*, e pode não ser exatamente "
"computável para argumentos de ponto flutuante. Por exemplo, ``fmod(-1e-100, "
"1e100)`` é ``-1e-100``, mas o resultado de ``-1e-100 % 1e100`` do Python é "
"``1e100-1e-100``, que não pode ser representado exatamente como um ponto "
"flutuante, e é arredondado para o surpreendente ``1e100``. Por esta razão, a "
"função :func:`fmod` é geralmente preferida ao trabalhar com pontos "
"flutuantes, enquanto o ``x % y`` do Python é preferido ao trabalhar com "
"inteiros."

#: ../../library/math.rst:266
msgid ""
"Return the fractional and integer parts of *x*.  Both results carry the sign "
"of *x* and are floats."
msgstr ""
"Retorna as partes fracionárias e inteiras de *x*. Ambos os resultados "
"carregam o sinal de *x* e são pontos flutuantes."

#: ../../library/math.rst:269
msgid ""
"Note that :func:`modf` has a different call/return pattern than its C "
"equivalents: it takes a single argument and return a pair of values, rather "
"than returning its second return value through an 'output parameter' (there "
"is no such thing in Python)."
msgstr ""
"Observe que :func:`modf` tem um padrão de chamada/retorno diferente de seu "
"equivalente C: elas pegam um único argumento e retornam um par de valores, "
"ao invés de retornar seu segundo valor de retorno por meio de um \"parâmetro "
"de saída\" (não existe tal coisa em Python)."

#: ../../library/math.rst:277
msgid ""
"Return the IEEE 754-style remainder of *x* with respect to *y*.  For finite "
"*x* and finite nonzero *y*, this is the difference ``x - n*y``, where ``n`` "
"is the closest integer to the exact value of the quotient ``x / y``.  If "
"``x / y`` is exactly halfway between two consecutive integers, the nearest "
"*even* integer is used for ``n``.  The remainder ``r = remainder(x, y)`` "
"thus always satisfies ``abs(r) <= 0.5 * abs(y)``."
msgstr ""
"Retorna o resto no estilo IEEE 754 de *x* em relação a *y*. Para o finito "
"*x* e o finito diferente de zero *y*, esta é a diferença ``x - n*y``, onde "
"``n`` é o número inteiro mais próximo do valor exato do quociente ``x / "
"y`` . Se ``x / y`` está exatamente no meio do caminho entre dois inteiros "
"consecutivos, o inteiro *par* mais próximo é usado para ``n``. O resto ``r = "
"remainder(x, y)`` assim sempre satisfaz ``abs(r) <= 0.5 * abs(y)``."

#: ../../library/math.rst:284
msgid ""
"Special cases follow IEEE 754: in particular, ``remainder(x, math.inf)`` is "
"*x* for any finite *x*, and ``remainder(x, 0)`` and ``remainder(math.inf, "
"x)`` raise :exc:`ValueError` for any non-NaN *x*. If the result of the "
"remainder operation is zero, that zero will have the same sign as *x*."
msgstr ""
"Casos especiais seguem IEEE 754: em particular, ``remainder(x, math.inf)`` é "
"*x* para qualquer *x* finito, e ``remainder(x, 0)`` e ``remainder(math.inf, "
"x)`` levantam :exc:`ValueError` para qualquer *x* não NaN. Se o resultado da "
"operação ``remainder`` for zero, esse zero terá o mesmo sinal de *x*."

#: ../../library/math.rst:290
msgid ""
"On platforms using IEEE 754 binary floating point, the result of this "
"operation is always exactly representable: no rounding error is introduced."
msgstr ""
"Em plataformas que usam ponto flutuante binário do IEEE 754, o resultado "
"dessa operação é sempre exatamente representável: nenhum erro de "
"arredondamento é introduzido."

#: ../../library/math.rst:298
msgid ""
"Return *x* with the fractional part removed, leaving the integer part.  This "
"rounds toward 0: ``trunc()`` is equivalent to :func:`floor` for positive "
"*x*, and equivalent to :func:`ceil` for negative *x*. If *x* is not a float, "
"delegates to :meth:`x.__trunc__ <object.__trunc__>`, which should return an :"
"class:`~numbers.Integral` value."
msgstr ""
"Retorna *x* com a parte fracionária removida, deixando a parte inteira. Isso "
"arredonda para 0: ``trunc()`` é equivalente a :func:`floor` para *x* "
"positivos, e equivalentes a :func:`ceil` para *x* negativos. Se *x* não é um "
"ponto flutuante, então delega para :meth:`x.__trunc__ <object.__trunc__>`, "
"cujo qual deve retornar um valor do tipo :class:`~numbers.Integral`."

#: ../../library/math.rst:305
msgid ""
"For the :func:`ceil`, :func:`floor`, and :func:`modf` functions, note that "
"*all* floating-point numbers of sufficiently large magnitude are exact "
"integers. Python floats typically carry no more than 53 bits of precision "
"(the same as the platform C double type), in which case any float *x* with "
"``abs(x) >= 2**52`` necessarily has no fractional bits."
msgstr ""
"Para as funções :func:`ceil`, :func:`floor` e :func:`modf`, observe que "
"*todos* os números de ponto flutuante de magnitude suficientemente grande "
"são inteiros exatos. Os pontos flutuantes do Python normalmente não carregam "
"mais do que 53 bits de precisão (o mesmo que o tipo duplo da plataforma C), "
"caso em que qualquer ponto flutuante *x* com ``abs(x) >= 2**52`` "
"necessariamente não tem bits fracionários."

#: ../../library/math.rst:313
msgid "Floating point manipulation functions"
msgstr "Funções de manipulação de ponto flutuante"

#: ../../library/math.rst:317
msgid ""
"Return a float with the magnitude (absolute value) of *x* but the sign of "
"*y*.  On platforms that support signed zeros, ``copysign(1.0, -0.0)`` "
"returns *-1.0*."
msgstr ""
"Retorna um ponto flutuante com a magnitude (valor absoluto) de *x*, mas o "
"sinal de *y*. Em plataformas que suportam zeros com sinal, ``copysign(1.0, "
"-0.0)`` retorna *-1.0*."

#: ../../library/math.rst:324
msgid ""
"Return the mantissa and exponent of *x* as the pair ``(m, e)``.  *m* is a "
"float and *e* is an integer such that ``x == m * 2**e`` exactly. If *x* is "
"zero, returns ``(0.0, 0)``, otherwise ``0.5 <= abs(m) < 1``.  This is used "
"to \"pick apart\" the internal representation of a float in a portable way."
msgstr ""
"Retorna a mantissa e o expoente de *x* como o par ``(m, e)``. *m* é um ponto "
"flutuante e *e* é um inteiro tal que ``x == m * 2**e`` exatamente. Se *x* "
"for zero, retorna ``(0.0, 0)``, caso contrário, ``0.5 <= abs(m) < 1``. Isso "
"é usado para \"separar\" a representação interna de um ponto flutuante de "
"forma portátil."

#: ../../library/math.rst:329
msgid ""
"Note that :func:`frexp` has a different call/return pattern than its C "
"equivalents: it takes a single argument and return a pair of values, rather "
"than returning its second return value through an 'output parameter' (there "
"is no such thing in Python)."
msgstr ""
"Observe que :func:`frexp` tem um padrão de chamada/retorno diferente de seu "
"equivalente C: elas pegam um único argumento e retornam um par de valores, "
"ao invés de retornar seu segundo valor de retorno por meio de um \"parâmetro "
"de saída\" (não existe tal coisa em Python)."

#: ../../library/math.rst:336
msgid ""
"Return ``True`` if the values *a* and *b* are close to each other and "
"``False`` otherwise."
msgstr ""
"Retorna ``True`` se os valores *a* e *b* estiverem próximos e ``False`` caso "
"contrário."

#: ../../library/math.rst:339
msgid ""
"Whether or not two values are considered close is determined according to "
"given absolute and relative tolerances.  If no errors occur, the result will "
"be: ``abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)``."
msgstr ""
"Se dois valores são considerados próximos ou não é determinado de acordo com "
"tolerâncias absolutas e relativas fornecidas. Se nenhum erro ocorrer, o "
"resultado será: ``abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)``."

#: ../../library/math.rst:343
msgid ""
"*rel_tol* is the relative tolerance -- it is the maximum allowed difference "
"between *a* and *b*, relative to the larger absolute value of *a* or *b*. "
"For example, to set a tolerance of 5%, pass ``rel_tol=0.05``.  The default "
"tolerance is ``1e-09``, which assures that the two values are the same "
"within about 9 decimal digits.  *rel_tol* must be nonnegative and less than "
"``1.0``."
msgstr ""
"*rel_tol* é a tolerância relativa -- é a diferença máxima permitida entre "
"*a* e *b*, em relação ao maior valor absoluto de *a* ou *b*. Por exemplo, "
"para definir uma tolerância de 5%, passe ``rel_tol=0.05``. A tolerância "
"padrão é ``1e-09``, o que garante que os dois valores sejam iguais em cerca "
"de 9 dígitos decimais. *rel_tol* deve ser não negativo e menor que ``1.0``."

#: ../../library/math.rst:350
msgid ""
"*abs_tol* is the absolute tolerance; it defaults to ``0.0`` and it must be "
"nonnegative.  When comparing ``x`` to ``0.0``, ``isclose(x, 0)`` is computed "
"as ``abs(x) <= rel_tol  * abs(x)``, which is ``False`` for any nonzero ``x`` "
"and *rel_tol* less than ``1.0``.  So add an appropriate positive *abs_tol* "
"argument to the call."
msgstr ""
"*abs_tol* é a tolerância absoluta; o padrão é ``0.0`` e deve ser não "
"negativo. Ao comparar ``x`` com ``0.0``, ``isclose(x, 0)`` é computado como "
"``abs(x) <= rel_tol * abs(x)``, que é ``False`` para qualquer ``x`` não zero "
"e *rel_tol* menor que ``1.0``. Então adicione um argumento *abs_tol* "
"positivo apropriado à chamada."

#: ../../library/math.rst:356
msgid ""
"The IEEE 754 special values of ``NaN``, ``inf``, and ``-inf`` will be "
"handled according to IEEE rules.  Specifically, ``NaN`` is not considered "
"close to any other value, including ``NaN``.  ``inf`` and ``-inf`` are only "
"considered close to themselves."
msgstr ""
"Os valores especiais do IEEE 754 de ``NaN``, ``inf`` e ``-inf`` serão "
"tratados de acordo com as regras do IEEE. Especificamente, ``NaN`` não é "
"considerado próximo a qualquer outro valor, incluindo ``NaN``. ``inf`` e ``-"
"inf`` são considerados apenas próximos a si mesmos."

#: ../../library/math.rst:365
msgid ":pep:`485` -- A function for testing approximate equality"
msgstr ":pep:`485` -- Uma função para testar igualdade aproximada"

#: ../../library/math.rst:370
msgid ""
"Return ``True`` if *x* is neither an infinity nor a NaN, and ``False`` "
"otherwise.  (Note that ``0.0`` *is* considered finite.)"
msgstr ""
"Retorna ``True`` se *x* não for um infinito nem um NaN, e ``False`` caso "
"contrário.  (Observe que ``0.0`` *é* considerado finito.)"

#: ../../library/math.rst:378
msgid ""
"Return ``True`` if *x* is a positive or negative infinity, and ``False`` "
"otherwise."
msgstr ""
"Retorna ``True`` se *x* for um infinito positivo ou negativo, e ``False`` "
"caso contrário."

#: ../../library/math.rst:384
msgid ""
"Return ``True`` if *x* is a NaN (not a number), and ``False`` otherwise."
msgstr ""
"Retorna ``True`` se *x* for um NaN (não um número), e ``False`` caso "
"contrário."

#: ../../library/math.rst:389
msgid ""
"Return ``x * (2**i)``.  This is essentially the inverse of function :func:"
"`frexp`."
msgstr ""
"Retorna ``x * (2**i)``. Este é essencialmente o inverso da função :func:"
"`frexp`."

#: ../../library/math.rst:395
msgid "Return the floating-point value *steps* steps after *x* towards *y*."
msgstr ""
"Retorna o valor de ponto flutuante com *steps* passos após *x* em direção a "
"*y*."

#: ../../library/math.rst:397
msgid "If *x* is equal to *y*, return *y*, unless *steps* is zero."
msgstr "Se *x* for igual a *y*, retorna *y*, a menos que *steps* seja zero."

#: ../../library/math.rst:399
msgid "Examples:"
msgstr "Exemplos:"

#: ../../library/math.rst:401
msgid "``math.nextafter(x, math.inf)`` goes up: towards positive infinity."
msgstr "``math.nextafter(x, math.inf)`` sobe: em direção ao infinito positivo."

#: ../../library/math.rst:402
msgid "``math.nextafter(x, -math.inf)`` goes down: towards minus infinity."
msgstr "``math.nextafter(x, -math.inf)`` desce: em direção ao menos infinito."

#: ../../library/math.rst:403
msgid "``math.nextafter(x, 0.0)`` goes towards zero."
msgstr "``math.nextafter(x, 0.0)`` vai em direção a zero."

#: ../../library/math.rst:404
msgid "``math.nextafter(x, math.copysign(math.inf, x))`` goes away from zero."
msgstr "``math.nextafter(x, math.copysign(math.inf, x))`` se afasta do zero."

#: ../../library/math.rst:406
msgid "See also :func:`math.ulp`."
msgstr "Veja também :func:`math.ulp.`"

#: ../../library/math.rst:410
msgid "Added the *steps* argument."
msgstr "Adicionado o argumento *steps*."

#: ../../library/math.rst:416
msgid "Return the value of the least significant bit of the float *x*:"
msgstr "Retorna o valor do bit menos significativo do ponto flutuante *x*:"

#: ../../library/math.rst:418
msgid "If *x* is a NaN (not a number), return *x*."
msgstr "Se *x* for um NaN (não um número), retorna *x*."

#: ../../library/math.rst:419
msgid "If *x* is negative, return ``ulp(-x)``."
msgstr "Se *x* for negativo, retorna ``ulp(-x)``."

#: ../../library/math.rst:420
msgid "If *x* is a positive infinity, return *x*."
msgstr "Se *x* for um infinito positivo, retorna *x*."

#: ../../library/math.rst:421
msgid ""
"If *x* is equal to zero, return the smallest positive *denormalized* "
"representable float (smaller than the minimum positive *normalized* float, :"
"data:`sys.float_info.min <sys.float_info>`)."
msgstr ""
"Se *x* for igual a zero, retorna o menor valor flutuante positivo "
"*desnormalizado* representável (menor que o ponto flutuante de valor mínimo "
"positivo *normalizado*, :data:`sys.float_info.min <sys.float_info>`)."

#: ../../library/math.rst:424
msgid ""
"If *x* is equal to the largest positive representable float, return the "
"value of the least significant bit of *x*, such that the first float smaller "
"than *x* is ``x - ulp(x)``."
msgstr ""
"Se *x* for igual ao maior ponto flutuante positivo representável, retorna o "
"valor do bit menos significativo de *x*, tal que o primeiro ponto flutuante "
"menor que *x* seja ``x - ulp(x)``."

#: ../../library/math.rst:427
msgid ""
"Otherwise (*x* is a positive finite number), return the value of the least "
"significant bit of *x*, such that the first float bigger than *x* is ``x + "
"ulp(x)``."
msgstr ""
"Caso contrário (*x* é um número finito positivo), retorna o valor do bit "
"menos significativo de *x*, de modo que o primeiro ponto flutuante maior que "
"*x* seja ``x + ulp(x)``."

#: ../../library/math.rst:431
msgid "ULP stands for \"Unit in the Last Place\"."
msgstr ""
"ULP significa \"Unit in the Last Place\" ou, em português, unidade na última "
"posição."

#: ../../library/math.rst:433
msgid ""
"See also :func:`math.nextafter` and :data:`sys.float_info.epsilon <sys."
"float_info>`."
msgstr ""
"Veja também :func:`math.nextafter` e :data:`sys.float_info.epsilon <sys."
"float_info>`."

#: ../../library/math.rst:440
msgid "Power, exponential and logarithmic functions"
msgstr "Funções de potências, exponenciais e logarítmicas"

#: ../../library/math.rst:444
msgid "Return the cube root of *x*."
msgstr "Retorna a raiz cúbica de *x*."

#: ../../library/math.rst:451
msgid ""
"Return *e* raised to the power *x*, where *e* = 2.718281... is the base of "
"natural logarithms.  This is usually more accurate than ``math.e ** x`` or "
"``pow(math.e, x)``."
msgstr ""
"Retorna *e* elevado à potência *x*, onde *e* = 2.718281... é a base dos "
"logaritmos naturais. Isso geralmente é mais preciso do que ``math.e ** x`` "
"ou ``pow(math.e, x)``."

#: ../../library/math.rst:458
msgid "Return *2* raised to the power *x*."
msgstr "Retorna *2* elevado a *x*"

#: ../../library/math.rst:465
msgid ""
"Return *e* raised to the power *x*, minus 1.  Here *e* is the base of "
"natural logarithms.  For small floats *x*, the subtraction in ``exp(x) - 1`` "
"can result in a `significant loss of precision <https://en.wikipedia.org/"
"wiki/Loss_of_significance>`_\\; the :func:`expm1` function provides a way to "
"compute this quantity to full precision:"
msgstr ""
"Retorna *e* elevado à potência *x*, menos 1. Aqui *e* é a base dos "
"logaritmos naturais. Para pequenos pontos flutuantes *x*, a subtração em "
"``exp(x) - 1`` pode resultar em uma `perda significativa de precisão "
"<https://en.wikipedia.org/wiki/Loss_of_significance>`_\\; a função :func:"
"`expm1` fornece uma maneira de calcular essa quantidade com precisão total:"

#: ../../library/math.rst:482
msgid "With one argument, return the natural logarithm of *x* (to base *e*)."
msgstr "Com um argumento, retorna o logaritmo natural de *x* (para base *e*)."

#: ../../library/math.rst:484
msgid ""
"With two arguments, return the logarithm of *x* to the given *base*, "
"calculated as ``log(x)/log(base)``."
msgstr ""
"Com dois argumentos, retorna o logaritmo de *x* para a *base* fornecida, "
"calculada como ``log(x)/log(base)``."

#: ../../library/math.rst:490
msgid ""
"Return the natural logarithm of *1+x* (base *e*). The result is calculated "
"in a way which is accurate for *x* near zero."
msgstr ""
"Retorna o logaritmo natural de *1+x* (base *e*). O resultado é calculado de "
"forma precisa para *x* próximo a zero."

#: ../../library/math.rst:496
msgid ""
"Return the base-2 logarithm of *x*. This is usually more accurate than "
"``log(x, 2)``."
msgstr ""
"Retorna o logaritmo de base 2 de *x*. Isso geralmente é mais preciso do que "
"``log(x, 2)``."

#: ../../library/math.rst:503
msgid ""
":meth:`int.bit_length` returns the number of bits necessary to represent an "
"integer in binary, excluding the sign and leading zeros."
msgstr ""
":meth:`int.bit_length` retorna o número de bits necessários para representar "
"um inteiro em binário, excluindo o sinal e os zeros à esquerda."

#: ../../library/math.rst:509
msgid ""
"Return the base-10 logarithm of *x*.  This is usually more accurate than "
"``log(x, 10)``."
msgstr ""
"Retorna o logaritmo de base 10 de *x*. Isso geralmente é mais preciso do que "
"``log(x, 10)``."

#: ../../library/math.rst:515
msgid ""
"Return *x* raised to the power *y*.  Exceptional cases follow the IEEE 754 "
"standard as far as possible.  In particular, ``pow(1.0, x)`` and ``pow(x, "
"0.0)`` always return ``1.0``, even when *x* is a zero or a NaN.  If both *x* "
"and *y* are finite, *x* is negative, and *y* is not an integer then ``pow(x, "
"y)`` is undefined, and raises :exc:`ValueError`."
msgstr ""
"Retorna *x* elevado a potência de *y*. Exceções seguem o padrão IEEE 754 o "
"máximo possível. ``pow(1.0, x)`` e ``pow(x, 0.0)`` em particular sempre "
"retornam ``1.0``, mesmo quando *x* é ZERO ou NaN. Se ambos *x* e *y* são "
"números finitos, *x* é negativo, e *y* não é um inteiro então ``pow(x, y)`` "
"é indefinido e levanta :exc:`ValueError`."

#: ../../library/math.rst:522
msgid ""
"Unlike the built-in ``**`` operator, :func:`math.pow` converts both its "
"arguments to type :class:`float`.  Use ``**`` or the built-in :func:`pow` "
"function for computing exact integer powers."
msgstr ""
"Ao contrário do operador embutido ``**``, :func:`math.pow` converte ambos os "
"seus argumentos para o tipo :class:`float`. Use ``**`` ou a função embutida :"
"func:`pow` para calcular potências inteiras exatas."

#: ../../library/math.rst:526
msgid ""
"The special cases ``pow(0.0, -inf)`` and ``pow(-0.0, -inf)`` were changed to "
"return ``inf`` instead of raising :exc:`ValueError`, for consistency with "
"IEEE 754."
msgstr ""
"Os casos especiais ``pow(0.0, -inf)`` e ``pow(-0.0, -inf)`` foram alterados "
"para retornar ``inf`` ao invés de levantar :exc:`ValueError`, para ter "
"consistência com a IEEE 754."

#: ../../library/math.rst:534
msgid "Return the square root of *x*."
msgstr "Retorna a raiz quadrada de *x*."

#: ../../library/math.rst:538
msgid "Summation and product functions"
msgstr "Funções de soma e produto"

#: ../../library/math.rst:542
msgid ""
"Return the Euclidean distance between two points *p* and *q*, each given as "
"a sequence (or iterable) of coordinates.  The two points must have the same "
"dimension."
msgstr ""
"Retorna a distância euclidiana entre dois pontos *p* e *q*, cada um dado "
"como uma sequência (ou iterável) de coordenadas. Os dois pontos devem ter a "
"mesma dimensão."

#: ../../library/math.rst:546 ../../library/math.rst:607
msgid "Roughly equivalent to::"
msgstr "Aproximadamente equivalente a::"

#: ../../library/math.rst:548
msgid "sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))"
msgstr "sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))"

#: ../../library/math.rst:555
msgid ""
"Return an accurate floating-point sum of values in the iterable.  Avoids "
"loss of precision by tracking multiple intermediate partial sums."
msgstr ""
"Retorna uma soma precisa dos valores de ponto flutuante no iterável. Evita "
"perda de precisão rastreando várias somas parciais intermediárias."

#: ../../library/math.rst:558
msgid ""
"The algorithm's accuracy depends on IEEE-754 arithmetic guarantees and the "
"typical case where the rounding mode is half-even.  On some non-Windows "
"builds, the underlying C library uses extended precision addition and may "
"occasionally double-round an intermediate sum causing it to be off in its "
"least significant bit."
msgstr ""
"A precisão do algoritmo depende das garantias aritméticas do IEEE-754 e do "
"caso típico em que o modo de arredondamento é meio par. Em algumas "
"compilações que não são do Windows, a biblioteca C subjacente usa adição de "
"precisão estendida e pode ocasionalmente arredondar uma soma intermediária "
"fazendo com que ela introduza um erro no bit menos significativo."

#: ../../library/math.rst:564
msgid ""
"For further discussion and two alternative approaches, see the `ASPN "
"cookbook recipes for accurate floating-point summation <https://code."
"activestate.com/recipes/393090-binary-floating-point-summation-accurate-to-"
"full-p/>`_\\."
msgstr ""
"Para uma discussão mais aprofundada e duas abordagens alternativas, consulte "
"o `ASPN cookbook recipes for accurate floating point summation <https://code."
"activestate.com/recipes/393090-binary-floating-point-summation-accurate-to-"
"full-p/>`_\\."

#: ../../library/math.rst:571
msgid ""
"Return the Euclidean norm, ``sqrt(sum(x**2 for x in coordinates))``. This is "
"the length of the vector from the origin to the point given by the "
"coordinates."
msgstr ""
"Retorna a norma euclidiana, ``sqrt(sum(x**2 for x in coordinates))``. Este é "
"o comprimento do vetor da origem até o ponto dado pelas coordenadas."

#: ../../library/math.rst:575
msgid ""
"For a two dimensional point ``(x, y)``, this is equivalent to computing the "
"hypotenuse of a right triangle using the Pythagorean theorem, ``sqrt(x*x + "
"y*y)``."
msgstr ""
"Para um ponto bidimensional ``(x, y)``, isso é equivalente a calcular a "
"hipotenusa de um triângulo retângulo usando o teorema de Pitágoras, "
"``sqrt(x*x + y*y)``."

#: ../../library/math.rst:579
msgid ""
"Added support for n-dimensional points. Formerly, only the two dimensional "
"case was supported."
msgstr ""
"Adicionado suporte para pontos n-dimensionais. Anteriormente, apenas o caso "
"bidimensional era suportado."

#: ../../library/math.rst:583
msgid ""
"Improved the algorithm's accuracy so that the maximum error is under 1 ulp "
"(unit in the last place).  More typically, the result is almost always "
"correctly rounded to within 1/2 ulp."
msgstr ""
"Melhorou a precisão do algoritmo para que o erro máximo seja inferior a 1 "
"ulp (unidade no último lugar). Mais tipicamente, o resultado é quase sempre "
"arredondado corretamente para 1/2 ulp."

#: ../../library/math.rst:591
msgid ""
"Calculate the product of all the elements in the input *iterable*. The "
"default *start* value for the product is ``1``."
msgstr ""
"Calcula o produto de todos os elementos na entrada *iterable*. O valor "
"*start* padrão para o produto é ``1``."

#: ../../library/math.rst:594
msgid ""
"When the iterable is empty, return the start value.  This function is "
"intended specifically for use with numeric values and may reject non-numeric "
"types."
msgstr ""
"Quando o iterável estiver vazio, retorna o valor de start. Esta função deve "
"ser usada especificamente com valores numéricos e pode rejeitar tipos não "
"numéricos."

#: ../../library/math.rst:603
msgid "Return the sum of products of values from two iterables *p* and *q*."
msgstr "Retorna a soma dos produtos dos valores de dois iteráveis *p* e *q*."

#: ../../library/math.rst:605
msgid "Raises :exc:`ValueError` if the inputs do not have the same length."
msgstr ""
"Levanta :exc:`ValueError` se as entradas não tiverem o mesmo comprimento."

#: ../../library/math.rst:609
msgid "sum(map(operator.mul, p, q, strict=True))"
msgstr "sum(map(operator.mul, p, q, strict=True))"

#: ../../library/math.rst:611
msgid ""
"For float and mixed int/float inputs, the intermediate products and sums are "
"computed with extended precision."
msgstr ""
"Para entradas float e mistas int/float, os produtos intermediários e as "
"somas são calculados com precisão estendida."

#: ../../library/math.rst:618
msgid "Angular conversion"
msgstr "Conversão angular"

#: ../../library/math.rst:622
msgid "Convert angle *x* from radians to degrees."
msgstr "Converte o ângulo *x* de radianos para graus."

#: ../../library/math.rst:627
msgid "Convert angle *x* from degrees to radians."
msgstr "Converte o ângulo *x* de graus para radianos."

#: ../../library/math.rst:631
msgid "Trigonometric functions"
msgstr "Funções trigonométricas"

#: ../../library/math.rst:635
msgid ""
"Return the arc cosine of *x*, in radians. The result is between ``0`` and "
"``pi``."
msgstr ""
"Retorna o arco cosseno de *x*, em radianos. O resultado está entre ``0`` e "
"``pi``."

#: ../../library/math.rst:641
msgid ""
"Return the arc sine of *x*, in radians. The result is between ``-pi/2`` and "
"``pi/2``."
msgstr ""
"Retorna o arco seno de *x*, em radianos. O resultado está entre ``-pi/2`` e "
"``pi/2``."

#: ../../library/math.rst:647
msgid ""
"Return the arc tangent of *x*, in radians. The result is between ``-pi/2`` "
"and ``pi/2``."
msgstr ""
"Retorna o arco tangente de *x*, em radianos. O resultado está entre ``-"
"pi/2`` e ``pi/2``."

#: ../../library/math.rst:653
msgid ""
"Return ``atan(y / x)``, in radians. The result is between ``-pi`` and "
"``pi``. The vector in the plane from the origin to point ``(x, y)`` makes "
"this angle with the positive X axis. The point of :func:`atan2` is that the "
"signs of both inputs are known to it, so it can compute the correct quadrant "
"for the angle. For example, ``atan(1)`` and ``atan2(1, 1)`` are both "
"``pi/4``, but ``atan2(-1, -1)`` is ``-3*pi/4``."
msgstr ""
"Retorna ``atan(y / x)``, em radianos. O resultado está entre ``-pi`` e "
"``pi``. O vetor no plano da origem ao ponto ``(x, y)`` faz este ângulo com o "
"eixo X positivo. O ponto de :func:`atan2` é que os sinais de ambas as "
"entradas são conhecidos por ele, então ele pode calcular o quadrante correto "
"para o ângulo. Por exemplo, ``atan(1)`` e ``atan2(1, 1)`` são ambos "
"``pi/4``, mas ``atan2(-1, -1)`` é ``-3*pi/4``."

#: ../../library/math.rst:663
msgid "Return the cosine of *x* radians."
msgstr "Retorna o cosseno de *x* radianos."

#: ../../library/math.rst:668
msgid "Return the sine of *x* radians."
msgstr "Retorna o seno de *x* radianos."

#: ../../library/math.rst:673
msgid "Return the tangent of *x* radians."
msgstr "Retorna o tangente de *x* radianos."

#: ../../library/math.rst:677
msgid "Hyperbolic functions"
msgstr "Funções hiperbólicas"

#: ../../library/math.rst:679
msgid ""
"`Hyperbolic functions <https://en.wikipedia.org/wiki/Hyperbolic_functions>`_ "
"are analogs of trigonometric functions that are based on hyperbolas instead "
"of circles."
msgstr ""
"`Funções hiperbólicas <https://en.wikipedia.org/wiki/Hyperbolic_functions>`_ "
"são análogas às funções trigonométricas baseadas em hipérboles em vez de "
"círculos."

#: ../../library/math.rst:685
msgid "Return the inverse hyperbolic cosine of *x*."
msgstr "Retorna o cosseno hiperbólico inverso de *x*."

#: ../../library/math.rst:690
msgid "Return the inverse hyperbolic sine of *x*."
msgstr "Retorna o seno hiperbólico inverso de *x*."

#: ../../library/math.rst:695
msgid "Return the inverse hyperbolic tangent of *x*."
msgstr "Retorna a tangente hiperbólica inversa de *x*."

#: ../../library/math.rst:700
msgid "Return the hyperbolic cosine of *x*."
msgstr "Retorna o cosseno hiperbólico de *x*."

#: ../../library/math.rst:705
msgid "Return the hyperbolic sine of *x*."
msgstr "Retorna o seno hiperbólico de *x*."

#: ../../library/math.rst:710
msgid "Return the hyperbolic tangent of *x*."
msgstr "Retorna a tangente hiperbólica de *x*."

#: ../../library/math.rst:714
msgid "Special functions"
msgstr "Funções especiais"

#: ../../library/math.rst:718
msgid ""
"Return the `error function <https://en.wikipedia.org/wiki/Error_function>`_ "
"at *x*."
msgstr ""
"Retorna a `função erro <https://pt.wikipedia.org/wiki/Função_erro>`_ em *x*."

#: ../../library/math.rst:721
msgid ""
"The :func:`erf` function can be used to compute traditional statistical "
"functions such as the `cumulative standard normal distribution <https://en."
"wikipedia.org/wiki/Cumulative_distribution_function>`_::"
msgstr ""
"A função :func:`erf` pode ser usada para calcular funções estatísticas "
"tradicionais, como a `distribuição normal padrão cumulativa <https://en."
"wikipedia.org/wiki/Cumulative_distribution_function>`_::"

#: ../../library/math.rst:725
msgid ""
"def phi(x):\n"
"    'Cumulative distribution function for the standard normal distribution'\n"
"    return (1.0 + erf(x / sqrt(2.0))) / 2.0"
msgstr ""
"def phi(x):\n"
"    'Função de distribuição cumulativa para a distribuição normal padrão.'\n"
"    return (1.0 + erf(x / sqrt(2.0))) / 2.0"

#: ../../library/math.rst:734
msgid ""
"Return the complementary error function at *x*.  The `complementary error "
"function <https://en.wikipedia.org/wiki/Error_function>`_ is defined as "
"``1.0 - erf(x)``.  It is used for large values of *x* where a subtraction "
"from one would cause a `loss of significance <https://en.wikipedia.org/wiki/"
"Loss_of_significance>`_\\."
msgstr ""
"Retorna a função erro complementar em *x*. A `função erro complementar "
"<https://en.wikipedia.org/wiki/Error_function>`_ é definida como ``1.0 - "
"erf(x)``. É usado para grandes valores de *x* onde uma subtração de um "
"causaria uma `perda de significância <https://en.wikipedia.org/wiki/"
"Loss_of_significance>`_\\."

#: ../../library/math.rst:745
msgid ""
"Return the `Gamma function <https://en.wikipedia.org/wiki/Gamma_function>`_ "
"at *x*."
msgstr ""
"Retorna a `função gama <https://pt.wikipedia.org/wiki/Função_gama>`_ em *x*."

#: ../../library/math.rst:753
msgid ""
"Return the natural logarithm of the absolute value of the Gamma function at "
"*x*."
msgstr "Retorna o logaritmo natural do valor absoluto da função gama em *x*."

#: ../../library/math.rst:760
msgid "Constants"
msgstr "Constantes"

#: ../../library/math.rst:764
msgid "The mathematical constant *π* = 3.141592..., to available precision."
msgstr "A constante matemática *π* = 3.141592..., para a precisão disponível."

#: ../../library/math.rst:769
msgid "The mathematical constant *e* = 2.718281..., to available precision."
msgstr "A constante matemática *e* = 2.718281..., para a precisão disponível."

#: ../../library/math.rst:774
msgid ""
"The mathematical constant *τ* = 6.283185..., to available precision. Tau is "
"a circle constant equal to 2\\ *π*, the ratio of a circle's circumference to "
"its radius. To learn more about Tau, check out Vi Hart's video `Pi is "
"(still) Wrong <https://vimeo.com/147792667>`_, and start celebrating `Tau "
"day <https://tauday.com/>`_ by eating twice as much pie!"
msgstr ""
"A constante matemática *τ* = 6.283185..., para a precisão disponível. Tau é "
"uma constante de círculo igual a 2\\ *π*, a razão entre a circunferência de "
"um círculo e seu raio. Para saber mais sobre Tau, confira o vídeo `Pi is "
"(still) Wrong <https://vimeo.com/147792667>`_ de Vi Hart, e comece a "
"comemorar o `dia do Tau <https://tauday.com/>`_ comendo duas vezes mais "
"torta!"

#: ../../library/math.rst:785
msgid ""
"A floating-point positive infinity.  (For negative infinity, use ``-math."
"inf``.)  Equivalent to the output of ``float('inf')``."
msgstr ""
"Um infinito positivo de ponto flutuante. (Para infinito negativo, use ``-"
"math.inf``.) Equivalente à saída de ``float('inf')``."

#: ../../library/math.rst:793
msgid ""
"A floating-point \"not a number\" (NaN) value. Equivalent to the output of "
"``float('nan')``. Due to the requirements of the `IEEE-754 standard <https://"
"en.wikipedia.org/wiki/IEEE_754>`_, ``math.nan`` and ``float('nan')`` are not "
"considered to equal to any other numeric value, including themselves. To "
"check whether a number is a NaN, use the :func:`isnan` function to test for "
"NaNs instead of ``is`` or ``==``. Example:"
msgstr ""
"Um valor de ponto flutuante \"não é um número\" (NaN). Equivalente à saída "
"de ``float('nan')``. Devido aos requisitos do `padrão IEEE-754 <https://en."
"wikipedia.org/wiki/IEEE_754>`_, ``math.nan`` e ``float('nan')`` não são "
"considerados para ser igual a qualquer outro valor numérico, incluindo eles "
"próprios. Para verificar se um número é NaN, use a função :func:`isnan` para "
"testar NaNs em vez de ``is`` ou ``==``. Exemplo:"

#: ../../library/math.rst:813
msgid "It is now always available."
msgstr "Agora está sempre disponível"

#: ../../library/math.rst:819
msgid ""
"The :mod:`math` module consists mostly of thin wrappers around the platform "
"C math library functions.  Behavior in exceptional cases follows Annex F of "
"the C99 standard where appropriate.  The current implementation will raise :"
"exc:`ValueError` for invalid operations like ``sqrt(-1.0)`` or ``log(0.0)`` "
"(where C99 Annex F recommends signaling invalid operation or divide-by-"
"zero), and :exc:`OverflowError` for results that overflow (for example, "
"``exp(1000.0)``).  A NaN will not be returned from any of the functions "
"above unless one or more of the input arguments was a NaN; in that case, "
"most functions will return a NaN, but (again following C99 Annex F) there "
"are some exceptions to this rule, for example ``pow(float('nan'), 0.0)`` or "
"``hypot(float('nan'), float('inf'))``."
msgstr ""
"O módulo :mod:`math` consiste principalmente em invólucros finos em torno "
"das funções da biblioteca matemática C da plataforma. O comportamento em "
"casos excepcionais segue o Anexo F da norma C99 quando apropriado. A "
"implementação atual levantará :exc:`ValueError` para operações inválidas "
"como ``sqrt(-1.0)`` ou ``log(0.0)`` (onde C99 Anexo F recomenda sinalizar "
"operação inválida ou divisão por zero), e :exc:`OverflowError` para "
"resultados que estouram (por exemplo, ``exp(1000.0)``). Um NaN não será "
"retornado de nenhuma das funções acima, a menos que um ou mais dos "
"argumentos de entrada sejam um NaN; nesse caso, a maioria das funções "
"retornará um NaN, mas (novamente seguindo C99 Anexo F) há algumas exceções a "
"esta regra, por exemplo, ``pow(float('nan'), 0.0)`` ou ``hypot(float('nan'), "
"float('inf'))``."

#: ../../library/math.rst:831
msgid ""
"Note that Python makes no effort to distinguish signaling NaNs from quiet "
"NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior "
"is to treat all NaNs as though they were quiet."
msgstr ""
"Observe que o Python não faz nenhum esforço para distinguir NaNs de "
"sinalização de NaNs silenciosos, e o comportamento para NaNs de sinalização "
"permanece não especificado. O comportamento típico é tratar todos os NaNs "
"como se estivessem quietos."

#: ../../library/math.rst:838
msgid "Module :mod:`cmath`"
msgstr "Módulo :mod:`cmath`"

#: ../../library/math.rst:839
msgid "Complex number versions of many of these functions."
msgstr "Versões de números complexos de muitas dessas funções."

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Raphael Mendonça, 2020
# Marco Rougeth <marco@rougeth.com>, 2020
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2020
# Italo Penaforte <italo.penaforte@gmail.com>, 2020
# i17obot <i17obot@rougeth.com>, 2020
# Vinicius Gubiani Ferreira <vini.g.fer@gmail.com>, 2020
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-08-23 17:20+0000\n"
"PO-Revision-Date: 2020-05-30 11:56+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/asyncio-task.rst:6
msgid "Coroutines and Tasks"
msgstr "Corrotinas e Tarefas"

#: ../../library/asyncio-task.rst:8
msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr ""
"Esta seção descreve APIs assíncronas de alto nível para trabalhar com "
"corrotinas e tarefas."

#: ../../library/asyncio-task.rst:19 ../../library/asyncio-task.rst:121
msgid "Coroutines"
msgstr "Corrotinas"

#: ../../library/asyncio-task.rst:21
msgid ""
":term:`Coroutines <coroutine>` declared with the async/await syntax is the "
"preferred way of writing asyncio applications.  For example, the following "
"snippet of code (requires Python 3.7+) prints \"hello\", waits 1 second, and "
"then prints \"world\"::"
msgstr ""
":term:`Corrotinas <coroutine>` declaradas com a sintaxe async/await é a "
"forma preferida de escrever aplicações assíncronas. Por exemplo, o seguinte "
"trecho de código (requer Python 3.7+) imprime \"hello\", espera 1 segundo, e "
"então imprime \"world\"::"

#: ../../library/asyncio-task.rst:37
msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr ""
"Perceba que simplesmente chamar uma corrotina não irá agendá-la para ser "
"executada::"

#: ../../library/asyncio-task.rst:43
msgid "To actually run a coroutine, asyncio provides three main mechanisms:"
msgstr ""
"Para realmente executar uma corrotina, asyncio fornece três mecanismos "
"principais:"

#: ../../library/asyncio-task.rst:45
msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\" "
"function (see the above example.)"
msgstr ""
"A função :func:`asyncio.run` para executar a função \"main()\" do ponto de "
"entrada no nível mais alto (veja o exemplo acima.)"

#: ../../library/asyncio-task.rst:48
msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\" "
"after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr ""
"Aguardando uma corrotina. O seguinte trecho de código exibirá \"hello\" após "
"esperar por 1 segundo e, em seguida, exibirá \"world\" após esperar por "
"*outros* 2 segundos::"

#: ../../library/asyncio-task.rst:69
msgid "Expected output::"
msgstr "Resultado esperado::"

#: ../../library/asyncio-task.rst:76
msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ""
"A função :func:`asyncio.create_task` para executar corrotinas "
"concorrentemente como :class:`Tasks <Task>` asyncio."

#: ../../library/asyncio-task.rst:79
msgid ""
"Let's modify the above example and run two ``say_after`` coroutines "
"*concurrently*::"
msgstr ""
"Vamos modificar o exemplo acima e executar duas corrotinas ``say_after`` "
"*concorrentemente*::"

#: ../../library/asyncio-task.rst:98
msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr ""
"Perceba que a saída esperada agora mostra que o trecho de código é executado "
"1 segundo mais rápido do que antes::"

#: ../../library/asyncio-task.rst:110
msgid "Awaitables"
msgstr "Aguardáveis"

#: ../../library/asyncio-task.rst:112
msgid ""
"We say that an object is an **awaitable** object if it can be used in "
"an :keyword:`await` expression.  Many asyncio APIs are designed to accept "
"awaitables."
msgstr ""
"Dizemos que um objeto é um objeto **aguardável** se ele pode ser usado em "
"uma expressão :keyword:`await`. Muitas APIs asyncio são projetadas para "
"aceitar aguardáveis."

#: ../../library/asyncio-task.rst:116
msgid ""
"There are three main types of *awaitable* objects: **coroutines**, "
"**Tasks**, and **Futures**."
msgstr ""
"Existem três tipos principais de objetos *aguardáveis*: **corrotinas**, "
"**Tarefas**, e **Futuros**."

#: ../../library/asyncio-task.rst:122
msgid ""
"Python coroutines are *awaitables* and therefore can be awaited from other "
"coroutines::"
msgstr ""
"Corrotinas Python são *aguardáveis* e portanto podem ser aguardadas a partir "
"de outras corrotinas::"

#: ../../library/asyncio-task.rst:143
msgid ""
"In this documentation the term \"coroutine\" can be used for two closely "
"related concepts:"
msgstr ""
"Nesta documentação, o termo \"corrotina\" pode ser usado para dois conceitos "
"intimamente relacionados:"

#: ../../library/asyncio-task.rst:146
msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr "uma *função de corrotina*: uma função :keyword:`async def`;"

#: ../../library/asyncio-task.rst:148
msgid ""
"a *coroutine object*: an object returned by calling a *coroutine function*."
msgstr ""
"um *objeto de corrotina*: um objeto retornado ao chamar uma *função de "
"corrotina*."

#: ../../library/asyncio-task.rst:151
msgid ""
"asyncio also supports legacy :ref:`generator-based "
"<asyncio_generator_based_coro>` coroutines."
msgstr ""
"asyncio também suporta corrotinas legadas :ref:`baseadas em geradores "
"<asyncio_generator_based_coro>`."

#: ../../library/asyncio-task.rst:156
msgid "Tasks"
msgstr "Tarefas"

#: ../../library/asyncio-task.rst:157
msgid "*Tasks* are used to schedule coroutines *concurrently*."
msgstr "*Tarefas* são usadas para agendar corrotinas *concorrentemente*."

#: ../../library/asyncio-task.rst:159
msgid ""
"When a coroutine is wrapped into a *Task* with functions "
"like :func:`asyncio.create_task` the coroutine is automatically scheduled to "
"run soon::"
msgstr ""
"Quando uma corrotina é envolta em uma *tarefa* com funções "
"como :func:`asyncio.create_task`, a corrotina é automaticamente agendada "
"para executar em breve::"

#: ../../library/asyncio-task.rst:181
msgid "Futures"
msgstr "Futuros"

#: ../../library/asyncio-task.rst:182
msgid ""
"A :class:`Future` is a special **low-level** awaitable object that "
"represents an **eventual result** of an asynchronous operation."
msgstr ""
"Um :class:`Future` é um objeto aguardável especial de **baixo nível** que "
"representa um **resultado eventual** de uma operação assíncrona."

#: ../../library/asyncio-task.rst:185
msgid ""
"When a Future object is *awaited* it means that the coroutine will wait "
"until the Future is resolved in some other place."
msgstr ""
"Quando um objeto Future é *aguardado* isso significa que a corrotina irá "
"esperar até que o Future seja resolvido em algum outro local."

#: ../../library/asyncio-task.rst:188
msgid ""
"Future objects in asyncio are needed to allow callback-based code to be used "
"with async/await."
msgstr ""
"Objetos Future em asyncio são necessários para permitir que código baseado "
"em função de retorno seja utilizado com async/await."

#: ../../library/asyncio-task.rst:191
msgid ""
"Normally **there is no need** to create Future objects at the application "
"level code."
msgstr ""
"Normalmente **não existe necessidade** em criar objetos Future no nível de "
"código da aplicação."

#: ../../library/asyncio-task.rst:194
msgid ""
"Future objects, sometimes exposed by libraries and some asyncio APIs, can be "
"awaited::"
msgstr ""
"Objetos Future, algumas vezes expostos por bibliotecas e algumas APIs "
"asyncio, podem ser aguardados::"

#: ../../library/asyncio-task.rst:206
msgid ""
"A good example of a low-level function that returns a Future object "
"is :meth:`loop.run_in_executor`."
msgstr ""
"Um bom exemplo de uma função de baixo nível que retorna um objeto Future "
"é :meth:`loop.run_in_executor`."

#: ../../library/asyncio-task.rst:211
msgid "Running an asyncio Program"
msgstr "Executando um programa asyncio"

#: ../../library/asyncio-task.rst:215
msgid "Execute the :term:`coroutine` *coro* and return the result."
msgstr "Executa a :term:`corrotina <coroutine>` *coro* e retorna o resultado."

#: ../../library/asyncio-task.rst:217
msgid ""
"This function runs the passed coroutine, taking care of managing the asyncio "
"event loop and *finalizing asynchronous generators*."
msgstr ""

#: ../../library/asyncio-task.rst:221
msgid ""
"This function cannot be called when another asyncio event loop is running in "
"the same thread."
msgstr ""
"Esta função não pode ser chamada quando outro laço de eventos asyncio está "
"executando na mesma thread."

#: ../../library/asyncio-task.rst:224
msgid "If *debug* is ``True``, the event loop will be run in debug mode."
msgstr ""
"Se *debug* for ``True``, o laço de eventos irá ser executado em modo debug."

#: ../../library/asyncio-task.rst:226
msgid ""
"This function always creates a new event loop and closes it at the end.  It "
"should be used as a main entry point for asyncio programs, and should "
"ideally only be called once."
msgstr ""
"Esta função sempre cria um novo laço de eventos e fecha-o no final. Ela deve "
"ser usada como um ponto de entrada principal para programas asyncio, e deve "
"idealmente ser chamada apenas uma vez."

#: ../../library/asyncio-task.rst:230 ../../library/asyncio-task.rst:354
#: ../../library/asyncio-task.rst:471 ../../library/asyncio-task.rst:601
msgid "Example::"
msgstr "Exemplo::"

#: ../../library/asyncio-task.rst:242
msgid ""
"The source code for ``asyncio.run()`` can be found in :source:`Lib/asyncio/"
"runners.py`."
msgstr ""
"O código-fonte para ``asyncio.run()`` pode ser encontrado em :source:`Lib/"
"asyncio/runners.py`."

#: ../../library/asyncio-task.rst:246
msgid "Creating Tasks"
msgstr "Criando Tarefas"

#: ../../library/asyncio-task.rst:250
msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a :class:`Task` and "
"schedule its execution.  Return the Task object."
msgstr ""
"Envolva a :ref:`corrotina <coroutine>` *coro* em uma :class:`Task` e agende "
"sua execução. Retorne o objeto Task."

#: ../../library/asyncio-task.rst:253
msgid ""
"If *name* is not ``None``, it is set as the name of the task "
"using :meth:`Task.set_name`."
msgstr ""
"Se *name* não for ``None``, ele é setado como o nome da tarefa "
"usando :meth:`Task.set_name`."

#: ../../library/asyncio-task.rst:256
msgid ""
"The task is executed in the loop returned "
"by :func:`get_running_loop`, :exc:`RuntimeError` is raised if there is no "
"running loop in current thread."
msgstr ""
"A tarefa é executada no laço e retornada "
"por :func:`get_running_loop`, :exc:`RuntimeError` é levantado se não existir "
"nenhum loop na thread atual."

#: ../../library/asyncio-task.rst:260
msgid ""
"This function has been **added in Python 3.7**.  Prior to Python 3.7, the "
"low-level :func:`asyncio.ensure_future` function can be used instead::"
msgstr ""
"Esta função foi **adicionada no Python 3.7**. Antes do Python 3.7, a função "
"de baixo nível :func:`asyncio.ensure_future` pode ser usada ao invés::"

#: ../../library/asyncio-task.rst:277 ../../library/asyncio-task.rst:724
msgid "Added the ``name`` parameter."
msgstr "Adicionado o parâmetro ``name``."

#: ../../library/asyncio-task.rst:282
msgid "Sleeping"
msgstr "Dormindo"

#: ../../library/asyncio-task.rst:286
msgid "Block for *delay* seconds."
msgstr "Bloqueia por *delay* segundos."

#: ../../library/asyncio-task.rst:288
msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr ""
"Se *result* é fornecido, é retornado para o autor da chamada quando a "
"corrotina termina."

#: ../../library/asyncio-task.rst:291
msgid ""
"``sleep()`` always suspends the current task, allowing other tasks to run."
msgstr ""
"``sleep()`` sempre suspende a tarefa atual, permitindo que outras tarefas "
"sejam executadas."

#: ../../library/asyncio-task.rst:296 ../../library/asyncio-task.rst:351
#: ../../library/asyncio-task.rst:438 ../../library/asyncio-task.rst:468
#: ../../library/asyncio-task.rst:553 ../../library/asyncio-task.rst:600
#: ../../library/asyncio-task.rst:729
msgid "The *loop* parameter."
msgstr "O parâmetro *loop*."

#: ../../library/asyncio-task.rst:299
msgid ""
"Example of coroutine displaying the current date every second for 5 seconds::"
msgstr ""
"Exemplo de uma corrotina exibindo a data atual a cada segundo durante 5 "
"segundos::"

#: ../../library/asyncio-task.rst:318
msgid "Running Tasks Concurrently"
msgstr "Executando tarefas concorrentemente"

#: ../../library/asyncio-task.rst:322
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* sequence "
"*concurrently*."
msgstr ""
"Executa :ref:`objetos aguardáveis <asyncio-awaitables>` na sequência *aws* "
"de forma *concorrente*."

#: ../../library/asyncio-task.rst:325
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task."
msgstr ""
"Se qualquer aguardável em *aws* é uma corrotina, ele é automaticamente "
"agendado como uma Tarefa."

#: ../../library/asyncio-task.rst:328
msgid ""
"If all awaitables are completed successfully, the result is an aggregate "
"list of returned values.  The order of result values corresponds to the "
"order of awaitables in *aws*."
msgstr ""
"Se todos os aguardáveis forem concluídos com sucesso, o resultado é uma "
"lista agregada de valores retornados. A ordem dos valores resultantes "
"corresponde a ordem dos aguardáveis em *aws*."

#: ../../library/asyncio-task.rst:332
msgid ""
"If *return_exceptions* is ``False`` (default), the first raised exception is "
"immediately propagated to the task that awaits on ``gather()``.  Other "
"awaitables in the *aws* sequence **won't be cancelled** and will continue to "
"run."
msgstr ""
"Se *return_exceptions* for ``False`` (valor padrão), a primeira exceção "
"levantada é imediatamente propagada para a tarefa que espera em "
"``gather()``. Outros aguardáveis na sequência *aws* **não serão cancelados** "
"e irão continuar a executar."

#: ../../library/asyncio-task.rst:337
msgid ""
"If *return_exceptions* is ``True``, exceptions are treated the same as "
"successful results, and aggregated in the result list."
msgstr ""
"Se *return_exceptions* for ``True``, exceções são tratadas da mesma forma "
"que resultados com sucesso, e agregadas na lista de resultados."

#: ../../library/asyncio-task.rst:340
msgid ""
"If ``gather()`` is *cancelled*, all submitted awaitables (that have not "
"completed yet) are also *cancelled*."
msgstr ""
"Se ``gather()`` for *cancelado*, todos os aguardáveis que foram submetidos "
"(que não foram concluídos ainda) também são *cancelados*."

#: ../../library/asyncio-task.rst:343
msgid ""
"If any Task or Future from the *aws* sequence is *cancelled*, it is treated "
"as if it raised :exc:`CancelledError` -- the ``gather()`` call is **not** "
"cancelled in this case.  This is to prevent the cancellation of one "
"submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""
"Se qualquer Tarefa ou Futuro da sequência *aws* for *cancelado*, ele é "
"tratado como se tivesse levantado :exc:`CancelledError` -- a chamada para "
"``gather()`` **não** é cancelada neste caso. Isso existe para prevenir que o "
"cancelamento de uma Tarefa/Futuro submetida ocasione outras Tarefas/Futuros "
"a serem cancelados."

#: ../../library/asyncio-task.rst:389
msgid ""
"If *return_exceptions* is False, cancelling gather() after it has been "
"marked done won't cancel any submitted awaitables. For instance, gather can "
"be marked done after propagating an exception to the caller, therefore, "
"calling ``gather.cancel()`` after catching an exception (raised by one of "
"the awaitables) from gather won't cancel any other awaitables."
msgstr ""
"Se *return_exceptions* for False, cancelar gather() depois que ele foi "
"marcado como concluído não irá cancelar quaisquer aguardáveis submetidos. "
"Por exemplo, gather pode ser marcado como concluído após propagar uma "
"exceção para o autor da chamada, portanto, chamar ``gather.cancel()`` após "
"capturar uma exceção (levantada por um dos aguardáveis) a partir de gather "
"não irá cancelar quaisquer outros aguardáveis."

#: ../../library/asyncio-task.rst:396
msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr ""
"Se *gather* por si mesmo for cancelado, o cancelamento é propagado "
"independente de *return_exceptions*."

#: ../../library/asyncio-task.rst:402
msgid "Shielding From Cancellation"
msgstr "Protegendo contra cancelamento"

#: ../../library/asyncio-task.rst:406
msgid ""
"Protect an :ref:`awaitable object <asyncio-awaitables>` from "
"being :meth:`cancelled <Task.cancel>`."
msgstr ""
"Protege um :ref:`objeto aguardável <asyncio-awaitables>` de "
"ser :meth:`cancelado <Task.cancel>`."

#: ../../library/asyncio-task.rst:409 ../../library/asyncio-task.rst:449
msgid "If *aw* is a coroutine it is automatically scheduled as a Task."
msgstr ""
"Se *aw* é uma corrotina, ela é automaticamente agendada como uma Tarefa."

#: ../../library/asyncio-task.rst:411
msgid "The statement::"
msgstr "A instrução::"

#: ../../library/asyncio-task.rst:415
msgid "is equivalent to::"
msgstr "é equivalente a::"

#: ../../library/asyncio-task.rst:419
msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises "
"a :exc:`CancelledError`."
msgstr ""
"*exceto* que se a corrotina contendo-a for cancelada, a Tarefa executando em "
"``something()`` não é cancelada. Do ponto de vista de ``something()``, o "
"cancelamento não aconteceu. Apesar do autor da chamada ainda estar "
"cancelado, então a expressão \"await\" ainda levanta "
"um :exc:`CancelledError`."

#: ../../library/asyncio-task.rst:425
msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr ""
"Se ``something()`` é cancelada por outros meios (isto é, dentro ou a partir "
"de si mesma) isso também iria cancelar ``shield()``."

#: ../../library/asyncio-task.rst:428
msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr ""
"Se for desejado ignorar completamente os cancelamentos (não recomendado) a "
"função ``shield()`` deve ser combinada com uma cláusula try/except, conforme "
"abaixo::"

#: ../../library/asyncio-task.rst:442
msgid "Timeouts"
msgstr "Tempo limite"

#: ../../library/asyncio-task.rst:446
msgid ""
"Wait for the *aw* :ref:`awaitable <asyncio-awaitables>` to complete with a "
"timeout."
msgstr ""
"Espera o :ref:`aguardável <asyncio-awaitables>` *aw* concluir sem "
"ultrapassar o tempo limite \"timeout\"."

#: ../../library/asyncio-task.rst:451
msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait "
"for.  If *timeout* is ``None``, block until the future completes."
msgstr ""
"*timeout* pode ser ``None``, ou um ponto flutuante, ou um número inteiro de "
"segundos para aguardar. Se *timeout* é ``None``, aguarda até o future "
"encerrar."

#: ../../library/asyncio-task.rst:455
msgid ""
"If a timeout occurs, it cancels the task and "
"raises :exc:`asyncio.TimeoutError`."
msgstr ""
"Se o tempo limite timeout for atingido, ele cancela a tarefa e "
"levanta :exc:`asyncio.TimeoutError`."

#: ../../library/asyncio-task.rst:458
msgid ""
"To avoid the task :meth:`cancellation <Task.cancel>`, wrap it "
"in :func:`shield`."
msgstr ""
"Para evitar o :meth:`cancelamento <Task.cancel>` da tarefa, envolva-a "
"com :func:`shield`."

#: ../../library/asyncio-task.rst:461
msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*."
msgstr ""

#: ../../library/asyncio-task.rst:464
msgid "If the wait is cancelled, the future *aw* is also cancelled."
msgstr "Se ele for cancelado, o future *aw* também é cancelado."

#: ../../library/asyncio-task.rst:491
msgid ""
"When *aw* is cancelled due to a timeout, ``wait_for`` waits for *aw* to be "
"cancelled.  Previously, it raised :exc:`asyncio.TimeoutError` immediately."
msgstr ""
"Quando *aw* é cancelado devido a um tempo limite, ``wait_for`` aguarda que "
"*aw* seja cancelado. Anteriormente, ele "
"levantava :exc:`asyncio.TimeoutError` imediatamente."

#: ../../library/asyncio-task.rst:498
msgid "Waiting Primitives"
msgstr "Primitivas de Espera"

#: ../../library/asyncio-task.rst:503
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently and block until the condition specified by *return_when*."
msgstr ""
"Executa :ref:`objetos aguardáveis <asyncio-awaitables>` no iterável *aws* "
"concorrentemente e bloqueia até que a condição especificada por "
"*return_when* seja atingida."

#: ../../library/asyncio-task.rst:507
msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr "Retorna dois conjuntos de Tarefas/Futuros: ``(done, pending)``."

#: ../../library/asyncio-task.rst:509
msgid "Usage::"
msgstr "Uso::"

#: ../../library/asyncio-task.rst:513
msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum "
"number of seconds to wait before returning."
msgstr ""
"*timeout* (um ponto flutuante ou inteiro), se especificado, pode ser usado "
"para controlar o número máximo de segundos para aguardar antes de retornar."

#: ../../library/asyncio-task.rst:516
msgid ""
"Note that this function does not raise :exc:`asyncio.TimeoutError`. Futures "
"or Tasks that aren't done when the timeout occurs are simply returned in the "
"second set."
msgstr ""
"Perceba que esta função não levanta :exc:`asyncio.TimeoutError`. Futuros ou "
"Tarefas que não estão concluídas quando o tempo limite é excedido são "
"simplesmente retornadas no segundo conjunto."

#: ../../library/asyncio-task.rst:520
msgid ""
"*return_when* indicates when this function should return.  It must be one of "
"the following constants:"
msgstr ""
"*return_when* indica quando esta função deve retornar. Ele deve ser uma das "
"seguintes constantes:"

#: ../../library/asyncio-task.rst:526
msgid "Constant"
msgstr "Constante"

#: ../../library/asyncio-task.rst:526
msgid "Description"
msgstr "Descrição"

#: ../../library/asyncio-task.rst:528
msgid ":const:`FIRST_COMPLETED`"
msgstr ":const:`FIRST_COMPLETED`"

#: ../../library/asyncio-task.rst:528
msgid "The function will return when any future finishes or is cancelled."
msgstr ""
"A função irá retornar quando qualquer futuro terminar ou for cancelado."

#: ../../library/asyncio-task.rst:531
msgid ":const:`FIRST_EXCEPTION`"
msgstr ":const:`FIRST_EXCEPTION`"

#: ../../library/asyncio-task.rst:531
msgid ""
"The function will return when any future finishes by raising an exception.  "
"If no future raises an exception then it is equivalent "
"to :const:`ALL_COMPLETED`."
msgstr ""
"A função irá retornar quando qualquer futuro encerrar levantando uma "
"exceção. Se nenhum futuro levantar uma exceção, então é equivalente "
"a :const:`ALL_COMPLETED`."

#: ../../library/asyncio-task.rst:537
msgid ":const:`ALL_COMPLETED`"
msgstr ":const:`ALL_COMPLETED`"

#: ../../library/asyncio-task.rst:537
msgid "The function will return when all futures finish or are cancelled."
msgstr ""
"A função irá retornar quando todos os futuros encerrarem ou forem cancelados."

#: ../../library/asyncio-task.rst:541
msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr ""
"Diferente de :func:`~asyncio.wait_for`, ``wait()`` não cancela os futuros "
"quando um tempo limite é atingido."

#: ../../library/asyncio-task.rst:546
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task.  Passing coroutines objects to ``wait()`` directly is deprecated as it "
"leads to :ref:`confusing behavior <asyncio_example_wait_coroutine>`."
msgstr ""
"Se qualquer aguardável em *aws* for uma corrotina, ela é automaticamente "
"agendada como uma tarefa. Passar objetos que são corrotinas para ``wait()`` "
"diretamente está descontinuado, pois leva a :ref:`comportamentos confusos "
"<asyncio_example_wait_coroutine>`."

#: ../../library/asyncio-task.rst:558
msgid ""
"``wait()`` schedules coroutines as Tasks automatically and later returns "
"those implicitly created Task objects in ``(done, pending)`` sets.  "
"Therefore the following code won't work as expected::"
msgstr ""
"``wait()`` agenda corrotinas como Tarefas automaticamente e posteriormente "
"retorna esses objetos Tarefas criados implicitamente em conjuntos ``(done, "
"pending)``. Portanto o seguinte código não irá funcionar como esperado::"

#: ../../library/asyncio-task.rst:571
msgid "Here is how the above snippet can be fixed::"
msgstr "Aqui está a forma como o trecho de código acima pode ser consertado::"

#: ../../library/asyncio-task.rst:584
msgid "Passing coroutine objects to ``wait()`` directly is deprecated."
msgstr ""
"Passar objetos corrotina para ``wait()`` diretamente foi descontinuado."

#: ../../library/asyncio-task.rst:590
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently.  Return an iterator of coroutines. Each coroutine returned can "
"be awaited to get the earliest next result from the iterable of the "
"remaining awaitables."
msgstr ""
"Executa :ref:`objetos aguardáveis <asyncio-awaitables>` no iterável *aws* "
"concorrentemente. Retorna um iterador de corrotinas. Cada corrotina "
"retornada pode ser aguardada para obter o primeiro resultado seguinte a "
"partir do iterável dos aguardáveis restantes."

#: ../../library/asyncio-task.rst:595
msgid ""
"Raises :exc:`asyncio.TimeoutError` if the timeout occurs before all Futures "
"are done."
msgstr ""
"Levanta :exc:`asyncio.TimeoutError` se o tempo limite ocorrer antes que "
"todos os futuros tenham encerrado."

#: ../../library/asyncio-task.rst:609
msgid "Scheduling From Other Threads"
msgstr "Agendando a partir de outras Threads"

#: ../../library/asyncio-task.rst:613
msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr ""
"Envia uma corrotina para o laço de eventos fornecido. Seguro para thread."

#: ../../library/asyncio-task.rst:615
msgid ""
"Return a :class:`concurrent.futures.Future` to wait for the result from "
"another OS thread."
msgstr ""
"Retorna um :class:`concurrent.futures.Future` para aguardar pelo resultado "
"de outra thread do sistema operacional."

#: ../../library/asyncio-task.rst:618
msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr ""
"Esta função destina-se a ser chamada partir de uma thread diferente do "
"sistema operacional, da qual o laço de eventos está executando. Exemplo::"

#: ../../library/asyncio-task.rst:630
msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr ""
"Se uma exceção for levantada na corrotina, o Futuro retornado será "
"notificado. Isso também pode ser usado para cancelar a tarefa no laço de "
"eventos::"

#: ../../library/asyncio-task.rst:644
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Veja a seção :ref:`concorrência e multithreading <asyncio-multithreading>` "
"da documentação."

#: ../../library/asyncio-task.rst:647
msgid ""
"Unlike other asyncio functions this function requires the *loop* argument to "
"be passed explicitly."
msgstr ""
"Ao contrário de outras funções asyncio, esta função requer que o argumento "
"*loop* seja passado explicitamente."

#: ../../library/asyncio-task.rst:654
msgid "Introspection"
msgstr "Introspecção"

#: ../../library/asyncio-task.rst:659
msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr ""
"Retorna a instância :class:`Task` atualmente em execução, ou ``None`` se "
"nenhuma tarefa estiver executando."

#: ../../library/asyncio-task.rst:662
msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr ""
"Se *loop* for ``None``, então :func:`get_running_loop` é usado para obter o "
"laço atual."

#: ../../library/asyncio-task.rst:670
msgid "Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr ""
"Retorna um conjunto de objetos :class:`Task` ainda não concluídos a serem "
"executados pelo laço."

#: ../../library/asyncio-task.rst:673
msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr ""
"Se *loop* for ``None``, então :func:`get_running_loop` é usado para obter o "
"laço atual."

#: ../../library/asyncio-task.rst:680
msgid "Task Object"
msgstr "Objeto Task"

#: ../../library/asyncio-task.rst:684
msgid ""
"A :class:`Future-like <Future>` object that runs a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr ""
"Um objeto :class:`similar a Futuro <Future>` que executa uma :ref:`corrotina "
"<coroutine>` Python. Não é seguro para thread."

#: ../../library/asyncio-task.rst:687
msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""
"Tarefas são usadas para executar corrotinas em laços de eventos. Se uma "
"corrotina espera por um Futuro, a Tarefa suspende a execução da corrotina e "
"aguarda a conclusão do Futuro. Quando o Futuro é *concluído*, a execução da "
"corrotina contida é retomada."

#: ../../library/asyncio-task.rst:693
msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr ""
"Laço de eventos usam agendamento cooperativo: um ciclo de evento executa uma "
"Tarefa de cada vez. Enquanto uma Tarefa aguarda a conclusão de um Futuro, o "
"laço de eventos executa outras Tarefas, funções de retorno, ou executa "
"operações de IO."

#: ../../library/asyncio-task.rst:698
msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""
"Use a função de alto nível :func:`asyncio.create_task` para criar Tarefas, "
"ou as funções de baixo nível :meth:`loop.create_task` "
"ou :func:`ensure_future`. Instanciação manual de Tarefas é desencorajado."

#: ../../library/asyncio-task.rst:703
msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""
"Para cancelar uma Tarefa em execução, use o método :meth:`cancel`. Chamar "
"ele fará com que a Tarefa levante uma exceção :exc:`CancelledError` dentro "
"da corrotina contida. Se a corrotina estiver esperando por um objeto Future "
"durante o cancelamento, o objeto Future será cancelado."

#: ../../library/asyncio-task.rst:708
msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method "
"returns ``True`` if the wrapped coroutine did not suppress "
"the :exc:`CancelledError` exception and was actually cancelled."
msgstr ""
":meth:`cancelled` pode ser usado para verificar se a Tarefa foi cancelada. O "
"método retorna ``True`` se a corrotina envolta não suprimiu a "
"exceção :exc:`CancelledError` e foi na verdade cancelada."

#: ../../library/asyncio-task.rst:713
msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs "
"except :meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""
":class:`asyncio.Task` herda de :class:`Future` todas as suas APIs "
"exceto :meth:`Future.set_result` e :meth:`Future.set_exception`."

#: ../../library/asyncio-task.rst:717
msgid ""
"Tasks support the :mod:`contextvars` module.  When a Task is created it "
"copies the current context and later runs its coroutine in the copied "
"context."
msgstr ""
"Tarefas suportam o módulo :mod:`contextvars`. Quando a Tarefa é criada, ela "
"copia o contexto atual e posteriormente executa sua corrotina no contexto "
"copiado."

#: ../../library/asyncio-task.rst:721
msgid "Added support for the :mod:`contextvars` module."
msgstr "Adicionado suporte para o módulo :mod:`contextvars`."

#: ../../library/asyncio-task.rst:732
msgid "Request the Task to be cancelled."
msgstr "Solicita o cancelamento da Tarefa."

#: ../../library/asyncio-task.rst:734
msgid ""
"This arranges for a :exc:`CancelledError` exception to be thrown into the "
"wrapped coroutine on the next cycle of the event loop."
msgstr ""
"Isto prepara para uma exceção :exc:`CancelledError` ser lançada na corrotina "
"contida no próximo ciclo do laço de eventos."

#: ../../library/asyncio-task.rst:737
msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, "
"unlike :meth:`Future.cancel`, :meth:`Task.cancel` does not guarantee that "
"the Task will be cancelled, although suppressing cancellation completely is "
"not common and is actively discouraged."
msgstr ""
"A corrotina então tem uma chance de limpar ou até mesmo negar a requisição, "
"suprimindo a exceção com um bloco :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally`. Portanto, ao contrário "
"de :meth:`Future.cancel`, :meth:`Task.cancel` não garante que a Tarefa será "
"cancelada, apesar que suprimir o cancelamento completamente não é comum, e é "
"ativamente desencorajado."

#: ../../library/asyncio-task.rst:747
msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr ""
"O seguinte exemplo ilustra como corrotinas podem interceptar o cancelamento "
"de requisições::"

#: ../../library/asyncio-task.rst:786
msgid "Return ``True`` if the Task is *cancelled*."
msgstr "Retorna ``True`` se a Tarefa for *cancelada*."

#: ../../library/asyncio-task.rst:788
msgid ""
"The Task is *cancelled* when the cancellation was requested "
"with :meth:`cancel` and the wrapped coroutine propagated "
"the :exc:`CancelledError` exception thrown into it."
msgstr ""
"A Tarefa é *cancelada* quando o cancelamento foi requisitado "
"com :meth:`cancel` e a corrotina contida propagou a "
"exceção :exc:`CancelledError` gerada nela."

#: ../../library/asyncio-task.rst:794
msgid "Return ``True`` if the Task is *done*."
msgstr "Retorna ``True`` se a Tarefa estiver *concluída*."

#: ../../library/asyncio-task.rst:796
msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr ""
"Uma Tarefa está *concluída* quando a corrotina contida retornou um valor, ou "
"levantou uma exceção, ou a Tarefa foi cancelada."

#: ../../library/asyncio-task.rst:801
msgid "Return the result of the Task."
msgstr "Retorna o resultado da Tarefa."

#: ../../library/asyncio-task.rst:803
msgid ""
"If the Task is *done*, the result of the wrapped coroutine is returned (or "
"if the coroutine raised an exception, that exception is re-raised.)"
msgstr ""
"Se a Tarefa estiver *concluída*, o resultado da corrotina contida é "
"retornado (ou se a corrotina levantou uma exceção, essa exceção é re-"
"levantada.)"

#: ../../library/asyncio-task.rst:807 ../../library/asyncio-task.rst:821
msgid ""
"If the Task has been *cancelled*, this method raises a :exc:`CancelledError` "
"exception."
msgstr ""
"Se a Tarefa foi *cancelada*, este método levanta uma "
"exceção :exc:`CancelledError`."

#: ../../library/asyncio-task.rst:810
msgid ""
"If the Task's result isn't yet available, this method raises "
"a :exc:`InvalidStateError` exception."
msgstr ""
"Se o resultado da Tarefa não estiver disponível ainda, este método levanta "
"uma exceção :exc:`InvalidStateError`."

#: ../../library/asyncio-task.rst:815
msgid "Return the exception of the Task."
msgstr "Retorna a exceção de uma Tarefa."

#: ../../library/asyncio-task.rst:817
msgid ""
"If the wrapped coroutine raised an exception that exception is returned.  If "
"the wrapped coroutine returned normally this method returns ``None``."
msgstr ""
"Se a corrotina contida levantou uma exceção, essa exceção é retornada. Se a "
"corrotina contida retornou normalmente, este método retorna ``None``."

#: ../../library/asyncio-task.rst:824
msgid ""
"If the Task isn't *done* yet, this method raises an :exc:`InvalidStateError` "
"exception."
msgstr ""
"Se a Tarefa não estiver *concluída* ainda, este método levanta uma "
"exceção :exc:`InvalidStateError`."

#: ../../library/asyncio-task.rst:829
msgid "Add a callback to be run when the Task is *done*."
msgstr ""
"Adiciona uma função de retorno para ser executada quando a Tarefa estiver "
"*concluída*."

#: ../../library/asyncio-task.rst:831 ../../library/asyncio-task.rst:840
msgid "This method should only be used in low-level callback-based code."
msgstr ""
"Este método deve ser usado apenas em código de baixo nível baseado em "
"funções de retorno."

#: ../../library/asyncio-task.rst:833
msgid ""
"See the documentation of :meth:`Future.add_done_callback` for more details."
msgstr ""
"Veja a documentação para :meth:`Future.add_done_callback` para mais detalhes."

#: ../../library/asyncio-task.rst:838
msgid "Remove *callback* from the callbacks list."
msgstr "Remove *callback* da lista de funções de retorno."

#: ../../library/asyncio-task.rst:842
msgid ""
"See the documentation of :meth:`Future.remove_done_callback` for more "
"details."
msgstr ""
"Veja a documentação do método :meth:`Future.remove_done_callback` para mais "
"detalhes."

#: ../../library/asyncio-task.rst:847
msgid "Return the list of stack frames for this Task."
msgstr "Retorna a lista de frames da pilha para esta Tarefa."

#: ../../library/asyncio-task.rst:849
msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception, "
"this returns the list of traceback frames."
msgstr ""
"Se a corrotina contida não estiver concluída, isto retorna a pilha onde ela "
"foi suspensa. Se a corrotina foi concluída com sucesso ou foi cancelada, "
"isto retorna uma lista vazia. Se a corrotina foi terminada por uma exceção, "
"isto retorna a lista de frames do traceback (situação da pilha de execução)."

#: ../../library/asyncio-task.rst:855
msgid "The frames are always ordered from oldest to newest."
msgstr ""
"Os quadros são sempre ordenados dos mais antigos para os mais recentes."

#: ../../library/asyncio-task.rst:857
msgid "Only one stack frame is returned for a suspended coroutine."
msgstr "Apenas um frame da pilha é retornado para uma corrotina suspensa."

#: ../../library/asyncio-task.rst:859
msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""
"O argumento opcional *limit* define o o número de frames máximo para "
"retornar; por padrão todos os frames disponíveis são retornados. O "
"ordenamento da lista retornada é diferente dependendo se uma pilha ou um "
"traceback (situação da pilha de execução) é retornado: os frames mais "
"recentes de uma pilha são retornados, mas os frames mais antigos de um "
"traceback são retornados. (Isso combina com o comportamento do módulo "
"traceback.)"

#: ../../library/asyncio-task.rst:868
msgid "Print the stack or traceback for this Task."
msgstr "Exibe a pilha ou situação da pilha de execução para esta Tarefa."

#: ../../library/asyncio-task.rst:870
msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr ""
"Isto produz uma saída similar a do módulo traceback para frames recuperados "
"por :meth:`get_stack`."

#: ../../library/asyncio-task.rst:873
msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr "O argumento *limit* é passado para :meth:`get_stack` diretamente."

#: ../../library/asyncio-task.rst:875
msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stderr`."
msgstr ""
"O argumento *file* é um fluxo de entrada e saída para o qual a saída é "
"escrita; por padrão a saída é escrita para :data:`sys.stderr`."

#: ../../library/asyncio-task.rst:880
msgid "Return the coroutine object wrapped by the :class:`Task`."
msgstr "Retorna o objeto corrotina contido pela :class:`Task`."

#: ../../library/asyncio-task.rst:886
msgid "Return the name of the Task."
msgstr "Retorna o nome da Tarefa."

#: ../../library/asyncio-task.rst:888
msgid ""
"If no name has been explicitly assigned to the Task, the default asyncio "
"Task implementation generates a default name during instantiation."
msgstr ""
"Se nenhum nome foi explicitamente designado para a Tarefa, a implementação "
"padrão asyncio da classe Task gera um nome padrão durante a instanciação."

#: ../../library/asyncio-task.rst:896
msgid "Set the name of the Task."
msgstr "Define o nome da Tarefa."

#: ../../library/asyncio-task.rst:898
msgid ""
"The *value* argument can be any object, which is then converted to a string."
msgstr ""
"O argumento *value* pode ser qualquer objeto, o qual é então convertido para "
"uma string."

#: ../../library/asyncio-task.rst:901
msgid ""
"In the default Task implementation, the name will be visible in "
"the :func:`repr` output of a task object."
msgstr ""
"Na implementação padrão da Tarefa, o nome será visível na :func:`repr` de "
"saída de um objeto task."

#: ../../library/asyncio-task.rst:908
msgid "Return a set of all tasks for an event loop."
msgstr ""

#: ../../library/asyncio-task.rst:910
msgid ""
"By default all tasks for the current event loop are returned. If *loop* is "
"``None``, the :func:`get_event_loop` function is used to get the current "
"loop."
msgstr ""

#: ../../library/asyncio-task.rst:916
msgid ""
"Do not call this as a task method. Use the :func:`asyncio.all_tasks` "
"function instead."
msgstr ""

#: ../../library/asyncio-task.rst:921
msgid "Return the currently running task or ``None``."
msgstr ""

#: ../../library/asyncio-task.rst:923
msgid ""
"If *loop* is ``None``, the :func:`get_event_loop` function is used to get "
"the current loop."
msgstr ""

#: ../../library/asyncio-task.rst:928
msgid ""
"Do not call this as a task method.  Use the :func:`asyncio.current_task` "
"function instead."
msgstr ""

#: ../../library/asyncio-task.rst:935
msgid "Generator-based Coroutines"
msgstr "Corrotinas baseadas em gerador"

#: ../../library/asyncio-task.rst:939
msgid ""
"Support for generator-based coroutines is **deprecated** and is scheduled "
"for removal in Python 3.10."
msgstr ""
"Suporte para corrotinas baseadas em gerador está **descontinuado** e "
"agendado para ser removido no Python 3.10."

#: ../../library/asyncio-task.rst:942
msgid ""
"Generator-based coroutines predate async/await syntax.  They are Python "
"generators that use ``yield from`` expressions to await on Futures and other "
"coroutines."
msgstr ""
"Corrotinas baseadas em gerador antecedem a sintaxe async/await. Elas são "
"geradores Python que usam expressões ``yield from`` para aguardar Futuros e "
"outras corrotinas."

#: ../../library/asyncio-task.rst:946
msgid ""
"Generator-based coroutines should be decorated "
"with :func:`@asyncio.coroutine <asyncio.coroutine>`, although this is not "
"enforced."
msgstr ""
"Corrotinas baseadas em gerador devem ser decoradas "
"com :func:`@asyncio.coroutine <asyncio.coroutine>`, apesar disso não ser "
"forçado."

#: ../../library/asyncio-task.rst:953
msgid "Decorator to mark generator-based coroutines."
msgstr "Decorador para marcar corrotinas baseadas em gerador."

#: ../../library/asyncio-task.rst:955
msgid ""
"This decorator enables legacy generator-based coroutines to be compatible "
"with async/await code::"
msgstr ""
"Este decorador permite que corrotinas legadas baseadas em gerador sejam "
"compatíveis com código async/await::"

#: ../../library/asyncio-task.rst:965
msgid "This decorator should not be used for :keyword:`async def` coroutines."
msgstr ""
"Este decorador não deve ser usado para corrotinas :keyword:`async def`."

#: ../../library/asyncio-task.rst:970
msgid "Use :keyword:`async def` instead."
msgstr "Use :keyword:`async def` ao invés."

#: ../../library/asyncio-task.rst:974
msgid "Return ``True`` if *obj* is a :ref:`coroutine object <coroutine>`."
msgstr "Retorna ``True`` se *obj* é um :ref:`objeto corrotina <coroutine>`."

#: ../../library/asyncio-task.rst:976
msgid ""
"This method is different from :func:`inspect.iscoroutine` because it returns "
"``True`` for generator-based coroutines."
msgstr ""
"Este método é diferente de :func:`inspect.iscoroutine` porque ele retorna "
"``True`` para corrotinas baseadas em gerador."

#: ../../library/asyncio-task.rst:981
msgid "Return ``True`` if *func* is a :ref:`coroutine function <coroutine>`."
msgstr ""
"Retorna ``True`` se *func* é uma :ref:`função de corrotina <coroutine>`."

#: ../../library/asyncio-task.rst:984
msgid ""
"This method is different from :func:`inspect.iscoroutinefunction` because it "
"returns ``True`` for generator-based coroutine functions decorated "
"with :func:`@coroutine <coroutine>`."
msgstr ""
"Este método é diferente de :func:`inspect.iscoroutinefunction` porque ele "
"retorna ``True`` para funções de corrotina baseadas em gerador, decoradas "
"com :func:`@coroutine <coroutine>`."

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 17:51+0000\n"
"PO-Revision-Date: 2017-02-16 23:08+0000\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/email.header.rst:2
msgid ":mod:`email.header`: Internationalized headers"
msgstr ":mod:`email.header`: інтернаціоналізовані заголовки"

#: ../../library/email.header.rst:7
msgid "**Source code:** :source:`Lib/email/header.py`"
msgstr "**Código-fonte:** :source:`Lib/email/header.py`"

#: ../../library/email.header.rst:11
msgid ""
"This module is part of the legacy (``Compat32``) email API.  In the current "
"API encoding and decoding of headers is handled transparently by the "
"dictionary-like API of the :class:`~email.message.EmailMessage` class.  In "
"addition to uses in legacy code, this module can be useful in applications "
"that need to completely control the character sets used when encoding "
"headers."
msgstr ""
"Цей модуль є частиною застарілого (``Compat32``) API електронної пошти. У "
"поточному API кодування та декодування заголовків обробляється прозоро за "
"допомогою словникового API класу :class:`~email.message.EmailMessage`. На "
"додаток до використання у застарілому коді, цей модуль може бути корисним у "
"програмах, яким потрібно повністю контролювати набори символів, що "
"використовуються під час кодування заголовків."

#: ../../library/email.header.rst:17
msgid ""
"The remaining text in this section is the original documentation of the "
"module."
msgstr "O texto restante nesta seção é a documentação original do módulo."

#: ../../library/email.header.rst:19
msgid ""
":rfc:`2822` is the base standard that describes the format of email "
"messages. It derives from the older :rfc:`822` standard which came into "
"widespread use at a time when most email was composed of ASCII characters "
"only.  :rfc:`2822` is a specification written assuming email contains only 7-"
"bit ASCII characters."
msgstr ""
":rfc:`2822` — це базовий стандарт, який описує формат електронних "
"повідомлень. Він походить від старішого стандарту :rfc:`822`, який набув "
"широкого використання в той час, коли більшість електронних листів "
"складалися лише з символів ASCII. :rfc:`2822` — це специфікація, написана за "
"умови, що електронна пошта містить лише 7-бітні символи ASCII."

#: ../../library/email.header.rst:24
msgid ""
"Of course, as email has been deployed worldwide, it has become "
"internationalized, such that language specific character sets can now be "
"used in email messages.  The base standard still requires email messages to "
"be transferred using only 7-bit ASCII characters, so a slew of RFCs have "
"been written describing how to encode email containing non-ASCII characters "
"into :rfc:`2822`\\ -compliant format. These RFCs include :rfc:`2045`, :rfc:"
"`2046`, :rfc:`2047`, and :rfc:`2231`. The :mod:`email` package supports "
"these standards in its :mod:`email.header` and :mod:`email.charset` modules."
msgstr ""
"Звичайно, оскільки електронна пошта була розгорнута в усьому світі, вона "
"стала інтернаціоналізованою, так що набори символів для певної мови тепер "
"можна використовувати в електронних повідомленнях. Базовий стандарт все ще "
"вимагає, щоб повідомлення електронної пошти передавалися лише з "
"використанням 7-бітових символів ASCII, тому було написано безліч RFC, які "
"описують, як кодувати електронну пошту, що містить символи, відмінні від "
"ASCII, у :rfc:`2822`\\ -сумісний формат. Ці RFC включають :rfc:`2045`, :rfc:"
"`2046`, :rfc:`2047` і :rfc:`2231`. Пакет :mod:`email` підтримує ці стандарти "
"у своїх модулях :mod:`email.header` і :mod:`email.charset`."

#: ../../library/email.header.rst:33
msgid ""
"If you want to include non-ASCII characters in your email headers, say in "
"the :mailheader:`Subject` or :mailheader:`To` fields, you should use the :"
"class:`Header` class and assign the field in the :class:`~email.message."
"Message` object to an instance of :class:`Header` instead of using a string "
"for the header value.  Import the :class:`Header` class from the :mod:`email."
"header` module. For example::"
msgstr ""
"Якщо ви хочете включити символи, відмінні від ASCII, у заголовки електронної "
"пошти, скажімо, у поля :mailheader:`Subject` або :mailheader:`To`, вам слід "
"використовувати клас :class:`Header` і призначити поле в :class:`~email."
"message.Message` до екземпляра :class:`Header` замість використання рядка "
"для значення заголовка. Імпортуйте клас :class:`Header` з модуля :mod:`email."
"header`. Наприклад::"

#: ../../library/email.header.rst:50
msgid ""
"Notice here how we wanted the :mailheader:`Subject` field to contain a non-"
"ASCII character?  We did this by creating a :class:`Header` instance and "
"passing in the character set that the byte string was encoded in.  When the "
"subsequent :class:`~email.message.Message` instance was flattened, the :"
"mailheader:`Subject` field was properly :rfc:`2047` encoded.  MIME-aware "
"mail readers would show this header using the embedded ISO-8859-1 character."
msgstr ""
"Зверніть увагу, як ми хотіли, щоб поле :mailheader:`Subject` містило символ "
"не ASCII? Ми зробили це, створивши екземпляр :class:`Header` і передавши "
"набір символів, у якому було закодовано рядок байтів. Коли наступний "
"екземпляр :class:`~email.message.Message` було зведено, :mailheader:"
"`Subject` було правильно закодовано :rfc:`2047`. Програми читання пошти з "
"підтримкою MIME відображатимуть цей заголовок за допомогою вбудованого "
"символу ISO-8859-1."

#: ../../library/email.header.rst:57
msgid "Here is the :class:`Header` class description:"
msgstr "Ось опис класу :class:`Header`:"

#: ../../library/email.header.rst:62
msgid ""
"Create a MIME-compliant header that can contain strings in different "
"character sets."
msgstr ""
"Створіть MIME-сумісний заголовок, який може містити рядки з різними наборами "
"символів."

#: ../../library/email.header.rst:65
msgid ""
"Optional *s* is the initial header value.  If ``None`` (the default), the "
"initial header value is not set.  You can later append to the header with :"
"meth:`append` method calls.  *s* may be an instance of :class:`bytes` or :"
"class:`str`, but see the :meth:`append` documentation for semantics."
msgstr ""
"Необов’язковий параметр *s* — початкове значення заголовка. Якщо ``None`` "
"(за замовчуванням), початкове значення заголовка не встановлено. Ви можете "
"пізніше додати до заголовка за допомогою викликів методу :meth:`append`. *s* "
"може бути екземпляром :class:`bytes` або :class:`str`, але див. "
"документацію :meth:`append` щодо семантики."

#: ../../library/email.header.rst:70
msgid ""
"Optional *charset* serves two purposes: it has the same meaning as the "
"*charset* argument to the :meth:`append` method.  It also sets the default "
"character set for all subsequent :meth:`append` calls that omit the "
"*charset* argument.  If *charset* is not provided in the constructor (the "
"default), the ``us-ascii`` character set is used both as *s*'s initial "
"charset and as the default for subsequent :meth:`append` calls."
msgstr ""
"Додатковий *charset* служить двом цілям: він має те саме значення, що й "
"аргумент *charset* для методу :meth:`append`. Він також встановлює "
"стандартний набір символів для всіх наступних викликів :meth:`append`, які "
"пропускають аргумент *charset*. Якщо *charset* не надано в конструкторі (за "
"замовчуванням), набір символів ``us-ascii`` використовується і як початковий "
"набір символів *s*, і як типовий для наступних викликів :meth:`append`."

#: ../../library/email.header.rst:77
msgid ""
"The maximum line length can be specified explicitly via *maxlinelen*.  For "
"splitting the first line to a shorter value (to account for the field header "
"which isn't included in *s*, e.g. :mailheader:`Subject`) pass in the name of "
"the field in *header_name*.  The default *maxlinelen* is 76, and the default "
"value for *header_name* is ``None``, meaning it is not taken into account "
"for the first line of a long, split header."
msgstr ""
"Максимальну довжину рядка можна вказати явно за допомогою *maxlinelen*. Щоб "
"розділити перший рядок на коротше значення (щоб врахувати заголовок поля, "
"який не входить до *s*, наприклад, :mailheader:`Subject`), передайте назву "
"поля в *header_name*. Типовим значенням *maxlinelen* є 76, а типовим "
"значенням для *header_name* є ``None``, тобто воно не враховується для "
"першого рядка довгого розділеного заголовка."

#: ../../library/email.header.rst:84
msgid ""
"Optional *continuation_ws* must be :rfc:`2822`\\ -compliant folding "
"whitespace, and is usually either a space or a hard tab character.  This "
"character will be prepended to continuation lines.  *continuation_ws* "
"defaults to a single space character."
msgstr ""
"Необов’язковий *continuation_ws* має бути :rfc:`2822`\\ -сумісним згортаним "
"пробілом і зазвичай є пробілом або символом жорсткої табуляції. Цей символ "
"буде додано до рядків продовження. *continuation_ws* за замовчуванням "
"використовує один пробіл."

#: ../../library/email.header.rst:89
msgid ""
"Optional *errors* is passed straight through to the :meth:`append` method."
msgstr ""
"Необов’язкові *помилки* передаються безпосередньо до методу :meth:`append`."

#: ../../library/email.header.rst:94
msgid "Append the string *s* to the MIME header."
msgstr "Додайте рядок *s* до заголовка MIME."

#: ../../library/email.header.rst:96
msgid ""
"Optional *charset*, if given, should be a :class:`~email.charset.Charset` "
"instance (see :mod:`email.charset`) or the name of a character set, which "
"will be converted to a :class:`~email.charset.Charset` instance.  A value of "
"``None`` (the default) means that the *charset* given in the constructor is "
"used."
msgstr ""
"Додатковий *charset*, якщо він наданий, має бути екземпляром :class:`~email."
"charset.Charset` (див. :mod:`email.charset`) або назвою набору символів, "
"який буде перетворено на :class:`~email.charset.Charset` екземпляр. Значення "
"``None`` (за замовчуванням) означає, що використовується *набір символів*, "
"наданий у конструкторі."

#: ../../library/email.header.rst:102
msgid ""
"*s* may be an instance of :class:`bytes` or :class:`str`.  If it is an "
"instance of :class:`bytes`, then *charset* is the encoding of that byte "
"string, and a :exc:`UnicodeError` will be raised if the string cannot be "
"decoded with that character set."
msgstr ""
"*s* може бути екземпляром :class:`bytes` або :class:`str`. Якщо це "
"екземпляр :class:`bytes`, тоді *charset* є кодуванням цього рядка байтів, і :"
"exc:`UnicodeError` буде викликано, якщо рядок не можна декодувати за "
"допомогою цього набору символів."

#: ../../library/email.header.rst:107
msgid ""
"If *s* is an instance of :class:`str`, then *charset* is a hint specifying "
"the character set of the characters in the string."
msgstr ""
"Якщо *s* є екземпляром :class:`str`, тоді *charset* є підказкою, що визначає "
"набір символів у рядку."

#: ../../library/email.header.rst:110
msgid ""
"In either case, when producing an :rfc:`2822`\\ -compliant header using :rfc:"
"`2047` rules, the string will be encoded using the output codec of the "
"charset.  If the string cannot be encoded using the output codec, a "
"UnicodeError will be raised."
msgstr ""
"У будь-якому випадку, під час створення :rfc:`2822`\\ -сумісного заголовка з "
"використанням правил :rfc:`2047` рядок кодуватиметься за допомогою вихідного "
"кодека набору символів. Якщо рядок неможливо закодувати за допомогою "
"вихідного кодека, виникне UnicodeError."

#: ../../library/email.header.rst:115
msgid ""
"Optional *errors* is passed as the errors argument to the decode call if *s* "
"is a byte string."
msgstr ""
"Необов’язковий *errors* передається як аргумент errors виклику декодування, "
"якщо *s* є рядком байтів."

#: ../../library/email.header.rst:121
msgid ""
"Encode a message header into an RFC-compliant format, possibly wrapping long "
"lines and encapsulating non-ASCII parts in base64 or quoted-printable "
"encodings."
msgstr ""
"Закодуйте заголовок повідомлення у RFC-сумісний формат, можливо, обгортаючи "
"довгі рядки та інкапсулюючи частини, що не належать до ASCII, у кодування "
"base64 або кодування в лапках."

#: ../../library/email.header.rst:125
msgid ""
"Optional *splitchars* is a string containing characters which should be "
"given extra weight by the splitting algorithm during normal header "
"wrapping.  This is in very rough support of :RFC:`2822`\\'s 'higher level "
"syntactic breaks':  split points preceded by a splitchar are preferred "
"during line splitting, with the characters preferred in the order in which "
"they appear in the string.  Space and tab may be included in the string to "
"indicate whether preference should be given to one over the other as a split "
"point when other split chars do not appear in the line being split.  "
"Splitchars does not affect :RFC:`2047` encoded lines."
msgstr ""
"Необов’язковий *splitchars* — це рядок, що містить символи, яким слід надати "
"додаткову вагу за допомогою алгоритму розбиття під час звичайного обгортання "
"заголовка. Це є дуже грубою підтримкою \"синтаксичних розривів вищого "
"рівня\" :RFC:`2822`: крапки розділення, яким передує символ розділення, є "
"кращими під час поділу рядка, а символи мають перевагу в тому порядку, в "
"якому вони з’являються в рядку. Пробіл і табуляція можуть бути включені в "
"рядок, щоб вказати, чи слід надавати перевагу одному над іншим як точці "
"розділення, коли інші символи розділення не з’являються в рядку, що "
"розділяється. Splitchars не впливає на рядки, закодовані :RFC:`2047`."

#: ../../library/email.header.rst:135
msgid ""
"*maxlinelen*, if given, overrides the instance's value for the maximum line "
"length."
msgstr ""
"*maxlinelen*, якщо задано, замінює значення екземпляра для максимальної "
"довжини рядка."

#: ../../library/email.header.rst:138
msgid ""
"*linesep* specifies the characters used to separate the lines of the folded "
"header.  It defaults to the most useful value for Python application code "
"(``\\n``), but ``\\r\\n`` can be specified in order to produce headers with "
"RFC-compliant line separators."
msgstr ""
"*linesep* визначає символи, які використовуються для розділення рядків "
"згорнутого заголовка. За замовчуванням це найбільш корисне значення для коду "
"програми Python (``\\n``), але ``\\r\\n`` можна вказати, щоб створити "
"заголовки з RFC-сумісними роздільниками рядків."

#: ../../library/email.header.rst:143
msgid "Added the *linesep* argument."
msgstr "Adicionado o argumento *linesep*."

#: ../../library/email.header.rst:147
msgid ""
"The :class:`Header` class also provides a number of methods to support "
"standard operators and built-in functions."
msgstr ""
"Клас :class:`Header` також надає ряд методів для підтримки стандартних "
"операторів і вбудованих функцій."

#: ../../library/email.header.rst:152
msgid ""
"Returns an approximation of the :class:`Header` as a string, using an "
"unlimited line length.  All pieces are converted to unicode using the "
"specified encoding and joined together appropriately.  Any pieces with a "
"charset of ``'unknown-8bit'`` are decoded as ASCII using the ``'replace'`` "
"error handler."
msgstr ""
"Повертає наближення :class:`Header` у вигляді рядка, використовуючи "
"необмежену довжину рядка. Усі фрагменти перетворюються на юнікод із "
"використанням зазначеного кодування та об’єднуються належним чином. Будь-які "
"фрагменти з кодуванням ``'unknown-8bit'`` декодуються як ASCII за допомогою "
"обробника помилок ``'replace'``."

#: ../../library/email.header.rst:158
msgid "Added handling for the ``'unknown-8bit'`` charset."
msgstr "Додано обробку набору символів ``'unknown-8bit''``."

#: ../../library/email.header.rst:164
msgid ""
"This method allows you to compare two :class:`Header` instances for equality."
msgstr ""
"Цей метод дозволяє порівнювати два екземпляри :class:`Header` на предмет "
"рівності."

#: ../../library/email.header.rst:170
msgid ""
"This method allows you to compare two :class:`Header` instances for "
"inequality."
msgstr ""
"Цей метод дозволяє порівнювати два екземпляри :class:`Header` на предмет "
"нерівності."

#: ../../library/email.header.rst:173
msgid ""
"The :mod:`email.header` module also provides the following convenient "
"functions."
msgstr "Модуль :mod:`email.header` також надає такі зручні функції."

#: ../../library/email.header.rst:178
msgid ""
"Decode a message header value without converting the character set. The "
"header value is in *header*."
msgstr ""
"Декодуйте значення заголовка повідомлення без перетворення набору символів. "
"Значення заголовка знаходиться в *заголовку*."

#: ../../library/email.header.rst:181
msgid ""
"This function returns a list of ``(decoded_string, charset)`` pairs "
"containing each of the decoded parts of the header.  *charset* is ``None`` "
"for non-encoded parts of the header, otherwise a lower case string "
"containing the name of the character set specified in the encoded string."
msgstr ""
"Ця функція повертає список пар ``(decoded_string, charset)``, що містить "
"кожну з декодованих частин заголовка. *charset* має значення ``None`` для "
"незакодованих частин заголовка, інакше рядок у нижньому регістрі, що містить "
"назву набору символів, указаного в закодованому рядку."

#: ../../library/email.header.rst:186
msgid "Here's an example::"
msgstr "Aqui está um exemplo::"

#: ../../library/email.header.rst:195
msgid ""
"Create a :class:`Header` instance from a sequence of pairs as returned by :"
"func:`decode_header`."
msgstr ""
"Створіть екземпляр :class:`Header` із послідовності пар, які повертає :func:"
"`decode_header`."

#: ../../library/email.header.rst:198
msgid ""
":func:`decode_header` takes a header value string and returns a sequence of "
"pairs of the format ``(decoded_string, charset)`` where *charset* is the "
"name of the character set."
msgstr ""
":func:`decode_header` приймає рядок значення заголовка та повертає "
"послідовність пар у форматі ``(decoded_string, charset)``, де *charset* — "
"назва набору символів."

#: ../../library/email.header.rst:202
msgid ""
"This function takes one of those sequence of pairs and returns a :class:"
"`Header` instance.  Optional *maxlinelen*, *header_name*, and "
"*continuation_ws* are as in the :class:`Header` constructor."
msgstr ""
"Ця функція бере одну з цих пар і повертає екземпляр :class:`Header`. "
"Необов’язкові *maxlinelen*, *header_name* і *continuation_ws* такі, як у "
"конструкторі :class:`Header`."

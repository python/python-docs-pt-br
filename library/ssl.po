# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2017
# Marco Rougeth <marco@rougeth.com>, 2020
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 17:51+0000\n"
"PO-Revision-Date: 2017-02-16 23:27+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/ssl.rst:2
msgid ":mod:`ssl` --- TLS/SSL wrapper for socket objects"
msgstr ":mod:`ssl` --- оболонка TLS/SSL для об'єктів сокета"

#: ../../library/ssl.rst:10
msgid "**Source code:** :source:`Lib/ssl.py`"
msgstr "**Código-fonte:** :source:`Lib/ssl.py`"

#: ../../library/ssl.rst:18
msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities for "
"network sockets, both client-side and server-side.  This module uses the "
"OpenSSL library. It is available on all modern Unix systems, Windows, macOS, "
"and probably additional platforms, as long as OpenSSL is installed on that "
"platform."
msgstr ""
"Este módulo fornece acesso à criptografia Transport Layer Security "
"(frequentemente conhecida como \"Secure Sockets Layer\") e aos recursos de "
"autenticação de pares para sockets de rede, tanto do lado do cliente quanto "
"do lado do servidor. Este módulo usa a biblioteca OpenSSL. Ela está "
"disponível em todos os sistemas Unix modernos, Windows, macOS e "
"provavelmente plataformas adicionais, desde que o OpenSSL esteja instalado "
"nessa plataforma."

#: ../../library/ssl.rst:26
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior. For example, TLSv1.1 and TLSv1.2 come with "
"openssl version 1.0.1."
msgstr ""

#: ../../library/ssl.rst:32
msgid ""
"Don't use this module without reading the :ref:`ssl-security`.  Doing so may "
"lead to a false sense of security, as the default settings of the ssl module "
"are not necessarily appropriate for your application."
msgstr ""
"Não use este módulo sem ler o :ref:`ssl-security`. Fazer isso pode levar a "
"uma falsa sensação de segurança, pois as configurações padrão do módulo ssl "
"não são necessariamente apropriadas para sua aplicação."

#: ../../library/ssl.rst:37
msgid ""
"This section documents the objects and functions in the ``ssl`` module; for "
"more general information about TLS, SSL, and certificates, the reader is "
"referred to the documents in the \"See Also\" section at the bottom."
msgstr ""
"Esta seção documenta os objetos e funções no módulo ``ssl``; para obter mais "
"informações gerais sobre TLS, SSL e certificados, o leitor pode consultar os "
"documentos na seção \"Consulte também\" na parte inferior."

#: ../../library/ssl.rst:41
msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived from "
"the :class:`socket.socket` type, and provides a socket-like wrapper that "
"also encrypts and decrypts the data going over the socket with SSL.  It "
"supports additional methods such as :meth:`getpeercert`, which retrieves the "
"certificate of the other side of the connection, and :meth:`cipher`, which "
"retrieves the cipher being used for the secure connection."
msgstr ""
"Этот модуль предоставляет класс :class:`ssl.SSLSocket`, который является "
"производным от типа :class:`socket.socket` и предоставляет оболочку, "
"подобную сокету, которая также шифрует и расшифровывает данные, проходящие "
"через сокет с помощью SSL. . Он поддерживает дополнительные методы, такие "
"как :meth:`getpeercert`, который получает сертификат другой стороны "
"соединения, и :meth:`cipher`, который получает шифр, используемый для "
"безопасного соединения."

#: ../../library/ssl.rst:48
msgid ""
"For more sophisticated applications, the :class:`ssl.SSLContext` class helps "
"manage settings and certificates, which can then be inherited by SSL sockets "
"created through the :meth:`SSLContext.wrap_socket` method."
msgstr ""
"Para aplicações mais sofisticadas, a classe :class:`ssl.SSLContext` ajuda a "
"gerenciar configurações e certificados, que podem ser herdados por soquetes "
"SSL criados por meio do método :meth:`SSLContext.wrap_socket`."

#: ../../library/ssl.rst:52
msgid "Updated to support linking with OpenSSL 1.1.0"
msgstr "Atualizado para oferecer suporte à vinculação com OpenSSL 1.1.0"

#: ../../library/ssl.rst:57
msgid ""
"OpenSSL 0.9.8, 1.0.0 and 1.0.1 are deprecated and no longer supported. In "
"the future the ssl module will require at least OpenSSL 1.0.2 or 1.1.0."
msgstr ""
"OpenSSL 0.9.8, 1.0.0 e 1.0.1 estão descontinuado e não são mais suportados. "
"No futuro, o módulo ssl exigirá pelo menos OpenSSL 1.0.2 ou 1.1.0."

#: ../../library/ssl.rst:63
msgid "Functions, Constants, and Exceptions"
msgstr "Funções, constantes e exceções."

#: ../../library/ssl.rst:67
msgid "Socket creation"
msgstr "Criação de socket"

#: ../../library/ssl.rst:69
msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the :meth:`SSLContext."
"wrap_socket` of an :class:`SSLContext` instance to wrap sockets as :class:"
"`SSLSocket` objects. The helper functions :func:`create_default_context` "
"returns a new context with secure default settings. The old :func:"
"`wrap_socket` function is deprecated since it is both inefficient and has no "
"support for server name indication (SNI) and hostname matching."
msgstr ""
"Починаючи з Python 3.2 і 2.7.9, рекомендується використовувати :meth:"
"`SSLContext.wrap_socket` екземпляра :class:`SSLContext` для обгортання "
"сокетів як об’єктів :class:`SSLSocket`. Допоміжні функції :func:"
"`create_default_context` повертають новий контекст із безпечними параметрами "
"за замовчуванням. Стара функція :func:`wrap_socket` є застарілою, оскільки "
"вона є неефективною та не підтримує індикацію імені сервера (SNI) та "
"відповідність імені хоста."

#: ../../library/ssl.rst:77
msgid "Client socket example with default context and IPv4/IPv6 dual stack::"
msgstr ""
"Exemplo de soquete de cliente com contexto padrão e pilha dupla IPv4/IPv6::"

#: ../../library/ssl.rst:90
msgid "Client socket example with custom context and IPv4::"
msgstr "Exemplo de soquete de cliente com contexto personalizado e IPv4::"

#: ../../library/ssl.rst:102
msgid "Server socket example listening on localhost IPv4::"
msgstr "Exemplo de soquete de servidor escutando no localhost IPv4::"

#: ../../library/ssl.rst:116
msgid "Context creation"
msgstr "Criação de contexto"

#: ../../library/ssl.rst:118
msgid ""
"A convenience function helps create :class:`SSLContext` objects for common "
"purposes."
msgstr ""
"Зручна функція допомагає створювати об’єкти :class:`SSLContext` для "
"звичайних цілей."

#: ../../library/ssl.rst:123
msgid ""
"Return a new :class:`SSLContext` object with default settings for the given "
"*purpose*.  The settings are chosen by the :mod:`ssl` module, and usually "
"represent a higher security level than when calling the :class:`SSLContext` "
"constructor directly."
msgstr ""
"Повертає новий об’єкт :class:`SSLContext` із налаштуваннями за замовчуванням "
"для заданої *цілі*. Параметри вибираються модулем :mod:`ssl` і зазвичай "
"представляють вищий рівень безпеки, ніж під час безпосереднього виклику "
"конструктора :class:`SSLContext`."

#: ../../library/ssl.rst:128
msgid ""
"*cafile*, *capath*, *cadata* represent optional CA certificates to trust for "
"certificate verification, as in :meth:`SSLContext.load_verify_locations`.  "
"If all three are :const:`None`, this function can choose to trust the "
"system's default CA certificates instead."
msgstr ""
"*cafile*, *capath*, *cadata* представляють додаткові сертифікати ЦС, яким "
"можна довіряти для перевірки сертифікатів, як у :meth:`SSLContext."
"load_verify_locations`. Якщо всі три параметри :const:`None`, ця функція "
"може натомість довіряти стандартним сертифікатам ЦС системи."

#: ../../library/ssl.rst:134
msgid ""
"The settings are: :data:`PROTOCOL_TLS`, :data:`OP_NO_SSLv2`, and :data:"
"`OP_NO_SSLv3` with high encryption cipher suites without RC4 and without "
"unauthenticated cipher suites. Passing :data:`~Purpose.SERVER_AUTH` as "
"*purpose* sets :data:`~SSLContext.verify_mode` to :data:`CERT_REQUIRED` and "
"either loads CA certificates (when at least one of *cafile*, *capath* or "
"*cadata* is given) or uses :meth:`SSLContext.load_default_certs` to load "
"default CA certificates."
msgstr ""

#: ../../library/ssl.rst:142
msgid ""
"When :attr:`~SSLContext.keylog_filename` is supported and the environment "
"variable :envvar:`SSLKEYLOGFILE` is set, :func:`create_default_context` "
"enables key logging."
msgstr ""
"Якщо підтримується :attr:`~SSLContext.keylog_filename` і встановлено змінну "
"середовища :envvar:`SSLKEYLOGFILE`, :func:`create_default_context` вмикає "
"журналювання ключів."

#: ../../library/ssl.rst:147
msgid ""
"The protocol, options, cipher and other settings may change to more "
"restrictive values anytime without prior deprecation.  The values represent "
"a fair balance between compatibility and security."
msgstr ""
"Протокол, параметри, шифр та інші параметри можуть будь-коли змінитися на "
"більш обмежувальні значення без попереднього припинення. Значення "
"представляють справедливий баланс між сумісністю та безпекою."

#: ../../library/ssl.rst:151
msgid ""
"If your application needs specific settings, you should create a :class:"
"`SSLContext` and apply the settings yourself."
msgstr ""
"Якщо вашій програмі потрібні певні налаштування, ви повинні створити :class:"
"`SSLContext` і застосувати налаштування самостійно."

#: ../../library/ssl.rst:155
msgid ""
"If you find that when certain older clients or servers attempt to connect "
"with a :class:`SSLContext` created by this function that they get an error "
"stating \"Protocol or cipher suite mismatch\", it may be that they only "
"support SSL3.0 which this function excludes using the :data:`OP_NO_SSLv3`. "
"SSL3.0 is widely considered to be `completely broken <https://en.wikipedia."
"org/wiki/POODLE>`_. If you still wish to continue to use this function but "
"still allow SSL 3.0 connections you can re-enable them using::"
msgstr ""
"Якщо ви виявите, що коли певні старіші клієнти чи сервери намагаються "
"підключитися за допомогою :class:`SSLContext`, створеного цією функцією, "
"вони отримують помилку \"Невідповідність протоколу чи набору шифрів\", "
"можливо, вони підтримують лише SSL3.0, який ця функція виключає "
"використання :data:`OP_NO_SSLv3`. SSL3.0 широко вважається `повністю "
"зламаним <https://en.wikipedia.org/wiki/POODLE>`_. Якщо ви все ще бажаєте "
"продовжувати використовувати цю функцію, але все ще дозволяєте підключення "
"SSL 3.0, ви можете повторно ввімкнути їх за допомогою::"

#: ../../library/ssl.rst:171
msgid "RC4 was dropped from the default cipher string."
msgstr "RC4 було видалено з рядка шифру за замовчуванням."

#: ../../library/ssl.rst:175
msgid "ChaCha20/Poly1305 was added to the default cipher string."
msgstr "ChaCha20/Poly1305 додано до рядка шифру за замовчуванням."

#: ../../library/ssl.rst:177
msgid "3DES was dropped from the default cipher string."
msgstr "3DES було видалено з рядка шифру за замовчуванням."

#: ../../library/ssl.rst:181
msgid "Support for key logging to :envvar:`SSLKEYLOGFILE` was added."
msgstr "Додано підтримку реєстрації ключів у :envvar:`SSLKEYLOGFILE`."

#: ../../library/ssl.rst:185
msgid "Exceptions"
msgstr "Exceções"

#: ../../library/ssl.rst:189
msgid ""
"Raised to signal an error from the underlying SSL implementation (currently "
"provided by the OpenSSL library).  This signifies some problem in the higher-"
"level encryption and authentication layer that's superimposed on the "
"underlying network connection.  This error is a subtype of :exc:`OSError`.  "
"The error code and message of :exc:`SSLError` instances are provided by the "
"OpenSSL library."
msgstr ""
"Піднято, щоб повідомити про помилку базової реалізації SSL (наразі надається "
"бібліотекою OpenSSL). Це означає певну проблему на рівні шифрування та "
"автентифікації вищого рівня, який накладається на базове мережеве з’єднання. "
"Ця помилка є підтипом :exc:`OSError`. Код помилки та повідомлення "
"екземплярів :exc:`SSLError` надає бібліотека OpenSSL."

#: ../../library/ssl.rst:196
msgid ":exc:`SSLError` used to be a subtype of :exc:`socket.error`."
msgstr ":exc:`SSLError` раніше був підтипом :exc:`socket.error`."

#: ../../library/ssl.rst:201
msgid ""
"A string mnemonic designating the OpenSSL submodule in which the error "
"occurred, such as ``SSL``, ``PEM`` or ``X509``.  The range of possible "
"values depends on the OpenSSL version."
msgstr ""
"Рядкова мнемоніка, що позначає субмодуль OpenSSL, у якому сталася помилка, "
"наприклад ``SSL``, ``PEM`` або ``X509``. Діапазон можливих значень залежить "
"від версії OpenSSL."

#: ../../library/ssl.rst:209
msgid ""
"A string mnemonic designating the reason this error occurred, for example "
"``CERTIFICATE_VERIFY_FAILED``.  The range of possible values depends on the "
"OpenSSL version."
msgstr ""
"Рядок мнемоніки, що вказує причину цієї помилки, наприклад "
"``CERTIFICATE_VERIFY_FAILED``. Діапазон можливих значень залежить від версії "
"OpenSSL."

#: ../../library/ssl.rst:217
msgid ""
"A subclass of :exc:`SSLError` raised when trying to read or write and the "
"SSL connection has been closed cleanly.  Note that this doesn't mean that "
"the underlying transport (read TCP) has been closed."
msgstr ""
"Підклас :exc:`SSLError` викликається під час спроби читання або запису, а "
"SSL-з’єднання було закрито. Зауважте, що це не означає, що основний "
"транспорт (читай TCP) закрито."

#: ../../library/ssl.rst:225
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"received on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"Підклас :exc:`SSLError`, викликаний :ref:`неблокуючим SSL-сокетом <ssl-"
"nonblocking>` під час спроби прочитати або записати дані, але для виконання "
"запиту потрібно отримати більше даних базовим транспортом TCP."

#: ../../library/ssl.rst:234
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"sent on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"Підклас :exc:`SSLError`, викликаний :ref:`неблокуючим SSL-сокетом <ssl-"
"nonblocking>` під час спроби прочитати або записати дані, але більше даних "
"потрібно надіслати базовим транспортом TCP, перш ніж запит буде виконано."

#: ../../library/ssl.rst:243
msgid ""
"A subclass of :exc:`SSLError` raised when a system error was encountered "
"while trying to fulfill an operation on a SSL socket.  Unfortunately, there "
"is no easy way to inspect the original errno number."
msgstr ""
"Підклас :exc:`SSLError` викликається, коли виникла системна помилка під час "
"спроби виконати операцію на SSL-сокеті. На жаль, немає простого способу "
"перевірити оригінальний номер errno."

#: ../../library/ssl.rst:251
msgid ""
"A subclass of :exc:`SSLError` raised when the SSL connection has been "
"terminated abruptly.  Generally, you shouldn't try to reuse the underlying "
"transport when this error is encountered."
msgstr ""
"Підклас :exc:`SSLError` викликається, коли з’єднання SSL було раптово "
"розірвано. Як правило, ви не повинні намагатися повторно використовувати "
"базовий транспорт, коли виникає ця помилка."

#: ../../library/ssl.rst:259
msgid ""
"A subclass of :exc:`SSLError` raised when certificate validation has failed."
msgstr ""
"Підклас :exc:`SSLError` викликається, коли не вдається перевірити сертифікат."

#: ../../library/ssl.rst:266
msgid "A numeric error number that denotes the verification error."
msgstr "Числовий номер помилки, який позначає помилку підтвердження."

#: ../../library/ssl.rst:270
msgid "A human readable string of the verification error."
msgstr "Зрозумілий для людини рядок помилки перевірки."

#: ../../library/ssl.rst:274
msgid "An alias for :exc:`SSLCertVerificationError`."
msgstr "Псевдонім для :exc:`SSLCertVerificationError`."

#: ../../library/ssl.rst:276
msgid "The exception is now an alias for :exc:`SSLCertVerificationError`."
msgstr "Винятком тепер є псевдонім для :exc:`SSLCertVerificationError`."

#: ../../library/ssl.rst:281
msgid "Random generation"
msgstr "Випадкова генерація"

#: ../../library/ssl.rst:285
msgid ""
"Return *num* cryptographically strong pseudo-random bytes. Raises an :class:"
"`SSLError` if the PRNG has not been seeded with enough data or if the "
"operation is not supported by the current RAND method. :func:`RAND_status` "
"can be used to check the status of the PRNG and :func:`RAND_add` can be used "
"to seed the PRNG."
msgstr ""
"Повертає *num* криптографічно надійних псевдовипадкових байтів. Викликає :"
"class:`SSLError`, якщо PRNG не було заповнено достатньою кількістю даних або "
"якщо операція не підтримується поточним методом RAND. :func:`RAND_status` "
"можна використовувати для перевірки статусу PRNG, а :func:`RAND_add` можна "
"використовувати для заповнення PRNG."

#: ../../library/ssl.rst:291 ../../library/ssl.rst:312
msgid "For almost all applications :func:`os.urandom` is preferable."
msgstr "Майже для всіх програм :func:`os.urandom` є кращим."

#: ../../library/ssl.rst:293
msgid ""
"Read the Wikipedia article, `Cryptographically secure pseudorandom number "
"generator (CSPRNG) <https://en.wikipedia.org/wiki/"
"Cryptographically_secure_pseudorandom_number_generator>`_, to get the "
"requirements of a cryptographically strong generator."
msgstr ""
"Прочитайте статтю Вікіпедії `Криптографічно захищений генератор "
"псевдовипадкових чисел (CSPRNG) <https://en.wikipedia.org/wiki/"
"Cryptographically_secure_pseudorandom_number_generator>`_, щоб дізнатися про "
"вимоги до криптографічно надійного генератора."

#: ../../library/ssl.rst:302
msgid ""
"Return (bytes, is_cryptographic): bytes are *num* pseudo-random bytes, "
"is_cryptographic is ``True`` if the bytes generated are cryptographically "
"strong. Raises an :class:`SSLError` if the operation is not supported by the "
"current RAND method."
msgstr ""
"Повернення (байти, is_cryptographic): байти — це *кількість* "
"псевдовипадкових байтів, is_cryptographic має значення ``True``, якщо "
"згенеровані байти є криптографічно надійними. Викликає :class:`SSLError`, "
"якщо операція не підтримується поточним методом RAND."

#: ../../library/ssl.rst:307
msgid ""
"Generated pseudo-random byte sequences will be unique if they are of "
"sufficient length, but are not necessarily unpredictable. They can be used "
"for non-cryptographic purposes and for certain purposes in cryptographic "
"protocols, but usually not for key generation etc."
msgstr ""
"Згенеровані псевдовипадкові послідовності байтів будуть унікальними, якщо "
"вони мають достатню довжину, але не обов’язково є непередбачуваними. Їх "
"можна використовувати для некриптографічних цілей і для певних цілей у "
"криптографічних протоколах, але зазвичай не для генерації ключів тощо."

#: ../../library/ssl.rst:318
msgid ""
"OpenSSL has deprecated :func:`ssl.RAND_pseudo_bytes`, use :func:`ssl."
"RAND_bytes` instead."
msgstr ""
"OpenSSL застарів :func:`ssl.RAND_pseudo_bytes`, замість нього "
"використовуйте :func:`ssl.RAND_bytes`."

#: ../../library/ssl.rst:323
msgid ""
"Return ``True`` if the SSL pseudo-random number generator has been seeded "
"with 'enough' randomness, and ``False`` otherwise.  You can use :func:`ssl."
"RAND_egd` and :func:`ssl.RAND_add` to increase the randomness of the pseudo-"
"random number generator."
msgstr ""
"Повертає ``True``, якщо генератор псевдовипадкових чисел SSL заповнено "
"достатньою випадковістю, і ``False`` в іншому випадку. Ви можете "
"використовувати :func:`ssl.RAND_egd` і :func:`ssl.RAND_add`, щоб збільшити "
"випадковість генератора псевдовипадкових чисел."

#: ../../library/ssl.rst:330
msgid ""
"If you are running an entropy-gathering daemon (EGD) somewhere, and *path* "
"is the pathname of a socket connection open to it, this will read 256 bytes "
"of randomness from the socket, and add it to the SSL pseudo-random number "
"generator to increase the security of generated secret keys.  This is "
"typically only necessary on systems without better sources of randomness."
msgstr ""

#: ../../library/ssl.rst:336
msgid ""
"See http://egd.sourceforge.net/ or http://prngd.sourceforge.net/ for sources "
"of entropy-gathering daemons."
msgstr ""

#: ../../library/ssl.rst:339
msgid ""
":ref:`Availability <availability>`: not available with LibreSSL and OpenSSL "
"> 1.1.0."
msgstr ""

#: ../../library/ssl.rst:343
msgid ""
"Mix the given *bytes* into the SSL pseudo-random number generator.  The "
"parameter *entropy* (a float) is a lower bound on the entropy contained in "
"string (so you can always use :const:`0.0`).  See :rfc:`1750` for more "
"information on sources of entropy."
msgstr ""
"Змішайте надані *байти* в генераторі псевдовипадкових чисел SSL. Параметр "
"*entropy* (float) є нижньою межею ентропії, яка міститься в рядку (тому ви "
"завжди можете використовувати :const:`0.0`). Перегляньте :rfc:`1750` для "
"отримання додаткової інформації про джерела ентропії."

#: ../../library/ssl.rst:348
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "Записуваний :term:`bytes-like object` тепер приймається."

#: ../../library/ssl.rst:352
msgid "Certificate handling"
msgstr "Manipulação de certificados"

#: ../../library/ssl.rst:360
msgid ""
"Verify that *cert* (in decoded format as returned by :meth:`SSLSocket."
"getpeercert`) matches the given *hostname*.  The rules applied are those for "
"checking the identity of HTTPS servers as outlined in :rfc:`2818`, :rfc:"
"`5280` and :rfc:`6125`.  In addition to HTTPS, this function should be "
"suitable for checking the identity of servers in various SSL-based protocols "
"such as FTPS, IMAPS, POPS and others."
msgstr ""
"Переконайтеся, що *cert* (у декодованому форматі, який повертає :meth:"
"`SSLSocket.getpeercert`) відповідає заданому *назві хосту*. Застосовуються "
"правила для перевірки ідентичності серверів HTTPS, як описано в :rfc:"
"`2818`, :rfc:`5280` та :rfc:`6125`. Окрім HTTPS, ця функція має бути "
"придатною для перевірки ідентичності серверів у різних протоколах на основі "
"SSL, таких як FTPS, IMAPS, POPS та інші."

#: ../../library/ssl.rst:367
msgid ""
":exc:`CertificateError` is raised on failure. On success, the function "
"returns nothing::"
msgstr ""
":exc:`CertificateError` виникає в разі помилки. У разі успіху функція нічого "
"не повертає::"

#: ../../library/ssl.rst:380
msgid ""
"The function now follows :rfc:`6125`, section 6.4.3 and does neither match "
"multiple wildcards (e.g. ``*.*.com`` or ``*a*.example.org``) nor a wildcard "
"inside an internationalized domain names (IDN) fragment. IDN A-labels such "
"as ``www*.xn--pthon-kva.org`` are still supported, but ``x*.python.org`` no "
"longer matches ``xn--tda.python.org``."
msgstr ""
"Функція тепер відповідає :rfc:`6125`, розділ 6.4.3, і не відповідає ні "
"кільком символам підстановки (наприклад, ``*.*.com`` або ``*a*.example."
"org``), ні символу підстановки всередині фрагмент інтернаціоналізованих "
"доменних імен (IDN). А-мітки IDN, такі як ``www*.xn--pthon-kva.org``, як і "
"раніше підтримуються, але ``x*.python.org`` більше не відповідає ``xn--tda."
"python.org``."

#: ../../library/ssl.rst:387
msgid ""
"Matching of IP addresses, when present in the subjectAltName field of the "
"certificate, is now supported."
msgstr ""
"Тепер підтримується зіставлення IP-адрес, якщо вони присутні в полі "
"subjectAltName сертифіката."

#: ../../library/ssl.rst:391
msgid ""
"The function is no longer used to TLS connections. Hostname matching is now "
"performed by OpenSSL."
msgstr ""
"Ця функція більше не використовується для підключень TLS. Зіставлення імен "
"хостів тепер виконує OpenSSL."

#: ../../library/ssl.rst:395
msgid ""
"Allow wildcard when it is the leftmost and the only character in that "
"segment. Partial wildcards like ``www*.example.com`` are no longer supported."
msgstr ""
"Дозволити підстановку, якщо це крайній лівий і єдиний символ у сегменті. "
"Часткові символи узагальнення, наприклад ``www*.example.com`` більше не "
"підтримуються."

#: ../../library/ssl.rst:403
msgid ""
"Return the time in seconds since the Epoch, given the ``cert_time`` string "
"representing the \"notBefore\" or \"notAfter\" date from a certificate in "
"``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale)."
msgstr ""
"Повертає час у секундах з епохи, враховуючи рядок ``cert_time``, що "
"представляє дату \"notBefore\" або \"notAfter\" із сертифіката в ``\"%b %d "
"%H:%M:%S %Y %Z\"`` формат strptime (C локаль)."

#: ../../library/ssl.rst:408
msgid "Here's an example:"
msgstr "Ось приклад:"

#: ../../library/ssl.rst:420
msgid "\"notBefore\" or \"notAfter\" dates must use GMT (:rfc:`5280`)."
msgstr ""
"Дати \"notBefore\" або \"notAfter\" мають використовувати GMT (:rfc:`5280`)."

#: ../../library/ssl.rst:422
msgid ""
"Interpret the input time as a time in UTC as specified by 'GMT' timezone in "
"the input string. Local timezone was used previously. Return an integer (no "
"fractions of a second in the input format)"
msgstr ""
"Інтерпретуйте введений час як час у UTC, як зазначено часовим поясом \"GMT\" "
"у вхідному рядку. Раніше використовувався місцевий часовий пояс. Повертає "
"ціле число (без часток секунди у форматі введення)"

#: ../../library/ssl.rst:430
msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as a "
"PEM-encoded string.  If ``ssl_version`` is specified, uses that version of "
"the SSL protocol to attempt to connect to the server.  If ``ca_certs`` is "
"specified, it should be a file containing a list of root certificates, the "
"same format as used for the same parameter in :meth:`SSLContext."
"wrap_socket`.  The call will attempt to validate the server certificate "
"against that set of root certificates, and will fail if the validation "
"attempt fails."
msgstr ""

#: ../../library/ssl.rst:440
msgid "This function is now IPv6-compatible."
msgstr "Тепер ця функція сумісна з IPv6."

#: ../../library/ssl.rst:443
msgid ""
"The default *ssl_version* is changed from :data:`PROTOCOL_SSLv3` to :data:"
"`PROTOCOL_TLS` for maximum compatibility with modern servers."
msgstr ""
"Стандартну *ssl_version* змінено з :data:`PROTOCOL_SSLv3` на :data:"
"`PROTOCOL_TLS` для максимальної сумісності з сучасними серверами."

#: ../../library/ssl.rst:449
msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded "
"string version of the same certificate."
msgstr ""
"Надано сертифікат як DER-кодований блок байтів, повертає PEM-кодовану "
"рядкову версію того самого сертифіката."

#: ../../library/ssl.rst:454
msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded sequence "
"of bytes for that same certificate."
msgstr ""
"Надано сертифікат як рядок ASCII PEM, повертає закодовану DER послідовність "
"байтів для того самого сертифіката."

#: ../../library/ssl.rst:459
msgid ""
"Returns a named tuple with paths to OpenSSL's default cafile and capath. The "
"paths are the same as used by :meth:`SSLContext.set_default_verify_paths`. "
"The return value is a :term:`named tuple` ``DefaultVerifyPaths``:"
msgstr ""
"Повертає іменований кортеж із шляхами до cafile і capath OpenSSL за "
"замовчуванням. Шляхи такі самі, як і :meth:`SSLContext."
"set_default_verify_paths`. Поверненим значенням є :term:`named tuple` "
"``DefaultVerifyPaths``:"

#: ../../library/ssl.rst:464
msgid ""
":attr:`cafile` - resolved path to cafile or ``None`` if the file doesn't "
"exist,"
msgstr ""
":attr:`cafile` - визначений шлях до cafile або ``None``, якщо файл не існує,"

#: ../../library/ssl.rst:465
msgid ""
":attr:`capath` - resolved path to capath or ``None`` if the directory "
"doesn't exist,"
msgstr ""
":attr:`capath` - дозволений шлях до capath або ``None``, якщо каталог не "
"існує,"

#: ../../library/ssl.rst:466
msgid ""
":attr:`openssl_cafile_env` - OpenSSL's environment key that points to a "
"cafile,"
msgstr ""
":attr:`openssl_cafile_env` - ключ середовища OpenSSL, який вказує на cafile,"

#: ../../library/ssl.rst:467
msgid ":attr:`openssl_cafile` - hard coded path to a cafile,"
msgstr ":attr:`openssl_cafile` - жорстко закодований шлях до cafile,"

#: ../../library/ssl.rst:468
msgid ""
":attr:`openssl_capath_env` - OpenSSL's environment key that points to a "
"capath,"
msgstr ""
":attr:`openssl_capath_env` - ключ середовища OpenSSL, який вказує на capath,"

#: ../../library/ssl.rst:469
msgid ":attr:`openssl_capath` - hard coded path to a capath directory"
msgstr ":attr:`openssl_capath` - жорстко закодований шлях до каталогу capath"

#: ../../library/ssl.rst:473
msgid ""
":ref:`Availability <availability>`: LibreSSL ignores the environment vars :"
"attr:`openssl_cafile_env` and :attr:`openssl_capath_env`."
msgstr ""
":ref:`Доступність <availability>`: LibreSSL ігнорує змінні середовища :attr:"
"`openssl_cafile_env` і :attr:`openssl_capath_env`."

#: ../../library/ssl.rst:478
msgid ""
"Retrieve certificates from Windows' system cert store. *store_name* may be "
"one of ``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert "
"stores, too."
msgstr ""
"Отримати сертифікати зі сховища сертифікатів системи Windows. *store_name* "
"може бути одним із ``CA``, ``ROOT`` або ``MY``. Windows також може надавати "
"додаткові сховища сертифікатів."

#: ../../library/ssl.rst:482
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 "
"data. Trust specifies the purpose of the certificate as a set of OIDS or "
"exactly ``True`` if the certificate is trustworthy for all purposes."
msgstr ""
"Функція повертає список кортежів (cert_bytes, encoding_type, trust). "
"Encoding_type визначає кодування cert_bytes. Це або :const:`x509_asn` для "
"даних X.509 ASN.1, або :const:`pkcs_7_asn` для даних PKCS#7 ASN.1. Trust "
"визначає призначення сертифіката як набір OIDS або точно ``True``, якщо "
"сертифікат є надійним для всіх цілей."

#: ../../library/ssl.rst:489 ../../library/ssl.rst:1585
#: ../../library/ssl.rst:1900
msgid "Example::"
msgstr "Exemplo::"

#: ../../library/ssl.rst:496 ../../library/ssl.rst:511
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Availability <availability>`: Windows."

#: ../../library/ssl.rst:501
msgid ""
"Retrieve CRLs from Windows' system cert store. *store_name* may be one of "
"``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert stores, too."
msgstr ""
"Отримати CRL із сховища системних сертифікатів Windows. *store_name* може "
"бути одним із ``CA``, ``ROOT`` або ``MY``. Windows також може надавати "
"додаткові сховища сертифікатів."

#: ../../library/ssl.rst:505
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 data."
msgstr ""
"Функція повертає список кортежів (cert_bytes, encoding_type, trust). "
"Encoding_type визначає кодування cert_bytes. Це або :const:`x509_asn` для "
"даних X.509 ASN.1, або :const:`pkcs_7_asn` для даних PKCS#7 ASN.1."

#: ../../library/ssl.rst:519
msgid ""
"Takes an instance ``sock`` of :class:`socket.socket`, and returns an "
"instance of :class:`ssl.SSLSocket`, a subtype of :class:`socket.socket`, "
"which wraps the underlying socket in an SSL context.  ``sock`` must be a :"
"data:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""
"Бере екземпляр ``sock`` :class:`socket.socket` і повертає екземпляр :class:"
"`ssl.SSLSocket`, підтип :class:`socket.socket`, який обертає основний сокет "
"у контекст SSL. ``sock`` має бути :data:`~socket.SOCK_STREAM` сокетом; інші "
"типи сокетів не підтримуються."

#: ../../library/ssl.rst:524
msgid ""
"Internally, function creates a :class:`SSLContext` with protocol "
"*ssl_version* and :attr:`SSLContext.options` set to *cert_reqs*. If "
"parameters *keyfile*, *certfile*, *ca_certs* or *ciphers* are set, then the "
"values are passed to :meth:`SSLContext.load_cert_chain`, :meth:`SSLContext."
"load_verify_locations`, and :meth:`SSLContext.set_ciphers`."
msgstr ""
"Внутрішньо функція створює :class:`SSLContext` із протоколом *ssl_version* "
"і :attr:`SSSLContext.options` зі значенням *cert_reqs*. Якщо встановлено "
"параметри *keyfile*, *certfile*, *ca_certs* або *ciphers*, тоді значення "
"передаються до :meth:`SSLContext.load_cert_chain`, :meth:`SSLContext."
"load_verify_locations` і :meth:`SSLContext .set_ciphers`."

#: ../../library/ssl.rst:531
msgid ""
"The arguments *server_side*, *do_handshake_on_connect*, and "
"*suppress_ragged_eofs* have the same meaning as :meth:`SSLContext."
"wrap_socket`."
msgstr ""
"Аргументи *server_side*, *do_handshake_on_connect* і *suppress_ragged_eofs* "
"мають те саме значення, що й :meth:`SSLContext.wrap_socket`."

#: ../../library/ssl.rst:537
msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the :meth:`SSLContext."
"wrap_socket` instead of :func:`wrap_socket`. The top-level function is "
"limited and creates an insecure client socket without server name indication "
"or hostname matching."
msgstr ""
"Починаючи з Python 3.2 і 2.7.9, рекомендується використовувати :meth:"
"`SSLContext.wrap_socket` замість :func:`wrap_socket`. Функція верхнього "
"рівня обмежена та створює незахищений клієнтський сокет без індикації імені "
"сервера або відповідності імені хоста."

#: ../../library/ssl.rst:543
msgid "Constants"
msgstr "Constantes"

#: ../../library/ssl.rst:545
msgid ""
"All constants are now :class:`enum.IntEnum` or :class:`enum.IntFlag` "
"collections."
msgstr ""
"Усі константи тепер є колекціями :class:`enum.IntEnum` або :class:`enum."
"IntFlag`."

#: ../../library/ssl.rst:551
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  Except for :const:`PROTOCOL_TLS_CLIENT`, "
"it is the default mode.  With client-side sockets, just about any cert is "
"accepted.  Validation errors, such as untrusted or expired cert, are ignored "
"and do not abort the TLS/SSL handshake."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_mode` або параметра "
"``cert_reqs`` для :func:`wrap_socket`. За винятком :const:"
"`PROTOCOL_TLS_CLIENT`, це режим за замовчуванням. З сокетами на стороні "
"клієнта приймаються майже будь-які сертифікати. Помилки перевірки, такі як "
"ненадійний або прострочений сертифікат, ігноруються та не переривають "
"рукостискання TLS/SSL."

#: ../../library/ssl.rst:557
msgid ""
"In server mode, no certificate is requested from the client, so the client "
"does not send any for client cert authentication."
msgstr ""
"У режимі сервера від клієнта не запитується сертифікат, тому клієнт не "
"надсилає жодного сертифіката для автентифікації клієнта."

#: ../../library/ssl.rst:560 ../../library/ssl.rst:2330
msgid "See the discussion of :ref:`ssl-security` below."
msgstr "Дивіться обговорення :ref:`ssl-security` нижче."

#: ../../library/ssl.rst:564
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In client mode, :const:`CERT_OPTIONAL` "
"has the same meaning as :const:`CERT_REQUIRED`. It is recommended to use :"
"const:`CERT_REQUIRED` for client-side sockets instead."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_mode` або параметра "
"``cert_reqs`` для :func:`wrap_socket`. У режимі клієнта :const:"
"`CERT_OPTIONAL` має те саме значення, що і :const:`CERT_REQUIRED`. "
"Рекомендується використовувати :const:`CERT_REQUIRED` для клієнтських "
"сокетів."

#: ../../library/ssl.rst:569
msgid ""
"In server mode, a client certificate request is sent to the client.  The "
"client may either ignore the request or send a certificate in order perform "
"TLS client cert authentication.  If the client chooses to send a "
"certificate, it is verified.  Any verification error immediately aborts the "
"TLS handshake."
msgstr ""
"У режимі сервера клієнту надсилається запит на сертифікат клієнта. Клієнт "
"може або проігнорувати запит, або надіслати сертифікат, щоб виконати "
"автентифікацію клієнта за допомогою TLS. Якщо клієнт вирішує надіслати "
"сертифікат, він перевіряється. Будь-яка помилка перевірки негайно перериває "
"рукостискання TLS."

#: ../../library/ssl.rst:575 ../../library/ssl.rst:595
msgid ""
"Use of this setting requires a valid set of CA certificates to be passed, "
"either to :meth:`SSLContext.load_verify_locations` or as a value of the "
"``ca_certs`` parameter to :func:`wrap_socket`."
msgstr ""
"Для використання цього параметра потрібен дійсний набір сертифікатів ЦС у :"
"meth:`SSLContext.load_verify_locations` або як значення параметра "
"``ca_certs`` у :func:`wrap_socket`."

#: ../../library/ssl.rst:581
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode, certificates are required "
"from the other side of the socket connection; an :class:`SSLError` will be "
"raised if no certificate is provided, or if its validation fails. This mode "
"is **not** sufficient to verify a certificate in client mode as it does not "
"match hostnames.  :attr:`~SSLContext.check_hostname` must be enabled as well "
"to verify the authenticity of a cert. :const:`PROTOCOL_TLS_CLIENT` uses :"
"const:`CERT_REQUIRED` and enables :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_mode` або параметра "
"``cert_reqs`` для :func:`wrap_socket`. У цьому режимі потрібні сертифікати з "
"іншого боку сокет-з’єднання; :class:`SSLError` буде викликано, якщо "
"сертифікат не надано, або якщо його перевірка не вдається. Цього режиму "
"**не** достатньо для перевірки сертифіката в режимі клієнта, оскільки він не "
"відповідає іменам хостів. :attr:`~SSLContext.check_hostname` також має бути "
"ввімкнено, щоб перевірити автентичність сертифіката. :const:"
"`PROTOCOL_TLS_CLIENT` використовує :const:`CERT_REQUIRED` і вмикає :attr:"
"`~SSLContext.check_hostname` за умовчанням."

#: ../../library/ssl.rst:591
msgid ""
"With server socket, this mode provides mandatory TLS client cert "
"authentication.  A client certificate request is sent to the client and the "
"client must provide a valid and trusted certificate."
msgstr ""
"З серверним сокетом цей режим забезпечує обов’язкову автентифікацію клієнта "
"за допомогою TLS. Запит на сертифікат клієнта надсилається клієнту, і клієнт "
"повинен надати дійсний і надійний сертифікат."

#: ../../library/ssl.rst:601
msgid ":class:`enum.IntEnum` collection of CERT_* constants."
msgstr ":class:`enum.IntEnum` колекція констант CERT_*."

#: ../../library/ssl.rst:607
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, "
"certificate revocation lists (CRLs) are not checked. By default OpenSSL does "
"neither require nor verify CRLs."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_flags`. У цьому режимі списки "
"відкликаних сертифікатів (CRL) не перевіряються. За замовчуванням OpenSSL не "
"вимагає і не перевіряє CRL."

#: ../../library/ssl.rst:615
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, only the "
"peer cert is checked but none of the intermediate CA certificates. The mode "
"requires a valid CRL that is signed by the peer cert's issuer (its direct "
"ancestor CA). If no proper CRL has been loaded with :attr:`SSLContext."
"load_verify_locations`, validation will fail."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_flags`. У цьому режимі "
"перевіряється лише одноранговий сертифікат, але не перевіряються проміжні "
"сертифікати ЦС. Для режиму потрібен дійсний CRL, підписаний видавцем "
"однорангового сертифіката (його прямим предком CA). Якщо не було завантажено "
"відповідний CRL з :attr:`SSLContext.load_verify_locations`, перевірка не "
"вдасться."

#: ../../library/ssl.rst:625
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, CRLs of "
"all certificates in the peer cert chain are checked."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_flags`. У цьому режимі "
"перевіряються CRL усіх сертифікатів у ланцюжку однорангових сертифікатів."

#: ../../library/ssl.rst:632
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to disable workarounds "
"for broken X.509 certificates."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_flags` для вимкнення обхідних "
"шляхів для пошкоджених сертифікатів X.509."

#: ../../library/ssl.rst:639
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"prefer trusted certificates when building the trust chain to validate a "
"certificate. This flag is enabled by default."
msgstr ""
"Можливе значення для :attr:`SSLContext.verify_flags`. Він наказує OpenSSL "
"віддавати перевагу надійним сертифікатам під час побудови ланцюжка довіри "
"для перевірки сертифіката. Цей прапорець увімкнено за замовчуванням."

#: ../../library/ssl.rst:647
msgid ":class:`enum.IntFlag` collection of VERIFY_* constants."
msgstr ":class:`enum.IntFlag` колекція констант VERIFY_*."

#: ../../library/ssl.rst:653
msgid ""
"Selects the highest protocol version that both the client and server "
"support. Despite the name, this option can select both \"SSL\" and \"TLS\" "
"protocols."
msgstr ""
"Вибирає найвищу версію протоколу, яку підтримують як клієнт, так і сервер. "
"Незважаючи на назву, ця опція може вибрати як протоколи \"SSL\", так і "
"\"TLS\"."

#: ../../library/ssl.rst:660
msgid ""
"Auto-negotiate the highest protocol version like :data:`PROTOCOL_TLS`, but "
"only support client-side :class:`SSLSocket` connections. The protocol "
"enables :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""

#: ../../library/ssl.rst:669
msgid ""
"Auto-negotiate the highest protocol version like :data:`PROTOCOL_TLS`, but "
"only support server-side :class:`SSLSocket` connections."
msgstr ""

#: ../../library/ssl.rst:676
msgid "Alias for :data:`PROTOCOL_TLS`."
msgstr "Псевдонім для :data:`PROTOCOL_TLS`."

#: ../../library/ssl.rst:680
msgid "Use :data:`PROTOCOL_TLS` instead."
msgstr "Натомість використовуйте :data:`PROTOCOL_TLS`."

#: ../../library/ssl.rst:684
msgid "Selects SSL version 2 as the channel encryption protocol."
msgstr "Вибирає SSL версії 2 як протокол шифрування каналу."

#: ../../library/ssl.rst:686
msgid ""
"This protocol is not available if OpenSSL is compiled with the "
"``OPENSSL_NO_SSL2`` flag."
msgstr ""

#: ../../library/ssl.rst:691
msgid "SSL version 2 is insecure.  Its use is highly discouraged."
msgstr "SSL версії 2 небезпечний. Його використання вкрай не рекомендується."

#: ../../library/ssl.rst:695
msgid "OpenSSL has removed support for SSLv2."
msgstr "OpenSSL припиняє підтримку SSLv2."

#: ../../library/ssl.rst:699
msgid "Selects SSL version 3 as the channel encryption protocol."
msgstr "Вибирає SSL версії 3 як протокол шифрування каналу."

#: ../../library/ssl.rst:701
msgid ""
"This protocol is not be available if OpenSSL is compiled with the "
"``OPENSSL_NO_SSLv3`` flag."
msgstr ""

#: ../../library/ssl.rst:706
msgid "SSL version 3 is insecure.  Its use is highly discouraged."
msgstr "SSL версії 3 небезпечний. Його використання вкрай не рекомендується."

#: ../../library/ssl.rst:710 ../../library/ssl.rst:719
#: ../../library/ssl.rst:731 ../../library/ssl.rst:744
msgid ""
"OpenSSL has deprecated all version specific protocols. Use the default "
"protocol :data:`PROTOCOL_TLS` with flags like :data:`OP_NO_SSLv3` instead."
msgstr ""

#: ../../library/ssl.rst:715
msgid "Selects TLS version 1.0 as the channel encryption protocol."
msgstr "Вибирає TLS версії 1.0 як протокол шифрування каналу."

#: ../../library/ssl.rst:724
msgid ""
"Selects TLS version 1.1 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr ""
"Вибирає TLS версії 1.1 як протокол шифрування каналу. Доступно лише з "
"openssl версії 1.0.1+."

#: ../../library/ssl.rst:736
msgid ""
"Selects TLS version 1.2 as the channel encryption protocol. This is the most "
"modern version, and probably the best choice for maximum protection, if both "
"sides can speak it.  Available only with openssl version 1.0.1+."
msgstr ""

#: ../../library/ssl.rst:749
msgid ""
"Enables workarounds for various bugs present in other SSL implementations. "
"This option is set by default.  It does not necessarily set the same flags "
"as OpenSSL's ``SSL_OP_ALL`` constant."
msgstr ""
"Дозволяє обійти різні помилки, наявні в інших реалізаціях SSL. Ця опція "
"встановлена за замовчуванням. Він не обов’язково встановлює ті самі "
"позначки, що й константа ``SSL_OP_ALL`` OpenSSL."

#: ../../library/ssl.rst:757
msgid ""
"Prevents an SSLv2 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv2 as "
"the protocol version."
msgstr ""
"Запобігає підключенню SSLv2. Цей параметр застосовний лише в поєднанні з :"
"const:`PROTOCOL_TLS`. Це запобігає вибору одноранговими вузлами SSLv2 як "
"версії протоколу."

#: ../../library/ssl.rst:765
msgid "SSLv2 is deprecated"
msgstr "SSLv2 застарів"

#: ../../library/ssl.rst:770
msgid ""
"Prevents an SSLv3 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv3 as "
"the protocol version."
msgstr ""
"Запобігає підключенню SSLv3. Цей параметр застосовний лише в поєднанні з :"
"const:`PROTOCOL_TLS`. Це запобігає вибору одноранговими вузлами SSLv3 як "
"версії протоколу."

#: ../../library/ssl.rst:778
msgid "SSLv3 is deprecated"
msgstr "SSLv3 застарів"

#: ../../library/ssl.rst:782
msgid ""
"Prevents a TLSv1 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing TLSv1 as "
"the protocol version."
msgstr ""
"Запобігає підключенню TLSv1. Цей параметр застосовний лише в поєднанні з :"
"const:`PROTOCOL_TLS`. Це запобігає вибору партнерами TLSv1 як версії "
"протоколу."

#: ../../library/ssl.rst:788
msgid ""
"The option is deprecated since OpenSSL 1.1.0, use the new :attr:`SSLContext."
"minimum_version` and :attr:`SSLContext.maximum_version` instead."
msgstr ""
"Опція застаріла з OpenSSL 1.1.0, замість неї використовуйте нові :attr:"
"`SSLContext.minimum_version` і :attr:`SSSLContext.maximum_version`."

#: ../../library/ssl.rst:795
msgid ""
"Prevents a TLSv1.1 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.1 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"Запобігає підключенню TLSv1.1. Цей параметр застосовний лише в поєднанні з :"
"const:`PROTOCOL_TLS`. Це запобігає вибору одноранговими вузлами TLSv1.1 як "
"версії протоколу. Доступно лише з openssl версії 1.0.1+."

#: ../../library/ssl.rst:801 ../../library/ssl.rst:812
msgid "The option is deprecated since OpenSSL 1.1.0."
msgstr "Опція застаріла з OpenSSL 1.1.0."

#: ../../library/ssl.rst:806
msgid ""
"Prevents a TLSv1.2 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.2 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"Запобігає підключенню TLSv1.2. Цей параметр застосовний лише в поєднанні з :"
"const:`PROTOCOL_TLS`. Це запобігає вибору одноранговими вузлами TLSv1.2 як "
"версії протоколу. Доступно лише з openssl версії 1.0.1+."

#: ../../library/ssl.rst:817
msgid ""
"Prevents a TLSv1.3 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.3 as "
"the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later. When "
"Python has been compiled against an older version of OpenSSL, the flag "
"defaults to *0*."
msgstr ""
"Запобігає підключенню TLSv1.3. Цей параметр застосовний лише в поєднанні з :"
"const:`PROTOCOL_TLS`. Це запобігає вибору одноранговими вузлами TLSv1.3 як "
"версії протоколу. TLS 1.3 доступний з OpenSSL 1.1.1 або новішої версії. Якщо "
"Python скомпільовано зі старішою версією OpenSSL, прапорець за замовчуванням "
"має значення *0*."

#: ../../library/ssl.rst:825
msgid ""
"The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15, 3.6.3 "
"and 3.7.0 for backwards compatibility with OpenSSL 1.0.2."
msgstr ""
"Опція застаріла з OpenSSL 1.1.0. Він був доданий до 2.7.15, 3.6.3 і 3.7.0 "
"для зворотної сумісності з OpenSSL 1.0.2."

#: ../../library/ssl.rst:831
msgid ""
"Disable all renegotiation in TLSv1.2 and earlier. Do not send HelloRequest "
"messages, and ignore renegotiation requests via ClientHello."
msgstr ""
"Вимкніть усі повторні узгодження в TLSv1.2 і попередніх версіях. Не "
"надсилайте повідомлення HelloRequest і ігноруйте запити на повторне "
"узгодження через ClientHello."

#: ../../library/ssl.rst:834
msgid "This option is only available with OpenSSL 1.1.0h and later."
msgstr "Ця опція доступна лише для OpenSSL 1.1.0h і пізніших версій."

#: ../../library/ssl.rst:840
msgid ""
"Use the server's cipher ordering preference, rather than the client's. This "
"option has no effect on client sockets and SSLv2 server sockets."
msgstr ""
"Використовуйте параметри впорядкування шифрів сервера, а не клієнта. Цей "
"параметр не впливає на клієнтські сокети та серверні сокети SSLv2."

#: ../../library/ssl.rst:847
msgid ""
"Prevents re-use of the same DH key for distinct SSL sessions.  This improves "
"forward secrecy but requires more computational resources. This option only "
"applies to server sockets."
msgstr ""
"Запобігає повторному використанню того самого ключа DH для різних сеансів "
"SSL. Це покращує пряму секретність, але вимагає більше обчислювальних "
"ресурсів. Цей параметр стосується лише серверних сокетів."

#: ../../library/ssl.rst:855
msgid ""
"Prevents re-use of the same ECDH key for distinct SSL sessions.  This "
"improves forward secrecy but requires more computational resources. This "
"option only applies to server sockets."
msgstr ""
"Запобігає повторному використанню того самого ключа ECDH для різних сеансів "
"SSL. Це покращує пряму секретність, але вимагає більше обчислювальних "
"ресурсів. Цей параметр стосується лише серверних сокетів."

#: ../../library/ssl.rst:863
msgid ""
"Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make a "
"TLS 1.3 connection look more like a TLS 1.2 connection."
msgstr ""
"Надсилайте фіктивні повідомлення про зміну шифру (CCS) у рукостисканні TLS "
"1.3, щоб зробити з’єднання TLS 1.3 більш схожим на з’єднання TLS 1.2."

#: ../../library/ssl.rst:866
msgid "This option is only available with OpenSSL 1.1.1 and later."
msgstr "Ця опція доступна лише з OpenSSL 1.1.1 і новіших версій."

#: ../../library/ssl.rst:872
msgid ""
"Disable compression on the SSL channel.  This is useful if the application "
"protocol supports its own compression scheme."
msgstr ""
"Вимкніть стиснення на каналі SSL. Це корисно, якщо протокол програми "
"підтримує власну схему стиснення."

#: ../../library/ssl.rst:875
msgid "This option is only available with OpenSSL 1.0.0 and later."
msgstr ""

#: ../../library/ssl.rst:881
msgid ":class:`enum.IntFlag` collection of OP_* constants."
msgstr ":class:`enum.IntFlag` колекція констант OP_*."

#: ../../library/ssl.rst:885
msgid "Prevent client side from requesting a session ticket."
msgstr "Заборонити стороні клієнта запитувати квиток сеансу."

#: ../../library/ssl.rst:891
msgid "Ignore unexpected shutdown of TLS connections."
msgstr "Ігноруйте несподіване завершення з’єднань TLS."

#: ../../library/ssl.rst:893
msgid "This option is only available with OpenSSL 3.0.0 and later."
msgstr "Цей параметр доступний лише з OpenSSL 3.0.0 і пізніших версій."

#: ../../library/ssl.rst:899
msgid ""
"Whether the OpenSSL library has built-in support for the *Application-Layer "
"Protocol Negotiation* TLS extension as described in :rfc:`7301`."
msgstr ""
"Чи має бібліотека OpenSSL вбудовану підтримку розширення TLS *Application-"
"Layer Protocol Negotiation*, як описано в :rfc:`7301`."

#: ../../library/ssl.rst:906
msgid ""
"Whether the OpenSSL library has built-in support not checking subject common "
"name and :attr:`SSLContext.hostname_checks_common_name` is writeable."
msgstr ""
"Чи має бібліотека OpenSSL вбудовану підтримку, яка не перевіряє загальне "
"ім’я суб’єкта та :attr:`SSLContext.hostname_checks_common_name`, доступний "
"для запису."

#: ../../library/ssl.rst:914
msgid ""
"Whether the OpenSSL library has built-in support for the Elliptic Curve-"
"based Diffie-Hellman key exchange.  This should be true unless the feature "
"was explicitly disabled by the distributor."
msgstr ""
"Чи має бібліотека OpenSSL вбудовану підтримку для обміну ключами Діффі-"
"Хеллмана на основі еліптичної кривої. Це має бути правдою, якщо цю функцію "
"явно не вимкнув розповсюджувач."

#: ../../library/ssl.rst:922
msgid ""
"Whether the OpenSSL library has built-in support for the *Server Name "
"Indication* extension (as defined in :rfc:`6066`)."
msgstr ""
"Чи має бібліотека OpenSSL вбудовану підтримку розширення *Індикація імені "
"сервера* (як визначено в :rfc:`6066`)."

#: ../../library/ssl.rst:929
msgid ""
"Whether the OpenSSL library has built-in support for the *Next Protocol "
"Negotiation* as described in the `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"When true, you can use the :meth:`SSLContext.set_npn_protocols` method to "
"advertise which protocols you want to support."
msgstr ""
"Чи має бібліотека OpenSSL вбудовану підтримку *Узгодження наступного "
"протоколу*, як описано в розділі `Узгодження протоколу прикладного рівня "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"Якщо значення true, ви можете використовувати метод :meth:`SSLContext."
"set_npn_protocols`, щоб повідомити, які протоколи ви хочете підтримувати."

#: ../../library/ssl.rst:939
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 2.0 protocol."
msgstr "Чи бібліотека OpenSSL має вбудовану підтримку протоколу SSL 2.0."

#: ../../library/ssl.rst:945
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 3.0 protocol."
msgstr "Чи має бібліотека OpenSSL вбудовану підтримку протоколу SSL 3.0."

#: ../../library/ssl.rst:951
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.0 protocol."
msgstr "Чи бібліотека OpenSSL має вбудовану підтримку протоколу TLS 1.0."

#: ../../library/ssl.rst:957
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.1 protocol."
msgstr "Чи має бібліотека OpenSSL вбудовану підтримку протоколу TLS 1.1."

#: ../../library/ssl.rst:963
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.2 protocol."
msgstr "Чи бібліотека OpenSSL має вбудовану підтримку протоколу TLS 1.2."

#: ../../library/ssl.rst:969
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.3 protocol."
msgstr "Чи має бібліотека OpenSSL вбудовану підтримку протоколу TLS 1.3."

#: ../../library/ssl.rst:975
msgid ""
"List of supported TLS channel binding types.  Strings in this list can be "
"used as arguments to :meth:`SSLSocket.get_channel_binding`."
msgstr ""
"Список підтримуваних типів прив’язки каналу TLS. Рядки в цьому списку можна "
"використовувати як аргументи для :meth:`SSLSocket.get_channel_binding`."

#: ../../library/ssl.rst:982
msgid "The version string of the OpenSSL library loaded by the interpreter::"
msgstr "Рядок версії бібліотеки OpenSSL, завантажений інтерпретатором::"

#: ../../library/ssl.rst:991
msgid ""
"A tuple of five integers representing version information about the OpenSSL "
"library::"
msgstr ""
"Кортеж із п’яти цілих чисел, що представляє інформацію про версію бібліотеки "
"OpenSSL::"

#: ../../library/ssl.rst:1001
msgid "The raw version number of the OpenSSL library, as a single integer::"
msgstr ""
"Необроблений номер версії бібліотеки OpenSSL у вигляді одного цілого числа::"

#: ../../library/ssl.rst:1014
msgid ""
"Alert Descriptions from :rfc:`5246` and others. The `IANA TLS Alert Registry "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contains this list and references to the RFCs where their "
"meaning is defined."
msgstr ""
"Описи сповіщень від :rfc:`5246` та інших. `Реєстр сповіщень IANA TLS "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ містить цей список і посилання на RFC, де визначено їх "
"значення."

#: ../../library/ssl.rst:1018
msgid ""
"Used as the return value of the callback function in :meth:`SSLContext."
"set_servername_callback`."
msgstr ""
"Використовується як значення, що повертається функцією зворотного виклику в :"
"meth:`SSLContext.set_servername_callback`."

#: ../../library/ssl.rst:1025
msgid ":class:`enum.IntEnum` collection of ALERT_DESCRIPTION_* constants."
msgstr ":class:`enum.IntEnum` колекція констант ALERT_DESCRIPTION_*."

#: ../../library/ssl.rst:1031
msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate Web servers (therefore, it will be used to create client-side "
"sockets)."
msgstr ""

#: ../../library/ssl.rst:1040
msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate Web clients (therefore, it will be used to create server-side "
"sockets)."
msgstr ""

#: ../../library/ssl.rst:1049
msgid ":class:`enum.IntEnum` collection of SSL_ERROR_* constants."
msgstr ":class:`enum.IntEnum` колекція констант SSL_ERROR_*."

#: ../../library/ssl.rst:1055
msgid ""
":class:`enum.IntEnum` collection of SSL and TLS versions for :attr:"
"`SSLContext.maximum_version` and :attr:`SSLContext.minimum_version`."
msgstr ""
":class:`enum.IntEnum` колекція версій SSL і TLS для :attr:`SSLContext."
"maximum_version` і :attr:`SSLContext.minimum_version`."

#: ../../library/ssl.rst:1063
msgid ""
"The minimum or maximum supported SSL or TLS version. These are magic "
"constants. Their values don't reflect the lowest and highest available TLS/"
"SSL versions."
msgstr ""
"Мінімальна або максимальна підтримувана версія SSL або TLS. Це магічні "
"константи. Їх значення не відображають найнижчу та найвищу доступні версії "
"TLS/SSL."

#: ../../library/ssl.rst:1073
msgid "SSL 3.0 to TLS 1.3."
msgstr "SSL 3.0 до TLS 1.3."

#: ../../library/ssl.rst:1077
msgid "SSL Sockets"
msgstr "SSL-сокети"

#: ../../library/ssl.rst:1081
msgid "SSL sockets provide the following methods of :ref:`socket-objects`:"
msgstr "SSL-сокети надають такі методи :ref:`socket-objects`:"

#: ../../library/ssl.rst:1083
msgid ":meth:`~socket.socket.accept()`"
msgstr ":meth:`~socket.socket.accept()`"

#: ../../library/ssl.rst:1084
msgid ":meth:`~socket.socket.bind()`"
msgstr ":meth:`~socket.socket.bind()`"

#: ../../library/ssl.rst:1085
msgid ":meth:`~socket.socket.close()`"
msgstr ":meth:`~socket.socket.close()`"

#: ../../library/ssl.rst:1086
msgid ":meth:`~socket.socket.connect()`"
msgstr ":meth:`~socket.socket.connect()`"

#: ../../library/ssl.rst:1087
msgid ":meth:`~socket.socket.detach()`"
msgstr ":meth:`~socket.socket.detach()`"

#: ../../library/ssl.rst:1088
msgid ":meth:`~socket.socket.fileno()`"
msgstr ":meth:`~socket.socket.fileno()`"

#: ../../library/ssl.rst:1089
msgid ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"
msgstr ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"

#: ../../library/ssl.rst:1090
msgid ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"
msgstr ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"

#: ../../library/ssl.rst:1091
msgid ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, :"
"meth:`~socket.socket.setblocking()`"
msgstr ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, :"
"meth:`~socket.socket.setblocking()`"

#: ../../library/ssl.rst:1093
msgid ":meth:`~socket.socket.listen()`"
msgstr ":meth:`~socket.socket.listen()`"

#: ../../library/ssl.rst:1094
msgid ":meth:`~socket.socket.makefile()`"
msgstr ":meth:`~socket.socket.makefile()`"

#: ../../library/ssl.rst:1095
msgid ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (but "
"passing a non-zero ``flags`` argument is not allowed)"
msgstr ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (але "
"передача ненульового аргументу ``flags`` заборонена)"

#: ../../library/ssl.rst:1097
msgid ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (with the "
"same limitation)"
msgstr ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (з тим самим "
"обмеженням)"

#: ../../library/ssl.rst:1099
msgid ""
":meth:`~socket.socket.sendfile()` (but :mod:`os.sendfile` will be used for "
"plain-text sockets only, else :meth:`~socket.socket.send()` will be used)"
msgstr ""
":meth:`~socket.socket.sendfile()` (але :mod:`os.sendfile` "
"використовуватиметься лише для простих текстових сокетів, інакше "
"використовуватиметься :meth:`~socket.socket.send()` )"

#: ../../library/ssl.rst:1101
msgid ":meth:`~socket.socket.shutdown()`"
msgstr ":meth:`~socket.socket.shutdown()`"

#: ../../library/ssl.rst:1103
msgid ""
"However, since the SSL (and TLS) protocol has its own framing atop of TCP, "
"the SSL sockets abstraction can, in certain respects, diverge from the "
"specification of normal, OS-level sockets.  See especially the :ref:`notes "
"on non-blocking sockets <ssl-nonblocking>`."
msgstr ""
"Однак, оскільки протокол SSL (і TLS) має власне фреймування поверх TCP, "
"абстракція сокетів SSL може в певних аспектах відрізнятися від специфікації "
"звичайних сокетів рівня ОС. Особливо дивіться :ref:`примітки щодо "
"неблокуючих сокетів <ssl-nonblocking>`."

#: ../../library/ssl.rst:1108
msgid ""
"Instances of :class:`SSLSocket` must be created using the :meth:`SSLContext."
"wrap_socket` method."
msgstr ""
"Примірники :class:`SSLSocket` повинні бути створені за допомогою методу :"
"meth:`SSSLContext.wrap_socket`."

#: ../../library/ssl.rst:1111
msgid "The :meth:`sendfile` method was added."
msgstr "Додано метод :meth:`sendfile`."

#: ../../library/ssl.rst:1114
msgid ""
"The :meth:`shutdown` does not reset the socket timeout each time bytes are "
"received or sent. The socket timeout is now to maximum total duration of the "
"shutdown."
msgstr ""

#: ../../library/ssl.rst:1119
msgid ""
"It is deprecated to create a :class:`SSLSocket` instance directly, use :meth:"
"`SSLContext.wrap_socket` to wrap a socket."
msgstr ""
"Безпосереднє створення екземпляра :class:`SSLSocket` є застарілим, "
"використовуйте :meth:`SSSLContext.wrap_socket` для упаковки сокета."

#: ../../library/ssl.rst:1123
msgid ""
":class:`SSLSocket` instances must to created with :meth:`~SSLContext."
"wrap_socket`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""
":class:`SSLSocket` екземпляри повинні бути створені за допомогою :meth:"
"`~SSSLContext.wrap_socket`. У попередніх версіях можна було створювати "
"екземпляри безпосередньо. Це ніколи не було задокументовано чи офіційно "
"підтверджено."

#: ../../library/ssl.rst:1129
msgid "SSL sockets also have the following additional methods and attributes:"
msgstr "SSL-сокети також мають такі додаткові методи та атрибути:"

#: ../../library/ssl.rst:1133
msgid ""
"Read up to *len* bytes of data from the SSL socket and return the result as "
"a ``bytes`` instance. If *buffer* is specified, then read into the buffer "
"instead, and return the number of bytes read."
msgstr ""
"Читайте до *len* байтів даних із SSL-сокета та повертайте результат як "
"екземпляр ``bytes``. Якщо вказано *buffer*, то замість цього зчитується в "
"буфер і повертається кількість прочитаних байтів."

#: ../../library/ssl.rst:1137
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the read would block."
msgstr ""
"Викликайте :exc:`SSLWantReadError` або :exc:`SSLWantWriteError`, якщо сокет :"
"ref:`неблокує <ssl-nonblocking>`, і читання буде заблоковано."

#: ../../library/ssl.rst:1140
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`read` can also "
"cause write operations."
msgstr ""
"Оскільки в будь-який час можливе повторне узгодження, виклик :meth:`read` "
"також може викликати операції запису."

#: ../../library/ssl.rst:1143
msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration to read up to *len* "
"bytes."
msgstr ""

#: ../../library/ssl.rst:1148
msgid "Use :meth:`~SSLSocket.recv` instead of :meth:`~SSLSocket.read`."
msgstr ""
"Використовуйте :meth:`~SSLSocket.recv` замість :meth:`~SSLSocket.read`."

#: ../../library/ssl.rst:1153
msgid ""
"Write *buf* to the SSL socket and return the number of bytes written. The "
"*buf* argument must be an object supporting the buffer interface."
msgstr ""
"Запишіть *buf* у SSL-сокет і поверніть кількість записаних байтів. Аргумент "
"*buf* має бути об’єктом, що підтримує інтерфейс буфера."

#: ../../library/ssl.rst:1156
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the write would block."
msgstr ""
"Викликайте :exc:`SSLWantReadError` або :exc:`SSLWantWriteError`, якщо сокет :"
"ref:`неблокує <ssl-nonblocking>`, і запис буде заблоковано."

#: ../../library/ssl.rst:1159
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`write` can "
"also cause read operations."
msgstr ""
"Оскільки в будь-який час можливе повторне узгодження, виклик :meth:`write` "
"також може викликати операції читання."

#: ../../library/ssl.rst:1162
msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration to write *buf*."
msgstr ""

#: ../../library/ssl.rst:1166
msgid "Use :meth:`~SSLSocket.send` instead of :meth:`~SSLSocket.write`."
msgstr ""
"Використовуйте :meth:`~SSLSocket.send` замість :meth:`~SSLSocket.write`."

#: ../../library/ssl.rst:1171
msgid ""
"The :meth:`~SSLSocket.read` and :meth:`~SSLSocket.write` methods are the low-"
"level methods that read and write unencrypted, application-level data and "
"decrypt/encrypt it to encrypted, wire-level data. These methods require an "
"active SSL connection, i.e. the handshake was completed and :meth:`SSLSocket."
"unwrap` was not called."
msgstr ""
"Методи :meth:`~SSLSocket.read` і :meth:`~SSLSocket.write` є низькорівневими "
"методами, які читають і записують незашифровані дані на рівні програми та "
"розшифровують/шифрують їх у зашифровані дані на рівні проводів. Для цих "
"методів потрібне активне з’єднання SSL, тобто рукостискання завершено і :"
"meth:`SSLSocket.unwrap` не викликано."

#: ../../library/ssl.rst:1177
msgid ""
"Normally you should use the socket API methods like :meth:`~socket.socket."
"recv` and :meth:`~socket.socket.send` instead of these methods."
msgstr ""
"Зазвичай замість цих методів слід використовувати такі методи API сокетів, "
"як :meth:`~socket.socket.recv` і :meth:`~socket.socket.send`."

#: ../../library/ssl.rst:1183
msgid "Perform the SSL setup handshake."
msgstr "Виконайте рукостискання налаштування SSL."

#: ../../library/ssl.rst:1185
msgid ""
"The handshake method also performs :func:`match_hostname` when the :attr:"
"`~SSLContext.check_hostname` attribute of the socket's :attr:`~SSLSocket."
"context` is true."
msgstr ""
"Метод рукостискання також виконує :func:`match_hostname`, якщо атрибут :attr:"
"`~SSLContext.check_hostname` :attr:`~SSLSocket.context` сокета має значення "
"true."

#: ../../library/ssl.rst:1190
msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration of the handshake."
msgstr ""

#: ../../library/ssl.rst:1194
msgid ""
"Hostname or IP address is matched by OpenSSL during handshake. The function :"
"func:`match_hostname` is no longer used. In case OpenSSL refuses a hostname "
"or IP address, the handshake is aborted early and a TLS alert message is "
"send to the peer."
msgstr ""

#: ../../library/ssl.rst:1202
msgid ""
"If there is no certificate for the peer on the other end of the connection, "
"return ``None``.  If the SSL handshake hasn't been done yet, raise :exc:"
"`ValueError`."
msgstr ""
"Якщо немає сертифіката для вузла на іншому кінці з’єднання, поверніть "
"``None``. Якщо SSL-рукостискання ще не виконано, підніміть :exc:`ValueError`."

#: ../../library/ssl.rst:1206
msgid ""
"If the ``binary_form`` parameter is :const:`False`, and a certificate was "
"received from the peer, this method returns a :class:`dict` instance.  If "
"the certificate was not validated, the dict is empty.  If the certificate "
"was validated, it returns a dict with several keys, amongst them ``subject`` "
"(the principal for which the certificate was issued) and ``issuer`` (the "
"principal issuing the certificate).  If a certificate contains an instance "
"of the *Subject Alternative Name* extension (see :rfc:`3280`), there will "
"also be a ``subjectAltName`` key in the dictionary."
msgstr ""
"Якщо параметр ``binary_form`` має значення :const:`False`, а сертифікат "
"отримано від однорангового пристрою, цей метод повертає екземпляр :class:"
"`dict`. Якщо сертифікат не підтверджено, dict порожній. Якщо сертифікат "
"перевірено, він повертає dict із кількома ключами, серед яких ``subject`` "
"(принципал, для якого видано сертифікат) і ``issuer`` (принципал, який видає "
"сертифікат). Якщо сертифікат містить примірник розширення *Subject "
"Alternative Name* (див. :rfc:`3280`), у словнику також буде ключ "
"``subjectAltName``."

#: ../../library/ssl.rst:1215
msgid ""
"The ``subject`` and ``issuer`` fields are tuples containing the sequence of "
"relative distinguished names (RDNs) given in the certificate's data "
"structure for the respective fields, and each RDN is a sequence of name-"
"value pairs.  Here is a real-world example::"
msgstr ""
"Поля ``subject`` і ``issuer`` — це кортежі, що містять послідовність "
"відносних розрізняючих імен (RDN), наведених у структурі даних сертифіката "
"для відповідних полів, і кожен RDN є послідовністю пар ім’я-значення. Ось "
"реальний приклад:"

#: ../../library/ssl.rst:1241
msgid ""
"To validate a certificate for a particular service, you can use the :func:"
"`match_hostname` function."
msgstr ""
"Щоб перевірити сертифікат для певної служби, ви можете скористатися "
"функцією :func:`match_hostname`."

#: ../../library/ssl.rst:1244
msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire certificate "
"as a sequence of bytes, or :const:`None` if the peer did not provide a "
"certificate.  Whether the peer provides a certificate depends on the SSL "
"socket's role:"
msgstr ""
"Якщо параметр ``binary_form`` має значення :const:`True` і надано "
"сертифікат, цей метод повертає закодовану DER форму всього сертифіката у "
"вигляді послідовності байтів або :const:`None`, якщо одноранговий сертифікат "
"не надав. Чи надає партнер сертифікат, залежить від ролі SSL-сокета:"

#: ../../library/ssl.rst:1250
msgid ""
"for a client SSL socket, the server will always provide a certificate, "
"regardless of whether validation was required;"
msgstr ""
"для клієнтського SSL-сокета сервер завжди надаватиме сертифікат, незалежно "
"від того, чи була потрібна перевірка;"

#: ../../library/ssl.rst:1253
msgid ""
"for a server SSL socket, the client will only provide a certificate when "
"requested by the server; therefore :meth:`getpeercert` will return :const:"
"`None` if you used :const:`CERT_NONE` (rather than :const:`CERT_OPTIONAL` "
"or :const:`CERT_REQUIRED`)."
msgstr ""
"для серверного SSL-сокета клієнт надасть сертифікат лише за запитом сервера; "
"тому :meth:`getpeercert` поверне :const:`None`, якщо ви використали :const:"
"`CERT_NONE` (а не :const:`CERT_OPTIONAL` або :const:`CERT_REQUIRED`)."

#: ../../library/ssl.rst:1258
msgid ""
"The returned dictionary includes additional items such as ``issuer`` and "
"``notBefore``."
msgstr ""
"Повернений словник містить додаткові елементи, такі як ``issuer`` і "
"``notBefore``."

#: ../../library/ssl.rst:1262
msgid ""
":exc:`ValueError` is raised when the handshake isn't done. The returned "
"dictionary includes additional X509v3 extension items   such as "
"``crlDistributionPoints``, ``caIssuers`` and ``OCSP`` URIs."
msgstr ""
":exc:`ValueError` виникає, коли рукостискання не виконано. Повернений "
"словник містить додаткові елементи розширення X509v3, такі як "
"``crlDistributionPoints``, ``caIssuers`` і ``OCSP`` URI."

#: ../../library/ssl.rst:1267
msgid "IPv6 address strings no longer have a trailing new line."
msgstr "Рядки адрес IPv6 більше не мають кінцевого нового рядка."

#: ../../library/ssl.rst:1272
msgid ""
"Returns a three-value tuple containing the name of the cipher being used, "
"the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr ""
"Повертає кортеж із трьох значень, що містить назву шифру, який "
"використовується, версію протоколу SSL, яка визначає його використання, і "
"кількість секретних бітів, які використовуються. Якщо з’єднання не "
"встановлено, повертає ``None``."

#: ../../library/ssl.rst:1278
msgid ""
"Return the list of ciphers shared by the client during the handshake.  Each "
"entry of the returned list is a three-value tuple containing the name of the "
"cipher, the version of the SSL protocol that defines its use, and the number "
"of secret bits the cipher uses.  :meth:`~SSLSocket.shared_ciphers` returns "
"``None`` if no connection has been established or the socket is a client "
"socket."
msgstr ""

#: ../../library/ssl.rst:1289
msgid ""
"Return the compression algorithm being used as a string, or ``None`` if the "
"connection isn't compressed."
msgstr ""
"Повертає використаний алгоритм стиснення у вигляді рядка або ``None``, якщо "
"з'єднання не стиснуте."

#: ../../library/ssl.rst:1292
msgid ""
"If the higher-level protocol supports its own compression mechanism, you can "
"use :data:`OP_NO_COMPRESSION` to disable SSL-level compression."
msgstr ""
"Якщо протокол вищого рівня підтримує власний механізм стиснення, ви можете "
"використовувати :data:`OP_NO_COMPRESSION`, щоб вимкнути стиснення на рівні "
"SSL."

#: ../../library/ssl.rst:1299
msgid ""
"Get channel binding data for current connection, as a bytes object.  Returns "
"``None`` if not connected or the handshake has not been completed."
msgstr ""
"Отримайте дані прив’язки каналу для поточного з’єднання як об’єкт bytes. "
"Повертає ``None``, якщо немає підключення або рукостискання не було "
"завершено."

#: ../../library/ssl.rst:1302
msgid ""
"The *cb_type* parameter allow selection of the desired channel binding type. "
"Valid channel binding types are listed in the :data:`CHANNEL_BINDING_TYPES` "
"list.  Currently only the 'tls-unique' channel binding, defined by :rfc:"
"`5929`, is supported.  :exc:`ValueError` will be raised if an unsupported "
"channel binding type is requested."
msgstr ""
"Параметр *cb_type* дозволяє вибрати потрібний тип прив’язки каналу. Дійсні "
"типи зв’язування каналів наведено в списку :data:`CHANNEL_BINDING_TYPES`. "
"Наразі підтримується лише прив’язка каналу \"tls-unique\", визначена :rfc:"
"`5929`. :exc:`ValueError` буде викликано, якщо запитується непідтримуваний "
"тип прив’язки каналу."

#: ../../library/ssl.rst:1312
msgid ""
"Return the protocol that was selected during the TLS handshake.  If :meth:"
"`SSLContext.set_alpn_protocols` was not called, if the other party does not "
"support ALPN, if this socket does not support any of the client's proposed "
"protocols, or if the handshake has not happened yet, ``None`` is returned."
msgstr ""
"Повернути протокол, вибраний під час рукостискання TLS. Якщо :meth:"
"`SSLContext.set_alpn_protocols` не було викликано, якщо інша сторона не "
"підтримує ALPN, якщо цей сокет не підтримує жодного із запропонованих "
"клієнтом протоколів або якщо рукостискання ще не відбулося, ``None`` буде "
"повернувся."

#: ../../library/ssl.rst:1322
msgid ""
"Return the higher-level protocol that was selected during the TLS/SSL "
"handshake. If :meth:`SSLContext.set_npn_protocols` was not called, or if the "
"other party does not support NPN, or if the handshake has not yet happened, "
"this will return ``None``."
msgstr ""
"Повернути протокол вищого рівня, вибраний під час рукостискання TLS/SSL. "
"Якщо :meth:`SSLContext.set_npn_protocols` не було викликано, або якщо інша "
"сторона не підтримує NPN, або якщо рукостискання ще не відбулося, це поверне "
"``None``."

#: ../../library/ssl.rst:1331
msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the "
"underlying socket, and returns the underlying socket object.  This can be "
"used to go from encrypted operation over a connection to unencrypted.  The "
"returned socket should always be used for further communication with the "
"other side of the connection, rather than the original socket."
msgstr ""
"Виконує рукостискання завершення роботи SSL, яке видаляє рівень TLS із "
"базового сокета та повертає базовий об’єкт сокета. Це можна використовувати "
"для переходу від зашифрованої операції через з’єднання до незашифрованої. "
"Повернений сокет завжди слід використовувати для подальшого зв’язку з іншою "
"стороною з’єднання, а не оригінальний сокет."

#: ../../library/ssl.rst:1339
msgid ""
"Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA can "
"only be initiated for a TLS 1.3 connection from a server-side socket, after "
"the initial TLS handshake and with PHA enabled on both sides, see :attr:"
"`SSLContext.post_handshake_auth`."
msgstr ""
"Запитує автентифікацію після рукостискання (PHA) від клієнта TLS 1.3. PHA "
"можна ініціювати лише для з’єднання TLS 1.3 із сокета на стороні сервера "
"після початкового рукостискання TLS і з увімкненим PHA з обох сторін, див. :"
"attr:`SSLContext.post_handshake_auth`."

#: ../../library/ssl.rst:1344
msgid ""
"The method does not perform a cert exchange immediately. The server-side "
"sends a CertificateRequest during the next write event and expects the "
"client to respond with a certificate on the next read event."
msgstr ""
"Метод не виконує обмін сертифікатами негайно. Сторона сервера надсилає "
"CertificateRequest під час наступної події запису та очікує, що клієнт "
"відповість сертифікатом під час наступної події читання."

#: ../../library/ssl.rst:1348
msgid ""
"If any precondition isn't met (e.g. not TLS 1.3, PHA not enabled), an :exc:"
"`SSLError` is raised."
msgstr ""
"Якщо будь-яка передумова не виконується (наприклад, не TLS 1.3, PHA не "
"ввімкнено), виникає :exc:`SSLError`."

#: ../../library/ssl.rst:1352
msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the method raises :exc:`NotImplementedError`."
msgstr ""
"Доступно лише з увімкненими OpenSSL 1.1.1 і TLS 1.3. Без підтримки TLS 1.3 "
"метод викликає :exc:`NotImplementedError`."

#: ../../library/ssl.rst:1359
msgid ""
"Return the actual SSL protocol version negotiated by the connection as a "
"string, or ``None`` if no secure connection is established. As of this "
"writing, possible return values include ``\"SSLv2\"``, ``\"SSLv3\"``, "
"``\"TLSv1\"``, ``\"TLSv1.1\"`` and ``\"TLSv1.2\"``. Recent OpenSSL versions "
"may define more return values."
msgstr ""
"Повертає фактичну версію протоколу SSL, узгоджену з’єднанням, у вигляді "
"рядка або \"Немає\", якщо безпечне з’єднання не встановлено. На момент "
"написання цієї статті можливі значення, що повертаються, включають "
"``\"SSLv2\"``, ``\"SSLv3\"``, ``\"TLSv1\"``, ``\"TLSv1.1\"`` і "
"``\"TLSv1.2\"``. Останні версії OpenSSL можуть визначати більше значень, що "
"повертаються."

#: ../../library/ssl.rst:1369
msgid ""
"Returns the number of already decrypted bytes available for read, pending on "
"the connection."
msgstr ""
"Повертає кількість уже розшифрованих байтів, доступних для читання, які "
"очікують підключення."

#: ../../library/ssl.rst:1374
msgid ""
"The :class:`SSLContext` object this SSL socket is tied to.  If the SSL "
"socket was created using the deprecated :func:`wrap_socket` function (rather "
"than :meth:`SSLContext.wrap_socket`), this is a custom context object "
"created for this SSL socket."
msgstr ""
"Об’єкт :class:`SSLContext`, до якого прив’язаний цей SSL-сокет. Якщо SSL-"
"сокет було створено за допомогою застарілої функції :func:`wrap_socket` (а "
"не :meth:`SSSLContext.wrap_socket`), це спеціальний контекстний об’єкт, "
"створений для цього SSL-сокета."

#: ../../library/ssl.rst:1383
msgid ""
"A boolean which is ``True`` for server-side sockets and ``False`` for client-"
"side sockets."
msgstr ""
"Логічне значення, яке має значення ``True`` для сокетів на стороні сервера "
"та ``False`` для сокетів на стороні клієнта."

#: ../../library/ssl.rst:1390
msgid ""
"Hostname of the server: :class:`str` type, or ``None`` for server-side "
"socket or if the hostname was not specified in the constructor."
msgstr ""
"Ім’я хоста сервера: тип :class:`str` або ``None`` для серверного сокета або "
"якщо ім’я хосту не було вказано в конструкторі."

#: ../../library/ssl.rst:1395
msgid ""
"The attribute is now always ASCII text. When ``server_hostname`` is an "
"internationalized domain name (IDN), this attribute now stores the A-label "
"form (``\"xn--pythn-mua.org\"``), rather than the U-label form (``\"pythön."
"org\"``)."
msgstr ""
"Тепер атрибут завжди є текстом ASCII. Якщо ``server_hostname`` є "
"інтернаціоналізованим доменним іменем (IDN), цей атрибут тепер зберігає "
"форму A-мітки (``\"xn--pythn-mua.org\"``), а не форму U-мітки (``\"pythön."
"org\"``)."

#: ../../library/ssl.rst:1403
msgid ""
"The :class:`SSLSession` for this SSL connection. The session is available "
"for client and server side sockets after the TLS handshake has been "
"performed. For client sockets the session can be set before :meth:"
"`~SSLSocket.do_handshake` has been called to reuse a session."
msgstr ""
":class:`SSLSession` для цього з’єднання SSL. Сеанс доступний для сокетів на "
"стороні клієнта та сервера після того, як було виконано рукостискання TLS. "
"Для клієнтських сокетів сеанс можна встановити до виклику :meth:`~SSLSocket."
"do_handshake` для повторного використання сеансу."

#: ../../library/ssl.rst:1416
msgid "SSL Contexts"
msgstr "Контексти SSL"

#: ../../library/ssl.rst:1420
msgid ""
"An SSL context holds various data longer-lived than single SSL connections, "
"such as SSL configuration options, certificate(s) and private key(s). It "
"also manages a cache of SSL sessions for server-side sockets, in order to "
"speed up repeated connections from the same clients."
msgstr ""
"Контекст SSL зберігає різноманітні дані, які живуть довше, ніж окремі "
"з’єднання SSL, наприклад параметри конфігурації SSL, сертифікат(и) і "
"закритий ключ(и). Він також керує кеш-пам’яттю сеансів SSL для сокетів на "
"стороні сервера, щоб пришвидшити повторювані підключення від тих самих "
"клієнтів."

#: ../../library/ssl.rst:1427
msgid ""
"Create a new SSL context.  You may pass *protocol* which must be one of the "
"``PROTOCOL_*`` constants defined in this module.  The parameter specifies "
"which version of the SSL protocol to use.  Typically, the server chooses a "
"particular protocol version, and the client must adapt to the server's "
"choice.  Most of the versions are not interoperable with the other "
"versions.  If not specified, the default is :data:`PROTOCOL_TLS`; it "
"provides the most compatibility with other versions."
msgstr ""
"Створіть новий контекст SSL. Ви можете передати *протокол*, який має бути "
"однією з констант ``PROTOCOL_*``, визначених у цьому модулі. Параметр "
"визначає, яку версію протоколу SSL використовувати. Як правило, сервер "
"вибирає певну версію протоколу, а клієнт повинен адаптуватися до вибору "
"сервера. Більшість версій не сумісні з іншими версіями. Якщо не вказано, "
"типовим є :data:`PROTOCOL_TLS`; він забезпечує найбільшу сумісність з іншими "
"версіями."

#: ../../library/ssl.rst:1436
msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr ""
"Ось таблиця, яка показує, які версії клієнта (збоку) можуть підключатися до "
"яких версій на сервері (вгорі):"

#: ../../library/ssl.rst:1442
msgid "*client* / **server**"
msgstr "*клієнт* / **сервер**"

#: ../../library/ssl.rst:1442
msgid "**SSLv2**"
msgstr "**SSLv2**"

#: ../../library/ssl.rst:1442
msgid "**SSLv3**"
msgstr "**SSLv3**"

#: ../../library/ssl.rst:1442
msgid "**TLS** [3]_"
msgstr "**TLS** [3]_"

#: ../../library/ssl.rst:1442
msgid "**TLSv1**"
msgstr "**TLSv1**"

#: ../../library/ssl.rst:1442
msgid "**TLSv1.1**"
msgstr "**TLSv1.1**"

#: ../../library/ssl.rst:1442
msgid "**TLSv1.2**"
msgstr "**TLSv1.2**"

#: ../../library/ssl.rst:1444
msgid "*SSLv2*"
msgstr "*SSLv2*"

#: ../../library/ssl.rst:1444 ../../library/ssl.rst:1445
#: ../../library/ssl.rst:1446 ../../library/ssl.rst:1447
#: ../../library/ssl.rst:1448 ../../library/ssl.rst:1449
msgid "yes"
msgstr "sim"

#: ../../library/ssl.rst:1444 ../../library/ssl.rst:1445
#: ../../library/ssl.rst:1447 ../../library/ssl.rst:1448
#: ../../library/ssl.rst:1449
msgid "no"
msgstr "não"

#: ../../library/ssl.rst:1444 ../../library/ssl.rst:1446
msgid "no [1]_"
msgstr "ні [1]_"

#: ../../library/ssl.rst:1445
msgid "*SSLv3*"
msgstr "*SSLv3*"

#: ../../library/ssl.rst:1445 ../../library/ssl.rst:1446
msgid "no [2]_"
msgstr "ні [2]_"

#: ../../library/ssl.rst:1446
msgid "*TLS* (*SSLv23*) [3]_"
msgstr "*TLS* (*SSLv23*) [3]_"

#: ../../library/ssl.rst:1447
msgid "*TLSv1*"
msgstr "*TLSv1*"

#: ../../library/ssl.rst:1448
msgid "*TLSv1.1*"
msgstr "*TLSv1.1*"

#: ../../library/ssl.rst:1449
msgid "*TLSv1.2*"
msgstr "*TLSv1.2*"

#: ../../library/ssl.rst:1452
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../library/ssl.rst:1453
msgid ":class:`SSLContext` disables SSLv2 with :data:`OP_NO_SSLv2` by default."
msgstr ""
":class:`SSLContext` вимикає SSLv2 за допомогою :data:`OP_NO_SSLv2` за "
"замовчуванням."

#: ../../library/ssl.rst:1454
msgid ":class:`SSLContext` disables SSLv3 with :data:`OP_NO_SSLv3` by default."
msgstr ""
":class:`SSLContext` вимикає SSLv3 за допомогою :data:`OP_NO_SSLv3` за "
"замовчуванням."

#: ../../library/ssl.rst:1455
msgid ""
"TLS 1.3 protocol will be available with :data:`PROTOCOL_TLS` in OpenSSL >= "
"1.1.1. There is no dedicated PROTOCOL constant for just TLS 1.3."
msgstr ""
"Протокол TLS 1.3 буде доступний із :data:`PROTOCOL_TLS` у OpenSSL >= 1.1.1. "
"Немає виділеної константи PROTOCOL лише для TLS 1.3."

#: ../../library/ssl.rst:1460
msgid ""
":func:`create_default_context` lets the :mod:`ssl` module choose security "
"settings for a given purpose."
msgstr ""
":func:`create_default_context` дозволяє модулю :mod:`ssl` вибрати параметри "
"безпеки для певної мети."

#: ../../library/ssl.rst:1465
msgid ""
"The context is created with secure default values. The options :data:"
"`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, :data:"
"`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2` (except "
"for :data:`PROTOCOL_SSLv2`), and :data:`OP_NO_SSLv3` (except for :data:"
"`PROTOCOL_SSLv3`) are set by default. The initial cipher suite list contains "
"only ``HIGH`` ciphers, no ``NULL`` ciphers and no ``MD5`` ciphers (except "
"for :data:`PROTOCOL_SSLv2`)."
msgstr ""
"Контекст створюється із безпечними значеннями за замовчуванням. Параметри :"
"data:`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, :data:"
"`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2` (крім :"
"data:`PROTOCOL_SSLv2`) і :data:`OP_NO_SSLv3` (крім :data:`PROTOCOL_SSLv3`) "
"встановлено за замовчуванням. Початковий список набору шифрів містить лише "
"шифри ``HIGH``, шифри ``NULL`` і шифри ``MD5`` (крім :data:`PROTOCOL_SSLv2`)."

#: ../../library/ssl.rst:1475
msgid ":class:`SSLContext` objects have the following methods and attributes:"
msgstr ":class:`SSLContext` об’єкти мають такі методи та атрибути:"

#: ../../library/ssl.rst:1479
msgid ""
"Get statistics about quantities of loaded X.509 certificates, count of X.509 "
"certificates flagged as CA certificates and certificate revocation lists as "
"dictionary."
msgstr ""
"Отримайте статистичні дані про кількість завантажених сертифікатів X.509, "
"кількість сертифікатів X.509, позначених як сертифікати ЦС, і списки "
"відкликаних сертифікатів як словник."

#: ../../library/ssl.rst:1483
msgid "Example for a context with one CA cert and one other cert::"
msgstr ""
"Приклад для контексту з одним сертифікатом CA та одним іншим сертифікатом::"

#: ../../library/ssl.rst:1493
msgid ""
"Load a private key and the corresponding certificate.  The *certfile* string "
"must be the path to a single file in PEM format containing the certificate "
"as well as any number of CA certificates needed to establish the "
"certificate's authenticity.  The *keyfile* string, if present, must point to "
"a file containing the private key.  Otherwise the private key will be taken "
"from *certfile* as well.  See the discussion of :ref:`ssl-certificates` for "
"more information on how the certificate is stored in the *certfile*."
msgstr ""
"Завантажте закритий ключ і відповідний сертифікат. Рядок *certfile* має бути "
"шляхом до одного файлу у форматі PEM, що містить сертифікат, а також будь-"
"яку кількість сертифікатів ЦС, необхідних для встановлення автентичності "
"сертифіката. Рядок *keyfile*, якщо він присутній, має вказувати на файл, що "
"містить закритий ключ. Інакше закритий ключ також буде взято з *certfile*. "
"Перегляньте обговорення :ref:`ssl-certificates` для отримання додаткової "
"інформації про те, як сертифікат зберігається у *certfile*."

#: ../../library/ssl.rst:1502
msgid ""
"The *password* argument may be a function to call to get the password for "
"decrypting the private key.  It will only be called if the private key is "
"encrypted and a password is necessary.  It will be called with no arguments, "
"and it should return a string, bytes, or bytearray.  If the return value is "
"a string it will be encoded as UTF-8 before using it to decrypt the key. "
"Alternatively a string, bytes, or bytearray value may be supplied directly "
"as the *password* argument.  It will be ignored if the private key is not "
"encrypted and no password is needed."
msgstr ""
"Аргумент *password* може бути функцією для виклику, щоб отримати пароль для "
"розшифровки закритого ключа. Він буде викликаний, лише якщо закритий ключ "
"зашифрований і потрібен пароль. Він буде викликаний без аргументів і повинен "
"повернути рядок, байти або масив байтів. Якщо значення, що повертається, є "
"рядком, воно буде закодовано як UTF-8 перед використанням для розшифровки "
"ключа. Крім того, значення рядка, байтів або масиву байтів можна надати "
"безпосередньо як аргумент *пароль*. Він буде проігнорований, якщо закритий "
"ключ не зашифрований і пароль не потрібен."

#: ../../library/ssl.rst:1511
msgid ""
"If the *password* argument is not specified and a password is required, "
"OpenSSL's built-in password prompting mechanism will be used to "
"interactively prompt the user for a password."
msgstr ""
"Якщо аргумент *password* не вказано, а пароль потрібен, вбудований механізм "
"підказки пароля OpenSSL буде використано для інтерактивного запиту "
"користувача пароля."

#: ../../library/ssl.rst:1515
msgid ""
"An :class:`SSLError` is raised if the private key doesn't match with the "
"certificate."
msgstr ""
":class:`SSLError` виникає, якщо закритий ключ не збігається з сертифікатом."

#: ../../library/ssl.rst:1518
msgid "New optional argument *password*."
msgstr "Новий необов'язковий аргумент *пароль*."

#: ../../library/ssl.rst:1523
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from "
"default locations. On Windows it loads CA certs from the ``CA`` and ``ROOT`` "
"system stores. On all systems it calls :meth:`SSLContext."
"set_default_verify_paths`. In the future the method may load CA certificates "
"from other locations, too."
msgstr ""
"Завантажте набір стандартних сертифікатів \"центру сертифікації\" (CA) із "
"стандартних розташувань. У Windows він завантажує сертифікати ЦС із "
"системних сховищ ``CA`` і ``ROOT``. У всіх системах він викликає :meth:"
"`SSLContext.set_default_verify_paths`. У майбутньому цей метод може також "
"завантажувати сертифікати ЦС з інших місць."

#: ../../library/ssl.rst:1529
msgid ""
"The *purpose* flag specifies what kind of CA certificates are loaded. The "
"default settings :data:`Purpose.SERVER_AUTH` loads certificates, that are "
"flagged and trusted for TLS web server authentication (client side "
"sockets). :data:`Purpose.CLIENT_AUTH` loads CA certificates for client "
"certificate verification on the server side."
msgstr ""
"Прапор *purpose* визначає тип сертифікатів ЦС, які завантажуються. Параметри "
"за замовчуванням :data:`Purpose.SERVER_AUTH` завантажують сертифікати, які "
"позначено та є довіреними для автентифікації веб-сервера TLS (сокети на "
"стороні клієнта). :data:`Purpose.CLIENT_AUTH` завантажує сертифікати ЦС для "
"перевірки сертифікатів клієнта на стороні сервера."

#: ../../library/ssl.rst:1539
msgid ""
"Load a set of \"certification authority\" (CA) certificates used to validate "
"other peers' certificates when :data:`verify_mode` is other than :data:"
"`CERT_NONE`.  At least one of *cafile* or *capath* must be specified."
msgstr ""
"Завантажте набір сертифікатів \"центру сертифікації\" (CA), які "
"використовуються для перевірки сертифікатів інших вузлів, якщо :data:"
"`verify_mode` відрізняється від :data:`CERT_NONE`. Потрібно вказати "
"принаймні один із *cafile* або *capath*."

#: ../../library/ssl.rst:1543
msgid ""
"This method can also load certification revocation lists (CRLs) in PEM or "
"DER format. In order to make use of CRLs, :attr:`SSLContext.verify_flags` "
"must be configured properly."
msgstr ""
"Цей метод також може завантажувати списки відкликаних сертифікатів (CRL) у "
"форматі PEM або DER. Щоб використовувати CRL, :attr:`SSLContext."
"verify_flags` має бути правильно налаштовано."

#: ../../library/ssl.rst:1547
msgid ""
"The *cafile* string, if present, is the path to a file of concatenated CA "
"certificates in PEM format. See the discussion of :ref:`ssl-certificates` "
"for more information about how to arrange the certificates in this file."
msgstr ""
"Рядок *cafile*, якщо він присутній, є шляхом до файлу об’єднаних "
"сертифікатів ЦС у форматі PEM. Перегляньте обговорення :ref:`ssl-"
"certificates` для отримання додаткової інформації про те, як упорядкувати "
"сертифікати в цьому файлі."

#: ../../library/ssl.rst:1552
msgid ""
"The *capath* string, if present, is the path to a directory containing "
"several CA certificates in PEM format, following an `OpenSSL specific layout "
"<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations."
"html>`_."
msgstr ""
"Рядок *capath*, якщо він присутній, є шляхом до каталогу, що містить кілька "
"сертифікатів ЦС у форматі PEM, відповідно до `спеціального макета OpenSSL "
"<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations."
"html>`_."

#: ../../library/ssl.rst:1557
msgid ""
"The *cadata* object, if present, is either an ASCII string of one or more "
"PEM-encoded certificates or a :term:`bytes-like object` of DER-encoded "
"certificates. Like with *capath* extra lines around PEM-encoded certificates "
"are ignored but at least one certificate must be present."
msgstr ""
"Об’єкт *cadata*, якщо він присутній, є рядком ASCII одного чи кількох "
"сертифікатів у кодуванні PEM або :term:`bytes-like object` сертифікатів у "
"кодуванні DER. Подібно до *capath* додаткові рядки навколо PEM-кодованих "
"сертифікатів ігноруються, але принаймні один сертифікат має бути присутнім."

#: ../../library/ssl.rst:1562
msgid "New optional argument *cadata*"
msgstr "Новий необов'язковий аргумент *cadata*"

#: ../../library/ssl.rst:1567
msgid ""
"Get a list of loaded \"certification authority\" (CA) certificates. If the "
"``binary_form`` parameter is :const:`False` each list entry is a dict like "
"the output of :meth:`SSLSocket.getpeercert`. Otherwise the method returns a "
"list of DER-encoded certificates. The returned list does not contain "
"certificates from *capath* unless a certificate was requested and loaded by "
"a SSL connection."
msgstr ""
"Отримайте список завантажених сертифікатів \"центру сертифікації\" (CA). "
"Якщо параметр ``binary_form`` має значення :const:`False`, кожен запис у "
"списку є диктофоном, подібним до результату :meth:`SSLSocket.getpeercert`. В "
"іншому випадку метод повертає список сертифікатів, закодованих DER. "
"Повернений список не містить сертифікатів від *capath*, якщо тільки "
"сертифікат не було запитано та завантажено через підключення SSL."

#: ../../library/ssl.rst:1575
msgid ""
"Certificates in a capath directory aren't loaded unless they have been used "
"at least once."
msgstr ""
"Сертифікати в каталозі capath не завантажуються, якщо вони не були "
"використані принаймні один раз."

#: ../../library/ssl.rst:1582
msgid ""
"Get a list of enabled ciphers. The list is in order of cipher priority. See :"
"meth:`SSLContext.set_ciphers`."
msgstr ""
"Отримайте список увімкнених шифрів. Список розташований у порядку пріоритету "
"шифру. Перегляньте :meth:`SSLContext.set_ciphers`."

#: ../../library/ssl.rst:1605
msgid "On OpenSSL 1.1 and newer the cipher dict contains additional fields::"
msgstr ""

#: ../../library/ssl.rst:1634
msgid ":ref:`Availability <availability>`: OpenSSL 1.0.2+."
msgstr ""

#: ../../library/ssl.rst:1639
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from a "
"filesystem path defined when building the OpenSSL library.  Unfortunately, "
"there's no easy way to know whether this method succeeds: no error is "
"returned if no certificates are to be found.  When the OpenSSL library is "
"provided as part of the operating system, though, it is likely to be "
"configured properly."
msgstr ""
"Завантажте набір стандартних сертифікатів \"центру сертифікації\" (CA) із "
"шляху файлової системи, визначеного під час створення бібліотеки OpenSSL. На "
"жаль, немає простого способу дізнатися, чи цей метод успішний: помилка не "
"повертається, якщо сертифікати не знайдені. Однак, коли бібліотека OpenSSL "
"надається як частина операційної системи, вона, швидше за все, буде "
"налаштована належним чином."

#: ../../library/ssl.rst:1648
msgid ""
"Set the available ciphers for sockets created with this context. It should "
"be a string in the `OpenSSL cipher list format <https://www.openssl.org/docs/"
"manmaster/man1/ciphers.html>`_. If no cipher can be selected (because "
"compile-time options or other configuration forbids use of all the specified "
"ciphers), an :class:`SSLError` will be raised."
msgstr ""
"Встановіть доступні шифри для сокетів, створених із цим контекстом. Це має "
"бути рядок у `форматі списку шифрів OpenSSL <https://www.openssl.org/docs/"
"manmaster/man1/ciphers.html>`_. Якщо жоден шифр не може бути обраний "
"(оскільки параметри під час компіляції чи інша конфігурація забороняють "
"використовувати всі вказані шифри), буде викликано :class:`SSLError`."

#: ../../library/ssl.rst:1656
msgid ""
"when connected, the :meth:`SSLSocket.cipher` method of SSL sockets will give "
"the currently selected cipher."
msgstr ""
"під час підключення метод :meth:`SSLSocket.cipher` для сокетів SSL дасть "
"поточний вибраний шифр."

#: ../../library/ssl.rst:1659
msgid ""
"OpenSSL 1.1.1 has TLS 1.3 cipher suites enabled by default. The suites "
"cannot be disabled with :meth:`~SSLContext.set_ciphers`."
msgstr ""

#: ../../library/ssl.rst:1664
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of ASCII strings, like ``['http/1.1', "
"'spdy/2']``, ordered by preference. The selection of a protocol will happen "
"during the handshake, and will play out according to :rfc:`7301`. After a "
"successful handshake, the :meth:`SSLSocket.selected_alpn_protocol` method "
"will return the agreed-upon protocol."
msgstr ""
"Укажіть, які протоколи має сповіщати сокет під час рукостискання SSL/TLS. Це "
"має бути список рядків ASCII, наприклад ``['http/1.1', 'spdy/2']``, "
"упорядкованих за перевагами. Вибір протоколу відбуватиметься під час "
"рукостискання та відтворюватиметься відповідно до :rfc:`7301`. Після "
"успішного рукостискання метод :meth:`SSLSocket.selected_alpn_protocol` "
"поверне узгоджений протокол."

#: ../../library/ssl.rst:1671
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_ALPN` is "
"``False``."
msgstr ""
"Цей метод викличе :exc:`NotImplementedError`, якщо :data:`HAS_ALPN` має "
"значення ``False``."

#: ../../library/ssl.rst:1674
msgid ""
"OpenSSL 1.1.0 to 1.1.0e will abort the handshake and raise :exc:`SSLError` "
"when both sides support ALPN but cannot agree on a protocol. 1.1.0f+ behaves "
"like 1.0.2, :meth:`SSLSocket.selected_alpn_protocol` returns None."
msgstr ""

#: ../../library/ssl.rst:1682
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of strings, like ``['http/1.1', 'spdy/2']``, "
"ordered by preference. The selection of a protocol will happen during the "
"handshake, and will play out according to the `Application Layer Protocol "
"Negotiation <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. After a successful handshake, the :meth:"
"`SSLSocket.selected_npn_protocol` method will return the agreed-upon "
"protocol."
msgstr ""
"Укажіть, які протоколи має сповіщати сокет під час рукостискання SSL/TLS. Це "
"має бути список рядків, наприклад ``['http/1.1', 'spdy/2']``, упорядкованих "
"за перевагами. Вибір протоколу відбуватиметься під час рукостискання та "
"відтворюватиметься відповідно до `Узгодження протоколу прикладного рівня "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"Після успішного рукостискання метод :meth:`SSLSocket.selected_npn_protocol` "
"поверне узгоджений протокол."

#: ../../library/ssl.rst:1690
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_NPN` is "
"``False``."
msgstr ""
"Цей метод викличе :exc:`NotImplementedError`, якщо :data:`HAS_NPN` має "
"значення ``False``."

#: ../../library/ssl.rst:1697
msgid ""
"Register a callback function that will be called after the TLS Client Hello "
"handshake message has been received by the SSL/TLS server when the TLS "
"client specifies a server name indication. The server name indication "
"mechanism is specified in :rfc:`6066` section 3 - Server Name Indication."
msgstr ""
"Зареєструйте функцію зворотного виклику, яка буде викликана після отримання "
"повідомлення рукостискання TLS Client Hello сервером SSL/TLS, коли клієнт "
"TLS вказує вказівку імені сервера. Механізм індикації імені сервера вказано "
"в :rfc:`6066` розділі 3 - Індикація імені сервера."

#: ../../library/ssl.rst:1702
msgid ""
"Only one callback can be set per ``SSLContext``.  If *sni_callback* is set "
"to ``None`` then the callback is disabled. Calling this function a "
"subsequent time will disable the previously registered callback."
msgstr ""
"Для кожного SSLContext можна встановити лише один зворотний виклик. Якщо "
"*sni_callback* встановлено на ``None``, тоді зворотний виклик вимкнено. "
"Наступний виклик цієї функції вимкне попередньо зареєстрований зворотний "
"виклик."

#: ../../library/ssl.rst:1706
msgid ""
"The callback function will be called with three arguments; the first being "
"the :class:`ssl.SSLSocket`, the second is a string that represents the "
"server name that the client is intending to communicate (or :const:`None` if "
"the TLS Client Hello does not contain a server name) and the third argument "
"is the original :class:`SSLContext`. The server name argument is text. For "
"internationalized domain name, the server name is an IDN A-label (``\"xn--"
"pythn-mua.org\"``)."
msgstr ""
"Функція зворотного виклику буде викликана з трьома аргументами; перший — це :"
"class:`ssl.SSLSocket`, другий — це рядок, який представляє ім’я сервера, з "
"яким клієнт має намір зв’язатися (або :const:`None`, якщо TLS Client Hello "
"не містить імені сервера) а третій аргумент — вихідний :class:`SSLContext`. "
"Аргументом імені сервера є текст. Для інтернаціоналізованого доменного імені "
"ім’я сервера є міткою IDN A (``\"xn--pythn-mua.org\"``)."

#: ../../library/ssl.rst:1714
msgid ""
"A typical use of this callback is to change the :class:`ssl.SSLSocket`'s :"
"attr:`SSLSocket.context` attribute to a new object of type :class:"
"`SSLContext` representing a certificate chain that matches the server name."
msgstr ""
"Типовим використанням цього зворотного виклику є зміна атрибута :attr:"
"`SSLSocket.context` :class:`ssl.SSLSocket` на новий об’єкт типу :class:"
"`SSLContext`, який представляє ланцюжок сертифікатів, який відповідає імені "
"сервера ."

#: ../../library/ssl.rst:1719
msgid ""
"Due to the early negotiation phase of the TLS connection, only limited "
"methods and attributes are usable like :meth:`SSLSocket."
"selected_alpn_protocol` and :attr:`SSLSocket.context`. The :meth:`SSLSocket."
"getpeercert`, :meth:`SSLSocket.cipher` and :meth:`SSLSocket.compression` "
"methods require that the TLS connection has progressed beyond the TLS Client "
"Hello and therefore will not return meaningful values nor can they be called "
"safely."
msgstr ""
"Из-за ранней фазы согласования TLS-соединения можно использовать только "
"ограниченные методы и атрибуты, такие как :meth:`SSLSocket."
"selected_alpn_protocol` и :attr:`SSLSocket.context`. Методы :meth:`SSLSocket."
"getpeercert`, :meth:`SSLSocket.cipher` и :meth:`SSLSocket.compression` "
"требуют, чтобы TLS-соединение вышло за пределы TLS Client Hello, и поэтому "
"не будут возвращать значимые значения и не могут вызываться безопасно."

#: ../../library/ssl.rst:1727
msgid ""
"The *sni_callback* function must return ``None`` to allow the TLS "
"negotiation to continue.  If a TLS failure is required, a constant :const:"
"`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` can be returned.  "
"Other return values will result in a TLS fatal error with :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR`."
msgstr ""
"Функція *sni_callback* має повертати ``None``, щоб узгодження TLS "
"продовжилося. Якщо потрібна помилка TLS, можна повернути константу :const:"
"`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>`. Інші значення, що "
"повертаються, призведуть до фатальної помилки TLS із :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR`."

#: ../../library/ssl.rst:1733
msgid ""
"If an exception is raised from the *sni_callback* function the TLS "
"connection will terminate with a fatal TLS alert message :const:"
"`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."
msgstr ""
"Якщо функція *sni_callback* викликає виняток, TLS-з’єднання буде розірвано з "
"небезпечним TLS-повідомленням :const:`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."

#: ../../library/ssl.rst:1737
msgid ""
"This method will raise :exc:`NotImplementedError` if the OpenSSL library had "
"OPENSSL_NO_TLSEXT defined when it was built."
msgstr ""
"Цей метод викличе :exc:`NotImplementedError`, якщо під час створення "
"бібліотеки OpenSSL було визначено OPENSSL_NO_TLSEXT."

#: ../../library/ssl.rst:1744
msgid ""
"This is a legacy API retained for backwards compatibility. When possible, "
"you should use :attr:`sni_callback` instead. The given "
"*server_name_callback* is similar to *sni_callback*, except that when the "
"server hostname is an IDN-encoded internationalized domain name, the "
"*server_name_callback* receives a decoded U-label (``\"pythön.org\"``)."
msgstr ""
"Це застарілий API, збережений для зворотної сумісності. Якщо можливо, "
"замість цього слід використовувати :attr:`sni_callback`. Наданий "
"*server_name_callback* подібний до *sni_callback*, за винятком того, що коли "
"ім’я хосту сервера є інтернаціоналізованим доменним ім’ям із кодуванням IDN, "
"*server_name_callback* отримує декодовану U-мітку (``\"pythön.org\"``)."

#: ../../library/ssl.rst:1750
msgid ""
"If there is an decoding error on the server name, the TLS connection will "
"terminate with an :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` fatal TLS alert "
"message to the client."
msgstr ""
"Якщо в імені сервера є помилка декодування, TLS-з’єднання буде розірвано з "
"повідомленням TLS-сповіщення клієнта :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR`."

#: ../../library/ssl.rst:1758
msgid ""
"Load the key generation parameters for Diffie-Hellman (DH) key exchange. "
"Using DH key exchange improves forward secrecy at the expense of "
"computational resources (both on the server and on the client). The *dhfile* "
"parameter should be the path to a file containing DH parameters in PEM "
"format."
msgstr ""
"Завантажте параметри генерації ключів для обміну ключами Діффі-Хеллмана "
"(DH). Використання обміну ключами DH покращує пряму секретність за рахунок "
"обчислювальних ресурсів (як на сервері, так і на клієнті). Параметр *dhfile* "
"має бути шляхом до файлу, що містить параметри DH у форматі PEM."

#: ../../library/ssl.rst:1764
msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_DH_USE` option to further improve security."
msgstr ""
"Цей параметр не застосовується до клієнтських сокетів. Ви також можете "
"використовувати параметр :data:`OP_SINGLE_DH_USE` для подальшого покращення "
"безпеки."

#: ../../library/ssl.rst:1771
msgid ""
"Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key "
"exchange.  ECDH is significantly faster than regular DH while arguably as "
"secure.  The *curve_name* parameter should be a string describing a well-"
"known elliptic curve, for example ``prime256v1`` for a widely supported "
"curve."
msgstr ""
"Встановіть назву кривої для обміну ключами Діффі-Хеллмана (ECDH) на основі "
"еліптичної кривої. ECDH значно швидший, ніж звичайний DH, але, можливо, "
"такий же безпечний. Параметр *curve_name* має бути рядком, що описує добре "
"відому еліптичну криву, наприклад ``prime256v1`` для широко підтримуваної "
"кривої."

#: ../../library/ssl.rst:1777
msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_ECDH_USE` option to further improve security."
msgstr ""
"Цей параметр не застосовується до клієнтських сокетів. Ви також можете "
"використовувати опцію :data:`OP_SINGLE_ECDH_USE` для подальшого покращення "
"безпеки."

#: ../../library/ssl.rst:1780
msgid "This method is not available if :data:`HAS_ECDH` is ``False``."
msgstr "Цей метод недоступний, якщо :data:`HAS_ECDH` має значення ``False``."

#: ../../library/ssl.rst:1785
msgid ""
"`SSL/TLS & Perfect Forward Secrecy <https://vincent.bernat.im/en/blog/2011-"
"ssl-perfect-forward-secrecy>`_"
msgstr ""
"`SSL/TLS & Perfect Forward Secrecy <https://vincent.bernat.im/en/blog/2011-"
"ssl-perfect-forward-secrecy>`_"

#: ../../library/ssl.rst:1786
msgid "Vincent Bernat."
msgstr "Вінсент Бернат."

#: ../../library/ssl.rst:1792
msgid ""
"Wrap an existing Python socket *sock* and return an instance of :attr:"
"`SSLContext.sslsocket_class` (default :class:`SSLSocket`). The returned SSL "
"socket is tied to the context, its settings and certificates. *sock* must be "
"a :data:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""
"Оберніть існуючий сокет Python *sock* і поверніть екземпляр :attr:"
"`SSSLContext.sslsocket_class` (за замовчуванням :class:`SSLSocket`). "
"Повернений сокет SSL прив’язаний до контексту, його налаштувань і "
"сертифікатів. *sock* має бути сокетом :data:`~socket.SOCK_STREAM`; інші типи "
"сокетів не підтримуються."

#: ../../library/ssl.rst:1798
msgid ""
"The parameter ``server_side`` is a boolean which identifies whether server-"
"side or client-side behavior is desired from this socket."
msgstr ""
"Параметр ``server_side`` є логічним значенням, яке визначає, яка поведінка "
"для цього сокета – серверна чи клієнтська."

#: ../../library/ssl.rst:1801
msgid ""
"For client-side sockets, the context construction is lazy; if the underlying "
"socket isn't connected yet, the context construction will be performed "
"after :meth:`connect` is called on the socket.  For server-side sockets, if "
"the socket has no remote peer, it is assumed to be a listening socket, and "
"the server-side SSL wrapping is automatically performed on client "
"connections accepted via the :meth:`accept` method. The method may raise :"
"exc:`SSLError`."
msgstr ""
"Для сокетів на стороні клієнта конструкція контексту є ледачою; якщо "
"основний сокет ще не підключено, конструкція контексту буде виконана після "
"виклику :meth:`connect` для сокета. Для сокетів на стороні сервера, якщо "
"сокет не має віддаленого однорангового пристрою, він вважається сокетом, що "
"прослуховує, і обернення SSL на стороні сервера автоматично виконується для "
"підключень клієнта, прийнятих через метод :meth:`accept`. Метод може "
"викликати :exc:`SSLError`."

#: ../../library/ssl.rst:1809
msgid ""
"On client connections, the optional parameter *server_hostname* specifies "
"the hostname of the service which we are connecting to.  This allows a "
"single server to host multiple SSL-based services with distinct "
"certificates, quite similarly to HTTP virtual hosts. Specifying "
"*server_hostname* will raise a :exc:`ValueError` if *server_side* is true."
msgstr ""
"У клієнтських з’єднаннях необов’язковий параметр *server_hostname* визначає "
"ім’я хоста служби, до якої ми під’єднуємося. Це дозволяє одному серверу "
"розміщувати кілька служб на основі SSL з окремими сертифікатами, подібно до "
"віртуальних хостів HTTP. Якщо вказати *server_hostname*, виникне :exc:"
"`ValueError`, якщо *server_side* має значення true."

#: ../../library/ssl.rst:1815
msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL "
"handshake automatically after doing a :meth:`socket.connect`, or whether the "
"application program will call it explicitly, by invoking the :meth:"
"`SSLSocket.do_handshake` method.  Calling :meth:`SSLSocket.do_handshake` "
"explicitly gives the program control over the blocking behavior of the "
"socket I/O involved in the handshake."
msgstr ""
"Параметр ``do_handshake_on_connect`` визначає, чи виконувати SSL-"
"рукостискання автоматично після виконання :meth:`socket.connect`, чи "
"прикладна програма викличе його явно, викликаючи метод :meth:`SSLSocket."
"do_handshake`. Виклик :meth:`SSLSocket.do_handshake` явно дає програмі "
"контроль над поведінкою блокування вводу-виводу сокета, залученого до "
"рукостискання."

#: ../../library/ssl.rst:1822
msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the :meth:`SSLSocket."
"recv` method should signal unexpected EOF from the other end of the "
"connection.  If specified as :const:`True` (the default), it returns a "
"normal EOF (an empty bytes object) in response to unexpected EOF errors "
"raised from the underlying socket; if :const:`False`, it will raise the "
"exceptions back to the caller."
msgstr ""
"Параметр ``suppress_ragged_eofs`` визначає, як метод :meth:`SSLSocket.recv` "
"повинен сигналізувати про неочікуваний EOF з іншого боку з’єднання. Якщо "
"вказано як :const:`True` (за замовчуванням), він повертає звичайний EOF "
"(порожній об’єкт байтів) у відповідь на неочікувані помилки EOF, викликані "
"базовим сокетом; якщо :const:`False`, винятки повертаються до абонента."

#: ../../library/ssl.rst:1829
msgid "*session*, see :attr:`~SSLSocket.session`."
msgstr "*сеанс*, див. :attr:`~SSLSocket.session`."

#: ../../library/ssl.rst:1831
msgid ""
"Always allow a server_hostname to be passed, even if OpenSSL does not have "
"SNI."
msgstr ""
"Завжди дозволяйте передачу server_hostname, навіть якщо OpenSSL не має SNI."

#: ../../library/ssl.rst:1835 ../../library/ssl.rst:1861
msgid "*session* argument was added."
msgstr "o argumento *session* foi adicionado."

#: ../../library/ssl.rst:1838
msgid ""
"The method returns on instance of :attr:`SSLContext.sslsocket_class` instead "
"of hard-coded :class:`SSLSocket`."
msgstr ""
"此方法返回 :attr:`SSLContext.sslsocket_class` 的实例而非硬编码的 :class:"
"`SSLSocket`。"

#: ../../library/ssl.rst:1844
msgid ""
"The return type of :meth:`SSLContext.wrap_socket`, defaults to :class:"
"`SSLSocket`. The attribute can be overridden on instance of class in order "
"to return a custom subclass of :class:`SSLSocket`."
msgstr ""
"Тип повернення :meth:`SSLContext.wrap_socket` за замовчуванням :class:"
"`SSLSocket`. Атрибут можна перевизначити в екземплярі класу, щоб повернути "
"настроюваний підклас :class:`SSLSocket`."

#: ../../library/ssl.rst:1853
msgid ""
"Wrap the BIO objects *incoming* and *outgoing* and return an instance of :"
"attr:`SSLContext.sslobject_class` (default :class:`SSLObject`). The SSL "
"routines will read input data from the incoming BIO and write data to the "
"outgoing BIO."
msgstr ""
"Об’єднайте BIO-об’єкти *incoming* і *outgoing* і поверніть екземпляр :attr:"
"`SSLContext.sslobject_class` (за замовчуванням :class:`SSLObject`). "
"Підпрограми SSL читатимуть вхідні дані з вхідного BIO та записуватимуть дані "
"у вихідний BIO."

#: ../../library/ssl.rst:1858
msgid ""
"The *server_side*, *server_hostname* and *session* parameters have the same "
"meaning as in :meth:`SSLContext.wrap_socket`."
msgstr ""
"Параметри *server_side*, *server_hostname* і *session* мають те саме "
"значення, що й у :meth:`SSLContext.wrap_socket`."

#: ../../library/ssl.rst:1864
msgid ""
"The method returns on instance of :attr:`SSLContext.sslobject_class` instead "
"of hard-coded :class:`SSLObject`."
msgstr ""
"此方法返回 :attr:`SSLContext.sslobject_class` 的实例则非硬编码的 :class:"
"`SSLObject`。"

#: ../../library/ssl.rst:1870
msgid ""
"The return type of :meth:`SSLContext.wrap_bio`, defaults to :class:"
"`SSLObject`. The attribute can be overridden on instance of class in order "
"to return a custom subclass of :class:`SSLObject`."
msgstr ""
"Тип повернення :meth:`SSLContext.wrap_bio` за замовчуванням :class:"
"`SSLObject`. Атрибут можна перевизначити в екземплярі класу, щоб повернути "
"настроюваний підклас :class:`SSLObject`."

#: ../../library/ssl.rst:1878
msgid ""
"Get statistics about the SSL sessions created or managed by this context. A "
"dictionary is returned which maps the names of each `piece of information "
"<https://www.openssl.org/docs/man1.1.0/ssl/SSL_CTX_sess_number.html>`_ to "
"their numeric values.  For example, here is the total number of hits and "
"misses in the session cache since the context was created::"
msgstr ""

#: ../../library/ssl.rst:1889
msgid ""
"Whether to match the peer cert's hostname in :meth:`SSLSocket.do_handshake`. "
"The context's :attr:`~SSLContext.verify_mode` must be set to :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, and you must pass "
"*server_hostname* to :meth:`~SSLContext.wrap_socket` in order to match the "
"hostname.  Enabling hostname checking automatically sets :attr:`~SSLContext."
"verify_mode` from :data:`CERT_NONE` to :data:`CERT_REQUIRED`.  It cannot be "
"set back to :data:`CERT_NONE` as long as hostname checking is enabled. The :"
"data:`PROTOCOL_TLS_CLIENT` protocol enables hostname checking by default. "
"With other protocols, hostname checking must be enabled explicitly."
msgstr ""
"Чи відповідати імені хосту однорангового сертифіката в :meth:`SSLSocket."
"do_handshake`. :attr:`~SSLContext.verify_mode` контексту має бути "
"встановлено на :data:`CERT_OPTIONAL` або :data:`CERT_REQUIRED`, і ви повинні "
"передати *server_hostname* до :meth:`~SSLContext.wrap_socket` для "
"відповідності ім'я хоста. Увімкнення перевірки імені хоста автоматично "
"встановлює :attr:`~SSLContext.verify_mode` з :data:`CERT_NONE` на :data:"
"`CERT_REQUIRED`. Його не можна повернути до :data:`CERT_NONE`, доки "
"ввімкнено перевірку імені хоста. Протокол :data:`PROTOCOL_TLS_CLIENT` умикає "
"перевірку імені хоста за умовчанням. Для інших протоколів перевірка імені "
"хоста повинна бути включена явно."

#: ../../library/ssl.rst:1917
msgid ""
":attr:`~SSLContext.verify_mode` is now automatically changed to :data:"
"`CERT_REQUIRED`  when hostname checking is enabled and :attr:`~SSLContext."
"verify_mode` is :data:`CERT_NONE`. Previously the same operation would have "
"failed with a :exc:`ValueError`."
msgstr ""
":attr:`~SSSLContext.verify_mode` тепер автоматично змінюється на :data:"
"`CERT_REQUIRED`, коли перевірку імені хоста ввімкнено, а :attr:`~SSSLContext."
"verify_mode` має значення :data:`CERT_NONE`. Раніше ця сама операція не "
"виконувалася з помилкою :exc:`ValueError`."

#: ../../library/ssl.rst:1924
msgid "This features requires OpenSSL 0.9.8f or newer."
msgstr ""

#: ../../library/ssl.rst:1928
msgid ""
"Write TLS keys to a keylog file, whenever key material is generated or "
"received. The keylog file is designed for debugging purposes only. The file "
"format is specified by NSS and used by many traffic analyzers such as "
"Wireshark. The log file is opened in append-only mode. Writes are "
"synchronized between threads, but not between processes."
msgstr ""
"Записуйте ключі TLS у файл клавіатурного журналу щоразу, коли створюється "
"або отримується ключовий матеріал. Файл клавіатурного журналу створено лише "
"для налагодження. Формат файлу визначається NSS і використовується багатьма "
"аналізаторами трафіку, такими як Wireshark. Файл журналу відкривається в "
"режимі лише додавання. Записи синхронізуються між потоками, але не між "
"процесами."

#: ../../library/ssl.rst:1938
msgid "This features requires OpenSSL 1.1.1 or newer."
msgstr ""

#: ../../library/ssl.rst:1942
msgid ""
"A :class:`TLSVersion` enum member representing the highest supported TLS "
"version. The value defaults to :attr:`TLSVersion.MAXIMUM_SUPPORTED`. The "
"attribute is read-only for protocols other than :attr:`PROTOCOL_TLS`, :attr:"
"`PROTOCOL_TLS_CLIENT`, and :attr:`PROTOCOL_TLS_SERVER`."
msgstr ""
"Член переліку :class:`TLSVersion` представляє найвищу підтримувану версію "
"TLS. Значенням за замовчуванням є :attr:`TLSVersion.MAXIMUM_SUPPORTED`. "
"Атрибут доступний лише для читання для інших протоколів, ніж :attr:"
"`PROTOCOL_TLS`, :attr:`PROTOCOL_TLS_CLIENT` і :attr:`PROTOCOL_TLS_SERVER`."

#: ../../library/ssl.rst:1947
msgid ""
"The attributes :attr:`~SSLContext.maximum_version`, :attr:`~SSLContext."
"minimum_version` and :attr:`SSLContext.options` all affect the supported SSL "
"and TLS versions of the context. The implementation does not prevent invalid "
"combination. For example a context with :attr:`OP_NO_TLSv1_2` in :attr:"
"`~SSLContext.options` and :attr:`~SSLContext.maximum_version` set to :attr:"
"`TLSVersion.TLSv1_2` will not be able to establish a TLS 1.2 connection."
msgstr ""
"Атрибути :attr:`~SSLContext.maximum_version`, :attr:`~SSLContext."
"minimum_version` і :attr:`SSLContext.options` впливають на підтримувані "
"версії контексту SSL і TLS. Реалізація не запобігає недійсній комбінації. "
"Наприклад, контекст із :attr:`OP_NO_TLSv1_2` у :attr:`~SSLContext.options` "
"і :attr:`~SSLContext.maximum_version` зі значенням :attr:`TLSVersion."
"TLSv1_2` не зможе встановити TLS 1.2 підключення."

#: ../../library/ssl.rst:1958 ../../library/ssl.rst:1970
msgid ""
"This attribute is not available unless the ssl module is compiled with "
"OpenSSL 1.1.0g or newer."
msgstr ""

#: ../../library/ssl.rst:1965
msgid ""
"Like :attr:`SSLContext.maximum_version` except it is the lowest supported "
"version or :attr:`TLSVersion.MINIMUM_SUPPORTED`."
msgstr ""
"Як :attr:`SSLContext.maximum_version`, за винятком того, що це найнижча "
"підтримувана версія або :attr:`TLSVersion.MINIMUM_SUPPORTED`."

#: ../../library/ssl.rst:1977
msgid ""
"Control the number of TLS 1.3 session tickets of a :attr:"
"`TLS_PROTOCOL_SERVER` context. The setting has no impact on TLS 1.0 to 1.2 "
"connections."
msgstr ""

#: ../../library/ssl.rst:1983
msgid ""
"This attribute is not available unless the ssl module is compiled with "
"OpenSSL 1.1.1 or newer."
msgstr ""

#: ../../library/ssl.rst:1990
msgid ""
"An integer representing the set of SSL options enabled on this context. The "
"default value is :data:`OP_ALL`, but you can specify other options such as :"
"data:`OP_NO_SSLv2` by ORing them together."
msgstr ""
"Ціле число, що представляє набір параметрів SSL, увімкнених у цьому "
"контексті. Стандартним значенням є :data:`OP_ALL`, але ви можете вказати "
"інші параметри, наприклад :data:`OP_NO_SSLv2`, об’єднавши їх разом."

#: ../../library/ssl.rst:1995
msgid ""
"With versions of OpenSSL older than 0.9.8m, it is only possible to set "
"options, not to clear them.  Attempting to clear an option (by resetting the "
"corresponding bits) will raise a :exc:`ValueError`."
msgstr ""

#: ../../library/ssl.rst:1999
msgid ":attr:`SSLContext.options` returns :class:`Options` flags:"
msgstr ":attr:`SSLContext.options` повертає прапорці :class:`Options`:"

#: ../../library/ssl.rst:2007
msgid ""
"Enable TLS 1.3 post-handshake client authentication. Post-handshake auth is "
"disabled by default and a server can only request a TLS client certificate "
"during the initial handshake. When enabled, a server may request a TLS "
"client certificate at any time after the handshake."
msgstr ""
"Увімкнути автентифікацію клієнта після рукостискання TLS 1.3. Автентифікація "
"після рукостискання вимкнена за замовчуванням, і сервер може запитувати "
"сертифікат клієнта TLS лише під час початкового рукостискання. Якщо "
"ввімкнено, сервер може запитувати сертифікат клієнта TLS у будь-який час "
"після рукостискання."

#: ../../library/ssl.rst:2012
msgid ""
"When enabled on client-side sockets, the client signals the server that it "
"supports post-handshake authentication."
msgstr ""
"Якщо ввімкнено на сокетах на стороні клієнта, клієнт сигналізує серверу, що "
"він підтримує автентифікацію після рукостискання."

#: ../../library/ssl.rst:2015
msgid ""
"When enabled on server-side sockets, :attr:`SSLContext.verify_mode` must be "
"set to :data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, too. The actual "
"client cert exchange is delayed until :meth:`SSLSocket."
"verify_client_post_handshake` is called and some I/O is performed."
msgstr ""
"Якщо ввімкнено на серверних сокетах, :attr:`SSLContext.verify_mode` також "
"має бути встановлено на :data:`CERT_OPTIONAL` або :data:`CERT_REQUIRED`. "
"Фактичний обмін сертифікатами клієнта відкладено, доки не буде викликано :"
"meth:`SSLSocket.verify_client_post_handshake` і не буде виконано деякий ввід-"
"вивід."

#: ../../library/ssl.rst:2022
msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the property value is None and can't be modified"
msgstr ""

#: ../../library/ssl.rst:2029
msgid ""
"The protocol version chosen when constructing the context.  This attribute "
"is read-only."
msgstr ""
"Версія протоколу, обрана під час побудови контексту. Цей атрибут доступний "
"лише для читання."

#: ../../library/ssl.rst:2034
msgid ""
"Whether :attr:`~SSLContext.check_hostname` falls back to verify the cert's "
"subject common name in the absence of a subject alternative name extension "
"(default: true)."
msgstr ""
"Чи повертається :attr:`~SSLContext.check_hostname` для перевірки загальної "
"назви суб’єкта сертифіката за відсутності альтернативного розширення імені "
"суб’єкта (за умовчанням: істина)."

#: ../../library/ssl.rst:2039
msgid "Only writeable with OpenSSL 1.1.0 or higher."
msgstr ""

#: ../../library/ssl.rst:2045
msgid ""
"The flag had no effect with OpenSSL before version 1.1.1k. Python 3.8.9, "
"3.9.3, and 3.10 include workarounds for previous versions."
msgstr ""
"Прапор не мав ефекту з OpenSSL до версії 1.1.1k. Python 3.8.9, 3.9.3 і 3.10 "
"містять обхідні шляхи для попередніх версій."

#: ../../library/ssl.rst:2050
msgid ""
"The flags for certificate verification operations. You can set flags like :"
"data:`VERIFY_CRL_CHECK_LEAF` by ORing them together. By default OpenSSL does "
"neither require nor verify certificate revocation lists (CRLs). Available "
"only with openssl version 0.9.8+."
msgstr ""

#: ../../library/ssl.rst:2057
msgid ":attr:`SSLContext.verify_flags` returns :class:`VerifyFlags` flags:"
msgstr ""
":attr:`SSLContext.verify_flags` повертає :class:`VerifyFlags` прапорці:"

#: ../../library/ssl.rst:2065
msgid ""
"Whether to try to verify other peers' certificates and how to behave if "
"verification fails.  This attribute must be one of :data:`CERT_NONE`, :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`."
msgstr ""
"Чи намагатися перевірити сертифікати інших вузлів і як поводитися, якщо "
"перевірка не вдається. Цей атрибут має бути одним із :data:`CERT_NONE`, :"
"data:`CERT_OPTIONAL` або :data:`CERT_REQUIRED`."

#: ../../library/ssl.rst:2069
msgid ":attr:`SSLContext.verify_mode` returns :class:`VerifyMode` enum:"
msgstr ":attr:`SSLContext.verify_mode` повертає :class:`VerifyMode` enum:"

#: ../../library/ssl.rst:2082
msgid "Certificates"
msgstr "Certificados"

#: ../../library/ssl.rst:2084
msgid ""
"Certificates in general are part of a public-key / private-key system.  In "
"this system, each *principal*, (which may be a machine, or a person, or an "
"organization) is assigned a unique two-part encryption key.  One part of the "
"key is public, and is called the *public key*; the other part is kept "
"secret, and is called the *private key*.  The two parts are related, in that "
"if you encrypt a message with one of the parts, you can decrypt it with the "
"other part, and **only** with the other part."
msgstr ""
"Загалом сертифікати є частиною системи відкритого/приватного ключа. У цій "
"системі кожному *принципалу* (яким може бути машина, або особа, або "
"організація) призначається унікальний ключ шифрування, що складається з двох "
"частин. Одна частина ключа є відкритою і називається *відкритим ключем*; "
"інша частина зберігається в таємниці та називається *приватним ключем*. Ці "
"дві частини пов’язані між собою, оскільки якщо ви зашифровуєте повідомлення "
"за допомогою однієї з частин, ви можете розшифрувати його за допомогою іншої "
"частини та **тільки** за допомогою іншої частини."

#: ../../library/ssl.rst:2092
msgid ""
"A certificate contains information about two principals.  It contains the "
"name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who they "
"claim to be, and that this is indeed the subject's public key.  The issuer's "
"statement is signed with the issuer's private key, which only the issuer "
"knows.  However, anyone can verify the issuer's statement by finding the "
"issuer's public key, decrypting the statement with it, and comparing it to "
"the other information in the certificate. The certificate also contains "
"information about the time period over which it is valid.  This is expressed "
"as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""
"Сертифікат містить інформацію про двох принципалів. Він містить назву "
"*суб’єкта* та відкритий ключ суб’єкта. Він також містить заяву другого "
"принципала, *емітента*, про те, що суб’єкт є тим, за кого себе видає, і що "
"це справді відкритий ключ суб’єкта. Заява емітента підписується закритим "
"ключем емітента, який відомий лише емітенту. Проте будь-хто може перевірити "
"заяву емітента, знайшовши відкритий ключ емітента, розшифрувавши за його "
"допомогою заяву та порівнявши її з іншою інформацією в сертифікаті. "
"Сертифікат також містить інформацію про термін його дії. Це виражається "
"двома полями, які називаються \"notBefore\" і \"notAfter\"."

#: ../../library/ssl.rst:2102
msgid ""
"In the Python use of certificates, a client or server can use a certificate "
"to prove who they are.  The other side of a network connection can also be "
"required to produce a certificate, and that certificate can be validated to "
"the satisfaction of the client or server that requires such validation.  The "
"connection attempt can be set to raise an exception if the validation fails. "
"Validation is done automatically, by the underlying OpenSSL framework; the "
"application need not concern itself with its mechanics.  But the application "
"does usually need to provide sets of certificates to allow this process to "
"take place."
msgstr ""
"При використанні сертифікатів Python клієнт або сервер можуть "
"використовувати сертифікат, щоб підтвердити, ким вони є. Інша сторона "
"мережевого з’єднання також може вимагати створення сертифіката, і цей "
"сертифікат може бути перевірений відповідно до вимог клієнта або сервера, "
"які потребують такої перевірки. Спробу підключення можна налаштувати так, "
"щоб викликати виняток, якщо перевірка не вдається. Перевірка виконується "
"автоматично базовою структурою OpenSSL; програмі не потрібно займатися своєю "
"механікою. Але програмі зазвичай потрібно надати набори сертифікатів, щоб "
"дозволити цей процес."

#: ../../library/ssl.rst:2112
msgid ""
"Python uses files to contain certificates.  They should be formatted as "
"\"PEM\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a "
"header line and a footer line::"
msgstr ""
"Python використовує файли для зберігання сертифікатів. Вони повинні бути "
"відформатовані як \"PEM\" (див. :rfc:`1422`), який є формою, закодованою на "
"базі 64, оберненою рядком верхнього та нижнього колонтитулів::"

#: ../../library/ssl.rst:2121
msgid "Certificate chains"
msgstr "Ланцюжки сертифікатів"

#: ../../library/ssl.rst:2123
msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the client "
"or server, and then the certificate for the issuer of that certificate, and "
"then the certificate for the issuer of *that* certificate, and so on up the "
"chain till you get to a certificate which is *self-signed*, that is, a "
"certificate which has the same subject and issuer, sometimes called a *root "
"certificate*.  The certificates should just be concatenated together in the "
"certificate file.  For example, suppose we had a three certificate chain, "
"from our server certificate to the certificate of the certification "
"authority that signed our server certificate, to the root certificate of the "
"agency which issued the certification authority's certificate::"
msgstr ""
"Файли Python, які містять сертифікати, можуть містити послідовність "
"сертифікатів, яку іноді називають *ланцюжком сертифікатів*. Цей ланцюжок має "
"починатися з конкретного сертифіката для принципала, який \"є\" клієнтом або "
"сервером, а потім сертифіката для видавця цього сертифіката, а потім "
"сертифіката для видавця *цього* сертифіката, і так далі вгору по ланцюжку "
"доки ви не дійдете до *самопідписаного* сертифіката, тобто сертифіката з тим "
"самим суб’єктом і видавцем, який іноді називають *кореневим сертифікатом*. "
"Сертифікати потрібно просто об’єднати у файлі сертифікатів. Наприклад, "
"припустімо, що ми маємо ланцюжок із трьох сертифікатів: від сертифіката "
"нашого сервера до сертифіката центру сертифікації, який підписав наш "
"сертифікат сервера, до кореневого сертифіката агентства, яке видало "
"сертифікат центру сертифікації:"

#: ../../library/ssl.rst:2147
msgid "CA certificates"
msgstr "сертифікати ЦС"

#: ../../library/ssl.rst:2149
msgid ""
"If you are going to require validation of the other side of the connection's "
"certificate, you need to provide a \"CA certs\" file, filled with the "
"certificate chains for each issuer you are willing to trust.  Again, this "
"file just contains these chains concatenated together.  For validation, "
"Python will use the first chain it finds in the file which matches.  The "
"platform's certificates file can be used by calling :meth:`SSLContext."
"load_default_certs`, this is done automatically with :func:`."
"create_default_context`."
msgstr ""
"Якщо ви збираєтеся вимагати підтвердження іншої сторони сертифіката "
"з’єднання, вам потрібно надати файл \"сертифікатів ЦС\", заповнений "
"ланцюжками сертифікатів для кожного видавця, якому ви готові довіряти. Знову "
"ж таки, цей файл містить ці ланцюжки, об’єднані разом. Для перевірки Python "
"використовуватиме перший ланцюжок, знайдений у файлі, який відповідає. Файл "
"сертифікатів платформи можна використовувати, викликавши :meth:`SSLContext."
"load_default_certs`, це робиться автоматично за допомогою :func:`."
"create_default_context`."

#: ../../library/ssl.rst:2158
msgid "Combined key and certificate"
msgstr "Комбінований ключ і сертифікат"

#: ../../library/ssl.rst:2160
msgid ""
"Often the private key is stored in the same file as the certificate; in this "
"case, only the ``certfile`` parameter to :meth:`SSLContext.load_cert_chain` "
"and :func:`wrap_socket` needs to be passed.  If the private key is stored "
"with the certificate, it should come before the first certificate in the "
"certificate chain::"
msgstr ""
"Часто закритий ключ зберігається в тому ж файлі, що й сертифікат; у цьому "
"випадку потрібно передати лише параметр ``certfile`` для :meth:`SSSLContext."
"load_cert_chain` і :func:`wrap_socket`. Якщо приватний ключ зберігається "
"разом із сертифікатом, він має бути перед першим сертифікатом у ланцюжку "
"сертифікатів:"

#: ../../library/ssl.rst:2174
msgid "Self-signed certificates"
msgstr "Самопідписані сертифікати"

#: ../../library/ssl.rst:2176
msgid ""
"If you are going to create a server that provides SSL-encrypted connection "
"services, you will need to acquire a certificate for that service.  There "
"are many ways of acquiring appropriate certificates, such as buying one from "
"a certification authority.  Another common practice is to generate a self-"
"signed certificate.  The simplest way to do this is with the OpenSSL "
"package, using something like the following::"
msgstr ""
"Якщо ви збираєтеся створити сервер, який надає послуги з’єднання з "
"шифруванням SSL, вам потрібно буде отримати сертифікат для цієї послуги. Є "
"багато способів отримати відповідні сертифікати, наприклад придбати "
"сертифікат в центрі сертифікації. Іншою поширеною практикою є створення "
"самопідписаного сертифіката. Найпростіший спосіб зробити це за допомогою "
"пакета OpenSSL, використовуючи щось на зразок наступного:"

#: ../../library/ssl.rst:2205
msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr ""
"Недоліком самопідписаного сертифіката є те, що це його власний кореневий "
"сертифікат, і ніхто інший не матиме його в кеш-пам’яті відомих (і надійних) "
"кореневих сертифікатів."

#: ../../library/ssl.rst:2211
msgid "Examples"
msgstr "Exemplos"

#: ../../library/ssl.rst:2214
msgid "Testing for SSL support"
msgstr "Тестування підтримки SSL"

#: ../../library/ssl.rst:2216
msgid ""
"To test for the presence of SSL support in a Python installation, user code "
"should use the following idiom::"
msgstr ""
"Щоб перевірити наявність підтримки SSL у встановленому Python, код "
"користувача має використовувати таку ідіому:"

#: ../../library/ssl.rst:2227
msgid "Client-side operation"
msgstr "Робота на стороні клієнта"

#: ../../library/ssl.rst:2229
msgid ""
"This example creates a SSL context with the recommended security settings "
"for client sockets, including automatic certificate verification::"
msgstr ""
"У цьому прикладі створюється контекст SSL із рекомендованими налаштуваннями "
"безпеки для клієнтських сокетів, включаючи автоматичну перевірку сертифіката:"

#: ../../library/ssl.rst:2234
msgid ""
"If you prefer to tune security settings yourself, you might create a context "
"from scratch (but beware that you might not get the settings right)::"
msgstr ""
"Якщо ви бажаєте налаштувати параметри безпеки самостійно, ви можете створити "
"контекст з нуля (але пам’ятайте, що ви можете неправильно встановити "
"параметри):"

#: ../../library/ssl.rst:2241
msgid ""
"(this snippet assumes your operating system places a bundle of all CA "
"certificates in ``/etc/ssl/certs/ca-bundle.crt``; if not, you'll get an "
"error and have to adjust the location)"
msgstr ""
"(цей фрагмент припускає, що ваша операційна система розміщує пакет усіх "
"сертифікатів ЦС у ``/etc/ssl/certs/ca-bundle.crt``; якщо ні, ви отримаєте "
"повідомлення про помилку, і вам доведеться змінити розташування)"

#: ../../library/ssl.rst:2245
msgid ""
"The :data:`PROTOCOL_TLS_CLIENT` protocol configures the context for cert "
"validation and hostname verification. :attr:`~SSLContext.verify_mode` is set "
"to :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` is set to "
"``True``. All other protocols create SSL contexts with insecure defaults."
msgstr ""
"Протокол :data:`PROTOCOL_TLS_CLIENT` налаштовує контекст для перевірки "
"сертифіката та перевірки імені хоста. :attr:`~SSLContext.verify_mode` "
"встановлено на :data:`CERT_REQUIRED`, а :attr:`~SSLContext.check_hostname` "
"встановлено на ``True``. Усі інші протоколи створюють контексти SSL із "
"незахищеними значеннями за умовчанням."

#: ../../library/ssl.rst:2250
msgid ""
"When you use the context to connect to a server, :const:`CERT_REQUIRED` and :"
"attr:`~SSLContext.check_hostname` validate the server certificate: it "
"ensures that the server certificate was signed with one of the CA "
"certificates, checks the signature for correctness, and verifies other "
"properties like validity and identity of the hostname::"
msgstr ""
"Коли ви використовуєте контекст для підключення до сервера, :const:"
"`CERT_REQUIRED` і :attr:`~SSSLContext.check_hostname` перевіряють сертифікат "
"сервера: це гарантує, що сертифікат сервера було підписано одним із "
"сертифікатів ЦС, перевіряє підпис на коректність і перевіряє інші "
"властивості, такі як дійсність та ідентичність імені хоста::"

#: ../../library/ssl.rst:2260
msgid "You may then fetch the certificate::"
msgstr "Потім ви можете отримати сертифікат:"

#: ../../library/ssl.rst:2264
msgid ""
"Visual inspection shows that the certificate does identify the desired "
"service (that is, the HTTPS host ``www.python.org``)::"
msgstr ""
"Візуальна перевірка показує, що сертифікат ідентифікує потрібну службу "
"(тобто хост HTTPS ``www.python.org``):"

#: ../../library/ssl.rst:2307
msgid ""
"Now the SSL channel is established and the certificate verified, you can "
"proceed to talk with the server::"
msgstr ""
"Тепер SSL-канал встановлено та сертифікат перевірено, ви можете продовжити "
"спілкування з сервером:"

#: ../../library/ssl.rst:2334
msgid "Server-side operation"
msgstr "Робота на стороні сервера"

#: ../../library/ssl.rst:2336
msgid ""
"For server operation, typically you'll need to have a server certificate, "
"and private key, each in a file.  You'll first create a context holding the "
"key and the certificate, so that clients can check your authenticity.  Then "
"you'll open a socket, bind it to a port, call :meth:`listen` on it, and "
"start waiting for clients to connect::"
msgstr ""
"Для роботи сервера зазвичай потрібно мати сертифікат сервера та закритий "
"ключ, кожен у файлі. Спочатку ви створите контекст, що містить ключ і "
"сертифікат, щоб клієнти могли перевірити вашу автентичність. Потім ви "
"відкриєте сокет, прив’яжете його до порту, викличете на ньому :meth:`listen` "
"і почнете чекати підключення клієнтів::"

#: ../../library/ssl.rst:2351
msgid ""
"When a client connects, you'll call :meth:`accept` on the socket to get the "
"new socket from the other end, and use the context's :meth:`SSLContext."
"wrap_socket` method to create a server-side SSL socket for the connection::"
msgstr ""
"Коли клієнт підключається, ви викличете :meth:`accept` для сокета, щоб "
"отримати новий сокет з іншого боку, і використаєте контекстний метод :meth:"
"`SSLContext.wrap_socket`, щоб створити серверний сокет SSL для зв'язок::"

#: ../../library/ssl.rst:2364
msgid ""
"Then you'll read data from the ``connstream`` and do something with it till "
"you are finished with the client (or the client is finished with you)::"
msgstr ""
"Потім ви будете читати дані з ``connstream`` і щось робити з ними, поки не "
"закінчите роботу з клієнтом (або клієнт не закінчить роботу з вами):"

#: ../../library/ssl.rst:2378
msgid ""
"And go back to listening for new client connections (of course, a real "
"server would probably handle each client connection in a separate thread, or "
"put the sockets in :ref:`non-blocking mode <ssl-nonblocking>` and use an "
"event loop)."
msgstr ""
"І поверніться до прослуховування нових клієнтських з’єднань (звичайно, "
"реальний сервер, ймовірно, оброблятиме кожне клієнтське з’єднання в окремому "
"потоці або переведе сокети в :ref:`неблокуючий режим <ssl-nonblocking>` і "
"використає цикл подій)."

#: ../../library/ssl.rst:2386
msgid "Notes on non-blocking sockets"
msgstr "Примітки щодо неблокуючих розеток"

#: ../../library/ssl.rst:2388
msgid ""
"SSL sockets behave slightly different than regular sockets in non-blocking "
"mode. When working with non-blocking sockets, there are thus several things "
"you need to be aware of:"
msgstr ""
"SSL-сокети поводяться дещо інакше, ніж звичайні сокети в неблокуючому "
"режимі. Працюючи з неблокуючими сокетами, ви повинні знати про кілька речей:"

#: ../../library/ssl.rst:2392
msgid ""
"Most :class:`SSLSocket` methods will raise either :exc:`SSLWantWriteError` "
"or :exc:`SSLWantReadError` instead of :exc:`BlockingIOError` if an I/O "
"operation would block. :exc:`SSLWantReadError` will be raised if a read "
"operation on the underlying socket is necessary, and :exc:"
"`SSLWantWriteError` for a write operation on the underlying socket. Note "
"that attempts to *write* to an SSL socket may require *reading* from the "
"underlying socket first, and attempts to *read* from the SSL socket may "
"require a prior *write* to the underlying socket."
msgstr ""
"Більшість методів :class:`SSLSocket` викликають або :exc:"
"`SSLWantWriteError`, або :exc:`SSLWantReadError` замість :exc:"
"`BlockingIOError`, якщо операція вводу/виводу буде заблокована. :exc:"
"`SSLWantReadError` буде викликано, якщо операція читання базового сокета є "
"необхідною, і :exc:`SSLWantWriteError` для операції запису базового сокета. "
"Зауважте, що спроби *запису* в сокет SSL можуть вимагати спочатку *читання* "
"з базового сокета, а спроби *читання* з сокета SSL можуть вимагати "
"попереднього *запису* в базовий сокет."

#: ../../library/ssl.rst:2404
msgid ""
"In earlier Python versions, the :meth:`!SSLSocket.send` method returned zero "
"instead of raising :exc:`SSLWantWriteError` or :exc:`SSLWantReadError`."
msgstr ""
"У попередніх версіях Python метод :meth:`!SSLSocket.send` повертав нуль "
"замість того, щоб викликати :exc:`SSLWantWriteError` або :exc:"
"`SSLWantReadError`."

#: ../../library/ssl.rst:2408
msgid ""
"Calling :func:`~select.select` tells you that the OS-level socket can be "
"read from (or written to), but it does not imply that there is sufficient "
"data at the upper SSL layer.  For example, only part of an SSL frame might "
"have arrived.  Therefore, you must be ready to handle :meth:`SSLSocket.recv` "
"and :meth:`SSLSocket.send` failures, and retry after another call to :func:"
"`~select.select`."
msgstr ""
"Виклик :func:`~select.select` повідомляє вам, що сокет рівня ОС можна "
"зчитувати (або записувати), але це не означає, що на верхньому рівні SSL "
"достатньо даних. Наприклад, могла надійти лише частина кадру SSL. Таким "
"чином, ви повинні бути готові впоратися з помилками :meth:`SSLSocket.recv` "
"і :meth:`SSLSocket.send` і повторити спробу після іншого виклику :func:"
"`~select.select`."

#: ../../library/ssl.rst:2415
msgid ""
"Conversely, since the SSL layer has its own framing, a SSL socket may still "
"have data available for reading without :func:`~select.select` being aware "
"of it.  Therefore, you should first call :meth:`SSLSocket.recv` to drain any "
"potentially available data, and then only block on a :func:`~select.select` "
"call if still necessary."
msgstr ""
"І навпаки, оскільки рівень SSL має власне фреймування, сокет SSL все ще може "
"мати дані, доступні для читання, не знаючи про це :func:`~select.select`. "
"Таким чином, ви повинні спочатку викликати :meth:`SSLSocket.recv`, щоб "
"вичерпати будь-які потенційно доступні дані, а потім лише заблокувати "
"виклик :func:`~select.select`, якщо все ще необхідно."

#: ../../library/ssl.rst:2421
msgid ""
"(of course, similar provisions apply when using other primitives such as :"
"func:`~select.poll`, or those in the :mod:`selectors` module)"
msgstr ""
"(звичайно, подібні положення застосовуються при використанні інших "
"примітивів, таких як :func:`~select.poll` або в модулі :mod:`selectors`)"

#: ../../library/ssl.rst:2424
msgid ""
"The SSL handshake itself will be non-blocking: the :meth:`SSLSocket."
"do_handshake` method has to be retried until it returns successfully.  Here "
"is a synopsis using :func:`~select.select` to wait for the socket's "
"readiness::"
msgstr ""
"Саме рукостискання SSL буде неблокуючим: метод :meth:`SSLSocket."
"do_handshake` потрібно повторити, поки він не повернеться успішно. Ось "
"короткий опис використання :func:`~select.select` для очікування готовності "
"сокета::"

#: ../../library/ssl.rst:2440
msgid ""
"The :mod:`asyncio` module supports :ref:`non-blocking SSL sockets <ssl-"
"nonblocking>` and provides a higher level API. It polls for events using "
"the :mod:`selectors` module and handles :exc:`SSLWantWriteError`, :exc:"
"`SSLWantReadError` and :exc:`BlockingIOError` exceptions. It runs the SSL "
"handshake asynchronously as well."
msgstr ""
"Модуль :mod:`asyncio` підтримує :ref:`неблокуючі сокети SSL <ssl-"
"nonblocking>` і забезпечує API вищого рівня. Він опитує події за допомогою "
"модуля :mod:`selectors` і обробляє винятки :exc:`SSLWantWriteError`, :exc:"
"`SSLWantReadError` і :exc:`BlockingIOError`. Він також запускає "
"рукостискання SSL асинхронно."

#: ../../library/ssl.rst:2449
msgid "Memory BIO Support"
msgstr "Підтримка BIO пам'яті"

#: ../../library/ssl.rst:2453
msgid ""
"Ever since the SSL module was introduced in Python 2.6, the :class:"
"`SSLSocket` class has provided two related but distinct areas of "
"functionality:"
msgstr ""
"З тих пір, як модуль SSL було представлено в Python 2.6, клас :class:"
"`SSLSocket` забезпечив дві пов’язані, але різні області функціональності:"

#: ../../library/ssl.rst:2456
msgid "SSL protocol handling"
msgstr "Обробка протоколу SSL"

#: ../../library/ssl.rst:2457
msgid "Network IO"
msgstr "Мережа IO"

#: ../../library/ssl.rst:2459
msgid ""
"The network IO API is identical to that provided by :class:`socket.socket`, "
"from which :class:`SSLSocket` also inherits. This allows an SSL socket to be "
"used as a drop-in replacement for a regular socket, making it very easy to "
"add SSL support to an existing application."
msgstr ""
"Мережевий IO API ідентичний тому, який надає :class:`socket.socket`, від "
"якого також успадковується :class:`SSLSocket`. Це дозволяє використовувати "
"сокет SSL як додаткову заміну звичайного сокета, що дозволяє дуже легко "
"додати підтримку SSL до існуючої програми."

#: ../../library/ssl.rst:2464
msgid ""
"Combining SSL protocol handling and network IO usually works well, but there "
"are some cases where it doesn't. An example is async IO frameworks that want "
"to use a different IO multiplexing model than the \"select/poll on a file "
"descriptor\" (readiness based) model that is assumed by :class:`socket."
"socket` and by the internal OpenSSL socket IO routines. This is mostly "
"relevant for platforms like Windows where this model is not efficient. For "
"this purpose, a reduced scope variant of :class:`SSLSocket` called :class:"
"`SSLObject` is provided."
msgstr ""
"Поєднання обробки протоколу SSL і мережевого введення-виведення зазвичай "
"працює добре, але в деяких випадках це не так. Прикладом є асинхронні "
"структури вводу-виводу, які хочуть використовувати іншу модель "
"мультиплексування вводу-виводу, ніж модель \"вибір/опитування дескриптора "
"файлу\" (на основі готовності), яка передбачається :class:`socket.socket` і "
"внутрішнім вводом-виводом сокета OpenSSL рутини. Це в основному актуально "
"для таких платформ, як Windows, де ця модель не ефективна. Для цього "
"надається зменшений варіант :class:`SSLSocket` під назвою :class:`SSLObject`."

#: ../../library/ssl.rst:2475
msgid ""
"A reduced-scope variant of :class:`SSLSocket` representing an SSL protocol "
"instance that does not contain any network IO methods. This class is "
"typically used by framework authors that want to implement asynchronous IO "
"for SSL through memory buffers."
msgstr ""
"Зменшений варіант :class:`SSLSocket`, що представляє екземпляр протоколу "
"SSL, який не містить жодних мережевих методів введення-виведення. Цей клас "
"зазвичай використовується авторами фреймворків, які хочуть реалізувати "
"асинхронний IO для SSL через буфери пам’яті."

#: ../../library/ssl.rst:2480
msgid ""
"This class implements an interface on top of a low-level SSL object as "
"implemented by OpenSSL. This object captures the state of an SSL connection "
"but does not provide any network IO itself. IO needs to be performed through "
"separate \"BIO\" objects which are OpenSSL's IO abstraction layer."
msgstr ""
"Цей клас реалізує інтерфейс поверх об’єкта SSL низького рівня, реалізованого "
"OpenSSL. Цей об’єкт фіксує стан SSL-з’єднання, але сам не надає мережевий "
"IO. IO потрібно виконувати через окремі об’єкти \"BIO\", які є рівнем "
"абстракції IO OpenSSL."

#: ../../library/ssl.rst:2485
msgid ""
"This class has no public constructor.  An :class:`SSLObject` instance must "
"be created using the :meth:`~SSLContext.wrap_bio` method. This method will "
"create the :class:`SSLObject` instance and bind it to a pair of BIOs. The "
"*incoming* BIO is used to pass data from Python to the SSL protocol "
"instance, while the *outgoing* BIO is used to pass data the other way around."
msgstr ""
"Цей клас не має публічного конструктора. Екземпляр :class:`SSLObject` має "
"бути створений за допомогою методу :meth:`~SSLContext.wrap_bio`. Цей метод "
"створить екземпляр :class:`SSLObject` і прив’яже його до пари BIO. *Вхідний* "
"BIO використовується для передачі даних від Python до примірника протоколу "
"SSL, тоді як *вихідний* BIO використовується для передачі даних навпаки."

#: ../../library/ssl.rst:2492
msgid "The following methods are available:"
msgstr "Доступні такі методи:"

#: ../../library/ssl.rst:2494
msgid ":attr:`~SSLSocket.context`"
msgstr ":attr:`~SSLSocket.context`"

#: ../../library/ssl.rst:2495
msgid ":attr:`~SSLSocket.server_side`"
msgstr ":attr:`~SSLSocket.server_side`"

#: ../../library/ssl.rst:2496
msgid ":attr:`~SSLSocket.server_hostname`"
msgstr ":attr:`~SSLSocket.server_hostname`"

#: ../../library/ssl.rst:2497
msgid ":attr:`~SSLSocket.session`"
msgstr ":attr:`~SSLSocket.session`"

#: ../../library/ssl.rst:2498
msgid ":attr:`~SSLSocket.session_reused`"
msgstr ":attr:`~SSLSocket.session_reused`"

#: ../../library/ssl.rst:2499
msgid ":meth:`~SSLSocket.read`"
msgstr ":meth:`~SSLSocket.read`"

#: ../../library/ssl.rst:2500
msgid ":meth:`~SSLSocket.write`"
msgstr ":meth:`~SSLSocket.write`"

#: ../../library/ssl.rst:2501
msgid ":meth:`~SSLSocket.getpeercert`"
msgstr ":meth:`~SSLSocket.getpeercert`"

#: ../../library/ssl.rst:2502
msgid ":meth:`~SSLSocket.selected_alpn_protocol`"
msgstr ":meth:`~SSLSocket.selected_alpn_protocol`"

#: ../../library/ssl.rst:2503
msgid ":meth:`~SSLSocket.selected_npn_protocol`"
msgstr ":meth:`~SSLSocket.selected_npn_protocol`"

#: ../../library/ssl.rst:2504
msgid ":meth:`~SSLSocket.cipher`"
msgstr ":meth:`~SSLSocket.cipher`"

#: ../../library/ssl.rst:2505
msgid ":meth:`~SSLSocket.shared_ciphers`"
msgstr ":meth:`~SSLSocket.shared_ciphers`"

#: ../../library/ssl.rst:2506
msgid ":meth:`~SSLSocket.compression`"
msgstr ":meth:`~SSLSocket.compression`"

#: ../../library/ssl.rst:2507
msgid ":meth:`~SSLSocket.pending`"
msgstr ":meth:`~SSLSocket.pending`"

#: ../../library/ssl.rst:2508
msgid ":meth:`~SSLSocket.do_handshake`"
msgstr ":meth:`~SSLSocket.do_handshake`"

#: ../../library/ssl.rst:2509
msgid ":meth:`~SSLSocket.verify_client_post_handshake`"
msgstr ":meth:`~SSLSocket.verify_client_post_handshake`"

#: ../../library/ssl.rst:2510
msgid ":meth:`~SSLSocket.unwrap`"
msgstr ":meth:`~SSLSocket.unwrap`"

#: ../../library/ssl.rst:2511
msgid ":meth:`~SSLSocket.get_channel_binding`"
msgstr ":meth:`~SSLSocket.get_channel_binding`"

#: ../../library/ssl.rst:2512
msgid ":meth:`~SSLSocket.version`"
msgstr ":meth:`~SSLSocket.version`"

#: ../../library/ssl.rst:2514
msgid ""
"When compared to :class:`SSLSocket`, this object lacks the following "
"features:"
msgstr ""
"У порівнянні з :class:`SSLSocket` цьому об’єкту бракує наступних функцій:"

#: ../../library/ssl.rst:2517
msgid ""
"Any form of network IO; ``recv()`` and ``send()`` read and write only to the "
"underlying :class:`MemoryBIO` buffers."
msgstr ""
"Будь-яка форма мережевого вводу-виводу; ``recv()`` і ``send()`` читають і "
"записують лише в базові буфери :class:`MemoryBIO`."

#: ../../library/ssl.rst:2520
msgid ""
"There is no *do_handshake_on_connect* machinery. You must always manually "
"call :meth:`~SSLSocket.do_handshake` to start the handshake."
msgstr ""
"Не існує механізму *do_handshake_on_connect*. Ви завжди повинні вручну "
"викликати :meth:`~SSLSocket.do_handshake`, щоб почати рукостискання."

#: ../../library/ssl.rst:2523
msgid ""
"There is no handling of *suppress_ragged_eofs*. All end-of-file conditions "
"that are in violation of the protocol are reported via the :exc:"
"`SSLEOFError` exception."
msgstr ""
"Немає обробки *suppress_ragged_eofs*. Усі умови кінця файлу, які порушують "
"протокол, повідомляються через виняток :exc:`SSLEOFError`."

#: ../../library/ssl.rst:2527
msgid ""
"The method :meth:`~SSLSocket.unwrap` call does not return anything, unlike "
"for an SSL socket where it returns the underlying socket."
msgstr ""
"Виклик методу :meth:`~SSLSocket.unwrap` нічого не повертає, на відміну від "
"сокета SSL, де він повертає основний сокет."

#: ../../library/ssl.rst:2530
msgid ""
"The *server_name_callback* callback passed to :meth:`SSLContext."
"set_servername_callback` will get an :class:`SSLObject` instance instead of "
"a :class:`SSLSocket` instance as its first parameter."
msgstr ""
"Зворотний виклик *server_name_callback*, переданий :meth:`SSLContext."
"set_servername_callback`, отримає екземпляр :class:`SSLObject` замість "
"екземпляра :class:`SSLSocket` як перший параметр."

#: ../../library/ssl.rst:2534
msgid "Some notes related to the use of :class:`SSLObject`:"
msgstr "Деякі зауваження щодо використання :class:`SSLObject`:"

#: ../../library/ssl.rst:2536
msgid ""
"All IO on an :class:`SSLObject` is :ref:`non-blocking <ssl-nonblocking>`. "
"This means that for example :meth:`~SSLSocket.read` will raise an :exc:"
"`SSLWantReadError` if it needs more data than the incoming BIO has available."
msgstr ""
"Усі IO для :class:`SSLObject` є :ref:`неблокуючими <ssl-nonblocking>`. Це "
"означає, що, наприклад, :meth:`~SSLSocket.read` викличе :exc:"
"`SSLWantReadError`, якщо йому потрібно більше даних, ніж доступно у вхідному "
"BIO."

#: ../../library/ssl.rst:2541
msgid ""
"There is no module-level ``wrap_bio()`` call like there is for :meth:"
"`~SSLContext.wrap_socket`. An :class:`SSLObject` is always created via an :"
"class:`SSLContext`."
msgstr ""
"Немає виклику ``wrap_bio()`` на рівні модуля, як для :meth:`~SSLContext."
"wrap_socket`. :class:`SSLObject` завжди створюється через :class:"
"`SSLContext`."

#: ../../library/ssl.rst:2545
msgid ""
":class:`SSLObject` instances must to created with :meth:`~SSLContext."
"wrap_bio`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""
"Екземпляри :class:`SSLObject` повинні бути створені за допомогою :meth:"
"`~SSSLContext.wrap_bio`. У попередніх версіях можна було створювати "
"екземпляри безпосередньо. Це ніколи не було задокументовано чи офіційно "
"підтверджено."

#: ../../library/ssl.rst:2551
msgid ""
"An SSLObject communicates with the outside world using memory buffers. The "
"class :class:`MemoryBIO` provides a memory buffer that can be used for this "
"purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:"
msgstr ""
"SSLObject спілкується із зовнішнім світом за допомогою буферів пам’яті. "
"Клас :class:`MemoryBIO` забезпечує буфер пам’яті, який можна використовувати "
"для цієї мети. Він обертає об’єкт BIO пам’яті OpenSSL (Basic IO):"

#: ../../library/ssl.rst:2557
msgid ""
"A memory buffer that can be used to pass data between Python and an SSL "
"protocol instance."
msgstr ""
"Буфер пам’яті, який можна використовувати для передачі даних між Python та "
"екземпляром протоколу SSL."

#: ../../library/ssl.rst:2562
msgid "Return the number of bytes currently in the memory buffer."
msgstr "Повертає кількість байтів у буфері пам'яті."

#: ../../library/ssl.rst:2566
msgid ""
"A boolean indicating whether the memory BIO is current at the end-of-file "
"position."
msgstr ""
"Логічне значення, яке вказує, чи є BIO пам’яті поточним у позиції кінця "
"файлу."

#: ../../library/ssl.rst:2571
msgid ""
"Read up to *n* bytes from the memory buffer. If *n* is not specified or "
"negative, all bytes are returned."
msgstr ""
"Прочитати до *n* байт із буфера пам’яті. Якщо *n* не вказано або має "
"негативне значення, повертаються всі байти."

#: ../../library/ssl.rst:2576
msgid ""
"Write the bytes from *buf* to the memory BIO. The *buf* argument must be an "
"object supporting the buffer protocol."
msgstr ""
"Запишіть байти з *buf* в пам'ять BIO. Аргумент *buf* має бути об’єктом, що "
"підтримує протокол буфера."

#: ../../library/ssl.rst:2579
msgid ""
"The return value is the number of bytes written, which is always equal to "
"the length of *buf*."
msgstr ""
"Поверненим значенням є кількість записаних байтів, яка завжди дорівнює "
"довжині *buf*."

#: ../../library/ssl.rst:2584
msgid ""
"Write an EOF marker to the memory BIO. After this method has been called, it "
"is illegal to call :meth:`~MemoryBIO.write`. The attribute :attr:`eof` will "
"become true after all data currently in the buffer has been read."
msgstr ""
"Запишіть маркер EOF в пам'ять BIO. Після виклику цього методу викликати :"
"meth:`~MemoryBIO.write` заборонено. Атрибут :attr:`eof` стане істинним після "
"того, як усі дані, які зараз знаходяться в буфері, будуть прочитані."

#: ../../library/ssl.rst:2590
msgid "SSL session"
msgstr "Сеанс SSL"

#: ../../library/ssl.rst:2596
msgid "Session object used by :attr:`~SSLSocket.session`."
msgstr "Об’єкт сеансу, який використовує :attr:`~SSLSocket.session`."

#: ../../library/ssl.rst:2608
msgid "Security considerations"
msgstr "Considerações de segurança"

#: ../../library/ssl.rst:2611
msgid "Best defaults"
msgstr "Найкращі параметри за замовчуванням"

#: ../../library/ssl.rst:2613
msgid ""
"For **client use**, if you don't have any special requirements for your "
"security policy, it is highly recommended that you use the :func:"
"`create_default_context` function to create your SSL context. It will load "
"the system's trusted CA certificates, enable certificate validation and "
"hostname checking, and try to choose reasonably secure protocol and cipher "
"settings."
msgstr ""
"Для **користування клієнтом**, якщо у вас немає особливих вимог до вашої "
"політики безпеки, настійно рекомендується використовувати функцію :func:"
"`create_default_context` для створення контексту SSL. Він завантажить "
"довірені сертифікати ЦС системи, увімкне перевірку сертифіката та перевірку "
"імені хоста, а також спробує вибрати достатньо безпечний протокол і "
"налаштування шифру."

#: ../../library/ssl.rst:2620
msgid ""
"For example, here is how you would use the :class:`smtplib.SMTP` class to "
"create a trusted, secure connection to a SMTP server::"
msgstr ""
"Наприклад, ось як можна використовувати клас :class:`smtplib.SMTP` для "
"створення надійного безпечного з’єднання з сервером SMTP:"

#: ../../library/ssl.rst:2629
msgid ""
"If a client certificate is needed for the connection, it can be added with :"
"meth:`SSLContext.load_cert_chain`."
msgstr ""
"Якщо для підключення потрібен сертифікат клієнта, його можна додати за "
"допомогою :meth:`SSSLContext.load_cert_chain`."

#: ../../library/ssl.rst:2632
msgid ""
"By contrast, if you create the SSL context by calling the :class:"
"`SSLContext` constructor yourself, it will not have certificate validation "
"nor hostname checking enabled by default.  If you do so, please read the "
"paragraphs below to achieve a good security level."
msgstr ""
"Навпаки, якщо ви створюєте контекст SSL, викликаючи конструктор :class:"
"`SSLContext` самостійно, за замовчуванням не буде ввімкнено ні перевірку "
"сертифіката, ні перевірку імені хоста. Якщо ви це зробите, будь ласка, "
"прочитайте параграфи нижче, щоб досягти хорошого рівня безпеки."

#: ../../library/ssl.rst:2638
msgid "Manual settings"
msgstr "Ручні налаштування"

#: ../../library/ssl.rst:2641
msgid "Verifying certificates"
msgstr "Перевірка сертифікатів"

#: ../../library/ssl.rst:2643
msgid ""
"When calling the :class:`SSLContext` constructor directly, :const:"
"`CERT_NONE` is the default.  Since it does not authenticate the other peer, "
"it can be insecure, especially in client mode where most of time you would "
"like to ensure the authenticity of the server you're talking to. Therefore, "
"when in client mode, it is highly recommended to use :const:"
"`CERT_REQUIRED`.  However, it is in itself not sufficient; you also have to "
"check that the server certificate, which can be obtained by calling :meth:"
"`SSLSocket.getpeercert`, matches the desired service.  For many protocols "
"and applications, the service can be identified by the hostname; in this "
"case, the :func:`match_hostname` function can be used.  This common check is "
"automatically performed when :attr:`SSLContext.check_hostname` is enabled."
msgstr ""
"Під час безпосереднього виклику конструктора :class:`SSLContext` типовим є :"
"const:`CERT_NONE`. Оскільки він не автентифікує іншого однорангового вузла, "
"він може бути небезпечним, особливо в режимі клієнта, де більшу частину часу "
"ви хочете переконатися в автентичності сервера, з яким спілкуєтеся. Тому в "
"режимі клієнта настійно рекомендується використовувати :const:"
"`CERT_REQUIRED`. Однак цього самого по собі недостатньо; ви також повинні "
"перевірити, чи сертифікат сервера, який можна отримати, викликавши :meth:"
"`SSLSocket.getpeercert`, відповідає бажаній службі. Для багатьох протоколів "
"і програм послугу можна ідентифікувати за іменем хоста; у цьому випадку "
"можна використати функцію :func:`match_hostname`. Ця звичайна перевірка "
"виконується автоматично, коли :attr:`SSLContext.check_hostname` увімкнено."

#: ../../library/ssl.rst:2656
msgid ""
"Hostname matchings is now performed by OpenSSL. Python no longer uses :func:"
"`match_hostname`."
msgstr ""
"Зіставлення імен хостів тепер виконує OpenSSL. Python більше не "
"використовує :func:`match_hostname`."

#: ../../library/ssl.rst:2660
msgid ""
"In server mode, if you want to authenticate your clients using the SSL layer "
"(rather than using a higher-level authentication mechanism), you'll also "
"have to specify :const:`CERT_REQUIRED` and similarly check the client "
"certificate."
msgstr ""
"У режимі сервера, якщо ви хочете автентифікувати своїх клієнтів за допомогою "
"рівня SSL (замість використання механізму автентифікації вищого рівня), вам "
"також доведеться вказати :const:`CERT_REQUIRED` і так само перевірити "
"сертифікат клієнта."

#: ../../library/ssl.rst:2666
msgid "Protocol versions"
msgstr "Версії протоколу"

#: ../../library/ssl.rst:2668
msgid ""
"SSL versions 2 and 3 are considered insecure and are therefore dangerous to "
"use.  If you want maximum compatibility between clients and servers, it is "
"recommended to use :const:`PROTOCOL_TLS_CLIENT` or :const:"
"`PROTOCOL_TLS_SERVER` as the protocol version. SSLv2 and SSLv3 are disabled "
"by default."
msgstr ""
"SSL версії 2 і 3 вважаються небезпечними, тому їх використання небезпечно. "
"Якщо вам потрібна максимальна сумісність між клієнтами та серверами, "
"рекомендується використовувати :const:`PROTOCOL_TLS_CLIENT` або :const:"
"`PROTOCOL_TLS_SERVER` як версію протоколу. SSLv2 і SSLv3 вимкнено за "
"замовчуванням."

#: ../../library/ssl.rst:2681
msgid ""
"The SSL context created above will only allow TLSv1.2 and later (if "
"supported by your system) connections to a server. :const:"
"`PROTOCOL_TLS_CLIENT` implies certificate validation and hostname checks by "
"default. You have to load certificates into the context."
msgstr ""

#: ../../library/ssl.rst:2688
msgid "Cipher selection"
msgstr "Вибір шифру"

#: ../../library/ssl.rst:2690
msgid ""
"If you have advanced security requirements, fine-tuning of the ciphers "
"enabled when negotiating a SSL session is possible through the :meth:"
"`SSLContext.set_ciphers` method.  Starting from Python 3.2.3, the ssl module "
"disables certain weak ciphers by default, but you may want to further "
"restrict the cipher choice. Be sure to read OpenSSL's documentation about "
"the `cipher list format <https://www.openssl.org/docs/manmaster/man1/ciphers."
"html#CIPHER-LIST-FORMAT>`_. If you want to check which ciphers are enabled "
"by a given cipher list, use :meth:`SSLContext.get_ciphers` or the ``openssl "
"ciphers`` command on your system."
msgstr ""

#: ../../library/ssl.rst:2701
msgid "Multi-processing"
msgstr "Багатопроцесорність"

#: ../../library/ssl.rst:2703
msgid ""
"If using this module as part of a multi-processed application (using, for "
"example the :mod:`multiprocessing` or :mod:`concurrent.futures` modules), be "
"aware that OpenSSL's internal random number generator does not properly "
"handle forked processes.  Applications must change the PRNG state of the "
"parent process if they use any SSL feature with :func:`os.fork`.  Any "
"successful call of :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` or :func:"
"`~ssl.RAND_pseudo_bytes` is sufficient."
msgstr ""
"Якщо ви використовуєте цей модуль як частину багатопроцесорної програми "
"(використовуючи, наприклад, модулі :mod:`multiprocessing` або :mod:"
"`concurrent.futures`), майте на увазі, що внутрішній генератор випадкових "
"чисел OpenSSL не обробляє належним чином роздвоєні процеси . Програми "
"повинні змінити стан PRNG батьківського процесу, якщо вони використовують "
"будь-яку функцію SSL із :func:`os.fork`. Достатньо будь-якого успішного "
"виклику :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` або :func:`~ssl."
"RAND_pseudo_bytes`."

#: ../../library/ssl.rst:2715
msgid "TLS 1.3"
msgstr "TLS 1.3"

#: ../../library/ssl.rst:2719
msgid ""
"Python has provisional and experimental support for TLS 1.3 with OpenSSL "
"1.1.1.  The new protocol behaves slightly differently than previous version "
"of TLS/SSL.  Some new TLS 1.3 features are not yet available."
msgstr ""

#: ../../library/ssl.rst:2723
msgid ""
"TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and ChaCha20 "
"cipher suites are enabled by default.  The method :meth:`SSLContext."
"set_ciphers` cannot enable or disable any TLS 1.3 ciphers yet, but :meth:"
"`SSLContext.get_ciphers` returns them."
msgstr ""
"TLS 1.3 використовує диз’юнктний набір наборів шифрів. Усі набори шифрів AES-"
"GCM і ChaCha20 увімкнено за замовчуванням. Метод :meth:`SSLContext."
"set_ciphers` ще не може ввімкнути чи вимкнути будь-які шифри TLS 1.3, але :"
"meth:`SSLContext.get_ciphers` повертає їх."

#: ../../library/ssl.rst:2727
msgid ""
"Session tickets are no longer sent as part of the initial handshake and are "
"handled differently.  :attr:`SSLSocket.session` and :class:`SSLSession` are "
"not compatible with TLS 1.3."
msgstr ""
"Заявки на сеанс більше не надсилаються як частина початкового рукостискання "
"та обробляються інакше. :attr:`SSLSocket.session` і :class:`SSLSession` "
"несумісні з TLS 1.3."

#: ../../library/ssl.rst:2730
msgid ""
"Client-side certificates are also no longer verified during the initial "
"handshake.  A server can request a certificate at any time.  Clients process "
"certificate requests while they send or receive application data from the "
"server."
msgstr ""
"Клієнтські сертифікати також більше не перевіряються під час початкового "
"рукостискання. Сервер може запитати сертифікат у будь-який час. Клієнти "
"обробляють запити на сертифікати, коли вони надсилають або отримують дані "
"програми з сервера."

#: ../../library/ssl.rst:2734
msgid ""
"TLS 1.3 features like early data, deferred TLS client cert request, "
"signature algorithm configuration, and rekeying are not supported yet."
msgstr ""
"Такі функції TLS 1.3, як ранні дані, відкладений запит на сертифікат клієнта "
"TLS, конфігурація алгоритму підпису та повторне введення ключів, ще не "
"підтримуються."

#: ../../library/ssl.rst:2741
msgid "LibreSSL support"
msgstr ""

#: ../../library/ssl.rst:2743
msgid ""
"LibreSSL is a fork of OpenSSL 1.0.1. The ssl module has limited support for "
"LibreSSL. Some features are not available when the ssl module is compiled "
"with LibreSSL."
msgstr ""

#: ../../library/ssl.rst:2747
msgid ""
"LibreSSL >= 2.6.1 no longer supports NPN. The methods :meth:`SSLContext."
"set_npn_protocols` and :meth:`SSLSocket.selected_npn_protocol` are not "
"available."
msgstr ""

#: ../../library/ssl.rst:2750
msgid ""
":meth:`SSLContext.set_default_verify_paths` ignores the env vars :envvar:"
"`SSL_CERT_FILE` and :envvar:`SSL_CERT_PATH` although :func:"
"`get_default_verify_paths` still reports them."
msgstr ""

#: ../../library/ssl.rst:2758
msgid "Class :class:`socket.socket`"
msgstr "Клас :class:`socket.socket`"

#: ../../library/ssl.rst:2758
msgid "Documentation of underlying :mod:`socket` class"
msgstr "Документація основного класу :mod:`socket`"

#: ../../library/ssl.rst:2761
msgid ""
"`SSL/TLS Strong Encryption: An Introduction <https://httpd.apache.org/docs/"
"trunk/en/ssl/ssl_intro.html>`_"
msgstr ""
"`Надійне шифрування SSL/TLS: Вступ <https://httpd.apache.org/docs/trunk/en/"
"ssl/ssl_intro.html>`_"

#: ../../library/ssl.rst:2761
msgid "Intro from the Apache HTTP Server documentation"
msgstr "Введення з документації Apache HTTP Server"

#: ../../library/ssl.rst:2764
msgid ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <1422>`"
msgstr ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <1422>`"

#: ../../library/ssl.rst:2764
msgid "Steve Kent"
msgstr "Стів Кент"

#: ../../library/ssl.rst:2767
msgid ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"
msgstr ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"

#: ../../library/ssl.rst:2767
msgid "Donald E., Jeffrey I. Schiller"
msgstr "Дональд Е., Джеффрі І. Шиллер"

#: ../../library/ssl.rst:2770
msgid ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"
msgstr ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"

#: ../../library/ssl.rst:2770
msgid "D. Cooper"
msgstr "Д. Купер"

#: ../../library/ssl.rst:2773
msgid ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"
msgstr ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"

#: ../../library/ssl.rst:2773
msgid "T. Dierks et. al."
msgstr "T. Dierks et. al."

#: ../../library/ssl.rst:2776
msgid ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"
msgstr ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"

#: ../../library/ssl.rst:2776
msgid "D. Eastlake"
msgstr "Д. Істлейк"

#: ../../library/ssl.rst:2779
msgid ""
"`IANA TLS: Transport Layer Security (TLS) Parameters <https://www.iana.org/"
"assignments/tls-parameters/tls-parameters.xml>`_"
msgstr ""
"`IANA TLS: Параметри безпеки транспортного рівня (TLS) <https://www.iana.org/"
"assignments/tls-parameters/tls-parameters.xml>`_"

#: ../../library/ssl.rst:2779
msgid "IANA"
msgstr "IANA"

#: ../../library/ssl.rst:2782
msgid ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer Security "
"(TLS) and Datagram Transport Layer Security (DTLS) <7525>`"
msgstr ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer Security "
"(TLS) and Datagram Transport Layer Security (DTLS) <7525>`"

#: ../../library/ssl.rst:2782
msgid "IETF"
msgstr "IETF"

#: ../../library/ssl.rst:2784
msgid ""
"`Mozilla's Server Side TLS recommendations <https://wiki.mozilla.org/"
"Security/Server_Side_TLS>`_"
msgstr ""
"`Рекомендації TLS на стороні сервера Mozilla <https://wiki.mozilla.org/"
"Security/Server_Side_TLS>`_"

#: ../../library/ssl.rst:2785
msgid "Mozilla"
msgstr "Mozilla"

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2021
# i17obot <i17obot@rougeth.com>, 2021
# Marco Rougeth <marco@rougeth.com>, 2023
# Pedro Fonini, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-04 14:18+0000\n"
"PO-Revision-Date: 2021-06-28 00:56+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/cmath.rst:2
msgid ":mod:`!cmath` --- Mathematical functions for complex numbers"
msgstr ":mod:`!cmath` --- Funções matemáticas para números complexos"

#: ../../library/cmath.rst:9
msgid ""
"This module provides access to mathematical functions for complex numbers.  "
"The functions in this module accept integers, floating-point numbers or "
"complex numbers as arguments. They will also accept any Python object that "
"has either a :meth:`~object.__complex__` or a :meth:`~object.__float__` "
"method: these methods are used to convert the object to a complex or "
"floating-point number, respectively, and the function is then applied to the "
"result of the conversion."
msgstr ""
"Este módulo fornece acesso a funções matemáticas para números complexos. As "
"funções neste módulo aceitam inteiros, números de ponto flutuante ou números "
"complexos como argumentos. Eles também aceitarão qualquer objeto Python que "
"tenha um método :meth:`~object.__complex__` ou :meth:`~object.__float__`: "
"esses métodos são usados para converter o objeto em um número complexo ou de "
"ponto flutuante, respectivamente, e a função é então aplicada ao resultado "
"da conversão."

#: ../../library/cmath.rst:18
msgid ""
"For functions involving branch cuts, we have the problem of deciding how to "
"define those functions on the cut itself. Following Kahan's \"Branch cuts "
"for complex elementary functions\" paper, as well as Annex G of C99 and "
"later C standards, we use the sign of zero to distinguish one side of the "
"branch cut from the other: for a branch cut along (a portion of) the real "
"axis we look at the sign of the imaginary part, while for a branch cut along "
"the imaginary axis we look at the sign of the real part."
msgstr ""
"Para funções que envolvem cortes de ramificação, temos o problema de decidir "
"como definir essas funções no próprio corte. Seguindo o artigo de Kahan "
"intitulado \"Branch cuts for complex elementary functions\" (em tradução "
"livre, \"Cortes de ramificação para funções complexas elementares\"), bem "
"como o Anexo G do C99 e padrões C posteriores, usamos o sinal de zero para "
"distinguir um lado do outro no corte de ramificação: para um corte de "
"ramificação ao longo (de uma porção) do eixo real olhamos para o sinal da "
"parte imaginária, enquanto para um corte de ramificação ao longo do eixo "
"imaginário olhamos para o sinal da parte real."

#: ../../library/cmath.rst:26
msgid ""
"For example, the :func:`cmath.sqrt` function has a branch cut along the "
"negative real axis. An argument of ``complex(-2.0, -0.0)`` is treated as "
"though it lies *below* the branch cut, and so gives a result on the negative "
"imaginary axis::"
msgstr ""
"Por exemplo, a função :func:`cmath.sqrt` tem um corte de ramificação ao "
"longo do eixo real negativo. Um argumento de ``complex(-2.0, -0.0)`` é "
"tratado como se estivesse *abaixo* do corte de ramificação, e assim dá um "
"resultado no eixo imaginário negativo::"

#: ../../library/cmath.rst:31
msgid ""
">>> cmath.sqrt(complex(-2.0, -0.0))\n"
"-1.4142135623730951j"
msgstr ""
">>> cmath.sqrt(complex(-2.0, -0.0))\n"
"-1.4142135623730951j"

#: ../../library/cmath.rst:34
msgid ""
"But an argument of ``complex(-2.0, 0.0)`` is treated as though it lies above "
"the branch cut::"
msgstr ""
"Mas um argumento de ``complex(-2.0, 0.0)`` é tratado como se estivesse acima "
"do corte de ramificação::"

#: ../../library/cmath.rst:37
msgid ""
">>> cmath.sqrt(complex(-2.0, 0.0))\n"
"1.4142135623730951j"
msgstr ""
">>> cmath.sqrt(complex(-2.0, 0.0))\n"
"1.4142135623730951j"

#: ../../library/cmath.rst:42
msgid "Conversions to and from polar coordinates"
msgstr "Conversões de e para coordenadas polares"

#: ../../library/cmath.rst:44
msgid ""
"A Python complex number ``z`` is stored internally using *rectangular* or "
"*Cartesian* coordinates.  It is completely determined by its *real part* ``z."
"real`` and its *imaginary part* ``z.imag``."
msgstr ""
"Um número complexo Python ``z`` é armazenado internamente usando coordenadas "
"*retangulares* ou *cartesianas*. É completamente determinado por sua *parte "
"real* ``z.real`` e sua *parte imaginária* ``z.imag``."

#: ../../library/cmath.rst:48
msgid ""
"*Polar coordinates* give an alternative way to represent a complex number.  "
"In polar coordinates, a complex number *z* is defined by the modulus *r* and "
"the phase angle *phi*. The modulus *r* is the distance from *z* to the "
"origin, while the phase *phi* is the counterclockwise angle, measured in "
"radians, from the positive x-axis to the line segment that joins the origin "
"to *z*."
msgstr ""
"*Coordenadas polares* fornecem uma forma alternativa de representar um "
"número complexo. Em coordenadas polares, um número complexo *z* é definido "
"pelo módulo *r* e pelo ângulo de fase *phi*. O módulo *r* é a distância de "
"*z* à origem, enquanto a fase *phi* é o ângulo anti-horário, medido em "
"radianos, do eixo x positivo ao segmento de reta que une a origem a *z*."

#: ../../library/cmath.rst:55
msgid ""
"The following functions can be used to convert from the native rectangular "
"coordinates to polar coordinates and back."
msgstr ""
"As funções a seguir podem ser usadas para converter coordenadas retangulares "
"nativas em coordenadas polares e vice-versa."

#: ../../library/cmath.rst:60
msgid ""
"Return the phase of *z* (also known as the *argument* of *z*), as a float. "
"``phase(z)`` is equivalent to ``math.atan2(z.imag, z.real)``.  The result "
"lies in the range [-\\ *π*, *π*], and the branch cut for this operation lies "
"along the negative real axis.  The sign of the result is the same as the "
"sign of ``z.imag``, even when ``z.imag`` is zero::"
msgstr ""

#: ../../library/cmath.rst:66
msgid ""
">>> phase(complex(-1.0, 0.0))\n"
"3.141592653589793\n"
">>> phase(complex(-1.0, -0.0))\n"
"-3.141592653589793"
msgstr ""
">>> phase(complex(-1.0, 0.0))\n"
"3.141592653589793\n"
">>> phase(complex(-1.0, -0.0))\n"
"-3.141592653589793"

#: ../../library/cmath.rst:74
msgid ""
"The modulus (absolute value) of a complex number *z* can be computed using "
"the built-in :func:`abs` function.  There is no separate :mod:`cmath` module "
"function for this operation."
msgstr ""

#: ../../library/cmath.rst:81
msgid ""
"Return the representation of *z* in polar coordinates.  Returns a pair ``(r, "
"phi)`` where *r* is the modulus of *z* and *phi* is the phase of *z*.  "
"``polar(z)`` is equivalent to ``(abs(z), phase(z))``."
msgstr ""

#: ../../library/cmath.rst:89
msgid ""
"Return the complex number *z* with polar coordinates *r* and *phi*. "
"Equivalent to ``complex(r * math.cos(phi), r * math.sin(phi))``."
msgstr ""

#: ../../library/cmath.rst:94
msgid "Power and logarithmic functions"
msgstr "Funções de potência e logarítmicas"

#: ../../library/cmath.rst:98
msgid ""
"Return *e* raised to the power *z*, where *e* is the base of natural "
"logarithms."
msgstr ""

#: ../../library/cmath.rst:104
msgid ""
"Return the logarithm of *z* to the given *base*. If the *base* is not "
"specified, returns the natural logarithm of *z*. There is one branch cut, "
"from 0 along the negative real axis to -∞."
msgstr ""

#: ../../library/cmath.rst:111
msgid ""
"Return the base-10 logarithm of *z*. This has the same branch cut as :func:"
"`log`."
msgstr ""

#: ../../library/cmath.rst:117
msgid ""
"Return the square root of *z*. This has the same branch cut as :func:`log`."
msgstr ""

#: ../../library/cmath.rst:121
msgid "Trigonometric functions"
msgstr "Funções trigonométricas"

#: ../../library/cmath.rst:125
msgid ""
"Return the arc cosine of *z*. There are two branch cuts: One extends right "
"from 1 along the real axis to ∞. The other extends left from -1 along the "
"real axis to -∞."
msgstr ""

#: ../../library/cmath.rst:132
msgid ""
"Return the arc sine of *z*. This has the same branch cuts as :func:`acos`."
msgstr ""

#: ../../library/cmath.rst:137
msgid ""
"Return the arc tangent of *z*. There are two branch cuts: One extends from "
"``1j`` along the imaginary axis to ``∞j``. The other extends from ``-1j`` "
"along the imaginary axis to ``-∞j``."
msgstr ""

#: ../../library/cmath.rst:144
msgid "Return the cosine of *z*."
msgstr ""

#: ../../library/cmath.rst:149
msgid "Return the sine of *z*."
msgstr ""

#: ../../library/cmath.rst:154
msgid "Return the tangent of *z*."
msgstr ""

#: ../../library/cmath.rst:158
msgid "Hyperbolic functions"
msgstr "Funções hiperbólicas"

#: ../../library/cmath.rst:162
msgid ""
"Return the inverse hyperbolic cosine of *z*. There is one branch cut, "
"extending left from 1 along the real axis to -∞."
msgstr ""

#: ../../library/cmath.rst:168
msgid ""
"Return the inverse hyperbolic sine of *z*. There are two branch cuts: One "
"extends from ``1j`` along the imaginary axis to ``∞j``.  The other extends "
"from ``-1j`` along the imaginary axis to ``-∞j``."
msgstr ""

#: ../../library/cmath.rst:175
msgid ""
"Return the inverse hyperbolic tangent of *z*. There are two branch cuts: One "
"extends from ``1`` along the real axis to ``∞``. The other extends from "
"``-1`` along the real axis to ``-∞``."
msgstr ""

#: ../../library/cmath.rst:182
msgid "Return the hyperbolic cosine of *z*."
msgstr ""

#: ../../library/cmath.rst:187
msgid "Return the hyperbolic sine of *z*."
msgstr ""

#: ../../library/cmath.rst:192
msgid "Return the hyperbolic tangent of *z*."
msgstr ""

#: ../../library/cmath.rst:196
msgid "Classification functions"
msgstr "Funções de classificação"

#: ../../library/cmath.rst:200
msgid ""
"Return ``True`` if both the real and imaginary parts of *z* are finite, and "
"``False`` otherwise."
msgstr ""

#: ../../library/cmath.rst:208
msgid ""
"Return ``True`` if either the real or the imaginary part of *z* is an "
"infinity, and ``False`` otherwise."
msgstr ""

#: ../../library/cmath.rst:214
msgid ""
"Return ``True`` if either the real or the imaginary part of *z* is a NaN, "
"and ``False`` otherwise."
msgstr ""

#: ../../library/cmath.rst:220
msgid ""
"Return ``True`` if the values *a* and *b* are close to each other and "
"``False`` otherwise."
msgstr ""
"Retorna ``True`` se os valores *a* e *b* estiverem próximos e ``False`` caso "
"contrário."

#: ../../library/cmath.rst:223
msgid ""
"Whether or not two values are considered close is determined according to "
"given absolute and relative tolerances.  If no errors occur, the result will "
"be: ``abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)``."
msgstr ""
"Se dois valores são considerados próximos ou não é determinado de acordo com "
"tolerâncias absolutas e relativas fornecidas. Se nenhum erro ocorrer, o "
"resultado será: ``abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)``."

#: ../../library/cmath.rst:227
msgid ""
"*rel_tol* is the relative tolerance -- it is the maximum allowed difference "
"between *a* and *b*, relative to the larger absolute value of *a* or *b*. "
"For example, to set a tolerance of 5%, pass ``rel_tol=0.05``.  The default "
"tolerance is ``1e-09``, which assures that the two values are the same "
"within about 9 decimal digits.  *rel_tol* must be nonnegative and less than "
"``1.0``."
msgstr ""
"*rel_tol* é a tolerância relativa -- é a diferença máxima permitida entre "
"*a* e *b*, em relação ao maior valor absoluto de *a* ou *b*. Por exemplo, "
"para definir uma tolerância de 5%, passe ``rel_tol=0.05``. A tolerância "
"padrão é ``1e-09``, o que garante que os dois valores sejam iguais em cerca "
"de 9 dígitos decimais. *rel_tol* deve ser não negativo e menor que ``1.0``."

#: ../../library/cmath.rst:234
msgid ""
"*abs_tol* is the absolute tolerance; it defaults to ``0.0`` and it must be "
"nonnegative.  When comparing ``x`` to ``0.0``, ``isclose(x, 0)`` is computed "
"as ``abs(x) <= rel_tol  * abs(x)``, which is ``False`` for any ``x`` and "
"rel_tol less than ``1.0``.  So add an appropriate positive abs_tol argument "
"to the call."
msgstr ""
"*abs_tol* é a tolerância absoluta; o padrão é ``0.0`` e deve ser não "
"negativo. Ao comparar ``x`` com ``0.0``, ``isclose(x, 0)`` é computado como "
"``abs(x) <= rel_tol * abs(x)``, que é ``False`` para qualquer ``x`` e "
"rel_tol menor que ``1.0``. Então adicione um argumento abs_tol positivo "
"apropriado à chamada."

#: ../../library/cmath.rst:240
msgid ""
"The IEEE 754 special values of ``NaN``, ``inf``, and ``-inf`` will be "
"handled according to IEEE rules.  Specifically, ``NaN`` is not considered "
"close to any other value, including ``NaN``.  ``inf`` and ``-inf`` are only "
"considered close to themselves."
msgstr ""
"Os valores especiais do IEEE 754 de ``NaN``, ``inf`` e ``-inf`` serão "
"tratados de acordo com as regras do IEEE. Especificamente, ``NaN`` não é "
"considerado próximo a qualquer outro valor, incluindo ``NaN``. ``inf`` e ``-"
"inf`` são considerados apenas próximos a si mesmos."

#: ../../library/cmath.rst:249
msgid ":pep:`485` -- A function for testing approximate equality"
msgstr ":pep:`485` -- Uma função para testar igualdade aproximada"

#: ../../library/cmath.rst:253
msgid "Constants"
msgstr "Constantes"

#: ../../library/cmath.rst:257
msgid "The mathematical constant *π*, as a float."
msgstr "A constante matemática *π*, como um ponto flutuante."

#: ../../library/cmath.rst:262
msgid "The mathematical constant *e*, as a float."
msgstr "A constante matemática *e*, como um ponto flutuante."

#: ../../library/cmath.rst:267
msgid "The mathematical constant *τ*, as a float."
msgstr "A constante matemática *τ*, como um ponto flutuante."

#: ../../library/cmath.rst:274
msgid "Floating-point positive infinity. Equivalent to ``float('inf')``."
msgstr "Infinito positivo de ponto flutuante. Equivalente a ``float('inf')``."

#: ../../library/cmath.rst:281
msgid ""
"Complex number with zero real part and positive infinity imaginary part. "
"Equivalent to ``complex(0.0, float('inf'))``."
msgstr ""
"Número complexo com parte real zero e parte imaginária infinita positiva. "
"Equivalente a ``complex(0.0, float('inf'))``."

#: ../../library/cmath.rst:289
msgid ""
"A floating-point \"not a number\" (NaN) value.  Equivalent to "
"``float('nan')``."
msgstr ""
"Um valor de ponto flutuante \"não um número\" (NaN). Equivalente a "
"``float('nan')``."

#: ../../library/cmath.rst:297
msgid ""
"Complex number with zero real part and NaN imaginary part. Equivalent to "
"``complex(0.0, float('nan'))``."
msgstr ""
"Número complexo com parte real zero e parte imaginária NaN. Equivalente a "
"``complex(0.0, float('nan'))``."

#: ../../library/cmath.rst:305
msgid ""
"Note that the selection of functions is similar, but not identical, to that "
"in module :mod:`math`.  The reason for having two modules is that some users "
"aren't interested in complex numbers, and perhaps don't even know what they "
"are.  They would rather have ``math.sqrt(-1)`` raise an exception than "
"return a complex number. Also note that the functions defined in :mod:"
"`cmath` always return a complex number, even if the answer can be expressed "
"as a real number (in which case the complex number has an imaginary part of "
"zero)."
msgstr ""
"Observe que a seleção de funções é semelhante, mas não idêntica, àquela no "
"módulo :mod:`math`. A razão para ter dois módulos é que alguns usuários não "
"estão interessados em números complexos e talvez nem saibam o que são. Eles "
"preferem que ``math.sqrt(-1)`` gere uma exceção do que retorne um número "
"complexo. Observe também que as funções definidas em :mod:`cmath` sempre "
"retornam um número complexo, mesmo que a resposta possa ser expressa como um "
"número real (nesse caso o número complexo tem uma parte imaginária de zero)."

#: ../../library/cmath.rst:313
msgid ""
"A note on branch cuts: They are curves along which the given function fails "
"to be continuous.  They are a necessary feature of many complex functions.  "
"It is assumed that if you need to compute with complex functions, you will "
"understand about branch cuts.  Consult almost any (not too elementary) book "
"on complex variables for enlightenment.  For information of the proper "
"choice of branch cuts for numerical purposes, a good reference should be the "
"following:"
msgstr ""
"Uma nota sobre cortes de ramificação: são curvas ao longo das quais a função "
"dada não é contínua. Eles são um recurso necessário de muitas funções "
"complexas. Presume-se que se você precisar calcular com funções complexas, "
"você entenderá sobre cortes de ramificação. Consulte quase qualquer livro "
"(não muito elementar) sobre variáveis complexas para obter esclarecimento. "
"Para informações sobre a escolha adequada dos cortes de ramificação para "
"fins numéricos, uma boa referência deve ser a seguinte:"

#: ../../library/cmath.rst:323
msgid ""
"Kahan, W:  Branch cuts for complex elementary functions; or, Much ado about "
"nothing's sign bit.  In Iserles, A., and Powell, M. (eds.), The state of the "
"art in numerical analysis. Clarendon Press (1987) pp165--211."
msgstr ""
"Kahan, W:  Branch cuts for complex elementary functions; or, Much ado about "
"nothing's sign bit.  Em Iserles, A. e Powell, M. (eds.), The state of the "
"art in numerical analysis. Clarendon Press (1987) pp165--211."

#: ../../library/cmath.rst:303
msgid "module"
msgstr "módulo"

#: ../../library/cmath.rst:303
msgid "math"
msgstr "math"

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Matheus Sartor, 2022
# Marco Rougeth <marco@rougeth.com>, 2024
# i17obot <i17obot@rougeth.com>, 2024
# (Douglas da Silva) <dementikovalev@yandex.ru>, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-22 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 01:10+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/multiprocessing.shared_memory.rst:2
msgid ""
":mod:`!multiprocessing.shared_memory` --- Shared memory for direct access "
"across processes"
msgstr ""
":mod:`!multiprocessing.shared_memory` --- Memória compartilhada para acesso "
"direto entre processos"

#: ../../library/multiprocessing.shared_memory.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/shared_memory.py`"
msgstr "**Código-fonte:** :source:`Lib/multiprocessing/shared_memory.py`"

#: ../../library/multiprocessing.shared_memory.rst:18
msgid ""
"This module provides a class, :class:`SharedMemory`, for the allocation and "
"management of shared memory to be accessed by one or more processes on a "
"multicore or symmetric multiprocessor (SMP) machine.  To assist with the "
"life-cycle management of shared memory especially across distinct processes, "
"a :class:`~multiprocessing.managers.BaseManager` subclass, :class:"
"`~multiprocessing.managers.SharedMemoryManager`, is also provided in the :"
"mod:`multiprocessing.managers` module."
msgstr ""
"Este módulo fornece uma classe, :class:`SharedMemory`, para a alocação e "
"gerenciamento da memória compartilhada a ser acessada por um ou mais "
"processos em uma máquina multicore ou de multiprocessamento simétrico (SMP). "
"Para ajudar com o gerenciamento do ciclo de vida da memória compartilhada "
"especialmente entre processos distintos, uma subclasse de :class:"
"`~multiprocessing.managers.BaseManager`, :class:`~multiprocessing.managers."
"SharedMemoryManager`, também é fornecida no módulo :mod:`multiprocessing."
"managers`."

#: ../../library/multiprocessing.shared_memory.rst:26
msgid ""
"In this module, shared memory refers to \"POSIX style\" shared memory blocks "
"(though is not necessarily implemented explicitly as such) and does not "
"refer to \"distributed shared memory\".  This style of shared memory permits "
"distinct processes to potentially read and write to a common (or shared) "
"region of volatile memory.  Processes are conventionally limited to only "
"have access to their own process memory space but shared memory permits the "
"sharing of data between processes, avoiding the need to instead send "
"messages between processes containing that data.  Sharing data directly via "
"memory can provide significant performance benefits compared to sharing data "
"via disk or socket or other communications requiring the serialization/"
"deserialization and copying of data."
msgstr ""
"Neste módulo, memória compartilhada refere-se a blocos de memória "
"compartilhada no \"estilo POSIX\" (embora não seja necessariamente "
"implementado explicitamente como tal) e não se refere a \"memória "
"compartilhada distribuída\". Este estilo de memória compartilhada permite "
"que processos distintos potencialmente leiam e escrevam em uma região comum "
"(ou compartilhada) de memória volátil. Os processos são convencionalmente "
"limitados a ter acesso somente ao próprio espaço de memória de processo mas "
"a memória compartilhada permite o compartilhamento de dados entre processos, "
"evitando a necessidade de enviar mensagens entre processos contendo estes "
"dados. Compartilhar dados diretamente via memória pode fornecer ganhos de "
"desempenho significativos comparado ao compartilhamento de dados via disco "
"ou soquete ou outras comunicações que requerem a serialização/"
"desserialização e cópia dos dados."

#: ../../library/multiprocessing.shared_memory.rst:41
msgid ""
"Create an instance of the :class:`!SharedMemory` class for either creating a "
"new shared memory block or attaching to an existing shared memory block.  "
"Each shared memory block is assigned a unique name. In this way, one process "
"can create a shared memory block with a particular name and a different "
"process can attach to that same shared memory block using that same name."
msgstr ""
"Cria uma instância da classe :class:`!SharedMemory` para criar um novo bloco "
"de memória compartilhada ou anexar a um bloco de memória compartilhada "
"existente. A cada bloco de memória compartilhada é atribuído um nome único. "
"Desta forma, um processo pode criar um bloco de memória compartilhada com um "
"nome particular e um processo diferente pode ser anexado a esse mesmo bloco "
"de memória compartilhada usando este mesmo nome."

#: ../../library/multiprocessing.shared_memory.rst:48
msgid ""
"As a resource for sharing data across processes, shared memory blocks may "
"outlive the original process that created them.  When one process no longer "
"needs access to a shared memory block that might still be needed by other "
"processes, the :meth:`close` method should be called. When a shared memory "
"block is no longer needed by any process, the :meth:`unlink` method should "
"be called to ensure proper cleanup."
msgstr ""
"Como um recurso para compartilhar dados entre processos, os blocos de "
"memória compartilhada podem sobreviver ao processo original que os criou. "
"Quando um processo não precisa mais acessar um bloco de memória "
"compartilhada que ainda pode ser necessário para outros processos, o método :"
"meth:`close` deve ser chamado. Quando um bloco de memória compartilhada não "
"é mais necessário para nenhum processo, o método :meth:`unlink` deve ser "
"chamado para garantir a limpeza apropriada."

#: ../../library/multiprocessing.shared_memory.rst:0
msgid "Parameters"
msgstr "Parâmetros"

#: ../../library/multiprocessing.shared_memory.rst:55
msgid ""
"The unique name for the requested shared memory, specified as a string. When "
"creating a new shared memory block, if ``None`` (the default) is supplied "
"for the name, a novel name will be generated."
msgstr ""
"O nome único para a memória compartilhada requisitada, especificado como uma "
"string. Ao criar um novo bloco de memória compartilhada, se ``None`` (o "
"padrão) é fornecido para o nome, um novo nome será gerado."

#: ../../library/multiprocessing.shared_memory.rst:61
msgid ""
"Control whether a new shared memory block is created (``True``) or an "
"existing shared memory block is attached (``False``)."
msgstr ""
"Controla quando um novo bloco de memória compartilhada é criado (``True``) "
"ou um bloco de memória compartilhada existente é anexado (``False``)."

#: ../../library/multiprocessing.shared_memory.rst:65
msgid ""
"The requested number of bytes when creating a new shared memory block. "
"Because some platforms choose to allocate chunks of memory based upon that "
"platform's memory page size, the exact size of the shared memory block may "
"be larger or equal to the size requested. When attaching to an existing "
"shared memory block, the *size* parameter is ignored."
msgstr ""
"O número de bytes requeridos ao criar um novo bloco de memória "
"compartilhada. Como algumas plataformas optam por alocar pedaços de memória "
"com base no tamanho da página de memória da própria plataforma, o tamanho "
"exato do bloco de memória compartilhada pode ser maior ou igual ao tamanho "
"requerido. Ao anexar a um bloco de memória compartilhada existente, o "
"parâmetro *size* é ignorado."

#: ../../library/multiprocessing.shared_memory.rst:73
msgid ""
"When ``True``, register the shared memory block with a resource tracker "
"process on platforms where the OS does not do this automatically. The "
"resource tracker ensures proper cleanup of the shared memory even if all "
"other processes with access to the memory exit without doing so. Python "
"processes created from a common ancestor using :mod:`multiprocessing` "
"facilities share a single resource tracker process, and the lifetime of "
"shared memory segments is handled automatically among these processes. "
"Python processes created in any other way will receive their own resource "
"tracker when accessing shared memory with *track* enabled. This will cause "
"the shared memory to be deleted by the resource tracker of the first process "
"that terminates. To avoid this issue, users of :mod:`subprocess` or "
"standalone Python processes should set *track* to ``False`` when there is "
"already another process in place that does the bookkeeping. *track* is "
"ignored on Windows, which has its own tracking and automatically deletes "
"shared memory when all handles to it have been closed."
msgstr ""
"Quando ``True``, registra o bloco de memória compartilhada com um processo "
"de rastreador de recursos em plataformas onde o sistema operacional não faz "
"isso automaticamente. O rastreador de recursos garante a limpeza adequada da "
"memória compartilhada, mesmo se todos os outros processos com acesso à "
"memória saírem sem fazer isso. Os processos Python criados a partir de um "
"ancestral comum usando os recursos de :mod:`multiprocessing` compartilham um "
"único processo de rastreador de recursos, e o tempo de vida dos segmentos de "
"memória compartilhada é manipulado automaticamente entre esses processos. Os "
"processos Python criados de qualquer outra forma receberão seu próprio "
"rastreador de recursos ao acessar a memória compartilhada com *track* "
"habilitado. Isso fará com que a memória compartilhada seja excluída pelo "
"rastreador de recursos do primeiro processo que terminar. Para evitar esse "
"problema, os usuários de :mod:`subprocess` ou processos Python autônomos "
"devem definir *track* como ``False`` quando já houver outro processo em "
"vigor que faça a contabilidade. *track* é ignorado no Windows, que tem seu "
"próprio rastreamento e exclui automaticamente a memória compartilhada quando "
"todos os identificadores para ele foram fechados."

#: ../../library/multiprocessing.shared_memory.rst:91
msgid "Added the *track* parameter."
msgstr "Adicionado o parâmetro *track*."

#: ../../library/multiprocessing.shared_memory.rst:96
msgid ""
"Close the file descriptor/handle to the shared memory from this instance.  :"
"meth:`close` should be called once access to the shared memory block from "
"this instance is no longer needed.  Depending on operating system, the "
"underlying memory may or may not be freed even if all handles to it have "
"been closed.  To ensure proper cleanup, use the :meth:`unlink` method."
msgstr ""
"Fecha o identificador/descritor de arquivo para a memória compartilhada "
"desta instância. :meth:`close` deve ser chamado quando o acesso ao bloco de "
"memória compartilhada desta instância não for mais necessário. Dependendo do "
"sistema operacional, a memória subjacente pode ou não ser liberada, mesmo "
"que todos os identificadores para ela tenham sido fechados. Para garantir "
"uma limpeza adequada, use o método :meth:`unlink`."

#: ../../library/multiprocessing.shared_memory.rst:105
msgid ""
"Delete the underlying shared memory block.  This should be called only once "
"per shared memory block regardless of the number of handles to it, even in "
"other processes. :meth:`unlink` and :meth:`close` can be called in any "
"order, but trying to access data inside a shared memory block after :meth:"
"`unlink` may result in memory access errors, depending on platform."
msgstr ""
"Exclui o bloco de memória compartilhada subjacente. Isso deve ser chamado "
"apenas uma vez por bloco de memória compartilhada, independentemente do "
"número de handles para ele, mesmo em outros processos. :meth:`unlink` e :"
"meth:`close` podem ser chamados em qualquer ordem, mas tentar acessar dados "
"dentro de um bloco de memória compartilhada após :meth:`unlink` pode "
"resultar em erros de acesso à memória, dependendo da plataforma."

#: ../../library/multiprocessing.shared_memory.rst:112
msgid ""
"This method has no effect on Windows, where the only way to delete a shared "
"memory block is to close all handles."
msgstr ""
"Este método não tem efeito no Windows, onde a única maneira de excluir um "
"bloco de memória compartilhada é fechar todos os identificadores."

#: ../../library/multiprocessing.shared_memory.rst:117
msgid "A memoryview of contents of the shared memory block."
msgstr ""
"Uma visualização de memória do conteúdo do bloco de memória compartilhada."

#: ../../library/multiprocessing.shared_memory.rst:121
msgid "Read-only access to the unique name of the shared memory block."
msgstr ""
"Acesso somente leitura ao nome único do bloco de memória compartilhada."

#: ../../library/multiprocessing.shared_memory.rst:125
msgid "Read-only access to size in bytes of the shared memory block."
msgstr ""
"Acesso somente leitura ao tamanho em bytes do bloco de memória compartilhada."

#: ../../library/multiprocessing.shared_memory.rst:128
msgid ""
"The following example demonstrates low-level use of :class:`SharedMemory` "
"instances::"
msgstr ""
"O exemplo a seguir demonstra um uso baixo nível de instâncias de :class:"
"`SharedMemory`::"

#: ../../library/multiprocessing.shared_memory.rst:131
msgid ""
">>> from multiprocessing import shared_memory\n"
">>> shm_a = shared_memory.SharedMemory(create=True, size=10)\n"
">>> type(shm_a.buf)\n"
"<class 'memoryview'>\n"
">>> buffer = shm_a.buf\n"
">>> len(buffer)\n"
"10\n"
">>> buffer[:4] = bytearray([22, 33, 44, 55])  # Modify multiple at once\n"
">>> buffer[4] = 100                           # Modify single byte at a "
"time\n"
">>> # Attach to an existing shared memory block\n"
">>> shm_b = shared_memory.SharedMemory(shm_a.name)\n"
">>> import array\n"
">>> array.array('b', shm_b.buf[:5])  # Copy the data into a new array.array\n"
"array('b', [22, 33, 44, 55, 100])\n"
">>> shm_b.buf[:5] = b'howdy'  # Modify via shm_b using bytes\n"
">>> bytes(shm_a.buf[:5])      # Access via shm_a\n"
"b'howdy'\n"
">>> shm_b.close()   # Close each SharedMemory instance\n"
">>> shm_a.close()\n"
">>> shm_a.unlink()  # Call unlink only once to release the shared memory"
msgstr ""
">>> from multiprocessing import shared_memory\n"
">>> shm_a = shared_memory.SharedMemory(create=True, size=10)\n"
">>> type(shm_a.buf)\n"
"<class 'memoryview'>\n"
">>> buffer = shm_a.buf\n"
">>> len(buffer)\n"
"10\n"
">>> buffer[:4] = bytearray([22, 33, 44, 55])  # Modifica vários de uma só "
"vez\n"
">>> buffer[4] = 100                           # Modifica um único byte de "
"cada vez\n"
">>> # Anexa a um bloco de memória compartilhada existente\n"
">>> shm_b = shared_memory.SharedMemory(shm_a.name)\n"
">>> import array\n"
">>> array.array('b', shm_b.buf[:5])  # Copia os dados para um novo array."
"array\n"
"array('b', [22, 33, 44, 55, 100])\n"
">>> shm_b.buf[:5] = b'howdy'  # Modifica via shm_b usando bytes\n"
">>> bytes(shm_a.buf[:5])      # Acessa via shm_a\n"
"b'howdy'\n"
">>> shm_b.close()   # Fecha cada instância de SharedMemory\n"
">>> shm_a.close()\n"
">>> shm_a.unlink()  # Chama unlink uma vez para liberar a memória "
"Compartilhada"

#: ../../library/multiprocessing.shared_memory.rst:154
msgid ""
"The following example demonstrates a practical use of the :class:"
"`SharedMemory` class with `NumPy arrays <https://numpy.org/>`_, accessing "
"the same :class:`!numpy.ndarray` from two distinct Python shells:"
msgstr ""
"O exemplo a seguir demonstra um uso prático da classe :class:`SharedMemory` "
"com `arrays do NumPy <https://numpy.org/>`_, acessando o mesmo :class:`!"
"numpy.ndarray` de dois consoles Python distintos."

#: ../../library/multiprocessing.shared_memory.rst:158
msgid ""
">>> # In the first Python interactive shell\n"
">>> import numpy as np\n"
">>> a = np.array([1, 1, 2, 3, 5, 8])  # Start with an existing NumPy array\n"
">>> from multiprocessing import shared_memory\n"
">>> shm = shared_memory.SharedMemory(create=True, size=a.nbytes)\n"
">>> # Now create a NumPy array backed by shared memory\n"
">>> b = np.ndarray(a.shape, dtype=a.dtype, buffer=shm.buf)\n"
">>> b[:] = a[:]  # Copy the original data into shared memory\n"
">>> b\n"
"array([1, 1, 2, 3, 5, 8])\n"
">>> type(b)\n"
"<class 'numpy.ndarray'>\n"
">>> type(a)\n"
"<class 'numpy.ndarray'>\n"
">>> shm.name  # We did not specify a name so one was chosen for us\n"
"'psm_21467_46075'\n"
"\n"
">>> # In either the same shell or a new Python shell on the same machine\n"
">>> import numpy as np\n"
">>> from multiprocessing import shared_memory\n"
">>> # Attach to the existing shared memory block\n"
">>> existing_shm = shared_memory.SharedMemory(name='psm_21467_46075')\n"
">>> # Note that a.shape is (6,) and a.dtype is np.int64 in this example\n"
">>> c = np.ndarray((6,), dtype=np.int64, buffer=existing_shm.buf)\n"
">>> c\n"
"array([1, 1, 2, 3, 5, 8])\n"
">>> c[-1] = 888\n"
">>> c\n"
"array([  1,   1,   2,   3,   5, 888])\n"
"\n"
">>> # Back in the first Python interactive shell, b reflects this change\n"
">>> b\n"
"array([  1,   1,   2,   3,   5, 888])\n"
"\n"
">>> # Clean up from within the second Python shell\n"
">>> del c  # Unnecessary; merely emphasizing the array is no longer used\n"
">>> existing_shm.close()\n"
"\n"
">>> # Clean up from within the first Python shell\n"
">>> del b  # Unnecessary; merely emphasizing the array is no longer used\n"
">>> shm.close()\n"
">>> shm.unlink()  # Free and release the shared memory block at the very end"
msgstr ""
">>> # No primeiro console interativo do Python\n"
">>> import numpy as np\n"
">>> a = np.array([1, 1, 2, 3, 5, 8])  # Inicia com um array de NumPy "
"existente\n"
">>> from multiprocessing import shared_memory\n"
">>> shm = shared_memory.SharedMemory(create=True, size=a.nbytes)\n"
">>> # Agora cria um array de NumPy suportado por memória compartilhada\n"
">>> b = np.ndarray(a.shape, dtype=a.dtype, buffer=shm.buf)\n"
">>> b[:] = a[:]  # Copia os dados originais para memória compartilhada\n"
">>> b\n"
"array([1, 1, 2, 3, 5, 8])\n"
">>> type(b)\n"
"<class 'numpy.ndarray'>\n"
">>> type(a)\n"
"<class 'numpy.ndarray'>\n"
">>> shm.name  # Não especificamos um nome, então um foi escolhido por nós\n"
"'psm_21467_46075'\n"
"\n"
">>> # No mesmo shell ou em um novo console do Python na mesma máquina\n"
">>> import numpy as np\n"
">>> from multiprocessing import shared_memory\n"
">>> # Anexa ao bloco de memória compartilhada existente\n"
">>> existing_shm = shared_memory.SharedMemory(name='psm_21467_46075')\n"
">>> # Observe que a.shape é (6,) e a.dtype é np.int64 neste exemplo\n"
">>> c = np.ndarray((6,), dtype=np.int64, buffer=existing_shm.buf)\n"
">>> c\n"
"array([1, 1, 2, 3, 5, 8])\n"
">>> c[-1] = 888\n"
">>> c\n"
"array([  1,   1,   2,   3,   5, 888])\n"
"\n"
">>> # De volta ao primeiro console interativo do Python, b reflete essa "
"mudança\n"
">>> b\n"
"array([  1,   1,   2,   3,   5, 888])\n"
"\n"
">>> # Limpeza de dentro do segundo console Python\n"
">>> del c  # Desnecessário; apenas enfatizar a array não é mais usado\n"
">>> existing_shm.close()\n"
"\n"
">>> # Limpeza de dentro do primeiro console Python\n"
">>> del b  # Desnecessário; apenas enfatizar a array não é mais usado\n"
">>> shm.close()\n"
">>> shm.unlink()  # Libera o bloco de memória compartilhada no final"

#: ../../library/multiprocessing.shared_memory.rst:208
msgid ""
"A subclass of :class:`multiprocessing.managers.BaseManager` which can be "
"used for the management of shared memory blocks across processes."
msgstr ""
"Uma subclasse de :class:`multiprocessing.managers.BaseManager` que pode ser "
"usada para o gerenciamento dos blocos de memória compartilhada entre "
"processos."

#: ../../library/multiprocessing.shared_memory.rst:211
msgid ""
"A call to :meth:`~multiprocessing.managers.BaseManager.start` on a :class:`!"
"SharedMemoryManager` instance causes a new process to be started. This new "
"process's sole purpose is to manage the life cycle of all shared memory "
"blocks created through it.  To trigger the release of all shared memory "
"blocks managed by that process, call :meth:`~multiprocessing.managers."
"BaseManager.shutdown` on the instance. This triggers a :meth:"
"`~multiprocessing.shared_memory.SharedMemory.unlink` call on all of the :"
"class:`SharedMemory` objects managed by that process and then stops the "
"process itself.  By creating :class:`!SharedMemory` instances through a :"
"class:`!SharedMemoryManager`, we avoid the need to manually track and "
"trigger the freeing of shared memory resources."
msgstr ""
"Uma chamada ao método :meth:`~multiprocessing.managers.BaseManager.start` em "
"uma instância de :class:`!SharedMemoryManager` faz com que um novo processo "
"seja iniciado. A única finalidade desse novo processo é gerenciar o ciclo de "
"vida de todos os blocos de memória criados através dele. Para acionar a "
"liberação de todos os blocos de memória gerenciados por este processo, "
"invoque o método :meth:`~multiprocessing.managers.BaseManager.shutdown` na "
"instância. Isso aciona uma chamada de :meth:`~multiprocessing.shared_memory."
"SharedMemory.unlink` em todos os objetos :class:`SharedMemory` gerenciados "
"por esse processo e então para o processo em si. Ao criar instâncias de :"
"class:`!SharedMemory` através de um :class:`!SharedMemoryManager`, evitamos "
"a necessidade de rastrear e acionar manualmente a liberação dos recursos de "
"memória compartilhada."

#: ../../library/multiprocessing.shared_memory.rst:223
msgid ""
"This class provides methods for creating and returning :class:`SharedMemory` "
"instances and for creating a list-like object (:class:`ShareableList`) "
"backed by shared memory."
msgstr ""
"Esta classe fornece métodos para criar e retornar instâncias de :class:"
"`SharedMemory` e para criar um objeto lista ou similar (:class:"
"`ShareableList`) apoiado por memória compartilhada."

#: ../../library/multiprocessing.shared_memory.rst:227
msgid ""
"Refer to :class:`~multiprocessing.managers.BaseManager` for a description of "
"the inherited *address* and *authkey* optional input arguments and how they "
"may be used to connect to an existing :class:`!SharedMemoryManager` service "
"from other processes."
msgstr ""
"Consulte :class:`~multiprocessing.managers.BaseManager` para obter uma "
"descrição dos argumentos de entrada opcionais herdados *address* e *authkey* "
"e como eles podem ser usados para conectar-se a um serviço :class:`!"
"SharedMemoryManager` existente de outros processos."

#: ../../library/multiprocessing.shared_memory.rst:234
msgid ""
"Create and return a new :class:`SharedMemory` object with the specified "
"*size* in bytes."
msgstr ""
"Cria e retorna um novo objeto :class:`SharedMemory` com o *size* "
"especificado em bytes."

#: ../../library/multiprocessing.shared_memory.rst:239
msgid ""
"Create and return a new :class:`ShareableList` object, initialized by the "
"values from the input *sequence*."
msgstr ""
"Cria e retorna um novo objeto :class:`ShareableList`, inicializado pelos "
"valores da entrada *sequence*."

#: ../../library/multiprocessing.shared_memory.rst:243
msgid ""
"The following example demonstrates the basic mechanisms of a :class:"
"`~multiprocessing.managers.SharedMemoryManager`:"
msgstr ""
"O exemplo a seguir demonstra os mecanismos básicos de um :class:"
"`~multiprocessing.managers.SharedMemoryManager`:"

#: ../../library/multiprocessing.shared_memory.rst:246
msgid ""
">>> from multiprocessing.managers import SharedMemoryManager\n"
">>> smm = SharedMemoryManager()\n"
">>> smm.start()  # Start the process that manages the shared memory blocks\n"
">>> sl = smm.ShareableList(range(4))\n"
">>> sl\n"
"ShareableList([0, 1, 2, 3], name='psm_6572_7512')\n"
">>> raw_shm = smm.SharedMemory(size=128)\n"
">>> another_sl = smm.ShareableList('alpha')\n"
">>> another_sl\n"
"ShareableList(['a', 'l', 'p', 'h', 'a'], name='psm_6572_12221')\n"
">>> smm.shutdown()  # Calls unlink() on sl, raw_shm, and another_sl"
msgstr ""
">>> from multiprocessing.managers import SharedMemoryManager\n"
">>> smm = SharedMemoryManager()\n"
">>> smm.start()  # Inicia o procsso que gerencia os blocos de memória "
"compartilhada\n"
">>> sl = smm.ShareableList(range(4))\n"
">>> sl\n"
"ShareableList([0, 1, 2, 3], name='psm_6572_7512')\n"
">>> raw_shm = smm.SharedMemory(size=128)\n"
">>> another_sl = smm.ShareableList('alpha')\n"
">>> another_sl\n"
"ShareableList(['a', 'l', 'p', 'h', 'a'], name='psm_6572_12221')\n"
">>> smm.shutdown()  # Chama unlink() em sl, raw_shm, e another_sl"

#: ../../library/multiprocessing.shared_memory.rst:261
msgid ""
"The following example depicts a potentially more convenient pattern for "
"using :class:`~multiprocessing.managers.SharedMemoryManager` objects via "
"the :keyword:`with` statement to ensure that all shared memory blocks are "
"released after they are no longer needed:"
msgstr ""
"O exemplo a seguir retrata um padrão potencialmente mais conveniente para "
"usar objetos :class:`~multiprocessing.managers.SharedMemoryManager` através "
"da instrução :keyword:`with` para garantir que todos os blocos de memória "
"compartilhada são liberados depois que não são mais necessários."

#: ../../library/multiprocessing.shared_memory.rst:266
msgid ""
">>> with SharedMemoryManager() as smm:\n"
"...     sl = smm.ShareableList(range(2000))\n"
"...     # Divide the work among two processes, storing partial results in "
"sl\n"
"...     p1 = Process(target=do_work, args=(sl, 0, 1000))\n"
"...     p2 = Process(target=do_work, args=(sl, 1000, 2000))\n"
"...     p1.start()\n"
"...     p2.start()  # A multiprocessing.Pool might be more efficient\n"
"...     p1.join()\n"
"...     p2.join()   # Wait for all work to complete in both processes\n"
"...     total_result = sum(sl)  # Consolidate the partial results now in sl"
msgstr ""
">>> with SharedMemoryManager() as smm:\n"
"...     sl = smm.ShareableList(range(2000))\n"
"...     # Divide o trabalho entre dois processos, armazenando resultados "
"parciais em sl\n"
"...     p1 = Process(target=do_work, args=(sl, 0, 1000))\n"
"...     p2 = Process(target=do_work, args=(sl, 1000, 2000))\n"
"...     p1.start()\n"
"...     p2.start()  # Um multiprocessing.Pool pode ser mais eficiente\n"
"...     p1.join()\n"
"...     p2.join()   # Espera todo trabalho ser concluído nos dois procssos\n"
"...     total_result = sum(sl)  # Consolida os resutlados parciais agora em "
"sl"

#: ../../library/multiprocessing.shared_memory.rst:280
msgid ""
"When using a :class:`~multiprocessing.managers.SharedMemoryManager` in a :"
"keyword:`with` statement, the shared memory blocks created using that "
"manager are all released when the :keyword:`!with` statement's code block "
"finishes execution."
msgstr ""
"Ao usar um :class:`~multiprocessing.managers.SharedMemoryManager` em uma "
"instrução :keyword:`with`, os blocos de memória compartilhada criados "
"utilizando este gerenciador são todos liberados quando o bloco de código com "
"a instrução :keyword:`!with` termina sua execução."

#: ../../library/multiprocessing.shared_memory.rst:288
msgid ""
"Provide a mutable list-like object where all values stored within are stored "
"in a shared memory block. This constrains storable values to the following "
"built-in data types:"
msgstr ""
"Fornece um objeto mutável do tipo lista onde todos os valores armazenados "
"dentro são armazenados em um bloco de memória compartilhada. Isso restringe "
"valores armazenáveis ​aos seguintes tipos de dados embutidos:"

#: ../../library/multiprocessing.shared_memory.rst:292
msgid ":class:`int` (signed 64-bit)"
msgstr ":class:`int` (com sinal, 64-bit)"

#: ../../library/multiprocessing.shared_memory.rst:293
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../library/multiprocessing.shared_memory.rst:294
msgid ":class:`bool`"
msgstr ":class:`bool`"

#: ../../library/multiprocessing.shared_memory.rst:295
msgid ":class:`str` (less than 10M bytes each when encoded as UTF-8)"
msgstr ":class:`str` (menos de 10M bytes cada quando codificado como UTF-8)"

#: ../../library/multiprocessing.shared_memory.rst:296
msgid ":class:`bytes` (less than 10M bytes each)"
msgstr ":class:`bytes` (menos de 10M bytes cada)"

#: ../../library/multiprocessing.shared_memory.rst:297
msgid "``None``"
msgstr "``None``"

#: ../../library/multiprocessing.shared_memory.rst:299
msgid ""
"It also notably differs from the built-in :class:`list` type in that these "
"lists can not change their overall length (i.e. no :meth:`!append`, :meth:`!"
"insert`, etc.) and do not support the dynamic creation of new :class:`!"
"ShareableList` instances via slicing."
msgstr ""
"Ele também difere notavelmente do tipo embutido :class:`list`, pois essas "
"listas não podem alterar seu comprimento geral (ou seja, sem :meth:`!"
"append`, :meth:`!insert`, etc.) e não oferecem suporte à criação dinâmica de "
"novas instâncias :class:`!ShareableList` por meio de fatiamento."

#: ../../library/multiprocessing.shared_memory.rst:305
msgid ""
"*sequence* is used in populating a new :class:`!ShareableList` full of "
"values. Set to ``None`` to instead attach to an already existing :class:`!"
"ShareableList` by its unique shared memory name."
msgstr ""
"*sequence* é usado para preencher um :class:`!ShareableList` com valores. "
"Defina como ``None`` para anexar a uma :class:`!ShareableList` já existente "
"pelo seu nome único de memória compartilhada."

#: ../../library/multiprocessing.shared_memory.rst:309
msgid ""
"*name* is the unique name for the requested shared memory, as described in "
"the definition for :class:`SharedMemory`.  When attaching to an existing :"
"class:`!ShareableList`, specify its shared memory block's unique name while "
"leaving *sequence* set to ``None``."
msgstr ""
"*name* é um nome único para a memória compartilhada requerida, como descrito "
"na definição de :class:`SharedMemory`. Ao anexar a uma :class:`!"
"ShareableList` já existente, deve-se especificar o nome único do bloco de "
"memória compartilhada e definir *sequence* como ``None``."

#: ../../library/multiprocessing.shared_memory.rst:316
msgid ""
"A known issue exists for :class:`bytes` and :class:`str` values. If they end "
"with ``\\x00`` nul bytes or characters, those may be *silently stripped* "
"when fetching them by index from the :class:`!ShareableList`. This ``."
"rstrip(b'\\x00')`` behavior is considered a bug and may go away in the "
"future. See :gh:`106939`."
msgstr ""
"Existe um problema conhecido para os valores :class:`bytes` e :class:`str`. "
"Se eles terminarem com bytes ou caracteres nulos ``\\x00``, eles podem ser "
"*silenciosamente removidos* ao buscá-los pelo índice da :class:`!"
"ShareableList`. Esse comportamento ``.rstrip(b'\\x00')`` é considerado um "
"bug e pode desaparecer no futuro. Veja :gh:`106939`."

#: ../../library/multiprocessing.shared_memory.rst:322
msgid ""
"For applications where rstripping of trailing nulls is a problem, work "
"around it by always unconditionally appending an extra non-0 byte to the end "
"of such values when storing and unconditionally removing it when fetching:"
msgstr ""
"Para aplicações onde a remoção de nulos finais é um problema, contorne-o "
"sempre anexando incondicionalmente um byte extra diferente de 0 ao final de "
"tais valores ao armazená-los e removendo-os incondicionalmente ao buscá-los:"

#: ../../library/multiprocessing.shared_memory.rst:327
msgid ""
">>> from multiprocessing import shared_memory\n"
">>> nul_bug_demo = shared_memory.ShareableList(['?\\x00', "
"b'\\x03\\x02\\x01\\x00\\x00\\x00'])\n"
">>> nul_bug_demo[0]\n"
"'?'\n"
">>> nul_bug_demo[1]\n"
"b'\\x03\\x02\\x01'\n"
">>> nul_bug_demo.shm.unlink()\n"
">>> padded = shared_memory.ShareableList(['?\\x00\\x07', "
"b'\\x03\\x02\\x01\\x00\\x00\\x00\\x07'])\n"
">>> padded[0][:-1]\n"
"'?\\x00'\n"
">>> padded[1][:-1]\n"
"b'\\x03\\x02\\x01\\x00\\x00\\x00'\n"
">>> padded.shm.unlink()"
msgstr ""
">>> from multiprocessing import shared_memory\n"
">>> nul_bug_demo = shared_memory.ShareableList(['?\\x00', "
"b'\\x03\\x02\\x01\\x00\\x00\\x00'])\n"
">>> nul_bug_demo[0]\n"
"'?'\n"
">>> nul_bug_demo[1]\n"
"b'\\x03\\x02\\x01'\n"
">>> nul_bug_demo.shm.unlink()\n"
">>> padded = shared_memory.ShareableList(['?\\x00\\x07', "
"b'\\x03\\x02\\x01\\x00\\x00\\x00\\x07'])\n"
">>> padded[0][:-1]\n"
"'?\\x00'\n"
">>> padded[1][:-1]\n"
"b'\\x03\\x02\\x01\\x00\\x00\\x00'\n"
">>> padded.shm.unlink()"

#: ../../library/multiprocessing.shared_memory.rst:345
msgid "Return the number of occurrences of *value*."
msgstr "Retorna o número de ocorrências de *value*."

#: ../../library/multiprocessing.shared_memory.rst:349
msgid ""
"Return first index position of *value*. Raise :exc:`ValueError` if *value* "
"is not present."
msgstr ""
"Retorna a primeira posição do índice de *value*. Levanta :exc:`ValueError` "
"se *value* não estiver presente."

#: ../../library/multiprocessing.shared_memory.rst:354
msgid ""
"Read-only attribute containing the :mod:`struct` packing format used by all "
"currently stored values."
msgstr ""
"Atributo somente leitura contendo o formato de empacotamento :mod:`struct` "
"usado por todos os valores armazenados atualmente."

#: ../../library/multiprocessing.shared_memory.rst:359
msgid "The :class:`SharedMemory` instance where the values are stored."
msgstr "A instância de :class:`SharedMemory` onde os valores são armazenados."

#: ../../library/multiprocessing.shared_memory.rst:362
msgid ""
"The following example demonstrates basic use of a :class:`ShareableList` "
"instance:"
msgstr ""
"O exemplo a seguir demonstra o uso básico de uma instância de :class:"
"`ShareableList`:"

#: ../../library/multiprocessing.shared_memory.rst:395
msgid ""
"The following example depicts how one, two, or many processes may access the "
"same :class:`ShareableList` by supplying the name of the shared memory block "
"behind it:"
msgstr ""
"O exemplo a seguir retrata como um, dois ou mais processos podem acessar a "
"mesma :class:`ShareableList` fornecendo o nome do bloco de memória "
"compartilhada por trás dela:"

#: ../../library/multiprocessing.shared_memory.rst:410
msgid ""
"The following examples demonstrates that :class:`ShareableList` (and "
"underlying :class:`SharedMemory`) objects can be pickled and unpickled if "
"needed. Note, that it will still be the same shared object. This happens, "
"because the deserialized object has the same unique name and is just "
"attached to an existing object with the same name (if the object is still "
"alive):"
msgstr ""
"Os exemplos a seguir demonstram que os objetos  :class:`ShareableList` (e o "
"subjacente :class:`SharedMemory`) podem ser serializados e desserializados "
"com pickle, se preciso. Note, ainda será o mesmo objeto compartilhado. Isto "
"acontece pois o objeto desserializado tem o mesmo nome único e é somente "
"anexado ao objeto existente com o mesmo nome (se o objeto ainda existe):"

#: ../../library/multiprocessing.shared_memory.rst:11
msgid "Shared Memory"
msgstr "Memória compartilhada"

#: ../../library/multiprocessing.shared_memory.rst:11
msgid "POSIX Shared Memory"
msgstr "POSIX, memória compartilhada"

#: ../../library/multiprocessing.shared_memory.rst:11
msgid "Named Shared Memory"
msgstr "Nomeada, memória compartilhada"

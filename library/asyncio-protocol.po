# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 17:51+0000\n"
"PO-Revision-Date: 2017-02-16 17:49+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/asyncio-protocol.rst:9
msgid "Transports and Protocols"
msgstr "Транспорт і протоколи"

#: ../../library/asyncio-protocol.rst:12
msgid "Preface"
msgstr "Prefácio"

#: ../../library/asyncio-protocol.rst:13
msgid ""
"Transports and Protocols are used by the **low-level** event loop APIs such "
"as :meth:`loop.create_connection`.  They use callback-based programming "
"style and enable high-performance implementations of network or IPC "
"protocols (e.g. HTTP)."
msgstr ""
"Транспорти та протоколи використовуються API циклу подій **низького рівня**, "
"наприклад :meth:`loop.create_connection`. Вони використовують стиль "
"програмування на основі зворотного виклику та дозволяють високопродуктивні "
"реалізації мережевих або IPC-протоколів (наприклад, HTTP)."

#: ../../library/asyncio-protocol.rst:18
msgid ""
"Essentially, transports and protocols should only be used in libraries and "
"frameworks and never in high-level asyncio applications."
msgstr ""
"По суті, транспорти та протоколи слід використовувати лише в бібліотеках і "
"фреймворках, а не в асинхронних програмах високого рівня."

#: ../../library/asyncio-protocol.rst:22
msgid "This documentation page covers both `Transports`_ and `Protocols`_."
msgstr "Ця сторінка документації охоплює як `Transports`_, так і `Protocols`_."

#: ../../library/asyncio-protocol.rst:25
msgid "Introduction"
msgstr "Introdução"

#: ../../library/asyncio-protocol.rst:26
msgid ""
"At the highest level, the transport is concerned with *how* bytes are "
"transmitted, while the protocol determines *which* bytes to transmit (and to "
"some extent when)."
msgstr ""
"На найвищому рівні транспорт стосується того, *як* передаються байти, тоді "
"як протокол визначає, *які* байти передавати (і певною мірою коли)."

#: ../../library/asyncio-protocol.rst:30
msgid ""
"A different way of saying the same thing: a transport is an abstraction for "
"a socket (or similar I/O endpoint) while a protocol is an abstraction for an "
"application, from the transport's point of view."
msgstr ""
"Інший спосіб сказати те саме: транспорт є абстракцією для сокета (або "
"подібної кінцевої точки вводу/виводу), тоді як протокол є абстракцією для "
"програми з точки зору транспорту."

#: ../../library/asyncio-protocol.rst:35
msgid ""
"Yet another view is the transport and protocol interfaces together define an "
"abstract interface for using network I/O and interprocess I/O."
msgstr ""
"Ще один погляд полягає в тому, що транспортний і протокольний інтерфейси "
"разом визначають абстрактний інтерфейс для використання мережевого вводу-"
"виводу та міжпроцесного введення-виведення."

#: ../../library/asyncio-protocol.rst:39
msgid ""
"There is always a 1:1 relationship between transport and protocol objects: "
"the protocol calls transport methods to send data, while the transport calls "
"protocol methods to pass it data that has been received."
msgstr ""
"Між транспортними об’єктами та об’єктами протоколу завжди існує зв’язок 1:1: "
"протокол викликає транспортні методи для надсилання даних, тоді як транспорт "
"викликає протокольні методи для передачі йому отриманих даних."

#: ../../library/asyncio-protocol.rst:44
msgid ""
"Most of connection oriented event loop methods (such as :meth:`loop."
"create_connection`) usually accept a *protocol_factory* argument used to "
"create a *Protocol* object for an accepted connection, represented by a "
"*Transport* object. Such methods usually return a tuple of ``(transport, "
"protocol)``."
msgstr ""
"Більшість методів циклу подій, орієнтованих на підключення (таких як :meth:"
"`loop.create_connection`), зазвичай приймають аргумент *protocol_factory*, "
"який використовується для створення об’єкта *Protocol* для прийнятного "
"з’єднання, представленого об’єктом *Transport*. Такі методи зазвичай "
"повертають кортеж ``(транспорт, протокол)``."

#: ../../library/asyncio-protocol.rst:51
msgid "Contents"
msgstr "Conteúdo"

#: ../../library/asyncio-protocol.rst:52
msgid "This documentation page contains the following sections:"
msgstr "Esta página de documentação contém as seguintes seções:"

#: ../../library/asyncio-protocol.rst:54
msgid ""
"The `Transports`_ section documents asyncio :class:`BaseTransport`, :class:"
"`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, :class:"
"`DatagramTransport`, and :class:`SubprocessTransport` classes."
msgstr ""
"Розділ `Transports`_ документує asyncio :class:`BaseTransport`, :class:"
"`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, :class:"
"`DatagramTransport` і :class:`SubprocessTransport` класи."

#: ../../library/asyncio-protocol.rst:59
msgid ""
"The `Protocols`_ section documents asyncio :class:`BaseProtocol`, :class:"
"`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol`, and :class:"
"`SubprocessProtocol` classes."
msgstr ""
"Розділ `Protocols`_ документує асинхронні класи :class:`BaseProtocol`, :"
"class:`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol` і :"
"class:`SubprocessProtocol`."

#: ../../library/asyncio-protocol.rst:63
msgid ""
"The `Examples`_ section showcases how to work with transports, protocols, "
"and low-level event loop APIs."
msgstr ""
"Розділ `Examples`_ демонструє, як працювати з транспортами, протоколами та "
"API низькорівневого циклу подій."

#: ../../library/asyncio-protocol.rst:70
msgid "Transports"
msgstr "Transportes"

#: ../../library/asyncio-protocol.rst:72
msgid "**Source code:** :source:`Lib/asyncio/transports.py`"
msgstr "**Kod źródłowy:** :source:`Lib/asyncio/transports.py`"

#: ../../library/asyncio-protocol.rst:76
msgid ""
"Transports are classes provided by :mod:`asyncio` in order to abstract "
"various kinds of communication channels."
msgstr ""
"Транспорти — це класи, надані :mod:`asyncio` для абстрагування різних видів "
"каналів зв’язку."

#: ../../library/asyncio-protocol.rst:79
msgid ""
"Transport objects are always instantiated by an :ref:`asyncio event loop "
"<asyncio-event-loop>`."
msgstr ""
"Транспортні об’єкти завжди створюються :ref:`асинхронним циклом подій "
"<asyncio-event-loop>`."

#: ../../library/asyncio-protocol.rst:82
msgid ""
"asyncio implements transports for TCP, UDP, SSL, and subprocess pipes. The "
"methods available on a transport depend on the transport's kind."
msgstr ""
"asyncio реалізує транспорти для каналів TCP, UDP, SSL і підпроцесів. Методи, "
"доступні на транспорті, залежать від типу транспорту."

#: ../../library/asyncio-protocol.rst:85
msgid ""
"The transport classes are :ref:`not thread safe <asyncio-multithreading>`."
msgstr ""
"Транспортні класи :ref:`не потоково безпечні <asyncio-multithreading>`."

#: ../../library/asyncio-protocol.rst:89
msgid "Transports Hierarchy"
msgstr "Ієрархія транспортів"

#: ../../library/asyncio-protocol.rst:93
msgid ""
"Base class for all transports.  Contains methods that all asyncio transports "
"share."
msgstr ""
"Базовий клас для всіх видів транспорту. Містить методи, спільні для всіх "
"асинхронних транспортів."

#: ../../library/asyncio-protocol.rst:98
msgid "A base transport for write-only connections."
msgstr "Базовий транспорт для підключень лише для запису."

#: ../../library/asyncio-protocol.rst:100
msgid ""
"Instances of the *WriteTransport* class are returned from the :meth:`loop."
"connect_write_pipe` event loop method and are also used by subprocess-"
"related methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Екземпляри класу *WriteTransport* повертаються з методу циклу подій :meth:"
"`loop.connect_write_pipe`, а також використовуються пов’язаними з "
"підпроцесами методами, наприклад :meth:`loop.subprocess_exec`."

#: ../../library/asyncio-protocol.rst:107
msgid "A base transport for read-only connections."
msgstr "Базовий транспорт для підключень лише для читання."

#: ../../library/asyncio-protocol.rst:109
msgid ""
"Instances of the *ReadTransport* class are returned from the :meth:`loop."
"connect_read_pipe` event loop method and are also used by subprocess-related "
"methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Екземпляри класу *ReadTransport* повертаються з методу циклу подій :meth:"
"`loop.connect_read_pipe`, а також використовуються пов’язаними з "
"підпроцесами методами, наприклад :meth:`loop.subprocess_exec`."

#: ../../library/asyncio-protocol.rst:116
msgid ""
"Interface representing a bidirectional transport, such as a TCP connection."
msgstr ""
"Інтерфейс, що представляє двонаправлений транспорт, наприклад TCP-з'єднання."

#: ../../library/asyncio-protocol.rst:119
msgid ""
"The user does not instantiate a transport directly; they call a utility "
"function, passing it a protocol factory and other information necessary to "
"create the transport and protocol."
msgstr ""
"Користувач не створює екземпляр транспорту безпосередньо; вони викликають "
"службову функцію, передаючи їй фабрику протоколів та іншу інформацію, "
"необхідну для створення транспорту та протоколу."

#: ../../library/asyncio-protocol.rst:123
msgid ""
"Instances of the *Transport* class are returned from or used by event loop "
"methods like :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop.sendfile`, "
"etc."
msgstr ""
"Екземпляри класу *Transport* повертаються або використовуються такими "
"методами циклу подій, як :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop. sendfile` "
"тощо."

#: ../../library/asyncio-protocol.rst:131
msgid "A transport for datagram (UDP) connections."
msgstr "Транспорт для з’єднань дейтаграм (UDP)."

#: ../../library/asyncio-protocol.rst:133
msgid ""
"Instances of the *DatagramTransport* class are returned from the :meth:`loop."
"create_datagram_endpoint` event loop method."
msgstr ""
"Екземпляри класу *DatagramTransport* повертаються з методу циклу подій :meth:"
"`loop.create_datagram_endpoint`."

#: ../../library/asyncio-protocol.rst:139
msgid ""
"An abstraction to represent a connection between a parent and its child OS "
"process."
msgstr ""
"Абстракція для представлення зв’язку між батьківським і дочірнім процесами "
"ОС."

#: ../../library/asyncio-protocol.rst:142
msgid ""
"Instances of the *SubprocessTransport* class are returned from event loop "
"methods :meth:`loop.subprocess_shell` and :meth:`loop.subprocess_exec`."
msgstr ""
"Екземпляри класу *SubprocessTransport* повертаються з методів циклу подій :"
"meth:`loop.subprocess_shell` і :meth:`loop.subprocess_exec`."

#: ../../library/asyncio-protocol.rst:148
msgid "Base Transport"
msgstr "Базовий транспорт"

#: ../../library/asyncio-protocol.rst:152
msgid "Close the transport."
msgstr "Fecha o transporte."

#: ../../library/asyncio-protocol.rst:154
msgid ""
"If the transport has a buffer for outgoing data, buffered data will be "
"flushed asynchronously.  No more data will be received.  After all buffered "
"data is flushed, the protocol's :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` method will be called with :const:`None` as "
"its argument."
msgstr ""

#: ../../library/asyncio-protocol.rst:163
msgid "Return ``True`` if the transport is closing or is closed."
msgstr "Retorna ``True`` se o transporte estiver fechando ou estiver fechado."

#: ../../library/asyncio-protocol.rst:167
msgid "Return information about the transport or underlying resources it uses."
msgstr ""
"Повертає інформацію про транспорт або основні ресурси, які він використовує."

#: ../../library/asyncio-protocol.rst:170
msgid ""
"*name* is a string representing the piece of transport-specific information "
"to get."
msgstr ""
"*ім’я* — це рядок, що представляє частину транспортної інформації, яку "
"потрібно отримати."

#: ../../library/asyncio-protocol.rst:173
msgid ""
"*default* is the value to return if the information is not available, or if "
"the transport does not support querying it with the given third-party event "
"loop implementation or on the current platform."
msgstr ""
"*default* — це значення, яке повертається, якщо інформація недоступна або "
"якщо транспорт не підтримує її запит за допомогою сторонньої реалізації "
"циклу подій або на поточній платформі."

#: ../../library/asyncio-protocol.rst:178
msgid ""
"For example, the following code attempts to get the underlying socket object "
"of the transport::"
msgstr ""
"Наприклад, наступний код намагається отримати базовий об’єкт сокета "
"транспорту::"

#: ../../library/asyncio-protocol.rst:185
msgid "Categories of information that can be queried on some transports:"
msgstr "Категорії інформації, які можна запитувати на деяких транспортах:"

#: ../../library/asyncio-protocol.rst:187
msgid "socket:"
msgstr "розетка:"

#: ../../library/asyncio-protocol.rst:189
msgid ""
"``'peername'``: the remote address to which the socket is connected, result "
"of :meth:`socket.socket.getpeername` (``None`` on error)"
msgstr ""
"``'peername'``: віддалена адреса, до якої підключено сокет, результат :meth:"
"`socket.socket.getpeername` (``None`` у разі помилки)"

#: ../../library/asyncio-protocol.rst:193
msgid "``'socket'``: :class:`socket.socket` instance"
msgstr "``'socket'``: :class:`socket.socket` екземпляр"

#: ../../library/asyncio-protocol.rst:195
msgid ""
"``'sockname'``: the socket's own address, result of :meth:`socket.socket."
"getsockname`"
msgstr ""
"``'sockname'``: власна адреса сокета, результат :meth:`socket.socket."
"getsockname`"

#: ../../library/asyncio-protocol.rst:198
msgid "SSL socket:"
msgstr "SSL-сокет:"

#: ../../library/asyncio-protocol.rst:200
msgid ""
"``'compression'``: the compression algorithm being used as a string, or "
"``None`` if the connection isn't compressed; result of :meth:`ssl.SSLSocket."
"compression`"
msgstr ""
"``'стиснення'``: алгоритм стиснення, що використовується як рядок, або "
"``None``, якщо з'єднання не стиснуте; результат :meth:`ssl.SSLSocket."
"compression`"

#: ../../library/asyncio-protocol.rst:204
msgid ""
"``'cipher'``: a three-value tuple containing the name of the cipher being "
"used, the version of the SSL protocol that defines its use, and the number "
"of secret bits being used; result of :meth:`ssl.SSLSocket.cipher`"
msgstr ""
"``'cipher'``: кортеж з трьох значень, що містить назву використовуваного "
"шифру, версію протоколу SSL, яка визначає його використання, і кількість "
"секретних бітів, що використовуються; результат :meth:`ssl.SSLSocket.cipher`"

#: ../../library/asyncio-protocol.rst:209
msgid ""
"``'peercert'``: peer certificate; result of :meth:`ssl.SSLSocket.getpeercert`"
msgstr ""
"``'peercert'``: одноранговий сертифікат; результат :meth:`ssl.SSLSocket."
"getpeercert`"

#: ../../library/asyncio-protocol.rst:212
msgid "``'sslcontext'``: :class:`ssl.SSLContext` instance"
msgstr "``'sslcontext'``: :class:`ssl.SSLContext` instance"

#: ../../library/asyncio-protocol.rst:214
msgid ""
"``'ssl_object'``: :class:`ssl.SSLObject` or :class:`ssl.SSLSocket` instance"
msgstr ""
"``'ssl_object'``: :class:`ssl.SSLObject` або :class:`ssl.SSLSocket` екземпляр"

#: ../../library/asyncio-protocol.rst:217
msgid "pipe:"
msgstr "труба:"

#: ../../library/asyncio-protocol.rst:219
msgid "``'pipe'``: pipe object"
msgstr "``'pipe'``: об'єкт труби"

#: ../../library/asyncio-protocol.rst:221
msgid "subprocess:"
msgstr "підпроцес:"

#: ../../library/asyncio-protocol.rst:223
msgid "``'subprocess'``: :class:`subprocess.Popen` instance"
msgstr "``'subprocess'``: :class:`subprocess.Popen` instance"

#: ../../library/asyncio-protocol.rst:227
msgid "Set a new protocol."
msgstr "Define um novo protocolo."

#: ../../library/asyncio-protocol.rst:229
msgid ""
"Switching protocol should only be done when both protocols are documented to "
"support the switch."
msgstr ""
"Протокол перемикання слід виконувати лише тоді, коли обидва протоколи "
"задокументовано для підтримки перемикання."

#: ../../library/asyncio-protocol.rst:234
msgid "Return the current protocol."
msgstr "Retorna o protocolo atual."

#: ../../library/asyncio-protocol.rst:238
msgid "Read-only Transports"
msgstr "Транспорти лише для читання"

#: ../../library/asyncio-protocol.rst:242
msgid "Return ``True`` if the transport is receiving new data."
msgstr "Повертає ``True``, якщо транспорт отримує нові дані."

#: ../../library/asyncio-protocol.rst:248
msgid ""
"Pause the receiving end of the transport.  No data will be passed to the "
"protocol's :meth:`protocol.data_received() <Protocol.data_received>` method "
"until :meth:`resume_reading` is called."
msgstr ""
"Призупинити приймальний кінець транспорту. Жодні дані не будуть передані в "
"метод протоколу :meth:`protocol.data_received() <Protocol.data_received>`, "
"доки не буде викликано :meth:`resume_reading`."

#: ../../library/asyncio-protocol.rst:252
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already paused or closed."
msgstr ""
"Метод є ідемпотентним, тобто його можна викликати, коли транспорт вже "
"призупинено або закрито."

#: ../../library/asyncio-protocol.rst:258
msgid ""
"Resume the receiving end.  The protocol's :meth:`protocol.data_received() "
"<Protocol.data_received>` method will be called once again if some data is "
"available for reading."
msgstr ""
"Відновіть приймальний кінець. Метод :meth:`protocol.data_received() "
"<Protocol.data_received>` протоколу буде викликано ще раз, якщо деякі дані "
"доступні для читання."

#: ../../library/asyncio-protocol.rst:262
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already reading."
msgstr ""
"Метод є ідемпотентним, тобто його можна викликати, коли транспорт вже читає."

#: ../../library/asyncio-protocol.rst:268
msgid "Write-only Transports"
msgstr "Транспорти лише для запису"

#: ../../library/asyncio-protocol.rst:272
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost.  No more data will be received. The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Закрийте транспорт негайно, не чекаючи завершення незавершених операцій. "
"Буферизовані дані буде втрачено. Дані більше не надходитимуть. Метод :meth:"
"`protocol.connection_lost() <BaseProtocol.connection_lost>` протоколу "
"зрештою буде викликано з :const:`None` як аргумент."

#: ../../library/asyncio-protocol.rst:280
msgid ""
"Return :const:`True` if the transport supports :meth:`~WriteTransport."
"write_eof`, :const:`False` if not."
msgstr ""
"Повертає :const:`True`, якщо транспорт підтримує :meth:`~WriteTransport."
"write_eof`, :const:`False`, якщо ні."

#: ../../library/asyncio-protocol.rst:285
msgid "Return the current size of the output buffer used by the transport."
msgstr ""
"Повертає поточний розмір вихідного буфера, який використовується транспортом."

#: ../../library/asyncio-protocol.rst:289
msgid ""
"Get the *high* and *low* watermarks for write flow control. Return a tuple "
"``(low, high)`` where *low* and *high* are positive number of bytes."
msgstr ""
"Отримайте *високий* і *низький* водяні знаки для керування потоком запису. "
"Повертає кортеж ``(low, high)``, де *low* і *high* є додатною кількістю "
"байтів."

#: ../../library/asyncio-protocol.rst:293
msgid "Use :meth:`set_write_buffer_limits` to set the limits."
msgstr ""
"Використовуйте :meth:`set_write_buffer_limits`, щоб встановити обмеження."

#: ../../library/asyncio-protocol.rst:299
msgid "Set the *high* and *low* watermarks for write flow control."
msgstr ""
"Встановіть *високий* і *низький* водяні знаки для керування потоком запису."

#: ../../library/asyncio-protocol.rst:301
msgid ""
"These two values (measured in number of bytes) control when the protocol's :"
"meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` and :meth:"
"`protocol.resume_writing() <BaseProtocol.resume_writing>` methods are "
"called. If specified, the low watermark must be less than or equal to the "
"high watermark.  Neither *high* nor *low* can be negative."
msgstr ""
"Ці два значення (вимірюються в кількості байтів) контролюють, коли "
"викликаються методи протоколу :meth:`protocol.pause_writing() <BaseProtocol."
"pause_writing>` і :meth:`protocol.resume_writing() <BaseProtocol."
"resume_writing>`. Якщо вказано, нижній водяний знак має бути меншим або "
"дорівнювати високому водяному знаку. Ні *високий*, ні *низький* не можуть "
"бути негативними."

#: ../../library/asyncio-protocol.rst:309
msgid ""
":meth:`~BaseProtocol.pause_writing` is called when the buffer size becomes "
"greater than or equal to the *high* value. If writing has been paused, :meth:"
"`~BaseProtocol.resume_writing` is called when the buffer size becomes less "
"than or equal to the *low* value."
msgstr ""
":meth:`~BaseProtocol.pause_writing` викликається, коли розмір буфера стає "
"більшим або рівним значенню *high*. Якщо запис призупинено, :meth:"
"`~BaseProtocol.resume_writing` викликається, коли розмір буфера стає меншим "
"або рівним *низькому* значенню."

#: ../../library/asyncio-protocol.rst:314
msgid ""
"The defaults are implementation-specific.  If only the high watermark is "
"given, the low watermark defaults to an implementation-specific value less "
"than or equal to the high watermark.  Setting *high* to zero forces *low* to "
"zero as well, and causes :meth:`~BaseProtocol.pause_writing` to be called "
"whenever the buffer becomes non-empty.  Setting *low* to zero causes :meth:"
"`~BaseProtocol.resume_writing` to be called only once the buffer is empty. "
"Use of zero for either limit is generally sub-optimal as it reduces "
"opportunities for doing I/O and computation concurrently."
msgstr ""
"Значення за замовчуванням залежать від реалізації. Якщо вказано лише високий "
"водяний знак, низький водяний знак за замовчуванням має значення, що "
"залежить від реалізації, менше або дорівнює верхньому водяному знаку. Якщо "
"встановити *high* на нуль, *low* також буде встановлено на нуль і спричинить "
"виклик :meth:`~BaseProtocol.pause_writing` щоразу, коли буфер стає "
"непорожнім. Якщо встановити *low* на нуль, :meth:`~BaseProtocol."
"resume_writing` буде викликатися лише після того, як буфер буде порожнім. "
"Використання нуля для будь-якого обмеження, як правило, є неоптимальним, "
"оскільки воно зменшує можливості одночасного виконання вводу-виводу та "
"обчислень."

#: ../../library/asyncio-protocol.rst:325
msgid "Use :meth:`~WriteTransport.get_write_buffer_limits` to get the limits."
msgstr ""
"Використовуйте :meth:`~WriteTransport.get_write_buffer_limits`, щоб отримати "
"обмеження."

#: ../../library/asyncio-protocol.rst:330
msgid "Write some *data* bytes to the transport."
msgstr "Запишіть кілька байтів *data* в транспорт."

#: ../../library/asyncio-protocol.rst:332
#: ../../library/asyncio-protocol.rst:361
msgid ""
"This method does not block; it buffers the data and arranges for it to be "
"sent out asynchronously."
msgstr ""
"Цей спосіб не блокує; він буферизує дані та організовує їх асинхронне "
"надсилання."

#: ../../library/asyncio-protocol.rst:337
msgid ""
"Write a list (or any iterable) of data bytes to the transport. This is "
"functionally equivalent to calling :meth:`write` on each element yielded by "
"the iterable, but may be implemented more efficiently."
msgstr ""
"Запишіть список (або будь-яку ітерацію) байтів даних у транспорт. Це "
"функціонально еквівалентно виклику :meth:`write` для кожного елемента, "
"отриманого iterable, але може бути реалізовано більш ефективно."

#: ../../library/asyncio-protocol.rst:344
msgid ""
"Close the write end of the transport after flushing all buffered data. Data "
"may still be received."
msgstr ""
"Закрийте кінець запису транспорту після очищення всіх буферизованих даних. "
"Дані ще можуть бути отримані."

#: ../../library/asyncio-protocol.rst:347
msgid ""
"This method can raise :exc:`NotImplementedError` if the transport (e.g. SSL) "
"doesn't support half-closed connections."
msgstr ""
"Цей метод може викликати :exc:`NotImplementedError`, якщо транспорт "
"(наприклад, SSL) не підтримує напівзакриті з’єднання."

#: ../../library/asyncio-protocol.rst:352
msgid "Datagram Transports"
msgstr "Transportes de datagrama"

#: ../../library/asyncio-protocol.rst:356
msgid ""
"Send the *data* bytes to the remote peer given by *addr* (a transport-"
"dependent target address).  If *addr* is :const:`None`, the data is sent to "
"the target address given on transport creation."
msgstr ""
"Надішліть байти *data* до віддаленого однорангового вузла, заданого *addr* "
"(цільова адреса, що залежить від транспорту). Якщо *addr* має значення :"
"const:`None`, дані надсилаються на цільову адресу, указану під час створення "
"транспорту."

#: ../../library/asyncio-protocol.rst:366
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost. No more data will be received.  The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Закрийте транспорт негайно, не чекаючи завершення незавершених операцій. "
"Буферизовані дані буде втрачено. Дані більше не надходитимуть. Метод :meth:"
"`protocol.connection_lost() <BaseProtocol.connection_lost>` протоколу "
"зрештою буде викликано з :const:`None` як аргумент."

#: ../../library/asyncio-protocol.rst:376
msgid "Subprocess Transports"
msgstr "Transportes de Subprocesso"

#: ../../library/asyncio-protocol.rst:380
msgid "Return the subprocess process id as an integer."
msgstr "Повертає ідентифікатор процесу підпроцесу як ціле число."

#: ../../library/asyncio-protocol.rst:384
msgid ""
"Return the transport for the communication pipe corresponding to the integer "
"file descriptor *fd*:"
msgstr ""
"Повертає транспорт для комунікаційного каналу, що відповідає цілочисельному "
"файловому дескриптору *fd*:"

#: ../../library/asyncio-protocol.rst:387
msgid ""
"``0``: readable streaming transport of the standard input (*stdin*), or :"
"const:`None` if the subprocess was not created with ``stdin=PIPE``"
msgstr ""
"``0``: доступний для читання потоковий транспорт стандартного введення "
"(*stdin*) або :const:`None`, якщо підпроцес не було створено за допомогою "
"``stdin=PIPE``"

#: ../../library/asyncio-protocol.rst:389
msgid ""
"``1``: writable streaming transport of the standard output (*stdout*), or :"
"const:`None` if the subprocess was not created with ``stdout=PIPE``"
msgstr ""
"``1``: доступний для запису потоковий транспорт стандартного виводу "
"(*stdout*) або :const:`None`, якщо підпроцес не було створено за допомогою "
"``stdout=PIPE``"

#: ../../library/asyncio-protocol.rst:391
msgid ""
"``2``: writable streaming transport of the standard error (*stderr*), or :"
"const:`None` if the subprocess was not created with ``stderr=PIPE``"
msgstr ""
"``2``: доступний для запису потоковий транспорт стандартної помилки "
"(*stderr*) або :const:`None`, якщо підпроцес не було створено за допомогою "
"``stderr=PIPE``"

#: ../../library/asyncio-protocol.rst:393
msgid "other *fd*: :const:`None`"
msgstr "інший *fd*: :const:`None`"

#: ../../library/asyncio-protocol.rst:397
msgid ""
"Return the subprocess return code as an integer or :const:`None` if it "
"hasn't returned, which is similar to the :attr:`subprocess.Popen.returncode` "
"attribute."
msgstr ""
"Повертає код повернення підпроцесу як ціле число або :const:`None`, якщо він "
"не повернувся, що подібно до атрибута :attr:`subprocess.Popen.returncode`."

#: ../../library/asyncio-protocol.rst:403
msgid "Kill the subprocess."
msgstr "Mata o subprocesso."

#: ../../library/asyncio-protocol.rst:405
msgid ""
"On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, "
"this method is an alias for :meth:`terminate`."
msgstr ""
"У системах POSIX функція надсилає SIGKILL підпроцесу. У Windows цей метод є "
"псевдонімом для :meth:`terminate`."

#: ../../library/asyncio-protocol.rst:408
msgid "See also :meth:`subprocess.Popen.kill`."
msgstr "Дивіться також :meth:`subprocess.Popen.kill`."

#: ../../library/asyncio-protocol.rst:412
msgid ""
"Send the *signal* number to the subprocess, as in :meth:`subprocess.Popen."
"send_signal`."
msgstr ""
"Надішліть номер *сигналу* підпроцесу, як у :meth:`subprocess.Popen."
"send_signal`."

#: ../../library/asyncio-protocol.rst:417
msgid "Stop the subprocess."
msgstr "Interrompe o  subprocesso."

#: ../../library/asyncio-protocol.rst:419
msgid ""
"On POSIX systems, this method sends SIGTERM to the subprocess. On Windows, "
"the Windows API function TerminateProcess() is called to stop the subprocess."
msgstr ""

#: ../../library/asyncio-protocol.rst:423
msgid "See also :meth:`subprocess.Popen.terminate`."
msgstr "Дивіться також :meth:`subprocess.Popen.terminate`."

#: ../../library/asyncio-protocol.rst:427
msgid "Kill the subprocess by calling the :meth:`kill` method."
msgstr "Закрийте підпроцес, викликавши метод :meth:`kill`."

#: ../../library/asyncio-protocol.rst:429
msgid ""
"If the subprocess hasn't returned yet, and close transports of *stdin*, "
"*stdout*, and *stderr* pipes."
msgstr ""
"Якщо підпроцес ще не повернувся, закрийте транспорти каналів *stdin*, "
"*stdout* і *stderr*."

#: ../../library/asyncio-protocol.rst:436
msgid "Protocols"
msgstr "Protocolos"

#: ../../library/asyncio-protocol.rst:438
msgid "**Source code:** :source:`Lib/asyncio/protocols.py`"
msgstr "**Kod źródłowy:** :source:`Lib/asyncio/protocols.py`"

#: ../../library/asyncio-protocol.rst:442
msgid ""
"asyncio provides a set of abstract base classes that should be used to "
"implement network protocols.  Those classes are meant to be used together "
"with :ref:`transports <asyncio-transport>`."
msgstr ""
"asyncio надає набір абстрактних базових класів, які слід використовувати для "
"реалізації мережевих протоколів. Ці класи призначені для використання разом "
"із :ref:`transports <asyncio-transport>`."

#: ../../library/asyncio-protocol.rst:446
msgid ""
"Subclasses of abstract base protocol classes may implement some or all "
"methods.  All these methods are callbacks: they are called by transports on "
"certain events, for example when some data is received. A base protocol "
"method should be called by the corresponding transport."
msgstr ""
"Підкласи абстрактних базових класів протоколу можуть реалізовувати деякі або "
"всі методи. Усі ці методи є зворотними викликами: вони викликаються "
"транспортами під час певних подій, наприклад, коли надходять якісь дані. "
"Метод базового протоколу має викликатися відповідним транспортом."

#: ../../library/asyncio-protocol.rst:453
msgid "Base Protocols"
msgstr "Protocolos de Base"

#: ../../library/asyncio-protocol.rst:457
msgid "Base protocol with methods that all protocols share."
msgstr "Базовий протокол із методами, які використовують усі протоколи."

#: ../../library/asyncio-protocol.rst:461
msgid ""
"The base class for implementing streaming protocols (TCP, Unix sockets, etc)."
msgstr ""
"Базовий клас для реалізації потокових протоколів (TCP, Unix-сокети тощо)."

#: ../../library/asyncio-protocol.rst:466
msgid ""
"A base class for implementing streaming protocols with manual control of the "
"receive buffer."
msgstr ""
"Базовий клас для реалізації потокових протоколів із ручним керуванням "
"приймальним буфером."

#: ../../library/asyncio-protocol.rst:471
msgid "The base class for implementing datagram (UDP) protocols."
msgstr "Базовий клас для реалізації протоколів дейтаграм (UDP)."

#: ../../library/asyncio-protocol.rst:475
msgid ""
"The base class for implementing protocols communicating with child processes "
"(unidirectional pipes)."
msgstr ""
"Базовий клас для реалізації протоколів, що спілкуються з дочірніми процесами "
"(односпрямовані канали)."

#: ../../library/asyncio-protocol.rst:480
msgid "Base Protocol"
msgstr "Базовий протокол"

#: ../../library/asyncio-protocol.rst:482
msgid "All asyncio protocols can implement Base Protocol callbacks."
msgstr ""
"Усі асинхронні протоколи можуть реалізовувати зворотні виклики базового "
"протоколу."

#: ../../library/asyncio-protocol.rst:485
msgid "Connection Callbacks"
msgstr "Зворотні виклики підключення"

#: ../../library/asyncio-protocol.rst:486
msgid ""
"Connection callbacks are called on all protocols, exactly once per a "
"successful connection.  All other protocol callbacks can only be called "
"between those two methods."
msgstr ""
"Зворотні виклики підключення викликаються для всіх протоколів рівно один раз "
"за успішне підключення. Усі інші зворотні виклики протоколу можна викликати "
"лише між цими двома методами."

#: ../../library/asyncio-protocol.rst:492
msgid "Called when a connection is made."
msgstr "Chamado quando uma conexão é estabelecida."

#: ../../library/asyncio-protocol.rst:494
msgid ""
"The *transport* argument is the transport representing the connection.  The "
"protocol is responsible for storing the reference to its transport."
msgstr ""
"Аргумент *transport* — це транспорт, що представляє з’єднання. Протокол "
"відповідає за збереження посилання на свій транспорт."

#: ../../library/asyncio-protocol.rst:500
msgid "Called when the connection is lost or closed."
msgstr "Chamado quanto a conexão é perdida ou fechada."

#: ../../library/asyncio-protocol.rst:502
msgid ""
"The argument is either an exception object or :const:`None`. The latter "
"means a regular EOF is received, or the connection was aborted or closed by "
"this side of the connection."
msgstr ""
"Аргументом є або об’єкт винятку, або :const:`None`. Останнє означає, що "
"отримано звичайний EOF, або з’єднання було перервано чи закрито цією "
"стороною з’єднання."

#: ../../library/asyncio-protocol.rst:508
msgid "Flow Control Callbacks"
msgstr "Зворотні виклики керування потоком"

#: ../../library/asyncio-protocol.rst:509
msgid ""
"Flow control callbacks can be called by transports to pause or resume "
"writing performed by the protocol."
msgstr ""
"Зворотні виклики керування потоком можуть бути викликані транспортами, щоб "
"призупинити або відновити запис, який виконується протоколом."

#: ../../library/asyncio-protocol.rst:512
msgid ""
"See the documentation of the :meth:`~WriteTransport.set_write_buffer_limits` "
"method for more details."
msgstr ""
"Додаткову інформацію дивіться в документації методу :meth:`~WriteTransport."
"set_write_buffer_limits`."

#: ../../library/asyncio-protocol.rst:517
msgid "Called when the transport's buffer goes over the high watermark."
msgstr "Викликається, коли транспортний буфер переходить верхній водяний знак."

#: ../../library/asyncio-protocol.rst:521
msgid "Called when the transport's buffer drains below the low watermark."
msgstr ""
"Викликається, коли транспортний буфер закінчується нижче низького водяного "
"знака."

#: ../../library/asyncio-protocol.rst:523
msgid ""
"If the buffer size equals the high watermark, :meth:`~BaseProtocol."
"pause_writing` is not called: the buffer size must go strictly over."
msgstr ""
"Якщо розмір буфера дорівнює верхньому водяному знаку, :meth:`~BaseProtocol."
"pause_writing` не викликається: розмір буфера має суворо перевищувати."

#: ../../library/asyncio-protocol.rst:527
msgid ""
"Conversely, :meth:`~BaseProtocol.resume_writing` is called when the buffer "
"size is equal or lower than the low watermark.  These end conditions are "
"important to ensure that things go as expected when either mark is zero."
msgstr ""
"І навпаки, :meth:`~BaseProtocol.resume_writing` викликається, коли розмір "
"буфера дорівнює або менше ніж нижній водяний знак. Ці кінцеві умови важливі "
"для забезпечення того, щоб усе відбувалося так, як очікувалося, коли будь-"
"яка позначка дорівнює нулю."

#: ../../library/asyncio-protocol.rst:534
msgid "Streaming Protocols"
msgstr "Протоколи потокової передачі"

#: ../../library/asyncio-protocol.rst:536
msgid ""
"Event methods, such as :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe`, and :meth:`loop.connect_write_pipe` accept factories "
"that return streaming protocols."
msgstr ""
"Методи подій, такі як :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe` і :meth:`loop.connect_write_pipe` приймають фабрики, які "
"повертають потокові протоколи."

#: ../../library/asyncio-protocol.rst:544
msgid ""
"Called when some data is received.  *data* is a non-empty bytes object "
"containing the incoming data."
msgstr ""
"Викликається при отриманні деяких даних. *data* — це об’єкт із непорожніми "
"байтами, що містить вхідні дані."

#: ../../library/asyncio-protocol.rst:547
msgid ""
"Whether the data is buffered, chunked or reassembled depends on the "
"transport.  In general, you shouldn't rely on specific semantics and instead "
"make your parsing generic and flexible. However, data is always received in "
"the correct order."
msgstr ""
"Від транспортування залежить, чи будуть дані буферизовані, фрагментовані чи "
"повторно зібрані. Загалом, вам не слід покладатися на конкретну семантику, а "
"натомість робити аналіз загальним і гнучким. Однак дані завжди надходять у "
"правильному порядку."

#: ../../library/asyncio-protocol.rst:552
msgid ""
"The method can be called an arbitrary number of times while a connection is "
"open."
msgstr ""
"Метод можна викликати довільну кількість разів, поки з’єднання відкрито."

#: ../../library/asyncio-protocol.rst:555
msgid ""
"However, :meth:`protocol.eof_received() <Protocol.eof_received>` is called "
"at most once.  Once `eof_received()` is called, ``data_received()`` is not "
"called anymore."
msgstr ""

#: ../../library/asyncio-protocol.rst:561
msgid ""
"Called when the other end signals it won't send any more data (for example "
"by calling :meth:`transport.write_eof() <WriteTransport.write_eof>`, if the "
"other end also uses asyncio)."
msgstr ""
"Викликається, коли інший кінець сигналізує, що більше не надсилатиме даних "
"(наприклад, викликом :meth:`transport.write_eof() <WriteTransport."
"write_eof>`, якщо інший кінець також використовує asyncio)."

#: ../../library/asyncio-protocol.rst:566
msgid ""
"This method may return a false value (including ``None``), in which case the "
"transport will close itself.  Conversely, if this method returns a true "
"value, the protocol used determines whether to close the transport. Since "
"the default implementation returns ``None``, it implicitly closes the "
"connection."
msgstr ""
"Цей метод може повернути хибне значення (включаючи ``None``), у цьому "
"випадку транспорт закриється сам. І навпаки, якщо цей метод повертає істинне "
"значення, протокол, який використовується, визначає, чи закривати транспорт. "
"Оскільки реалізація за замовчуванням повертає ``None``, вона неявно закриває "
"з’єднання."

#: ../../library/asyncio-protocol.rst:572
msgid ""
"Some transports, including SSL, don't support half-closed connections, in "
"which case returning true from this method will result in the connection "
"being closed."
msgstr ""
"Деякі транспортні засоби, включно з SSL, не підтримують напівзакриті "
"з’єднання, і в цьому випадку повернення true з цього методу призведе до "
"закриття з’єднання."

#: ../../library/asyncio-protocol.rst:577
#: ../../library/asyncio-protocol.rst:635
msgid "State machine:"
msgstr "Державна машина:"

#: ../../library/asyncio-protocol.rst:588
msgid "Buffered Streaming Protocols"
msgstr "Protocolos de Streaming Bufferizados"

#: ../../library/asyncio-protocol.rst:592
msgid ""
"Buffered Protocols can be used with any event loop method that supports "
"`Streaming Protocols`_."
msgstr ""
"Буферизовані протоколи можна використовувати з будь-яким методом циклу "
"подій, який підтримує `Streaming Protocols`_."

#: ../../library/asyncio-protocol.rst:595
msgid ""
"``BufferedProtocol`` implementations allow explicit manual allocation and "
"control of the receive buffer.  Event loops can then use the buffer provided "
"by the protocol to avoid unnecessary data copies.  This can result in "
"noticeable performance improvement for protocols that receive big amounts of "
"data.  Sophisticated protocol implementations can significantly reduce the "
"number of buffer allocations."
msgstr ""
"Реалізації ``BufferedProtocol`` дозволяють явно вручну розподіляти та "
"контролювати буфер отримання. Потім цикли подій можуть використовувати "
"буфер, наданий протоколом, щоб уникнути непотрібних копій даних. Це може "
"призвести до помітного підвищення продуктивності для протоколів, які "
"отримують великі обсяги даних. Складні реалізації протоколів можуть значно "
"зменшити кількість розподілів буферів."

#: ../../library/asyncio-protocol.rst:602
msgid ""
"The following callbacks are called on :class:`BufferedProtocol` instances:"
msgstr ""
"Наступні зворотні виклики викликаються в екземплярах :class:"
"`BufferedProtocol`:"

#: ../../library/asyncio-protocol.rst:607
msgid "Called to allocate a new receive buffer."
msgstr "Chamada para alocar um novo buffer para recebimento."

#: ../../library/asyncio-protocol.rst:609
msgid ""
"*sizehint* is the recommended minimum size for the returned buffer.  It is "
"acceptable to return smaller or larger buffers than what *sizehint* "
"suggests.  When set to -1, the buffer size can be arbitrary. It is an error "
"to return a buffer with a zero size."
msgstr ""
"*sizehint* — рекомендований мінімальний розмір для поверненого буфера. "
"Дозволено повертати менші або більші буфери, ніж пропонує *sizehint*. Якщо "
"встановлено значення -1, розмір буфера може бути довільним. Помилкою є "
"повернення буфера з нульовим розміром."

#: ../../library/asyncio-protocol.rst:614
msgid ""
"``get_buffer()`` must return an object implementing the :ref:`buffer "
"protocol <bufferobjects>`."
msgstr ""
"``get_buffer()`` має повертати об’єкт, що реалізує :ref:`протокол буфера "
"<bufferobjects>`."

#: ../../library/asyncio-protocol.rst:619
msgid "Called when the buffer was updated with the received data."
msgstr "Chamado quando o buffer foi atualizado com os dados recebidos."

#: ../../library/asyncio-protocol.rst:621
msgid "*nbytes* is the total number of bytes that were written to the buffer."
msgstr "*nbytes* — це загальна кількість байтів, які були записані в буфер."

#: ../../library/asyncio-protocol.rst:625
msgid ""
"See the documentation of the :meth:`protocol.eof_received() <Protocol."
"eof_received>` method."
msgstr ""
"Перегляньте документацію методу :meth:`protocol.eof_received() <Protocol."
"eof_received>`."

#: ../../library/asyncio-protocol.rst:629
msgid ""
":meth:`~BufferedProtocol.get_buffer` can be called an arbitrary number of "
"times during a connection.  However, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` is called at most once and, if called, :meth:"
"`~BufferedProtocol.get_buffer` and :meth:`~BufferedProtocol.buffer_updated` "
"won't be called after it."
msgstr ""
":meth:`~BufferedProtocol.get_buffer` можна викликати довільну кількість "
"разів під час з’єднання. Однак :meth:`protocol.eof_received() <Protocol."
"eof_received>` викликається щонайбільше один раз, і, якщо буде викликано, :"
"meth:`~BufferedProtocol.get_buffer` і :meth:`~BufferedProtocol."
"buffer_updated` не будуть викликатися після нього."

#: ../../library/asyncio-protocol.rst:648
msgid "Datagram Protocols"
msgstr "Protocolos de Datagramas"

#: ../../library/asyncio-protocol.rst:650
msgid ""
"Datagram Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.create_datagram_endpoint` method."
msgstr ""
"Екземпляри протоколу дейтаграм мають бути створені фабриками протоколів, "
"переданими в метод :meth:`loop.create_datagram_endpoint`."

#: ../../library/asyncio-protocol.rst:655
msgid ""
"Called when a datagram is received.  *data* is a bytes object containing the "
"incoming data.  *addr* is the address of the peer sending the data; the "
"exact format depends on the transport."
msgstr ""
"Викликається, коли отримано дейтаграму. *data* — це об’єкт bytes, що містить "
"вхідні дані. *addr* — це адреса вузла, який надсилає дані; точний формат "
"залежить від транспорту."

#: ../../library/asyncio-protocol.rst:661
msgid ""
"Called when a previous send or receive operation raises an :class:"
"`OSError`.  *exc* is the :class:`OSError` instance."
msgstr ""
"Викликається, коли попередня операція надсилання чи отримання викликає :"
"class:`OSError`. *exc* — це екземпляр :class:`OSError`."

#: ../../library/asyncio-protocol.rst:664
msgid ""
"This method is called in rare conditions, when the transport (e.g. UDP) "
"detects that a datagram could not be delivered to its recipient. In many "
"conditions though, undeliverable datagrams will be silently dropped."
msgstr ""
"Цей метод викликається в рідкісних випадках, коли транспорт (наприклад, UDP) "
"виявляє, що дейтаграму не вдалося доставити одержувачу. Однак у багатьох "
"випадках дейтаграми, які неможливо доставити, будуть мовчки видалені."

#: ../../library/asyncio-protocol.rst:671
msgid ""
"On BSD systems (macOS, FreeBSD, etc.) flow control is not supported for "
"datagram protocols, because there is no reliable way to detect send failures "
"caused by writing too many packets."
msgstr ""
"У системах BSD (macOS, FreeBSD тощо) керування потоком не підтримується для "
"протоколів дейтаграм, оскільки немає надійного способу виявити помилки "
"надсилання, спричинені записом занадто великої кількості пакетів."

#: ../../library/asyncio-protocol.rst:675
msgid ""
"The socket always appears 'ready' and excess packets are dropped. An :class:"
"`OSError` with ``errno`` set to :const:`errno.ENOBUFS` may or may not be "
"raised; if it is raised, it will be reported to :meth:`DatagramProtocol."
"error_received` but otherwise ignored."
msgstr ""
"Сокет завжди виглядає \"готовим\", а зайві пакети відкидаються. Помилка :"
"class:`OSEror` з ``errno`` встановленим на :const:`errno.ENOBUFS` може "
"виникати або не виникати; якщо воно піднято, про це буде повідомлено :meth:"
"`DatagramProtocol.error_received`, але в інших випадках воно буде "
"проігноровано."

#: ../../library/asyncio-protocol.rst:684
msgid "Subprocess Protocols"
msgstr "Protocolos de Subprocesso"

#: ../../library/asyncio-protocol.rst:686
msgid ""
"Subprocess Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` "
"methods."
msgstr ""
"Екземпляри протоколу підпроцесу мають бути створені фабриками протоколів, "
"переданими методам :meth:`loop.subprocess_exec` і :meth:`loop."
"subprocess_shell`."

#: ../../library/asyncio-protocol.rst:692
msgid ""
"Called when the child process writes data into its stdout or stderr pipe."
msgstr ""
"Викликається, коли дочірній процес записує дані в канал stdout або stderr."

#: ../../library/asyncio-protocol.rst:695
msgid "*fd* is the integer file descriptor of the pipe."
msgstr "*fd* — цілочисельний файловий дескриптор каналу."

#: ../../library/asyncio-protocol.rst:697
msgid "*data* is a non-empty bytes object containing the received data."
msgstr "*data* — об’єкт із непорожніми байтами, що містить отримані дані."

#: ../../library/asyncio-protocol.rst:701
msgid ""
"Called when one of the pipes communicating with the child process is closed."
msgstr ""
"Chamado quando um dos encadeamentos comunicando com o processo filho é "
"fechado."

#: ../../library/asyncio-protocol.rst:704
msgid "*fd* is the integer file descriptor that was closed."
msgstr "*fd* — цілочисельний файловий дескриптор, який було закрито."

#: ../../library/asyncio-protocol.rst:708
msgid "Called when the child process has exited."
msgstr "Chamado quando o processo filho encerrou."

#: ../../library/asyncio-protocol.rst:712
msgid "Examples"
msgstr "Exemplos"

#: ../../library/asyncio-protocol.rst:717
msgid "TCP Echo Server"
msgstr "TCP Echo Server"

#: ../../library/asyncio-protocol.rst:719
msgid ""
"Create a TCP echo server using the :meth:`loop.create_server` method, send "
"back received data, and close the connection::"
msgstr ""
"Створіть TCP-сервер ехо за допомогою методу :meth:`loop.create_server`, "
"надішліть назад отримані дані та закрийте з’єднання::"

#: ../../library/asyncio-protocol.rst:760
msgid ""
"The :ref:`TCP echo server using streams <asyncio-tcp-echo-server-streams>` "
"example uses the high-level :func:`asyncio.start_server` function."
msgstr ""
"У прикладі :ref:`TCP echo server using streams <asyncio-tcp-echo-server-"
"streams>` використовується функція :func:`asyncio.start_server` високого "
"рівня."

#: ../../library/asyncio-protocol.rst:766
msgid "TCP Echo Client"
msgstr "TCP Echo Client"

#: ../../library/asyncio-protocol.rst:768
msgid ""
"A TCP echo client using the :meth:`loop.create_connection` method, sends "
"data, and waits until the connection is closed::"
msgstr ""
"TCP-клієнт відлуння, використовуючи метод :meth:`loop.create_connection`, "
"надсилає дані та чекає, доки з’єднання не буде закрито::"

#: ../../library/asyncio-protocol.rst:816
msgid ""
"The :ref:`TCP echo client using streams <asyncio-tcp-echo-client-streams>` "
"example uses the high-level :func:`asyncio.open_connection` function."
msgstr ""
"У прикладі :ref:`TCP echo client using streams <asyncio-tcp-echo-client-"
"streams>` використовується функція :func:`asyncio.open_connection` високого "
"рівня."

#: ../../library/asyncio-protocol.rst:823
msgid "UDP Echo Server"
msgstr "Сервер UDP Echo"

#: ../../library/asyncio-protocol.rst:825
msgid ""
"A UDP echo server, using the :meth:`loop.create_datagram_endpoint` method, "
"sends back received data::"
msgstr ""
"Ехо-сервер UDP за допомогою методу :meth:`loop.create_datagram_endpoint` "
"повертає отримані дані:"

#: ../../library/asyncio-protocol.rst:867
msgid "UDP Echo Client"
msgstr "UDP Echo Client"

#: ../../library/asyncio-protocol.rst:869
msgid ""
"A UDP echo client, using the :meth:`loop.create_datagram_endpoint` method, "
"sends data and closes the transport when it receives the answer::"
msgstr ""
"Ехо-клієнт UDP, використовуючи метод :meth:`loop.create_datagram_endpoint`, "
"надсилає дані та закриває транспорт, коли отримує відповідь:"

#: ../../library/asyncio-protocol.rst:924
msgid "Connecting Existing Sockets"
msgstr "Підключення наявних розеток"

#: ../../library/asyncio-protocol.rst:926
msgid ""
"Wait until a socket receives data using the :meth:`loop.create_connection` "
"method with a protocol::"
msgstr ""
"Зачекайте, поки сокет отримає дані за допомогою методу :meth:`loop."
"create_connection` з протоколом::"

#: ../../library/asyncio-protocol.rst:980
msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level :meth:`loop."
"add_reader` method to register an FD."
msgstr ""
"У прикладі :ref:`спостерігати за файловим дескриптором для подій читання "
"<asyncio_example_watch_fd>` використовується метод низького рівня :meth:"
"`loop.add_reader` для реєстрації FD."

#: ../../library/asyncio-protocol.rst:984
msgid ""
"The :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` example uses high-level streams "
"created by the :func:`open_connection` function in a coroutine."
msgstr ""
"У прикладі :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` використовуються потоки "
"високого рівня, створені функцією :func:`open_connection` у співпрограмі."

#: ../../library/asyncio-protocol.rst:991
msgid "loop.subprocess_exec() and SubprocessProtocol"
msgstr "loop.subprocess_exec() і SubprocessProtocol"

#: ../../library/asyncio-protocol.rst:993
msgid ""
"An example of a subprocess protocol used to get the output of a subprocess "
"and to wait for the subprocess exit."
msgstr ""
"Приклад протоколу підпроцесу, який використовується для отримання "
"результатів підпроцесу та очікування виходу підпроцесу."

#: ../../library/asyncio-protocol.rst:996
msgid "The subprocess is created by the :meth:`loop.subprocess_exec` method::"
msgstr "Підпроцес створюється методом :meth:`loop.subprocess_exec`::"

#: ../../library/asyncio-protocol.rst:1042
msgid ""
"See also the :ref:`same example <asyncio_example_create_subprocess_exec>` "
"written using high-level APIs."
msgstr ""
"Дивіться також :ref:`той самий приклад "
"<asyncio_example_create_subprocess_exec>`, написаний з використанням API "
"високого рівня."

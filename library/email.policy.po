# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2017
# Marco Rougeth <marco@rougeth.com>, 2020
# i17obot <i17obot@rougeth.com>, 2020
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 17:51+0000\n"
"PO-Revision-Date: 2017-02-16 23:09+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/email.policy.rst:2
msgid ":mod:`email.policy`: Policy Objects"
msgstr ":mod:`email.policy`: Об’єкти політики"

#: ../../library/email.policy.rst:12
msgid "**Source code:** :source:`Lib/email/policy.py`"
msgstr "**Código-fonte:** :source:`Lib/email/policy.py`"

#: ../../library/email.policy.rst:16
msgid ""
"The :mod:`email` package's prime focus is the handling of email messages as "
"described by the various email and MIME RFCs.  However, the general format "
"of email messages (a block of header fields each consisting of a name "
"followed by a colon followed by a value, the whole block followed by a blank "
"line and an arbitrary 'body'), is a format that has found utility outside of "
"the realm of email.  Some of these uses conform fairly closely to the main "
"email RFCs, some do not.  Even when working with email, there are times when "
"it is desirable to break strict compliance with the RFCs, such as generating "
"emails that interoperate with email servers that do not themselves follow "
"the standards, or that implement extensions you want to use in ways that "
"violate the standards."
msgstr ""
"Пакунок :mod:`email` головним чином зосереджується на обробці повідомлень "
"електронної пошти, як описано в різних RFC електронної пошти та MIME. Однак "
"загальний формат повідомлень електронної пошти (блок полів заголовка, кожне "
"з яких складається з назви, за якою йде двокрапка, за якою йде значення, "
"весь блок, після якого йде порожній рядок і довільний \"тіло\"), — це "
"формат, який знайшов утиліта за межами сфери електронної пошти. Деякі з цих "
"способів використання досить точно відповідають основним RFC електронної "
"пошти, інші – ні. Навіть під час роботи з електронною поштою бувають "
"випадки, коли бажано порушити сувору відповідність RFC, наприклад, "
"створювати електронні листи, які взаємодіють із серверами електронної пошти, "
"які самі по собі не дотримуються стандартів, або які реалізують розширення, "
"які ви хочете використовувати, у спосіб, який порушує стандарти."

#: ../../library/email.policy.rst:28
msgid ""
"Policy objects give the email package the flexibility to handle all these "
"disparate use cases."
msgstr ""
"Об’єкти політики надають пакету електронної пошти гнучкість для обробки всіх "
"цих різнорідних випадків використання."

#: ../../library/email.policy.rst:31
msgid ""
"A :class:`Policy` object encapsulates a set of attributes and methods that "
"control the behavior of various components of the email package during use. :"
"class:`Policy` instances can be passed to various classes and methods in the "
"email package to alter the default behavior.  The settable values and their "
"defaults are described below."
msgstr ""
"Об’єкт :class:`Policy` інкапсулює набір атрибутів і методів, які контролюють "
"поведінку різних компонентів пакета електронної пошти під час використання. "
"Екземпляри :class:`Policy` можна передати різним класам і методам у пакеті "
"електронної пошти, щоб змінити типову поведінку. Нижче описано встановлені "
"значення та їх значення за замовчуванням."

#: ../../library/email.policy.rst:37
msgid ""
"There is a default policy used by all classes in the email package.  For all "
"of the :mod:`~email.parser` classes and the related convenience functions, "
"and for the :class:`~email.message.Message` class, this is the :class:"
"`Compat32` policy, via its corresponding pre-defined instance :const:"
"`compat32`.  This policy provides for complete backward compatibility (in "
"some cases, including bug compatibility) with the pre-Python3.3 version of "
"the email package."
msgstr ""
"Існує політика за замовчуванням, яка використовується всіма класами в пакеті "
"електронної пошти. Для всіх класів :mod:`~email.parser` і відповідних "
"функцій зручності, а також для класу :class:`~email.message.Message`, це "
"політика :class:`Compat32` через відповідну політику попередньо визначений "
"екземпляр :const:`compat32`. Ця політика забезпечує повну зворотну "
"сумісність (у деяких випадках, включаючи сумісність із помилками) із версією "
"пакета електронної пошти до Python3.3."

#: ../../library/email.policy.rst:44
msgid ""
"This default value for the *policy* keyword to :class:`~email.message."
"EmailMessage` is the :class:`EmailPolicy` policy, via its pre-defined "
"instance :data:`~default`."
msgstr ""
"Це значення за умовчанням для ключового слова *policy* для :class:`~email."
"message.EmailMessage` є політикою :class:`EmailPolicy` через її попередньо "
"визначений екземпляр :data:`~default`."

#: ../../library/email.policy.rst:48
msgid ""
"When a :class:`~email.message.Message` or :class:`~email.message."
"EmailMessage` object is created, it acquires a policy.  If the message is "
"created by a :mod:`~email.parser`, a policy passed to the parser will be the "
"policy used by the message it creates.  If the message is created by the "
"program, then the policy can be specified when it is created.  When a "
"message is passed to a :mod:`~email.generator`, the generator uses the "
"policy from the message by default, but you can also pass a specific policy "
"to the generator that will override the one stored on the message object."
msgstr ""
"Коли створюється об’єкт :class:`~email.message.Message` або :class:`~email."
"message.EmailMessage`, він отримує політику. Якщо повідомлення створено :mod:"
"`~email.parser`, політика, передана аналізатору, буде політикою, яка "
"використовується у створеному ним повідомленні. Якщо повідомлення "
"створюється програмою, то під час його створення можна вказати політику. "
"Коли повідомлення передається до :mod:`~email.generator`, генератор "
"використовує політику з повідомлення за замовчуванням, але ви також можете "
"передати певну політику генератору, яка замінить політику, збережену в "
"об’єкті повідомлення."

#: ../../library/email.policy.rst:57
msgid ""
"The default value for the *policy* keyword for the :mod:`email.parser` "
"classes and the parser convenience functions **will be changing** in a "
"future version of Python.  Therefore you should **always specify explicitly "
"which policy you want to use** when calling any of the classes and functions "
"described in the :mod:`~email.parser` module."
msgstr ""
"Значення за замовчуванням для ключового слова *policy* для класів :mod:"
"`email.parser` і зручних функцій синтаксичного аналізатора **буде змінено** "
"в наступній версії Python. Тому ви повинні **завжди чітко вказувати, яку "
"політику ви хочете використовувати** під час виклику будь-якого з класів і "
"функцій, описаних у модулі :mod:`~email.parser`."

#: ../../library/email.policy.rst:63
msgid ""
"The first part of this documentation covers the features of :class:`Policy`, "
"an :term:`abstract base class` that defines the features that are common to "
"all policy objects, including :const:`compat32`.  This includes certain hook "
"methods that are called internally by the email package, which a custom "
"policy could override to obtain different behavior.  The second part "
"describes the concrete classes :class:`EmailPolicy` and :class:`Compat32`, "
"which implement the hooks that provide the standard behavior and the "
"backward compatible behavior and features, respectively."
msgstr ""
"Перша частина цієї документації охоплює функції :class:`Policy`, :term:"
"`abstract base class`, який визначає функції, спільні для всіх об’єктів "
"політики, включаючи :const:`compat32`. Це включає в себе певні методи "
"підключення, які викликаються внутрішньо пакетом електронної пошти, які "
"спеціальна політика може замінити, щоб отримати іншу поведінку. Друга "
"частина описує конкретні класи :class:`EmailPolicy` і :class:`Compat32`, які "
"реалізують хуки, які забезпечують стандартну поведінку та зворотну "
"сумісність і функції відповідно."

#: ../../library/email.policy.rst:72
msgid ""
":class:`Policy` instances are immutable, but they can be cloned, accepting "
"the same keyword arguments as the class constructor and returning a new :"
"class:`Policy` instance that is a copy of the original but with the "
"specified attributes values changed."
msgstr ""
"Екземпляри :class:`Policy` незмінні, але їх можна клонувати, приймаючи ті "
"самі аргументи ключового слова, що й конструктор класу, і повертаючи новий "
"екземпляр :class:`Policy`, який є копією оригіналу, але зі зміненими "
"значеннями вказаних атрибутів ."

#: ../../library/email.policy.rst:77
msgid ""
"As an example, the following code could be used to read an email message "
"from a file on disk and pass it to the system ``sendmail`` program on a Unix "
"system:"
msgstr ""
"Як приклад, наступний код можна використати для читання повідомлення "
"електронної пошти з файлу на диску та передачі його системній програмі "
"``sendmail`` в системі Unix:"

#: ../../library/email.policy.rst:113
msgid ""
"Here we are telling :class:`~email.generator.BytesGenerator` to use the RFC "
"correct line separator characters when creating the binary string to feed "
"into ``sendmail's`` ``stdin``, where the default policy would use ``\\n`` "
"line separators."
msgstr ""
"Тут ми повідомляємо :class:`~email.generator.BytesGenerator` використовувати "
"правильні символи роздільників рядків RFC під час створення двійкового рядка "
"для передачі в ``stdin`` ``sendmail``, де політика за замовчуванням "
"використовуватиме ``\\n`` роздільники рядків."

#: ../../library/email.policy.rst:118
msgid ""
"Some email package methods accept a *policy* keyword argument, allowing the "
"policy to be overridden for that method.  For example, the following code "
"uses the :meth:`~email.message.Message.as_bytes` method of the *msg* object "
"from the previous example and writes the message to a file using the native "
"line separators for the platform on which it is running::"
msgstr ""
"Деякі методи пакетів електронної пошти приймають аргумент ключового слова "
"*policy*, що дозволяє перевизначати політику для цього методу. Наприклад, у "
"наступному коді використовується метод :meth:`~email.message.Message."
"as_bytes` об’єкта *msg* із попереднього прикладу та записує повідомлення у "
"файл, використовуючи рідні розділювачі рядків для платформи, на якій воно "
"біжить::"

#: ../../library/email.policy.rst:129
msgid ""
"Policy objects can also be combined using the addition operator, producing a "
"policy object whose settings are a combination of the non-default values of "
"the summed objects::"
msgstr ""
"Об’єкти політики також можна комбінувати за допомогою оператора додавання, "
"утворюючи об’єкт політики, параметри якого є комбінацією нестандартних "
"значень сумованих об’єктів::"

#: ../../library/email.policy.rst:137
msgid ""
"This operation is not commutative; that is, the order in which the objects "
"are added matters.  To illustrate::"
msgstr ""
"Ця операція не є комутативною; тобто порядок, у якому додаються об’єкти, має "
"значення. Проілюструвати::"

#: ../../library/email.policy.rst:152
msgid ""
"This is the :term:`abstract base class` for all policy classes.  It provides "
"default implementations for a couple of trivial methods, as well as the "
"implementation of the immutability property, the :meth:`clone` method, and "
"the constructor semantics."
msgstr ""
"Це :term:`abstract base class` для всіх класів політики. Він забезпечує "
"реалізацію за замовчуванням для кількох тривіальних методів, а також "
"реалізацію властивості незмінності, метод :meth:`clone` і семантику "
"конструктора."

#: ../../library/email.policy.rst:157
msgid ""
"The constructor of a policy class can be passed various keyword arguments. "
"The arguments that may be specified are any non-method properties on this "
"class, plus any additional non-method properties on the concrete class.  A "
"value specified in the constructor will override the default value for the "
"corresponding attribute."
msgstr ""
"Конструктору класу політики можна передати різні ключові аргументи. "
"Аргументами, які можна вказати, є будь-які неметодні властивості цього "
"класу, а також будь-які додаткові неметодні властивості конкретного класу. "
"Значення, указане в конструкторі, замінить значення за замовчуванням для "
"відповідного атрибута."

#: ../../library/email.policy.rst:163
msgid ""
"This class defines the following properties, and thus values for the "
"following may be passed in the constructor of any policy class:"
msgstr ""
"Цей клас визначає наступні властивості, і, отже, значення для наступного "
"можна передати в конструктор будь-якого класу політики:"

#: ../../library/email.policy.rst:169
msgid ""
"The maximum length of any line in the serialized output, not counting the "
"end of line character(s).  Default is 78, per :rfc:`5322`.  A value of ``0`` "
"or :const:`None` indicates that no line wrapping should be done at all."
msgstr ""
"Максимальна довжина будь-якого рядка в серіалізованому виведенні, не "
"враховуючи символ(и) кінця рядка. За замовчуванням 78 відповідно до :rfc:"
"`5322`. Значення ``0`` або :const:`None` вказує на те, що перенесення рядків "
"не потрібно виконувати взагалі."

#: ../../library/email.policy.rst:177
msgid ""
"The string to be used to terminate lines in serialized output.  The default "
"is ``\\n`` because that's the internal end-of-line discipline used by "
"Python, though ``\\r\\n`` is required by the RFCs."
msgstr ""
"Рядок, який буде використовуватися для завершення рядків у серіалізованому "
"виведенні. Типовим є ``\\n``, оскільки це внутрішня дисципліна кінця рядка, "
"яка використовується Python, хоча ``\\r\\n`` вимагається RFC."

#: ../../library/email.policy.rst:184
msgid ""
"Controls the type of Content Transfer Encodings that may be or are required "
"to be used.  The possible values are:"
msgstr ""
"Керує типом кодувань передачі вмісту, які можуть або повинні "
"використовуватися. Можливі значення:"

#: ../../library/email.policy.rst:190
msgid "``7bit``"
msgstr "``7bit``"

#: ../../library/email.policy.rst:190
msgid ""
"all data must be \"7 bit clean\" (ASCII-only).  This means that where "
"necessary data will be encoded using either quoted-printable or base64 "
"encoding."
msgstr ""
"усі дані мають бути \"7-бітними чистими\" (лише ASCII). Це означає, що там, "
"де це необхідно, дані будуть закодовані з використанням кодування для друку "
"в цитатах або кодування base64."

#: ../../library/email.policy.rst:194
msgid "``8bit``"
msgstr "``8bit``"

#: ../../library/email.policy.rst:194
msgid ""
"data is not constrained to be 7 bit clean.  Data in headers is still "
"required to be ASCII-only and so will be encoded (see :meth:`fold_binary` "
"and :attr:`~EmailPolicy.utf8` below for exceptions), but body parts may use "
"the ``8bit`` CTE."
msgstr ""
"дані не мають обмежень бути чистими 7 біт. Дані в заголовках, як і раніше, "
"повинні бути лише ASCII, тому вони будуть закодовані (див. :meth:"
"`fold_binary` і :attr:`~EmailPolicy.utf8` нижче для винятків), але частини "
"тіла можуть використовувати ``8bit`` CTE."

#: ../../library/email.policy.rst:200
msgid ""
"A ``cte_type`` value of ``8bit`` only works with ``BytesGenerator``, not "
"``Generator``, because strings cannot contain binary data.  If a "
"``Generator`` is operating under a policy that specifies ``cte_type=8bit``, "
"it will act as if ``cte_type`` is ``7bit``."
msgstr ""
"Значення ``cte_type`` ``8bit`` працює лише з ``BytesGenerator``, а не "
"``Generator``, оскільки рядки не можуть містити двійкові дані. Якщо "
"``генератор`` працює відповідно до політики, яка визначає ``cte_type=8bit``, "
"він діятиме так, ніби ``cte_type`` має значення ``7bit``."

#: ../../library/email.policy.rst:208
msgid ""
"If :const:`True`, any defects encountered will be raised as errors.  If :"
"const:`False` (the default), defects will be passed to the :meth:"
"`register_defect` method."
msgstr ""
"Якщо :const:`True`, будь-які виявлені дефекти визначатимуться як помилки. "
"Якщо :const:`False` (за замовчуванням), дефекти будуть передані в метод :"
"meth:`register_defect`."

#: ../../library/email.policy.rst:215
msgid ""
"If :const:`True`, lines starting with *\"From \"* in the body are escaped by "
"putting a ``>`` in front of them. This parameter is used when the message is "
"being serialized by a generator. Default: :const:`False`."
msgstr ""
"Якщо :const:`True`, рядки, що починаються з *\"From \"* у тілі, екрануються "
"шляхом розміщення ``>`` перед ними. Цей параметр використовується, коли "
"повідомлення серіалізується генератором. Типове значення: :const:`False`."

#: ../../library/email.policy.rst:220
msgid "The *mangle_from_* parameter."
msgstr "O parâmetro *mangle_from_*."

#: ../../library/email.policy.rst:226
msgid ""
"A factory function for constructing a new empty message object.  Used by the "
"parser when building messages.  Defaults to ``None``, in which case :class:"
"`~email.message.Message` is used."
msgstr ""
"Фабрична функція для створення нового порожнього об’єкта повідомлення. "
"Використовується аналізатором під час створення повідомлень. За "
"замовчуванням ``None``, у цьому випадку використовується :class:`~email."
"message.Message`."

#: ../../library/email.policy.rst:235
msgid ""
"If ``True`` (the default), the generator will raise :exc:`~email.errors."
"HeaderWriteError` instead of writing a header that is improperly folded or "
"delimited, such that it would be parsed as multiple headers or joined with "
"adjacent data. Such headers can be generated by custom header classes or "
"bugs in the ``email`` module."
msgstr ""
"Если ``True`` (по умолчанию), генератор выдаст :exc:`~email.errors."
"HeaderWriteError` вместо записи заголовка, который неправильно сложен или "
"разделен, так что он будет анализироваться как несколько заголовков или "
"объединяться с помощью соседние данные. Такие заголовки могут быть созданы с "
"помощью пользовательских классов заголовков или ошибок в модуле электронной "
"почты."

#: ../../library/email.policy.rst:242
msgid ""
"As it's a security feature, this defaults to ``True`` even in the :class:"
"`~email.policy.Compat32` policy. For backwards compatible, but unsafe, "
"behavior, it must be set to ``False`` explicitly."
msgstr ""
"Поскольку это функция безопасности, по умолчанию для нее установлено "
"значение True даже в политике :class:`~email.policy.Compat32`. Для обратно "
"совместимого, но небезопасного поведения необходимо явно установить значение "
"False."

#: ../../library/email.policy.rst:250
msgid ""
"The following :class:`Policy` method is intended to be called by code using "
"the email library to create policy instances with custom settings:"
msgstr ""
"Наступний метод :class:`Policy` призначений для виклику за допомогою коду за "
"допомогою бібліотеки електронної пошти для створення екземплярів політики з "
"настроюваними налаштуваннями:"

#: ../../library/email.policy.rst:256
msgid ""
"Return a new :class:`Policy` instance whose attributes have the same values "
"as the current instance, except where those attributes are given new values "
"by the keyword arguments."
msgstr ""
"Повертає новий екземпляр :class:`Policy`, атрибути якого мають ті самі "
"значення, що й поточний екземпляр, за винятком тих випадків, коли ці "
"атрибути отримують нові значення аргументами ключового слова."

#: ../../library/email.policy.rst:261
msgid ""
"The remaining :class:`Policy` methods are called by the email package code, "
"and are not intended to be called by an application using the email package. "
"A custom policy must implement all of these methods."
msgstr ""
"Решта методів :class:`Policy` викликається кодом пакета електронної пошти і "
"не призначена для виклику програмою, яка використовує пакет електронної "
"пошти. Спеціальна політика повинна реалізовувати всі ці методи."

#: ../../library/email.policy.rst:268
msgid ""
"Handle a *defect* found on *obj*.  When the email package calls this method, "
"*defect* will always be a subclass of :class:`~email.errors.Defect`."
msgstr ""
"Виправити *дефект*, знайдений на *obj*. Коли пакет електронної пошти "
"викликає цей метод, *defect* завжди буде підкласом :class:`~email.errors."
"Defect`."

#: ../../library/email.policy.rst:272
msgid ""
"The default implementation checks the :attr:`raise_on_defect` flag.  If it "
"is ``True``, *defect* is raised as an exception.  If it is ``False`` (the "
"default), *obj* and *defect* are passed to :meth:`register_defect`."
msgstr ""
"Стандартна реалізація перевіряє прапорець :attr:`raise_on_defect`. Якщо "
"значення ``True``, *defect* створюється як виняток. Якщо значення ``False`` "
"(за замовчуванням), *obj* і *defect* передаються в :meth:`register_defect`."

#: ../../library/email.policy.rst:279
msgid ""
"Register a *defect* on *obj*.  In the email package, *defect* will always be "
"a subclass of :class:`~email.errors.Defect`."
msgstr ""
"Зареєструйте *дефект* на *obj*. У пакеті електронної пошти *defect* завжди "
"буде підкласом :class:`~email.errors.Defect`."

#: ../../library/email.policy.rst:282
msgid ""
"The default implementation calls the ``append`` method of the ``defects`` "
"attribute of *obj*.  When the email package calls :attr:`handle_defect`, "
"*obj* will normally have a ``defects`` attribute that has an ``append`` "
"method.  Custom object types used with the email package (for example, "
"custom ``Message`` objects) should also provide such an attribute, otherwise "
"defects in parsed messages will raise unexpected errors."
msgstr ""
"Стандартна реалізація викликає метод ``append`` атрибута ``defects`` *obj*. "
"Коли пакет електронної пошти викликає :attr:`handle_defect`, *obj* зазвичай "
"матиме атрибут ``defects``, який має метод ``append``. Спеціальні типи "
"об’єктів, які використовуються з пакетом електронної пошти (наприклад, "
"спеціальні об’єкти ``Message``), також повинні надавати такий атрибут, "
"інакше дефекти в проаналізованих повідомленнях призведуть до неочікуваних "
"помилок."

#: ../../library/email.policy.rst:292
msgid "Return the maximum allowed number of headers named *name*."
msgstr "Повертає максимально дозволену кількість заголовків із назвою *ім’я*."

#: ../../library/email.policy.rst:294
msgid ""
"Called when a header is added to an :class:`~email.message.EmailMessage` or :"
"class:`~email.message.Message` object.  If the returned value is not ``0`` "
"or ``None``, and there are already a number of headers with the name *name* "
"greater than or equal to the value returned, a :exc:`ValueError` is raised."
msgstr ""
"Викликається, коли заголовок додається до об’єкта :class:`~email.message."
"EmailMessage` або :class:`~email.message.Message`. Якщо повернуте значення "
"не є ``0`` або ``None``, і вже існує кількість заголовків з іменем *name*, "
"більшим або рівним поверненому значенню, виникає :exc:`ValueError` ."

#: ../../library/email.policy.rst:300
msgid ""
"Because the default behavior of ``Message.__setitem__`` is to append the "
"value to the list of headers, it is easy to create duplicate headers without "
"realizing it.  This method allows certain headers to be limited in the "
"number of instances of that header that may be added to a ``Message`` "
"programmatically.  (The limit is not observed by the parser, which will "
"faithfully produce as many headers as exist in the message being parsed.)"
msgstr ""
"Оскільки за замовчуванням ``Message.__setitem__`` додає значення до списку "
"заголовків, легко створити дублікати заголовків, не усвідомлюючи цього. Цей "
"метод дозволяє обмежити певні заголовки в кількості екземплярів цього "
"заголовка, які можна додати до ``повідомлення`` програмним шляхом. "
"(Обмеження не дотримується синтаксичним аналізатором, який сумлінно створить "
"стільки заголовків, скільки існує в повідомленні, що аналізується.)"

#: ../../library/email.policy.rst:308
msgid "The default implementation returns ``None`` for all header names."
msgstr ""
"Реалізація за замовчуванням повертає ``None`` для всіх імен заголовків."

#: ../../library/email.policy.rst:313
msgid ""
"The email package calls this method with a list of strings, each string "
"ending with the line separation characters found in the source being "
"parsed.  The first line includes the field header name and separator. All "
"whitespace in the source is preserved.  The method should return the "
"``(name, value)`` tuple that is to be stored in the ``Message`` to represent "
"the parsed header."
msgstr ""
"Пакет електронної пошти викликає цей метод зі списком рядків, кожен рядок "
"закінчується символами розділення рядків, знайденими в джерелі, що "
"аналізується. Перший рядок містить назву заголовка поля та роздільник. Усі "
"пробіли в джерелі збережено. Метод має повертати кортеж ``(name, value)``, "
"який має зберігатися в ``Message`` для представлення аналізованого заголовка."

#: ../../library/email.policy.rst:320
msgid ""
"If an implementation wishes to retain compatibility with the existing email "
"package policies, *name* should be the case preserved name (all characters "
"up to the '``:``' separator), while *value* should be the unfolded value "
"(all line separator characters removed, but whitespace kept intact), "
"stripped of leading whitespace."
msgstr ""
"Якщо реалізація бажає зберегти сумісність із існуючими політиками пакетів "
"електронної пошти, *ім’я* має бути ім’ям із збереженням регістру (усі "
"символи до роздільника \"``:``), тоді як *значення* має бути розгорнутим "
"значенням (усі символи-роздільники рядків видалено, але пробіли збережено "
"без змін), видалено пробіли на початку."

#: ../../library/email.policy.rst:326
msgid "*sourcelines* may contain surrogateescaped binary data."
msgstr "*вихідні лінії* можуть містити сурогатні двійкові дані."

#: ../../library/email.policy.rst:328 ../../library/email.policy.rst:344
#: ../../library/email.policy.rst:360
msgid "There is no default implementation"
msgstr "Реалізації за замовчуванням немає"

#: ../../library/email.policy.rst:333
msgid ""
"The email package calls this method with the name and value provided by the "
"application program when the application program is modifying a ``Message`` "
"programmatically (as opposed to a ``Message`` created by a parser).  The "
"method should return the ``(name, value)`` tuple that is to be stored in the "
"``Message`` to represent the header."
msgstr ""
"Пакет електронної пошти викликає цей метод із назвою та значенням, наданими "
"прикладною програмою, коли прикладна програма програмно змінює "
"``повідомлення`` (на відміну від ``повідомлення``, створеного аналізатором). "
"Метод має повертати кортеж ``(name, value)``, який має зберігатися в "
"``Message`` для представлення заголовка."

#: ../../library/email.policy.rst:339
msgid ""
"If an implementation wishes to retain compatibility with the existing email "
"package policies, the *name* and *value* should be strings or string "
"subclasses that do not change the content of the passed in arguments."
msgstr ""
"Якщо реалізація бажає зберегти сумісність із існуючими політиками пакетів "
"електронної пошти, *ім’я* та *значення* мають бути рядками або підкласами "
"рядків, які не змінюють вміст переданих аргументів."

#: ../../library/email.policy.rst:349
msgid ""
"The email package calls this method with the *name* and *value* currently "
"stored in the ``Message`` when that header is requested by the application "
"program, and whatever the method returns is what is passed back to the "
"application as the value of the header being retrieved. Note that there may "
"be more than one header with the same name stored in the ``Message``; the "
"method is passed the specific name and value of the header destined to be "
"returned to the application."
msgstr ""
"Пакет електронної пошти викликає цей метод із *ім’ям* і *значенням*, які "
"наразі зберігаються в ``Message``, коли прикладна програма запитує цей "
"заголовок, і те, що метод повертає, передається назад до програми як "
"значення заголовка, що витягується. Зауважте, що в ``Повідомленні`` може "
"бути більше одного заголовка з однаковою назвою; методу передається "
"конкретне ім'я та значення заголовка, призначеного для повернення до "
"програми."

#: ../../library/email.policy.rst:357
msgid ""
"*value* may contain surrogateescaped binary data.  There should be no "
"surrogateescaped binary data in the value returned by the method."
msgstr ""
"*значення* може містити сурогатні екрановані двійкові дані. У значенні, яке "
"повертає метод, не повинно бути сурогатних двійкових даних."

#: ../../library/email.policy.rst:365
msgid ""
"The email package calls this method with the *name* and *value* currently "
"stored in the ``Message`` for a given header.  The method should return a "
"string that represents that header \"folded\" correctly (according to the "
"policy settings) by composing the *name* with the *value* and inserting :"
"attr:`linesep` characters at the appropriate places.  See :rfc:`5322` for a "
"discussion of the rules for folding email headers."
msgstr ""
"Пакет електронної пошти викликає цей метод із *ім’ям* і *значенням*, які "
"наразі зберігаються в ``Повідомленні`` для заданого заголовка. Метод має "
"повернути рядок, який представляє цей заголовок, \"згорнутий\" правильно "
"(відповідно до налаштувань політики), складаючи *ім’я* з *значенням* і "
"вставляючи символи :attr:`linesep` у відповідних місцях. Перегляньте :rfc:"
"`5322` для обговорення правил згортання заголовків електронних листів."

#: ../../library/email.policy.rst:372
msgid ""
"*value* may contain surrogateescaped binary data.  There should be no "
"surrogateescaped binary data in the string returned by the method."
msgstr ""
"*значення* може містити сурогатні екрановані двійкові дані. У рядку, який "
"повертає метод, не повинно бути сурогатних двійкових даних."

#: ../../library/email.policy.rst:378
msgid ""
"The same as :meth:`fold`, except that the returned value should be a bytes "
"object rather than a string."
msgstr ""
"Те саме, що :meth:`fold`, за винятком того, що повернуте значення має бути "
"об’єктом bytes, а не рядком."

#: ../../library/email.policy.rst:381
msgid ""
"*value* may contain surrogateescaped binary data.  These could be converted "
"back into binary data in the returned bytes object."
msgstr ""
"*значення* може містити сурогатні екрановані двійкові дані. Вони можуть бути "
"перетворені назад у двійкові дані у повернутому об’єкті bytes."

#: ../../library/email.policy.rst:388
msgid ""
"This concrete :class:`Policy` provides behavior that is intended to be fully "
"compliant with the current email RFCs.  These include (but are not limited "
"to) :rfc:`5322`, :rfc:`2047`, and the current MIME RFCs."
msgstr ""
"Ця конкретна :class:`Policy` забезпечує поведінку, яка повністю відповідає "
"поточним RFC електронної пошти. До них належать (але не обмежуються ними) :"
"rfc:`5322`, :rfc:`2047` і поточні RFC MIME."

#: ../../library/email.policy.rst:392
msgid ""
"This policy adds new header parsing and folding algorithms.  Instead of "
"simple strings, headers are ``str`` subclasses with attributes that depend "
"on the type of the field.  The parsing and folding algorithm fully "
"implement :rfc:`2047` and :rfc:`5322`."
msgstr ""
"Ця політика додає нові алгоритми аналізу та згортання заголовків. Замість "
"простих рядків, заголовки є підкласами ``str`` з атрибутами, які залежать "
"від типу поля. Алгоритм аналізу та згортання повністю реалізує :rfc:`2047` "
"і :rfc:`5322`."

#: ../../library/email.policy.rst:397
msgid ""
"The default value for the :attr:`~email.policy.Policy.message_factory` "
"attribute is :class:`~email.message.EmailMessage`."
msgstr ""
"Значенням за замовчуванням атрибута :attr:`~email.policy.Policy."
"message_factory` є :class:`~email.message.EmailMessage`."

#: ../../library/email.policy.rst:400
msgid ""
"In addition to the settable attributes listed above that apply to all "
"policies, this policy adds the following additional attributes:"
msgstr ""
"На додаток до перерахованих вище настроюваних атрибутів, які застосовуються "
"до всіх політик, ця політика додає такі додаткові атрибути:"

#: ../../library/email.policy.rst:403
msgid "[1]_"
msgstr "[1]_"

#: ../../library/email.policy.rst:408
msgid ""
"If ``False``, follow :rfc:`5322`, supporting non-ASCII characters in headers "
"by encoding them as \"encoded words\".  If ``True``, follow :rfc:`6532` and "
"use ``utf-8`` encoding for headers.  Messages formatted in this way may be "
"passed to SMTP servers that support the ``SMTPUTF8`` extension (:rfc:`6531`)."
msgstr ""
"Якщо ``False``, дотримуйтесь :rfc:`5322`, підтримуючи символи, відмінні від "
"ASCII, у заголовках, кодуючи їх як \"закодовані слова\". Якщо ``True``, "
"слідуйте :rfc:`6532` і використовуйте ``utf-8`` кодування для заголовків. "
"Повідомлення, відформатовані таким чином, можуть передаватися на сервери "
"SMTP, які підтримують розширення ``SMTPUTF8`` (:rfc:`6531`)."

#: ../../library/email.policy.rst:417
msgid ""
"If the value for a header in the ``Message`` object originated from a :mod:"
"`~email.parser` (as opposed to being set by a program), this attribute "
"indicates whether or not a generator should refold that value when "
"transforming the message back into serialized form.  The possible values are:"
msgstr ""
"Якщо значення для заголовка в об’єкті ``Message`` походить від :mod:`~email."
"parser` (на відміну від встановлення програмою), цей атрибут вказує, чи "
"повинен генератор повторно згортати це значення, коли перетворення "
"повідомлення назад у серіалізовану форму. Можливі значення:"

#: ../../library/email.policy.rst:424
msgid "``none``"
msgstr "``none``"

#: ../../library/email.policy.rst:424
msgid "all source values use original folding"
msgstr "усі вихідні значення використовують оригінальне згортання"

#: ../../library/email.policy.rst:426
msgid "``long``"
msgstr "``long``"

#: ../../library/email.policy.rst:426
msgid ""
"source values that have any line that is longer than ``max_line_length`` "
"will be refolded"
msgstr ""
"вихідні значення, які мають будь-який рядок, довший за ``max_line_length``, "
"будуть повторно згорнуті"

#: ../../library/email.policy.rst:429
msgid "``all``"
msgstr "``all``"

#: ../../library/email.policy.rst:429
msgid "all values are refolded."
msgstr "todos os valores são redobrados."

#: ../../library/email.policy.rst:432
msgid "The default is ``long``."
msgstr "O padrão é ``long``."

#: ../../library/email.policy.rst:437
msgid ""
"A callable that takes two arguments, ``name`` and ``value``, where ``name`` "
"is a header field name and ``value`` is an unfolded header field value, and "
"returns a string subclass that represents that header.  A default "
"``header_factory`` (see :mod:`~email.headerregistry`) is provided that "
"supports custom parsing for the various address and date :RFC:`5322` header "
"field types, and the major MIME header field stypes.  Support for additional "
"custom parsing will be added in the future."
msgstr ""
"Викликається, що приймає два аргументи, ``name`` і ``value``, де ``name`` — "
"це ім’я поля заголовка, а ``value`` — це значення розгорнутого поля "
"заголовка, і повертає підклас рядка, який представляє той заголовок. За "
"замовчуванням надається ``header_factory`` (див. :mod:`~email."
"headerregistry`), який підтримує спеціальний аналіз для різних типів полів "
"заголовків адреси та дати :RFC:`5322`, а також основних типів полів "
"заголовків MIME. У майбутньому буде додано підтримку додаткового "
"спеціального аналізу."

#: ../../library/email.policy.rst:448
msgid ""
"An object with at least two methods: get_content and set_content.  When the :"
"meth:`~email.message.EmailMessage.get_content` or :meth:`~email.message."
"EmailMessage.set_content` method of an :class:`~email.message.EmailMessage` "
"object is called, it calls the corresponding method of this object, passing "
"it the message object as its first argument, and any arguments or keywords "
"that were passed to it as additional arguments.  By default "
"``content_manager`` is set to :data:`~email.contentmanager.raw_data_manager`."
msgstr ""
"Об’єкт із принаймні двома методами: get_content і set_content. Коли "
"викликається метод :meth:`~email.message.EmailMessage.get_content` або :meth:"
"`~email.message.EmailMessage.set_content` об’єкта :class:`~email.message."
"EmailMessage`, він викликає відповідний метод цього об’єкта, передаючи йому "
"об’єкт повідомлення як його перший аргумент, а також будь-які аргументи або "
"ключові слова, які були передані йому як додаткові аргументи. За умовчанням "
"``content_manager`` встановлено на :data:`~email.contentmanager."
"raw_data_manager`."

#: ../../library/email.policy.rst:460 ../../library/email.policy.rst:618
msgid ""
"The class provides the following concrete implementations of the abstract "
"methods of :class:`Policy`:"
msgstr ""
"Клас забезпечує такі конкретні реалізації абстрактних методів :class:"
"`Policy`:"

#: ../../library/email.policy.rst:466
msgid ""
"Returns the value of the :attr:`~email.headerregistry.BaseHeader.max_count` "
"attribute of the specialized class used to represent the header with the "
"given name."
msgstr ""
"Повертає значення атрибута :attr:`~email.headerregistry.BaseHeader."
"max_count` спеціалізованого класу, який використовується для представлення "
"заголовка з заданим іменем."

#: ../../library/email.policy.rst:474 ../../library/email.policy.rst:624
msgid ""
"The name is parsed as everything up to the '``:``' and returned unmodified.  "
"The value is determined by stripping leading whitespace off the remainder of "
"the first line, joining all subsequent lines together, and stripping any "
"trailing carriage return or linefeed characters."
msgstr ""
"Ім'я аналізується як усе, аж до \"``:``\", і повертається без змін. Значення "
"визначається видаленням початкових пробілів із решти першого рядка, "
"з’єднанням усіх наступних рядків разом і видаленням будь-яких завершальних "
"символів повернення каретки або переводу рядка."

#: ../../library/email.policy.rst:482
msgid ""
"The name is returned unchanged.  If the input value has a ``name`` attribute "
"and it matches *name* ignoring case, the value is returned unchanged.  "
"Otherwise the *name* and *value* are passed to ``header_factory``, and the "
"resulting header object is returned as the value.  In this case a "
"``ValueError`` is raised if the input value contains CR or LF characters."
msgstr ""
"Ім'я повертається без змін. Якщо вхідне значення має атрибут ``name`` і воно "
"відповідає *name* без урахування регістру, значення повертається без змін. В "
"іншому випадку *ім’я* та *значення* передаються до ``header_factory``, а "
"отриманий об’єкт заголовка повертається як значення. У цьому випадку виникає "
"``ValueError``, якщо вхідне значення містить символи CR або LF."

#: ../../library/email.policy.rst:492
msgid ""
"If the value has a ``name`` attribute, it is returned to unmodified. "
"Otherwise the *name*, and the *value* with any CR or LF characters removed, "
"are passed to the ``header_factory``, and the resulting header object is "
"returned.  Any surrogateescaped bytes get turned into the unicode unknown-"
"character glyph."
msgstr ""
"Якщо значення має атрибут ``name``, воно повертається до незміненого. В "
"іншому випадку *ім’я* та *значення* з видаленими будь-якими символами CR або "
"LF передаються до ``header_factory``, і повертається отриманий об’єкт "
"заголовка. Будь-які сурогатні екрановані байти перетворюються на гліф "
"невідомих символів Unicode."

#: ../../library/email.policy.rst:501
msgid ""
"Header folding is controlled by the :attr:`refold_source` policy setting. A "
"value is considered to be a 'source value' if and only if it does not have a "
"``name`` attribute (having a ``name`` attribute means it is a header object "
"of some sort).  If a source value needs to be refolded according to the "
"policy, it is converted into a header object by passing the *name* and the "
"*value* with any CR and LF characters removed to the ``header_factory``.  "
"Folding of a header object is done by calling its ``fold`` method with the "
"current policy."
msgstr ""
"Згортання заголовка контролюється параметром політики :attr:`refold_source`. "
"Значення вважається \"вихідним значенням\" тоді і тільки тоді, коли воно не "
"має атрибута ``name`` (наявність атрибута ``name`` означає, що це певний "
"об’єкт заголовка). Якщо вихідне значення потрібно повторно згорнути "
"відповідно до політики, воно перетворюється на об’єкт заголовка шляхом "
"передачі *name* і *value* з будь-якими символами CR і LF, видаленими до "
"``header_factory``. Згортання об’єкта заголовка виконується викликом його "
"методу ``fold`` із поточною політикою."

#: ../../library/email.policy.rst:510
msgid ""
"Source values are split into lines using :meth:`~str.splitlines`.  If the "
"value is not to be refolded, the lines are rejoined using the ``linesep`` "
"from the policy and returned.  The exception is lines containing non-ascii "
"binary data.  In that case the value is refolded regardless of the "
"``refold_source`` setting, which causes the binary data to be CTE encoded "
"using the ``unknown-8bit`` charset."
msgstr ""
"Вихідні значення розбиваються на рядки за допомогою :meth:`~str.splitlines`. "
"Якщо значення не потрібно повторно згортати, рядки знову об’єднуються за "
"допомогою ``linesep`` із політики та повертаються. Винятком є рядки, що "
"містять двійкові дані, відмінні від ASCII. У цьому випадку значення повторно "
"згортається незалежно від параметра ``refold_source``, що призводить до "
"того, що двійкові дані кодуються CTE за допомогою набору символів "
"``unknown-8bit``."

#: ../../library/email.policy.rst:520
msgid ""
"The same as :meth:`fold` if :attr:`~Policy.cte_type` is ``7bit``, except "
"that the returned value is bytes."
msgstr ""
"Те саме, що :meth:`fold`, якщо :attr:`~Policy.cte_type` має значення "
"``7bit``, за винятком того, що повертається значення байтів."

#: ../../library/email.policy.rst:523
msgid ""
"If :attr:`~Policy.cte_type` is ``8bit``, non-ASCII binary data is converted "
"back into bytes.  Headers with binary data are not refolded, regardless of "
"the ``refold_header`` setting, since there is no way to know whether the "
"binary data consists of single byte characters or multibyte characters."
msgstr ""
"Якщо :attr:`~Policy.cte_type` має значення ``8bit``, двійкові дані, відмінні "
"від ASCII, перетворюються назад у байти. Заголовки з двійковими даними не "
"згортаються повторно, незалежно від параметра ``refold_header``, оскільки "
"немає способу дізнатися, чи двійкові дані складаються з однобайтових "
"символів чи багатобайтових символів."

#: ../../library/email.policy.rst:530
msgid ""
"The following instances of :class:`EmailPolicy` provide defaults suitable "
"for specific application domains.  Note that in the future the behavior of "
"these instances (in particular the ``HTTP`` instance) may be adjusted to "
"conform even more closely to the RFCs relevant to their domains."
msgstr ""
"Наступні екземпляри :class:`EmailPolicy` забезпечують значення за "
"замовчуванням, придатні для певних доменів програм. Зауважте, що в "
"майбутньому поведінка цих екземплярів (зокрема екземпляра ``HTTP``) може "
"бути налаштована для ще більшої відповідності RFC, що стосуються їхніх "
"доменів."

#: ../../library/email.policy.rst:538
msgid ""
"An instance of ``EmailPolicy`` with all defaults unchanged.  This policy "
"uses the standard Python ``\\n`` line endings rather than the RFC-correct "
"``\\r\\n``."
msgstr ""
"Екземпляр ``EmailPolicy`` з незмінними параметрами за замовчуванням. Ця "
"політика використовує стандартні закінчення рядків Python ``\\n`` замість "
"правильного RFC ``\\r\\n``."

#: ../../library/email.policy.rst:545
msgid ""
"Suitable for serializing messages in conformance with the email RFCs. Like "
"``default``, but with ``linesep`` set to ``\\r\\n``, which is RFC compliant."
msgstr ""
"Підходить для серіалізації повідомлень відповідно до RFC електронної пошти. "
"Як ``default``, але ``linesep`` має значення ``\\r\\n``, що відповідає RFC."

#: ../../library/email.policy.rst:552
msgid ""
"The same as ``SMTP`` except that :attr:`~EmailPolicy.utf8` is ``True``. "
"Useful for serializing messages to a message store without using encoded "
"words in the headers.  Should only be used for SMTP transmission if the "
"sender or recipient addresses have non-ASCII characters (the :meth:`smtplib."
"SMTP.send_message` method handles this automatically)."
msgstr ""
"Те саме, що ``SMTP``, за винятком того, що :attr:`~EmailPolicy.utf8` має "
"значення ``True``. Корисно для серіалізації повідомлень до сховища "
"повідомлень без використання закодованих слів у заголовках. Слід "
"використовувати лише для передачі SMTP, якщо адреси відправника чи "
"одержувача містять символи, відмінні від ASCII (метод :meth:`smtplib.SMTP."
"send_message` обробляє це автоматично)."

#: ../../library/email.policy.rst:561
msgid ""
"Suitable for serializing headers with for use in HTTP traffic.  Like "
"``SMTP`` except that ``max_line_length`` is set to ``None`` (unlimited)."
msgstr ""
"Підходить для серіалізації заголовків для використання в трафіку HTTP. "
"Подібно до ``SMTP``, за винятком того, що ``max_line_length`` встановлено на "
"``None`` (необмежено)."

#: ../../library/email.policy.rst:567
msgid ""
"Convenience instance.  The same as ``default`` except that "
"``raise_on_defect`` is set to ``True``.  This allows any policy to be made "
"strict by writing::"
msgstr ""
"Зручний екземпляр. Те саме, що ``default``, за винятком того, що "
"``raise_on_defect`` має значення ``True``. Це дозволяє зробити будь-яку "
"політику суворою, написавши:"

#: ../../library/email.policy.rst:574
msgid ""
"With all of these :class:`EmailPolicies <.EmailPolicy>`, the effective API "
"of the email package is changed from the Python 3.2 API in the following "
"ways:"
msgstr ""
"З усіма цими :class:`EmailPolicies <.EmailPolicy>` ефективний API пакета "
"електронної пошти змінюється від API Python 3.2 у такий спосіб:"

#: ../../library/email.policy.rst:577
msgid ""
"Setting a header on a :class:`~email.message.Message` results in that header "
"being parsed and a header object created."
msgstr ""
"Встановлення заголовка в :class:`~email.message.Message` призводить до "
"аналізу цього заголовка та створення об’єкта заголовка."

#: ../../library/email.policy.rst:580
msgid ""
"Fetching a header value from a :class:`~email.message.Message` results in "
"that header being parsed and a header object created and returned."
msgstr ""
"Отримання значення заголовка з :class:`~email.message.Message` призводить до "
"аналізу цього заголовка та створення та повернення об’єкта заголовка."

#: ../../library/email.policy.rst:584
msgid ""
"Any header object, or any header that is refolded due to the policy "
"settings, is folded using an algorithm that fully implements the RFC folding "
"algorithms, including knowing where encoded words are required and allowed."
msgstr ""
"Будь-який об’єкт заголовка або будь-який заголовок, який повторно "
"згортається через параметри політики, згортається за допомогою алгоритму, "
"який повністю реалізує алгоритми згортання RFC, включаючи визначення того, "
"де закодовані слова потрібні та дозволені."

#: ../../library/email.policy.rst:589
msgid ""
"From the application view, this means that any header obtained through the :"
"class:`~email.message.EmailMessage` is a header object with extra "
"attributes, whose string value is the fully decoded unicode value of the "
"header.  Likewise, a header may be assigned a new value, or a new header "
"created, using a unicode string, and the policy will take care of converting "
"the unicode string into the correct RFC encoded form."
msgstr ""
"З точки зору програми це означає, що будь-який заголовок, отриманий через :"
"class:`~email.message.EmailMessage`, є об’єктом заголовка з додатковими "
"атрибутами, рядкове значення якого є повністю розшифрованим значенням "
"заголовка в Unicode. Так само заголовку може бути призначено нове значення "
"або створений новий заголовок за допомогою рядка Юнікод, і політика подбає "
"про перетворення рядка Юнікод у правильну форму, закодовану RFC."

#: ../../library/email.policy.rst:596
msgid ""
"The header objects and their attributes are described in :mod:`~email."
"headerregistry`."
msgstr ""
"Об’єкти заголовка та їхні атрибути описані в :mod:`~email.headerregistry`."

#: ../../library/email.policy.rst:603
msgid ""
"This concrete :class:`Policy` is the backward compatibility policy.  It "
"replicates the behavior of the email package in Python 3.2.  The :mod:"
"`~email.policy` module also defines an instance of this class, :const:"
"`compat32`, that is used as the default policy.  Thus the default behavior "
"of the email package is to maintain compatibility with Python 3.2."
msgstr ""
"Ця конкретна :class:`Policy` є політикою зворотної сумісності. Він повторює "
"поведінку пакета електронної пошти в Python 3.2. Модуль :mod:`~email.policy` "
"також визначає екземпляр цього класу, :const:`compat32`, який "
"використовується як політика за замовчуванням. Таким чином, за замовчуванням "
"пакет електронної пошти підтримує сумісність із Python 3.2."

#: ../../library/email.policy.rst:609
msgid ""
"The following attributes have values that are different from the :class:"
"`Policy` default:"
msgstr ""
"Наступні атрибути мають значення, які відрізняються від стандартних :class:"
"`Policy`:"

#: ../../library/email.policy.rst:615
msgid "The default is ``True``."
msgstr "O padrão é ``True``."

#: ../../library/email.policy.rst:632
msgid "The name and value are returned unmodified."
msgstr "Ім'я та значення повертаються без змін."

#: ../../library/email.policy.rst:637
msgid ""
"If the value contains binary data, it is converted into a :class:`~email."
"header.Header` object using the ``unknown-8bit`` charset. Otherwise it is "
"returned unmodified."
msgstr ""
"Якщо значення містить двійкові дані, воно перетворюється на об’єкт :class:"
"`~email.header.Header` за допомогою кодування ``unknown-8bit``. В іншому "
"випадку він повертається без змін."

#: ../../library/email.policy.rst:644
msgid ""
"Headers are folded using the :class:`~email.header.Header` folding "
"algorithm, which preserves existing line breaks in the value, and wraps each "
"resulting line to the ``max_line_length``.  Non-ASCII binary data are CTE "
"encoded using the ``unknown-8bit`` charset."
msgstr ""
"Заголовки згортаються за допомогою алгоритму згортання :class:`~email.header."
"Header`, який зберігає наявні розриви рядків у значенні та обертає кожен "
"отриманий рядок до ``max_line_length``. Двійкові дані, відмінні від ASCII, "
"кодуються CTE за допомогою набору символів ``unknown-8bit``."

#: ../../library/email.policy.rst:652
msgid ""
"Headers are folded using the :class:`~email.header.Header` folding "
"algorithm, which preserves existing line breaks in the value, and wraps each "
"resulting line to the ``max_line_length``.  If ``cte_type`` is ``7bit``, non-"
"ascii binary data is CTE encoded using the ``unknown-8bit`` charset.  "
"Otherwise the original source header is used, with its existing line breaks "
"and any (RFC invalid) binary data it may contain."
msgstr ""
"Заголовки згортаються за допомогою алгоритму згортання :class:`~email.header."
"Header`, який зберігає наявні розриви рядків у значенні та обертає кожен "
"отриманий рядок до ``max_line_length``. Якщо ``cte_type`` дорівнює ``7bit``, "
"двійкові дані, що не є ascii, кодуються CTE з використанням набору символів "
"``unknown-8bit``. В іншому випадку використовується вихідний вихідний "
"заголовок із наявними розривами рядків і будь-якими (недійсними RFC) "
"двійковими даними, які він може містити."

#: ../../library/email.policy.rst:662
msgid ""
"An instance of :class:`Compat32`, providing  backward compatibility with the "
"behavior of the email package in Python 3.2."
msgstr ""
"Екземпляр :class:`Compat32`, що забезпечує зворотну сумісність із поведінкою "
"пакета електронної пошти в Python 3.2."

#: ../../library/email.policy.rst:667
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../library/email.policy.rst:668
msgid ""
"Originally added in 3.3 as a :term:`provisional feature <provisional "
"package>`."
msgstr ""
"Спочатку додано в 3.3 як :term:`попередню функцію <provisional package>`."

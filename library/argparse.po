# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-27 14:50+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/argparse.rst:2
msgid ""
":mod:`!argparse` --- Parser for command-line options, arguments and sub-"
"commands"
msgstr ""
":mod:`!argparse` --- Analisador sintático para opções de linha de comando, "
"argumentos e subcomandos"

#: ../../library/argparse.rst:12
msgid "**Source code:** :source:`Lib/argparse.py`"
msgstr "**Código-fonte:** :source:`Lib/argparse.py`"

#: ../../library/argparse.rst-1
msgid "Tutorial"
msgstr "Tutorial"

#: ../../library/argparse.rst:18
msgid ""
"This page contains the API reference information. For a more gentle "
"introduction to Python command-line parsing, have a look at the :ref:"
"`argparse tutorial <argparse-tutorial>`."
msgstr ""
"Esta página contém informações da API de Referência. Para uma introdução "
"mais prática para o parser de linha de comando Python, acesse o :ref:"
"`tutorial do argparse <argparse-tutorial>`."

#: ../../library/argparse.rst:22
msgid ""
"The :mod:`argparse` module makes it easy to write user-friendly command-line "
"interfaces. The program defines what arguments it requires, and :mod:"
"`argparse` will figure out how to parse those out of :data:`sys.argv`.  The :"
"mod:`argparse` module also automatically generates help and usage messages.  "
"The module will also issue errors when users give the program invalid "
"arguments."
msgstr ""
"O módulo :mod:`argparse` torna fácil a escrita de interfaces de linha de "
"comando amigáveis. O programa define quais argumentos são necessários e :mod:"
"`argparse` descobrirá como analisá-lo e interpretá-los a partir do :data:"
"`sys.argv`. O módulo :mod:`argparse` também gera automaticamente o texto "
"ajuda e mensagens de uso. O módulo também vai emitir erros quando o usuário "
"prover argumentos inválidos para o programa."

#: ../../library/argparse.rst:30
msgid "Core Functionality"
msgstr "Funcionalidade central"

#: ../../library/argparse.rst:32
msgid ""
"The :mod:`argparse` module's support for command-line interfaces is built "
"around an instance of :class:`argparse.ArgumentParser`.  It is a container "
"for argument specifications and has options that apply to the parser as "
"whole::"
msgstr ""
"O suporte do módulo :mod:`argparse` para interfaces de linha de comando é "
"construído em torno de uma instância de :class:`argparse.ArgumentParser`. É "
"um contêiner para especificações de argumentos e possui opções que se "
"aplicam ao analisador sintático como um todo::"

#: ../../library/argparse.rst:36
msgid ""
"parser = argparse.ArgumentParser(\n"
"                    prog='ProgramName',\n"
"                    description='What the program does',\n"
"                    epilog='Text at the bottom of help')"
msgstr ""

#: ../../library/argparse.rst:41
msgid ""
"The :meth:`ArgumentParser.add_argument` method attaches individual argument "
"specifications to the parser.  It supports positional arguments, options "
"that accept values, and on/off flags::"
msgstr ""
"O método :meth:`ArgumentParser.add_argument` anexa especificações de "
"argumentos individuais ao analisador. Ele oferece suporte a argumentos "
"posicionais, opções que aceitam valores e sinalizadores liga/desliga::"

#: ../../library/argparse.rst:45
msgid ""
"parser.add_argument('filename')           # positional argument\n"
"parser.add_argument('-c', '--count')      # option that takes a value\n"
"parser.add_argument('-v', '--verbose',\n"
"                    action='store_true')  # on/off flag"
msgstr ""

#: ../../library/argparse.rst:50
msgid ""
"The :meth:`ArgumentParser.parse_args` method runs the parser and places the "
"extracted data in a :class:`argparse.Namespace` object::"
msgstr ""
"O método :meth:`ArgumentParser.parse_args` executa o analisador e coloca os "
"dados extraídos em um objeto :class:`argparse.Namespace`::"

#: ../../library/argparse.rst:53
msgid ""
"args = parser.parse_args()\n"
"print(args.filename, args.count, args.verbose)"
msgstr ""

#: ../../library/argparse.rst:58
msgid "Quick Links for add_argument()"
msgstr "Links rápidos para add_argument()"

#: ../../library/argparse.rst:61
msgid "Name"
msgstr "Nome"

#: ../../library/argparse.rst:61
msgid "Description"
msgstr "Descrição"

#: ../../library/argparse.rst:61
msgid "Values"
msgstr "Valores"

#: ../../library/argparse.rst:63
msgid "action_"
msgstr "action_"

#: ../../library/argparse.rst:63
msgid "Specify how an argument should be handled"
msgstr "Especifica como um argumento deve ser tratado"

#: ../../library/argparse.rst:63
msgid ""
"``'store'``, ``'store_const'``, ``'store_true'``, ``'append'``, "
"``'append_const'``, ``'count'``, ``'help'``, ``'version'``"
msgstr ""
"``'store'``, ``'store_const'``, ``'store_true'``, ``'append'``, "
"``'append_const'``, ``'count'``, ``'help'``, ``'version'``"

#: ../../library/argparse.rst:64
msgid "choices_"
msgstr "choices_"

#: ../../library/argparse.rst:64
msgid "Limit values to a specific set of choices"
msgstr "Limita valores a um conjunto específico de opções"

#: ../../library/argparse.rst:64
msgid ""
"``['foo', 'bar']``, ``range(1, 10)``, or :class:`~collections.abc.Container` "
"instance"
msgstr ""
"``['foo', 'bar']``, ``range(1, 10)`` ou instância :class:`~collections.abc."
"Container`"

#: ../../library/argparse.rst:65
msgid "const_"
msgstr "const_"

#: ../../library/argparse.rst:65
msgid "Store a constant value"
msgstr "Armazena um valor constante"

#: ../../library/argparse.rst:66
msgid "default_"
msgstr "default_"

#: ../../library/argparse.rst:66
msgid "Default value used when an argument is not provided"
msgstr "Valor padrão usado quando um argumento não é fornecido"

#: ../../library/argparse.rst:66
msgid "Defaults to ``None``"
msgstr "O padrão é ``None``"

#: ../../library/argparse.rst:67
msgid "dest_"
msgstr "dest_"

#: ../../library/argparse.rst:67
msgid "Specify the attribute name used in the result namespace"
msgstr "Especifica o nome do atributo usado no espaço de nomes de resultado"

#: ../../library/argparse.rst:68
msgid "help_"
msgstr "help_"

#: ../../library/argparse.rst:68
msgid "Help message for an argument"
msgstr "Mensagem de ajuda para um argumento"

#: ../../library/argparse.rst:69
msgid "metavar_"
msgstr "metavar_"

#: ../../library/argparse.rst:69
msgid "Alternate display name for the argument as shown in help"
msgstr ""
"Nome de exibição alternativo para o argumento conforme mostrado na ajuda"

#: ../../library/argparse.rst:70
msgid "nargs_"
msgstr "nargs_"

#: ../../library/argparse.rst:70
msgid "Number of times the argument can be used"
msgstr "Número de vezes que o argumento pode ser usado"

#: ../../library/argparse.rst:70
msgid ":class:`int`, ``'?'``, ``'*'``, or ``'+'``"
msgstr ":class:`int`, ``'?'``, ``'*'``, ou ``'+'``"

#: ../../library/argparse.rst:71
msgid "required_"
msgstr "required_"

#: ../../library/argparse.rst:71
msgid "Indicate whether an argument is required or optional"
msgstr "Indica se um argumento é obrigatório ou opcional"

#: ../../library/argparse.rst:71
msgid "``True`` or ``False``"
msgstr "``True`` ou ``False``"

#: ../../library/argparse.rst:72
msgid ":ref:`type <argparse-type>`"
msgstr ":ref:`type <argparse-type>`"

#: ../../library/argparse.rst:72
msgid "Automatically convert an argument to the given type"
msgstr "Converte automaticamente um argumento para o tipo fornecido"

#: ../../library/argparse.rst:72
msgid ""
":class:`int`, :class:`float`, ``argparse.FileType('w')``, or callable "
"function"
msgstr ""
":class:`int`, :class:`float`, ``argparse.FileType('w')`` ou uma função "
"chamável"

#: ../../library/argparse.rst:77
msgid "Example"
msgstr "Exemplo"

#: ../../library/argparse.rst:79
msgid ""
"The following code is a Python program that takes a list of integers and "
"produces either the sum or the max::"
msgstr ""
"O código a seguir é um programa Python que recebe uma lista de inteiros e "
"apresenta a soma ou o máximo::"

#: ../../library/argparse.rst:82
msgid ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser(description='Process some integers.')\n"
"parser.add_argument('integers', metavar='N', type=int, nargs='+',\n"
"                    help='an integer for the accumulator')\n"
"parser.add_argument('--sum', dest='accumulate', action='store_const',\n"
"                    const=sum, default=max,\n"
"                    help='sum the integers (default: find the max)')\n"
"\n"
"args = parser.parse_args()\n"
"print(args.accumulate(args.integers))"
msgstr ""

#: ../../library/argparse.rst:94
msgid ""
"Assuming the above Python code is saved into a file called ``prog.py``, it "
"can be run at the command line and it provides useful help messages:"
msgstr ""
"Presumindo que o código Python acima seja salvo em um arquivo chamado ``prog."
"py``, ele pode ser executado pela linha de comando e fornece mensagens de "
"ajuda úteis:"

#: ../../library/argparse.rst:97
msgid ""
"$ python prog.py -h\n"
"usage: prog.py [-h] [--sum] N [N ...]\n"
"\n"
"Process some integers.\n"
"\n"
"positional arguments:\n"
" N           an integer for the accumulator\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --sum       sum the integers (default: find the max)"
msgstr ""

#: ../../library/argparse.rst:111
msgid ""
"When run with the appropriate arguments, it prints either the sum or the max "
"of the command-line integers:"
msgstr ""
"Quando executado com argumentos apropriados, a soma ou o maior número dos "
"números digitados na linha de comando:"

#: ../../library/argparse.rst:114
msgid ""
"$ python prog.py 1 2 3 4\n"
"4\n"
"\n"
"$ python prog.py 1 2 3 4 --sum\n"
"10"
msgstr ""

#: ../../library/argparse.rst:122
msgid "If invalid arguments are passed in, an error will be displayed:"
msgstr "Se argumentos inválidos forem passados, um erro será exibido:"

#: ../../library/argparse.rst:124
msgid ""
"$ python prog.py a b c\n"
"usage: prog.py [-h] [--sum] N [N ...]\n"
"prog.py: error: argument N: invalid int value: 'a'"
msgstr ""

#: ../../library/argparse.rst:130
msgid "The following sections walk you through this example."
msgstr "As próximas seções apresentarão detalhes deste exemplo."

#: ../../library/argparse.rst:134
msgid "Creating a parser"
msgstr "Criando um analisador sintático"

#: ../../library/argparse.rst:136
msgid ""
"The first step in using the :mod:`argparse` is creating an :class:"
"`ArgumentParser` object::"
msgstr ""
"O primeiro passo ao utilizar o :mod:`argparse` é criar um objeto :class:"
"`ArgumentParser`::"

#: ../../library/argparse.rst:139
msgid ""
">>> parser = argparse.ArgumentParser(description='Process some integers.')"
msgstr ""

#: ../../library/argparse.rst:141
msgid ""
"The :class:`ArgumentParser` object will hold all the information necessary "
"to parse the command line into Python data types."
msgstr ""
"O objeto :class:`ArgumentParser` contém toda informação necessária para "
"análise e interpretação da linha de comando em tipos de dados Python."

#: ../../library/argparse.rst:146
msgid "Adding arguments"
msgstr "Adicionando argumentos"

#: ../../library/argparse.rst:148
msgid ""
"Filling an :class:`ArgumentParser` with information about program arguments "
"is done by making calls to the :meth:`~ArgumentParser.add_argument` method. "
"Generally, these calls tell the :class:`ArgumentParser` how to take the "
"strings on the command line and turn them into objects.  This information is "
"stored and used when :meth:`~ArgumentParser.parse_args` is called. For "
"example::"
msgstr ""
"O preenchimento de :class:`ArgumentParser` com informações sobre os "
"argumentos do programa é feito por chamadas ao método :meth:`~ArgumentParser."
"add_argument`. Geralmente, estas chamadas informam ao :class:"
"`ArgumentParser` como traduzir strings da linha de comando e torná-los em "
"objetos. Esta informação é armazenada e utilizada quando o método :meth:"
"`~ArgumentParser.parse_args` é invocado. Por exemplo::"

#: ../../library/argparse.rst:154
msgid ""
">>> parser.add_argument('integers', metavar='N', type=int, nargs='+',\n"
"...                     help='an integer for the accumulator')\n"
">>> parser.add_argument('--sum', dest='accumulate', action='store_const',\n"
"...                     const=sum, default=max,\n"
"...                     help='sum the integers (default: find the max)')"
msgstr ""

#: ../../library/argparse.rst:160
msgid ""
"Later, calling :meth:`~ArgumentParser.parse_args` will return an object with "
"two attributes, ``integers`` and ``accumulate``.  The ``integers`` attribute "
"will be a list of one or more integers, and the ``accumulate`` attribute "
"will be either the :func:`sum` function, if ``--sum`` was specified at the "
"command line, or the :func:`max` function if it was not."
msgstr ""
"Em seguida, a chamada ao método :meth:`~ArgumentParser.parse_args` irá "
"retornar um objeto com dois atributos, ``integers`` e ``accumulate``. O "
"atributo ``integers`` será uma lista com um ou mais números inteiros, e o "
"atributo ``accumulate`` será ou a função :func:`sum`, se ``--sum`` for "
"especificado na linha de comando, ou a função :func:`max`, caso contrário."

#: ../../library/argparse.rst:168
msgid "Parsing arguments"
msgstr "Análise de argumentos"

#: ../../library/argparse.rst:170
msgid ""
":class:`ArgumentParser` parses arguments through the :meth:`~ArgumentParser."
"parse_args` method.  This will inspect the command line, convert each "
"argument to the appropriate type and then invoke the appropriate action. In "
"most cases, this means a simple :class:`Namespace` object will be built up "
"from attributes parsed out of the command line::"
msgstr ""
":class:`ArgumentParser` analisa os argumentos através do método :meth:"
"`~ArgumentParser.parse_args`. Isso inspecionará a linha de comando, "
"converterá cada argumento no tipo apropriado e, em seguida, chamará a ação "
"apropriada. Na maioria dos casos, isso significa que um objeto :class:"
"`Namespace` simples será construído a partir de atributos analisados a "
"partir da linha de comando::"

#: ../../library/argparse.rst:176
msgid ""
">>> parser.parse_args(['--sum', '7', '-1', '42'])\n"
"Namespace(accumulate=<built-in function sum>, integers=[7, -1, 42])"
msgstr ""

#: ../../library/argparse.rst:179
msgid ""
"In a script, :meth:`~ArgumentParser.parse_args` will typically be called "
"with no arguments, and the :class:`ArgumentParser` will automatically "
"determine the command-line arguments from :data:`sys.argv`."
msgstr ""
"Em um script, :meth:`~ArgumentParser.parse_args` será tipicamente chamado "
"sem argumentos, e :class:`ArgumentParser` irá determinar automaticamente os "
"argumentos de linha de comando de :data:`sys.argv`."

#: ../../library/argparse.rst:185
msgid "ArgumentParser objects"
msgstr "Objetos ArgumentParser"

#: ../../library/argparse.rst:194
msgid ""
"Create a new :class:`ArgumentParser` object. All parameters should be passed "
"as keyword arguments. Each parameter has its own more detailed description "
"below, but in short they are:"
msgstr ""
"Cria um novo objeto :class:`ArgumentParser`. Todos os parâmetros devem ser "
"passados como argumentos nomeados. Cada parâmetro tem sua própria descrição "
"mais detalhada abaixo, mas em resumo eles são:"

#: ../../library/argparse.rst:198
msgid ""
"prog_ - The name of the program (default: ``os.path.basename(sys.argv[0])``)"
msgstr "prog_ - O nome do programa (padrão: ``os.path.basename(sys.argv[0])``)"

#: ../../library/argparse.rst:201
msgid ""
"usage_ - The string describing the program usage (default: generated from "
"arguments added to parser)"
msgstr ""
"usage_ - A string que descreve o uso do programa (padrão: gerado a partir de "
"argumentos adicionados ao analisador sintático)"

#: ../../library/argparse.rst:204
msgid ""
"description_ - Text to display before the argument help (by default, no text)"
msgstr ""
"description_ - Texto para exibir antes da ajuda dos argumentos (por padrão, "
"nenhum texto)"

#: ../../library/argparse.rst:207
msgid "epilog_ - Text to display after the argument help (by default, no text)"
msgstr ""
"epilog_ - Texto para exibir após da ajuda dos argumentos (por padrão, nenhum "
"texto)"

#: ../../library/argparse.rst:209
msgid ""
"parents_ - A list of :class:`ArgumentParser` objects whose arguments should "
"also be included"
msgstr ""
"parents_ - Uma lista de objetos :class:`ArgumentParser` cujos argumentos "
"também devem ser incluídos"

#: ../../library/argparse.rst:212
msgid "formatter_class_ - A class for customizing the help output"
msgstr "formatter_class_ - Uma classe para personalizar a saída de ajuda"

#: ../../library/argparse.rst:214
msgid ""
"prefix_chars_ - The set of characters that prefix optional arguments "
"(default: '-')"
msgstr ""
"prefix_chars_ - O conjunto de caracteres que prefixam argumentos opcionais "
"(padrão: \"-\")"

#: ../../library/argparse.rst:217
msgid ""
"fromfile_prefix_chars_ - The set of characters that prefix files from which "
"additional arguments should be read (default: ``None``)"
msgstr ""
"fromfile_prefix_chars_ - O conjunto de caracteres que prefixam os arquivos "
"dos quais os argumentos adicionais devem ser lidos (padrão: ``None``)"

#: ../../library/argparse.rst:220
msgid ""
"argument_default_ - The global default value for arguments (default: "
"``None``)"
msgstr ""
"argument_default_ - O valor padrão global para argumentos (padrão: ``None``)"

#: ../../library/argparse.rst:223
msgid ""
"conflict_handler_ - The strategy for resolving conflicting optionals "
"(usually unnecessary)"
msgstr ""
"conflict_handler_ - A estratégia para resolver opcionais conflitantes "
"(geralmente desnecessário)"

#: ../../library/argparse.rst:226
msgid ""
"add_help_ - Add a ``-h/--help`` option to the parser (default: ``True``)"
msgstr ""
"add_help_ - Adiciona uma opção ``-h/--help`` para o analisador sintático "
"(padrão: ``True``)"

#: ../../library/argparse.rst:228
msgid ""
"allow_abbrev_ - Allows long options to be abbreviated if the abbreviation is "
"unambiguous. (default: ``True``)"
msgstr ""
"allow_abbrev_ - Permite que opções longas sejam abreviadas se a abreviação "
"não for ambígua. (padrão: ``True``)"

#: ../../library/argparse.rst:231
msgid ""
"exit_on_error_ - Determines whether or not ArgumentParser exits with error "
"info when an error occurs. (default: ``True``)"
msgstr ""
"exit_on_error_ - Determina se ArgumentParser sai ou não com informações de "
"erro quando ocorre um erro. (padrão: ``True``)"

#: ../../library/argparse.rst:234
msgid "*allow_abbrev* parameter was added."
msgstr "O parâmetro *allow_abbrev* foi adicionado."

#: ../../library/argparse.rst:237
msgid ""
"In previous versions, *allow_abbrev* also disabled grouping of short flags "
"such as ``-vv`` to mean ``-v -v``."
msgstr ""
"Em versões anteriores, *allow_abbrev* também desabilitava o agrupamento de "
"sinalizadores curtos, como ``-vv`` para significar ``-v -v``."

#: ../../library/argparse.rst:241
msgid "*exit_on_error* parameter was added."
msgstr "O parâmetro *exit_on_error* foi adicionado."

#: ../../library/argparse.rst:244 ../../library/argparse.rst:781
msgid "The following sections describe how each of these are used."
msgstr "As seções a seguir descrevem como cada um deles é usado."

#: ../../library/argparse.rst:250
msgid "prog"
msgstr "prog"

#: ../../library/argparse.rst:252
msgid ""
"By default, :class:`ArgumentParser` objects use the base name (see :func:`os."
"path.basename`) of ``sys.argv[0]`` to determine how to display the name of "
"the program in help messages.  This default is almost always desirable "
"because it will make the help messages match the name that was used to "
"invoke the program on the command line.  For example, consider a file named "
"``myprogram.py`` with the following code::"
msgstr ""

#: ../../library/argparse.rst:259 ../../library/argparse.rst:679
msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('--foo', help='foo help')\n"
"args = parser.parse_args()"
msgstr ""

#: ../../library/argparse.rst:264
msgid ""
"The help for this program will display ``myprogram.py`` as the program name "
"(regardless of where the program was invoked from):"
msgstr ""
"A ajuda para este programa exibirá ``myprogram.py`` como o nome do programa "
"(independentemente de onde o programa foi chamado):"

#: ../../library/argparse.rst:267
msgid ""
"$ python myprogram.py --help\n"
"usage: myprogram.py [-h] [--foo FOO]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   foo help\n"
"$ cd ..\n"
"$ python subdir/myprogram.py --help\n"
"usage: myprogram.py [-h] [--foo FOO]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   foo help"
msgstr ""

#: ../../library/argparse.rst:283
msgid ""
"To change this default behavior, another value can be supplied using the "
"``prog=`` argument to :class:`ArgumentParser`::"
msgstr ""
"Para alterar este comportamento padrão, outro valor pode ser fornecido "
"usando o argumento ``prog=`` para :class:`ArgumentParser`::"

#: ../../library/argparse.rst:286
msgid ""
">>> parser = argparse.ArgumentParser(prog='myprogram')\n"
">>> parser.print_help()\n"
"usage: myprogram [-h]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"
msgstr ""

#: ../../library/argparse.rst:293
msgid ""
"Note that the program name, whether determined from ``sys.argv[0]`` or from "
"the ``prog=`` argument, is available to help messages using the ``%(prog)s`` "
"format specifier."
msgstr ""
"Observe que o nome do programa, seja determinado a partir de ``sys.argv[0]`` "
"ou do argumento ``prog=``, está disponível para mensagens de ajuda usando o "
"especificador de formato ``%(prog)s``."

#: ../../library/argparse.rst:299
msgid ""
">>> parser = argparse.ArgumentParser(prog='myprogram')\n"
">>> parser.add_argument('--foo', help='foo of the %(prog)s program')\n"
">>> parser.print_help()\n"
"usage: myprogram [-h] [--foo FOO]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   foo of the myprogram program"
msgstr ""

#: ../../library/argparse.rst:310
msgid "usage"
msgstr "usage"

#: ../../library/argparse.rst:312
msgid ""
"By default, :class:`ArgumentParser` calculates the usage message from the "
"arguments it contains::"
msgstr ""
"Por padrão, :class:`ArgumentParser` calcula a mensagem de uso a partir dos "
"argumentos que contém::"

#: ../../library/argparse.rst:315
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', nargs='?', help='foo help')\n"
">>> parser.add_argument('bar', nargs='+', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo [FOO]] bar [bar ...]\n"
"\n"
"positional arguments:\n"
" bar          bar help\n"
"\n"
"options:\n"
" -h, --help   show this help message and exit\n"
" --foo [FOO]  foo help"
msgstr ""

#: ../../library/argparse.rst:328
msgid ""
"The default message can be overridden with the ``usage=`` keyword argument::"
msgstr ""
"A mensagem padrão pode ser substituído com o argumento nomeado ``usage=``::"

#: ../../library/argparse.rst:330
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s "
"[options]')\n"
">>> parser.add_argument('--foo', nargs='?', help='foo help')\n"
">>> parser.add_argument('bar', nargs='+', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [options]\n"
"\n"
"positional arguments:\n"
" bar          bar help\n"
"\n"
"options:\n"
" -h, --help   show this help message and exit\n"
" --foo [FOO]  foo help"
msgstr ""

#: ../../library/argparse.rst:343
msgid ""
"The ``%(prog)s`` format specifier is available to fill in the program name "
"in your usage messages."
msgstr ""
"O especificador de formato ``%(prog)s`` está disponível para preencher o "
"nome do programa em suas mensagens de uso."

#: ../../library/argparse.rst:350
msgid "description"
msgstr "description"

#: ../../library/argparse.rst:352
msgid ""
"Most calls to the :class:`ArgumentParser` constructor will use the "
"``description=`` keyword argument.  This argument gives a brief description "
"of what the program does and how it works.  In help messages, the "
"description is displayed between the command-line usage string and the help "
"messages for the various arguments::"
msgstr ""
"A maioria das chamadas para o construtor :class:`ArgumentParser` usará o "
"argumento nomeado  ``description=``. Este argumento fornece uma breve "
"descrição do que o programa faz e como funciona. Nas mensagens de ajuda, a "
"descrição é exibida entre a string de uso da linha de comando e as mensagens "
"de ajuda para os vários argumentos::"

#: ../../library/argparse.rst:358
msgid ""
">>> parser = argparse.ArgumentParser(description='A foo that bars')\n"
">>> parser.print_help()\n"
"usage: argparse.py [-h]\n"
"\n"
"A foo that bars\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"
msgstr ""

#: ../../library/argparse.rst:367
msgid ""
"By default, the description will be line-wrapped so that it fits within the "
"given space.  To change this behavior, see the formatter_class_ argument."
msgstr ""
"Por padrão, a descrição terá sua linha quebrada para que se encaixe no "
"espaço fornecido. Para alterar esse comportamento, consulte o argumento "
"formatter_class_."

#: ../../library/argparse.rst:372
msgid "epilog"
msgstr "epilog"

#: ../../library/argparse.rst:374
msgid ""
"Some programs like to display additional description of the program after "
"the description of the arguments.  Such text can be specified using the "
"``epilog=`` argument to :class:`ArgumentParser`::"
msgstr ""
"Alguns programas gostam de exibir uma descrição adicional do programa após a "
"descrição dos argumentos. Esse texto pode ser especificado usando o "
"argumento ``epilog=`` para :class:`ArgumentParser`::"

#: ../../library/argparse.rst:378
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     description='A foo that bars',\n"
"...     epilog=\"And that's how you'd foo a bar\")\n"
">>> parser.print_help()\n"
"usage: argparse.py [-h]\n"
"\n"
"A foo that bars\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
"\n"
"And that's how you'd foo a bar"
msgstr ""

#: ../../library/argparse.rst:391
msgid ""
"As with the description_ argument, the ``epilog=`` text is by default line-"
"wrapped, but this behavior can be adjusted with the formatter_class_ "
"argument to :class:`ArgumentParser`."
msgstr ""
"Tal como acontece com o argumento description_, o texto de ``epilog=`` tem "
"sua quebra de linha habilitada por padrão, mas este comportamento pode ser "
"ajustado com o argumento formatter_class_ para :class:`ArgumentParser`."

#: ../../library/argparse.rst:397
msgid "parents"
msgstr "parents"

#: ../../library/argparse.rst:399
msgid ""
"Sometimes, several parsers share a common set of arguments. Rather than "
"repeating the definitions of these arguments, a single parser with all the "
"shared arguments and passed to ``parents=`` argument to :class:"
"`ArgumentParser` can be used.  The ``parents=`` argument takes a list of :"
"class:`ArgumentParser` objects, collects all the positional and optional "
"actions from them, and adds these actions to the :class:`ArgumentParser` "
"object being constructed::"
msgstr ""
"Às vezes, vários analisadores sintáticos compartilham um conjunto comum de "
"argumentos. Ao invés de repetir as definições desses argumentos, um único "
"analisador com todos os argumentos compartilhados e passado para o argumento "
"``parents=`` para :class:`ArgumentParser` pode ser usado. O argumento "
"``parents=`` pega uma lista de objetos :class:`ArgumentParser`, coleta todas "
"as ações posicionais e opcionais deles, e adiciona essas ações ao objeto :"
"class:`ArgumentParser` sendo construído::"

#: ../../library/argparse.rst:406
msgid ""
">>> parent_parser = argparse.ArgumentParser(add_help=False)\n"
">>> parent_parser.add_argument('--parent', type=int)\n"
"\n"
">>> foo_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> foo_parser.add_argument('foo')\n"
">>> foo_parser.parse_args(['--parent', '2', 'XXX'])\n"
"Namespace(foo='XXX', parent=2)\n"
"\n"
">>> bar_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> bar_parser.add_argument('--bar')\n"
">>> bar_parser.parse_args(['--bar', 'YYY'])\n"
"Namespace(bar='YYY', parent=None)"
msgstr ""

#: ../../library/argparse.rst:419
msgid ""
"Note that most parent parsers will specify ``add_help=False``.  Otherwise, "
"the :class:`ArgumentParser` will see two ``-h/--help`` options (one in the "
"parent and one in the child) and raise an error."
msgstr ""
"Observe que a maioria dos analisadores sintáticos pais especificará "
"``add_help=False``. Caso contrário, o :class:`ArgumentParser` verá duas "
"opções ``-h/--help`` (uma no pai e outra no filho) e levantará um erro."

#: ../../library/argparse.rst:424
msgid ""
"You must fully initialize the parsers before passing them via ``parents=``. "
"If you change the parent parsers after the child parser, those changes will "
"not be reflected in the child."
msgstr ""
"Você deve inicializar totalmente os analisadores sintáticos antes de passá-"
"los via ``parents=``. Se você alterar os analisadores pais após o analisador "
"filho, essas mudanças não serão refletidas no filho."

#: ../../library/argparse.rst:432
msgid "formatter_class"
msgstr "formatter_class"

#: ../../library/argparse.rst:434
msgid ""
":class:`ArgumentParser` objects allow the help formatting to be customized "
"by specifying an alternate formatting class.  Currently, there are four such "
"classes:"
msgstr ""
"Objetos :class:`ArgumentParser` permitem que a  formação do texto de ajuda "
"seja personalizada por meio da especificação de uma classe de formatação "
"alternativa. Atualmente, há quatro dessas classes:"

#: ../../library/argparse.rst:443
msgid ""
":class:`RawDescriptionHelpFormatter` and :class:`RawTextHelpFormatter` give "
"more control over how textual descriptions are displayed. By default, :class:"
"`ArgumentParser` objects line-wrap the description_ and epilog_ texts in "
"command-line help messages::"
msgstr ""
":class:`RawDescriptionHelpFormatter` e :class:`RawTextHelpFormatter` dão "
"mais controle sobre como as descrições textuais são exibidas. Por padrão, "
"objetos :class:`ArgumentParser` quebram em linha os textos description_ e "
"epilog_ nas mensagens de ajuda da linha de comando::"

#: ../../library/argparse.rst:448
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     description='''this description\n"
"...         was indented weird\n"
"...             but that is okay''',\n"
"...     epilog='''\n"
"...             likewise for this epilog whose whitespace will\n"
"...         be cleaned up and whose words will be wrapped\n"
"...         across a couple lines''')\n"
">>> parser.print_help()\n"
"usage: PROG [-h]\n"
"\n"
"this description was indented weird but that is okay\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
"\n"
"likewise for this epilog whose whitespace will be cleaned up and whose "
"words\n"
"will be wrapped across a couple lines"
msgstr ""

#: ../../library/argparse.rst:468
msgid ""
"Passing :class:`RawDescriptionHelpFormatter` as ``formatter_class=`` "
"indicates that description_ and epilog_ are already correctly formatted and "
"should not be line-wrapped::"
msgstr ""
"Passar :class:`RawDescriptionHelpFormatter` como ``formatter_class=`` indica "
"que description_ e epilog_ já estão formatados corretamente e não devem ter "
"suas linhas quebradas::"

#: ../../library/argparse.rst:472
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.RawDescriptionHelpFormatter,\n"
"...     description=textwrap.dedent('''\\\n"
"...         Please do not mess up this text!\n"
"...         --------------------------------\n"
"...             I have indented it\n"
"...             exactly the way\n"
"...             I want it\n"
"...         '''))\n"
">>> parser.print_help()\n"
"usage: PROG [-h]\n"
"\n"
"Please do not mess up this text!\n"
"--------------------------------\n"
"   I have indented it\n"
"   exactly the way\n"
"   I want it\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"
msgstr ""

#: ../../library/argparse.rst:494
msgid ""
":class:`RawTextHelpFormatter` maintains whitespace for all sorts of help "
"text, including argument descriptions. However, multiple new lines are "
"replaced with one. If you wish to preserve multiple blank lines, add spaces "
"between the newlines."
msgstr ""
":class:`RawTextHelpFormatter` mantém espaços em branco para todos os tipos "
"de texto de ajuda, incluindo descrições de argumentos. No entanto, várias "
"novas linhas são substituídas por uma. Se você deseja preservar várias "
"linhas em branco, adicione espaços entre as novas linhas."

#: ../../library/argparse.rst:499
msgid ""
":class:`ArgumentDefaultsHelpFormatter` automatically adds information about "
"default values to each of the argument help messages::"
msgstr ""
":class:`ArgumentDefaultsHelpFormatter` adiciona automaticamente informações "
"sobre os valores padrão para cada uma das mensagens de ajuda do argumento::"

#: ../../library/argparse.rst:502
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int, default=42, help='FOO!')\n"
">>> parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo FOO] [bar ...]\n"
"\n"
"positional arguments:\n"
" bar         BAR! (default: [1, 2, 3])\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   FOO! (default: 42)"
msgstr ""

#: ../../library/argparse.rst:517
msgid ""
":class:`MetavarTypeHelpFormatter` uses the name of the type_ argument for "
"each argument as the display name for its values (rather than using the "
"dest_ as the regular formatter does)::"
msgstr ""
":class:`MetavarTypeHelpFormatter` usa o nome de argumento type_ para cada "
"argumento como o nome de exibição para seus valores (em vez de usar o dest_ "
"como o formatador regular faz)::"

#: ../../library/argparse.rst:521
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.MetavarTypeHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', type=float)\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo int] float\n"
"\n"
"positional arguments:\n"
"  float\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"  --foo int"
msgstr ""

#: ../../library/argparse.rst:538
msgid "prefix_chars"
msgstr "prefix_chars"

#: ../../library/argparse.rst:540
msgid ""
"Most command-line options will use ``-`` as the prefix, e.g. ``-f/--foo``. "
"Parsers that need to support different or additional prefix characters, e.g. "
"for options like ``+f`` or ``/foo``, may specify them using the "
"``prefix_chars=`` argument to the ArgumentParser constructor::"
msgstr ""
"A maioria das opções de linha de comando usará ``-`` como prefixo, por "
"exemplo, ``-f/--foo``. Analisadores sintáticos que precisam ter suporte a "
"caracteres de prefixo diferentes ou adicionais, por exemplo, para opções "
"como ``+f`` ou ``/foo``, podem especificá-las usando o argumento "
"``prefix_chars=`` para o construtor ArgumentParser::"

#: ../../library/argparse.rst:546
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+')\n"
">>> parser.add_argument('+f')\n"
">>> parser.add_argument('++bar')\n"
">>> parser.parse_args('+f X ++bar Y'.split())\n"
"Namespace(bar='Y', f='X')"
msgstr ""

#: ../../library/argparse.rst:552
msgid ""
"The ``prefix_chars=`` argument defaults to ``'-'``. Supplying a set of "
"characters that does not include ``-`` will cause ``-f/--foo`` options to be "
"disallowed."
msgstr ""
"O argumento ``prefix_chars=`` é padronizado como ``'-'``. Fornecer um "
"conjunto de caracteres que não inclua ``-`` fará com que as opções ``-f/--"
"foo`` não sejam permitidas."

#: ../../library/argparse.rst:558
msgid "fromfile_prefix_chars"
msgstr "fromfile_prefix_chars"

#: ../../library/argparse.rst:560
msgid ""
"Sometimes, when dealing with a particularly long argument list, it may make "
"sense to keep the list of arguments in a file rather than typing it out at "
"the command line.  If the ``fromfile_prefix_chars=`` argument is given to "
"the :class:`ArgumentParser` constructor, then arguments that start with any "
"of the specified characters will be treated as files, and will be replaced "
"by the arguments they contain.  For example::"
msgstr ""
"Às vezes ao lidar com uma lista de argumentos particularmente longa, pode "
"fazer sentido manter a lista de argumentos em um arquivo em vez de digitá-la "
"na linha de comando. Se o argumento ``fromfile_prefix_chars=`` for dado ao "
"construtor :class:`ArgumentParser`, então os argumentos que começam com "
"qualquer um dos caracteres especificados serão tratados como arquivos e "
"serão substituídos pelos argumentos que eles contêm. Por exemplo::"

#: ../../library/argparse.rst:567
msgid ""
">>> with open('args.txt', 'w', encoding=sys.getfilesystemencoding()) as fp:\n"
"...     fp.write('-f\\nbar')\n"
"...\n"
">>> parser = argparse.ArgumentParser(fromfile_prefix_chars='@')\n"
">>> parser.add_argument('-f')\n"
">>> parser.parse_args(['-f', 'foo', '@args.txt'])\n"
"Namespace(f='bar')"
msgstr ""

#: ../../library/argparse.rst:575
msgid ""
"Arguments read from a file must by default be one per line (but see also :"
"meth:`~ArgumentParser.convert_arg_line_to_args`) and are treated as if they "
"were in the same place as the original file referencing argument on the "
"command line.  So in the example above, the expression ``['-f', 'foo', "
"'@args.txt']`` is considered equivalent to the expression ``['-f', 'foo', '-"
"f', 'bar']``."
msgstr ""
"Os argumentos lidos de um arquivo devem, por padrão, ser um por linha (mas "
"veja também :meth:`~ArgumentParser.convert_arg_line_to_args`) e são tratados "
"como se estivessem no mesmo lugar que o argumento de referência do arquivo "
"original na linha de comando. Portanto, no exemplo acima, a expressão ``['-"
"f', 'foo', '@args.txt']`` é considerada equivalente à expressão ``['-f', "
"'foo', '-f', 'bar']``."

#: ../../library/argparse.rst:581
msgid ""
":class:`ArgumentParser` uses :term:`filesystem encoding and error handler` "
"to read the file containing arguments."
msgstr ""
":class:`ArgumentParser` usa :term:`tratador de erros e codificação do "
"sistema de arquivos` para ler o arquivo que contém argumentos."

#: ../../library/argparse.rst:584
msgid ""
"The ``fromfile_prefix_chars=`` argument defaults to ``None``, meaning that "
"arguments will never be treated as file references."
msgstr ""
"O argumento ``fromfile_prefix_chars=`` é padronizado como ``None``, "
"significando que os argumentos nunca serão tratados como referências de "
"arquivo."

#: ../../library/argparse.rst:587
msgid ""
":class:`ArgumentParser` changed encoding and errors to read arguments files "
"from default (e.g. :func:`locale.getpreferredencoding(False) <locale."
"getpreferredencoding>` and ``\"strict\"``) to :term:`filesystem encoding and "
"error handler`. Arguments file should be encoded in UTF-8 instead of ANSI "
"Codepage on Windows."
msgstr ""
":class:`ArgumentParser` alterou a codificação e os erros para ler arquivos "
"de argumentos do padrão (por exemplo, :func:`locale."
"getpreferredencoding(False) <locale.getpreferredencoding>` e ``\"strict\"``) "
"para :term:`tratador de erros e codificação do sistema de arquivos`. O "
"arquivo de argumentos deve ser codificado em UTF-8 em vez de página de "
"código ANSI no Windows."

#: ../../library/argparse.rst:595
msgid "argument_default"
msgstr "argument_default"

#: ../../library/argparse.rst:597
msgid ""
"Generally, argument defaults are specified either by passing a default to :"
"meth:`~ArgumentParser.add_argument` or by calling the :meth:`~ArgumentParser."
"set_defaults` methods with a specific set of name-value pairs.  Sometimes "
"however, it may be useful to specify a single parser-wide default for "
"arguments.  This can be accomplished by passing the ``argument_default=`` "
"keyword argument to :class:`ArgumentParser`.  For example, to globally "
"suppress attribute creation on :meth:`~ArgumentParser.parse_args` calls, we "
"supply ``argument_default=SUPPRESS``::"
msgstr ""
"Geralmente, os padrões dos argumentos são especificados passando um padrão "
"para :meth:`~ArgumentParser.add_argument` ou chamando os métodos :meth:"
"`~ArgumentParser.set_defaults` com um conjunto específico de pares nome-"
"valor. Às vezes, no entanto, pode ser útil especificar um único padrão para "
"todo o analisador para argumentos. Isso pode ser feito passando o argumento "
"nomeado ``argument_default=`` para :class:`ArgumentParser`. Por exemplo, "
"para suprimir globalmente a criação de atributos em chamadas :meth:"
"`~ArgumentParser.parse_args`, fornecemos ``argument_default=SUPPRESS``::"

#: ../../library/argparse.rst:606
msgid ""
">>> parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar', nargs='?')\n"
">>> parser.parse_args(['--foo', '1', 'BAR'])\n"
"Namespace(bar='BAR', foo='1')\n"
">>> parser.parse_args([])\n"
"Namespace()"
msgstr ""

#: ../../library/argparse.rst:617
msgid "allow_abbrev"
msgstr "allow_abbrev"

#: ../../library/argparse.rst:619
msgid ""
"Normally, when you pass an argument list to the :meth:`~ArgumentParser."
"parse_args` method of an :class:`ArgumentParser`, it :ref:`recognizes "
"abbreviations <prefix-matching>` of long options."
msgstr ""
"Normalmente, quando você passa uma lista de argumentos para o método :meth:"
"`~ArgumentParser.parse_args` de um :class:`ArgumentParser`, ele :ref:"
"`reconhece as abreviações <prefix-matching>` de opções longas."

#: ../../library/argparse.rst:623
msgid "This feature can be disabled by setting ``allow_abbrev`` to ``False``::"
msgstr ""
"Este recurso pode ser desabilitado configurando ``allow_abbrev`` para "
"``False``::"

#: ../../library/argparse.rst:625
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', allow_abbrev=False)\n"
">>> parser.add_argument('--foobar', action='store_true')\n"
">>> parser.add_argument('--foonley', action='store_false')\n"
">>> parser.parse_args(['--foon'])\n"
"usage: PROG [-h] [--foobar] [--foonley]\n"
"PROG: error: unrecognized arguments: --foon"
msgstr ""

#: ../../library/argparse.rst:636
msgid "conflict_handler"
msgstr "conflict_handler"

#: ../../library/argparse.rst:638
msgid ""
":class:`ArgumentParser` objects do not allow two actions with the same "
"option string.  By default, :class:`ArgumentParser` objects raise an "
"exception if an attempt is made to create an argument with an option string "
"that is already in use::"
msgstr ""
"Objetos :class:`ArgumentParser` não permitem duas ações com a mesma string "
"de opções. Por padrão, objetos :class:`ArgumentParser` levantam uma exceção "
"se for feita uma tentativa de criar um argumento com uma string de opção que "
"já esteja em uso::"

#: ../../library/argparse.rst:643
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo', help='old foo help')\n"
">>> parser.add_argument('--foo', help='new foo help')\n"
"Traceback (most recent call last):\n"
" ..\n"
"ArgumentError: argument --foo: conflicting option string(s): --foo"
msgstr ""

#: ../../library/argparse.rst:650
msgid ""
"Sometimes (e.g. when using parents_) it may be useful to simply override any "
"older arguments with the same option string.  To get this behavior, the "
"value ``'resolve'`` can be supplied to the ``conflict_handler=`` argument "
"of :class:`ArgumentParser`::"
msgstr ""
"Às vezes (por exemplo, ao usar os parents_) pode ser útil simplesmente "
"substituir quaisquer argumentos mais antigos com a mesma string de opções. "
"Para obter este comportamento, o valor ``'resolve'`` pode ser fornecido ao "
"argumento ``conflict_handler=`` de :class:`ArgumentParser`::"

#: ../../library/argparse.rst:655
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', "
"conflict_handler='resolve')\n"
">>> parser.add_argument('-f', '--foo', help='old foo help')\n"
">>> parser.add_argument('--foo', help='new foo help')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [-f FOO] [--foo FOO]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" -f FOO      old foo help\n"
" --foo FOO   new foo help"
msgstr ""

#: ../../library/argparse.rst:666
msgid ""
"Note that :class:`ArgumentParser` objects only remove an action if all of "
"its option strings are overridden.  So, in the example above, the old ``-f/--"
"foo`` action is retained as the ``-f`` action, because only the ``--foo`` "
"option string was overridden."
msgstr ""
"Observe que os objetos :class:`ArgumentParser` só removem uma ação se todas "
"as suas strings de opção forem substituídas. Assim, no exemplo acima, a "
"antiga ação ``-f/--foo`` é mantida como a ação ``-f``, porque apenas a "
"string de opção ``--foo`` foi substituída."

#: ../../library/argparse.rst:673
msgid "add_help"
msgstr "add_help"

#: ../../library/argparse.rst:675
msgid ""
"By default, ArgumentParser objects add an option which simply displays the "
"parser's help message. For example, consider a file named ``myprogram.py`` "
"containing the following code::"
msgstr ""
"Por padrão, os objetos ArgumentParser adicionam uma opção que simplesmente "
"exibe a mensagem de ajuda do analisador. Por exemplo, considere um arquivo "
"chamado ``myprogram.py`` contendo o seguinte código::"

#: ../../library/argparse.rst:684
msgid ""
"If ``-h`` or ``--help`` is supplied at the command line, the ArgumentParser "
"help will be printed:"
msgstr ""
"Se ``-h`` ou ``--help`` for fornecido na linha de comando, a ajuda do "
"ArgumentParser será impressa:"

#: ../../library/argparse.rst:687
msgid ""
"$ python myprogram.py --help\n"
"usage: myprogram.py [-h] [--foo FOO]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   foo help"
msgstr ""

#: ../../library/argparse.rst:696
msgid ""
"Occasionally, it may be useful to disable the addition of this help option. "
"This can be achieved by passing ``False`` as the ``add_help=`` argument to :"
"class:`ArgumentParser`::"
msgstr ""
"Às vezes, pode ser útil desabilitar o acréscimo desta opção de ajuda. Isto "
"pode ser feito passando ``False`` como o argumento ``add_help=`` para a "
"classe :class:`ArgumentParser`::"

#: ../../library/argparse.rst:700
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> parser.add_argument('--foo', help='foo help')\n"
">>> parser.print_help()\n"
"usage: PROG [--foo FOO]\n"
"\n"
"options:\n"
" --foo FOO  foo help"
msgstr ""

#: ../../library/argparse.rst:708
msgid ""
"The help option is typically ``-h/--help``. The exception to this is if the "
"``prefix_chars=`` is specified and does not include ``-``, in which case ``-"
"h`` and ``--help`` are not valid options.  In this case, the first character "
"in ``prefix_chars`` is used to prefix the help options::"
msgstr ""
"A opção de ajuda é normalmente ``-h/--help``. A exceção a isso é se o "
"``prefix_chars=`` for especificado e não incluir ``-``, neste caso ``-h`` e "
"``--help`` não são opções válidas. Neste caso, o primeiro caractere em "
"``prefix_chars`` é usado para prefixar as opções de ajuda::"

#: ../../library/argparse.rst:714
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='+/')\n"
">>> parser.print_help()\n"
"usage: PROG [+h]\n"
"\n"
"options:\n"
"  +h, ++help  show this help message and exit"
msgstr ""

#: ../../library/argparse.rst:723
msgid "exit_on_error"
msgstr "exit_on_error"

#: ../../library/argparse.rst:725
msgid ""
"Normally, when you pass an invalid argument list to the :meth:"
"`~ArgumentParser.parse_args` method of an :class:`ArgumentParser`, it will "
"exit with error info."
msgstr ""
"Normalmente, quando você passa uma lista de argumentos inválidos para o "
"método :meth:`~ArgumentParser.parse_args` de um :class:`ArgumentParser`, ele "
"sairá com informações de erro."

#: ../../library/argparse.rst:728
msgid ""
"If the user would like to catch errors manually, the feature can be enabled "
"by setting ``exit_on_error`` to ``False``::"
msgstr ""
"Se o usuário quiser detectar erros manualmente, o recurso pode ser "
"habilitado configurando ``exit_on_error`` para ``False``::"

#: ../../library/argparse.rst:731
msgid ""
">>> parser = argparse.ArgumentParser(exit_on_error=False)\n"
">>> parser.add_argument('--integers', type=int)\n"
"_StoreAction(option_strings=['--integers'], dest='integers', nargs=None, "
"const=None, default=None, type=<class 'int'>, choices=None, help=None, "
"metavar=None)\n"
">>> try:\n"
"...     parser.parse_args('--integers a'.split())\n"
"... except argparse.ArgumentError:\n"
"...     print('Catching an argumentError')\n"
"...\n"
"Catching an argumentError"
msgstr ""

#: ../../library/argparse.rst:745
msgid "The add_argument() method"
msgstr "O método add_argument()"

#: ../../library/argparse.rst:751
msgid ""
"Define how a single command-line argument should be parsed.  Each parameter "
"has its own more detailed description below, but in short they are:"
msgstr ""
"Define como um único argumento de linha de comando deve ser analisado. Cada "
"parâmetro tem sua própria descrição mais detalhada abaixo, mas resumidamente "
"são eles:"

#: ../../library/argparse.rst:754
msgid ""
"`name or flags`_ - Either a name or a list of option strings, e.g. ``foo`` "
"or ``-f, --foo``."
msgstr ""
"`name ou flags`_ - Um nome ou uma lista de strings de opções, por exemplo. "
"``foo`` ou ``-f, --foo``."

#: ../../library/argparse.rst:757
msgid ""
"action_ - The basic type of action to be taken when this argument is "
"encountered at the command line."
msgstr ""
"action_ - O tipo básico de ação a ser executada quando esse argumento é "
"encontrado na linha de comando."

#: ../../library/argparse.rst:760
msgid "nargs_ - The number of command-line arguments that should be consumed."
msgstr ""
"nargs_ - O número de argumentos de linha de comando que devem ser consumidos."

#: ../../library/argparse.rst:762
msgid ""
"const_ - A constant value required by some action_ and nargs_ selections."
msgstr ""
"const_ - Um valor constante exigido por algumas seleções action_ e nargs_."

#: ../../library/argparse.rst:764
msgid ""
"default_ - The value produced if the argument is absent from the command "
"line and if it is absent from the namespace object."
msgstr ""
"default_ - O valor produzido se o argumento estiver ausente da linha de "
"comando e se estiver ausente do objeto espaço de nomes."

#: ../../library/argparse.rst:767
msgid ""
"type_ - The type to which the command-line argument should be converted."
msgstr ""
"type_ - O tipo para o qual o argumento de linha de comando deve ser "
"convertido."

#: ../../library/argparse.rst:769
msgid "choices_ - A sequence of the allowable values for the argument."
msgstr "choices_ - Uma sequência dos valores permitidos para o argumento."

#: ../../library/argparse.rst:771
msgid ""
"required_ - Whether or not the command-line option may be omitted (optionals "
"only)."
msgstr ""
"required_ - Se a opção de linha de comando pode ou não ser omitida (somente "
"opcionais)."

#: ../../library/argparse.rst:774
msgid "help_ - A brief description of what the argument does."
msgstr "help_ - Uma breve descrição do que o argumento faz."

#: ../../library/argparse.rst:776
msgid "metavar_ - A name for the argument in usage messages."
msgstr "metavar_ - Um nome para o argumento nas mensagens de uso."

#: ../../library/argparse.rst:778
msgid ""
"dest_ - The name of the attribute to be added to the object returned by :"
"meth:`parse_args`."
msgstr ""
"dest_ - O nome do atributo a ser adicionado ao objeto retornado por :meth:"
"`parse_args`."

#: ../../library/argparse.rst:787
msgid "name or flags"
msgstr "name ou flags"

#: ../../library/argparse.rst:789
msgid ""
"The :meth:`~ArgumentParser.add_argument` method must know whether an "
"optional argument, like ``-f`` or ``--foo``, or a positional argument, like "
"a list of filenames, is expected.  The first arguments passed to :meth:"
"`~ArgumentParser.add_argument` must therefore be either a series of flags, "
"or a simple argument name."
msgstr ""
"O método :meth:`~ArgumentParser.add_argument` deve saber se um argumento "
"opcional, como ``-f`` ou ``--foo``, ou um argumento posicional, como uma "
"lista de nomes de arquivos, é esperado. Os primeiros argumentos passados ​​"
"para :meth:`~ArgumentParser.add_argument` devem, portanto, ser uma série de "
"sinalizadores ou um simples nome de argumento."

#: ../../library/argparse.rst:795
msgid "For example, an optional argument could be created like::"
msgstr "Por exemplo, um argumento opcional poderia ser criado como::"

#: ../../library/argparse.rst:797
msgid ">>> parser.add_argument('-f', '--foo')"
msgstr ""

#: ../../library/argparse.rst:799
msgid "while a positional argument could be created like::"
msgstr "enquanto um argumento posicional pode ser criado como::"

#: ../../library/argparse.rst:801
msgid ">>> parser.add_argument('bar')"
msgstr ""

#: ../../library/argparse.rst:803
msgid ""
"When :meth:`~ArgumentParser.parse_args` is called, optional arguments will "
"be identified by the ``-`` prefix, and the remaining arguments will be "
"assumed to be positional::"
msgstr ""
"Quando :meth:`~ArgumentParser.parse_args` é chamado, argumentos opcionais "
"serão identificados pelo prefixo ``-``, e os argumentos restantes serão "
"considerados posicionais::"

#: ../../library/argparse.rst:807
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['BAR'])\n"
"Namespace(bar='BAR', foo=None)\n"
">>> parser.parse_args(['BAR', '--foo', 'FOO'])\n"
"Namespace(bar='BAR', foo='FOO')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"usage: PROG [-h] [-f FOO] bar\n"
"PROG: error: the following arguments are required: bar"
msgstr ""

#: ../../library/argparse.rst:822
msgid "action"
msgstr "ação"

#: ../../library/argparse.rst:824
msgid ""
":class:`ArgumentParser` objects associate command-line arguments with "
"actions.  These actions can do just about anything with the command-line "
"arguments associated with them, though most actions simply add an attribute "
"to the object returned by :meth:`~ArgumentParser.parse_args`.  The "
"``action`` keyword argument specifies how the command-line arguments should "
"be handled. The supplied actions are:"
msgstr ""
"Objetos :class:`ArgumentParser` associam argumentos de linha de comando com "
"ações. Essas ações podem fazer praticamente qualquer coisa com os argumentos "
"de linha de comando associados a elas, embora a maioria das ações "
"simplesmente adicione um atributo ao objeto retornado por :meth:"
"`~ArgumentParser.parse_args`. O argumento nomeado ``action`` especifica como "
"os argumentos da linha de comando devem ser tratados. As ações fornecidas "
"são:"

#: ../../library/argparse.rst:830
msgid ""
"``'store'`` - This just stores the argument's value.  This is the default "
"action. For example::"
msgstr ""
"``'store'`` - Isso apenas armazena o valor do argumento. Esta é a ação "
"padrão. Por exemplo::"

#: ../../library/argparse.rst:833
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args('--foo 1'.split())\n"
"Namespace(foo='1')"
msgstr ""

#: ../../library/argparse.rst:838
msgid ""
"``'store_const'`` - This stores the value specified by the const_ keyword "
"argument; note that the const_ keyword argument defaults to ``None``.  The "
"``'store_const'`` action is most commonly used with optional arguments that "
"specify some sort of flag.  For example::"
msgstr ""
"``'store_const'`` - Isso armazena o valor especificado pelo argumento "
"nomeado const_; observe que o argumento nomeado const_ tem como padrão "
"``None``. A ação ``'store_const'`` é mais comumente usada com argumentos "
"opcionais que especificam algum tipo de sinalizador. Por exemplo::"

#: ../../library/argparse.rst:843
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_const', const=42)\n"
">>> parser.parse_args(['--foo'])\n"
"Namespace(foo=42)"
msgstr ""

#: ../../library/argparse.rst:848
msgid ""
"``'store_true'`` and ``'store_false'`` - These are special cases of "
"``'store_const'`` used for storing the values ``True`` and ``False`` "
"respectively.  In addition, they create default values of ``False`` and "
"``True`` respectively.  For example::"
msgstr ""
"``'store_true'`` e ``'store_false'`` - Estes são casos especiais de "
"``'store_const'`` usados para armazenar os valores ``True`` e ``False`` "
"respectivamente. Além disso, eles criam valores padrão de ``False`` e "
"``True`` respectivamente. Por exemplo::"

#: ../../library/argparse.rst:853
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('--bar', action='store_false')\n"
">>> parser.add_argument('--baz', action='store_false')\n"
">>> parser.parse_args('--foo --bar'.split())\n"
"Namespace(foo=True, bar=False, baz=True)"
msgstr ""

#: ../../library/argparse.rst:860
msgid ""
"``'append'`` - This stores a list, and appends each argument value to the "
"list. It is useful to allow an option to be specified multiple times. If the "
"default value is non-empty, the default elements will be present in the "
"parsed value for the option, with any values from the command line appended "
"after those default values. Example usage::"
msgstr ""
"``'append'`` - Isso armazena uma lista e anexa cada valor de argumento à "
"lista.  É útil permitir que uma opção seja especificada várias vezes. Se o "
"valor padrão não estiver vazio, os elementos padrão estarão presentes no "
"valor analisado da opção, com quaisquer valores da linha de comando anexados "
"após esses valores padrão. Exemplo de uso::"

#: ../../library/argparse.rst:866
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='append')\n"
">>> parser.parse_args('--foo 1 --foo 2'.split())\n"
"Namespace(foo=['1', '2'])"
msgstr ""

#: ../../library/argparse.rst:871
msgid ""
"``'append_const'`` - This stores a list, and appends the value specified by "
"the const_ keyword argument to the list; note that the const_ keyword "
"argument defaults to ``None``. The ``'append_const'`` action is typically "
"useful when multiple arguments need to store constants to the same list. For "
"example::"
msgstr ""
"``'append_const'`` - Isso armazena uma lista e anexa o valor especificado "
"pelo argumento nomeado const_ à lista; observe que o argumento nomeado "
"const_ tem como padrão ``None``. A ação ``'append_const'`` é normalmente "
"útil quando vários argumentos precisam armazenar constantes na mesma lista. "
"Por exemplo::"

#: ../../library/argparse.rst:877
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--str', dest='types', action='append_const', "
"const=str)\n"
">>> parser.add_argument('--int', dest='types', action='append_const', "
"const=int)\n"
">>> parser.parse_args('--str --int'.split())\n"
"Namespace(types=[<class 'str'>, <class 'int'>])"
msgstr ""

#: ../../library/argparse.rst:883
msgid ""
"``'count'`` - This counts the number of times a keyword argument occurs. For "
"example, this is useful for increasing verbosity levels::"
msgstr ""
"``'count'`` - Isso conta o número de vezes que um argumento nomeado ocorre. "
"Por exemplo, isso é útil para aumentar os níveis de verbosidade::"

#: ../../library/argparse.rst:886
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--verbose', '-v', action='count', default=0)\n"
">>> parser.parse_args(['-vvv'])\n"
"Namespace(verbose=3)"
msgstr ""

#: ../../library/argparse.rst:891
msgid "Note, the *default* will be ``None`` unless explicitly set to *0*."
msgstr ""
"Observe que o *padrão* será ``None``, a menos que seja explicitamente "
"definido como *0*."

#: ../../library/argparse.rst:893
msgid ""
"``'help'`` - This prints a complete help message for all the options in the "
"current parser and then exits. By default a help action is automatically "
"added to the parser. See :class:`ArgumentParser` for details of how the "
"output is created."
msgstr ""
"``'help'`` - Isso imprime uma mensagem de ajuda completa para todas as "
"opções no analisador sintático atual e sai. Por padrão, uma ação de ajuda é "
"adicionada automaticamente ao analisador sintático. Veja :class:"
"`ArgumentParser` para detalhes de como a saída é criada."

#: ../../library/argparse.rst:898
msgid ""
"``'version'`` - This expects a ``version=`` keyword argument in the :meth:"
"`~ArgumentParser.add_argument` call, and prints version information and "
"exits when invoked::"
msgstr ""
"``'version'`` - Isso espera um argumento nomeado ``version=`` na chamada :"
"meth:`~ArgumentParser.add_argument` e imprime informações de versão e sai "
"quando invocado::"

#: ../../library/argparse.rst:902
msgid ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--version', action='version', version='%(prog)s "
"2.0')\n"
">>> parser.parse_args(['--version'])\n"
"PROG 2.0"
msgstr ""

#: ../../library/argparse.rst:908
msgid ""
"``'extend'`` - This stores a list, and extends each argument value to the "
"list. Example usage::"
msgstr ""
"``'extend'`` - Isso armazena uma lista e estende cada valor de argumento "
"para a lista. Exemplo de uso::"

#: ../../library/argparse.rst:912
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\"--foo\", action=\"extend\", nargs=\"+\", "
"type=str)\n"
">>> parser.parse_args([\"--foo\", \"f1\", \"--foo\", \"f2\", \"f3\", "
"\"f4\"])\n"
"Namespace(foo=['f1', 'f2', 'f3', 'f4'])"
msgstr ""

#: ../../library/argparse.rst:919
msgid ""
"You may also specify an arbitrary action by passing an Action subclass or "
"other object that implements the same interface. The "
"``BooleanOptionalAction`` is available in ``argparse`` and adds support for "
"boolean actions such as ``--foo`` and ``--no-foo``::"
msgstr ""
"Você também pode especificar uma ação arbitrária passando uma subclasse "
"Action ou outro objeto que implemente a mesma interface. O "
"``BooleanOptionalAction`` está disponível em ``argparse`` e adiciona suporte "
"para ações booleanas como ``--foo`` e ``--no-foo``::"

#: ../../library/argparse.rst:924
msgid ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=argparse.BooleanOptionalAction)\n"
">>> parser.parse_args(['--no-foo'])\n"
"Namespace(foo=False)"
msgstr ""

#: ../../library/argparse.rst:932
msgid ""
"The recommended way to create a custom action is to extend :class:`Action`, "
"overriding the ``__call__`` method and optionally the ``__init__`` and "
"``format_usage`` methods."
msgstr ""
"A maneira recomendada de criar uma ação personalizada é estender :class:"
"`Action`, substituindo o método ``__call__`` e opcionalmente os métodos "
"``__init__`` e ``format_usage``."

#: ../../library/argparse.rst:936
msgid "An example of a custom action::"
msgstr "Um exemplo de uma ação personalizada::"

#: ../../library/argparse.rst:938
msgid ""
">>> class FooAction(argparse.Action):\n"
"...     def __init__(self, option_strings, dest, nargs=None, **kwargs):\n"
"...         if nargs is not None:\n"
"...             raise ValueError(\"nargs not allowed\")\n"
"...         super().__init__(option_strings, dest, **kwargs)\n"
"...     def __call__(self, parser, namespace, values, option_string=None):\n"
"...         print('%r %r %r' % (namespace, values, option_string))\n"
"...         setattr(namespace, self.dest, values)\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=FooAction)\n"
">>> parser.add_argument('bar', action=FooAction)\n"
">>> args = parser.parse_args('1 --foo 2'.split())\n"
"Namespace(bar=None, foo=None) '1' None\n"
"Namespace(bar='1', foo=None) '2' '--foo'\n"
">>> args\n"
"Namespace(bar='1', foo='2')"
msgstr ""

#: ../../library/argparse.rst:956
msgid "For more details, see :class:`Action`."
msgstr "Para mais detalhes, veja :class:`Action`."

#: ../../library/argparse.rst:962
msgid "nargs"
msgstr "nargs"

#: ../../library/argparse.rst:964
msgid ""
"ArgumentParser objects usually associate a single command-line argument with "
"a single action to be taken.  The ``nargs`` keyword argument associates a "
"different number of command-line arguments with a single action. See also :"
"ref:`specifying-ambiguous-arguments`. The supported values are:"
msgstr ""
"Os objetos ArgumentParser geralmente associam um único argumento de linha de "
"comando a uma única ação a ser executada. O argumento nomeado ``nargs`` "
"associa um número diferente de argumentos de linha de comando com uma única "
"ação. Veja também :ref:`specifying-ambiguous-arguments`. Os valores "
"suportados são:"

#: ../../library/argparse.rst:969
msgid ""
"``N`` (an integer).  ``N`` arguments from the command line will be gathered "
"together into a list.  For example::"
msgstr ""
"``N`` (um inteiro). Os argumentos ``N`` da linha de comando serão reunidos "
"em uma lista. Por exemplo::"

#: ../../library/argparse.rst:972
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs=2)\n"
">>> parser.add_argument('bar', nargs=1)\n"
">>> parser.parse_args('c --foo a b'.split())\n"
"Namespace(bar=['c'], foo=['a', 'b'])"
msgstr ""

#: ../../library/argparse.rst:978
msgid ""
"Note that ``nargs=1`` produces a list of one item.  This is different from "
"the default, in which the item is produced by itself."
msgstr ""
"Observe que ``nargs=1`` produz uma lista de um item. Isso é diferente do "
"padrão, em que o item é produzido sozinho."

#: ../../library/argparse.rst:983
msgid ""
"``'?'``. One argument will be consumed from the command line if possible, "
"and produced as a single item.  If no command-line argument is present, the "
"value from default_ will be produced.  Note that for optional arguments, "
"there is an additional case - the option string is present but not followed "
"by a command-line argument.  In this case the value from const_ will be "
"produced.  Some examples to illustrate this::"
msgstr ""
"``'?'``. Um argumento será consumido da linha de comando, se possível, e "
"produzido como um único item. Se nenhum argumento de linha de comando "
"estiver presente, o valor de default_ será produzido. Observe que, para "
"argumentos opcionais, há um caso adicional - a string de opções está "
"presente, mas não é seguida por um argumento de linha de comando. Neste caso "
"o valor de const_ será produzido. Alguns exemplos para ilustrar isso::"

#: ../../library/argparse.rst:990
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='?', const='c', default='d')\n"
">>> parser.add_argument('bar', nargs='?', default='d')\n"
">>> parser.parse_args(['XX', '--foo', 'YY'])\n"
"Namespace(bar='XX', foo='YY')\n"
">>> parser.parse_args(['XX', '--foo'])\n"
"Namespace(bar='XX', foo='c')\n"
">>> parser.parse_args([])\n"
"Namespace(bar='d', foo='d')"
msgstr ""

#: ../../library/argparse.rst:1000
msgid ""
"One of the more common uses of ``nargs='?'`` is to allow optional input and "
"output files::"
msgstr ""
"Um dos usos mais comuns de ``nargs='?'`` é permitir arquivos de entrada e "
"saída opcionais::"

#: ../../library/argparse.rst:1003
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('infile', nargs='?', type=argparse.FileType('r'),\n"
"...                     default=sys.stdin)\n"
">>> parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'),\n"
"...                     default=sys.stdout)\n"
">>> parser.parse_args(['input.txt', 'output.txt'])\n"
"Namespace(infile=<_io.TextIOWrapper name='input.txt' encoding='UTF-8'>,\n"
"          outfile=<_io.TextIOWrapper name='output.txt' encoding='UTF-8'>)\n"
">>> parser.parse_args([])\n"
"Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>,\n"
"          outfile=<_io.TextIOWrapper name='<stdout>' encoding='UTF-8'>)"
msgstr ""

#: ../../library/argparse.rst:1017
msgid ""
"``'*'``.  All command-line arguments present are gathered into a list.  Note "
"that it generally doesn't make much sense to have more than one positional "
"argument with ``nargs='*'``, but multiple optional arguments with "
"``nargs='*'`` is possible.  For example::"
msgstr ""
"``'*'``. Todos os argumentos de linha de comando presentes são reunidos em "
"uma lista. Note que geralmente não faz muito sentido ter mais de um "
"argumento posicional com ``nargs='*'``, mas vários argumentos opcionais com "
"``nargs='*'`` são possíveis. Por exemplo::"

#: ../../library/argparse.rst:1022
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='*')\n"
">>> parser.add_argument('--bar', nargs='*')\n"
">>> parser.add_argument('baz', nargs='*')\n"
">>> parser.parse_args('a b --foo x y --bar 1 2'.split())\n"
"Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])"
msgstr ""

#: ../../library/argparse.rst:1031
msgid ""
"``'+'``. Just like ``'*'``, all command-line args present are gathered into "
"a list.  Additionally, an error message will be generated if there wasn't at "
"least one command-line argument present.  For example::"
msgstr ""
"``'+'``. Assim como ``'*'``, todos os argumentos de linha de comando "
"presentes são reunidos em uma lista. Além disso, uma mensagem de erro será "
"gerada se não houver pelo menos um argumento de linha de comando presente. "
"Por exemplo::"

#: ../../library/argparse.rst:1035
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('foo', nargs='+')\n"
">>> parser.parse_args(['a', 'b'])\n"
"Namespace(foo=['a', 'b'])\n"
">>> parser.parse_args([])\n"
"usage: PROG [-h] foo [foo ...]\n"
"PROG: error: the following arguments are required: foo"
msgstr ""

#: ../../library/argparse.rst:1043
msgid ""
"If the ``nargs`` keyword argument is not provided, the number of arguments "
"consumed is determined by the action_.  Generally this means a single "
"command-line argument will be consumed and a single item (not a list) will "
"be produced."
msgstr ""
"Se o argumento nomeado ``nargs`` não for fornecido, o número de argumentos "
"consumidos é determinado pela action_. Geralmente, isso significa que um "
"único argumento de linha de comando será consumido e um único item (não uma "
"lista) será produzido."

#: ../../library/argparse.rst:1051
msgid "const"
msgstr "const"

#: ../../library/argparse.rst:1053
msgid ""
"The ``const`` argument of :meth:`~ArgumentParser.add_argument` is used to "
"hold constant values that are not read from the command line but are "
"required for the various :class:`ArgumentParser` actions.  The two most "
"common uses of it are:"
msgstr ""
"O argumento ``const`` de :meth:`~ArgumentParser.add_argument` é usado para "
"manter valores constantes que não são lidos da linha de comando, mas são "
"necessários para as várias ações :class:`ArgumentParser`. Os dois usos mais "
"comuns são:"

#: ../../library/argparse.rst:1057
msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with "
"``action='store_const'`` or ``action='append_const'``.  These actions add "
"the ``const`` value to one of the attributes of the object returned by :meth:"
"`~ArgumentParser.parse_args`. See the action_ description for examples. If "
"``const`` is not provided to :meth:`~ArgumentParser.add_argument`, it will "
"receive a default value of ``None``."
msgstr ""
"Quando :meth:`~ArgumentParser.add_argument` é chamado com "
"``action='store_const'`` ou ``action='append_const'``. Essas ações adicionam "
"o valor ``const`` a um dos atributos do objeto retornado por :meth:"
"`~ArgumentParser.parse_args`. Consulte a descrição da action_ para obter "
"exemplos. Se ``const`` não for fornecido :meth:`~ArgumentParser."
"add_argument`, será recebido um valor padrão de ``None``."

#: ../../library/argparse.rst:1065
msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with option strings "
"(like ``-f`` or ``--foo``) and ``nargs='?'``.  This creates an optional "
"argument that can be followed by zero or one command-line arguments. When "
"parsing the command line, if the option string is encountered with no "
"command-line argument following it, the value of ``const`` will be assumed "
"to be ``None`` instead.  See the nargs_ description for examples."
msgstr ""
"Quando :meth:`~ArgumentParser.add_argument` é chamado com strings de opções "
"(como ``-f`` ou ``--foo``) e ``nargs='?'``. Isso cria um argumento opcional "
"que pode ser seguido por zero ou um argumento de linha de comando. Ao "
"analisar a linha de comando, se a string de opções for encontrada sem nenhum "
"argumento de linha de comando seguindo, o valor de ``const`` será presumido "
"como sendo ``None``. Veja a descrição de nargs_ para exemplos."

#: ../../library/argparse.rst:1072
msgid ""
"``const=None`` by default, including when ``action='append_const'`` or "
"``action='store_const'``."
msgstr ""
"``const=None`` por padrão, incluindo quando ``action='append_const'`` ou "
"``action='store_const'``."

#: ../../library/argparse.rst:1079
msgid "default"
msgstr "default"

#: ../../library/argparse.rst:1081
msgid ""
"All optional arguments and some positional arguments may be omitted at the "
"command line.  The ``default`` keyword argument of :meth:`~ArgumentParser."
"add_argument`, whose value defaults to ``None``, specifies what value should "
"be used if the command-line argument is not present. For optional arguments, "
"the ``default`` value is used when the option string was not present at the "
"command line::"
msgstr ""
"Todos os argumentos opcionais e alguns argumentos posicionais podem ser "
"omitidos na linha de comando. O argumento nomeado ``default`` de :meth:"
"`~ArgumentParser.add_argument`, cujo valor padrão é ``None``, especifica "
"qual valor deve ser usado se o argumento de linha de comando não estiver "
"presente. Para argumentos opcionais, o valor ``default`` é usado quando a "
"string de opção não estava presente na linha de comando::"

#: ../../library/argparse.rst:1088
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args(['--foo', '2'])\n"
"Namespace(foo='2')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"
msgstr ""

#: ../../library/argparse.rst:1095
msgid ""
"If the target namespace already has an attribute set, the action *default* "
"will not over write it::"
msgstr ""
"Se o espaço de nomes de destino já tiver um atributo definido, a ação "
"*default* não o substituirá::"

#: ../../library/argparse.rst:1098
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args([], namespace=argparse.Namespace(foo=101))\n"
"Namespace(foo=101)"
msgstr ""

#: ../../library/argparse.rst:1103
msgid ""
"If the ``default`` value is a string, the parser parses the value as if it "
"were a command-line argument.  In particular, the parser applies any type_ "
"conversion argument, if provided, before setting the attribute on the :class:"
"`Namespace` return value.  Otherwise, the parser uses the value as is::"
msgstr ""
"Se o valor ``default`` for uma string, o analisador analisa o valor como se "
"fosse um argumento de linha de comando. Em particular, o analisador aplica "
"qualquer argumento de conversão type_, se fornecido, antes de definir o "
"atributo no valor de retorno :class:`Namespace`. Caso contrário, o "
"analisador usa o valor como está::"

#: ../../library/argparse.rst:1108
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--length', default='10', type=int)\n"
">>> parser.add_argument('--width', default=10.5, type=int)\n"
">>> parser.parse_args()\n"
"Namespace(length=10, width=10.5)"
msgstr ""

#: ../../library/argparse.rst:1114
msgid ""
"For positional arguments with nargs_ equal to ``?`` or ``*``, the "
"``default`` value is used when no command-line argument was present::"
msgstr ""
"Para argumentos posicionais com nargs_ igual a ``?`` ou ``*``, o valor "
"``default`` é usado quando nenhum argumento de linha de comando estava "
"presente::"

#: ../../library/argparse.rst:1117
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', nargs='?', default=42)\n"
">>> parser.parse_args(['a'])\n"
"Namespace(foo='a')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"
msgstr ""

#: ../../library/argparse.rst:1124
msgid ""
"For required_ arguments, the ``default`` value is ignored. For example, this "
"applies to positional arguments with nargs_ values other than ``?`` or "
"``*``, or optional arguments marked as ``required=True``."
msgstr ""

#: ../../library/argparse.rst:1128
msgid ""
"Providing ``default=argparse.SUPPRESS`` causes no attribute to be added if "
"the command-line argument was not present::"
msgstr ""
"Fornecer ``default=argparse.SUPPRESS`` faz com que nenhum atributo seja "
"adicionado se o argumento da linha de comando não estiver presente::"

#: ../../library/argparse.rst:1131
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=argparse.SUPPRESS)\n"
">>> parser.parse_args([])\n"
"Namespace()\n"
">>> parser.parse_args(['--foo', '1'])\n"
"Namespace(foo='1')"
msgstr ""

#: ../../library/argparse.rst:1142
msgid "type"
msgstr "tipo"

#: ../../library/argparse.rst:1144
msgid ""
"By default, the parser reads command-line arguments in as simple strings. "
"However, quite often the command-line string should instead be interpreted "
"as another type, such as a :class:`float` or :class:`int`.  The ``type`` "
"keyword for :meth:`~ArgumentParser.add_argument` allows any necessary type-"
"checking and type conversions to be performed."
msgstr ""
"Por padrão, o analisador sintático lê argumentos de linha de comando como "
"strings simples. No entanto, muitas vezes a string da linha de comando deve "
"ser interpretada como outro tipo, como :class:`float` ou :class:`int`. O "
"argumento nomeado ``type`` para :meth:`~ArgumentParser.add_argument` permite "
"que qualquer verificação de tipo e conversões de tipo necessárias sejam "
"realizadas."

#: ../../library/argparse.rst:1150
msgid ""
"If the type_ keyword is used with the default_ keyword, the type converter "
"is only applied if the default is a string."
msgstr ""
"Se o argumento nomeado type_ for usado com default_, o conversor de tipo só "
"será aplicado se o padrão for uma string."

#: ../../library/argparse.rst:1153
msgid ""
"The argument to ``type`` can be any callable that accepts a single string. "
"If the function raises :exc:`ArgumentTypeError`, :exc:`TypeError`, or :exc:"
"`ValueError`, the exception is caught and a nicely formatted error message "
"is displayed.  No other exception types are handled."
msgstr ""
"O argumento para ``type`` pode ser qualquer chamável que aceite uma única "
"string. Se a função levantar :exc:`ArgumentTypeError`, :exc:`TypeError` ou :"
"exc:`ValueError`, a exceção será capturada e uma mensagem de erro bem "
"formatada será exibida. Nenhum outro tipo de exceção é tratado."

#: ../../library/argparse.rst:1158
msgid "Common built-in types and functions can be used as type converters:"
msgstr ""
"Tipos e funções embutidas comuns podem ser usados ​​como conversores de tipo:"

#: ../../library/argparse.rst:1160
msgid ""
"import argparse\n"
"import pathlib\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('count', type=int)\n"
"parser.add_argument('distance', type=float)\n"
"parser.add_argument('street', type=ascii)\n"
"parser.add_argument('code_point', type=ord)\n"
"parser.add_argument('source_file', type=open)\n"
"parser.add_argument('dest_file', type=argparse.FileType('w', "
"encoding='latin-1'))\n"
"parser.add_argument('datapath', type=pathlib.Path)"
msgstr ""

#: ../../library/argparse.rst:1174
msgid "User defined functions can be used as well:"
msgstr "Funções definidas pelo usuário também podem ser usadas:"

#: ../../library/argparse.rst:1176
msgid ""
">>> def hyphenated(string):\n"
"...     return '-'.join([word[:4] for word in string.casefold().split()])\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> _ = parser.add_argument('short_title', type=hyphenated)\n"
">>> parser.parse_args(['\"The Tale of Two Cities\"'])\n"
"Namespace(short_title='\"the-tale-of-two-citi')"
msgstr ""

#: ../../library/argparse.rst:1186
msgid ""
"The :func:`bool` function is not recommended as a type converter.  All it "
"does is convert empty strings to ``False`` and non-empty strings to "
"``True``. This is usually not what is desired."
msgstr ""
"A função :func:`bool` não é recomendada como conversor de tipo. Tudo o que "
"ele faz é converter strings vazias em ``False`` e strings não vazias em "
"``True``. Geralmente não é isso que se deseja."

#: ../../library/argparse.rst:1190
msgid ""
"In general, the ``type`` keyword is a convenience that should only be used "
"for simple conversions that can only raise one of the three supported "
"exceptions. Anything with more interesting error-handling or resource "
"management should be done downstream after the arguments are parsed."
msgstr ""
"Em geral, o argumento nomeado ``type`` é uma conveniência que só deve ser "
"usada para conversões simples que só podem gerar uma das três exceções "
"suportadas. Qualquer coisa com tratamento de erros ou gerenciamento de "
"recursos mais interessante deve ser feita posteriormente, após a análise dos "
"argumentos."

#: ../../library/argparse.rst:1195
msgid ""
"For example, JSON or YAML conversions have complex error cases that require "
"better reporting than can be given by the ``type`` keyword.  A :exc:`~json."
"JSONDecodeError` would not be well formatted and a :exc:`FileNotFoundError` "
"exception would not be handled at all."
msgstr ""
"Por exemplo, conversões JSON ou YAML têm casos de erros complexos que exigem "
"relatórios melhores do que os fornecidos pelo argumento nomeado ``type``. "
"Um :exc:`~json.JSONDecodeError` não seria bem formatado e uma exceção :exc:"
"`FileNotFoundError` não seria tratada."

#: ../../library/argparse.rst:1200
msgid ""
"Even :class:`~argparse.FileType` has its limitations for use with the "
"``type`` keyword.  If one argument uses *FileType* and then a subsequent "
"argument fails, an error is reported but the file is not automatically "
"closed.  In this case, it would be better to wait until after the parser has "
"run and then use the :keyword:`with`-statement to manage the files."
msgstr ""
"Mesmo :class:`~argparse.FileType` tem suas limitações para uso com o "
"argumento nomeado ``type``. Se um argumento usar *FileType* e um argumento "
"subsequente falhar, um erro será relatado, mas o arquivo não será fechado "
"automaticamente. Neste caso, seria melhor esperar até que o analisador tenha "
"sido executado e então usar a instrução :keyword:`with` para gerenciar os "
"arquivos."

#: ../../library/argparse.rst:1206
msgid ""
"For type checkers that simply check against a fixed set of values, consider "
"using the choices_ keyword instead."
msgstr ""
"Para verificadores de tipo que simplesmente verificam um conjunto fixo de "
"valores, considere usar o argumento nomeado choices_."

#: ../../library/argparse.rst:1213
msgid "choices"
msgstr "choices"

#: ../../library/argparse.rst:1215
msgid ""
"Some command-line arguments should be selected from a restricted set of "
"values. These can be handled by passing a sequence object as the *choices* "
"keyword argument to :meth:`~ArgumentParser.add_argument`.  When the command "
"line is parsed, argument values will be checked, and an error message will "
"be displayed if the argument was not one of the acceptable values::"
msgstr ""
"Alguns argumentos de linha de comando devem ser selecionados em um conjunto "
"restrito de valores. Eles podem ser tratados passando um objeto sequência "
"como o argumento nomeado *choices* para :meth:`~ArgumentParser."
"add_argument`. Quando a linha de comando for analisada, os valores dos "
"argumentos serão verificados e uma mensagem de erro será exibida se o "
"argumento não for um dos valores aceitáveis::"

#: ../../library/argparse.rst:1221
msgid ""
">>> parser = argparse.ArgumentParser(prog='game.py')\n"
">>> parser.add_argument('move', choices=['rock', 'paper', 'scissors'])\n"
">>> parser.parse_args(['rock'])\n"
"Namespace(move='rock')\n"
">>> parser.parse_args(['fire'])\n"
"usage: game.py [-h] {rock,paper,scissors}\n"
"game.py: error: argument move: invalid choice: 'fire' (choose from 'rock',\n"
"'paper', 'scissors')"
msgstr ""

#: ../../library/argparse.rst:1230
msgid ""
"Note that inclusion in the *choices* sequence is checked after any type_ "
"conversions have been performed, so the type of the objects in the *choices* "
"sequence should match the type_ specified::"
msgstr ""
"Observe que a inclusão na sequência *choices* é verificada após qualquer "
"conversão de type_ ter sido realizada, portanto o tipo dos objetos na "
"sequência *choices* deve corresponder ao type_ especificado::"

#: ../../library/argparse.rst:1234
msgid ""
">>> parser = argparse.ArgumentParser(prog='doors.py')\n"
">>> parser.add_argument('door', type=int, choices=range(1, 4))\n"
">>> print(parser.parse_args(['3']))\n"
"Namespace(door=3)\n"
">>> parser.parse_args(['4'])\n"
"usage: doors.py [-h] {1,2,3}\n"
"doors.py: error: argument door: invalid choice: 4 (choose from 1, 2, 3)"
msgstr ""

#: ../../library/argparse.rst:1242
msgid ""
"Any sequence can be passed as the *choices* value, so :class:`list` "
"objects, :class:`tuple` objects, and custom sequences are all supported."
msgstr ""
"Qualquer sequência pode ser passada como o valor *choices*, portanto "
"objetos :class:`list`, objetos :class:`tuple` e sequências personalizadas "
"são todos suportados."

#: ../../library/argparse.rst:1245
msgid ""
"Use of :class:`enum.Enum` is not recommended because it is difficult to "
"control its appearance in usage, help, and error messages."
msgstr ""
"O uso de :class:`enum.Enum` não é recomendado porque é difícil controlar sua "
"aparência no uso, na ajuda e nas mensagens de erro."

#: ../../library/argparse.rst:1248
msgid ""
"Formatted choices override the default *metavar* which is normally derived "
"from *dest*.  This is usually what you want because the user never sees the "
"*dest* parameter.  If this display isn't desirable (perhaps because there "
"are many choices), just specify an explicit metavar_."
msgstr ""
"As opções formatadas substituem o *metavar* padrão que normalmente é "
"derivado de *dest*. Geralmente é isso que você deseja porque o usuário nunca "
"vê o parâmetro *dest*. Se esta exibição não for desejável (talvez porque "
"haja muitas opções), basta especificar um metavar_ explícito."

#: ../../library/argparse.rst:1257
msgid "required"
msgstr "required"

#: ../../library/argparse.rst:1259
msgid ""
"In general, the :mod:`argparse` module assumes that flags like ``-f`` and "
"``--bar`` indicate *optional* arguments, which can always be omitted at the "
"command line. To make an option *required*, ``True`` can be specified for "
"the ``required=`` keyword argument to :meth:`~ArgumentParser.add_argument`::"
msgstr ""
"Em geral, o módulo :mod:`argparse` presume que sinalizadores como ``-f`` e "
"``--bar`` indicam argumentos *opcionais*, que sempre podem ser omitidos na "
"linha de comando. Para tornar uma opção obrigatória, ``True`` pode ser "
"especificado para o argumento nomeado ``required=`` para :meth:"
"`~ArgumentParser.add_argument`::"

#: ../../library/argparse.rst:1264
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', required=True)\n"
">>> parser.parse_args(['--foo', 'BAR'])\n"
"Namespace(foo='BAR')\n"
">>> parser.parse_args([])\n"
"usage: [-h] --foo FOO\n"
": error: the following arguments are required: --foo"
msgstr ""

#: ../../library/argparse.rst:1272
msgid ""
"As the example shows, if an option is marked as ``required``, :meth:"
"`~ArgumentParser.parse_args` will report an error if that option is not "
"present at the command line."
msgstr ""
"Como mostra o exemplo, se uma opção estiver marcada como ``required``, :meth:"
"`~ArgumentParser.parse_args` reportará um erro se essa opção não estiver "
"presente na linha de comando."

#: ../../library/argparse.rst:1278
msgid ""
"Required options are generally considered bad form because users expect "
"*options* to be *optional*, and thus they should be avoided when possible."
msgstr ""
"As opções obrigatórias são geralmente consideradas inadequadas porque os "
"usuários esperam que as *opções* sejam *opcionais* e, portanto, devem ser "
"evitadas quando possível."

#: ../../library/argparse.rst:1285
msgid "help"
msgstr "help"

#: ../../library/argparse.rst:1287
msgid ""
"The ``help`` value is a string containing a brief description of the "
"argument. When a user requests help (usually by using ``-h`` or ``--help`` "
"at the command line), these ``help`` descriptions will be displayed with "
"each argument::"
msgstr ""
"O valor ``help`` é uma string contendo uma breve descrição do argumento. "
"Quando um usuário solicita ajuda (geralmente usando ``-h`` ou ``--help`` na "
"linha de comando), estas descrições de ``help`` serão exibidas com cada "
"argumento::"

#: ../../library/argparse.rst:1292
msgid ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('--foo', action='store_true',\n"
"...                     help='foo the bars before frobbling')\n"
">>> parser.add_argument('bar', nargs='+',\n"
"...                     help='one of the bars to be frobbled')\n"
">>> parser.parse_args(['-h'])\n"
"usage: frobble [-h] [--foo] bar [bar ...]\n"
"\n"
"positional arguments:\n"
" bar     one of the bars to be frobbled\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo   foo the bars before frobbling"
msgstr ""

#: ../../library/argparse.rst:1307
msgid ""
"The ``help`` strings can include various format specifiers to avoid "
"repetition of things like the program name or the argument default_.  The "
"available specifiers include the program name, ``%(prog)s`` and most keyword "
"arguments to :meth:`~ArgumentParser.add_argument`, e.g. ``%(default)s``, "
"``%(type)s``, etc.::"
msgstr ""
"As strings ``help`` podem incluir vários especificadores de formato para "
"evitar a repetição de coisas como o nome do programa ou o argumento "
"default_. Os especificadores disponíveis incluem o nome do programa, "
"``%(prog)s`` e a maioria dos argumentos nomeados para :meth:`~ArgumentParser."
"add_argument`, por exemplo. ``%(default)s``, ``%(type)s``, etc.::"

#: ../../library/argparse.rst:1312
msgid ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('bar', nargs='?', type=int, default=42,\n"
"...                     help='the bar to %(prog)s (default: %(default)s)')\n"
">>> parser.print_help()\n"
"usage: frobble [-h] [bar]\n"
"\n"
"positional arguments:\n"
" bar     the bar to frobble (default: 42)\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"
msgstr ""

#: ../../library/argparse.rst:1324
msgid ""
"As the help string supports %-formatting, if you want a literal ``%`` to "
"appear in the help string, you must escape it as ``%%``."
msgstr ""
"Como a string de ajuda oferece suporte à formatação com %, se você quiser "
"que um literal ``%`` apareça na string de ajuda, você deve escapá-lo como ``%"
"%``."

#: ../../library/argparse.rst:1327
msgid ""
":mod:`argparse` supports silencing the help entry for certain options, by "
"setting the ``help`` value to ``argparse.SUPPRESS``::"
msgstr ""
":mod:`argparse` oferece suporte a silenciar a entrada de ajuda para certas "
"opções, definindo o valor ``help`` como ``argparse.SUPPRESS``::"

#: ../../library/argparse.rst:1330
msgid ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('--foo', help=argparse.SUPPRESS)\n"
">>> parser.print_help()\n"
"usage: frobble [-h]\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit"
msgstr ""

#: ../../library/argparse.rst:1342
msgid "metavar"
msgstr "metavar"

#: ../../library/argparse.rst:1344
msgid ""
"When :class:`ArgumentParser` generates help messages, it needs some way to "
"refer to each expected argument.  By default, ArgumentParser objects use the "
"dest_ value as the \"name\" of each object.  By default, for positional "
"argument actions, the dest_ value is used directly, and for optional "
"argument actions, the dest_ value is uppercased.  So, a single positional "
"argument with ``dest='bar'`` will be referred to as ``bar``. A single "
"optional argument ``--foo`` that should be followed by a single command-line "
"argument will be referred to as ``FOO``.  An example::"
msgstr ""
"Quando :class:`ArgumentParser` gera mensagens de ajuda, ele precisa de "
"alguma forma de se referir a cada argumento esperado. Por padrão, os objetos "
"ArgumentParser usam o valor dest_ como o \"nome\" de cada objeto. Por "
"padrão, para ações de argumentos posicionais, o valor dest_ é usado "
"diretamente, e para ações de argumentos opcionais, o valor dest_ é "
"maiúsculo. Portanto, um único argumento posicional com ``dest='bar'`` será "
"referido como ``bar``. Um único argumento opcional ``--foo`` que deve ser "
"seguido por um único argumento de linha de comando será referido como "
"``FOO``. Um exemplo::"

#: ../../library/argparse.rst:1353
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo FOO] bar\n"
"\n"
"positional arguments:\n"
" bar\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO"
msgstr ""

#: ../../library/argparse.rst:1368
msgid "An alternative name can be specified with ``metavar``::"
msgstr "Um nome alternativo pode ser especificado com ``metavar``::"

#: ../../library/argparse.rst:1370
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', metavar='YYY')\n"
">>> parser.add_argument('bar', metavar='XXX')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo YYY] XXX\n"
"\n"
"positional arguments:\n"
" XXX\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo YYY"
msgstr ""

#: ../../library/argparse.rst:1385
msgid ""
"Note that ``metavar`` only changes the *displayed* name - the name of the "
"attribute on the :meth:`~ArgumentParser.parse_args` object is still "
"determined by the dest_ value."
msgstr ""
"Observe que ``metavar`` apenas altera o nome *exibido* - o nome do atributo "
"no objeto :meth:`~ArgumentParser.parse_args` ainda é determinado pelo valor "
"dest_."

#: ../../library/argparse.rst:1389
msgid ""
"Different values of ``nargs`` may cause the metavar to be used multiple "
"times. Providing a tuple to ``metavar`` specifies a different display for "
"each of the arguments::"
msgstr ""
"Valores diferentes de ``nargs`` podem fazer com que o metavar seja usado "
"múltiplas vezes. Fornecer uma tupla para ``metavar`` especifica uma exibição "
"diferente para cada um dos argumentos::"

#: ../../library/argparse.rst:1393
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', nargs=2)\n"
">>> parser.add_argument('--foo', nargs=2, metavar=('bar', 'baz'))\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [-x X X] [--foo bar baz]\n"
"\n"
"options:\n"
" -h, --help     show this help message and exit\n"
" -x X X\n"
" --foo bar baz"
msgstr ""

#: ../../library/argparse.rst:1408
msgid "dest"
msgstr "dest"

#: ../../library/argparse.rst:1410
msgid ""
"Most :class:`ArgumentParser` actions add some value as an attribute of the "
"object returned by :meth:`~ArgumentParser.parse_args`.  The name of this "
"attribute is determined by the ``dest`` keyword argument of :meth:"
"`~ArgumentParser.add_argument`.  For positional argument actions, ``dest`` "
"is normally supplied as the first argument to :meth:`~ArgumentParser."
"add_argument`::"
msgstr ""
"A maioria das ações :class:`ArgumentParser` adiciona algum valor como um "
"atributo do objeto retornado por :meth:`~ArgumentParser.parse_args`. O nome "
"deste atributo é determinado pelo argumento nomeado ``dest`` de :meth:"
"`~ArgumentParser.add_argument`. Para ações de argumento posicional, ``dest`` "
"é normalmente fornecido como o primeiro argumento para :meth:"
"`~ArgumentParser.add_argument`::"

#: ../../library/argparse.rst:1417
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['XXX'])\n"
"Namespace(bar='XXX')"
msgstr ""

#: ../../library/argparse.rst:1422
msgid ""
"For optional argument actions, the value of ``dest`` is normally inferred "
"from the option strings.  :class:`ArgumentParser` generates the value of "
"``dest`` by taking the first long option string and stripping away the "
"initial ``--`` string.  If no long option strings were supplied, ``dest`` "
"will be derived from the first short option string by stripping the initial "
"``-`` character.  Any internal ``-`` characters will be converted to ``_`` "
"characters to make sure the string is a valid attribute name.  The examples "
"below illustrate this behavior::"
msgstr ""
"Para ações de argumentos opcionais, o valor de ``dest`` é normalmente "
"inferido das strings de opções. :class:`ArgumentParser` gera o valor de "
"``dest`` pegando a primeira string de opção longa e removendo a string "
"inicial ``--``. Se nenhuma string de opção longa for fornecida, ``dest`` "
"será derivado da primeira string de opção curta removendo o caractere ``-`` "
"inicial.  Quaisquer caracteres ``-`` internos serão convertidos em "
"caracteres ``_`` para garantir que a string seja um nome de atributo válido. "
"Os exemplos abaixo ilustram esse comportamento:"

#: ../../library/argparse.rst:1431
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('-f', '--foo-bar', '--foo')\n"
">>> parser.add_argument('-x', '-y')\n"
">>> parser.parse_args('-f 1 -x 2'.split())\n"
"Namespace(foo_bar='1', x='2')\n"
">>> parser.parse_args('--foo 1 -y 2'.split())\n"
"Namespace(foo_bar='1', x='2')"
msgstr ""

#: ../../library/argparse.rst:1439
msgid "``dest`` allows a custom attribute name to be provided::"
msgstr ""
"``dest`` permite que um nome de atributo personalizado seja fornecido::"

#: ../../library/argparse.rst:1441
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', dest='bar')\n"
">>> parser.parse_args('--foo XXX'.split())\n"
"Namespace(bar='XXX')"
msgstr ""

#: ../../library/argparse.rst:1447
msgid "Action classes"
msgstr "Classes de ação"

#: ../../library/argparse.rst:1449
msgid ""
"Action classes implement the Action API, a callable which returns a callable "
"which processes arguments from the command-line. Any object which follows "
"this API may be passed as the ``action`` parameter to :meth:`~ArgumentParser."
"add_argument`."
msgstr ""
"As classes de ação implementam a API de Action, um chamável que retorna um "
"chamável que processa argumentos da linha de comando. Qualquer objeto que "
"siga esta API pode ser passado como parâmetro ``action`` para :meth:"
"`~ArgumentParser.add_argument`."

#: ../../library/argparse.rst:1458
msgid ""
"Action objects are used by an ArgumentParser to represent the information "
"needed to parse a single argument from one or more strings from the command "
"line. The Action class must accept the two positional arguments plus any "
"keyword arguments passed to :meth:`ArgumentParser.add_argument` except for "
"the ``action`` itself."
msgstr ""

#: ../../library/argparse.rst:1464
msgid ""
"Instances of Action (or return value of any callable to the ``action`` "
"parameter) should have attributes \"dest\", \"option_strings\", \"default\", "
"\"type\", \"required\", \"help\", etc. defined. The easiest way to ensure "
"these attributes are defined is to call ``Action.__init__``."
msgstr ""

#: ../../library/argparse.rst:1469
msgid ""
"Action instances should be callable, so subclasses must override the "
"``__call__`` method, which should accept four parameters:"
msgstr ""

#: ../../library/argparse.rst:1472
msgid "``parser`` - The ArgumentParser object which contains this action."
msgstr ""

#: ../../library/argparse.rst:1474
msgid ""
"``namespace`` - The :class:`Namespace` object that will be returned by :meth:"
"`~ArgumentParser.parse_args`.  Most actions add an attribute to this object "
"using :func:`setattr`."
msgstr ""

#: ../../library/argparse.rst:1478
msgid ""
"``values`` - The associated command-line arguments, with any type "
"conversions applied.  Type conversions are specified with the type_ keyword "
"argument to :meth:`~ArgumentParser.add_argument`."
msgstr ""

#: ../../library/argparse.rst:1482
msgid ""
"``option_string`` - The option string that was used to invoke this action. "
"The ``option_string`` argument is optional, and will be absent if the action "
"is associated with a positional argument."
msgstr ""

#: ../../library/argparse.rst:1486
msgid ""
"The ``__call__`` method may perform arbitrary actions, but will typically "
"set attributes on the ``namespace`` based on ``dest`` and ``values``."
msgstr ""

#: ../../library/argparse.rst:1489
msgid ""
"Action subclasses can define a ``format_usage`` method that takes no "
"argument and return a string which will be used when printing the usage of "
"the program. If such method is not provided, a sensible default will be used."
msgstr ""

#: ../../library/argparse.rst:1494
msgid "The parse_args() method"
msgstr ""

#: ../../library/argparse.rst:1498
msgid ""
"Convert argument strings to objects and assign them as attributes of the "
"namespace.  Return the populated namespace."
msgstr ""

#: ../../library/argparse.rst:1501
msgid ""
"Previous calls to :meth:`add_argument` determine exactly what objects are "
"created and how they are assigned. See the documentation for :meth:"
"`add_argument` for details."
msgstr ""

#: ../../library/argparse.rst:1505
msgid ""
"args_ - List of strings to parse.  The default is taken from :data:`sys."
"argv`."
msgstr ""

#: ../../library/argparse.rst:1508
msgid ""
"namespace_ - An object to take the attributes.  The default is a new empty :"
"class:`Namespace` object."
msgstr ""

#: ../../library/argparse.rst:1513
msgid "Option value syntax"
msgstr ""

#: ../../library/argparse.rst:1515
msgid ""
"The :meth:`~ArgumentParser.parse_args` method supports several ways of "
"specifying the value of an option (if it takes one).  In the simplest case, "
"the option and its value are passed as two separate arguments::"
msgstr ""

#: ../../library/argparse.rst:1519
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(['-x', 'X'])\n"
"Namespace(foo=None, x='X')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"Namespace(foo='FOO', x=None)"
msgstr ""

#: ../../library/argparse.rst:1527
msgid ""
"For long options (options with names longer than a single character), the "
"option and value can also be passed as a single command-line argument, using "
"``=`` to separate them::"
msgstr ""

#: ../../library/argparse.rst:1531
msgid ""
">>> parser.parse_args(['--foo=FOO'])\n"
"Namespace(foo='FOO', x=None)"
msgstr ""

#: ../../library/argparse.rst:1534
msgid ""
"For short options (options only one character long), the option and its "
"value can be concatenated::"
msgstr ""

#: ../../library/argparse.rst:1537
msgid ""
">>> parser.parse_args(['-xX'])\n"
"Namespace(foo=None, x='X')"
msgstr ""

#: ../../library/argparse.rst:1540
msgid ""
"Several short options can be joined together, using only a single ``-`` "
"prefix, as long as only the last option (or none of them) requires a value::"
msgstr ""

#: ../../library/argparse.rst:1543
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', action='store_true')\n"
">>> parser.add_argument('-y', action='store_true')\n"
">>> parser.add_argument('-z')\n"
">>> parser.parse_args(['-xyzZ'])\n"
"Namespace(x=True, y=True, z='Z')"
msgstr ""

#: ../../library/argparse.rst:1552
msgid "Invalid arguments"
msgstr "Argumentos inválidos"

#: ../../library/argparse.rst:1554
msgid ""
"While parsing the command line, :meth:`~ArgumentParser.parse_args` checks "
"for a variety of errors, including ambiguous options, invalid types, invalid "
"options, wrong number of positional arguments, etc.  When it encounters such "
"an error, it exits and prints the error along with a usage message::"
msgstr ""

#: ../../library/argparse.rst:1559
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', nargs='?')\n"
"\n"
">>> # invalid type\n"
">>> parser.parse_args(['--foo', 'spam'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: argument --foo: invalid int value: 'spam'\n"
"\n"
">>> # invalid option\n"
">>> parser.parse_args(['--bar'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: no such option: --bar\n"
"\n"
">>> # wrong number of arguments\n"
">>> parser.parse_args(['spam', 'badger'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: extra arguments found: badger"
msgstr ""

#: ../../library/argparse.rst:1580
msgid "Arguments containing ``-``"
msgstr "Argumentos contendo ``-``"

#: ../../library/argparse.rst:1582
msgid ""
"The :meth:`~ArgumentParser.parse_args` method attempts to give errors "
"whenever the user has clearly made a mistake, but some situations are "
"inherently ambiguous.  For example, the command-line argument ``-1`` could "
"either be an attempt to specify an option or an attempt to provide a "
"positional argument. The :meth:`~ArgumentParser.parse_args` method is "
"cautious here: positional arguments may only begin with ``-`` if they look "
"like negative numbers and there are no options in the parser that look like "
"negative numbers::"
msgstr ""

#: ../../library/argparse.rst:1590
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # no negative number options, so -1 is a positional argument\n"
">>> parser.parse_args(['-x', '-1'])\n"
"Namespace(foo=None, x='-1')\n"
"\n"
">>> # no negative number options, so -1 and -5 are positional arguments\n"
">>> parser.parse_args(['-x', '-1', '-5'])\n"
"Namespace(foo='-5', x='-1')\n"
"\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-1', dest='one')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # negative number options present, so -1 is an option\n"
">>> parser.parse_args(['-1', 'X'])\n"
"Namespace(foo=None, one='X')\n"
"\n"
">>> # negative number options present, so -2 is an option\n"
">>> parser.parse_args(['-2'])\n"
"usage: PROG [-h] [-1 ONE] [foo]\n"
"PROG: error: no such option: -2\n"
"\n"
">>> # negative number options present, so both -1s are options\n"
">>> parser.parse_args(['-1', '-1'])\n"
"usage: PROG [-h] [-1 ONE] [foo]\n"
"PROG: error: argument -1: expected one argument"
msgstr ""

#: ../../library/argparse.rst:1620
msgid ""
"If you have positional arguments that must begin with ``-`` and don't look "
"like negative numbers, you can insert the pseudo-argument ``'--'`` which "
"tells :meth:`~ArgumentParser.parse_args` that everything after that is a "
"positional argument::"
msgstr ""

#: ../../library/argparse.rst:1625
msgid ""
">>> parser.parse_args(['--', '-f'])\n"
"Namespace(foo='-f', one=None)"
msgstr ""

#: ../../library/argparse.rst:1628
msgid ""
"See also :ref:`the argparse howto on ambiguous arguments <specifying-"
"ambiguous-arguments>` for more details."
msgstr ""

#: ../../library/argparse.rst:1634
msgid "Argument abbreviations (prefix matching)"
msgstr ""

#: ../../library/argparse.rst:1636
msgid ""
"The :meth:`~ArgumentParser.parse_args` method :ref:`by default "
"<allow_abbrev>` allows long options to be abbreviated to a prefix, if the "
"abbreviation is unambiguous (the prefix matches a unique option)::"
msgstr ""

#: ../../library/argparse.rst:1640
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-bacon')\n"
">>> parser.add_argument('-badger')\n"
">>> parser.parse_args('-bac MMM'.split())\n"
"Namespace(bacon='MMM', badger=None)\n"
">>> parser.parse_args('-bad WOOD'.split())\n"
"Namespace(bacon=None, badger='WOOD')\n"
">>> parser.parse_args('-ba BA'.split())\n"
"usage: PROG [-h] [-bacon BACON] [-badger BADGER]\n"
"PROG: error: ambiguous option: -ba could match -badger, -bacon"
msgstr ""

#: ../../library/argparse.rst:1651
msgid ""
"An error is produced for arguments that could produce more than one options. "
"This feature can be disabled by setting :ref:`allow_abbrev` to ``False``."
msgstr ""

#: ../../library/argparse.rst:1657
msgid "Beyond ``sys.argv``"
msgstr "Além do ``sys.argv``"

#: ../../library/argparse.rst:1659
msgid ""
"Sometimes it may be useful to have an ArgumentParser parse arguments other "
"than those of :data:`sys.argv`.  This can be accomplished by passing a list "
"of strings to :meth:`~ArgumentParser.parse_args`.  This is useful for "
"testing at the interactive prompt::"
msgstr ""

#: ../../library/argparse.rst:1664
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\n"
"...     'integers', metavar='int', type=int, choices=range(10),\n"
"...     nargs='+', help='an integer in the range 0..9')\n"
">>> parser.add_argument(\n"
"...     '--sum', dest='accumulate', action='store_const', const=sum,\n"
"...     default=max, help='sum the integers (default: find the max)')\n"
">>> parser.parse_args(['1', '2', '3', '4'])\n"
"Namespace(accumulate=<built-in function max>, integers=[1, 2, 3, 4])\n"
">>> parser.parse_args(['1', '2', '3', '4', '--sum'])\n"
"Namespace(accumulate=<built-in function sum>, integers=[1, 2, 3, 4])"
msgstr ""

#: ../../library/argparse.rst:1679
msgid "The Namespace object"
msgstr "O objeto Namespace"

#: ../../library/argparse.rst:1683
msgid ""
"Simple class used by default by :meth:`~ArgumentParser.parse_args` to create "
"an object holding attributes and return it."
msgstr ""

#: ../../library/argparse.rst:1686
msgid ""
"This class is deliberately simple, just an :class:`object` subclass with a "
"readable string representation. If you prefer to have dict-like view of the "
"attributes, you can use the standard Python idiom, :func:`vars`::"
msgstr ""

#: ../../library/argparse.rst:1690
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> args = parser.parse_args(['--foo', 'BAR'])\n"
">>> vars(args)\n"
"{'foo': 'BAR'}"
msgstr ""

#: ../../library/argparse.rst:1696
msgid ""
"It may also be useful to have an :class:`ArgumentParser` assign attributes "
"to an already existing object, rather than a new :class:`Namespace` object.  "
"This can be achieved by specifying the ``namespace=`` keyword argument::"
msgstr ""

#: ../../library/argparse.rst:1700
msgid ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(args=['--foo', 'BAR'], namespace=c)\n"
">>> c.foo\n"
"'BAR'"
msgstr ""

#: ../../library/argparse.rst:1712
msgid "Other utilities"
msgstr ""

#: ../../library/argparse.rst:1715
msgid "Sub-commands"
msgstr "Sub-comandos"

#: ../../library/argparse.rst:1722
msgid ""
"Many programs split up their functionality into a number of sub-commands, "
"for example, the ``svn`` program can invoke sub-commands like ``svn "
"checkout``, ``svn update``, and ``svn commit``.  Splitting up functionality "
"this way can be a particularly good idea when a program performs several "
"different functions which require different kinds of command-line "
"arguments. :class:`ArgumentParser` supports the creation of such sub-"
"commands with the :meth:`add_subparsers` method.  The :meth:`add_subparsers` "
"method is normally called with no arguments and returns a special action "
"object.  This object has a single method, :meth:`~_SubParsersAction."
"add_parser`, which takes a command name and any :class:`ArgumentParser` "
"constructor arguments, and returns an :class:`ArgumentParser` object that "
"can be modified as usual."
msgstr ""

#: ../../library/argparse.rst:1734
msgid "Description of parameters:"
msgstr "Descrição de parâmetros:"

#: ../../library/argparse.rst:1736
msgid ""
"title - title for the sub-parser group in help output; by default "
"\"subcommands\" if description is provided, otherwise uses title for "
"positional arguments"
msgstr ""

#: ../../library/argparse.rst:1740
msgid ""
"description - description for the sub-parser group in help output, by "
"default ``None``"
msgstr ""

#: ../../library/argparse.rst:1743
msgid ""
"prog - usage information that will be displayed with sub-command help, by "
"default the name of the program and any positional arguments before the "
"subparser argument"
msgstr ""

#: ../../library/argparse.rst:1747
msgid ""
"parser_class - class which will be used to create sub-parser instances, by "
"default the class of the current parser (e.g. ArgumentParser)"
msgstr ""

#: ../../library/argparse.rst:1750
msgid ""
"action_ - the basic type of action to be taken when this argument is "
"encountered at the command line"
msgstr ""

#: ../../library/argparse.rst:1753
msgid ""
"dest_ - name of the attribute under which sub-command name will be stored; "
"by default ``None`` and no value is stored"
msgstr ""

#: ../../library/argparse.rst:1756
msgid ""
"required_ - Whether or not a subcommand must be provided, by default "
"``False`` (added in 3.7)"
msgstr ""

#: ../../library/argparse.rst:1759
msgid "help_ - help for sub-parser group in help output, by default ``None``"
msgstr ""

#: ../../library/argparse.rst:1761
msgid ""
"metavar_ - string presenting available sub-commands in help; by default it "
"is ``None`` and presents sub-commands in form {cmd1, cmd2, ..}"
msgstr ""

#: ../../library/argparse.rst:1764
msgid "Some example usage::"
msgstr "Alguns exemplos de uso::"

#: ../../library/argparse.rst:1766
msgid ""
">>> # create the top-level parser\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', action='store_true', help='foo help')\n"
">>> subparsers = parser.add_subparsers(help='sub-command help')\n"
">>>\n"
">>> # create the parser for the \"a\" command\n"
">>> parser_a = subparsers.add_parser('a', help='a help')\n"
">>> parser_a.add_argument('bar', type=int, help='bar help')\n"
">>>\n"
">>> # create the parser for the \"b\" command\n"
">>> parser_b = subparsers.add_parser('b', help='b help')\n"
">>> parser_b.add_argument('--baz', choices='XYZ', help='baz help')\n"
">>>\n"
">>> # parse some argument lists\n"
">>> parser.parse_args(['a', '12'])\n"
"Namespace(bar=12, foo=False)\n"
">>> parser.parse_args(['--foo', 'b', '--baz', 'Z'])\n"
"Namespace(baz='Z', foo=True)"
msgstr ""

#: ../../library/argparse.rst:1785
msgid ""
"Note that the object returned by :meth:`parse_args` will only contain "
"attributes for the main parser and the subparser that was selected by the "
"command line (and not any other subparsers).  So in the example above, when "
"the ``a`` command is specified, only the ``foo`` and ``bar`` attributes are "
"present, and when the ``b`` command is specified, only the ``foo`` and "
"``baz`` attributes are present."
msgstr ""

#: ../../library/argparse.rst:1792
msgid ""
"Similarly, when a help message is requested from a subparser, only the help "
"for that particular parser will be printed.  The help message will not "
"include parent parser or sibling parser messages.  (A help message for each "
"subparser command, however, can be given by supplying the ``help=`` argument "
"to :meth:`~_SubParsersAction.add_parser` as above.)"
msgstr ""

#: ../../library/argparse.rst:1800
msgid ""
">>> parser.parse_args(['--help'])\n"
"usage: PROG [-h] [--foo] {a,b} ...\n"
"\n"
"positional arguments:\n"
"  {a,b}   sub-command help\n"
"    a     a help\n"
"    b     b help\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"  --foo   foo help\n"
"\n"
">>> parser.parse_args(['a', '--help'])\n"
"usage: PROG a [-h] bar\n"
"\n"
"positional arguments:\n"
"  bar     bar help\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
">>> parser.parse_args(['b', '--help'])\n"
"usage: PROG b [-h] [--baz {X,Y,Z}]\n"
"\n"
"options:\n"
"  -h, --help     show this help message and exit\n"
"  --baz {X,Y,Z}  baz help"
msgstr ""

#: ../../library/argparse.rst:1828
msgid ""
"The :meth:`add_subparsers` method also supports ``title`` and "
"``description`` keyword arguments.  When either is present, the subparser's "
"commands will appear in their own group in the help output.  For example::"
msgstr ""

#: ../../library/argparse.rst:1832
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(title='subcommands',\n"
"...                                    description='valid subcommands',\n"
"...                                    help='additional help')\n"
">>> subparsers.add_parser('foo')\n"
">>> subparsers.add_parser('bar')\n"
">>> parser.parse_args(['-h'])\n"
"usage:  [-h] {foo,bar} ...\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
"subcommands:\n"
"  valid subcommands\n"
"\n"
"  {foo,bar}   additional help"
msgstr ""

#: ../../library/argparse.rst:1849
msgid ""
"Furthermore, ``add_parser`` supports an additional ``aliases`` argument, "
"which allows multiple strings to refer to the same subparser. This example, "
"like ``svn``, aliases ``co`` as a shorthand for ``checkout``::"
msgstr ""

#: ../../library/argparse.rst:1853
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers()\n"
">>> checkout = subparsers.add_parser('checkout', aliases=['co'])\n"
">>> checkout.add_argument('foo')\n"
">>> parser.parse_args(['co', 'bar'])\n"
"Namespace(foo='bar')"
msgstr ""

#: ../../library/argparse.rst:1860
msgid ""
"One particularly effective way of handling sub-commands is to combine the "
"use of the :meth:`add_subparsers` method with calls to :meth:`set_defaults` "
"so that each subparser knows which Python function it should execute.  For "
"example::"
msgstr ""

#: ../../library/argparse.rst:1865
msgid ""
">>> # sub-command functions\n"
">>> def foo(args):\n"
"...     print(args.x * args.y)\n"
"...\n"
">>> def bar(args):\n"
"...     print('((%s))' % args.z)\n"
"...\n"
">>> # create the top-level parser\n"
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(required=True)\n"
">>>\n"
">>> # create the parser for the \"foo\" command\n"
">>> parser_foo = subparsers.add_parser('foo')\n"
">>> parser_foo.add_argument('-x', type=int, default=1)\n"
">>> parser_foo.add_argument('y', type=float)\n"
">>> parser_foo.set_defaults(func=foo)\n"
">>>\n"
">>> # create the parser for the \"bar\" command\n"
">>> parser_bar = subparsers.add_parser('bar')\n"
">>> parser_bar.add_argument('z')\n"
">>> parser_bar.set_defaults(func=bar)\n"
">>>\n"
">>> # parse the args and call whatever function was selected\n"
">>> args = parser.parse_args('foo 1 -x 2'.split())\n"
">>> args.func(args)\n"
"2.0\n"
">>>\n"
">>> # parse the args and call whatever function was selected\n"
">>> args = parser.parse_args('bar XYZYX'.split())\n"
">>> args.func(args)\n"
"((XYZYX))"
msgstr ""

#: ../../library/argparse.rst:1897
msgid ""
"This way, you can let :meth:`parse_args` do the job of calling the "
"appropriate function after argument parsing is complete.  Associating "
"functions with actions like this is typically the easiest way to handle the "
"different actions for each of your subparsers.  However, if it is necessary "
"to check the name of the subparser that was invoked, the ``dest`` keyword "
"argument to the :meth:`add_subparsers` call will work::"
msgstr ""

#: ../../library/argparse.rst:1904
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(dest='subparser_name')\n"
">>> subparser1 = subparsers.add_parser('1')\n"
">>> subparser1.add_argument('-x')\n"
">>> subparser2 = subparsers.add_parser('2')\n"
">>> subparser2.add_argument('y')\n"
">>> parser.parse_args(['2', 'frobble'])\n"
"Namespace(subparser_name='2', y='frobble')"
msgstr ""

#: ../../library/argparse.rst:1913
msgid "New *required* keyword argument."
msgstr ""

#: ../../library/argparse.rst:1918
msgid "FileType objects"
msgstr "Objetos FileType"

#: ../../library/argparse.rst:1922
msgid ""
"The :class:`FileType` factory creates objects that can be passed to the type "
"argument of :meth:`ArgumentParser.add_argument`.  Arguments that have :class:"
"`FileType` objects as their type will open command-line arguments as files "
"with the requested modes, buffer sizes, encodings and error handling (see "
"the :func:`open` function for more details)::"
msgstr ""

#: ../../library/argparse.rst:1928
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--raw', type=argparse.FileType('wb', 0))\n"
">>> parser.add_argument('out', type=argparse.FileType('w', "
"encoding='UTF-8'))\n"
">>> parser.parse_args(['--raw', 'raw.dat', 'file.txt'])\n"
"Namespace(out=<_io.TextIOWrapper name='file.txt' mode='w' encoding='UTF-8'>, "
"raw=<_io.FileIO name='raw.dat' mode='wb'>)"
msgstr ""

#: ../../library/argparse.rst:1934
msgid ""
"FileType objects understand the pseudo-argument ``'-'`` and automatically "
"convert this into :data:`sys.stdin` for readable :class:`FileType` objects "
"and :data:`sys.stdout` for writable :class:`FileType` objects::"
msgstr ""

#: ../../library/argparse.rst:1938
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('infile', type=argparse.FileType('r'))\n"
">>> parser.parse_args(['-'])\n"
"Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>)"
msgstr ""

#: ../../library/argparse.rst:1943
msgid "Added the *encodings* and *errors* parameters."
msgstr ""

#: ../../library/argparse.rst:1948
msgid "Argument groups"
msgstr "Grupos de Argumentos"

#: ../../library/argparse.rst:1952
msgid ""
"By default, :class:`ArgumentParser` groups command-line arguments into "
"\"positional arguments\" and \"options\" when displaying help messages. When "
"there is a better conceptual grouping of arguments than this default one, "
"appropriate groups can be created using the :meth:`add_argument_group` "
"method::"
msgstr ""

#: ../../library/argparse.rst:1958
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group = parser.add_argument_group('group')\n"
">>> group.add_argument('--foo', help='foo help')\n"
">>> group.add_argument('bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [--foo FOO] bar\n"
"\n"
"group:\n"
"  bar    bar help\n"
"  --foo FOO  foo help"
msgstr ""

#: ../../library/argparse.rst:1969
msgid ""
"The :meth:`add_argument_group` method returns an argument group object which "
"has an :meth:`~ArgumentParser.add_argument` method just like a regular :"
"class:`ArgumentParser`.  When an argument is added to the group, the parser "
"treats it just like a normal argument, but displays the argument in a "
"separate group for help messages.  The :meth:`add_argument_group` method "
"accepts *title* and *description* arguments which can be used to customize "
"this display::"
msgstr ""

#: ../../library/argparse.rst:1977
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group1 = parser.add_argument_group('group1', 'group1 description')\n"
">>> group1.add_argument('foo', help='foo help')\n"
">>> group2 = parser.add_argument_group('group2', 'group2 description')\n"
">>> group2.add_argument('--bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [--bar BAR] foo\n"
"\n"
"group1:\n"
"  group1 description\n"
"\n"
"  foo    foo help\n"
"\n"
"group2:\n"
"  group2 description\n"
"\n"
"  --bar BAR  bar help"
msgstr ""

#: ../../library/argparse.rst:1995
msgid ""
"Note that any arguments not in your user-defined groups will end up back in "
"the usual \"positional arguments\" and \"optional arguments\" sections."
msgstr ""

#: ../../library/argparse.rst:1998
msgid ""
"Calling :meth:`add_argument_group` on an argument group is deprecated. This "
"feature was never supported and does not always work correctly. The function "
"exists on the API by accident through inheritance and will be removed in the "
"future."
msgstr ""

#: ../../library/argparse.rst:2006
msgid "Mutual exclusion"
msgstr "Exclusão Mútua"

#: ../../library/argparse.rst:2010
msgid ""
"Create a mutually exclusive group. :mod:`argparse` will make sure that only "
"one of the arguments in the mutually exclusive group was present on the "
"command line::"
msgstr ""

#: ../../library/argparse.rst:2014
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group()\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args(['--foo'])\n"
"Namespace(bar=True, foo=True)\n"
">>> parser.parse_args(['--bar'])\n"
"Namespace(bar=False, foo=False)\n"
">>> parser.parse_args(['--foo', '--bar'])\n"
"usage: PROG [-h] [--foo | --bar]\n"
"PROG: error: argument --bar: not allowed with argument --foo"
msgstr ""

#: ../../library/argparse.rst:2026
msgid ""
"The :meth:`add_mutually_exclusive_group` method also accepts a *required* "
"argument, to indicate that at least one of the mutually exclusive arguments "
"is required::"
msgstr ""

#: ../../library/argparse.rst:2030
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group(required=True)\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args([])\n"
"usage: PROG [-h] (--foo | --bar)\n"
"PROG: error: one of the arguments --foo --bar is required"
msgstr ""

#: ../../library/argparse.rst:2038
msgid ""
"Note that currently mutually exclusive argument groups do not support the "
"*title* and *description* arguments of :meth:`~ArgumentParser."
"add_argument_group`. However, a mutually exclusive group can be added to an "
"argument group that has a title and description. For example::"
msgstr ""

#: ../../library/argparse.rst:2044
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_argument_group('Group title', 'Group description')\n"
">>> exclusive_group = group.add_mutually_exclusive_group(required=True)\n"
">>> exclusive_group.add_argument('--foo', help='foo help')\n"
">>> exclusive_group.add_argument('--bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] (--foo FOO | --bar BAR)\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
"Group title:\n"
"  Group description\n"
"\n"
"  --foo FOO   foo help\n"
"  --bar BAR   bar help"
msgstr ""

#: ../../library/argparse.rst:2061
msgid ""
"Calling :meth:`add_argument_group` or :meth:`add_mutually_exclusive_group` "
"on a mutually exclusive group is deprecated. These features were never "
"supported and do not always work correctly. The functions exist on the API "
"by accident through inheritance and will be removed in the future."
msgstr ""

#: ../../library/argparse.rst:2069
msgid "Parser defaults"
msgstr ""

#: ../../library/argparse.rst:2073
msgid ""
"Most of the time, the attributes of the object returned by :meth:"
"`parse_args` will be fully determined by inspecting the command-line "
"arguments and the argument actions.  :meth:`set_defaults` allows some "
"additional attributes that are determined without any inspection of the "
"command line to be added::"
msgstr ""

#: ../../library/argparse.rst:2079
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', type=int)\n"
">>> parser.set_defaults(bar=42, baz='badger')\n"
">>> parser.parse_args(['736'])\n"
"Namespace(bar=42, baz='badger', foo=736)"
msgstr ""

#: ../../library/argparse.rst:2085
msgid ""
"Note that parser-level defaults always override argument-level defaults::"
msgstr ""

#: ../../library/argparse.rst:2087
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='bar')\n"
">>> parser.set_defaults(foo='spam')\n"
">>> parser.parse_args([])\n"
"Namespace(foo='spam')"
msgstr ""

#: ../../library/argparse.rst:2093
msgid ""
"Parser-level defaults can be particularly useful when working with multiple "
"parsers.  See the :meth:`~ArgumentParser.add_subparsers` method for an "
"example of this type."
msgstr ""

#: ../../library/argparse.rst:2099
msgid ""
"Get the default value for a namespace attribute, as set by either :meth:"
"`~ArgumentParser.add_argument` or by :meth:`~ArgumentParser.set_defaults`::"
msgstr ""

#: ../../library/argparse.rst:2103
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='badger')\n"
">>> parser.get_default('foo')\n"
"'badger'"
msgstr ""

#: ../../library/argparse.rst:2110
msgid "Printing help"
msgstr "Imprimindo a ajuda"

#: ../../library/argparse.rst:2112
msgid ""
"In most typical applications, :meth:`~ArgumentParser.parse_args` will take "
"care of formatting and printing any usage or error messages.  However, "
"several formatting methods are available:"
msgstr ""

#: ../../library/argparse.rst:2118
msgid ""
"Print a brief description of how the :class:`ArgumentParser` should be "
"invoked on the command line.  If *file* is ``None``, :data:`sys.stdout` is "
"assumed."
msgstr ""

#: ../../library/argparse.rst:2124
msgid ""
"Print a help message, including the program usage and information about the "
"arguments registered with the :class:`ArgumentParser`.  If *file* is "
"``None``, :data:`sys.stdout` is assumed."
msgstr ""

#: ../../library/argparse.rst:2128
msgid ""
"There are also variants of these methods that simply return a string instead "
"of printing it:"
msgstr ""

#: ../../library/argparse.rst:2133
msgid ""
"Return a string containing a brief description of how the :class:"
"`ArgumentParser` should be invoked on the command line."
msgstr ""

#: ../../library/argparse.rst:2138
msgid ""
"Return a string containing a help message, including the program usage and "
"information about the arguments registered with the :class:`ArgumentParser`."
msgstr ""

#: ../../library/argparse.rst:2143
msgid "Partial parsing"
msgstr "Análise parcial"

#: ../../library/argparse.rst:2147
msgid ""
"Sometimes a script may only parse a few of the command-line arguments, "
"passing the remaining arguments on to another script or program. In these "
"cases, the :meth:`~ArgumentParser.parse_known_args` method can be useful.  "
"It works much like :meth:`~ArgumentParser.parse_args` except that it does "
"not produce an error when extra arguments are present.  Instead, it returns "
"a two item tuple containing the populated namespace and the list of "
"remaining argument strings."
msgstr ""

#: ../../library/argparse.rst:2156
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_known_args(['--foo', '--badger', 'BAR', 'spam'])\n"
"(Namespace(bar='BAR', foo=True), ['--badger', 'spam'])"
msgstr ""

#: ../../library/argparse.rst:2163
msgid ""
":ref:`Prefix matching <prefix-matching>` rules apply to :meth:"
"`~ArgumentParser.parse_known_args`. The parser may consume an option even if "
"it's just a prefix of one of its known options, instead of leaving it in the "
"remaining arguments list."
msgstr ""

#: ../../library/argparse.rst:2170
msgid "Customizing file parsing"
msgstr ""

#: ../../library/argparse.rst:2174
msgid ""
"Arguments that are read from a file (see the *fromfile_prefix_chars* keyword "
"argument to the :class:`ArgumentParser` constructor) are read one argument "
"per line. :meth:`convert_arg_line_to_args` can be overridden for fancier "
"reading."
msgstr ""

#: ../../library/argparse.rst:2179
msgid ""
"This method takes a single argument *arg_line* which is a string read from "
"the argument file.  It returns a list of arguments parsed from this string. "
"The method is called once per line read from the argument file, in order."
msgstr ""

#: ../../library/argparse.rst:2183
msgid ""
"A useful override of this method is one that treats each space-separated "
"word as an argument.  The following example demonstrates how to do this::"
msgstr ""

#: ../../library/argparse.rst:2186
msgid ""
"class MyArgumentParser(argparse.ArgumentParser):\n"
"    def convert_arg_line_to_args(self, arg_line):\n"
"        return arg_line.split()"
msgstr ""

#: ../../library/argparse.rst:2192
msgid "Exiting methods"
msgstr "Métodos existentes"

#: ../../library/argparse.rst:2196
msgid ""
"This method terminates the program, exiting with the specified *status* and, "
"if given, it prints a *message* to :data:`sys.stderr` before that. The user "
"can override this method to handle these steps differently::"
msgstr ""

#: ../../library/argparse.rst:2200
msgid ""
"class ErrorCatchingArgumentParser(argparse.ArgumentParser):\n"
"    def exit(self, status=0, message=None):\n"
"        if status:\n"
"            raise Exception(f'Exiting because of an error: {message}')\n"
"        exit(status)"
msgstr ""

#: ../../library/argparse.rst:2208
msgid ""
"This method prints a usage message, including the *message*, to :data:`sys."
"stderr` and terminates the program with a status code of 2."
msgstr ""

#: ../../library/argparse.rst:2213
msgid "Intermixed parsing"
msgstr ""

#: ../../library/argparse.rst:2218
msgid ""
"A number of Unix commands allow the user to intermix optional arguments with "
"positional arguments.  The :meth:`~ArgumentParser.parse_intermixed_args` "
"and :meth:`~ArgumentParser.parse_known_intermixed_args` methods support this "
"parsing style."
msgstr ""

#: ../../library/argparse.rst:2223
msgid ""
"These parsers do not support all the argparse features, and will raise "
"exceptions if unsupported features are used.  In particular, subparsers, and "
"mutually exclusive groups that include both optionals and positionals are "
"not supported."
msgstr ""

#: ../../library/argparse.rst:2228
msgid ""
"The following example shows the difference between :meth:`~ArgumentParser."
"parse_known_args` and :meth:`~ArgumentParser.parse_intermixed_args`: the "
"former returns ``['2', '3']`` as unparsed arguments, while the latter "
"collects all the positionals into ``rest``.  ::"
msgstr ""

#: ../../library/argparse.rst:2234
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('cmd')\n"
">>> parser.add_argument('rest', nargs='*', type=int)\n"
">>> parser.parse_known_args('doit 1 --foo bar 2 3'.split())\n"
"(Namespace(cmd='doit', foo='bar', rest=[1]), ['2', '3'])\n"
">>> parser.parse_intermixed_args('doit 1 --foo bar 2 3'.split())\n"
"Namespace(cmd='doit', foo='bar', rest=[1, 2, 3])"
msgstr ""

#: ../../library/argparse.rst:2243
msgid ""
":meth:`~ArgumentParser.parse_known_intermixed_args` returns a two item tuple "
"containing the populated namespace and the list of remaining argument "
"strings. :meth:`~ArgumentParser.parse_intermixed_args` raises an error if "
"there are any remaining unparsed argument strings."
msgstr ""

#: ../../library/argparse.rst:2253
msgid "Upgrading optparse code"
msgstr ""

#: ../../library/argparse.rst:2255
msgid ""
"Originally, the :mod:`argparse` module had attempted to maintain "
"compatibility with :mod:`optparse`.  However, :mod:`optparse` was difficult "
"to extend transparently, particularly with the changes required to support "
"the new ``nargs=`` specifiers and better usage messages.  When most "
"everything in :mod:`optparse` had either been copy-pasted over or monkey-"
"patched, it no longer seemed practical to try to maintain the backwards "
"compatibility."
msgstr ""

#: ../../library/argparse.rst:2262
msgid ""
"The :mod:`argparse` module improves on the standard library :mod:`optparse` "
"module in a number of ways including:"
msgstr ""

#: ../../library/argparse.rst:2265
msgid "Handling positional arguments."
msgstr "Tratando argumentos posicionais."

#: ../../library/argparse.rst:2266
msgid "Supporting sub-commands."
msgstr ""

#: ../../library/argparse.rst:2267
msgid "Allowing alternative option prefixes like ``+`` and ``/``."
msgstr ""

#: ../../library/argparse.rst:2268
msgid "Handling zero-or-more and one-or-more style arguments."
msgstr ""

#: ../../library/argparse.rst:2269
msgid "Producing more informative usage messages."
msgstr ""

#: ../../library/argparse.rst:2270
msgid "Providing a much simpler interface for custom ``type`` and ``action``."
msgstr ""

#: ../../library/argparse.rst:2272
msgid "A partial upgrade path from :mod:`optparse` to :mod:`argparse`:"
msgstr ""

#: ../../library/argparse.rst:2274
msgid ""
"Replace all :meth:`optparse.OptionParser.add_option` calls with :meth:"
"`ArgumentParser.add_argument` calls."
msgstr ""

#: ../../library/argparse.rst:2277
msgid ""
"Replace ``(options, args) = parser.parse_args()`` with ``args = parser."
"parse_args()`` and add additional :meth:`ArgumentParser.add_argument` calls "
"for the positional arguments. Keep in mind that what was previously called "
"``options``, now in the :mod:`argparse` context is called ``args``."
msgstr ""

#: ../../library/argparse.rst:2282
msgid ""
"Replace :meth:`optparse.OptionParser.disable_interspersed_args` by using :"
"meth:`~ArgumentParser.parse_intermixed_args` instead of :meth:"
"`~ArgumentParser.parse_args`."
msgstr ""

#: ../../library/argparse.rst:2286
msgid ""
"Replace callback actions and the ``callback_*`` keyword arguments with "
"``type`` or ``action`` arguments."
msgstr ""

#: ../../library/argparse.rst:2289
msgid ""
"Replace string names for ``type`` keyword arguments with the corresponding "
"type objects (e.g. int, float, complex, etc)."
msgstr ""

#: ../../library/argparse.rst:2292
msgid ""
"Replace :class:`optparse.Values` with :class:`Namespace` and :exc:`optparse."
"OptionError` and :exc:`optparse.OptionValueError` with :exc:`ArgumentError`."
msgstr ""

#: ../../library/argparse.rst:2296
msgid ""
"Replace strings with implicit arguments such as ``%default`` or ``%prog`` "
"with the standard Python syntax to use dictionaries to format strings, that "
"is, ``%(default)s`` and ``%(prog)s``."
msgstr ""

#: ../../library/argparse.rst:2300
msgid ""
"Replace the OptionParser constructor ``version`` argument with a call to "
"``parser.add_argument('--version', action='version', version='<the "
"version>')``."
msgstr ""

#: ../../library/argparse.rst:2304
msgid "Exceptions"
msgstr "Exceções"

#: ../../library/argparse.rst:2308
msgid "An error from creating or using an argument (optional or positional)."
msgstr ""

#: ../../library/argparse.rst:2310
msgid ""
"The string value of this exception is the message, augmented with "
"information about the argument that caused it."
msgstr ""

#: ../../library/argparse.rst:2315
msgid ""
"Raised when something goes wrong converting a command line string to a type."
msgstr ""

#: ../../library/argparse.rst:981
msgid "? (question mark)"
msgstr "? (interrogação)"

#: ../../library/argparse.rst:981 ../../library/argparse.rst:1015
#: ../../library/argparse.rst:1029
msgid "in argparse module"
msgstr ""

#: ../../library/argparse.rst:1015
msgid "* (asterisk)"
msgstr "* (asterisco)"

#: ../../library/argparse.rst:1029
msgid "+ (plus)"
msgstr "+ (mais)"

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Raphael Mendonça, 2021
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2021
# i17obot <i17obot@rougeth.com>, 2021
# Adorilson Bezerra <adorilson@gmail.com>, 2023
# Vitor Buxbaum Orlandi, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-12-20 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/ast.rst:2
msgid ":mod:`!ast` --- Abstract Syntax Trees"
msgstr ":mod:`!ast` --- Árvores de Sintaxe Abstrata"

#: ../../library/ast.rst:14
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**Código-fonte:** :source:`Lib/ast.py`"

#: ../../library/ast.rst:18
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""
"O módulo :mod:`ast` ajuda as aplicações Python a processar árvores da "
"gramática de sintaxe abstrata do Python. A sintaxe abstrata em si pode mudar "
"em cada lançamento do Python; este módulo ajuda a descobrir "
"programaticamente como é a gramática atual."

#: ../../library/ast.rst:23
msgid ""
"An abstract syntax tree can be generated by passing :data:`ast."
"PyCF_ONLY_AST` as a flag to the :func:`compile` built-in function, or using "
"the :func:`parse` helper provided in this module.  The result will be a tree "
"of objects whose classes all inherit from :class:`ast.AST`.  An abstract "
"syntax tree can be compiled into a Python code object using the built-in :"
"func:`compile` function."
msgstr ""
"Uma árvore de sintaxe abstrata pode ser gerada passando :data:`ast."
"PyCF_ONLY_AST` como um sinalizador para a função embutida :func:`compile`, "
"ou usando o auxiliar :func:`parse` fornecido neste módulo. O resultado será "
"uma árvore de objetos cujas classes herdam de :class:`ast.AST`. Uma árvore "
"de sintaxe abstrata pode ser compilada em um objeto código Python usando a "
"função embutida :func:`compile`."

#: ../../library/ast.rst:33
msgid "Abstract Grammar"
msgstr "Gramática Abstrata"

#: ../../library/ast.rst:35
msgid "The abstract grammar is currently defined as follows:"
msgstr "A gramática abstrata está atualmente definida da seguinte forma:"

#: ../../library/ast.rst:37
msgid ""
"-- ASDL's 4 builtin types are:\n"
"-- identifier, int, string, constant\n"
"\n"
"module Python\n"
"{\n"
"    mod = Module(stmt* body, type_ignore* type_ignores)\n"
"        | Interactive(stmt* body)\n"
"        | Expression(expr body)\n"
"        | FunctionType(expr* argtypes, expr returns)\n"
"\n"
"    stmt = FunctionDef(identifier name, arguments args,\n"
"                       stmt* body, expr* decorator_list, expr? returns,\n"
"                       string? type_comment, type_param* type_params)\n"
"          | AsyncFunctionDef(identifier name, arguments args,\n"
"                             stmt* body, expr* decorator_list, expr? "
"returns,\n"
"                             string? type_comment, type_param* type_params)\n"
"\n"
"          | ClassDef(identifier name,\n"
"             expr* bases,\n"
"             keyword* keywords,\n"
"             stmt* body,\n"
"             expr* decorator_list,\n"
"             type_param* type_params)\n"
"          | Return(expr? value)\n"
"\n"
"          | Delete(expr* targets)\n"
"          | Assign(expr* targets, expr value, string? type_comment)\n"
"          | TypeAlias(expr name, type_param* type_params, expr value)\n"
"          | AugAssign(expr target, operator op, expr value)\n"
"          -- 'simple' indicates that we annotate simple name without parens\n"
"          | AnnAssign(expr target, expr annotation, expr? value, int "
"simple)\n"
"\n"
"          -- use 'orelse' because else is a keyword in target languages\n"
"          | For(expr target, expr iter, stmt* body, stmt* orelse, string? "
"type_comment)\n"
"          | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, "
"string? type_comment)\n"
"          | While(expr test, stmt* body, stmt* orelse)\n"
"          | If(expr test, stmt* body, stmt* orelse)\n"
"          | With(withitem* items, stmt* body, string? type_comment)\n"
"          | AsyncWith(withitem* items, stmt* body, string? type_comment)\n"
"\n"
"          | Match(expr subject, match_case* cases)\n"
"\n"
"          | Raise(expr? exc, expr? cause)\n"
"          | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* "
"finalbody)\n"
"          | TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* "
"finalbody)\n"
"          | Assert(expr test, expr? msg)\n"
"\n"
"          | Import(alias* names)\n"
"          | ImportFrom(identifier? module, alias* names, int? level)\n"
"\n"
"          | Global(identifier* names)\n"
"          | Nonlocal(identifier* names)\n"
"          | Expr(expr value)\n"
"          | Pass | Break | Continue\n"
"\n"
"          -- col_offset is the byte offset in the utf8 string the parser "
"uses\n"
"          attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"          -- BoolOp() can use left & right?\n"
"    expr = BoolOp(boolop op, expr* values)\n"
"         | NamedExpr(expr target, expr value)\n"
"         | BinOp(expr left, operator op, expr right)\n"
"         | UnaryOp(unaryop op, expr operand)\n"
"         | Lambda(arguments args, expr body)\n"
"         | IfExp(expr test, expr body, expr orelse)\n"
"         | Dict(expr* keys, expr* values)\n"
"         | Set(expr* elts)\n"
"         | ListComp(expr elt, comprehension* generators)\n"
"         | SetComp(expr elt, comprehension* generators)\n"
"         | DictComp(expr key, expr value, comprehension* generators)\n"
"         | GeneratorExp(expr elt, comprehension* generators)\n"
"         -- the grammar constrains where yield expressions can occur\n"
"         | Await(expr value)\n"
"         | Yield(expr? value)\n"
"         | YieldFrom(expr value)\n"
"         -- need sequences for compare to distinguish between\n"
"         -- x < 4 < 3 and (x < 4) < 3\n"
"         | Compare(expr left, cmpop* ops, expr* comparators)\n"
"         | Call(expr func, expr* args, keyword* keywords)\n"
"         | FormattedValue(expr value, int conversion, expr? format_spec)\n"
"         | JoinedStr(expr* values)\n"
"         | Constant(constant value, string? kind)\n"
"\n"
"         -- the following expression can appear in assignment context\n"
"         | Attribute(expr value, identifier attr, expr_context ctx)\n"
"         | Subscript(expr value, expr slice, expr_context ctx)\n"
"         | Starred(expr value, expr_context ctx)\n"
"         | Name(identifier id, expr_context ctx)\n"
"         | List(expr* elts, expr_context ctx)\n"
"         | Tuple(expr* elts, expr_context ctx)\n"
"\n"
"         -- can appear only in Subscript\n"
"         | Slice(expr? lower, expr? upper, expr? step)\n"
"\n"
"          -- col_offset is the byte offset in the utf8 string the parser "
"uses\n"
"          attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    expr_context = Load | Store | Del\n"
"\n"
"    boolop = And | Or\n"
"\n"
"    operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift\n"
"                 | RShift | BitOr | BitXor | BitAnd | FloorDiv\n"
"\n"
"    unaryop = Invert | Not | UAdd | USub\n"
"\n"
"    cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn\n"
"\n"
"    comprehension = (expr target, expr iter, expr* ifs, int is_async)\n"
"\n"
"    excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)\n"
"                    attributes (int lineno, int col_offset, int? end_lineno, "
"int? end_col_offset)\n"
"\n"
"    arguments = (arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs,\n"
"                 expr* kw_defaults, arg? kwarg, expr* defaults)\n"
"\n"
"    arg = (identifier arg, expr? annotation, string? type_comment)\n"
"           attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    -- keyword arguments supplied to call (NULL identifier for **kwargs)\n"
"    keyword = (identifier? arg, expr value)\n"
"               attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    -- import name with optional 'as' alias.\n"
"    alias = (identifier name, identifier? asname)\n"
"             attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    withitem = (expr context_expr, expr? optional_vars)\n"
"\n"
"    match_case = (pattern pattern, expr? guard, stmt* body)\n"
"\n"
"    pattern = MatchValue(expr value)\n"
"            | MatchSingleton(constant value)\n"
"            | MatchSequence(pattern* patterns)\n"
"            | MatchMapping(expr* keys, pattern* patterns, identifier? rest)\n"
"            | MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, "
"pattern* kwd_patterns)\n"
"\n"
"            | MatchStar(identifier? name)\n"
"            -- The optional \"rest\" MatchMapping parameter handles "
"capturing extra mapping keys\n"
"\n"
"            | MatchAs(pattern? pattern, identifier? name)\n"
"            | MatchOr(pattern* patterns)\n"
"\n"
"             attributes (int lineno, int col_offset, int end_lineno, int "
"end_col_offset)\n"
"\n"
"    type_ignore = TypeIgnore(int lineno, string tag)\n"
"\n"
"    type_param = TypeVar(identifier name, expr? bound, expr? default_value)\n"
"               | ParamSpec(identifier name, expr? default_value)\n"
"               | TypeVarTuple(identifier name, expr? default_value)\n"
"               attributes (int lineno, int col_offset, int end_lineno, int "
"end_col_offset)\n"
"}\n"
msgstr ""
"-- 4 tipos embutidos da ASDL são:\n"
"-- identifier, int, string, constant\n"
"\n"
"module Python\n"
"{\n"
"    mod = Module(stmt* body, type_ignore* type_ignores)\n"
"        | Interactive(stmt* body)\n"
"        | Expression(expr body)\n"
"        | FunctionType(expr* argtypes, expr returns)\n"
"\n"
"    stmt = FunctionDef(identifier name, arguments args,\n"
"                       stmt* body, expr* decorator_list, expr? returns,\n"
"                       string? type_comment, type_param* type_params)\n"
"          | AsyncFunctionDef(identifier name, arguments args,\n"
"                             stmt* body, expr* decorator_list, expr? "
"returns,\n"
"                             string? type_comment, type_param* type_params)\n"
"\n"
"          | ClassDef(identifier name,\n"
"             expr* bases,\n"
"             keyword* keywords,\n"
"             stmt* body,\n"
"             expr* decorator_list,\n"
"             type_param* type_params)\n"
"          | Return(expr? value)\n"
"\n"
"          | Delete(expr* targets)\n"
"          | Assign(expr* targets, expr value, string? type_comment)\n"
"          | TypeAlias(expr name, type_param* type_params, expr value)\n"
"          | AugAssign(expr target, operator op, expr value)\n"
"          -- 'simple' indica que anotamos nome simples sem parênteses\n"
"          | AnnAssign(expr target, expr annotation, expr? value, int "
"simple)\n"
"\n"
"          -- usa 'orelse' porque else é uma palavra reservada em idiomas "
"alvos\n"
"          | For(expr target, expr iter, stmt* body, stmt* orelse, string? "
"type_comment)\n"
"          | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, "
"string? type_comment)\n"
"          | While(expr test, stmt* body, stmt* orelse)\n"
"          | If(expr test, stmt* body, stmt* orelse)\n"
"          | With(withitem* items, stmt* body, string? type_comment)\n"
"          | AsyncWith(withitem* items, stmt* body, string? type_comment)\n"
"\n"
"          | Match(expr subject, match_case* cases)\n"
"\n"
"          | Raise(expr? exc, expr? cause)\n"
"          | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* "
"finalbody)\n"
"          | TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* "
"finalbody)\n"
"          | Assert(expr test, expr? msg)\n"
"\n"
"          | Import(alias* names)\n"
"          | ImportFrom(identifier? module, alias* names, int? level)\n"
"\n"
"          | Global(identifier* names)\n"
"          | Nonlocal(identifier* names)\n"
"          | Expr(expr value)\n"
"          | Pass | Break | Continue\n"
"\n"
"          -- col_offset é o deslocamente do bytes na string utf8 que o "
"analisador sintático usa\n"
"          attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"          -- BoolOp() pode usar esquerda e direita?\n"
"    expr = BoolOp(boolop op, expr* values)\n"
"         | NamedExpr(expr target, expr value)\n"
"         | BinOp(expr left, operator op, expr right)\n"
"         | UnaryOp(unaryop op, expr operand)\n"
"         | Lambda(arguments args, expr body)\n"
"         | IfExp(expr test, expr body, expr orelse)\n"
"         | Dict(expr* keys, expr* values)\n"
"         | Set(expr* elts)\n"
"         | ListComp(expr elt, comprehension* generators)\n"
"         | SetComp(expr elt, comprehension* generators)\n"
"         | DictComp(expr key, expr value, comprehension* generators)\n"
"         | GeneratorExp(expr elt, comprehension* generators)\n"
"         -- as restrições gramaticais onde yield expressions pode ocorrer\n"
"         | Await(expr value)\n"
"         | Yield(expr? value)\n"
"         | YieldFrom(expr value)\n"
"         -- precisa de sequências para comparar para distringuir entre\n"
"         -- x < 4 < 3 and (x < 4) < 3\n"
"         | Compare(expr left, cmpop* ops, expr* comparators)\n"
"         | Call(expr func, expr* args, keyword* keywords)\n"
"         | FormattedValue(expr value, int conversion, expr? format_spec)\n"
"         | JoinedStr(expr* values)\n"
"         | Constant(constant value, string? kind)\n"
"\n"
"         -- a expressão a seguir pode aparecer no contexto da atribuição\n"
"         | Attribute(expr value, identifier attr, expr_context ctx)\n"
"         | Subscript(expr value, expr slice, expr_context ctx)\n"
"         | Starred(expr value, expr_context ctx)\n"
"         | Name(identifier id, expr_context ctx)\n"
"         | List(expr* elts, expr_context ctx)\n"
"         | Tuple(expr* elts, expr_context ctx)\n"
"\n"
"         -- pode aparecer apenas em subscrição\n"
"         | Slice(expr? lower, expr? upper, expr? step)\n"
"\n"
"          -- col_offset é o deslocamente do bytes na string utf8 que o "
"analisador sintático usa\n"
"          attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    expr_context = Load | Store | Del\n"
"\n"
"    boolop = And | Or\n"
"\n"
"    operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift\n"
"                 | RShift | BitOr | BitXor | BitAnd | FloorDiv\n"
"\n"
"    unaryop = Invert | Not | UAdd | USub\n"
"\n"
"    cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn\n"
"\n"
"    comprehension = (expr target, expr iter, expr* ifs, int is_async)\n"
"\n"
"    excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)\n"
"                    attributes (int lineno, int col_offset, int? end_lineno, "
"int? end_col_offset)\n"
"\n"
"    arguments = (arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs,\n"
"                 expr* kw_defaults, arg? kwarg, expr* defaults)\n"
"\n"
"    arg = (identifier arg, expr? annotation, string? type_comment)\n"
"           attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    -- argumentos nomeados fornecidos à chamada (identificador NULL para "
"**kwargs)\n"
"    keyword = (identifier? arg, expr value)\n"
"               attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    -- nomes de importação com o apelido opcional 'as'.\n"
"    alias = (identifier name, identifier? asname)\n"
"             attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    withitem = (expr context_expr, expr? optional_vars)\n"
"\n"
"    match_case = (pattern pattern, expr? guard, stmt* body)\n"
"\n"
"    pattern = MatchValue(expr value)\n"
"            | MatchSingleton(constant value)\n"
"            | MatchSequence(pattern* patterns)\n"
"            | MatchMapping(expr* keys, pattern* patterns, identifier? rest)\n"
"            | MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, "
"pattern* kwd_patterns)\n"
"\n"
"            | MatchStar(identifier? name)\n"
"            -- O parâmetro opcional de MatchMapping \"rest\" lida com a "
"captura de chaves extras de mapeamento\n"
"\n"
"            | MatchAs(pattern? pattern, identifier? name)\n"
"            | MatchOr(pattern* patterns)\n"
"\n"
"             attributes (int lineno, int col_offset, int end_lineno, int "
"end_col_offset)\n"
"\n"
"    type_ignore = TypeIgnore(int lineno, string tag)\n"
"\n"
"    type_param = TypeVar(identifier name, expr? bound, expr? default_value)\n"
"               | ParamSpec(identifier name, expr? default_value)\n"
"               | TypeVarTuple(identifier name, expr? default_value)\n"
"               attributes (int lineno, int col_offset, int end_lineno, int "
"end_col_offset)\n"
"}\n"

#: ../../library/ast.rst:42
msgid "Node classes"
msgstr "Classes de nós"

#: ../../library/ast.rst:46
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced :ref:"
"`above <abstract-grammar>`.  They are defined in the :mod:`!_ast` C module "
"and re-exported in :mod:`ast`."
msgstr ""
"Esta é a base de todas as classes de nós de AST. As classes de nós reais são "
"derivadas do arquivo :file:`Parser/Python.asdl`, que é reproduzido :ref:"
"`acima <abstract-grammar>`. Elas são definidas no módulo C :mod:`!_ast` e "
"reexportadas no :mod:`ast`."

#: ../../library/ast.rst:51
msgid ""
"There is one class defined for each left-hand side symbol in the abstract "
"grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In addition, "
"there is one class defined for each constructor on the right-hand side; "
"these classes inherit from the classes for the left-hand side trees.  For "
"example, :class:`ast.BinOp` inherits from :class:`ast.expr`.  For production "
"rules with alternatives (aka \"sums\"), the left-hand side class is "
"abstract: only instances of specific constructor nodes are ever created."
msgstr ""
"Há uma classe definida para cada símbolo do lado esquerdo na gramática "
"abstrata (por exemplo, :class:`ast.stmt` ou :class:`ast.expr`). Além disso, "
"existe uma classe definida para cada construtor no lado direito; essas "
"classes herdam das classes para as árvores do lado esquerdo. Por exemplo, :"
"class:`ast.BinOp` herda de :class:`ast.expr`. Para regras de produção com "
"alternativas (\"somas\"), a classe do lado esquerdo é abstrata: apenas "
"instâncias de nós construtores específicos são criadas."

#: ../../library/ast.rst:64
msgid ""
"Each concrete class has an attribute :attr:`!_fields` which gives the names "
"of all child nodes."
msgstr ""
"Cada classe concreta possui um atributo :attr:`!_fields` que fornece os "
"nomes de todos os nós filhos."

#: ../../library/ast.rst:67
msgid ""
"Each instance of a concrete class has one attribute for each child node, of "
"the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""
"Cada instância de uma classe concreta tem um atributo para cada nó filho, do "
"tipo definido na gramática. Por exemplo, as instâncias :class:`ast.BinOp` "
"possuem um atributo :attr:`left` do tipo :class:`ast.expr`."

#: ../../library/ast.rst:71
msgid ""
"If these attributes are marked as optional in the grammar (using a question "
"mark), the value might be ``None``.  If the attributes can have zero-or-more "
"values (marked with an asterisk), the values are represented as Python "
"lists.  All possible attributes must be present and have valid values when "
"compiling an AST with :func:`compile`."
msgstr ""
"Se estes atributos estiverem marcados como opcionais na gramática (usando um "
"ponto de interrogação), o valor pode ser ``None``. Se os atributos puderem "
"ter valor zero ou mais (marcados com um asterisco), os valores serão "
"representados como listas do Python. Todos os atributos possíveis devem "
"estar presentes e ter valores válidos ao compilar uma AST com :func:"
"`compile`."

#: ../../library/ast.rst:79
msgid ""
"The :attr:`!_field_types` attribute on each concrete class is a dictionary "
"mapping field names (as also listed in :attr:`_fields`) to their types."
msgstr ""
"O atributo :attr:`!_field_types` em cada classe concreta é um dicionário que "
"mapeia nomes de campos (como também listado em :attr:`_fields`) para seus "
"tipos."

#: ../../library/ast.rst:82
msgid ""
">>> ast.TypeVar._field_types\n"
"{'name': <class 'str'>, 'bound': ast.expr | None, 'default_value': ast.expr "
"| None}"
msgstr ""
">>> ast.TypeVar._field_types\n"
"{'name': <class 'str'>, 'bound': ast.expr | None, 'default_value': ast.expr "
"| None}"

#: ../../library/ast.rst:94
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have :attr:"
"`lineno`, :attr:`col_offset`, :attr:`end_lineno`, and :attr:`end_col_offset` "
"attributes.  The :attr:`lineno` and :attr:`end_lineno` are the first and "
"last line numbers of source text span (1-indexed so the first line is line "
"1) and the :attr:`col_offset` and :attr:`end_col_offset` are the "
"corresponding UTF-8 byte offsets of the first and last tokens that generated "
"the node. The UTF-8 offset is recorded because the parser uses UTF-8 "
"internally."
msgstr ""
"As instâncias das subclasses :class:`ast.expr` e :class:`ast.stmt` possuem "
"os atributos :attr:`lineno`, :attr:`col_offset`, :attr:`end_lineno` e :attr:"
"`end_col_offset`. O :attr:`lineno` e :attr:`end_lineno` são o primeiro e o "
"último número de linha do intervalo do texto de origem (indexado em 1, para "
"que a primeira linha seja a linha 1) e o :attr:`col_offset` e :attr:"
"`end_col_offset` são os deslocamentos de byte UTF-8 correspondentes do "
"primeiro e do último tokens que geraram o nó. O deslocamento UTF-8 é "
"registrado porque o analisador sintático usa UTF-8 internamente."

#: ../../library/ast.rst:103
msgid ""
"Note that the end positions are not required by the compiler and are "
"therefore optional. The end offset is *after* the last symbol, for example "
"one can get the source segment of a one-line expression node using "
"``source_line[node.col_offset : node.end_col_offset]``."
msgstr ""
"Observe que as posições finais não são exigidas pelo compilador e, portanto, "
"são opcionais. O deslocamento final está *após* o último símbolo, por "
"exemplo, é possível obter o segmento de origem de um nó de expressão de uma "
"linha usando ``source_line[node.col_offset : node.end_col_offset]``."

#: ../../library/ast.rst:108
msgid ""
"The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr ""
"O construtor de uma classe :class:`ast.T` analisa seus argumentos da "
"seguinte forma:"

#: ../../library/ast.rst:110
msgid ""
"If there are positional arguments, there must be as many as there are items "
"in :attr:`T._fields`; they will be assigned as attributes of these names."
msgstr ""
"Se houver argumentos posicionais, deve haver tantos quanto houver itens em :"
"attr:`T._fields`; eles serão atribuídos como atributos desses nomes."

#: ../../library/ast.rst:112
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr ""
"Se houver argumentos nomeados, eles definirão os atributos dos mesmos nomes "
"para os valores fornecidos."

#: ../../library/ast.rst:115
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you could "
"use ::"
msgstr ""
"Por exemplo, para criar e popular um nó :class:`ast.UnaryOp`, você poderia "
"usar ::"

#: ../../library/ast.rst:118
msgid ""
"node = ast.UnaryOp(ast.USub(), ast.Constant(5, lineno=0, col_offset=0),\n"
"                   lineno=0, col_offset=0)"
msgstr ""
"node = ast.UnaryOp(ast.USub(), ast.Constant(5, lineno=0, col_offset=0),\n"
"                   lineno=0, col_offset=0)"

#: ../../library/ast.rst:121
msgid ""
"If a field that is optional in the grammar is omitted from the constructor, "
"it defaults to ``None``. If a list field is omitted, it defaults to the "
"empty list. If a field of type :class:`!ast.expr_context` is omitted, it "
"defaults to :class:`Load() <ast.Load>`. If any other field is omitted, a :"
"exc:`DeprecationWarning` is raised and the AST node will not have this "
"field. In Python 3.15, this condition will raise an error."
msgstr ""
"Se um campo que é opcional na gramática for omitido do construtor, o padrão "
"é ``None``. Se um campo de lista for omitido, o padrão será a lista vazia. "
"Se um campo do tipo :class:`!ast.expr_context` for omitido, o padrão é :"
"class:`Load() <ast.Load>`. Se qualquer outro campo for omitido, uma :exc:"
"`DeprecationWarning` será levantada e o nó AST não terá este campo. No "
"Python 3.15, esta condição levantará um erro."

#: ../../library/ast.rst:130
msgid "Class :class:`ast.Constant` is now used for all constants."
msgstr "A classe :class:`ast.Constant` é agora usada para todas as constantes."

#: ../../library/ast.rst:134
msgid ""
"Simple indices are represented by their value, extended slices are "
"represented as tuples."
msgstr ""
"Os índices simples são representados por seus valores, as fatias estendidas "
"são representadas como tuplas."

#: ../../library/ast.rst:139
msgid ""
"Old classes :class:`!ast.Num`, :class:`!ast.Str`, :class:`!ast.Bytes`, :"
"class:`!ast.NameConstant` and :class:`!ast.Ellipsis` are still available, "
"but they will be removed in future Python releases.  In the meantime, "
"instantiating them will return an instance of a different class."
msgstr ""
"Classes antigas :class:`!ast.Num`, :class:`!ast.Str`, :class:`!ast.Bytes`, :"
"class:`!ast.NameConstant` e :class:`!ast.Ellipsis` ainda estão disponíveis, "
"mas serão removidos em versões futuras do Python. Enquanto isso, instanciá-"
"las retornará uma instância de uma classe diferente."

#: ../../library/ast.rst:146
msgid ""
"Old classes :class:`!ast.Index` and :class:`!ast.ExtSlice` are still "
"available, but they will be removed in future Python releases. In the "
"meantime, instantiating them will return an instance of a different class."
msgstr ""
"Classes antigas :class:`!ast.Index` e :class:`!ast.ExtSlice` ainda estão "
"disponíveis, mas serão removidos em versões futuras do Python. Enquanto "
"isso, instanciá-las retornará uma instância de uma classe diferente."

#: ../../library/ast.rst:153
msgid ""
"Previous versions of Python allowed the creation of AST nodes that were "
"missing required fields. Similarly, AST node constructors allowed arbitrary "
"keyword arguments that were set as attributes of the AST node, even if they "
"did not match any of the fields of the AST node. This behavior is deprecated "
"and will be removed in Python 3.15."
msgstr ""
"Versões anteriores do Python permitiam a criação de nós AST sem campos "
"obrigatórios. Da mesma forma, os construtores do nó AST permitiam argumentos "
"nomeados arbitrários que eram definidos como atributos do nó AST, mesmo que "
"não correspondessem a nenhum dos campos do nó AST. Este comportamento foi "
"descontinuado e será removido no Python 3.15."

#: ../../library/ast.rst:160
msgid ""
"The descriptions of the specific node classes displayed here were initially "
"adapted from the fantastic `Green Tree Snakes <https://greentreesnakes."
"readthedocs.io/en/latest/>`__ project and all its contributors."
msgstr ""
"As descrições das classes de nós específicas exibidas aqui foram "
"inicialmente adaptadas do fantástico projeto `Green Tree Snakes <https://"
"greentreesnakes.readthedocs.io/en/latest/>`__ e de todos os seus "
"contribuidores."

#: ../../library/ast.rst:169
msgid "Root nodes"
msgstr "Nós raízes"

#: ../../library/ast.rst:173
msgid ""
"A Python module, as with :ref:`file input <file-input>`. Node type generated "
"by :func:`ast.parse` in the default ``\"exec\"`` *mode*."
msgstr ""
"Um módulo Python, como :ref:`entrada de arquivo <file-input>`. Tipo de nó "
"gerado por :func:`ast.parse` com *mode* no padrão ``\"exec\"``."

#: ../../library/ast.rst:176
msgid "``body`` is a :class:`list` of the module's :ref:`ast-statements`."
msgstr "``body`` é uma :class:`list` das :ref:`ast-statements` do módulo."

#: ../../library/ast.rst:178
msgid ""
"``type_ignores`` is a :class:`list` of the module's type ignore comments; "
"see :func:`ast.parse` for more details."
msgstr ""
"``type_ignores`` é uma :class:`list` dos comentários de ignorar tipo do "
"módulo; veja :func:`ast.parse` para mais detalhes."

#: ../../library/ast.rst:181
msgid ""
">>> print(ast.dump(ast.parse('x = 1'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='x', ctx=Store())],\n"
"            value=Constant(value=1))])"
msgstr ""
">>> print(ast.dump(ast.parse('x = 1'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='x', ctx=Store())],\n"
"            value=Constant(value=1))])"

#: ../../library/ast.rst:194
msgid ""
"A single Python :ref:`expression input <expression-input>`. Node type "
"generated by :func:`ast.parse` when *mode* is ``\"eval\"``."
msgstr ""
"Uma única :ref:`entrada de expressão <expression-input>` Python. Tipo de nó "
"gerado por :func:`ast.parse` quando *mode* é ``\"eval\"``."

#: ../../library/ast.rst:197
msgid ""
"``body`` is a single node, one of the :ref:`expression types <ast-"
"expressions>`."
msgstr ""
"``body`` é um nó único, um dos :ref:`tipos de expressão <ast-expressions>`."

#: ../../library/ast.rst:200 ../../library/ast.rst:270
msgid ""
">>> print(ast.dump(ast.parse('123', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Constant(value=123))"
msgstr ""
">>> print(ast.dump(ast.parse('123', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Constant(value=123))"

#: ../../library/ast.rst:209
msgid ""
"A single :ref:`interactive input <interactive>`, like in :ref:`tut-interac`. "
"Node type generated by :func:`ast.parse` when *mode* is ``\"single\"``."
msgstr ""
"Uma única :ref:`entrada interativa <interactive>`, como em :ref:`tut-"
"interac`. Tipo de nó gerado por :func:`ast.parse` quando *mode* é "
"``\"single\"``."

#: ../../library/ast.rst:212
msgid "``body`` is a :class:`list` of :ref:`statement nodes <ast-statements>`."
msgstr ""
"``body`` é uma :class:`list` de :ref:`nós de instrução <ast-statements>`."

#: ../../library/ast.rst:214
msgid ""
">>> print(ast.dump(ast.parse('x = 1; y = 2', mode='single'), indent=4))\n"
"Interactive(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='x', ctx=Store())],\n"
"            value=Constant(value=1)),\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='y', ctx=Store())],\n"
"            value=Constant(value=2))])"
msgstr ""
">>> print(ast.dump(ast.parse('x = 1; y = 2', mode='single'), indent=4))\n"
"Interactive(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='x', ctx=Store())],\n"
"            value=Constant(value=1)),\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='y', ctx=Store())],\n"
"            value=Constant(value=2))])"

#: ../../library/ast.rst:231
msgid ""
"A representation of an old-style type comments for functions, as Python "
"versions prior to 3.5 didn't support :pep:`484` annotations. Node type "
"generated by :func:`ast.parse` when *mode* is ``\"func_type\"``."
msgstr ""
"Uma representação de comentários de tipo antigo para funções, já que as "
"versões do Python anteriores a 3.5 não davam suporte às anotações da :pep:"
"`484`. Tipo de nó gerado por :func:`ast.parse` quando *mode* é "
"``\"func_type\"``."

#: ../../library/ast.rst:235
msgid "Such type comments would look like this::"
msgstr "Esses comentários de tipo ficariam assim::"

#: ../../library/ast.rst:237
msgid ""
"def sum_two_number(a, b):\n"
"    # type: (int, int) -> int\n"
"    return a + b"
msgstr ""
"def sum_two_number(a, b):\n"
"    # tipo: (int, int) -> int\n"
"    return a + b"

#: ../../library/ast.rst:241
msgid ""
"``argtypes`` is a :class:`list` of :ref:`expression nodes <ast-expressions>`."
msgstr ""
"``argtypes`` é uma :class:`list` de :ref:`nós de expressão <ast-"
"expressions>`."

#: ../../library/ast.rst:243
msgid "``returns`` is a single :ref:`expression node <ast-expressions>`."
msgstr "``returns`` é um único :ref:`nó de expressão <ast-expressions>`."

#: ../../library/ast.rst:245
msgid ""
">>> print(ast.dump(ast.parse('(int, str) -> List[int]', mode='func_type'), "
"indent=4))\n"
"FunctionType(\n"
"    argtypes=[\n"
"        Name(id='int', ctx=Load()),\n"
"        Name(id='str', ctx=Load())],\n"
"    returns=Subscript(\n"
"        value=Name(id='List', ctx=Load()),\n"
"        slice=Name(id='int', ctx=Load()),\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('(int, str) -> List[int]', mode='func_type'), "
"indent=4))\n"
"FunctionType(\n"
"    argtypes=[\n"
"        Name(id='int', ctx=Load()),\n"
"        Name(id='str', ctx=Load())],\n"
"    returns=Subscript(\n"
"        value=Name(id='List', ctx=Load()),\n"
"        slice=Name(id='int', ctx=Load()),\n"
"        ctx=Load()))"

#: ../../library/ast.rst:261
msgid "Literals"
msgstr "Literais"

#: ../../library/ast.rst:265
msgid ""
"A constant value. The ``value`` attribute of the ``Constant`` literal "
"contains the Python object it represents. The values represented can be "
"simple types such as a number, string or ``None``, but also immutable "
"container types (tuples and frozensets) if all of their elements are "
"constant."
msgstr ""
"Um valor constante. O atributo ``value`` do literal ``Constant`` contém o "
"objeto Python que ele representa. Os valores representados podem ser tipos "
"simples como um número, string ou ``None``, mas também tipos de contêineres "
"imutáveis (tuplas e frozensets) se todos os seus elementos forem constantes."

#: ../../library/ast.rst:279
msgid ""
"Node representing a single formatting field in an f-string. If the string "
"contains a single formatting field and nothing else the node can be isolated "
"otherwise it appears in :class:`JoinedStr`."
msgstr ""
"Nó que representa um único campo de formatação em uma f-string. Se a string "
"contiver um único campo de formatação e nada mais, o nó poderá ser isolado, "
"caso contrário ele aparecerá em :class:`JoinedStr`."

#: ../../library/ast.rst:283
msgid ""
"``value`` is any expression node (such as a literal, a variable, or a "
"function call)."
msgstr ""
"``value`` é qualquer nó de expressão (como um literal, uma variável ou uma "
"chamada de função)."

#: ../../library/ast.rst:285
msgid "``conversion`` is an integer:"
msgstr "``conversion`` é um inteiro:"

#: ../../library/ast.rst:287
msgid "-1: no formatting"
msgstr "-1: sem formatação"

#: ../../library/ast.rst:288
msgid "115: ``!s`` string formatting"
msgstr "115: ``!s`` formatação de string"

#: ../../library/ast.rst:289
msgid "114: ``!r`` repr formatting"
msgstr "114: ``!r`` formatação de repr"

#: ../../library/ast.rst:290
msgid "97: ``!a`` ascii formatting"
msgstr "97: ``!a`` formatação ascii"

#: ../../library/ast.rst:292
msgid ""
"``format_spec`` is a :class:`JoinedStr` node representing the formatting of "
"the value, or ``None`` if no format was specified. Both ``conversion`` and "
"``format_spec`` can be set at the same time."
msgstr ""
"``format_spec`` é um nó :class:`JoinedStr` que representa a formatação do "
"valor, ou ``None`` se nenhum formato foi especificado. Tanto ``conversion`` "
"quanto ``format_spec`` podem ser configurados ao mesmo tempo."

#: ../../library/ast.rst:299
msgid ""
"An f-string, comprising a series of :class:`FormattedValue` and :class:"
"`Constant` nodes."
msgstr ""
"Uma f-string, compreendendo uma série de nós :class:`FormattedValue` e :"
"class:`Constant`."

#: ../../library/ast.rst:302
msgid ""
">>> print(ast.dump(ast.parse('f\"sin({a}) is {sin(a):.3}\"', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=JoinedStr(\n"
"        values=[\n"
"            Constant(value='sin('),\n"
"            FormattedValue(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                conversion=-1),\n"
"            Constant(value=') is '),\n"
"            FormattedValue(\n"
"                value=Call(\n"
"                    func=Name(id='sin', ctx=Load()),\n"
"                    args=[\n"
"                        Name(id='a', ctx=Load())]),\n"
"                conversion=-1,\n"
"                format_spec=JoinedStr(\n"
"                    values=[\n"
"                        Constant(value='.3')]))]))"
msgstr ""
">>> print(ast.dump(ast.parse('f\"sin({a}) is {sin(a):.3}\"', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=JoinedStr(\n"
"        values=[\n"
"            Constant(value='sin('),\n"
"            FormattedValue(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                conversion=-1),\n"
"            Constant(value=') is '),\n"
"            FormattedValue(\n"
"                value=Call(\n"
"                    func=Name(id='sin', ctx=Load()),\n"
"                    args=[\n"
"                        Name(id='a', ctx=Load())]),\n"
"                conversion=-1,\n"
"                format_spec=JoinedStr(\n"
"                    values=[\n"
"                        Constant(value='.3')]))]))"

#: ../../library/ast.rst:327
msgid ""
"A list or tuple. ``elts`` holds a list of nodes representing the elements. "
"``ctx`` is :class:`Store` if the container is an assignment target (i.e. "
"``(x,y)=something``), and :class:`Load` otherwise."
msgstr ""
"Uma lista ou tupla. ``elts`` contém uma lista de nós que representam os "
"elementos. ``ctx`` é :class:`Store` se o contêiner for um alvo de atribuição "
"(ou seja, ``(x,y)=algumacoisa``), e :class:`Load` caso contrário."

#: ../../library/ast.rst:331
msgid ""
">>> print(ast.dump(ast.parse('[1, 2, 3]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=List(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)],\n"
"        ctx=Load()))\n"
">>> print(ast.dump(ast.parse('(1, 2, 3)', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Tuple(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)],\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('[1, 2, 3]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=List(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)],\n"
"        ctx=Load()))\n"
">>> print(ast.dump(ast.parse('(1, 2, 3)', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Tuple(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)],\n"
"        ctx=Load()))"

#: ../../library/ast.rst:353
msgid "A set. ``elts`` holds a list of nodes representing the set's elements."
msgstr ""
"Um conjunto. ``elts`` contém uma lista de nós que representam os elementos "
"do conjunto."

#: ../../library/ast.rst:355
msgid ""
">>> print(ast.dump(ast.parse('{1, 2, 3}', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Set(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)]))"
msgstr ""
">>> print(ast.dump(ast.parse('{1, 2, 3}', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Set(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)]))"

#: ../../library/ast.rst:368
msgid ""
"A dictionary. ``keys`` and ``values`` hold lists of nodes representing the "
"keys and the values respectively, in matching order (what would be returned "
"when calling :code:`dictionary.keys()` and :code:`dictionary.values()`)."
msgstr ""
"Um dicionário. ``keys`` e ``values`` contêm listas de nós que representam as "
"chaves e os valores respectivamente, em ordem correspondente (o que seria "
"retornado ao chamar :code:`dictionary.keys()` e :code:`dictionary.values()`)."

#: ../../library/ast.rst:372
msgid ""
"When doing dictionary unpacking using dictionary literals the expression to "
"be expanded goes in the ``values`` list, with a ``None`` at the "
"corresponding position in ``keys``."
msgstr ""
"Ao desempacotar o dicionário usando literais de dicionário, a expressão a "
"ser expandida vai para a lista ``values``, com um ``None`` na posição "
"correspondente em ``keys``."

#: ../../library/ast.rst:376
msgid ""
">>> print(ast.dump(ast.parse('{\"a\":1, **d}', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Dict(\n"
"        keys=[\n"
"            Constant(value='a'),\n"
"            None],\n"
"        values=[\n"
"            Constant(value=1),\n"
"            Name(id='d', ctx=Load())]))"
msgstr ""
">>> print(ast.dump(ast.parse('{\"a\":1, **d}', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Dict(\n"
"        keys=[\n"
"            Constant(value='a'),\n"
"            None],\n"
"        values=[\n"
"            Constant(value=1),\n"
"            Name(id='d', ctx=Load())]))"

#: ../../library/ast.rst:390
msgid "Variables"
msgstr "Variáveis"

#: ../../library/ast.rst:394
msgid ""
"A variable name. ``id`` holds the name as a string, and ``ctx`` is one of "
"the following types."
msgstr ""
"Um nome de variável. ``id`` contém o nome como uma string e ``ctx`` é um dos "
"seguintes tipos."

#: ../../library/ast.rst:402
msgid ""
"Variable references can be used to load the value of a variable, to assign a "
"new value to it, or to delete it. Variable references are given a context to "
"distinguish these cases."
msgstr ""
"As referências de variáveis podem ser usadas para carregar o valor de uma "
"variável, para atribuir um novo valor a ela ou para excluí-la. As "
"referências de variáveis recebem um contexto para distinguir esses casos."

#: ../../library/ast.rst:406
msgid ""
">>> print(ast.dump(ast.parse('a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Name(id='a', ctx=Load()))])\n"
"\n"
">>> print(ast.dump(ast.parse('a = 1'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='a', ctx=Store())],\n"
"            value=Constant(value=1))])\n"
"\n"
">>> print(ast.dump(ast.parse('del a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Delete(\n"
"            targets=[\n"
"                Name(id='a', ctx=Del())])])"
msgstr ""
">>> print(ast.dump(ast.parse('a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Name(id='a', ctx=Load()))])\n"
"\n"
">>> print(ast.dump(ast.parse('a = 1'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='a', ctx=Store())],\n"
"            value=Constant(value=1))])\n"
"\n"
">>> print(ast.dump(ast.parse('del a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Delete(\n"
"            targets=[\n"
"                Name(id='a', ctx=Del())])])"

#: ../../library/ast.rst:432
msgid ""
"A ``*var`` variable reference. ``value`` holds the variable, typically a :"
"class:`Name` node. This type must be used when building a :class:`Call` node "
"with ``*args``."
msgstr ""
"Uma referência de variável ``*var``. ``value`` contém a variável, "
"normalmente um nó :class:`Name`. Este tipo deve ser usado ao construir um "
"nó :class:`Call` com ``*args``."

#: ../../library/ast.rst:436
msgid ""
">>> print(ast.dump(ast.parse('a, *b = it'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Tuple(\n"
"                    elts=[\n"
"                        Name(id='a', ctx=Store()),\n"
"                        Starred(\n"
"                            value=Name(id='b', ctx=Store()),\n"
"                            ctx=Store())],\n"
"                    ctx=Store())],\n"
"            value=Name(id='it', ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse('a, *b = it'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Tuple(\n"
"                    elts=[\n"
"                        Name(id='a', ctx=Store()),\n"
"                        Starred(\n"
"                            value=Name(id='b', ctx=Store()),\n"
"                            ctx=Store())],\n"
"                    ctx=Store())],\n"
"            value=Name(id='it', ctx=Load()))])"

#: ../../library/ast.rst:456
msgid "Expressions"
msgstr "Expressões"

#: ../../library/ast.rst:460
msgid ""
"When an expression, such as a function call, appears as a statement by "
"itself with its return value not used or stored, it is wrapped in this "
"container. ``value`` holds one of the other nodes in this section, a :class:"
"`Constant`, a :class:`Name`, a :class:`Lambda`, a :class:`Yield` or :class:"
"`YieldFrom` node."
msgstr ""
"Quando uma expressão, como uma chamada de função, aparece como uma instrução "
"por si só com seu valor de retorno não usado ou armazenado, ela é "
"encapsulada neste contêiner. ``value`` contém um dos outros nós nesta seção, "
"um nó :class:`Constant`, um :class:`Name`, um :class:`Lambda`, um :class:"
"`Yield` ou :class:`YieldFrom`."

#: ../../library/ast.rst:465
msgid ""
">>> print(ast.dump(ast.parse('-a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=UnaryOp(\n"
"                op=USub(),\n"
"                operand=Name(id='a', ctx=Load())))])"
msgstr ""
">>> print(ast.dump(ast.parse('-a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=UnaryOp(\n"
"                op=USub(),\n"
"                operand=Name(id='a', ctx=Load())))])"

#: ../../library/ast.rst:478
msgid ""
"A unary operation. ``op`` is the operator, and ``operand`` any expression "
"node."
msgstr ""
"Uma operação unária. ``op`` é o operador e ``operand`` qualquer nó de "
"expressão."

#: ../../library/ast.rst:487
msgid ""
"Unary operator tokens. :class:`Not` is the ``not`` keyword, :class:`Invert` "
"is the ``~`` operator."
msgstr ""
"Tokens de operador unário. :class:`Not` é a palavra reservada ``not``, :"
"class:`Invert` é o operador ``~``."

#: ../../library/ast.rst:490
msgid ""
">>> print(ast.dump(ast.parse('not x', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=UnaryOp(\n"
"        op=Not(),\n"
"        operand=Name(id='x', ctx=Load())))"
msgstr ""
">>> print(ast.dump(ast.parse('not x', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=UnaryOp(\n"
"        op=Not(),\n"
"        operand=Name(id='x', ctx=Load())))"

#: ../../library/ast.rst:501
msgid ""
"A binary operation (like addition or division). ``op`` is the operator, and "
"``left`` and ``right`` are any expression nodes."
msgstr ""
"Uma operação binária (como adição ou divisão). ``op`` é o operador, e "
"``left`` e ``right`` são quaisquer nós de expressão."

#: ../../library/ast.rst:504
msgid ""
">>> print(ast.dump(ast.parse('x + y', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=BinOp(\n"
"        left=Name(id='x', ctx=Load()),\n"
"        op=Add(),\n"
"        right=Name(id='y', ctx=Load())))"
msgstr ""
">>> print(ast.dump(ast.parse('x + y', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=BinOp(\n"
"        left=Name(id='x', ctx=Load()),\n"
"        op=Add(),\n"
"        right=Name(id='y', ctx=Load())))"

#: ../../library/ast.rst:528
msgid "Binary operator tokens."
msgstr "Tokens de operador binário."

#: ../../library/ast.rst:533
msgid ""
"A boolean operation, 'or' or 'and'. ``op`` is :class:`Or` or :class:`And`. "
"``values`` are the values involved. Consecutive operations with the same "
"operator, such as ``a or b or c``, are collapsed into one node with several "
"values."
msgstr ""
"Uma operação booleana, 'or' ou 'and'. ``op`` é :class:`Or` ou :class:`And`. "
"``values`` são os valores envolvidos. Operações consecutivas com o mesmo "
"operador, como ``a or b or c``, são recolhidas em um nó com vários valores."

#: ../../library/ast.rst:538
msgid "This doesn't include ``not``, which is a :class:`UnaryOp`."
msgstr "Isso não inclui ``not``, que é um :class:`UnaryOp`."

#: ../../library/ast.rst:540
msgid ""
">>> print(ast.dump(ast.parse('x or y', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=BoolOp(\n"
"        op=Or(),\n"
"        values=[\n"
"            Name(id='x', ctx=Load()),\n"
"            Name(id='y', ctx=Load())]))"
msgstr ""
">>> print(ast.dump(ast.parse('x or y', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=BoolOp(\n"
"        op=Or(),\n"
"        values=[\n"
"            Name(id='x', ctx=Load()),\n"
"            Name(id='y', ctx=Load())]))"

#: ../../library/ast.rst:554
msgid "Boolean operator tokens."
msgstr "Tokens de operador booleano."

#: ../../library/ast.rst:559
msgid ""
"A comparison of two or more values. ``left`` is the first value in the "
"comparison, ``ops`` the list of operators, and ``comparators`` the list of "
"values after the first element in the comparison."
msgstr ""
"Uma comparação de dois ou mais valores. ``left`` é o primeiro valor na "
"comparação, ``ops`` a lista de operadores e ``comparators`` a lista de "
"valores após o primeiro elemento na comparação."

#: ../../library/ast.rst:563
msgid ""
">>> print(ast.dump(ast.parse('1 <= a < 10', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Compare(\n"
"        left=Constant(value=1),\n"
"        ops=[\n"
"            LtE(),\n"
"            Lt()],\n"
"        comparators=[\n"
"            Name(id='a', ctx=Load()),\n"
"            Constant(value=10)]))"
msgstr ""
">>> print(ast.dump(ast.parse('1 <= a < 10', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Compare(\n"
"        left=Constant(value=1),\n"
"        ops=[\n"
"            LtE(),\n"
"            Lt()],\n"
"        comparators=[\n"
"            Name(id='a', ctx=Load()),\n"
"            Constant(value=10)]))"

#: ../../library/ast.rst:588
msgid "Comparison operator tokens."
msgstr "Tokens de operador de comparação."

#: ../../library/ast.rst:593
msgid ""
"A function call. ``func`` is the function, which will often be a :class:"
"`Name` or :class:`Attribute` object. Of the arguments:"
msgstr ""
"Uma chamada de função. ``func`` é a função, que geralmente será um objeto :"
"class:`Name` ou :class:`Attribute`. Dos argumentos:"

#: ../../library/ast.rst:596
msgid "``args`` holds a list of the arguments passed by position."
msgstr "``args`` contém uma lista dos argumentos passados ​por posição."

#: ../../library/ast.rst:597
msgid ""
"``keywords`` holds a list of :class:`.keyword` objects representing "
"arguments passed by keyword."
msgstr ""
"``keywords`` contém uma lista de objetos :class:`.keyword` representando "
"argumentos passados como nomeados."

#: ../../library/ast.rst:600
msgid ""
"The ``args`` and ``keywords`` arguments are optional and default to empty "
"lists."
msgstr ""
"Os argumentos ``args`` e ``keywords`` são opcionais e padrão para listas "
"vazias."

#: ../../library/ast.rst:602
msgid ""
">>> print(ast.dump(ast.parse('func(a, b=c, *d, **e)', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=Call(\n"
"        func=Name(id='func', ctx=Load()),\n"
"        args=[\n"
"            Name(id='a', ctx=Load()),\n"
"            Starred(\n"
"                value=Name(id='d', ctx=Load()),\n"
"                ctx=Load())],\n"
"        keywords=[\n"
"            keyword(\n"
"                arg='b',\n"
"                value=Name(id='c', ctx=Load())),\n"
"            keyword(\n"
"                value=Name(id='e', ctx=Load()))]))"
msgstr ""
">>> print(ast.dump(ast.parse('func(a, b=c, *d, **e)', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=Call(\n"
"        func=Name(id='func', ctx=Load()),\n"
"        args=[\n"
"            Name(id='a', ctx=Load()),\n"
"            Starred(\n"
"                value=Name(id='d', ctx=Load()),\n"
"                ctx=Load())],\n"
"        keywords=[\n"
"            keyword(\n"
"                arg='b',\n"
"                value=Name(id='c', ctx=Load())),\n"
"            keyword(\n"
"                value=Name(id='e', ctx=Load()))]))"

#: ../../library/ast.rst:623
msgid ""
"A keyword argument to a function call or class definition. ``arg`` is a raw "
"string of the parameter name, ``value`` is a node to pass in."
msgstr ""
"Um argumento nomeado para uma chamada de função ou definição de classe. "
"``arg`` é uma string bruta do nome do parâmetro, ``value`` é um nó para "
"passar."

#: ../../library/ast.rst:629
msgid ""
"An expression such as ``a if b else c``. Each field holds a single node, so "
"in the following example, all three are :class:`Name` nodes."
msgstr ""
"Uma expressão como ``a if b else c``. Cada campo contém um único nó, "
"portanto, no exemplo a seguir, todos os três são nós :class:`Name`."

#: ../../library/ast.rst:632
msgid ""
">>> print(ast.dump(ast.parse('a if b else c', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=IfExp(\n"
"        test=Name(id='b', ctx=Load()),\n"
"        body=Name(id='a', ctx=Load()),\n"
"        orelse=Name(id='c', ctx=Load())))"
msgstr ""
">>> print(ast.dump(ast.parse('a if b else c', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=IfExp(\n"
"        test=Name(id='b', ctx=Load()),\n"
"        body=Name(id='a', ctx=Load()),\n"
"        orelse=Name(id='c', ctx=Load())))"

#: ../../library/ast.rst:644
msgid ""
"Attribute access, e.g. ``d.keys``. ``value`` is a node, typically a :class:"
"`Name`. ``attr`` is a bare string giving the name of the attribute, and "
"``ctx`` is :class:`Load`, :class:`Store` or :class:`Del` according to how "
"the attribute is acted on."
msgstr ""
"Acesso a atributo como, por exemplo, ``d.keys``. ``value`` é um nó, "
"normalmente um :class:`Name`. ``attr`` é uma string simples fornecendo o "
"nome do atributo, e ``ctx`` é :class:`Load`, :class:`Store` ou :class:`Del` "
"de acordo com como o atributo é acionado sobre."

#: ../../library/ast.rst:649
msgid ""
">>> print(ast.dump(ast.parse('snake.colour', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Attribute(\n"
"        value=Name(id='snake', ctx=Load()),\n"
"        attr='colour',\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('snake.colour', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Attribute(\n"
"        value=Name(id='snake', ctx=Load()),\n"
"        attr='colour',\n"
"        ctx=Load()))"

#: ../../library/ast.rst:661
msgid ""
"A named expression. This AST node is produced by the assignment expressions "
"operator (also known as the walrus operator). As opposed to the :class:"
"`Assign` node in which the first argument can be multiple nodes, in this "
"case both ``target`` and ``value`` must be single nodes."
msgstr ""
"Uma expressão nomeada. Este nó de AST é produzido pelo operador de "
"expressões de atribuição (também conhecido como operador morsa). Ao "
"contrário do nó :class:`Assign` no qual o primeiro argumento pode ser "
"múltiplos nós, neste caso ambos ``target`` e ``value`` devem ser nós únicos."

#: ../../library/ast.rst:666
msgid ""
">>> print(ast.dump(ast.parse('(x := 4)', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=NamedExpr(\n"
"        target=Name(id='x', ctx=Store()),\n"
"        value=Constant(value=4)))"
msgstr ""
">>> print(ast.dump(ast.parse('(x := 4)', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=NamedExpr(\n"
"        target=Name(id='x', ctx=Store()),\n"
"        value=Constant(value=4)))"

#: ../../library/ast.rst:677
msgid "Subscripting"
msgstr "Subscrição"

#: ../../library/ast.rst:681
msgid ""
"A subscript, such as ``l[1]``. ``value`` is the subscripted object (usually "
"sequence or mapping). ``slice`` is an index, slice or key. It can be a :"
"class:`Tuple` and contain a :class:`Slice`. ``ctx`` is :class:`Load`, :class:"
"`Store` or :class:`Del` according to the action performed with the subscript."
msgstr ""
"Um subscrito, como ``l[1]``. ``value`` é o objeto subscrito (geralmente "
"sequência ou mapeamento). ``slice`` é um índice, fatia ou chave. Pode ser "
"uma :class:`Tuple` e conter uma :class:`Slice`. ``ctx`` é :class:`Load`, :"
"class:`Store` ou :class:`Del` de acordo com a ação realizada com o subscrito."

#: ../../library/ast.rst:687
msgid ""
">>> print(ast.dump(ast.parse('l[1:2, 3]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Subscript(\n"
"        value=Name(id='l', ctx=Load()),\n"
"        slice=Tuple(\n"
"            elts=[\n"
"                Slice(\n"
"                    lower=Constant(value=1),\n"
"                    upper=Constant(value=2)),\n"
"                Constant(value=3)],\n"
"            ctx=Load()),\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('l[1:2, 3]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Subscript(\n"
"        value=Name(id='l', ctx=Load()),\n"
"        slice=Tuple(\n"
"            elts=[\n"
"                Slice(\n"
"                    lower=Constant(value=1),\n"
"                    upper=Constant(value=2)),\n"
"                Constant(value=3)],\n"
"            ctx=Load()),\n"
"        ctx=Load()))"

#: ../../library/ast.rst:705
msgid ""
"Regular slicing (on the form ``lower:upper`` or ``lower:upper:step``). Can "
"occur only inside the *slice* field of :class:`Subscript`, either directly "
"or as an element of :class:`Tuple`."
msgstr ""
"Fatiamento regular (no formato ``lower:upper`` ou ``lower:upper:step``). "
"Pode ocorrer apenas dentro do campo *slice* de :class:`Subscript`, "
"diretamente ou como um elemento de :class:`Tuple`."

#: ../../library/ast.rst:709
msgid ""
">>> print(ast.dump(ast.parse('l[1:2]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Subscript(\n"
"        value=Name(id='l', ctx=Load()),\n"
"        slice=Slice(\n"
"            lower=Constant(value=1),\n"
"            upper=Constant(value=2)),\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('l[1:2]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Subscript(\n"
"        value=Name(id='l', ctx=Load()),\n"
"        slice=Slice(\n"
"            lower=Constant(value=1),\n"
"            upper=Constant(value=2)),\n"
"        ctx=Load()))"

#: ../../library/ast.rst:722
msgid "Comprehensions"
msgstr "Compreensões"

#: ../../library/ast.rst:729
msgid ""
"List and set comprehensions, generator expressions, and dictionary "
"comprehensions. ``elt`` (or ``key`` and ``value``) is a single node "
"representing the part that will be evaluated for each item."
msgstr ""
"Lista e define compreensões, expressões geradoras e compreensões de "
"dicionário. ``elt`` (ou ``key`` e ``value``) é um único nó que representa a "
"parte que será avaliada para cada item."

#: ../../library/ast.rst:733
msgid "``generators`` is a list of :class:`comprehension` nodes."
msgstr "``generators`` é uma lista de nós de :class:`comprehension`."

#: ../../library/ast.rst:735
msgid ""
">>> print(ast.dump(\n"
"...     ast.parse('[x for x in numbers]', mode='eval'),\n"
"...     indent=4,\n"
"... ))\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Name(id='x', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))\n"
">>> print(ast.dump(\n"
"...     ast.parse('{x: x**2 for x in numbers}', mode='eval'),\n"
"...     indent=4,\n"
"... ))\n"
"Expression(\n"
"    body=DictComp(\n"
"        key=Name(id='x', ctx=Load()),\n"
"        value=BinOp(\n"
"            left=Name(id='x', ctx=Load()),\n"
"            op=Pow(),\n"
"            right=Constant(value=2)),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))\n"
">>> print(ast.dump(\n"
"...     ast.parse('{x for x in numbers}', mode='eval'),\n"
"...     indent=4,\n"
"... ))\n"
"Expression(\n"
"    body=SetComp(\n"
"        elt=Name(id='x', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))"
msgstr ""
">>> print(ast.dump(\n"
"...     ast.parse('[x for x in numbers]', mode='eval'),\n"
"...     indent=4,\n"
"... ))\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Name(id='x', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))\n"
">>> print(ast.dump(\n"
"...     ast.parse('{x: x**2 for x in numbers}', mode='eval'),\n"
"...     indent=4,\n"
"... ))\n"
"Expression(\n"
"    body=DictComp(\n"
"        key=Name(id='x', ctx=Load()),\n"
"        value=BinOp(\n"
"            left=Name(id='x', ctx=Load()),\n"
"            op=Pow(),\n"
"            right=Constant(value=2)),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))\n"
">>> print(ast.dump(\n"
"...     ast.parse('{x for x in numbers}', mode='eval'),\n"
"...     indent=4,\n"
"... ))\n"
"Expression(\n"
"    body=SetComp(\n"
"        elt=Name(id='x', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))"

#: ../../library/ast.rst:781
msgid ""
"One ``for`` clause in a comprehension. ``target`` is the reference to use "
"for each element - typically a :class:`Name` or :class:`Tuple` node. "
"``iter`` is the object to iterate over. ``ifs`` is a list of test "
"expressions: each ``for`` clause can have multiple ``ifs``."
msgstr ""
"Uma cláusula ``for`` em uma compreensão. ``target`` é a referência a ser "
"usada para cada elemento - normalmente um nó :class:`Name` ou :class:"
"`Tuple`. ``iter`` é o objeto sobre o qual iterar. ``ifs`` é uma lista de "
"expressões de teste: cada cláusula ``for`` pode ter múltiplos ``ifs``."

#: ../../library/ast.rst:786
msgid ""
"``is_async`` indicates a comprehension is asynchronous (using an ``async "
"for`` instead of ``for``). The value is an integer (0 or 1)."
msgstr ""
"``is_async`` indica que uma compreensão é assíncrona (usando um ``async "
"for`` em vez de ``for``). O valor é um número inteiro (0 ou 1)."

#: ../../library/ast.rst:789
msgid ""
">>> print(ast.dump(ast.parse('[ord(c) for line in file for c in line]', "
"mode='eval'),\n"
"...                indent=4)) # Multiple comprehensions in one.\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Call(\n"
"            func=Name(id='ord', ctx=Load()),\n"
"            args=[\n"
"                Name(id='c', ctx=Load())]),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='line', ctx=Store()),\n"
"                iter=Name(id='file', ctx=Load()),\n"
"                is_async=0),\n"
"            comprehension(\n"
"                target=Name(id='c', ctx=Store()),\n"
"                iter=Name(id='line', ctx=Load()),\n"
"                is_async=0)]))\n"
"\n"
">>> print(ast.dump(ast.parse('(n**2 for n in it if n>5 if n<10)', "
"mode='eval'),\n"
"...                indent=4)) # generator comprehension\n"
"Expression(\n"
"    body=GeneratorExp(\n"
"        elt=BinOp(\n"
"            left=Name(id='n', ctx=Load()),\n"
"            op=Pow(),\n"
"            right=Constant(value=2)),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='n', ctx=Store()),\n"
"                iter=Name(id='it', ctx=Load()),\n"
"                ifs=[\n"
"                    Compare(\n"
"                        left=Name(id='n', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=5)]),\n"
"                    Compare(\n"
"                        left=Name(id='n', ctx=Load()),\n"
"                        ops=[\n"
"                            Lt()],\n"
"                        comparators=[\n"
"                            Constant(value=10)])],\n"
"                is_async=0)]))\n"
"\n"
">>> print(ast.dump(ast.parse('[i async for i in soc]', mode='eval'),\n"
"...                indent=4)) # Async comprehension\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Name(id='i', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='i', ctx=Store()),\n"
"                iter=Name(id='soc', ctx=Load()),\n"
"                is_async=1)]))"
msgstr ""
">>> print(ast.dump(ast.parse('[ord(c) for line in file for c in line]', "
"mode='eval'),\n"
"...                indent=4)) # Várias compreensões em uma.\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Call(\n"
"            func=Name(id='ord', ctx=Load()),\n"
"            args=[\n"
"                Name(id='c', ctx=Load())]),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='line', ctx=Store()),\n"
"                iter=Name(id='file', ctx=Load()),\n"
"                is_async=0),\n"
"            comprehension(\n"
"                target=Name(id='c', ctx=Store()),\n"
"                iter=Name(id='line', ctx=Load()),\n"
"                is_async=0)]))\n"
"\n"
">>> print(ast.dump(ast.parse('(n**2 for n in it if n>5 if n<10)', "
"mode='eval'),\n"
"...                indent=4)) # compreensão de gerador\n"
"Expression(\n"
"    body=GeneratorExp(\n"
"        elt=BinOp(\n"
"            left=Name(id='n', ctx=Load()),\n"
"            op=Pow(),\n"
"            right=Constant(value=2)),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='n', ctx=Store()),\n"
"                iter=Name(id='it', ctx=Load()),\n"
"                ifs=[\n"
"                    Compare(\n"
"                        left=Name(id='n', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=5)]),\n"
"                    Compare(\n"
"                        left=Name(id='n', ctx=Load()),\n"
"                        ops=[\n"
"                            Lt()],\n"
"                        comparators=[\n"
"                            Constant(value=10)])],\n"
"                is_async=0)]))\n"
"\n"
">>> print(ast.dump(ast.parse('[i async for i in soc]', mode='eval'),\n"
"...                indent=4)) # compreensão de async\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Name(id='i', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='i', ctx=Store()),\n"
"                iter=Name(id='soc', ctx=Load()),\n"
"                is_async=1)]))"

#: ../../library/ast.rst:851
msgid "Statements"
msgstr "Instruções"

#: ../../library/ast.rst:855
msgid ""
"An assignment. ``targets`` is a list of nodes, and ``value`` is a single "
"node."
msgstr ""
"Uma atribuição. ``targets`` é uma lista de nós e ``value`` é um único nó."

#: ../../library/ast.rst:857
msgid ""
"Multiple nodes in ``targets`` represents assigning the same value to each. "
"Unpacking is represented by putting a :class:`Tuple` or :class:`List` within "
"``targets``."
msgstr ""
"Vários nós em ``targets`` representam a atribuição do mesmo valor a cada um. "
"O desempacotamento é representada colocando uma :class:`Tuple` ou :class:"
"`List` dentro de ``targets``."

#: ../../library/ast.rst:863 ../../library/ast.rst:1158
#: ../../library/ast.rst:1352 ../../library/ast.rst:1881
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment."
msgstr ""
"``type_comment`` é uma string opcional com a anotação de tipo como "
"comentário."

#: ../../library/ast.rst:865
msgid ""
">>> print(ast.dump(ast.parse('a = b = 1'), indent=4)) # Multiple assignment\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='a', ctx=Store()),\n"
"                Name(id='b', ctx=Store())],\n"
"            value=Constant(value=1))])\n"
"\n"
">>> print(ast.dump(ast.parse('a,b = c'), indent=4)) # Unpacking\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Tuple(\n"
"                    elts=[\n"
"                        Name(id='a', ctx=Store()),\n"
"                        Name(id='b', ctx=Store())],\n"
"                    ctx=Store())],\n"
"            value=Name(id='c', ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse('a = b = 1'), indent=4)) # Multiple assignment\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='a', ctx=Store()),\n"
"                Name(id='b', ctx=Store())],\n"
"            value=Constant(value=1))])\n"
"\n"
">>> print(ast.dump(ast.parse('a,b = c'), indent=4)) # Unpacking\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Tuple(\n"
"                    elts=[\n"
"                        Name(id='a', ctx=Store()),\n"
"                        Name(id='b', ctx=Store())],\n"
"                    ctx=Store())],\n"
"            value=Name(id='c', ctx=Load()))])"

#: ../../library/ast.rst:891
msgid ""
"An assignment with a type annotation. ``target`` is a single node and can be "
"a :class:`Name`, an :class:`Attribute` or a :class:`Subscript`. "
"``annotation`` is the annotation, such as a :class:`Constant` or :class:"
"`Name` node. ``value`` is a single optional node."
msgstr ""
"Uma atribuição com uma anotação de tipo. ``target`` é um nó único e pode ser "
"uma classe :class:`Name`, :class:`Attribute` ou :class:`Subscript`. "
"``annotation`` é a anotação, como um nó :class:`Constant` ou :class:`Name`. "
"``value`` é um único nó opcional."

#: ../../library/ast.rst:896
msgid ""
"``simple`` is always either 0 (indicating a \"complex\" target) or 1 "
"(indicating a \"simple\" target). A \"simple\" target consists solely of a :"
"class:`Name` node that does not appear between parentheses; all other "
"targets are considered complex. Only simple targets appear in the :attr:"
"`~object.__annotations__` dictionary of modules and classes."
msgstr ""
"``simple`` é sempre 0 (indicando um alvo \"complexo\") ou 1 (indicando um "
"alvo \"simples\"). Um alvo \"simples\" consiste apenas em um nó :class:"
"`Name` que não aparece entre parênteses; todos os outros alvos são "
"considerados complexos. Apenas alvos simples aparecem no dicionário :attr:"
"`~object.__annotations__` de módulos e classes."

#: ../../library/ast.rst:902
msgid ""
">>> print(ast.dump(ast.parse('c: int'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Name(id='c', ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=1)])\n"
"\n"
">>> print(ast.dump(ast.parse('(a): int = 1'), indent=4)) # Annotation with "
"parenthesis\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Name(id='a', ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            value=Constant(value=1),\n"
"            simple=0)])\n"
"\n"
">>> print(ast.dump(ast.parse('a.b: int'), indent=4)) # Attribute annotation\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Attribute(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                attr='b',\n"
"                ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=0)])\n"
"\n"
">>> print(ast.dump(ast.parse('a[1]: int'), indent=4)) # Subscript "
"annotation\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Subscript(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                slice=Constant(value=1),\n"
"                ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=0)])"
msgstr ""
">>> print(ast.dump(ast.parse('c: int'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Name(id='c', ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=1)])\n"
"\n"
">>> print(ast.dump(ast.parse('(a): int = 1'), indent=4)) # Annotation with "
"parenthesis\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Name(id='a', ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            value=Constant(value=1),\n"
"            simple=0)])\n"
"\n"
">>> print(ast.dump(ast.parse('a.b: int'), indent=4)) # Attribute annotation\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Attribute(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                attr='b',\n"
"                ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=0)])\n"
"\n"
">>> print(ast.dump(ast.parse('a[1]: int'), indent=4)) # Subscript "
"annotation\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Subscript(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                slice=Constant(value=1),\n"
"                ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=0)])"

#: ../../library/ast.rst:946
msgid ""
"Augmented assignment, such as ``a += 1``. In the following example, "
"``target`` is a :class:`Name` node for ``x`` (with the :class:`Store` "
"context), ``op`` is :class:`Add`, and ``value`` is a :class:`Constant` with "
"value for 1."
msgstr ""
"Atribuição aumentada, como ``a += 1``. No exemplo a seguir, ``target`` é um "
"nó :class:`Name` para ``x`` (com o contexto :class:`Store`), ``op`` é :class:"
"`Add`, e ``value`` é uma :class:`Constant` com valor para 1."

#: ../../library/ast.rst:951
msgid ""
"The ``target`` attribute cannot be of class :class:`Tuple` or :class:`List`, "
"unlike the targets of :class:`Assign`."
msgstr ""
"O atributo ``target`` não pode ser da classe :class:`Tuple` ou :class:"
"`List`, diferentemente dos alvos de :class:`Assign`."

#: ../../library/ast.rst:954
msgid ""
">>> print(ast.dump(ast.parse('x += 2'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AugAssign(\n"
"            target=Name(id='x', ctx=Store()),\n"
"            op=Add(),\n"
"            value=Constant(value=2))])"
msgstr ""
">>> print(ast.dump(ast.parse('x += 2'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AugAssign(\n"
"            target=Name(id='x', ctx=Store()),\n"
"            op=Add(),\n"
"            value=Constant(value=2))])"

#: ../../library/ast.rst:967
msgid ""
"A ``raise`` statement. ``exc`` is the exception object to be raised, "
"normally a :class:`Call` or :class:`Name`, or ``None`` for a standalone "
"``raise``. ``cause`` is the optional part for ``y`` in ``raise x from y``."
msgstr ""
"Uma instrução ``raise``. ``exc`` é o objeto de exceção a ser levantado, "
"normalmente uma :class:`Call` ou :class:`Name`, ou ``None`` para um "
"``raise`` independente. ``cause`` é a parte opcional para ``y`` em ``raise x "
"from y``."

#: ../../library/ast.rst:971
msgid ""
">>> print(ast.dump(ast.parse('raise x from y'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Raise(\n"
"            exc=Name(id='x', ctx=Load()),\n"
"            cause=Name(id='y', ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse('raise x from y'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Raise(\n"
"            exc=Name(id='x', ctx=Load()),\n"
"            cause=Name(id='y', ctx=Load()))])"

#: ../../library/ast.rst:983
msgid ""
"An assertion. ``test`` holds the condition, such as a :class:`Compare` node. "
"``msg`` holds the failure message."
msgstr ""
"Uma asserção. ``test`` contém a condição, como um nó :class:`Compare`. "
"``msg`` contém a mensagem de falha."

#: ../../library/ast.rst:986
msgid ""
">>> print(ast.dump(ast.parse('assert x,y'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assert(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            msg=Name(id='y', ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse('assert x,y'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assert(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            msg=Name(id='y', ctx=Load()))])"

#: ../../library/ast.rst:998
msgid ""
"Represents a ``del`` statement. ``targets`` is a list of nodes, such as :"
"class:`Name`, :class:`Attribute` or :class:`Subscript` nodes."
msgstr ""
"Representa uma instrução ``del``. ``targets`` é uma lista de nós, como nós :"
"class:`Name`, :class:`Attribute` ou :class:`Subscript`."

#: ../../library/ast.rst:1001
msgid ""
">>> print(ast.dump(ast.parse('del x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Delete(\n"
"            targets=[\n"
"                Name(id='x', ctx=Del()),\n"
"                Name(id='y', ctx=Del()),\n"
"                Name(id='z', ctx=Del())])])"
msgstr ""
">>> print(ast.dump(ast.parse('del x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Delete(\n"
"            targets=[\n"
"                Name(id='x', ctx=Del()),\n"
"                Name(id='y', ctx=Del()),\n"
"                Name(id='z', ctx=Del())])])"

#: ../../library/ast.rst:1015
msgid "A ``pass`` statement."
msgstr "Uma instrução ``pass``."

#: ../../library/ast.rst:1017
msgid ""
">>> print(ast.dump(ast.parse('pass'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Pass()])"
msgstr ""
">>> print(ast.dump(ast.parse('pass'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Pass()])"

#: ../../library/ast.rst:1027
msgid ""
"A :ref:`type alias <type-aliases>` created through the :keyword:`type` "
"statement. ``name`` is the name of the alias, ``type_params`` is a list of :"
"ref:`type parameters <ast-type-params>`, and ``value`` is the value of the "
"type alias."
msgstr ""
"Um :ref:`apelido de tipo <type-aliases>` criado através da instrução :"
"keyword:`type`. ``name`` é o nome do apelido, ``type_params`` é uma lista "
"de :ref:`parâmetros de tipo <ast-type-params>`, e ``value`` é o valor do "
"apelido do tipo."

#: ../../library/ast.rst:1032
msgid ""
">>> print(ast.dump(ast.parse('type Alias = int'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            value=Name(id='int', ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse('type Alias = int'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            value=Name(id='int', ctx=Load()))])"

#: ../../library/ast.rst:1043
msgid ""
"Other statements which are only applicable inside functions or loops are "
"described in other sections."
msgstr ""
"Outras instruções que são aplicáveis apenas dentro de funções ou laços são "
"descritas em outras seções."

#: ../../library/ast.rst:1047
msgid "Imports"
msgstr "Importações"

#: ../../library/ast.rst:1051
msgid "An import statement. ``names`` is a list of :class:`alias` nodes."
msgstr ""
"Uma instrução de importação. ``names`` é uma lista de nós de :class:`alias`."

#: ../../library/ast.rst:1053
msgid ""
">>> print(ast.dump(ast.parse('import x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Import(\n"
"            names=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')])])"
msgstr ""
">>> print(ast.dump(ast.parse('import x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Import(\n"
"            names=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')])])"

#: ../../library/ast.rst:1067
msgid ""
"Represents ``from x import y``. ``module`` is a raw string of the 'from' "
"name, without any leading dots, or ``None`` for statements such as ``from . "
"import foo``. ``level`` is an integer holding the level of the relative "
"import (0 means absolute import)."
msgstr ""
"Representa ``from x import y``. ``module`` é uma string bruta do nome "
"'from', sem quaisquer pontos iniciais, ou ``None`` para instruções como "
"``from . import foo``. ``level`` é um número inteiro que contém o nível da "
"importação relativa (0 significa importação absoluta)."

#: ../../library/ast.rst:1072
msgid ""
">>> print(ast.dump(ast.parse('from y import x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ImportFrom(\n"
"            module='y',\n"
"            names=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')],\n"
"            level=0)])"
msgstr ""
">>> print(ast.dump(ast.parse('from y import x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ImportFrom(\n"
"            module='y',\n"
"            names=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')],\n"
"            level=0)])"

#: ../../library/ast.rst:1088
msgid ""
"Both parameters are raw strings of the names. ``asname`` can be ``None`` if "
"the regular name is to be used."
msgstr ""
"Ambos os parâmetros são strings brutas dos nomes. ``asname`` pode ser "
"``None`` se o nome normal for usado."

#: ../../library/ast.rst:1091
msgid ""
">>> print(ast.dump(ast.parse('from ..foo.bar import a as b, c'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ImportFrom(\n"
"            module='foo.bar',\n"
"            names=[\n"
"                alias(name='a', asname='b'),\n"
"                alias(name='c')],\n"
"            level=2)])"
msgstr ""
">>> print(ast.dump(ast.parse('from ..foo.bar import a as b, c'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ImportFrom(\n"
"            module='foo.bar',\n"
"            names=[\n"
"                alias(name='a', asname='b'),\n"
"                alias(name='c')],\n"
"            level=2)])"

#: ../../library/ast.rst:1104
msgid "Control flow"
msgstr "Fluxo de controle"

#: ../../library/ast.rst:1107
msgid ""
"Optional clauses such as ``else`` are stored as an empty list if they're not "
"present."
msgstr ""
"Cláusulas opcionais como ``else`` são armazenadas como uma lista vazia se "
"não estiverem presentes."

#: ../../library/ast.rst:1112
msgid ""
"An ``if`` statement. ``test`` holds a single node, such as a :class:"
"`Compare` node. ``body`` and ``orelse`` each hold a list of nodes."
msgstr ""
"Uma instrução ``if``. ``test`` contém um único nó, como um nó :class:"
"`Compare`. ``body`` e ``orelse`` contêm, cada um, uma lista de nós."

#: ../../library/ast.rst:1115
msgid ""
"``elif`` clauses don't have a special representation in the AST, but rather "
"appear as extra :class:`If` nodes within the ``orelse`` section of the "
"previous one."
msgstr ""
"As cláusulas ``elif`` não têm uma representação especial no AST, mas "
"aparecem como nós extras de :class:`If` dentro da seção ``orelse`` da "
"cláusula anterior."

#: ../../library/ast.rst:1119
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... if x:\n"
"...    ...\n"
"... elif y:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        If(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                If(\n"
"                    test=Name(id='y', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))],\n"
"                    orelse=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... if x:\n"
"...    ...\n"
"... elif y:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        If(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                If(\n"
"                    test=Name(id='y', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))],\n"
"                    orelse=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"

#: ../../library/ast.rst:1149
msgid ""
"A ``for`` loop. ``target`` holds the variable(s) the loop assigns to, as a "
"single :class:`Name`, :class:`Tuple`, :class:`List`, :class:`Attribute` or :"
"class:`Subscript` node. ``iter`` holds the item to be looped over, again as "
"a single node. ``body`` and ``orelse`` contain lists of nodes to execute. "
"Those in ``orelse`` are executed if the loop finishes normally, rather than "
"via a ``break`` statement."
msgstr ""
"Um laço ``for``. ``target`` contém as variáveis às quais o laço atribui, "
"como um único nó de :class:`Name`, :class:`Tuple`, :class:`List`, :class:"
"`Attribute` ou :class:`Subscript`. ``iter`` contém o item a ser repetido, "
"novamente como um único nó. ``body`` e ``orelse`` contêm listas de nós para "
"executar. Aqueles em ``orelse`` são executados se o laço terminar "
"normalmente, ao invés de através de uma instrução ``break``."

#: ../../library/ast.rst:1160
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... for x in y:\n"
"...     ...\n"
"... else:\n"
"...     ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        For(\n"
"            target=Name(id='x', ctx=Store()),\n"
"            iter=Name(id='y', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... for x in y:\n"
"...     ...\n"
"... else:\n"
"...     ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        For(\n"
"            target=Name(id='x', ctx=Store()),\n"
"            iter=Name(id='y', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])])"

#: ../../library/ast.rst:1183
msgid ""
"A ``while`` loop. ``test`` holds the condition, such as a :class:`Compare` "
"node."
msgstr ""
"Um laço ``while``. ``test`` contém a condição, como um nó de :class:"
"`Compare`."

#: ../../library/ast.rst:1186
msgid ""
">> print(ast.dump(ast.parse(\"\"\"\n"
"... while x:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        While(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])])"
msgstr ""
">> print(ast.dump(ast.parse(\"\"\"\n"
"... while x:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        While(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])])"

#: ../../library/ast.rst:1209
msgid "The ``break`` and ``continue`` statements."
msgstr "As instruções ``break`` e ``continue``."

#: ../../library/ast.rst:1211
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... for a in b:\n"
"...     if a > 5:\n"
"...         break\n"
"...     else:\n"
"...         continue\n"
"...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        For(\n"
"            target=Name(id='a', ctx=Store()),\n"
"            iter=Name(id='b', ctx=Load()),\n"
"            body=[\n"
"                If(\n"
"                    test=Compare(\n"
"                        left=Name(id='a', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=5)]),\n"
"                    body=[\n"
"                        Break()],\n"
"                    orelse=[\n"
"                        Continue()])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... for a in b:\n"
"...     if a > 5:\n"
"...         break\n"
"...     else:\n"
"...         continue\n"
"...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        For(\n"
"            target=Name(id='a', ctx=Store()),\n"
"            iter=Name(id='b', ctx=Load()),\n"
"            body=[\n"
"                If(\n"
"                    test=Compare(\n"
"                        left=Name(id='a', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=5)]),\n"
"                    body=[\n"
"                        Break()],\n"
"                    orelse=[\n"
"                        Continue()])])])"

#: ../../library/ast.rst:1242
msgid ""
"``try`` blocks. All attributes are list of nodes to execute, except for "
"``handlers``, which is a list of :class:`ExceptHandler` nodes."
msgstr ""
"Blocos ``try``. Todos os atributos são uma lista de nós a serem executados, "
"exceto ``handlers``, que é uma lista de nós de :class:`ExceptHandler`."

#: ../../library/ast.rst:1245
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... try:\n"
"...    ...\n"
"... except Exception:\n"
"...    ...\n"
"... except OtherException as e:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... finally:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Try(\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                ExceptHandler(\n"
"                    type=Name(id='OtherException', ctx=Load()),\n"
"                    name='e',\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            finalbody=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... try:\n"
"...    ...\n"
"... except Exception:\n"
"...    ...\n"
"... except OtherException as e:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... finally:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Try(\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                ExceptHandler(\n"
"                    type=Name(id='OtherException', ctx=Load()),\n"
"                    name='e',\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            finalbody=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])])"

#: ../../library/ast.rst:1287
msgid ""
"``try`` blocks which are followed by ``except*`` clauses. The attributes are "
"the same as for :class:`Try` but the :class:`ExceptHandler` nodes in "
"``handlers`` are interpreted as ``except*`` blocks rather then ``except``."
msgstr ""
"Blocos ``try`` que são seguidos por cláusulas ``except*``. Os atributos são "
"os mesmos de :class:`Try`, mas os nós :class:`ExceptHandler` em ``handlers`` "
"são interpretados como blocos ``except*`` em vez de ``except``."

#: ../../library/ast.rst:1291
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... try:\n"
"...    ...\n"
"... except* Exception:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TryStar(\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... try:\n"
"...    ...\n"
"... except* Exception:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TryStar(\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"

#: ../../library/ast.rst:1316
msgid ""
"A single ``except`` clause. ``type`` is the exception type it will match, "
"typically a :class:`Name` node (or ``None`` for a catch-all ``except:`` "
"clause). ``name`` is a raw string for the name to hold the exception, or "
"``None`` if the clause doesn't have ``as foo``. ``body`` is a list of nodes."
msgstr ""
"Uma única cláusula ``except``. ``type`` é o tipo de exceção que irá "
"corresponder, normalmente um nó de :class:`Name` (ou ``None`` para uma "
"cláusula abrangente ``except:``). ``name`` é uma string bruta para o nome "
"conter a exceção, ou ``None`` se a cláusula não tiver ``as foo``. ``body`` é "
"uma lista de nós."

#: ../../library/ast.rst:1321
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... try:\n"
"...     a + 1\n"
"... except TypeError:\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Try(\n"
"            body=[\n"
"                Expr(\n"
"                    value=BinOp(\n"
"                        left=Name(id='a', ctx=Load()),\n"
"                        op=Add(),\n"
"                        right=Constant(value=1)))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='TypeError', ctx=Load()),\n"
"                    body=[\n"
"                        Pass()])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... try:\n"
"...     a + 1\n"
"... except TypeError:\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Try(\n"
"            body=[\n"
"                Expr(\n"
"                    value=BinOp(\n"
"                        left=Name(id='a', ctx=Load()),\n"
"                        op=Add(),\n"
"                        right=Constant(value=1)))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='TypeError', ctx=Load()),\n"
"                    body=[\n"
"                        Pass()])])])"

#: ../../library/ast.rst:1347
msgid ""
"A ``with`` block. ``items`` is a list of :class:`withitem` nodes "
"representing the context managers, and ``body`` is the indented block inside "
"the context."
msgstr ""
"Um bloco ``with``. ``items`` é uma lista de nós :class:`withitem` "
"representando os gerenciadores de contexto, e ``body`` é o bloco indentado "
"dentro do contexto."

#: ../../library/ast.rst:1357
msgid ""
"A single context manager in a ``with`` block. ``context_expr`` is the "
"context manager, often a :class:`Call` node. ``optional_vars`` is a :class:"
"`Name`, :class:`Tuple` or :class:`List` for the ``as foo`` part, or ``None`` "
"if that isn't used."
msgstr ""
"Um único gerenciador de contexto em um bloco ``with``. ``context_expr`` é o "
"gerenciador de contexto, geralmente um nó de :class:`Call`. "
"``optional_vars`` é um :class:`Name`, :class:`Tuple` ou :class:`List` para a "
"parte ``as foo``, ou ``None`` se não for usado."

#: ../../library/ast.rst:1362
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... with a as b, c as d:\n"
"...    something(b, d)\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        With(\n"
"            items=[\n"
"                withitem(\n"
"                    context_expr=Name(id='a', ctx=Load()),\n"
"                    optional_vars=Name(id='b', ctx=Store())),\n"
"                withitem(\n"
"                    context_expr=Name(id='c', ctx=Load()),\n"
"                    optional_vars=Name(id='d', ctx=Store()))],\n"
"            body=[\n"
"                Expr(\n"
"                    value=Call(\n"
"                        func=Name(id='something', ctx=Load()),\n"
"                        args=[\n"
"                            Name(id='b', ctx=Load()),\n"
"                            Name(id='d', ctx=Load())]))])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... with a as b, c as d:\n"
"...    something(b, d)\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        With(\n"
"            items=[\n"
"                withitem(\n"
"                    context_expr=Name(id='a', ctx=Load()),\n"
"                    optional_vars=Name(id='b', ctx=Store())),\n"
"                withitem(\n"
"                    context_expr=Name(id='c', ctx=Load()),\n"
"                    optional_vars=Name(id='d', ctx=Store()))],\n"
"            body=[\n"
"                Expr(\n"
"                    value=Call(\n"
"                        func=Name(id='something', ctx=Load()),\n"
"                        args=[\n"
"                            Name(id='b', ctx=Load()),\n"
"                            Name(id='d', ctx=Load())]))])])"

#: ../../library/ast.rst:1388
msgid "Pattern matching"
msgstr "Correspondência de padrões"

#: ../../library/ast.rst:1393
msgid ""
"A ``match`` statement. ``subject`` holds the subject of the match (the "
"object that is being matched against the cases) and ``cases`` contains an "
"iterable of :class:`match_case` nodes with the different cases."
msgstr ""
"Uma instrução ``match``. ``subject`` contém o assunto da correspondência (o "
"objeto que está sendo comparado com os casos) e ``cases`` contém um iterável "
"de nós de :class:`match_case` com os diferentes casos."

#: ../../library/ast.rst:1401
msgid ""
"A single case pattern in a ``match`` statement. ``pattern`` contains the "
"match pattern that the subject will be matched against. Note that the :class:"
"`AST` nodes produced for patterns differ from those produced for "
"expressions, even when they share the same syntax."
msgstr ""
"Um padrão de caso único em uma instrução ``match``. ``pattern`` contém o "
"padrão de correspondência com o qual o assunto será comparado. Observe que "
"os nós :class:`AST` produzidos para padrões diferem daqueles produzidos para "
"expressões, mesmo quando compartilham a mesma sintaxe."

#: ../../library/ast.rst:1406
msgid ""
"The ``guard`` attribute contains an expression that will be evaluated if the "
"pattern matches the subject."
msgstr ""
"O atributo ``guard`` contém uma expressão que será avaliada se o padrão "
"corresponder ao assunto."

#: ../../library/ast.rst:1409
msgid ""
"``body`` contains a list of nodes to execute if the pattern matches and the "
"result of evaluating the guard expression is true."
msgstr ""
"``body`` contém uma lista de nós a serem executados se o padrão corresponder "
"e o resultado da avaliação da expressão de guarda for verdadeiro."

#: ../../library/ast.rst:1412
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] if x>0:\n"
"...         ...\n"
"...     case tuple():\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchAs(name='x')]),\n"
"                    guard=Compare(\n"
"                        left=Name(id='x', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=0)]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='tuple', ctx=Load())),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] if x>0:\n"
"...         ...\n"
"...     case tuple():\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchAs(name='x')]),\n"
"                    guard=Compare(\n"
"                        left=Name(id='x', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=0)]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='tuple', ctx=Load())),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"

#: ../../library/ast.rst:1450
msgid ""
"A match literal or value pattern that compares by equality. ``value`` is an "
"expression node. Permitted value nodes are restricted as described in the "
"match statement documentation. This pattern succeeds if the match subject is "
"equal to the evaluated value."
msgstr ""
"Um literal de correspondência ou padrão de valor que é comparado por "
"igualdade. ``value`` é um nó de expressão. Os nós de valor permitido são "
"restritos conforme descrito na documentação da instrução de correspondência. "
"Este padrão será bem-sucedido se o assunto da correspondência for igual ao "
"valor avaliado."

#: ../../library/ast.rst:1455
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case \"Relevant\":\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchValue(\n"
"                        value=Constant(value='Relevant')),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case \"Relevant\":\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchValue(\n"
"                        value=Constant(value='Relevant')),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"

#: ../../library/ast.rst:1478
msgid ""
"A match literal pattern that compares by identity. ``value`` is the "
"singleton to be compared against: ``None``, ``True``, or ``False``. This "
"pattern succeeds if the match subject is the given constant."
msgstr ""
"Um padrão literal de correspondência que compara por identidade. ``value`` é "
"o singleton a ser comparado com: ``None``, ``True`` ou ``False``. Este "
"padrão será bem-sucedido se o assunto da correspondência for a constante "
"fornecida."

#: ../../library/ast.rst:1482
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case None:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSingleton(value=None),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case None:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSingleton(value=None),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"

#: ../../library/ast.rst:1504
msgid ""
"A match sequence pattern. ``patterns`` contains the patterns to be matched "
"against the subject elements if the subject is a sequence. Matches a "
"variable length sequence if one of the subpatterns is a ``MatchStar`` node, "
"otherwise matches a fixed length sequence."
msgstr ""
"Um padrão de sequência de correspondência. ``patterns`` contém os padrões a "
"serem comparados aos elementos do assunto se o assunto for uma sequência. "
"Corresponde a uma sequência de comprimento variável se um dos subpadrões for "
"um nó ``MatchStar``, caso contrário corresponde a uma sequência de "
"comprimento fixo."

#: ../../library/ast.rst:1509
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [1, 2]:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=1)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=2))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [1, 2]:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=1)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=2))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"

#: ../../library/ast.rst:1536
msgid ""
"Matches the rest of the sequence in a variable length match sequence "
"pattern. If ``name`` is not ``None``, a list containing the remaining "
"sequence elements is bound to that name if the overall sequence pattern is "
"successful."
msgstr ""
"Corresponde ao restante da sequência em um padrão de sequência de "
"correspondência de comprimento variável. Se ``name`` não for ``None``, uma "
"lista contendo os elementos restantes da sequência será vinculada a esse "
"nome se o padrão de sequência geral for bem-sucedido."

#: ../../library/ast.rst:1540
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [1, 2, *rest]:\n"
"...         ...\n"
"...     case [*_]:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=1)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=2)),\n"
"                            MatchStar(name='rest')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchStar()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [1, 2, *rest]:\n"
"...         ...\n"
"...     case [*_]:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=1)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=2)),\n"
"                            MatchStar(name='rest')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchStar()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"

#: ../../library/ast.rst:1577
msgid ""
"A match mapping pattern. ``keys`` is a sequence of expression nodes. "
"``patterns`` is a corresponding sequence of pattern nodes. ``rest`` is an "
"optional name that can be specified to capture the remaining mapping "
"elements. Permitted key expressions are restricted as described in the match "
"statement documentation."
msgstr ""
"Um padrão de mapeamento de correspondência. ``keys`` é uma sequência de nós "
"de expressão. ``patterns`` é uma sequência correspondente de nós padrão. "
"``rest`` é um nome opcional que pode ser especificado para capturar os "
"elementos restantes do mapeamento. As expressões-chave permitidas são "
"restritas conforme descrito na documentação da instrução match."

#: ../../library/ast.rst:1583
msgid ""
"This pattern succeeds if the subject is a mapping, all evaluated key "
"expressions are present in the mapping, and the value corresponding to each "
"key matches the corresponding subpattern. If ``rest`` is not ``None``, a "
"dict containing the remaining mapping elements is bound to that name if the "
"overall mapping pattern is successful."
msgstr ""
"Este padrão será bem-sucedido se o assunto for um mapeamento, todas as "
"expressões-chave avaliadas estiverem presentes no mapeamento e o valor "
"correspondente a cada chave corresponder ao subpadrão correspondente. Se "
"``rest`` não for ``None``, um dict contendo os elementos de mapeamento "
"restantes será vinculado a esse nome se o padrão de mapeamento geral for bem-"
"sucedido."

#: ../../library/ast.rst:1589
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case {1: _, 2: _}:\n"
"...         ...\n"
"...     case {**rest}:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchMapping(\n"
"                        keys=[\n"
"                            Constant(value=1),\n"
"                            Constant(value=2)],\n"
"                        patterns=[\n"
"                            MatchAs(),\n"
"                            MatchAs()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchMapping(rest='rest'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case {1: _, 2: _}:\n"
"...         ...\n"
"...     case {**rest}:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchMapping(\n"
"                        keys=[\n"
"                            Constant(value=1),\n"
"                            Constant(value=2)],\n"
"                        patterns=[\n"
"                            MatchAs(),\n"
"                            MatchAs()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchMapping(rest='rest'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"

#: ../../library/ast.rst:1624
msgid ""
"A match class pattern. ``cls`` is an expression giving the nominal class to "
"be matched. ``patterns`` is a sequence of pattern nodes to be matched "
"against the class defined sequence of pattern matching attributes. "
"``kwd_attrs`` is a sequence of additional attributes to be matched "
"(specified as keyword arguments in the class pattern), ``kwd_patterns`` are "
"the corresponding patterns (specified as keyword values in the class "
"pattern)."
msgstr ""
"Um padrão de classe de correspondência. ``cls`` é uma expressão que fornece "
"a classe nominal a ser correspondida. ``patterns`` é uma sequência de nós "
"padrão a serem comparados com a sequência definida pela classe de atributos "
"de correspondência de padrões. ``kwd_attrs`` é uma sequência de atributos "
"adicionais a serem correspondidos (especificados como argumentos nomeados no "
"padrão de classe), ``kwd_patterns`` são os padrões correspondentes "
"(especificados como valores de argumentos nomeados no padrão de classe)."

#: ../../library/ast.rst:1631
msgid ""
"This pattern succeeds if the subject is an instance of the nominated class, "
"all positional patterns match the corresponding class-defined attributes, "
"and any specified keyword attributes match their corresponding pattern."
msgstr ""
"Esse padrão será bem-sucedido se o assunto for uma instância da classe "
"indicada, todos os padrões posicionais corresponderem aos atributos "
"correspondentes definidos pela classe e quaisquer atributos, passados como "
"argumentos nomeados, especificados corresponderem ao seu padrão "
"correspondente."

#: ../../library/ast.rst:1635
msgid ""
"Note: classes may define a property that returns self in order to match a "
"pattern node against the instance being matched. Several builtin types are "
"also matched that way, as described in the match statement documentation."
msgstr ""
"Nota: as classes podem definir uma propriedade que retorna self para "
"corresponder um nó padrão à instância que está sendo correspondida. Vários "
"tipos internos também são combinados dessa forma, conforme descrito na "
"documentação da instrução match."

#: ../../library/ast.rst:1639
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case Point2D(0, 0):\n"
"...         ...\n"
"...     case Point3D(x=0, y=0, z=0):\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='Point2D', ctx=Load()),\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='Point3D', ctx=Load()),\n"
"                        kwd_attrs=[\n"
"                            'x',\n"
"                            'y',\n"
"                            'z'],\n"
"                        kwd_patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case Point2D(0, 0):\n"
"...         ...\n"
"...     case Point3D(x=0, y=0, z=0):\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='Point2D', ctx=Load()),\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='Point3D', ctx=Load()),\n"
"                        kwd_attrs=[\n"
"                            'x',\n"
"                            'y',\n"
"                            'z'],\n"
"                        kwd_patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"

#: ../../library/ast.rst:1686
msgid ""
"A match \"as-pattern\", capture pattern or wildcard pattern. ``pattern`` "
"contains the match pattern that the subject will be matched against. If the "
"pattern is ``None``, the node represents a capture pattern (i.e a bare name) "
"and will always succeed."
msgstr ""
"Uma correspondência \"como padrão\", padrão de captura ou padrão curinga. "
"``pattern`` contém o padrão de correspondência com o qual o assunto será "
"comparado. Se o padrão for ``None``, o nó representa um padrão de captura "
"(ou seja, um nome simples) e sempre terá sucesso."

#: ../../library/ast.rst:1691
msgid ""
"The ``name`` attribute contains the name that will be bound if the pattern "
"is successful. If ``name`` is ``None``, ``pattern`` must also be ``None`` "
"and the node represents the wildcard pattern."
msgstr ""
"O atributo ``name`` contém o nome que será vinculado se o padrão for bem-"
"sucedido. Se ``name`` for ``None``, ``pattern`` também deverá ser ``None`` e "
"o nó representa o padrão curinga."

#: ../../library/ast.rst:1695
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] as y:\n"
"...         ...\n"
"...     case _:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchAs(\n"
"                        pattern=MatchSequence(\n"
"                            patterns=[\n"
"                                MatchAs(name='x')]),\n"
"                        name='y'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchAs(),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] as y:\n"
"...         ...\n"
"...     case _:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchAs(\n"
"                        pattern=MatchSequence(\n"
"                            patterns=[\n"
"                                MatchAs(name='x')]),\n"
"                        name='y'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchAs(),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"

#: ../../library/ast.rst:1728
msgid ""
"A match \"or-pattern\". An or-pattern matches each of its subpatterns in "
"turn to the subject, until one succeeds. The or-pattern is then deemed to "
"succeed. If none of the subpatterns succeed the or-pattern fails. The "
"``patterns`` attribute contains a list of match pattern nodes that will be "
"matched against the subject."
msgstr ""
"Uma correspondência de \"padrão ou\". Um \"padrão ou\" corresponde cada um "
"de seus subpadrões com o assunto, até que um seja bem-sucedido. O \"padrão "
"ou\" é então considerado bem-sucedido. Se nenhum dos subpadrões for bem-"
"sucedido, o padrão or falhará. O atributo ``patterns`` contém uma lista de "
"nós de padrões de correspondência que serão comparados com o assunto."

#: ../../library/ast.rst:1734
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] | (y):\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchOr(\n"
"                        patterns=[\n"
"                            MatchSequence(\n"
"                                patterns=[\n"
"                                    MatchAs(name='x')]),\n"
"                            MatchAs(name='y')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] | (y):\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchOr(\n"
"                        patterns=[\n"
"                            MatchSequence(\n"
"                                patterns=[\n"
"                                    MatchAs(name='x')]),\n"
"                            MatchAs(name='y')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"

#: ../../library/ast.rst:1762
msgid "Type parameters"
msgstr "Parâmetros de tipo"

#: ../../library/ast.rst:1764
msgid ""
":ref:`Type parameters <type-params>` can exist on classes, functions, and "
"type aliases."
msgstr ""
":ref:`Parâmetros de tipo <type-params>` podem existir em classes, funções e "
"apelidos de tipo."

#: ../../library/ast.rst:1769
msgid ""
"A :class:`typing.TypeVar`. ``name`` is the name of the type variable. "
"``bound`` is the bound or constraints, if any. If ``bound`` is a :class:"
"`Tuple`, it represents constraints; otherwise it represents the bound. "
"``default_value`` is the default value; if the :class:`!TypeVar` has no "
"default, this attribute will be set to ``None``."
msgstr ""
"Uma :class:`typing.TypeVar`. ``name`` é o nome da variável de tipo. "
"``bound`` é o limite ou as restrições, se houver. Se ``bound`` for uma :"
"class:`Tuple`, ele representa restrições; caso contrário, representa o "
"limite. ``default_value`` é o valor padrão; se :class:`!TypeVar` não tiver "
"padrão, este atributo será definido como ``None``."

#: ../../library/ast.rst:1775
msgid ""
">>> print(ast.dump(ast.parse(\"type Alias[T: int = bool] = list[T]\"), "
"indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVar(\n"
"                    name='T',\n"
"                    bound=Name(id='int', ctx=Load()),\n"
"                    default_value=Name(id='bool', ctx=Load()))],\n"
"            value=Subscript(\n"
"                value=Name(id='list', ctx=Load()),\n"
"                slice=Name(id='T', ctx=Load()),\n"
"                ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse(\"type Alias[T: int = bool] = list[T]\"), "
"indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVar(\n"
"                    name='T',\n"
"                    bound=Name(id='int', ctx=Load()),\n"
"                    default_value=Name(id='bool', ctx=Load()))],\n"
"            value=Subscript(\n"
"                value=Name(id='list', ctx=Load()),\n"
"                slice=Name(id='T', ctx=Load()),\n"
"                ctx=Load()))])"

#: ../../library/ast.rst:1794 ../../library/ast.rst:1829
#: ../../library/ast.rst:1861
msgid "Added the *default_value* parameter."
msgstr "Adicionado o parâmetro *default_value*."

#: ../../library/ast.rst:1799
msgid ""
"A :class:`typing.ParamSpec`. ``name`` is the name of the parameter "
"specification. ``default_value`` is the default value; if the :class:`!"
"ParamSpec` has no default, this attribute will be set to ``None``."
msgstr ""
"Uma :class:`typing.ParamSpec`. ``name`` é o nome da especificação do "
"parâmetro. ``default_value`` é o valor padrão; se :class:`!ParamSpec` não "
"tiver padrão, este atributo será definido como ``None``."

#: ../../library/ast.rst:1803
msgid ""
">>> print(ast.dump(ast.parse(\"type Alias[**P = [int, str]] = Callable[P, "
"int]\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                ParamSpec(\n"
"                    name='P',\n"
"                    default_value=List(\n"
"                        elts=[\n"
"                            Name(id='int', ctx=Load()),\n"
"                            Name(id='str', ctx=Load())],\n"
"                        ctx=Load()))],\n"
"            value=Subscript(\n"
"                value=Name(id='Callable', ctx=Load()),\n"
"                slice=Tuple(\n"
"                    elts=[\n"
"                        Name(id='P', ctx=Load()),\n"
"                        Name(id='int', ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse(\"type Alias[**P = [int, str]] = Callable[P, "
"int]\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                ParamSpec(\n"
"                    name='P',\n"
"                    default_value=List(\n"
"                        elts=[\n"
"                            Name(id='int', ctx=Load()),\n"
"                            Name(id='str', ctx=Load())],\n"
"                        ctx=Load()))],\n"
"            value=Subscript(\n"
"                value=Name(id='Callable', ctx=Load()),\n"
"                slice=Tuple(\n"
"                    elts=[\n"
"                        Name(id='P', ctx=Load()),\n"
"                        Name(id='int', ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))])"

#: ../../library/ast.rst:1834
msgid ""
"A :class:`typing.TypeVarTuple`. ``name`` is the name of the type variable "
"tuple. ``default_value`` is the default value; if the :class:`!TypeVarTuple` "
"has no default, this attribute will be set to ``None``."
msgstr ""
"Uma :class:`typing.TypeVarTuple`. ``name`` é o nome da tupla da variável de "
"tipo. ``default_value`` é o valor padrão; se :class:`!TypeVarTuple` não "
"tiver padrão, este atributo será definido como ``None``."

#: ../../library/ast.rst:1838
msgid ""
">>> print(ast.dump(ast.parse(\"type Alias[*Ts = ()] = tuple[*Ts]\"), "
"indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVarTuple(\n"
"                    name='Ts',\n"
"                    default_value=Tuple(ctx=Load()))],\n"
"            value=Subscript(\n"
"                value=Name(id='tuple', ctx=Load()),\n"
"                slice=Tuple(\n"
"                    elts=[\n"
"                        Starred(\n"
"                            value=Name(id='Ts', ctx=Load()),\n"
"                            ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse(\"type Alias[*Ts = ()] = tuple[*Ts]\"), "
"indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVarTuple(\n"
"                    name='Ts',\n"
"                    default_value=Tuple(ctx=Load()))],\n"
"            value=Subscript(\n"
"                value=Name(id='tuple', ctx=Load()),\n"
"                slice=Tuple(\n"
"                    elts=[\n"
"                        Starred(\n"
"                            value=Name(id='Ts', ctx=Load()),\n"
"                            ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))])"

#: ../../library/ast.rst:1865
msgid "Function and class definitions"
msgstr "Definições de função e classe"

#: ../../library/ast.rst:1869
msgid "A function definition."
msgstr "Uma definição de função"

#: ../../library/ast.rst:1871
msgid "``name`` is a raw string of the function name."
msgstr "``name`` é uma string bruta do nome da função."

#: ../../library/ast.rst:1872
msgid "``args`` is an :class:`arguments` node."
msgstr "``args`` é um nó :class:`arguments`."

#: ../../library/ast.rst:1873
msgid "``body`` is the list of nodes inside the function."
msgstr "``body`` é a lista de nós dentro da função."

#: ../../library/ast.rst:1874
msgid ""
"``decorator_list`` is the list of decorators to be applied, stored outermost "
"first (i.e. the first in the list will be applied last)."
msgstr ""
"``decorator_list`` é a lista de decoradores a serem aplicados, armazenados "
"primeiro na parte externa (ou seja, o primeiro da lista será aplicado por "
"último)."

#: ../../library/ast.rst:1876
msgid "``returns`` is the return annotation."
msgstr "``returns`` é a anotação de retorno."

#: ../../library/ast.rst:1877 ../../library/ast.rst:2040
msgid "``type_params`` is a list of :ref:`type parameters <ast-type-params>`."
msgstr ""
"``type_params`` é uma lista de :ref:`parâmetros de tipo <ast-type-params>`."

#: ../../library/ast.rst:1883 ../../library/ast.rst:2067
#: ../../library/ast.rst:2078
msgid "Added ``type_params``."
msgstr "Adicionado ``type_params``."

#: ../../library/ast.rst:1889
msgid ""
"``lambda`` is a minimal function definition that can be used inside an "
"expression. Unlike :class:`FunctionDef`, ``body`` holds a single node."
msgstr ""
"``lambda`` é uma definição mínima de função que pode ser usada dentro de uma "
"expressão. Ao contrário de :class:`FunctionDef`, ``body`` contém um único nó."

#: ../../library/ast.rst:1892
msgid ""
">>> print(ast.dump(ast.parse('lambda x,y: ...'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Lambda(\n"
"                args=arguments(\n"
"                    args=[\n"
"                        arg(arg='x'),\n"
"                        arg(arg='y')]),\n"
"                body=Constant(value=Ellipsis)))])"
msgstr ""
">>> print(ast.dump(ast.parse('lambda x,y: ...'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Lambda(\n"
"                args=arguments(\n"
"                    args=[\n"
"                        arg(arg='x'),\n"
"                        arg(arg='y')]),\n"
"                body=Constant(value=Ellipsis)))])"

#: ../../library/ast.rst:1908
msgid "The arguments for a function."
msgstr "Os argumentos para uma função."

#: ../../library/ast.rst:1910
msgid ""
"``posonlyargs``, ``args`` and ``kwonlyargs`` are lists of :class:`arg` nodes."
msgstr ""
"``posonlyargs``, ``args`` e ``kwonlyargs`` são listas de nós :class:`arg`."

#: ../../library/ast.rst:1911
msgid ""
"``vararg`` and ``kwarg`` are single :class:`arg` nodes, referring to the "
"``*args, **kwargs`` parameters."
msgstr ""
"``vararg`` e ``kwarg`` são nós :class:`arg` únicos, referindo-se aos "
"parâmetros ``*args, **kwargs``."

#: ../../library/ast.rst:1913
msgid ""
"``kw_defaults`` is a list of default values for keyword-only arguments. If "
"one is ``None``, the corresponding argument is required."
msgstr ""
"``kw_defaults`` é uma lista de valores padrão para argumentos somente-"
"nomeados. Se um for ``None``, o argumento correspondente é necessário."

#: ../../library/ast.rst:1915
msgid ""
"``defaults`` is a list of default values for arguments that can be passed "
"positionally. If there are fewer defaults, they correspond to the last n "
"arguments."
msgstr ""
"``defaults`` é uma lista de valores padrão para argumentos que podem ser "
"passados ​posicionalmente. Se houver menos padrões, eles corresponderão aos "
"últimos n argumentos."

#: ../../library/ast.rst:1922
msgid ""
"A single argument in a list. ``arg`` is a raw string of the argument name; "
"``annotation`` is its annotation, such as a :class:`Name` node."
msgstr ""
"Um único argumento em uma lista. ``arg`` é uma string bruta do nome do "
"argumento; ``annotation`` é sua anotação, como um nó :class:`Name`."

#: ../../library/ast.rst:1927
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment"
msgstr ""
"``type_comment`` é uma string opcional com a anotação de tipo como comentário"

#: ../../library/ast.rst:1929
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... @decorator1\n"
"... @decorator2\n"
"... def f(a: 'annotation', b=1, c=2, *d, e, f=3, **g) -> 'return "
"annotation':\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        FunctionDef(\n"
"            name='f',\n"
"            args=arguments(\n"
"                args=[\n"
"                    arg(\n"
"                        arg='a',\n"
"                        annotation=Constant(value='annotation')),\n"
"                    arg(arg='b'),\n"
"                    arg(arg='c')],\n"
"                vararg=arg(arg='d'),\n"
"                kwonlyargs=[\n"
"                    arg(arg='e'),\n"
"                    arg(arg='f')],\n"
"                kw_defaults=[\n"
"                    None,\n"
"                    Constant(value=3)],\n"
"                kwarg=arg(arg='g'),\n"
"                defaults=[\n"
"                    Constant(value=1),\n"
"                    Constant(value=2)]),\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Name(id='decorator1', ctx=Load()),\n"
"                Name(id='decorator2', ctx=Load())],\n"
"            returns=Constant(value='return annotation'))])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... @decorator1\n"
"... @decorator2\n"
"... def f(a: 'annotation', b=1, c=2, *d, e, f=3, **g) -> 'return "
"annotation':\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        FunctionDef(\n"
"            name='f',\n"
"            args=arguments(\n"
"                args=[\n"
"                    arg(\n"
"                        arg='a',\n"
"                        annotation=Constant(value='annotation')),\n"
"                    arg(arg='b'),\n"
"                    arg(arg='c')],\n"
"                vararg=arg(arg='d'),\n"
"                kwonlyargs=[\n"
"                    arg(arg='e'),\n"
"                    arg(arg='f')],\n"
"                kw_defaults=[\n"
"                    None,\n"
"                    Constant(value=3)],\n"
"                kwarg=arg(arg='g'),\n"
"                defaults=[\n"
"                    Constant(value=1),\n"
"                    Constant(value=2)]),\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Name(id='decorator1', ctx=Load()),\n"
"                Name(id='decorator2', ctx=Load())],\n"
"            returns=Constant(value='return annotation'))])"

#: ../../library/ast.rst:1969
msgid "A ``return`` statement."
msgstr "Uma instrução ``return``."

#: ../../library/ast.rst:1971
msgid ""
">>> print(ast.dump(ast.parse('return 4'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Return(\n"
"            value=Constant(value=4))])"
msgstr ""
">>> print(ast.dump(ast.parse('return 4'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Return(\n"
"            value=Constant(value=4))])"

#: ../../library/ast.rst:1983
msgid ""
"A ``yield`` or ``yield from`` expression. Because these are expressions, "
"they must be wrapped in an :class:`Expr` node if the value sent back is not "
"used."
msgstr ""
"Uma expressão ``yield`` ou ``yield from``. Por serem expressões, elas devem "
"ser agrupadas em um nó :class:`Expr` se o valor enviado de volta não for "
"usado."

#: ../../library/ast.rst:1986
msgid ""
">>> print(ast.dump(ast.parse('yield x'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Yield(\n"
"                value=Name(id='x', ctx=Load())))])\n"
"\n"
">>> print(ast.dump(ast.parse('yield from x'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=YieldFrom(\n"
"                value=Name(id='x', ctx=Load())))])"
msgstr ""
">>> print(ast.dump(ast.parse('yield x'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Yield(\n"
"                value=Name(id='x', ctx=Load())))])\n"
"\n"
">>> print(ast.dump(ast.parse('yield from x'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=YieldFrom(\n"
"                value=Name(id='x', ctx=Load())))])"

#: ../../library/ast.rst:2006
msgid ""
"``global`` and ``nonlocal`` statements. ``names`` is a list of raw strings."
msgstr ""
"Instruções ``global`` e ``nonlocal``. ``names`` é uma lista de strings "
"brutas."

#: ../../library/ast.rst:2008
msgid ""
">>> print(ast.dump(ast.parse('global x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Global(\n"
"            names=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])])\n"
"\n"
">>> print(ast.dump(ast.parse('nonlocal x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Nonlocal(\n"
"            names=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])])"
msgstr ""
">>> print(ast.dump(ast.parse('global x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Global(\n"
"            names=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])])\n"
"\n"
">>> print(ast.dump(ast.parse('nonlocal x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Nonlocal(\n"
"            names=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])])"

#: ../../library/ast.rst:2031
msgid "A class definition."
msgstr "Uma definição de classe"

#: ../../library/ast.rst:2033
msgid "``name`` is a raw string for the class name"
msgstr "``name`` é uma string bruta para o nome da classe"

#: ../../library/ast.rst:2034
msgid "``bases`` is a list of nodes for explicitly specified base classes."
msgstr ""
"``bases`` é uma lista de nós para classes base especificadas explicitamente."

#: ../../library/ast.rst:2035
msgid ""
"``keywords`` is a list of :class:`.keyword` nodes, principally for "
"'metaclass'. Other keywords will be passed to the metaclass, as per :pep:"
"`3115`."
msgstr ""
"``keywords`` é uma lista de nós :class:`.keyword`, principalmente para "
"'metaclass'. Outras argumentos nomeados serão passadas para a metaclasse, "
"conforme a :pep:`3115`."

#: ../../library/ast.rst:2037
msgid ""
"``body`` is a list of nodes representing the code within the class "
"definition."
msgstr ""
"``body`` é uma lista de nós que representam o código dentro da definição de "
"classe."

#: ../../library/ast.rst:2039
msgid "``decorator_list`` is a list of nodes, as in :class:`FunctionDef`."
msgstr "``decorator_list`` é uma lista de nós, como em :class:`FunctionDef`."

#: ../../library/ast.rst:2042
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... @decorator1\n"
"... @decorator2\n"
"... class Foo(base1, base2, metaclass=meta):\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ClassDef(\n"
"            name='Foo',\n"
"            bases=[\n"
"                Name(id='base1', ctx=Load()),\n"
"                Name(id='base2', ctx=Load())],\n"
"            keywords=[\n"
"                keyword(\n"
"                    arg='metaclass',\n"
"                    value=Name(id='meta', ctx=Load()))],\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Name(id='decorator1', ctx=Load()),\n"
"                Name(id='decorator2', ctx=Load())])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... @decorator1\n"
"... @decorator2\n"
"... class Foo(base1, base2, metaclass=meta):\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ClassDef(\n"
"            name='Foo',\n"
"            bases=[\n"
"                Name(id='base1', ctx=Load()),\n"
"                Name(id='base2', ctx=Load())],\n"
"            keywords=[\n"
"                keyword(\n"
"                    arg='metaclass',\n"
"                    value=Name(id='meta', ctx=Load()))],\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Name(id='decorator1', ctx=Load()),\n"
"                Name(id='decorator2', ctx=Load())])])"

#: ../../library/ast.rst:2071
msgid "Async and await"
msgstr "Async e await"

#: ../../library/ast.rst:2075
msgid ""
"An ``async def`` function definition. Has the same fields as :class:"
"`FunctionDef`."
msgstr ""
"Uma definição de função ``async def``. Possui os mesmos campos que :class:"
"`FunctionDef`."

#: ../../library/ast.rst:2084
msgid ""
"An ``await`` expression. ``value`` is what it waits for. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"Uma expressão ``await``. ``value`` é o que ela espera. Válido apenas no "
"corpo de um :class:`AsyncFunctionDef`."

#: ../../library/ast.rst:2087
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... async def f():\n"
"...     await other_func()\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AsyncFunctionDef(\n"
"            name='f',\n"
"            args=arguments(),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Await(\n"
"                        value=Call(\n"
"                            func=Name(id='other_func', ctx=Load()))))])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... async def f():\n"
"...     await other_func()\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AsyncFunctionDef(\n"
"            name='f',\n"
"            args=arguments(),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Await(\n"
"                        value=Call(\n"
"                            func=Name(id='other_func', ctx=Load()))))])])"

#: ../../library/ast.rst:2108
msgid ""
"``async for`` loops and ``async with`` context managers. They have the same "
"fields as :class:`For` and :class:`With`, respectively. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"Laços ``async for`` e gerenciadores de contexto ``async with``. Eles têm os "
"mesmos campos que :class:`For` e :class:`With`, respectivamente. Válido "
"apenas no corpo de :class:`AsyncFunctionDef`."

#: ../../library/ast.rst:2113
msgid ""
"When a string is parsed by :func:`ast.parse`, operator nodes (subclasses of :"
"class:`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, :class:`ast."
"boolop` and :class:`ast.expr_context`) on the returned tree will be "
"singletons. Changes to one will be reflected in all other occurrences of the "
"same value (e.g. :class:`ast.Add`)."
msgstr ""
"Quando uma string é analisada por :func:`ast.parse`, os nós operadores "
"(subclasses de :class:`ast.operator`, :class:`ast.unaryop`, :class:`ast."
"cmpop`, :class:`ast.boolop` e :class:`ast.expr_context`) na árvore retornada "
"serão singletons. As alterações em um serão refletidas em todas as outras "
"ocorrências do mesmo valor (por exemplo, :class:`ast.Add`)."

#: ../../library/ast.rst:2121
msgid ":mod:`ast` Helpers"
msgstr "Auxiliares de :mod:`ast`"

#: ../../library/ast.rst:2123
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr ""
"Além das classes de nós, o módulo :mod:`ast` define essas funções e classes "
"utilitárias para percorrer árvores de sintaxe abstrata:"

#: ../../library/ast.rst:2128
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, flags=FLAGS_VALUE, optimize=optimize)``, where "
"``FLAGS_VALUE`` is ``ast.PyCF_ONLY_AST`` if ``optimize <= 0`` and ``ast."
"PyCF_OPTIMIZED_AST`` otherwise."
msgstr ""
"Analisa a fonte como um nó AST. Equivalente a ``compile(source, filename, "
"mode, flags=FLAGS_VALUE, optimize=optimize)``, onde ``FLAGS_VALUE`` é ``ast."
"PyCF_ONLY_AST`` se ``optimize <= 0`` e ``ast.PyCF_OPTIMIZED_AST`` caso "
"contrário."

#: ../../library/ast.rst:2133
msgid ""
"If ``type_comments=True`` is given, the parser is modified to check and "
"return type comments as specified by :pep:`484` and :pep:`526`. This is "
"equivalent to adding :data:`ast.PyCF_TYPE_COMMENTS` to the flags passed to :"
"func:`compile`.  This will report syntax errors for misplaced type "
"comments.  Without this flag, type comments will be ignored, and the "
"``type_comment`` field on selected AST nodes will always be ``None``.  In "
"addition, the locations of ``# type: ignore`` comments will be returned as "
"the ``type_ignores`` attribute of :class:`Module` (otherwise it is always an "
"empty list)."
msgstr ""
"Se ``type_comments=True`` é fornecido, o analisador é modificado para "
"verificar e retornar comentários do tipo, conforme especificado por :pep:"
"`484` e :pep:`526`. Isso é equivalente a adicionar :data:`ast."
"PyCF_TYPE_COMMENTS` aos sinalizadores passados para :func:`compile`. Isso "
"relatará erros de sintaxe para comentários do tipo extraviado. Sem esse "
"sinalizador, os comentários do tipo serão ignorados e o campo "
"``type_comment`` nos nós AST selecionados sempre será ``None``. Além disso, "
"os locais dos comentários ``# type: ignore`` serão retornados como o "
"atributo ``type_ignores`` de :class:`Module` (caso contrário, é sempre uma "
"lista vazia)."

#: ../../library/ast.rst:2143
msgid ""
"In addition, if ``mode`` is ``'func_type'``, the input syntax is modified to "
"correspond to :pep:`484` \"signature type comments\", e.g. ``(str, int) -> "
"List[str]``."
msgstr ""
"Além disso, se ``mode`` for ``'func_type'``, a sintaxe de entrada é "
"modificada para corresponder a \"comentários de tipo de assinatura\" de :pep:"
"`484`, por exemplo, ``(str, int) -> List[str]``."

#: ../../library/ast.rst:2147
msgid ""
"Setting ``feature_version`` to a tuple ``(major, minor)`` will result in a "
"\"best-effort\" attempt to parse using that Python version's grammar. For "
"example, setting ``feature_version=(3, 9)`` will attempt to disallow parsing "
"of :keyword:`match` statements. Currently ``major`` must equal to ``3``. The "
"lowest supported version is ``(3, 7)`` (and this may increase in future "
"Python versions); the highest is ``sys.version_info[0:2]``. \"Best-effort\" "
"attempt means there is no guarantee that the parse (or success of the parse) "
"is the same as when run on the Python version corresponding to "
"``feature_version``."
msgstr ""
"Definir ``feature_version`` como uma tupla ``(major, minor)`` resultará em "
"uma tentativa de \"melhor esforço\" de análise usando a gramática daquela "
"versão do Python. Por exemplo, definir ``feature_version=(3, 9)`` tentará "
"proibir a análise de instruções :keyword:`match`. Atualmente ``major`` deve "
"ser igual a ``3``. A versão mais baixa suportada é ``(3, 7)`` (e isso pode "
"aumentar em versões futuras do Python); o mais alto é ``sys."
"version_info[0:2]``. A tentativa de \"melhor esforço\" significa que não há "
"garantia de que a análise (ou sucesso da análise) seja a mesma que quando "
"executada na versão Python correspondente a ``feature_version``."

#: ../../library/ast.rst:2157
msgid ""
"If source contains a null character (``\\0``), :exc:`ValueError` is raised."
msgstr ""
"Se a fonte contém um caractere nulo (``\\0``), :exc:`ValueError` é levantada."

#: ../../library/ast.rst:2160
msgid ""
"Note that successfully parsing source code into an AST object doesn't "
"guarantee that the source code provided is valid Python code that can be "
"executed as the compilation step can raise further :exc:`SyntaxError` "
"exceptions. For instance, the source ``return 42`` generates a valid AST "
"node for a return statement, but it cannot be compiled alone (it needs to be "
"inside a function node)."
msgstr ""
"Observe que a análise bem-sucedida do código-fonte em um objeto AST não "
"garante que o código-fonte fornecido seja um código Python válido que pode "
"ser executado, pois a etapa de compilação pode levantar mais exceções :exc:"
"`SyntaxError`. Por exemplo, a fonte ``return 42`` gera um nó AST válido para "
"uma instrução return, mas não pode ser compilado sozinho (precisa estar "
"dentro de um nó de função)."

#: ../../library/ast.rst:2167
msgid ""
"In particular, :func:`ast.parse` won't do any scoping checks, which the "
"compilation step does."
msgstr ""
"Em particular, :func:`ast.parse` não fará nenhuma verificação de escopo, o "
"que a etapa de compilação faz."

#: ../../library/ast.rst:2171
msgid ""
"It is possible to crash the Python interpreter with a sufficiently large/"
"complex string due to stack depth limitations in Python's AST compiler."
msgstr ""
"É possível travar o interpretador Python com uma string suficientemente "
"grande/complexa devido às limitações de profundidade da pilha no compilador "
"de AST do Python."

#: ../../library/ast.rst:2175
msgid "Added ``type_comments``, ``mode='func_type'`` and ``feature_version``."
msgstr ""
"Adicionado ``type_comments``, ``mode='func_type'`` e ``feature_version``."

#: ../../library/ast.rst:2178
msgid ""
"The minimum supported version for ``feature_version`` is now ``(3, 7)``. The "
"``optimize`` argument was added."
msgstr ""
"A versão mínima suportada para ``feature_version`` agora é ``(3, 7)``. O "
"argumento ``optimize`` foi adicionado."

#: ../../library/ast.rst:2185
msgid ""
"Unparse an :class:`ast.AST` object and generate a string with code that "
"would produce an equivalent :class:`ast.AST` object if parsed back with :"
"func:`ast.parse`."
msgstr ""
"Desfaz análise de um objeto :class:`ast.AST` e gera uma string com código "
"que produziria um objeto :class:`ast.AST` equivalente se analisado novamente "
"com :func:`ast.parse`."

#: ../../library/ast.rst:2190
msgid ""
"The produced code string will not necessarily be equal to the original code "
"that generated the :class:`ast.AST` object (without any compiler "
"optimizations, such as constant tuples/frozensets)."
msgstr ""
"A string de código produzida não será necessariamente igual ao código "
"original que gerou o objeto :class:`ast.AST` (sem quaisquer otimizações do "
"compilador, como tuplas/frozensets constantes)."

#: ../../library/ast.rst:2195
msgid ""
"Trying to unparse a highly complex expression would result with :exc:"
"`RecursionError`."
msgstr ""
"Tentar desfazer análise de uma expressão altamente complexa resultaria em :"
"exc:`RecursionError`."

#: ../../library/ast.rst:2203
msgid ""
"Evaluate an expression node or a string containing only a Python literal or "
"container display.  The string or node provided may only consist of the "
"following Python literal structures: strings, bytes, numbers, tuples, lists, "
"dicts, sets, booleans, ``None`` and ``Ellipsis``."
msgstr ""
"Avalia um nó de expressão ou uma string contendo apenas um literal Python ou "
"uma exibição de contêiner. A string ou nó fornecido pode consistir apenas "
"nas seguintes estruturas literais Python: strings, bytes, números, tuplas, "
"listas, dicionários, conjuntos, booleanos, ``None`` e ``Ellipsis``."

#: ../../library/ast.rst:2208
msgid ""
"This can be used for evaluating strings containing Python values without the "
"need to parse the values oneself.  It is not capable of evaluating "
"arbitrarily complex expressions, for example involving operators or indexing."
msgstr ""
"Isso pode ser usado para avaliar strings contendo valores Python sem a "
"necessidade de analisar os valores por conta própria. Não é capaz de avaliar "
"expressões arbitrariamente complexas, por exemplo, envolvendo operadores ou "
"indexação."

#: ../../library/ast.rst:2213
msgid ""
"This function had been documented as \"safe\" in the past without defining "
"what that meant. That was misleading. This is specifically designed not to "
"execute Python code, unlike the more general :func:`eval`. There is no "
"namespace, no name lookups, or ability to call out. But it is not free from "
"attack: A relatively small input can lead to memory exhaustion or to C stack "
"exhaustion, crashing the process. There is also the possibility for "
"excessive CPU consumption denial of service on some inputs. Calling it on "
"untrusted data is thus not recommended."
msgstr ""
"Esta função foi documentada como “segura” no passado sem definir o que isso "
"significava. Isso foi enganoso. Isso foi projetado especificamente para não "
"executar código Python, ao contrário do :func:`eval` mais geral. Não há "
"espaço de nomes, pesquisas de nome ou capacidade de chamada. Mas não está "
"livre de ataques: uma entrada relativamente pequena pode levar ao "
"esgotamento da memória ou ao esgotamento da pilha C, travando o processo. "
"Também existe a possibilidade de negação de serviço por consumo excessivo de "
"CPU em algumas entradas. Portanto, não é recomendado chamá-la em dados não "
"confiáveis."

#: ../../library/ast.rst:2223
msgid ""
"It is possible to crash the Python interpreter due to stack depth "
"limitations in Python's AST compiler."
msgstr ""
"É possível travar o interpretador Python devido às limitações de "
"profundidade da pilha no compilador AST do Python."

#: ../../library/ast.rst:2226
msgid ""
"It can raise :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, :exc:"
"`MemoryError` and :exc:`RecursionError` depending on the malformed input."
msgstr ""
"Pode levantar :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, :exc:"
"`MemoryError` e :exc:`RecursionError` dependendo da entrada malformada."

#: ../../library/ast.rst:2230
msgid "Now allows bytes and set literals."
msgstr "Agora permite bytes e literais de conjuntos."

#: ../../library/ast.rst:2233
msgid "Now supports creating empty sets with ``'set()'``."
msgstr "Agora oferece suporte à criação de conjuntos vazios com ``'set()'``."

#: ../../library/ast.rst:2236
msgid "For string inputs, leading spaces and tabs are now stripped."
msgstr ""
"Para entradas de string, os espaços iniciais e tabulações agora são "
"removidos."

#: ../../library/ast.rst:2242
msgid ""
"Return the docstring of the given *node* (which must be a :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or :class:"
"`Module` node), or ``None`` if it has no docstring. If *clean* is true, "
"clean up the docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""
"Retorna a docstring do *node* dado (que deve ser um nó :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef` ou :class:"
"`Module`) ou ``None`` se não tiver uma docstring. Se *clean* for verdadeiro, "
"limpa o recuo da docstring com :func:`inspect.cleandoc`."

#: ../../library/ast.rst:2248
msgid ":class:`AsyncFunctionDef` is now supported."
msgstr "Não há suporte a :class:`AsyncFunctionDef`."

#: ../../library/ast.rst:2254
msgid ""
"Get source code segment of the *source* that generated *node*. If some "
"location information (:attr:`~ast.AST.lineno`, :attr:`~ast.AST.end_lineno`, :"
"attr:`~ast.AST.col_offset`, or :attr:`~ast.AST.end_col_offset`) is missing, "
"return ``None``."
msgstr ""
"Obtém o segmento de código-fonte do *source* que gerou o *node*. Se alguma "
"informação de localização (:attr:`~ast.AST.lineno`, :attr:`~ast.AST."
"end_lineno`, :attr:`~ast.AST.col_offset` ou :attr:`~ast.AST.end_col_offset`) "
"está faltando, retorna ``None``."

#: ../../library/ast.rst:2258
msgid ""
"If *padded* is ``True``, the first line of a multi-line statement will be "
"padded with spaces to match its original position."
msgstr ""
"Se *padded* for ``True``, a primeira linha de uma instrução multilinha será "
"preenchida com espaços para corresponder à sua posição original."

#: ../../library/ast.rst:2266
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects :"
"attr:`~ast.AST.lineno` and :attr:`~ast.AST.col_offset` attributes for every "
"node that supports them.  This is rather tedious to fill in for generated "
"nodes, so this helper adds these attributes recursively where not already "
"set, by setting them to the values of the parent node.  It works recursively "
"starting at *node*."
msgstr ""
"Quando você compila uma árvore de nós com :func:`compile`, o compilador "
"espera atributos :attr:`~ast.AST.lineno` e :attr:`~ast.AST.col_offset` para "
"cada nó que os suporta. Isso é tedioso para preencher nós gerados, portanto, "
"esse auxiliar adiciona esses atributos recursivamente, onde ainda não estão "
"definidos, definindo-os para os valores do nó pai. Ele funciona "
"recursivamente a partir do *node*."

#: ../../library/ast.rst:2275
msgid ""
"Increment the line number and end line number of each node in the tree "
"starting at *node* by *n*. This is useful to \"move code\" to a different "
"location in a file."
msgstr ""
"Incrementa o número da linhas e o número da linha final de cada nó na árvore "
"começando em *node* em *n*. Isso é útil para \"mover código\" para um local "
"diferente em um arquivo."

#: ../../library/ast.rst:2282
msgid ""
"Copy source location (:attr:`~ast.AST.lineno`, :attr:`~ast.AST.col_offset`, :"
"attr:`~ast.AST.end_lineno`, and :attr:`~ast.AST.end_col_offset`) from "
"*old_node* to *new_node* if possible, and return *new_node*."
msgstr ""
"Copia o local de origem (:attr:`~ast.AST.lineno`, :attr:`~ast.AST."
"col_offset`, :attr:`~ast.AST.end_lineno` e :attr:`~ast.AST.end_col_offset`) "
"de *old_node* para *new_node* se possível e, então, retorna *new_node*."

#: ../../library/ast.rst:2289
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` "
"that is present on *node*."
msgstr ""
"Produz uma tupla de ``(fieldname, value)`` para cada campo em ``node."
"_fields`` que esteja presente em *node*."

#: ../../library/ast.rst:2295
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are nodes "
"and all items of fields that are lists of nodes."
msgstr ""
"Produz todos os nós filhos diretos de *node*, ou seja, todos os campos que "
"são nós e todos os itens de campos que são listas de nós."

#: ../../library/ast.rst:2301
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""
"Produz recursivamente todos os nós descendentes na árvore começando em "
"*node* (incluindo o próprio *node*), em nenhuma ordem especificada. Isso é "
"útil se você quiser apenas modificar nós no lugar e não se importar com o "
"contexto."

#: ../../library/ast.rst:2308
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a "
"visitor function for every node found.  This function may return a value "
"which is forwarded by the :meth:`visit` method."
msgstr ""
"Uma classe base de visitante de nó que percorre a árvore de sintaxe abstrata "
"e chama uma função de visitante para cada nó encontrado. Esta função pode "
"retornar um valor que é encaminhado pelo método :meth:`visit`."

#: ../../library/ast.rst:2312
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr ""
"Esta classe deve ser uma subclasse, com a subclasse adicionando métodos "
"visitantes."

#: ../../library/ast.rst:2317
msgid ""
"Visit a node.  The default implementation calls the method called :samp:"
"`self.visit_{classname}` where *classname* is the name of the node class, "
"or :meth:`generic_visit` if that method doesn't exist."
msgstr ""
"Visita um nó. A implementação padrão chama o método chamado :samp:`self."
"visit_{nomedaclasse}` sendo *nomedaclasse* o nome da classe do nó, ou :meth:"
"`generic_visit` se aquele método não existir."

#: ../../library/ast.rst:2323
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr "Este visitante chama :meth:`visit` em todos os filhos do nó."

#: ../../library/ast.rst:2325
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be "
"visited unless the visitor calls :meth:`generic_visit` or visits them itself."
msgstr ""
"Observe que nós filhos de nós que possuem um método de visitante "
"personalizado não serão visitados, a menos que o visitante chame :meth:"
"`generic_visit` ou os visite por conta própria."

#: ../../library/ast.rst:2331
msgid "Handles all constant nodes."
msgstr "Manipula todos os nós constantes."

#: ../../library/ast.rst:2333
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists (:class:"
"`NodeTransformer`) that allows modifications."
msgstr ""
"Não use o :class:`NodeVisitor` se você quiser aplicar mudanças nos nós "
"durante a travessia. Para isso existe um visitante especial (:class:"
"`NodeTransformer`) que permite modificações."

#: ../../library/ast.rst:2339
msgid ""
"Methods :meth:`!visit_Num`, :meth:`!visit_Str`, :meth:`!visit_Bytes`, :meth:"
"`!visit_NameConstant` and :meth:`!visit_Ellipsis` are deprecated now and "
"will not be called in future Python versions.  Add the :meth:"
"`visit_Constant` method to handle all constant nodes."
msgstr ""
"Os métodos :meth:`!visit_Num`, :meth:`!visit_Str`, :meth:`!visit_Bytes`, :"
"meth:`!visit_NameConstant` e :meth:`!visit_Ellipsis` estão agora "
"descontinuados e não serão chamados em futuras versões do Python. Adicione "
"um método :meth:`visit_Constant` para lidar com nós de constantes."

#: ../../library/ast.rst:2347
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr ""
"A subclasse :class:`NodeVisitor` que percorre a árvore de sintaxe abstrata e "
"permite a modificação de nós."

#: ../../library/ast.rst:2350
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value of "
"the visitor methods to replace or remove the old node.  If the return value "
"of the visitor method is ``None``, the node will be removed from its "
"location, otherwise it is replaced with the return value.  The return value "
"may be the original node in which case no replacement takes place."
msgstr ""
"O :class:`NodeTransformer` percorrerá a AST e usará o valor de retorno dos "
"métodos do visitante para substituir ou remover o nó antigo. Se o valor de "
"retorno do método visitante for ``None``, o nó será removido de seu local, "
"caso contrário, ele será substituído pelo valor de retorno. O valor de "
"retorno pode ser o nó original, caso em que não há substituição."

#: ../../library/ast.rst:2356
msgid ""
"Here is an example transformer that rewrites all occurrences of name lookups "
"(``foo``) to ``data['foo']``::"
msgstr ""
"Aqui está um exemplo de transformador que rescreve todas as ocorrências de "
"procuras por nome (``foo``) para ``data['foo']``::"

#: ../../library/ast.rst:2359
msgid ""
"class RewriteName(NodeTransformer):\n"
"\n"
"    def visit_Name(self, node):\n"
"        return Subscript(\n"
"            value=Name(id='data', ctx=Load()),\n"
"            slice=Constant(value=node.id),\n"
"            ctx=node.ctx\n"
"        )"
msgstr ""
"class RewriteName(NodeTransformer):\n"
"\n"
"    def visit_Name(self, node):\n"
"        return Subscript(\n"
"            value=Name(id='data', ctx=Load()),\n"
"            slice=Constant(value=node.id),\n"
"            ctx=node.ctx\n"
"        )"

#: ../../library/ast.rst:2368
msgid ""
"Keep in mind that if the node you're operating on has child nodes you must "
"either transform the child nodes yourself or call the :meth:`~ast."
"NodeVisitor.generic_visit` method for the node first."
msgstr ""
"Tenha em mente que, se o nó em que você está operando tiver nós filhos, você "
"deve transformar os nós filhos por conta própria ou chamar o método :meth:"
"`~ast.NodeVisitor.generic_visit` para o nó primeiro."

#: ../../library/ast.rst:2372
msgid ""
"For nodes that were part of a collection of statements (that applies to all "
"statement nodes), the visitor may also return a list of nodes rather than "
"just a single node."
msgstr ""
"Para nós que faziam parte de uma coleção de instruções (que se aplica a "
"todos os nós de instrução), o visitante também pode retornar uma lista de "
"nós em vez de apenas um único nó."

#: ../../library/ast.rst:2376
msgid ""
"If :class:`NodeTransformer` introduces new nodes (that weren't part of "
"original tree) without giving them location information (such as :attr:`~ast."
"AST.lineno`), :func:`fix_missing_locations` should be called with the new "
"sub-tree to recalculate the location information::"
msgstr ""
"Se :class:`NodeTransformer` introduz novos nós (que não faziam parte da "
"árvore original) sem fornecer informações de localização (como :attr:`~ast."
"AST.lineno`), :func:`fix_missing_locations` deve ser chamado com o novo "
"subárvore para recalcular as informações de localização::"

#: ../../library/ast.rst:2381
msgid ""
"tree = ast.parse('foo', mode='eval')\n"
"new_tree = fix_missing_locations(RewriteName().visit(tree))"
msgstr ""
"tree = ast.parse('foo', mode='eval')\n"
"new_tree = fix_missing_locations(RewriteName().visit(tree))"

#: ../../library/ast.rst:2384
msgid "Usually you use the transformer like this::"
msgstr "Normalmente você usa o transformador assim::"

#: ../../library/ast.rst:2386
msgid "node = YourTransformer().visit(node)"
msgstr "node = YourTransformer().visit(node)"

#: ../../library/ast.rst:2391
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for "
"debugging purposes.  If *annotate_fields* is true (by default), the returned "
"string will show the names and the values for fields. If *annotate_fields* "
"is false, the result string will be more compact by omitting unambiguous "
"field names.  Attributes such as line numbers and column offsets are not "
"dumped by default.  If this is wanted, *include_attributes* can be set to "
"true."
msgstr ""
"Retorne um despejo formatado da árvore em *node*. Isso é útil principalmente "
"para fins de depuração. Se *annotate_fields* for verdadeiro (por padrão), a "
"sequência retornada mostrará os nomes e os valores para os campos. Se "
"*annotate_fields* for falso, a sequência de resultados será mais compacta ao "
"omitir nomes de campos não ambíguos. Atributos como números de linha e "
"deslocamentos de coluna não são despejados por padrão. Se isso for desejado, "
"*include_attributes* pode ser definido como verdadeiro."

#: ../../library/ast.rst:2399
msgid ""
"If *indent* is a non-negative integer or string, then the tree will be "
"pretty-printed with that indent level.  An indent level of 0, negative, or "
"``\"\"`` will only insert newlines.  ``None`` (the default) selects the "
"single line representation. Using a positive integer indent indents that "
"many spaces per level.  If *indent* is a string (such as ``\"\\t\"``), that "
"string is used to indent each level."
msgstr ""
"Se *indent* for um inteiro não negativo ou uma string, então a árvore terá "
"uma saída formatada com este nível de indentação. Um nível de indentação 0, "
"negativo ou ``\"\"`` apenas colocará novas linhas. ``None`` (o padrão) "
"seleciona a representação de uma única linha. Usando um inteiro positivo a "
"indentação terá alguns espaços por nível. Se *indent* for uma string (como "
"``\"\\t\"``), essa string será usada para indentar cada nível."

#: ../../library/ast.rst:2406
msgid ""
"If *show_empty* is ``False`` (the default), empty lists and fields that are "
"``None`` will be omitted from the output."
msgstr ""
"Se *show_empty* for ``False`` (o padrão), listas vazias e campos que forem "
"``None`` serão omitidos da saída."

#: ../../library/ast.rst:2409
msgid "Added the *indent* option."
msgstr "Adicionada a opção *indent*."

#: ../../library/ast.rst:2412
msgid "Added the *show_empty* option."
msgstr "Adicionada a opção *show_empty*."

#: ../../library/ast.rst:2415
msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... async def f():\n"
"...     await other_func()\n"
"... \"\"\"), indent=4, show_empty=True))\n"
"Module(\n"
"    body=[\n"
"        AsyncFunctionDef(\n"
"            name='f',\n"
"            args=arguments(\n"
"                posonlyargs=[],\n"
"                args=[],\n"
"                kwonlyargs=[],\n"
"                kw_defaults=[],\n"
"                defaults=[]),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Await(\n"
"                        value=Call(\n"
"                            func=Name(id='other_func', ctx=Load()),\n"
"                            args=[],\n"
"                            keywords=[])))],\n"
"            decorator_list=[],\n"
"            type_params=[])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... async def f():\n"
"...     await other_func()\n"
"... \"\"\"), indent=4, show_empty=True))\n"
"Module(\n"
"    body=[\n"
"        AsyncFunctionDef(\n"
"            name='f',\n"
"            args=arguments(\n"
"                posonlyargs=[],\n"
"                args=[],\n"
"                kwonlyargs=[],\n"
"                kw_defaults=[],\n"
"                defaults=[]),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Await(\n"
"                        value=Call(\n"
"                            func=Name(id='other_func', ctx=Load()),\n"
"                            args=[],\n"
"                            keywords=[])))],\n"
"            decorator_list=[],\n"
"            type_params=[])],\n"
"    type_ignores=[])"

#: ../../library/ast.rst:2446
msgid "Compiler Flags"
msgstr "Sinalizadores do compilador"

#: ../../library/ast.rst:2448
msgid ""
"The following flags may be passed to :func:`compile` in order to change "
"effects on the compilation of a program:"
msgstr ""
"Os seguintes sinalizadores podem ser passados para :func:`compile` para "
"alterar os efeitos na compilação de um programa:"

#: ../../library/ast.rst:2453
msgid ""
"Enables support for top-level ``await``, ``async for``, ``async with`` and "
"async comprehensions."
msgstr ""
"Habilita suporte para ``await``, ``async for``, ``async with`` e "
"compreensões assíncronas de nível superior."

#: ../../library/ast.rst:2460
msgid ""
"Generates and returns an abstract syntax tree instead of returning a "
"compiled code object."
msgstr ""
"Gera e retorna uma árvore de sintaxe abstrata em vez de retornar um objeto "
"de código compilado."

#: ../../library/ast.rst:2465
msgid ""
"The returned AST is optimized according to the *optimize* argument in :func:"
"`compile` or :func:`ast.parse`."
msgstr ""
"O AST retornado é otimizado de acordo com o argumento *optimize* em :func:"
"`compile` ou :func:`ast.parse`."

#: ../../library/ast.rst:2472
msgid ""
"Enables support for :pep:`484` and :pep:`526` style type comments (``# type: "
"<type>``, ``# type: ignore <stuff>``)."
msgstr ""
"Habilita suporte para comentários do tipo :pep:`484` e :pep:`526` (``# type: "
"<type>``, ``# type: ignore <stuff>``)."

#: ../../library/ast.rst:2481
msgid "Command-Line Usage"
msgstr "Uso na linha de comando"

#: ../../library/ast.rst:2485
msgid ""
"The :mod:`ast` module can be executed as a script from the command line. It "
"is as simple as:"
msgstr ""
"O módulo :mod:`ast` pode ser executado como um script na linha de comando. É "
"tão simples quanto:"

#: ../../library/ast.rst:2488
msgid "python -m ast [-m <mode>] [-a] [infile]"
msgstr "python -m ast [-m <mode>] [-a] [infile]"

#: ../../library/ast.rst:2492
msgid "The following options are accepted:"
msgstr "As seguintes opções são aceitas:"

#: ../../library/ast.rst:2498
msgid "Show the help message and exit."
msgstr "Mostra a mensagem de ajuda e sai."

#: ../../library/ast.rst:2503
msgid ""
"Specify what kind of code must be compiled, like the *mode* argument in :"
"func:`parse`."
msgstr ""
"Especifica que tipo de código deve ser compilado, como o argumento *mode* "
"em :func:`parse`."

#: ../../library/ast.rst:2508
msgid "Don't parse type comments."
msgstr "Não analisa comentários de tipo."

#: ../../library/ast.rst:2512
msgid "Include attributes such as line numbers and column offsets."
msgstr "Inclui atributos como números de linha e deslocamentos de colunas."

#: ../../library/ast.rst:2517
msgid "Indentation of nodes in AST (number of spaces)."
msgstr "indentação de nós em AST (número de espaços)."

#: ../../library/ast.rst:2519
msgid ""
"If :file:`infile` is specified its contents are parsed to AST and dumped to "
"stdout.  Otherwise, the content is read from stdin."
msgstr ""
"Se :file:`infile` for especificado, seu conteúdo será analisado no AST e "
"despejado no stdout. Caso contrário, o conteúdo será lido em stdin."

#: ../../library/ast.rst:2525
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, an external "
"documentation resource, has good details on working with Python ASTs."
msgstr ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, um recurso "
"de documentação externo, possui bons detalhes sobre trabalhar com ASTs do "
"Python."

#: ../../library/ast.rst:2528
msgid ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"annotates Python ASTs with the positions of tokens and text in the source "
"code that generated them. This is helpful for tools that make source code "
"transformations."
msgstr ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"anota ASTs do Python com as posições de tokens e texto no código-fonte que "
"as gerou. Isso é útil para ferramentas que fazem transformações de código-"
"fonte."

#: ../../library/ast.rst:2533
msgid ""
"`leoAst.py <https://leo-editor.github.io/leo-editor/appendices.html#leoast-"
"py>`_ unifies the token-based and parse-tree-based views of python programs "
"by inserting two-way links between tokens and ast nodes."
msgstr ""
"`leoAst.py <https://leo-editor.github.io/leo-editor/appendices.html#leoast-"
"py>`_ unifica as visualizações baseadas em token e em árvore de análise de "
"programas python, inserindo links duas vias entre tokens e nós de ast."

#: ../../library/ast.rst:2538
msgid ""
"`LibCST <https://libcst.readthedocs.io/>`_ parses code as a Concrete Syntax "
"Tree that looks like an ast tree and keeps all formatting details. It's "
"useful for building automated refactoring (codemod) applications and linters."
msgstr ""
"`LibCST <https://libcst.readthedocs.io/>`_ analisa o código como uma árvore "
"de sintaxe concreta que se parece com uma árvore ast e mantém todos os "
"detalhes de formatação. É útil para construir linters e aplicações de "
"refatoração automatizada (codemod)."

#: ../../library/ast.rst:2543
msgid ""
"`Parso <https://parso.readthedocs.io>`_ is a Python parser that supports "
"error recovery and round-trip parsing for different Python versions (in "
"multiple Python versions). Parso is also able to list multiple syntax errors "
"in your Python file."
msgstr ""
"`Parso <https://parso.readthedocs.io>`_ é um analisador Python que oferece "
"suporte a recuperação de erros e análise de ida e volta para diferentes "
"versões do Python (em várias versões do Python). Parso também é capaz de "
"listar vários erros de sintaxe em seu arquivo Python."

#: ../../library/ast.rst:59
msgid "? (question mark)"
msgstr "? (interrogação)"

#: ../../library/ast.rst:59 ../../library/ast.rst:60
msgid "in AST grammar"
msgstr "em gramática de AST"

#: ../../library/ast.rst:60
msgid "* (asterisk)"
msgstr "* (asterisco)"

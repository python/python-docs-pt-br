# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 15:45+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/ctypes.rst:2
msgid ":mod:`!ctypes` --- A foreign function library for Python"
msgstr ":mod:`!ctypes` --- Uma biblioteca de funções externas para Python"

#: ../../library/ctypes.rst:9
msgid "**Source code:** :source:`Lib/ctypes`"
msgstr "**Código-fonte:** :source:`Lib/ctypes`"

#: ../../library/ctypes.rst:13
msgid ""
":mod:`ctypes` is a foreign function library for Python.  It provides C "
"compatible data types, and allows calling functions in DLLs or shared "
"libraries.  It can be used to wrap these libraries in pure Python."
msgstr ""
":mod:`ctypes` é uma biblioteca de funções externas para Python. Ela fornece "
"tipos de dados compatíveis com C e permite funções de chamada em DLLs ou "
"bibliotecas compartilhadas. Ela pode ser usada para agrupar essas "
"bibliotecas em Python puro."

#: ../../library/ctypes.rst:21
msgid "ctypes tutorial"
msgstr "Tutorial ctypes"

#: ../../library/ctypes.rst:23
msgid ""
"Note: The code samples in this tutorial use :mod:`doctest` to make sure that "
"they actually work.  Since some code samples behave differently under Linux, "
"Windows, or macOS, they contain doctest directives in comments."
msgstr ""
"Nota: Os exemplos de código neste tutorial usam :mod:`doctest` para garantir "
"que eles realmente funcionem. Como algumas amostras de código se comportam "
"de maneira diferente no Linux, Windows ou macOS, elas contêm diretrizes de "
"doctest nos comentários."

#: ../../library/ctypes.rst:27
msgid ""
"Note: Some code samples reference the ctypes :class:`c_int` type.  On "
"platforms where ``sizeof(long) == sizeof(int)`` it is an alias to :class:"
"`c_long`. So, you should not be confused if :class:`c_long` is printed if "
"you would expect :class:`c_int` --- they are actually the same type."
msgstr ""
"Nota: Alguns exemplos de código fazem referência ao tipo ctypes :class:"
"`c_int`. Em plataformas onde ``sizeof(long) == sizeof(int)`` é um apelido "
"para :class:`c_long`. Então, você não deve ficar confuso se :class:`c_long` "
"for impresso se você esperaria :class:`c_int` --- eles são, na verdade, o "
"mesmo tipo."

#: ../../library/ctypes.rst:35
msgid "Loading dynamic link libraries"
msgstr "Carregando bibliotecas de links dinâmicos"

#: ../../library/ctypes.rst:37
msgid ""
":mod:`ctypes` exports the *cdll*, and on Windows *windll* and *oledll* "
"objects, for loading dynamic link libraries."
msgstr ""
":mod:`ctypes` exporta o *cdll* e, no Windows, os objetos *windll* e *oledll* "
"para carregar bibliotecas de vínculo dinâmico."

#: ../../library/ctypes.rst:40
msgid ""
"You load libraries by accessing them as attributes of these objects. *cdll* "
"loads libraries which export functions using the standard ``cdecl`` calling "
"convention, while *windll* libraries call functions using the ``stdcall`` "
"calling convention. *oledll* also uses the ``stdcall`` calling convention, "
"and assumes the functions return a Windows :c:type:`!HRESULT` error code. "
"The error code is used to automatically raise an :class:`OSError` exception "
"when the function call fails."
msgstr ""
"Você carrega bibliotecas acessando-as como atributos desses objetos. *cdll* "
"carrega bibliotecas que exportam funções usando a convenção de chamada "
"padrão ``cdecl``, enquanto bibliotecas *windll* chamam funções usando a "
"convenção de chamada ``stdcall``. *oledll* também usa a convenção de chamada "
"``stdcall`` e assume que as funções retornam um código de erro do Windows :c:"
"type:`!HRESULT`. O código de erro é usado para levantar automaticamente uma "
"exceção :class:`OSError` quando a chamada da função falha."

#: ../../library/ctypes.rst:48
msgid ""
"Windows errors used to raise :exc:`WindowsError`, which is now an alias of :"
"exc:`OSError`."
msgstr ""
"Erros do Windows costumavam levantar :exc:`WindowsError`, que agora é um "
"apelido de :exc:`OSError`."

#: ../../library/ctypes.rst:53
msgid ""
"Here are some examples for Windows. Note that ``msvcrt`` is the MS standard "
"C library containing most standard C functions, and uses the ``cdecl`` "
"calling convention::"
msgstr ""
"Veja alguns exemplos para Windows. Note que ``msvcrt`` é a biblioteca C "
"padrão da MS que contém a maioria das funções C padrão e usa a convenção de "
"chamada ``cdecl``::"

#: ../../library/ctypes.rst:57
msgid ""
">>> from ctypes import *\n"
">>> print(windll.kernel32)\n"
"<WinDLL 'kernel32', handle ... at ...>\n"
">>> print(cdll.msvcrt)\n"
"<CDLL 'msvcrt', handle ... at ...>\n"
">>> libc = cdll.msvcrt\n"
">>>"
msgstr ""
">>> from ctypes import *\n"
">>> print(windll.kernel32)\n"
"<WinDLL 'kernel32', handle ... at ...>\n"
">>> print(cdll.msvcrt)\n"
"<CDLL 'msvcrt', handle ... at ...>\n"
">>> libc = cdll.msvcrt\n"
">>>"

#: ../../library/ctypes.rst:65
msgid "Windows appends the usual ``.dll`` file suffix automatically."
msgstr ""
"O Windows acrescenta automaticamente o sufixo de arquivo ``.dll`` usual."

#: ../../library/ctypes.rst:68
msgid ""
"Accessing the standard C library through ``cdll.msvcrt`` will use an "
"outdated version of the library that may be incompatible with the one being "
"used by Python. Where possible, use native Python functionality, or else "
"import and use the ``msvcrt`` module."
msgstr ""
"Acessar a biblioteca padrão C por meio de ``cdll.msvcrt`` usará uma versão "
"desatualizada da biblioteca que pode ser incompatível com a que está sendo "
"usada pelo Python. Onde possível, use a funcionalidade nativa do Python ou "
"então importe e use o módulo ``msvcrt``."

#: ../../library/ctypes.rst:73
msgid ""
"On Linux, it is required to specify the filename *including* the extension "
"to load a library, so attribute access can not be used to load libraries. "
"Either the :meth:`~LibraryLoader.LoadLibrary` method of the dll loaders "
"should be used, or you should load the library by creating an instance of "
"CDLL by calling the constructor::"
msgstr ""
"No Linux, é necessário especificar o nome do arquivo *incluindo* a extensão "
"para carregar uma biblioteca, então o acesso de atributo não pode ser usado "
"para carregar bibliotecas. O método :meth:`~LibraryLoader.LoadLibrary` dos "
"carregadores de dll deve ser usado, ou você deve carregar a biblioteca "
"criando uma instância de CDLL chamando o construtor::"

#: ../../library/ctypes.rst:79
msgid ""
">>> cdll.LoadLibrary(\"libc.so.6\")\n"
"<CDLL 'libc.so.6', handle ... at ...>\n"
">>> libc = CDLL(\"libc.so.6\")\n"
">>> libc\n"
"<CDLL 'libc.so.6', handle ... at ...>\n"
">>>"
msgstr ""
">>> cdll.LoadLibrary(\"libc.so.6\")\n"
"<CDLL 'libc.so.6', handle ... at ...>\n"
">>> libc = CDLL(\"libc.so.6\")\n"
">>> libc\n"
"<CDLL 'libc.so.6', handle ... at ...>\n"
">>>"

#: ../../library/ctypes.rst:92
msgid "Accessing functions from loaded dlls"
msgstr "Acessando funções de dlls carregadas"

#: ../../library/ctypes.rst:94
msgid "Functions are accessed as attributes of dll objects::"
msgstr "Funções são acessadas como atributos de objetos dll::"

#: ../../library/ctypes.rst:96
msgid ""
">>> libc.printf\n"
"<_FuncPtr object at 0x...>\n"
">>> print(windll.kernel32.GetModuleHandleA)\n"
"<_FuncPtr object at 0x...>\n"
">>> print(windll.kernel32.MyOwnFunction)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"ctypes.py\", line 239, in __getattr__\n"
"    func = _StdcallFuncPtr(name, self)\n"
"AttributeError: function 'MyOwnFunction' not found\n"
">>>"
msgstr ""
">>> libc.printf\n"
"<_FuncPtr object at 0x...>\n"
">>> print(windll.kernel32.GetModuleHandleA)\n"
"<_FuncPtr object at 0x...>\n"
">>> print(windll.kernel32.MyOwnFunction)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"ctypes.py\", line 239, in __getattr__\n"
"    func = _StdcallFuncPtr(name, self)\n"
"AttributeError: function 'MyOwnFunction' not found\n"
">>>"

#: ../../library/ctypes.rst:108
msgid ""
"Note that win32 system dlls like ``kernel32`` and ``user32`` often export "
"ANSI as well as UNICODE versions of a function. The UNICODE version is "
"exported with a ``W`` appended to the name, while the ANSI version is "
"exported with an ``A`` appended to the name. The win32 ``GetModuleHandle`` "
"function, which returns a *module handle* for a given module name, has the "
"following C prototype, and a macro is used to expose one of them as "
"``GetModuleHandle`` depending on whether UNICODE is defined or not::"
msgstr ""
"Observe que DLLs de sistema do Win32, como ``kernel32`` e ``user32``, "
"frequentemente exportam versões ANSI e UNICODE de uma função. A versão "
"UNICODE é exportada com um ``W`` anexado ao nome, enquanto a versão ANSI é "
"exportada com um ``A`` anexado ao nome. A função ``GetModuleHandle`` do "
"Win32, que retorna um *identificador de módulo* para um determinado nome de "
"módulo, tem o seguinte protótipo em C, e uma macro é usada para expor um "
"deles como ``GetModuleHandle``, dependendo se UNICODE está definido ou não:"

#: ../../library/ctypes.rst:116
msgid ""
"/* ANSI version */\n"
"HMODULE GetModuleHandleA(LPCSTR lpModuleName);\n"
"/* UNICODE version */\n"
"HMODULE GetModuleHandleW(LPCWSTR lpModuleName);"
msgstr ""
"/* versão ANSI */\n"
"HMODULE GetModuleHandleA(LPCSTR lpModuleName);\n"
"/* versão UNICODE */\n"
"HMODULE GetModuleHandleW(LPCWSTR lpModuleName);"

#: ../../library/ctypes.rst:121
msgid ""
"*windll* does not try to select one of them by magic, you must access the "
"version you need by specifying ``GetModuleHandleA`` or ``GetModuleHandleW`` "
"explicitly, and then call it with bytes or string objects respectively."
msgstr ""
"*windll* não tenta selecionar um deles magicamente, você deve acessar a "
"versão necessária especificando ``GetModuleHandleA`` ou ``GetModuleHandleW`` "
"explicitamente e então chamá-lo com objetos bytes ou string, respectivamente."

#: ../../library/ctypes.rst:125
msgid ""
"Sometimes, dlls export functions with names which aren't valid Python "
"identifiers, like ``\"??2@YAPAXI@Z\"``. In this case you have to use :func:"
"`getattr` to retrieve the function::"
msgstr ""
"Às vezes, DLLs exportam funções com nomes que não são identificadores Python "
"válidos, como ``\"??2@YAPAXI@Z\"``. Nesse caso, você precisa usar :func:"
"`getattr` para recuperar a função::"

#: ../../library/ctypes.rst:129
msgid ""
">>> getattr(cdll.msvcrt, \"??2@YAPAXI@Z\")\n"
"<_FuncPtr object at 0x...>\n"
">>>"
msgstr ""
">>> getattr(cdll.msvcrt, \"??2@YAPAXI@Z\")\n"
"<_FuncPtr object at 0x...>\n"
">>>"

#: ../../library/ctypes.rst:133
msgid ""
"On Windows, some dlls export functions not by name but by ordinal. These "
"functions can be accessed by indexing the dll object with the ordinal "
"number::"
msgstr ""
"No Windows, algumas dlls exportam funções não por nome, mas por ordinal. "
"Essas funções podem ser acessadas indexando o objeto dll com o número "
"ordinal::"

#: ../../library/ctypes.rst:136
msgid ""
">>> cdll.kernel32[1]\n"
"<_FuncPtr object at 0x...>\n"
">>> cdll.kernel32[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"ctypes.py\", line 310, in __getitem__\n"
"    func = _StdcallFuncPtr(name, self)\n"
"AttributeError: function ordinal 0 not found\n"
">>>"
msgstr ""
">>> cdll.kernel32[1]\n"
"<_FuncPtr object at 0x...>\n"
">>> cdll.kernel32[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"ctypes.py\", line 310, in __getitem__\n"
"    func = _StdcallFuncPtr(name, self)\n"
"AttributeError: function ordinal 0 not found\n"
">>>"

#: ../../library/ctypes.rst:150
msgid "Calling functions"
msgstr "Chamando funções"

#: ../../library/ctypes.rst:152
msgid ""
"You can call these functions like any other Python callable. This example "
"uses the ``rand()`` function, which takes no arguments and returns a pseudo-"
"random integer::"
msgstr ""
"Você pode chamar essas funções como qualquer outro chamável do Python. Este "
"exemplo usa a função ``rand()``, que não aceita argumentos e retorna um "
"inteiro pseudoaleatório:"

#: ../../library/ctypes.rst:155
msgid ""
">>> print(libc.rand())\n"
"1804289383"
msgstr ""
">>> print(libc.rand())\n"
"1804289383"

#: ../../library/ctypes.rst:158
msgid ""
"On Windows, you can call the ``GetModuleHandleA()`` function, which returns "
"a win32 module handle (passing ``None`` as single argument to call it with a "
"``NULL`` pointer)::"
msgstr ""
"No Windows, você pode chamar a função ``GetModuleHandleA()``, que retorna um "
"identificador de módulo win32 (passando ``None`` como único argumento para "
"chamá-lo com um ponteiro ``NULL``)::"

#: ../../library/ctypes.rst:161
msgid ""
">>> print(hex(windll.kernel32.GetModuleHandleA(None)))\n"
"0x1d000000\n"
">>>"
msgstr ""
">>> print(hex(windll.kernel32.GetModuleHandleA(None)))\n"
"0x1d000000\n"
">>>"

#: ../../library/ctypes.rst:165
msgid ""
":exc:`ValueError` is raised when you call an ``stdcall`` function with the "
"``cdecl`` calling convention, or vice versa::"
msgstr ""
":exc:`ValueError` é gerado quando você chama uma função ``stdcall`` com a "
"convenção de chamada ``cdecl``, ou vice-versa::"

#: ../../library/ctypes.rst:168
msgid ""
">>> cdll.kernel32.GetModuleHandleA(None)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: Procedure probably called with not enough arguments (4 bytes "
"missing)\n"
">>>\n"
"\n"
">>> windll.msvcrt.printf(b\"spam\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: Procedure probably called with too many arguments (4 bytes in "
"excess)\n"
">>>"
msgstr ""
">>> cdll.kernel32.GetModuleHandleA(None)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: Procedure probably called with not enough arguments (4 bytes "
"missing)\n"
">>>\n"
"\n"
">>> windll.msvcrt.printf(b\"spam\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: Procedure probably called with too many arguments (4 bytes in "
"excess)\n"
">>>"

#: ../../library/ctypes.rst:180
msgid ""
"To find out the correct calling convention you have to look into the C "
"header file or the documentation for the function you want to call."
msgstr ""
"Para descobrir a convenção de chamada correta, você precisa consultar o "
"arquivo de cabeçalho C ou a documentação da função que deseja chamar."

#: ../../library/ctypes.rst:183
msgid ""
"On Windows, :mod:`ctypes` uses win32 structured exception handling to "
"prevent crashes from general protection faults when functions are called "
"with invalid argument values::"
msgstr ""
"No Windows, :mod:`ctypes` usa o tratamento de exceções estruturado do win32 "
"para evitar travamentos devido a falhas gerais de proteção quando funções "
"são chamadas com valores de argumentos inválidos::"

#: ../../library/ctypes.rst:187
msgid ""
">>> windll.kernel32.GetModuleHandleA(32)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"OSError: exception: access violation reading 0x00000020\n"
">>>"
msgstr ""
">>> windll.kernel32.GetModuleHandleA(32)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"OSError: exception: access violation reading 0x00000020\n"
">>>"

#: ../../library/ctypes.rst:193
msgid ""
"There are, however, enough ways to crash Python with :mod:`ctypes`, so you "
"should be careful anyway.  The :mod:`faulthandler` module can be helpful in "
"debugging crashes (e.g. from segmentation faults produced by erroneous C "
"library calls)."
msgstr ""
"No entanto, existem maneiras suficientes de travar o Python com :mod:"
"`ctypes`, então você deve ter cuidado de qualquer maneira. O módulo :mod:"
"`faulthandler` pode ser útil na depuração de travamentos (por exemplo, de "
"falhas de segmentação produzidas por chamadas errôneas da biblioteca C)."

#: ../../library/ctypes.rst:198
msgid ""
"``None``, integers, bytes objects and (unicode) strings are the only native "
"Python objects that can directly be used as parameters in these function "
"calls. ``None`` is passed as a C ``NULL`` pointer, bytes objects and strings "
"are passed as pointer to the memory block that contains their data (:c:expr:"
"`char *` or :c:expr:`wchar_t *`).  Python integers are passed as the "
"platforms default C :c:expr:`int` type, their value is masked to fit into "
"the C type."
msgstr ""

#: ../../library/ctypes.rst:205
msgid ""
"Before we move on calling functions with other parameter types, we have to "
"learn more about :mod:`ctypes` data types."
msgstr ""
"Antes de prosseguirmos com a chamada de funções com outros tipos de "
"parâmetros, precisamos aprender mais sobre os tipos de dados :mod:`ctypes`."

#: ../../library/ctypes.rst:212 ../../library/ctypes.rst:2237
msgid "Fundamental data types"
msgstr "Tipos de dados fundamentais"

#: ../../library/ctypes.rst:214
msgid ":mod:`ctypes` defines a number of primitive C compatible data types:"
msgstr ""
":mod:`ctypes` define uma série de tipos de dados primitivos compatíveis com "
"C:"

#: ../../library/ctypes.rst:217
msgid "ctypes type"
msgstr "Tipo ctypes"

#: ../../library/ctypes.rst:217
msgid "C type"
msgstr "Tipo em C"

#: ../../library/ctypes.rst:217
msgid "Python type"
msgstr "Tipo em Python"

#: ../../library/ctypes.rst:219
msgid ":class:`c_bool`"
msgstr ":class:`c_bool`"

#: ../../library/ctypes.rst:219
msgid ":c:expr:`_Bool`"
msgstr ":c:expr:`_Bool`"

#: ../../library/ctypes.rst:219
msgid "bool (1)"
msgstr "bool (1)"

#: ../../library/ctypes.rst:221
msgid ":class:`c_char`"
msgstr ":class:`c_char`"

#: ../../library/ctypes.rst:221 ../../library/ctypes.rst:225
msgid ":c:expr:`char`"
msgstr ":c:expr:`char`"

#: ../../library/ctypes.rst:221
msgid "1-character bytes object"
msgstr "objeto bytes de 1 caractere"

#: ../../library/ctypes.rst:223
msgid ":class:`c_wchar`"
msgstr ":class:`c_wchar`"

#: ../../library/ctypes.rst:223
msgid ":c:type:`wchar_t`"
msgstr ":c:type:`wchar_t`"

#: ../../library/ctypes.rst:223
msgid "1-character string"
msgstr "string de 1 caractere"

#: ../../library/ctypes.rst:225
msgid ":class:`c_byte`"
msgstr ":class:`c_byte`"

#: ../../library/ctypes.rst:225 ../../library/ctypes.rst:227
#: ../../library/ctypes.rst:229 ../../library/ctypes.rst:231
#: ../../library/ctypes.rst:233 ../../library/ctypes.rst:235
#: ../../library/ctypes.rst:237 ../../library/ctypes.rst:239
#: ../../library/ctypes.rst:241 ../../library/ctypes.rst:243
#: ../../library/ctypes.rst:246 ../../library/ctypes.rst:248
#: ../../library/ctypes.rst:251
msgid "int"
msgstr "int"

#: ../../library/ctypes.rst:227
msgid ":class:`c_ubyte`"
msgstr ":class:`c_ubyte`"

#: ../../library/ctypes.rst:227
msgid ":c:expr:`unsigned char`"
msgstr ":c:expr:`unsigned char`"

#: ../../library/ctypes.rst:229
msgid ":class:`c_short`"
msgstr ":class:`c_short`"

#: ../../library/ctypes.rst:229
msgid ":c:expr:`short`"
msgstr ":c:expr:`short`"

#: ../../library/ctypes.rst:231
msgid ":class:`c_ushort`"
msgstr ":class:`c_ushort`"

#: ../../library/ctypes.rst:231
msgid ":c:expr:`unsigned short`"
msgstr ":c:expr:`unsigned short`"

#: ../../library/ctypes.rst:233
msgid ":class:`c_int`"
msgstr ":class:`c_int`"

#: ../../library/ctypes.rst:233
msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

#: ../../library/ctypes.rst:235
msgid ":class:`c_uint`"
msgstr ":class:`c_uint`"

#: ../../library/ctypes.rst:235
msgid ":c:expr:`unsigned int`"
msgstr ":c:expr:`unsigned int`"

#: ../../library/ctypes.rst:237
msgid ":class:`c_long`"
msgstr ":class:`c_long`"

#: ../../library/ctypes.rst:237
msgid ":c:expr:`long`"
msgstr ":c:expr:`long`"

#: ../../library/ctypes.rst:239
msgid ":class:`c_ulong`"
msgstr ":class:`c_ulong`"

#: ../../library/ctypes.rst:239
msgid ":c:expr:`unsigned long`"
msgstr ":c:expr:`unsigned long`"

#: ../../library/ctypes.rst:241
msgid ":class:`c_longlong`"
msgstr ":class:`c_longlong`"

#: ../../library/ctypes.rst:241
msgid ":c:expr:`__int64` or :c:expr:`long long`"
msgstr ":c:expr:`__int64` ou :c:expr:`long long`"

#: ../../library/ctypes.rst:243
msgid ":class:`c_ulonglong`"
msgstr ":class:`c_ulonglong`"

#: ../../library/ctypes.rst:243
msgid ":c:expr:`unsigned __int64` or :c:expr:`unsigned long long`"
msgstr ":c:expr:`unsigned __int64` ou :c:expr:`unsigned long long`"

#: ../../library/ctypes.rst:246
msgid ":class:`c_size_t`"
msgstr ":class:`c_size_t`"

#: ../../library/ctypes.rst:246
msgid ":c:type:`size_t`"
msgstr ":c:type:`size_t`"

#: ../../library/ctypes.rst:248
msgid ":class:`c_ssize_t`"
msgstr ":class:`c_ssize_t`"

#: ../../library/ctypes.rst:248
msgid ":c:type:`ssize_t` or :c:expr:`Py_ssize_t`"
msgstr ":c:type:`ssize_t` ou :c:expr:`Py_ssize_t`"

#: ../../library/ctypes.rst:251
msgid ":class:`c_time_t`"
msgstr ":class:`c_time_t`"

#: ../../library/ctypes.rst:251
msgid ":c:type:`time_t`"
msgstr ":c:type:`time_t`"

#: ../../library/ctypes.rst:253
msgid ":class:`c_float`"
msgstr ":class:`c_float`"

#: ../../library/ctypes.rst:253
msgid ":c:expr:`float`"
msgstr ":c:expr:`float`"

#: ../../library/ctypes.rst:253 ../../library/ctypes.rst:255
#: ../../library/ctypes.rst:257
msgid "float"
msgstr "ponto flutuante"

#: ../../library/ctypes.rst:255
msgid ":class:`c_double`"
msgstr ":class:`c_double`"

#: ../../library/ctypes.rst:255
msgid ":c:expr:`double`"
msgstr ":c:expr:`double`"

#: ../../library/ctypes.rst:257
msgid ":class:`c_longdouble`"
msgstr ":class:`c_longdouble`"

#: ../../library/ctypes.rst:257
msgid ":c:expr:`long double`"
msgstr ":c:expr:`long double`"

#: ../../library/ctypes.rst:259
msgid ":class:`c_char_p`"
msgstr ":class:`c_char_p`"

#: ../../library/ctypes.rst:259
msgid ":c:expr:`char *` (NUL terminated)"
msgstr ":c:expr:`char *` (finalizado com NUL)"

#: ../../library/ctypes.rst:259
msgid "bytes object or ``None``"
msgstr "objeto bytes ou ``None``"

#: ../../library/ctypes.rst:261
msgid ":class:`c_wchar_p`"
msgstr ":class:`c_wchar_p`"

#: ../../library/ctypes.rst:261
msgid ":c:expr:`wchar_t *` (NUL terminated)"
msgstr ":c:expr:`wchar_t *` (finalizado com NUL)"

#: ../../library/ctypes.rst:261
msgid "string or ``None``"
msgstr "String ou ``None``"

#: ../../library/ctypes.rst:263
msgid ":class:`c_void_p`"
msgstr ":class:`c_void_p`"

#: ../../library/ctypes.rst:263
msgid ":c:expr:`void *`"
msgstr ":c:expr:`void *`"

#: ../../library/ctypes.rst:263
msgid "int or ``None``"
msgstr "int ou ``None``"

#: ../../library/ctypes.rst:267
msgid "The constructor accepts any object with a truth value."
msgstr "O construtor aceita qualquer objeto com um valor verdade."

#: ../../library/ctypes.rst:269
msgid ""
"All these types can be created by calling them with an optional initializer "
"of the correct type and value::"
msgstr ""
"Todos esses tipos podem ser criados chamando-os com um inicializador "
"opcional do tipo e valor corretos::"

#: ../../library/ctypes.rst:272
msgid ""
">>> c_int()\n"
"c_long(0)\n"
">>> c_wchar_p(\"Hello, World\")\n"
"c_wchar_p(140018365411392)\n"
">>> c_ushort(-3)\n"
"c_ushort(65533)\n"
">>>"
msgstr ""
">>> c_int()\n"
"c_long(0)\n"
">>> c_wchar_p(\"Olá, mundo\")\n"
"c_wchar_p(139878537078816)\n"
">>> c_ushort(-3)\n"
"c_ushort(65533)\n"
">>>"

#: ../../library/ctypes.rst:280
msgid ""
"Since these types are mutable, their value can also be changed afterwards::"
msgstr ""
"Como esses tipos são mutáveis, seus valores também podem ser alterados "
"posteriormente::"

#: ../../library/ctypes.rst:282
msgid ""
">>> i = c_int(42)\n"
">>> print(i)\n"
"c_long(42)\n"
">>> print(i.value)\n"
"42\n"
">>> i.value = -99\n"
">>> print(i.value)\n"
"-99\n"
">>>"
msgstr ""
">>> i = c_int(42)\n"
">>> print(i)\n"
"c_long(42)\n"
">>> print(i.value)\n"
"42\n"
">>> i.value = -99\n"
">>> print(i.value)\n"
"-99\n"
">>>"

#: ../../library/ctypes.rst:292
msgid ""
"Assigning a new value to instances of the pointer types :class:`c_char_p`, :"
"class:`c_wchar_p`, and :class:`c_void_p` changes the *memory location* they "
"point to, *not the contents* of the memory block (of course not, because "
"Python bytes objects are immutable)::"
msgstr ""

#: ../../library/ctypes.rst:297
msgid ""
">>> s = \"Hello, World\"\n"
">>> c_s = c_wchar_p(s)\n"
">>> print(c_s)\n"
"c_wchar_p(139966785747344)\n"
">>> print(c_s.value)\n"
"Hello World\n"
">>> c_s.value = \"Hi, there\"\n"
">>> print(c_s)              # the memory location has changed\n"
"c_wchar_p(139966783348904)\n"
">>> print(c_s.value)\n"
"Hi, there\n"
">>> print(s)                # first object is unchanged\n"
"Hello, World\n"
">>>"
msgstr ""
">>> s = \"Olá, mundo\"\n"
">>> c_s = c_wchar_p(s)\n"
">>> print(c_s)\n"
"c_wchar_p(139878542513936)\n"
">>> print(c_s.value)\n"
"Olá, mundo\n"
">>> c_s.value = \"Opa, beleza?\"\n"
">>> print(c_s)              # o local da memória foi alterado\n"
"c_wchar_p(139878536944240)\n"
">>> print(c_s.value)\n"
"Opa, beleza?\n"
">>> print(s)                # primeiro objeto está inalterado\n"
"Olá, mundo\n"
">>>"

#: ../../library/ctypes.rst:312
msgid ""
"You should be careful, however, not to pass them to functions expecting "
"pointers to mutable memory. If you need mutable memory blocks, ctypes has a :"
"func:`create_string_buffer` function which creates these in various ways.  "
"The current memory block contents can be accessed (or changed) with the "
"``raw`` property; if you want to access it as NUL terminated string, use the "
"``value`` property::"
msgstr ""
"No entanto, tome cuidado para não passá-los para funções que esperam "
"ponteiros para memória mutável. Se precisar de blocos de memória mutáveis, o "
"ctypes possui uma função :func:`create_string_buffer` que os cria de várias "
"maneiras. O conteúdo do bloco de memória atual pode ser acessado (ou "
"alterado) com a propriedade ``raw``; se quiser acessá-lo como uma string "
"terminada em NUL, use a propriedade ``value``:"

#: ../../library/ctypes.rst:319
msgid ""
">>> from ctypes import *\n"
">>> p = create_string_buffer(3)            # create a 3 byte buffer, "
"initialized to NUL bytes\n"
">>> print(sizeof(p), repr(p.raw))\n"
"3 b'\\x00\\x00\\x00'\n"
">>> p = create_string_buffer(b\"Hello\")     # create a buffer containing a "
"NUL terminated string\n"
">>> print(sizeof(p), repr(p.raw))\n"
"6 b'Hello\\x00'\n"
">>> print(repr(p.value))\n"
"b'Hello'\n"
">>> p = create_string_buffer(b\"Hello\", 10) # create a 10 byte buffer\n"
">>> print(sizeof(p), repr(p.raw))\n"
"10 b'Hello\\x00\\x00\\x00\\x00\\x00'\n"
">>> p.value = b\"Hi\"\n"
">>> print(sizeof(p), repr(p.raw))\n"
"10 b'Hi\\x00lo\\x00\\x00\\x00\\x00\\x00'\n"
">>>"
msgstr ""
">>> from ctypes import *\n"
">>> p = create_string_buffer(3)            # cria um buffer de 3 bytes, "
"inicializado para NUL bytes\n"
">>> print(sizeof(p), repr(p.raw))\n"
"3 b'\\x00\\x00\\x00'\n"
">>> p = create_string_buffer(b\"Opa\")       # cria um buffer contendo uma "
"string terminando com NUL\n"
">>> print(sizeof(p), repr(p.raw))\n"
"4 b'Opa\\x00'\n"
">>> print(repr(p.value))\n"
"b'Opa'\n"
">>> p = create_string_buffer(b\"Oi\", 10)    # cria um buffer de 10 bytes\n"
">>> print(sizeof(p), repr(p.raw))\n"
"10 b'Oi\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n"
">>> p.value = b\"Oi\"\n"
">>> print(sizeof(p), repr(p.raw))\n"
"10 b'Oi\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n"
">>>"

#: ../../library/ctypes.rst:336
msgid ""
"The :func:`create_string_buffer` function replaces the old :func:`!c_buffer` "
"function (which is still available as an alias).  To create a mutable memory "
"block containing unicode characters of the C type :c:type:`wchar_t`, use "
"the :func:`create_unicode_buffer` function."
msgstr ""
"A função :func:`create_string_buffer` substitui a antiga função :func:`!"
"c_buffer` (que ainda está disponível como um apelido). Para criar um bloco "
"de memória mutável contendo caracteres Unicode do tipo C :c:type:`wchar_t`, "
"use a função :func:`create_unicode_buffer`."

#: ../../library/ctypes.rst:345
msgid "Calling functions, continued"
msgstr "Chamando funções, continuação"

#: ../../library/ctypes.rst:347
msgid ""
"Note that printf prints to the real standard output channel, *not* to :data:"
"`sys.stdout`, so these examples will only work at the console prompt, not "
"from within *IDLE* or *PythonWin*::"
msgstr ""
"Observe que printf imprime no canal de saída padrão real, *não* em :data:"
"`sys.stdout`, então esses exemplos só funcionarão no prompt do console, não "
"de dentro do *IDLE* ou *PythonWin*::"

#: ../../library/ctypes.rst:351
msgid ""
">>> printf = libc.printf\n"
">>> printf(b\"Hello, %s\\n\", b\"World!\")\n"
"Hello, World!\n"
"14\n"
">>> printf(b\"Hello, %S\\n\", \"World!\")\n"
"Hello, World!\n"
"14\n"
">>> printf(b\"%d bottles of beer\\n\", 42)\n"
"42 bottles of beer\n"
"19\n"
">>> printf(b\"%f bottles of beer\\n\", 42.5)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ArgumentError: argument 2: TypeError: Don't know how to convert parameter 2\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:367
msgid ""
"As has been mentioned before, all Python types except integers, strings, and "
"bytes objects have to be wrapped in their corresponding :mod:`ctypes` type, "
"so that they can be converted to the required C data type::"
msgstr ""
"Як уже згадувалося раніше, усі типи Python, окрім цілих, рядкових і байтових "
"об’єктів, мають бути загорнуті у відповідний тип :mod:`ctypes`, щоб їх можна "
"було перетворити на необхідний тип даних C::"

#: ../../library/ctypes.rst:371
msgid ""
">>> printf(b\"An int %d, a double %f\\n\", 1234, c_double(3.14))\n"
"An int 1234, a double 3.140000\n"
"31\n"
">>>"
msgstr ""
">>> printf(b\"An int %d, a double %f\\n\", 1234, c_double(3.14))\n"
"An int 1234, a double 3.140000\n"
"31\n"
">>>"

#: ../../library/ctypes.rst:379
msgid "Calling variadic functions"
msgstr "Chamando funções variadas"

#: ../../library/ctypes.rst:381
msgid ""
"On a lot of platforms calling variadic functions through ctypes is exactly "
"the same as calling functions with a fixed number of parameters. On some "
"platforms, and in particular ARM64 for Apple Platforms, the calling "
"convention for variadic functions is different than that for regular "
"functions."
msgstr ""
"На многих платформах вызов переменных функций через ctypes точно такой же, "
"как вызов функций с фиксированным количеством параметров. На некоторых "
"платформах, в частности ARM64 для платформ Apple, соглашение о вызовах для "
"переменных функций отличается от соглашения о вызовах для обычных функций."

#: ../../library/ctypes.rst:386
msgid ""
"On those platforms it is required to specify the :attr:`~_CFuncPtr.argtypes` "
"attribute for the regular, non-variadic, function arguments:"
msgstr ""
"На этих платформах необходимо указать атрибут :attr:`~_CFuncPtr.argtypes` "
"для обычных, невариативных аргументов функции:"

#: ../../library/ctypes.rst:389
msgid "libc.printf.argtypes = [ctypes.c_char_p]"
msgstr "libc.printf.argtypes = [ctypes.c_char_p]"

#: ../../library/ctypes.rst:393
msgid ""
"Because specifying the attribute does not inhibit portability it is advised "
"to always specify :attr:`~_CFuncPtr.argtypes` for all variadic functions."
msgstr ""
"Поскольку указание атрибута не препятствует переносимости, рекомендуется "
"всегда указывать :attr:`~_CFuncPtr.argtypes` для всех переменных функций."

#: ../../library/ctypes.rst:400
msgid "Calling functions with your own custom data types"
msgstr "Виклик функцій із власними типами даних"

#: ../../library/ctypes.rst:402
msgid ""
"You can also customize :mod:`ctypes` argument conversion to allow instances "
"of your own classes be used as function arguments. :mod:`ctypes` looks for "
"an :attr:`!_as_parameter_` attribute and uses this as the function argument. "
"The attribute must be an integer, string, bytes, a :mod:`ctypes` instance, "
"or an object with an :attr:`!_as_parameter_` attribute::"
msgstr ""
"Вы также можете настроить преобразование аргументов :mod:`ctypes`, чтобы "
"экземпляры ваших собственных классов могли использоваться в качестве "
"аргументов функции. :mod:`ctypes` ищет атрибут :attr:`!_as_parameter_` и "
"использует его в качестве аргумента функции. Атрибут должен быть целым "
"числом, строкой, байтами, экземпляром :mod:`ctypes` или объектом с "
"атрибутом :attr:`!_as_parameter_`::"

#: ../../library/ctypes.rst:408
msgid ""
">>> class Bottles:\n"
"...     def __init__(self, number):\n"
"...         self._as_parameter_ = number\n"
"...\n"
">>> bottles = Bottles(42)\n"
">>> printf(b\"%d bottles of beer\\n\", bottles)\n"
"42 bottles of beer\n"
"19\n"
">>>"
msgstr ""
">>> class Bottles:\n"
"...     def __init__(self, number):\n"
"...         self._as_parameter_ = number\n"
"...\n"
">>> bottles = Bottles(42)\n"
">>> printf(b\"%d bottles of beer\\n\", bottles)\n"
"42 bottles of beer\n"
"19\n"
">>>"

#: ../../library/ctypes.rst:418
msgid ""
"If you don't want to store the instance's data in the :attr:`!"
"_as_parameter_` instance variable, you could define a :class:`property` "
"which makes the attribute available on request."
msgstr ""
"Если вы не хотите хранить данные экземпляра в переменной экземпляра :attr:`!"
"_as_parameter_`, вы можете определить :class:`property`, который делает "
"атрибут доступным по запросу."

#: ../../library/ctypes.rst:426
msgid "Specifying the required argument types (function prototypes)"
msgstr "Вказівка необхідних типів аргументів (прототипів функцій)"

#: ../../library/ctypes.rst:428
msgid ""
"It is possible to specify the required argument types of functions exported "
"from DLLs by setting the :attr:`~_CFuncPtr.argtypes` attribute."
msgstr ""
"Можно указать требуемые типы аргументов функций, экспортируемых из DLL, "
"установив атрибут :attr:`~_CFuncPtr.argtypes`."

#: ../../library/ctypes.rst:431
msgid ""
":attr:`~_CFuncPtr.argtypes` must be a sequence of C data types (the :func:`!"
"printf` function is probably not a good example here, because it takes a "
"variable number and different types of parameters depending on the format "
"string, on the other hand this is quite handy to experiment with this "
"feature)::"
msgstr ""
":attr:`~_CFuncPtr.argtypes` должен быть последовательностью типов данных C "
"(функция :func:`!printf`, вероятно, не является здесь хорошим примером, "
"поскольку она принимает переменное число и разные типы параметров в "
"зависимости от формата. string, с другой стороны, с этой функцией весьма "
"удобно экспериментировать)::"

#: ../../library/ctypes.rst:436
msgid ""
">>> printf.argtypes = [c_char_p, c_char_p, c_int, c_double]\n"
">>> printf(b\"String '%s', Int %d, Double %f\\n\", b\"Hi\", 10, 2.2)\n"
"String 'Hi', Int 10, Double 2.200000\n"
"37\n"
">>>"
msgstr ""
">>> printf.argtypes = [c_char_p, c_char_p, c_int, c_double]\n"
">>> printf(b\"String '%s', Int %d, Double %f\\n\", b\"Hi\", 10, 2.2)\n"
"String 'Hi', Int 10, Double 2.200000\n"
"37\n"
">>>"

#: ../../library/ctypes.rst:442
msgid ""
"Specifying a format protects against incompatible argument types (just as a "
"prototype for a C function), and tries to convert the arguments to valid "
"types::"
msgstr ""
"Зазначення формату захищає від несумісних типів аргументів (як прототип для "
"функції C) і намагається перетворити аргументи на дійсні типи:"

#: ../../library/ctypes.rst:445
msgid ""
">>> printf(b\"%d %d %d\", 1, 2, 3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ArgumentError: argument 2: TypeError: wrong type\n"
">>> printf(b\"%s %d %f\\n\", b\"X\", 2, 3)\n"
"X 2 3.000000\n"
"13\n"
">>>"
msgstr ""

#: ../../library/ctypes.rst:454
msgid ""
"If you have defined your own classes which you pass to function calls, you "
"have to implement a :meth:`~_CData.from_param` class method for them to be "
"able to use them in the :attr:`~_CFuncPtr.argtypes` sequence. The :meth:"
"`~_CData.from_param` class method receives the Python object passed to the "
"function call, it should do a typecheck or whatever is needed to make sure "
"this object is acceptable, and then return the object itself, its :attr:`!"
"_as_parameter_` attribute, or whatever you want to pass as the C function "
"argument in this case. Again, the result should be an integer, string, "
"bytes, a :mod:`ctypes` instance, or an object with an :attr:`!"
"_as_parameter_` attribute."
msgstr ""
"Если вы определили свои собственные классы, которые передаете в вызовы "
"функций, вам необходимо реализовать метод класса :meth:`~_CData.from_param`, "
"чтобы они могли использовать их в последовательности :attr:`~_CFuncPtr."
"argtypes`. . Метод класса :meth:`~_CData.from_param` получает объект Python, "
"переданный в вызов функции, он должен выполнить проверку типа или что-то "
"еще, что необходимо, чтобы убедиться, что этот объект приемлем, а затем "
"вернуть сам объект, его :attr: Атрибут `!_as_parameter_` или любой другой "
"атрибут, который вы хотите передать в качестве аргумента функции C в этом "
"случае. Опять же, результатом должно быть целое число, строка, байты, "
"экземпляр :mod:`ctypes` или объект с атрибутом :attr:`!_as_parameter_`."

#: ../../library/ctypes.rst:468
msgid "Return types"
msgstr "Tipos de Retorno"

#: ../../library/ctypes.rst:478
msgid ""
"By default functions are assumed to return the C :c:expr:`int` type.  Other "
"return types can be specified by setting the :attr:`~_CFuncPtr.restype` "
"attribute of the function object."
msgstr ""
"По умолчанию предполагается, что функции возвращают тип C :c:expr:`int`. "
"Другие типы возвращаемых значений можно указать, установив атрибут :attr:"
"`~_CFuncPtr.restype` объекта функции."

#: ../../library/ctypes.rst:482
msgid ""
"The C prototype of :c:func:`time` is ``time_t time(time_t *)``. Because :c:"
"type:`time_t` might be of a different type than the default return type :c:"
"expr:`int`, you should specify the :attr:`!restype` attribute::"
msgstr ""
"Прототипом C :c:func:`time` является ``time_t time(time_t *)``. Поскольку :c:"
"type:`time_t` может иметь другой тип, чем тип возвращаемого значения по "
"умолчанию :c:expr:`int`, вам следует указать атрибут :attr:`!restype`::"

#: ../../library/ctypes.rst:486
msgid ">>> libc.time.restype = c_time_t"
msgstr ">>> libc.time.restype = c_time_t"

#: ../../library/ctypes.rst:488
msgid "The argument types can be specified using :attr:`~_CFuncPtr.argtypes`::"
msgstr "Типы аргументов можно указать с помощью :attr:`~_CFuncPtr.argtypes`::"

#: ../../library/ctypes.rst:490
msgid ">>> libc.time.argtypes = (POINTER(c_time_t),)"
msgstr ">>> libc.time.argtypes = (POINTER(c_time_t),)"

#: ../../library/ctypes.rst:492
msgid ""
"To call the function with a ``NULL`` pointer as first argument, use "
"``None``::"
msgstr ""
"Чтобы вызвать функцию с указателем NULL в качестве первого аргумента, "
"используйте None::"

#: ../../library/ctypes.rst:494
msgid ""
">>> print(libc.time(None))\n"
"1150640792"
msgstr ""
">>> print(libc.time(None))\n"
"1150640792"

#: ../../library/ctypes.rst:497
msgid ""
"Here is a more advanced example, it uses the :func:`!strchr` function, which "
"expects a string pointer and a char, and returns a pointer to a string::"
msgstr ""
"Вот более продвинутый пример: он использует функцию :func:`!strchr`, которая "
"ожидает указатель на строку и символ и возвращает указатель на строку::"

#: ../../library/ctypes.rst:500
msgid ""
">>> strchr = libc.strchr\n"
">>> strchr(b\"abcdef\", ord(\"d\"))\n"
"8059983\n"
">>> strchr.restype = c_char_p    # c_char_p is a pointer to a string\n"
">>> strchr(b\"abcdef\", ord(\"d\"))\n"
"b'def'\n"
">>> print(strchr(b\"abcdef\", ord(\"x\")))\n"
"None\n"
">>>"
msgstr ""
">>> strchr = libc.strchr\n"
">>> strchr(b\"abcdef\", ord(\"d\"))\n"
"8059983\n"
">>> strchr.restype = c_char_p    # c_char_p is a pointer to a string\n"
">>> strchr(b\"abcdef\", ord(\"d\"))\n"
"b'def'\n"
">>> print(strchr(b\"abcdef\", ord(\"x\")))\n"
"None\n"
">>>"

#: ../../library/ctypes.rst:510
msgid ""
"If you want to avoid the :func:`ord(\"x\") <ord>` calls above, you can set "
"the :attr:`~_CFuncPtr.argtypes` attribute, and the second argument will be "
"converted from a single character Python bytes object into a C char:"
msgstr ""
"Если вы хотите избежать приведенных выше вызовов :func:`ord(\"x\") <ord>`, "
"вы можете установить атрибут :attr:`~_CFuncPtr.argtypes`, и второй аргумент "
"будет преобразован из одного символа Python. байтовый объект в символ C:"

#: ../../library/ctypes.rst:514
msgid ""
">>> strchr.restype = c_char_p\n"
">>> strchr.argtypes = [c_char_p, c_char]\n"
">>> strchr(b\"abcdef\", b\"d\")\n"
"b'def'\n"
">>> strchr(b\"abcdef\", b\"def\")\n"
"Traceback (most recent call last):\n"
"ctypes.ArgumentError: argument 2: TypeError: one character bytes, bytearray "
"or integer expected\n"
">>> print(strchr(b\"abcdef\", b\"x\"))\n"
"None\n"
">>> strchr(b\"abcdef\", b\"d\")\n"
"b'def'\n"
">>>"
msgstr ""
">>> strchr.restype = c_char_p\n"
">>> strchr.argtypes = [c_char_p, c_char]\n"
">>> strchr(b\"abcdef\", b\"d\")\n"
"b'def'\n"
">>> strchr(b\"abcdef\", b\"def\")\n"
"Traceback (most recent call last):\n"
"ctypes.ArgumentError: argument 2: TypeError: one character bytes, bytearray "
"or integer expected\n"
">>> print(strchr(b\"abcdef\", b\"x\"))\n"
"None\n"
">>> strchr(b\"abcdef\", b\"d\")\n"
"b'def'\n"
">>>"

#: ../../library/ctypes.rst:529
msgid ""
"You can also use a callable Python object (a function or a class for "
"example) as the :attr:`~_CFuncPtr.restype` attribute, if the foreign "
"function returns an integer.  The callable will be called with the *integer* "
"the C function returns, and the result of this call will be used as the "
"result of your function call. This is useful to check for error return "
"values and automatically raise an exception::"
msgstr ""
"Обычно ctypes выполняет строгую проверку типов. Это означает, что если у вас "
"есть POINTER(c_int) в списке :attr:`~_CFuncPtr.argtypes` функции или в "
"качестве типа поля-члена в определении структуры, будут использоваться "
"только экземпляры точно такого же типа. принял. Есть некоторые исключения из "
"этого правила, когда ctypes принимает другие объекты. Например, вы можете "
"передавать совместимые экземпляры массива вместо типов указателей. Итак, для "
"POINTER(c_int) ctypes принимает массив c_int::"

#: ../../library/ctypes.rst:535
msgid ""
">>> GetModuleHandle = windll.kernel32.GetModuleHandleA\n"
">>> def ValidHandle(value):\n"
"...     if value == 0:\n"
"...         raise WinError()\n"
"...     return value\n"
"...\n"
">>>\n"
">>> GetModuleHandle.restype = ValidHandle\n"
">>> GetModuleHandle(None)\n"
"486539264\n"
">>> GetModuleHandle(\"something silly\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 3, in ValidHandle\n"
"OSError: [Errno 126] The specified module could not be found.\n"
">>>"
msgstr ""
">>> GetModuleHandle = windll.kernel32.GetModuleHandleA\n"
">>> def ValidHandle(value):\n"
"...     if value == 0:\n"
"...         raise WinError()\n"
"...     return value\n"
"...\n"
">>>\n"
">>> GetModuleHandle.restype = ValidHandle\n"
">>> GetModuleHandle(None)\n"
"486539264\n"
">>> GetModuleHandle(\"something silly\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 3, in ValidHandle\n"
"OSError: [Errno 126] The specified module could not be found.\n"
">>>"

#: ../../library/ctypes.rst:552
msgid ""
"``WinError`` is a function which will call Windows ``FormatMessage()`` api "
"to get the string representation of an error code, and *returns* an "
"exception. ``WinError`` takes an optional error code parameter, if no one is "
"used, it calls :func:`GetLastError` to retrieve it."
msgstr ""
"``WinError`` — це функція, яка викликає Windows ``FormatMessage()`` API, щоб "
"отримати рядкове представлення коду помилки, і *повертає* виняткову "
"ситуацію. ``WinError`` приймає додатковий параметр коду помилки, якщо ніхто "
"не використовується, він викликає :func:`GetLastError`, щоб отримати його."

#: ../../library/ctypes.rst:557
msgid ""
"Please note that a much more powerful error checking mechanism is available "
"through the :attr:`~_CFuncPtr.errcheck` attribute; see the reference manual "
"for details."
msgstr ""
"Обратите внимание, что гораздо более мощный механизм проверки ошибок "
"доступен через атрибут :attr:`~_CFuncPtr.errcheck`; подробности см. в "
"справочном руководстве."

#: ../../library/ctypes.rst:565
msgid "Passing pointers (or: passing parameters by reference)"
msgstr "Passando ponteiros (ou: passando parâmetros por referência)"

#: ../../library/ctypes.rst:567
msgid ""
"Sometimes a C api function expects a *pointer* to a data type as parameter, "
"probably to write into the corresponding location, or if the data is too "
"large to be passed by value. This is also known as *passing parameters by "
"reference*."
msgstr ""
"Іноді функція C API очікує *вказівника* на тип даних як параметр, ймовірно, "
"для запису у відповідне розташування або якщо дані завеликі для передачі за "
"значенням. Це також відомо як *передача параметрів за посиланням*."

#: ../../library/ctypes.rst:571
msgid ""
":mod:`ctypes` exports the :func:`byref` function which is used to pass "
"parameters by reference.  The same effect can be achieved with the :func:"
"`pointer` function, although :func:`pointer` does a lot more work since it "
"constructs a real pointer object, so it is faster to use :func:`byref` if "
"you don't need the pointer object in Python itself::"
msgstr ""
":mod:`ctypes` експортує функцію :func:`byref`, яка використовується для "
"передачі параметрів за посиланням. Такого ж ефекту можна досягти за "
"допомогою функції :func:`pointer`, хоча :func:`pointer` виконує набагато "
"більше роботи, оскільки створює справжній об’єкт-вказівник, тому "
"використовувати :func:`byref` швидше не потрібен об’єкт покажчика в самому "
"Python::"

#: ../../library/ctypes.rst:577
msgid ""
">>> i = c_int()\n"
">>> f = c_float()\n"
">>> s = create_string_buffer(b'\\000' * 32)\n"
">>> print(i.value, f.value, repr(s.value))\n"
"0 0.0 b''\n"
">>> libc.sscanf(b\"1 3.14 Hello\", b\"%d %f %s\",\n"
"...             byref(i), byref(f), s)\n"
"3\n"
">>> print(i.value, f.value, repr(s.value))\n"
"1 3.1400001049 b'Hello'\n"
">>>"
msgstr ""
">>> i = c_int()\n"
">>> f = c_float()\n"
">>> s = create_string_buffer(b'\\000' * 32)\n"
">>> print(i.value, f.value, repr(s.value))\n"
"0 0.0 b''\n"
">>> libc.sscanf(b\"1 3.14 Hello\", b\"%d %f %s\",\n"
"...             byref(i), byref(f), s)\n"
"3\n"
">>> print(i.value, f.value, repr(s.value))\n"
"1 3.1400001049 b'Hello'\n"
">>>"

#: ../../library/ctypes.rst:593
msgid "Structures and unions"
msgstr "Estruturas e uniões"

#: ../../library/ctypes.rst:595
msgid ""
"Structures and unions must derive from the :class:`Structure` and :class:"
"`Union` base classes which are defined in the :mod:`ctypes` module. Each "
"subclass must define a :attr:`~Structure._fields_` attribute.  :attr:`!"
"_fields_` must be a list of *2-tuples*, containing a *field name* and a "
"*field type*."
msgstr ""
"Структуры и объединения должны быть производными от базовых классов :class:"
"`Structure` и :class:`Union`, которые определены в модуле :mod:`ctypes`. "
"Каждый подкласс должен определить атрибут :attr:`~Structure._fields_`. :attr:"
"`!_fields_` должен быть списком *2-кортежей*, содержащим *имя поля* и *тип "
"поля*."

#: ../../library/ctypes.rst:600
msgid ""
"The field type must be a :mod:`ctypes` type like :class:`c_int`, or any "
"other derived :mod:`ctypes` type: structure, union, array, pointer."
msgstr ""
"Тип поля має бути типу :mod:`ctypes`, наприклад :class:`c_int`, або будь-"
"якого іншого похідного типу :mod:`ctypes`: структура, об’єднання, масив, "
"покажчик."

#: ../../library/ctypes.rst:603
msgid ""
"Here is a simple example of a POINT structure, which contains two integers "
"named *x* and *y*, and also shows how to initialize a structure in the "
"constructor::"
msgstr ""
"Ось простий приклад структури POINT, яка містить два цілі числа з іменами "
"*x* і *y*, а також показує, як ініціалізувати структуру в конструкторі::"

#: ../../library/ctypes.rst:606
msgid ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = [(\"x\", c_int),\n"
"...                 (\"y\", c_int)]\n"
"...\n"
">>> point = POINT(10, 20)\n"
">>> print(point.x, point.y)\n"
"10 20\n"
">>> point = POINT(y=5)\n"
">>> print(point.x, point.y)\n"
"0 5\n"
">>> POINT(1, 2, 3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: too many initializers\n"
">>>"
msgstr ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = [(\"x\", c_int),\n"
"...                 (\"y\", c_int)]\n"
"...\n"
">>> point = POINT(10, 20)\n"
">>> print(point.x, point.y)\n"
"10 20\n"
">>> point = POINT(y=5)\n"
">>> print(point.x, point.y)\n"
"0 5\n"
">>> POINT(1, 2, 3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: too many initializers\n"
">>>"

#: ../../library/ctypes.rst:623
msgid ""
"You can, however, build much more complicated structures.  A structure can "
"itself contain other structures by using a structure as a field type."
msgstr ""
"Однак можна будувати набагато складніші конструкції. Структура може сама "
"містити інші структури, використовуючи структуру як тип поля."

#: ../../library/ctypes.rst:626
msgid ""
"Here is a RECT structure which contains two POINTs named *upperleft* and "
"*lowerright*::"
msgstr ""
"Ось структура RECT, яка містить дві ТОЧКИ з іменами *upperleft* і "
"*lowerright*::"

#: ../../library/ctypes.rst:629
msgid ""
">>> class RECT(Structure):\n"
"...     _fields_ = [(\"upperleft\", POINT),\n"
"...                 (\"lowerright\", POINT)]\n"
"...\n"
">>> rc = RECT(point)\n"
">>> print(rc.upperleft.x, rc.upperleft.y)\n"
"0 5\n"
">>> print(rc.lowerright.x, rc.lowerright.y)\n"
"0 0\n"
">>>"
msgstr ""
">>> class RECT(Structure):\n"
"...     _fields_ = [(\"upperleft\", POINT),\n"
"...                 (\"lowerright\", POINT)]\n"
"...\n"
">>> rc = RECT(point)\n"
">>> print(rc.upperleft.x, rc.upperleft.y)\n"
"0 5\n"
">>> print(rc.lowerright.x, rc.lowerright.y)\n"
"0 0\n"
">>>"

#: ../../library/ctypes.rst:640
msgid ""
"Nested structures can also be initialized in the constructor in several "
"ways::"
msgstr ""
"Вкладені структури також можна ініціалізувати в конструкторі кількома "
"способами:"

#: ../../library/ctypes.rst:642
msgid ""
">>> r = RECT(POINT(1, 2), POINT(3, 4))\n"
">>> r = RECT((1, 2), (3, 4))"
msgstr ""
">>> r = RECT(POINT(1, 2), POINT(3, 4))\n"
">>> r = RECT((1, 2), (3, 4))"

#: ../../library/ctypes.rst:645
msgid ""
"Field :term:`descriptor`\\s can be retrieved from the *class*, they are "
"useful for debugging because they can provide useful information::"
msgstr ""
"Поля :term:`descriptor`\\s можна отримати з *класу*, вони корисні для "
"налагодження, оскільки можуть надати корисну інформацію::"

#: ../../library/ctypes.rst:648
msgid ""
">>> print(POINT.x)\n"
"<Field type=c_long, ofs=0, size=4>\n"
">>> print(POINT.y)\n"
"<Field type=c_long, ofs=4, size=4>\n"
">>>"
msgstr ""
">>> print(POINT.x)\n"
"<Field type=c_long, ofs=0, size=4>\n"
">>> print(POINT.y)\n"
"<Field type=c_long, ofs=4, size=4>\n"
">>>"

#: ../../library/ctypes.rst:659
msgid ""
":mod:`ctypes` does not support passing unions or structures with bit-fields "
"to functions by value.  While this may work on 32-bit x86, it's not "
"guaranteed by the library to work in the general case.  Unions and "
"structures with bit-fields should always be passed to functions by pointer."
msgstr ""
":mod:`ctypes` не підтримує передачу об’єднань або структур із бітовими "
"полями функціям за значенням. Хоча це може працювати на 32-розрядних x86, "
"бібліотека не гарантує роботу в загальному випадку. Об’єднання та структури "
"з бітовими полями слід завжди передавати функціям за вказівником."

#: ../../library/ctypes.rst:665
msgid "Structure/union alignment and byte order"
msgstr "Вирівнювання структури/об'єднання та порядок байтів"

#: ../../library/ctypes.rst:667
msgid ""
"By default, Structure and Union fields are aligned in the same way the C "
"compiler does it. It is possible to override this behavior by specifying a :"
"attr:`~Structure._pack_` class attribute in the subclass definition. This "
"must be set to a positive integer and specifies the maximum alignment for "
"the fields. This is what ``#pragma pack(n)`` also does in MSVC."
msgstr ""

#: ../../library/ctypes.rst:673
msgid ""
":mod:`ctypes` uses the native byte order for Structures and Unions.  To "
"build structures with non-native byte order, you can use one of the :class:"
"`BigEndianStructure`, :class:`LittleEndianStructure`, :class:"
"`BigEndianUnion`, and :class:`LittleEndianUnion` base classes.  These "
"classes cannot contain pointer fields."
msgstr ""
":mod:`ctypes` використовує власний порядок байтів для структур і об’єднань. "
"Щоб створити структури з невласним порядком байтів, ви можете "
"використовувати один із базових класів :class:`BigEndianStructure`, :class:"
"`LittleEndianStructure`, :class:`BigEndianUnion` і :class:"
"`LittleEndianUnion`. Ці класи не можуть містити поля вказівників."

#: ../../library/ctypes.rst:683
msgid "Bit fields in structures and unions"
msgstr "Бітові поля в структурах і об'єднаннях"

#: ../../library/ctypes.rst:685
msgid ""
"It is possible to create structures and unions containing bit fields. Bit "
"fields are only possible for integer fields, the bit width is specified as "
"the third item in the :attr:`~Structure._fields_` tuples::"
msgstr ""
"Можно создавать структуры и объединения, содержащие битовые поля. Битовые "
"поля возможны только для целочисленных полей, разрядность указывается как "
"третий элемент в кортежах :attr:`~Structure._fields_`::"

#: ../../library/ctypes.rst:689
msgid ""
">>> class Int(Structure):\n"
"...     _fields_ = [(\"first_16\", c_int, 16),\n"
"...                 (\"second_16\", c_int, 16)]\n"
"...\n"
">>> print(Int.first_16)\n"
"<Field type=c_long, ofs=0:0, bits=16>\n"
">>> print(Int.second_16)\n"
"<Field type=c_long, ofs=0:16, bits=16>\n"
">>>"
msgstr ""
">>> class Int(Structure):\n"
"...     _fields_ = [(\"first_16\", c_int, 16),\n"
"...                 (\"second_16\", c_int, 16)]\n"
"...\n"
">>> print(Int.first_16)\n"
"<Field type=c_long, ofs=0:0, bits=16>\n"
">>> print(Int.second_16)\n"
"<Field type=c_long, ofs=0:16, bits=16>\n"
">>>"

#: ../../library/ctypes.rst:703
msgid "Arrays"
msgstr "Arrays"

#: ../../library/ctypes.rst:705
msgid ""
"Arrays are sequences, containing a fixed number of instances of the same "
"type."
msgstr ""
"Масиви - це послідовності, що містять фіксовану кількість екземплярів одного "
"типу."

#: ../../library/ctypes.rst:707
msgid ""
"The recommended way to create array types is by multiplying a data type with "
"a positive integer::"
msgstr ""
"Рекомендований спосіб створення типів масивів – це множення типу даних на "
"додатне ціле:"

#: ../../library/ctypes.rst:710
msgid "TenPointsArrayType = POINT * 10"
msgstr "TenPointsArrayType = POINT * 10"

#: ../../library/ctypes.rst:712
msgid ""
"Here is an example of a somewhat artificial data type, a structure "
"containing 4 POINTs among other stuff::"
msgstr ""
"Ось приклад дещо штучного типу даних, структура, яка містить 4 ТОЧКИ серед "
"іншого:"

#: ../../library/ctypes.rst:715
msgid ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = (\"x\", c_int), (\"y\", c_int)\n"
"...\n"
">>> class MyStruct(Structure):\n"
"...     _fields_ = [(\"a\", c_int),\n"
"...                 (\"b\", c_float),\n"
"...                 (\"point_array\", POINT * 4)]\n"
">>>\n"
">>> print(len(MyStruct().point_array))\n"
"4\n"
">>>"
msgstr ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = (\"x\", c_int), (\"y\", c_int)\n"
"...\n"
">>> class MyStruct(Structure):\n"
"...     _fields_ = [(\"a\", c_int),\n"
"...                 (\"b\", c_float),\n"
"...                 (\"point_array\", POINT * 4)]\n"
">>>\n"
">>> print(len(MyStruct().point_array))\n"
"4\n"
">>>"

#: ../../library/ctypes.rst:728
msgid "Instances are created in the usual way, by calling the class::"
msgstr "Екземпляри створюються звичайним способом за допомогою виклику класу::"

#: ../../library/ctypes.rst:730
msgid ""
"arr = TenPointsArrayType()\n"
"for pt in arr:\n"
"    print(pt.x, pt.y)"
msgstr ""
"arr = TenPointsArrayType()\n"
"for pt in arr:\n"
"    print(pt.x, pt.y)"

#: ../../library/ctypes.rst:734
msgid ""
"The above code print a series of ``0 0`` lines, because the array contents "
"is initialized to zeros."
msgstr ""
"Наведений вище код друкує серію рядків ``0 0``, оскільки вміст масиву "
"ініціалізовано нулями."

#: ../../library/ctypes.rst:737
msgid "Initializers of the correct type can also be specified::"
msgstr "Також можна вказати ініціалізатори правильного типу:"

#: ../../library/ctypes.rst:739
msgid ""
">>> from ctypes import *\n"
">>> TenIntegers = c_int * 10\n"
">>> ii = TenIntegers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n"
">>> print(ii)\n"
"<c_long_Array_10 object at 0x...>\n"
">>> for i in ii: print(i, end=\" \")\n"
"...\n"
"1 2 3 4 5 6 7 8 9 10\n"
">>>"
msgstr ""
">>> from ctypes import *\n"
">>> TenIntegers = c_int * 10\n"
">>> ii = TenIntegers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n"
">>> print(ii)\n"
"<c_long_Array_10 object at 0x...>\n"
">>> for i in ii: print(i, end=\" \")\n"
"...\n"
"1 2 3 4 5 6 7 8 9 10\n"
">>>"

#: ../../library/ctypes.rst:753
msgid "Pointers"
msgstr "Ponteiros"

#: ../../library/ctypes.rst:755
msgid ""
"Pointer instances are created by calling the :func:`pointer` function on a :"
"mod:`ctypes` type::"
msgstr ""
"Екземпляри вказівника створюються шляхом виклику функції :func:`pointer` для "
"типу :mod:`ctypes`::"

#: ../../library/ctypes.rst:758
msgid ""
">>> from ctypes import *\n"
">>> i = c_int(42)\n"
">>> pi = pointer(i)\n"
">>>"
msgstr ""
">>> from ctypes import *\n"
">>> i = c_int(42)\n"
">>> pi = pointer(i)\n"
">>>"

#: ../../library/ctypes.rst:763
msgid ""
"Pointer instances have a :attr:`~_Pointer.contents` attribute which returns "
"the object to which the pointer points, the ``i`` object above::"
msgstr ""
"Екземпляри вказівника мають атрибут :attr:`~_Pointer.contents`, який "
"повертає об’єкт, на який вказує вказівник, об’єкт ``i`` вище::"

#: ../../library/ctypes.rst:766
msgid ""
">>> pi.contents\n"
"c_long(42)\n"
">>>"
msgstr ""
">>> pi.contents\n"
"c_long(42)\n"
">>>"

#: ../../library/ctypes.rst:770
msgid ""
"Note that :mod:`ctypes` does not have OOR (original object return), it "
"constructs a new, equivalent object each time you retrieve an attribute::"
msgstr ""
"Зауважте, що :mod:`ctypes` не має OOR (повернення вихідного об’єкта), він "
"створює новий, еквівалентний об’єкт кожного разу, коли ви отримуєте атрибут::"

#: ../../library/ctypes.rst:773
msgid ""
">>> pi.contents is i\n"
"False\n"
">>> pi.contents is pi.contents\n"
"False\n"
">>>"
msgstr ""
">>> pi.contents is i\n"
"False\n"
">>> pi.contents is pi.contents\n"
"False\n"
">>>"

#: ../../library/ctypes.rst:779
msgid ""
"Assigning another :class:`c_int` instance to the pointer's contents "
"attribute would cause the pointer to point to the memory location where this "
"is stored::"
msgstr ""
"Призначення іншого екземпляра :class:`c_int` атрибуту contents вказівника "
"призведе до того, що вказівник вказуватиме на місце пам’яті, де це "
"зберігається::"

#: ../../library/ctypes.rst:782
msgid ""
">>> i = c_int(99)\n"
">>> pi.contents = i\n"
">>> pi.contents\n"
"c_long(99)\n"
">>>"
msgstr ""
">>> i = c_int(99)\n"
">>> pi.contents = i\n"
">>> pi.contents\n"
"c_long(99)\n"
">>>"

#: ../../library/ctypes.rst:791
msgid "Pointer instances can also be indexed with integers::"
msgstr "Екземпляри вказівників також можна індексувати цілими числами::"

#: ../../library/ctypes.rst:793
msgid ""
">>> pi[0]\n"
"99\n"
">>>"
msgstr ""
">>> pi[0]\n"
"99\n"
">>>"

#: ../../library/ctypes.rst:797
msgid "Assigning to an integer index changes the pointed to value::"
msgstr "Присвоєння цілочисельному індексу змінює вказане значення::"

#: ../../library/ctypes.rst:799
msgid ""
">>> print(i)\n"
"c_long(99)\n"
">>> pi[0] = 22\n"
">>> print(i)\n"
"c_long(22)\n"
">>>"
msgstr ""
">>> print(i)\n"
"c_long(99)\n"
">>> pi[0] = 22\n"
">>> print(i)\n"
"c_long(22)\n"
">>>"

#: ../../library/ctypes.rst:806
msgid ""
"It is also possible to use indexes different from 0, but you must know what "
"you're doing, just as in C: You can access or change arbitrary memory "
"locations. Generally you only use this feature if you receive a pointer from "
"a C function, and you *know* that the pointer actually points to an array "
"instead of a single item."
msgstr ""
"Також можна використовувати індекси, відмінні від 0, але ви повинні знати, "
"що ви робите, так само як у C: ви можете отримати доступ або змінити "
"довільні місця пам'яті. Зазвичай ви використовуєте цю функцію, лише якщо "
"отримуєте вказівник від функції C і *знаєте*, що вказівник насправді вказує "
"на масив, а не на один елемент."

#: ../../library/ctypes.rst:812
msgid ""
"Behind the scenes, the :func:`pointer` function does more than simply create "
"pointer instances, it has to create pointer *types* first. This is done with "
"the :func:`POINTER` function, which accepts any :mod:`ctypes` type, and "
"returns a new type::"
msgstr ""
"За лаштунками функція :func:`pointer` робить більше, ніж просто створює "
"екземпляри вказівників, вона повинна спочатку створити *типи* вказівників. "
"Це робиться за допомогою функції :func:`POINTER`, яка приймає будь-який тип :"
"mod:`ctypes` і повертає новий тип::"

#: ../../library/ctypes.rst:817
msgid ""
">>> PI = POINTER(c_int)\n"
">>> PI\n"
"<class 'ctypes.LP_c_long'>\n"
">>> PI(42)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: expected c_long instead of int\n"
">>> PI(c_int(42))\n"
"<ctypes.LP_c_long object at 0x...>\n"
">>>"
msgstr ""
">>> PI = POINTER(c_int)\n"
">>> PI\n"
"<class 'ctypes.LP_c_long'>\n"
">>> PI(42)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: expected c_long instead of int\n"
">>> PI(c_int(42))\n"
"<ctypes.LP_c_long object at 0x...>\n"
">>>"

#: ../../library/ctypes.rst:828
msgid ""
"Calling the pointer type without an argument creates a ``NULL`` pointer. "
"``NULL`` pointers have a ``False`` boolean value::"
msgstr ""
"Виклик типу покажчика без аргументу створює покажчик ``NULL``. Покажчики "
"``NULL`` мають логічне значення ``False``::"

#: ../../library/ctypes.rst:831
msgid ""
">>> null_ptr = POINTER(c_int)()\n"
">>> print(bool(null_ptr))\n"
"False\n"
">>>"
msgstr ""
">>> null_ptr = POINTER(c_int)()\n"
">>> print(bool(null_ptr))\n"
"False\n"
">>>"

#: ../../library/ctypes.rst:836
msgid ""
":mod:`ctypes` checks for ``NULL`` when dereferencing pointers (but "
"dereferencing invalid non-\\ ``NULL`` pointers would crash Python)::"
msgstr ""
":mod:`ctypes` перевіряє ``NULL`` під час розіменування вказівників (але "
"розіменування недійсних не\\ ``NULL`` вказівників призведе до збою Python)::"

#: ../../library/ctypes.rst:839
msgid ""
">>> null_ptr[0]\n"
"Traceback (most recent call last):\n"
"    ....\n"
"ValueError: NULL pointer access\n"
">>>\n"
"\n"
">>> null_ptr[0] = 1234\n"
"Traceback (most recent call last):\n"
"    ....\n"
"ValueError: NULL pointer access\n"
">>>"
msgstr ""
">>> null_ptr[0]\n"
"Traceback (most recent call last):\n"
"    ....\n"
"ValueError: NULL pointer access\n"
">>>\n"
"\n"
">>> null_ptr[0] = 1234\n"
"Traceback (most recent call last):\n"
"    ....\n"
"ValueError: NULL pointer access\n"
">>>"

#: ../../library/ctypes.rst:855
msgid "Type conversions"
msgstr "Conversão de Tipos"

#: ../../library/ctypes.rst:857
msgid ""
"Usually, ctypes does strict type checking.  This means, if you have "
"``POINTER(c_int)`` in the :attr:`~_CFuncPtr.argtypes` list of a function or "
"as the type of a member field in a structure definition, only instances of "
"exactly the same type are accepted.  There are some exceptions to this rule, "
"where ctypes accepts other objects.  For example, you can pass compatible "
"array instances instead of pointer types.  So, for ``POINTER(c_int)``, "
"ctypes accepts an array of c_int::"
msgstr ""
"Обычно ctypes выполняет строгую проверку типов. Это означает, что если у вас "
"есть POINTER(c_int) в списке :attr:`~_CFuncPtr.argtypes` функции или в "
"качестве типа поля-члена в определении структуры, будут использоваться "
"только экземпляры точно такого же типа. принял. Есть некоторые исключения из "
"этого правила, когда ctypes принимает другие объекты. Например, вы можете "
"передавать совместимые экземпляры массива вместо типов указателей. Итак, для "
"POINTER(c_int) ctypes принимает массив c_int::"

#: ../../library/ctypes.rst:864
msgid ""
">>> class Bar(Structure):\n"
"...     _fields_ = [(\"count\", c_int), (\"values\", POINTER(c_int))]\n"
"...\n"
">>> bar = Bar()\n"
">>> bar.values = (c_int * 3)(1, 2, 3)\n"
">>> bar.count = 3\n"
">>> for i in range(bar.count):\n"
"...     print(bar.values[i])\n"
"...\n"
"1\n"
"2\n"
"3\n"
">>>"
msgstr ""
">>> class Bar(Structure):\n"
"...     _fields_ = [(\"count\", c_int), (\"values\", POINTER(c_int))]\n"
"...\n"
">>> bar = Bar()\n"
">>> bar.values = (c_int * 3)(1, 2, 3)\n"
">>> bar.count = 3\n"
">>> for i in range(bar.count):\n"
"...     print(bar.values[i])\n"
"...\n"
"1\n"
"2\n"
"3\n"
">>>"

#: ../../library/ctypes.rst:878
msgid ""
"In addition, if a function argument is explicitly declared to be a pointer "
"type (such as ``POINTER(c_int)``) in :attr:`~_CFuncPtr.argtypes`, an object "
"of the pointed type (``c_int`` in this case) can be passed to the function.  "
"ctypes will apply the required :func:`byref` conversion in this case "
"automatically."
msgstr ""
"Кроме того, если аргумент функции явно объявлен как тип указателя (например, "
"``POINTER(c_int)``) в :attr:`~_CFuncPtr.argtypes`, объект указанного типа "
"(``c_int`` в данном случае) можно передать в функцию. В этом случае ctypes "
"автоматически применит необходимое преобразование :func:`byref`."

#: ../../library/ctypes.rst:883
msgid "To set a POINTER type field to ``NULL``, you can assign ``None``::"
msgstr ""
"Щоб встановити для поля типу POINTER значення ``NULL``, ви можете призначити "
"``None``::"

#: ../../library/ctypes.rst:885
msgid ""
">>> bar.values = None\n"
">>>"
msgstr ""
">>> bar.values = None\n"
">>>"

#: ../../library/ctypes.rst:890
msgid ""
"Sometimes you have instances of incompatible types.  In C, you can cast one "
"type into another type.  :mod:`ctypes` provides a :func:`cast` function "
"which can be used in the same way.  The ``Bar`` structure defined above "
"accepts ``POINTER(c_int)`` pointers or :class:`c_int` arrays for its "
"``values`` field, but not instances of other types::"
msgstr ""
"Іноді у вас є екземпляри несумісних типів. У C ви можете привести один тип "
"до іншого. :mod:`ctypes` надає функцію :func:`cast`, яку можна "
"використовувати таким же чином. Структура ``Bar``, визначена вище, приймає "
"покажчики ``POINTER(c_int)`` або :class:`c_int` масиви для свого поля "
"``values``, але не примірники інших типів::"

#: ../../library/ctypes.rst:896
msgid ""
">>> bar.values = (c_byte * 4)()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: incompatible types, c_byte_Array_4 instance instead of LP_c_long "
"instance\n"
">>>"
msgstr ""
">>> bar.values = (c_byte * 4)()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: incompatible types, c_byte_Array_4 instance instead of LP_c_long "
"instance\n"
">>>"

#: ../../library/ctypes.rst:902
msgid "For these cases, the :func:`cast` function is handy."
msgstr "Для цих випадків зручна функція :func:`cast`."

#: ../../library/ctypes.rst:904
msgid ""
"The :func:`cast` function can be used to cast a ctypes instance into a "
"pointer to a different ctypes data type.  :func:`cast` takes two parameters, "
"a ctypes object that is or can be converted to a pointer of some kind, and a "
"ctypes pointer type.  It returns an instance of the second argument, which "
"references the same memory block as the first argument::"
msgstr ""
"Функцію :func:`cast` можна використати для приведення екземпляра ctypes до "
"покажчика на інший тип даних ctypes. :func:`cast` приймає два параметри: "
"об’єкт ctypes, який є чи може бути перетворений на певний вказівник, і тип "
"вказівника ctypes. Він повертає екземпляр другого аргументу, який "
"посилається на той самий блок пам’яті, що й перший аргумент::"

#: ../../library/ctypes.rst:910
msgid ""
">>> a = (c_byte * 4)()\n"
">>> cast(a, POINTER(c_int))\n"
"<ctypes.LP_c_long object at ...>\n"
">>>"
msgstr ""
">>> а = (c_byte * 4)() >>> приведение(а, УКАЗАТЕЛЬ(c_int)) <объект ctypes."
"LP_c_long в ...> >>>"

#: ../../library/ctypes.rst:915
msgid ""
"So, :func:`cast` can be used to assign to the ``values`` field of ``Bar`` "
"the structure::"
msgstr ""
"Отже, :func:`cast` можна використовувати для призначення полю ``values`` "
"``Bar`` структури::"

#: ../../library/ctypes.rst:918
msgid ""
">>> bar = Bar()\n"
">>> bar.values = cast((c_byte * 4)(), POINTER(c_int))\n"
">>> print(bar.values[0])\n"
"0\n"
">>>"
msgstr ""
">>> bar = Bar()\n"
">>> bar.values = cast((c_byte * 4)(), POINTER(c_int))\n"
">>> print(bar.values[0])\n"
"0\n"
">>>"

#: ../../library/ctypes.rst:928
msgid "Incomplete Types"
msgstr "Tipos Incompletos"

#: ../../library/ctypes.rst:930
msgid ""
"*Incomplete Types* are structures, unions or arrays whose members are not "
"yet specified. In C, they are specified by forward declarations, which are "
"defined later::"
msgstr ""
"*Неповні типи* — це структури, об’єднання або масиви, члени яких ще не "
"визначено. У C вони визначені прямими оголошеннями, які визначені пізніше:"

#: ../../library/ctypes.rst:934
msgid ""
"struct cell; /* forward declaration */\n"
"\n"
"struct cell {\n"
"    char *name;\n"
"    struct cell *next;\n"
"};"
msgstr ""
"struct cell; /* forward declaration */\n"
"\n"
"struct cell {\n"
"    char *name;\n"
"    struct cell *next;\n"
"};"

#: ../../library/ctypes.rst:941
msgid ""
"The straightforward translation into ctypes code would be this, but it does "
"not work::"
msgstr "Прямий переклад у код ctypes буде таким, але він не працює:"

#: ../../library/ctypes.rst:944
msgid ""
">>> class cell(Structure):\n"
"...     _fields_ = [(\"name\", c_char_p),\n"
"...                 (\"next\", POINTER(cell))]\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 2, in cell\n"
"NameError: name 'cell' is not defined\n"
">>>"
msgstr ""
">>> class cell(Structure):\n"
"...     _fields_ = [(\"name\", c_char_p),\n"
"...                 (\"next\", POINTER(cell))]\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 2, in cell\n"
"NameError: name 'cell' is not defined\n"
">>>"

#: ../../library/ctypes.rst:954
msgid ""
"because the new ``class cell`` is not available in the class statement "
"itself. In :mod:`ctypes`, we can define the ``cell`` class and set the :attr:"
"`~Structure._fields_` attribute later, after the class statement::"
msgstr ""
"потому что новая ``ячейка класса`` недоступна в самом операторе класса. В :"
"mod:`ctypes` мы можем определить класс ``cell`` и установить атрибут :attr:"
"`~Structure._fields_` позже, после оператора класса::"

#: ../../library/ctypes.rst:958
msgid ""
">>> from ctypes import *\n"
">>> class cell(Structure):\n"
"...     pass\n"
"...\n"
">>> cell._fields_ = [(\"name\", c_char_p),\n"
"...                  (\"next\", POINTER(cell))]\n"
">>>"
msgstr ""
">>> from ctypes import *\n"
">>> class cell(Structure):\n"
"...     pass\n"
"...\n"
">>> cell._fields_ = [(\"name\", c_char_p),\n"
"...                  (\"next\", POINTER(cell))]\n"
">>>"

#: ../../library/ctypes.rst:966
msgid ""
"Let's try it. We create two instances of ``cell``, and let them point to "
"each other, and finally follow the pointer chain a few times::"
msgstr ""
"Давайте спробуємо. Ми створюємо два екземпляри ``cell`` і дозволяємо їм "
"вказувати один на одного, і, нарешті, слідуємо за ланцюжком вказівників "
"кілька разів::"

#: ../../library/ctypes.rst:969
msgid ""
">>> c1 = cell()\n"
">>> c1.name = b\"foo\"\n"
">>> c2 = cell()\n"
">>> c2.name = b\"bar\"\n"
">>> c1.next = pointer(c2)\n"
">>> c2.next = pointer(c1)\n"
">>> p = c1\n"
">>> for i in range(8):\n"
"...     print(p.name, end=\" \")\n"
"...     p = p.next[0]\n"
"...\n"
"foo bar foo bar foo bar foo bar\n"
">>>"
msgstr ""
">>> c1 = cell()\n"
">>> c1.name = b\"foo\"\n"
">>> c2 = cell()\n"
">>> c2.name = b\"bar\"\n"
">>> c1.next = pointer(c2)\n"
">>> c2.next = pointer(c1)\n"
">>> p = c1\n"
">>> for i in range(8):\n"
"...     print(p.name, end=\" \")\n"
"...     p = p.next[0]\n"
"...\n"
"foo bar foo bar foo bar foo bar\n"
">>>"

#: ../../library/ctypes.rst:987
msgid "Callback functions"
msgstr "Funções Callbacks"

#: ../../library/ctypes.rst:989
msgid ""
":mod:`ctypes` allows creating C callable function pointers from Python "
"callables. These are sometimes called *callback functions*."
msgstr ""
":mod:`ctypes` дозволяє створювати вказівники на функції C із викликів "
"Python. Іноді їх називають *функціями зворотного виклику*."

#: ../../library/ctypes.rst:992
msgid ""
"First, you must create a class for the callback function. The class knows "
"the calling convention, the return type, and the number and types of "
"arguments this function will receive."
msgstr ""
"По-перше, ви повинні створити клас для функції зворотного виклику. Клас знає "
"угоду про виклики, тип повернення, а також кількість і типи аргументів, які "
"ця функція отримає."

#: ../../library/ctypes.rst:996
msgid ""
"The :func:`CFUNCTYPE` factory function creates types for callback functions "
"using the ``cdecl`` calling convention. On Windows, the :func:`WINFUNCTYPE` "
"factory function creates types for callback functions using the ``stdcall`` "
"calling convention."
msgstr ""
"Фабрична функція :func:`CFUNCTYPE` створює типи для функцій зворотного "
"виклику за допомогою угоди про виклики ``cdecl``. У Windows фабрична "
"функція :func:`WINFUNCTYPE` створює типи для функцій зворотного виклику за "
"допомогою угоди про виклики ``stdcall``."

#: ../../library/ctypes.rst:1001
msgid ""
"Both of these factory functions are called with the result type as first "
"argument, and the callback functions expected argument types as the "
"remaining arguments."
msgstr ""
"Обидві ці фабричні функції викликаються з типом результату як першим "
"аргументом, а функції зворотного виклику – очікуваними типами аргументів як "
"рештою аргументів."

#: ../../library/ctypes.rst:1005
msgid ""
"I will present an example here which uses the standard C library's :c:func:`!"
"qsort` function, that is used to sort items with the help of a callback "
"function.  :c:func:`!qsort` will be used to sort an array of integers::"
msgstr ""
"Здесь я представлю пример, в котором используется функция :c:func:`!qsort` "
"стандартной библиотеки C, которая используется для сортировки элементов с "
"помощью функции обратного вызова. :c:func:`!qsort` будет использоваться для "
"сортировки массива целых чисел::"

#: ../../library/ctypes.rst:1009
msgid ""
">>> IntArray5 = c_int * 5\n"
">>> ia = IntArray5(5, 1, 7, 33, 99)\n"
">>> qsort = libc.qsort\n"
">>> qsort.restype = None\n"
">>>"
msgstr ""
">>> IntArray5 = c_int * 5\n"
">>> ia = IntArray5(5, 1, 7, 33, 99)\n"
">>> qsort = libc.qsort\n"
">>> qsort.restype = None\n"
">>>"

#: ../../library/ctypes.rst:1015
msgid ""
":func:`!qsort` must be called with a pointer to the data to sort, the number "
"of items in the data array, the size of one item, and a pointer to the "
"comparison function, the callback. The callback will then be called with two "
"pointers to items, and it must return a negative integer if the first item "
"is smaller than the second, a zero if they are equal, and a positive integer "
"otherwise."
msgstr ""
":func:`!qsort` должен вызываться с указателем на данные для сортировки, "
"количество элементов в массиве данных, размер одного элемента и указатель на "
"функцию сравнения, обратный вызов. Затем будет вызван обратный вызов с двумя "
"указателями на элементы, и он должен вернуть отрицательное целое число, если "
"первый элемент меньше второго, ноль, если они равны, и положительное целое "
"число в противном случае."

#: ../../library/ctypes.rst:1021
msgid ""
"So our callback function receives pointers to integers, and must return an "
"integer. First we create the ``type`` for the callback function::"
msgstr ""
"Таким чином, наша функція зворотного виклику отримує покажчики на цілі числа "
"та повинна повертати ціле число. Спочатку ми створюємо ``type`` для функції "
"зворотного виклику::"

#: ../../library/ctypes.rst:1024
msgid ""
">>> CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n"
">>>"
msgstr ""
">>> CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n"
">>>"

#: ../../library/ctypes.rst:1027
msgid ""
"To get started, here is a simple callback that shows the values it gets "
"passed::"
msgstr ""
"Щоб почати, ось простий зворотний виклик, який показує значення, які він "
"отримує:"

#: ../../library/ctypes.rst:1030
msgid ""
">>> def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a[0], b[0])\n"
"...     return 0\n"
"...\n"
">>> cmp_func = CMPFUNC(py_cmp_func)\n"
">>>"
msgstr ""
">>> def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a[0], b[0])\n"
"...     return 0\n"
"...\n"
">>> cmp_func = CMPFUNC(py_cmp_func)\n"
">>>"

#: ../../library/ctypes.rst:1037
msgid "The result::"
msgstr "O resultado::"

#: ../../library/ctypes.rst:1039
msgid ""
">>> qsort(ia, len(ia), sizeof(c_int), cmp_func)\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 5 7\n"
"py_cmp_func 1 7\n"
">>>"
msgstr ""
">>> qsort(ia, len(ia), sizeof(c_int), cmp_func)\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 5 7\n"
"py_cmp_func 1 7\n"
">>>"

#: ../../library/ctypes.rst:1047
msgid "Now we can actually compare the two items and return a useful result::"
msgstr ""
"Тепер ми фактично можемо порівняти два елементи та повернути корисний "
"результат:"

#: ../../library/ctypes.rst:1049
msgid ""
">>> def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a[0], b[0])\n"
"...     return a[0] - b[0]\n"
"...\n"
">>>\n"
">>> qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func))\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 1 7\n"
"py_cmp_func 5 7\n"
">>>"
msgstr ""
">>> def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a[0], b[0])\n"
"...     return a[0] - b[0]\n"
"...\n"
">>>\n"
">>> qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func))\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 1 7\n"
"py_cmp_func 5 7\n"
">>>"

#: ../../library/ctypes.rst:1062
msgid "As we can easily check, our array is sorted now::"
msgstr "Як ми можемо легко перевірити, наш масив зараз відсортовано::"

#: ../../library/ctypes.rst:1064
msgid ""
">>> for i in ia: print(i, end=\" \")\n"
"...\n"
"1 5 7 33 99\n"
">>>"
msgstr ""
">>> for i in ia: print(i, end=\" \")\n"
"...\n"
"1 5 7 33 99\n"
">>>"

#: ../../library/ctypes.rst:1069
msgid ""
"The function factories can be used as decorator factories, so we may as well "
"write::"
msgstr ""
"Фабрики функцій можна використовувати як фабрики декораторів, тому ми також "
"можемо написати::"

#: ../../library/ctypes.rst:1072
msgid ""
">>> @CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n"
"... def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a[0], b[0])\n"
"...     return a[0] - b[0]\n"
"...\n"
">>> qsort(ia, len(ia), sizeof(c_int), py_cmp_func)\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 1 7\n"
"py_cmp_func 5 7\n"
">>>"
msgstr ""
">>> @CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n"
"... def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a[0], b[0])\n"
"...     return a[0] - b[0]\n"
"...\n"
">>> qsort(ia, len(ia), sizeof(c_int), py_cmp_func)\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 1 7\n"
"py_cmp_func 5 7\n"
">>>"

#: ../../library/ctypes.rst:1087
msgid ""
"Make sure you keep references to :func:`CFUNCTYPE` objects as long as they "
"are used from C code. :mod:`ctypes` doesn't, and if you don't, they may be "
"garbage collected, crashing your program when a callback is made."
msgstr ""
"Переконайтеся, що ви зберігаєте посилання на об’єкти :func:`CFUNCTYPE`, доки "
"вони використовуються з коду C. :mod:`ctypes` не працює, і якщо ви цього не "
"зробите, вони можуть збиратися як сміття, що призведе до збою вашої програми "
"під час зворотного виклику."

#: ../../library/ctypes.rst:1091
msgid ""
"Also, note that if the callback function is called in a thread created "
"outside of Python's control (e.g. by the foreign code that calls the "
"callback), ctypes creates a new dummy Python thread on every invocation. "
"This behavior is correct for most purposes, but it means that values stored "
"with :class:`threading.local` will *not* survive across different callbacks, "
"even when those calls are made from the same C thread."
msgstr ""
"Також зауважте, що якщо функція зворотнього виклику викликається в потоці, "
"створеному поза контролем Python (наприклад, зовнішнім кодом, який викликає "
"зворотній виклик), ctypes створює новий фіктивний потік Python під час "
"кожного виклику. Така поведінка є правильною для більшості цілей, але це "
"означає, що значення, збережені в :class:`threading.local` *не* збережуться "
"в різних зворотних викликах, навіть якщо ці виклики здійснюються з того "
"самого потоку C."

#: ../../library/ctypes.rst:1101
msgid "Accessing values exported from dlls"
msgstr "Доступ до значень, експортованих із dll"

#: ../../library/ctypes.rst:1103
msgid ""
"Some shared libraries not only export functions, they also export variables. "
"An example in the Python library itself is the :c:data:`Py_Version`, Python "
"runtime version number encoded in a single constant integer."
msgstr ""
"Некоторые общие библиотеки экспортируют не только функции, но и переменные. "
"Примером самой библиотеки Python является :c:data:`Py_Version`, номер версии "
"среды выполнения Python, закодированный в одном постоянном целом числе."

#: ../../library/ctypes.rst:1107
msgid ""
":mod:`ctypes` can access values like this with the :meth:`~_CData.in_dll` "
"class methods of the type.  *pythonapi* is a predefined symbol giving access "
"to the Python C api::"
msgstr ""
":mod:`ctypes` может получить доступ к таким значениям с помощью методов "
"класса :meth:`~_CData.in_dll` этого типа. *pythonapi* — это предопределенный "
"символ, предоставляющий доступ к API Python C::"

#: ../../library/ctypes.rst:1111
msgid ""
">>> version = ctypes.c_int.in_dll(ctypes.pythonapi, \"Py_Version\")\n"
">>> print(hex(version.value))\n"
"0x30c00a0"
msgstr ""
">>> version = ctypes.c_int.in_dll(ctypes.pythonapi, \"Py_Version\")\n"
">>> print(hex(version.value))\n"
"0x30c00a0"

#: ../../library/ctypes.rst:1115
msgid ""
"An extended example which also demonstrates the use of pointers accesses "
"the :c:data:`PyImport_FrozenModules` pointer exported by Python."
msgstr ""
"Розширений приклад, який також демонструє використання покажчиків, "
"звертається до покажчика :c:data:`PyImport_FrozenModules`, експортованого "
"Python."

#: ../../library/ctypes.rst:1118
msgid "Quoting the docs for that value:"
msgstr "Цитування документів для цього значення:"

#: ../../library/ctypes.rst:1120
msgid ""
"This pointer is initialized to point to an array of :c:struct:`_frozen` "
"records, terminated by one whose members are all ``NULL`` or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""
"Este ponteiro é inicializado para apontar para um vetor de registros de :c:"
"struct:`_frozen`, terminado por um cujos membros são todos ``NULL`` ou zero. "
"Quando um módulo congelado é importado, ele é pesquisado nesta tabela. O "
"código de terceiros pode fazer truques com isso para fornecer uma coleção "
"criada dinamicamente de módulos congelados."

#: ../../library/ctypes.rst:1125
msgid ""
"So manipulating this pointer could even prove useful. To restrict the "
"example size, we show only how this table can be read with :mod:`ctypes`::"
msgstr ""
"Тож маніпулювання цим покажчиком може навіть виявитися корисним. Щоб "
"обмежити розмір прикладу, ми показуємо лише те, як цю таблицю можна "
"прочитати за допомогою :mod:`ctypes`::"

#: ../../library/ctypes.rst:1128
msgid ""
">>> from ctypes import *\n"
">>>\n"
">>> class struct_frozen(Structure):\n"
"...     _fields_ = [(\"name\", c_char_p),\n"
"...                 (\"code\", POINTER(c_ubyte)),\n"
"...                 (\"size\", c_int),\n"
"...                 (\"get_code\", POINTER(c_ubyte)),  # Function pointer\n"
"...                ]\n"
"...\n"
">>>"
msgstr ""
">>> from ctypes import *\n"
">>>\n"
">>> class struct_frozen(Structure):\n"
"...     _fields_ = [(\"name\", c_char_p),\n"
"...                 (\"code\", POINTER(c_ubyte)),\n"
"...                 (\"size\", c_int),\n"
"...                 (\"get_code\", POINTER(c_ubyte)),  # Function pointer\n"
"...                ]\n"
"...\n"
">>>"

#: ../../library/ctypes.rst:1139
msgid ""
"We have defined the :c:struct:`_frozen` data type, so we can get the pointer "
"to the table::"
msgstr ""
"Мы определили тип данных :c:struct:`_frozen`, поэтому мы можем получить "
"указатель на таблицу::"

#: ../../library/ctypes.rst:1142
msgid ""
">>> FrozenTable = POINTER(struct_frozen)\n"
">>> table = FrozenTable.in_dll(pythonapi, \"_PyImport_FrozenBootstrap\")\n"
">>>"
msgstr ""
">>> FrozenTable = POINTER(struct_frozen)\n"
">>> table = FrozenTable.in_dll(pythonapi, \"_PyImport_FrozenBootstrap\")\n"
">>>"

#: ../../library/ctypes.rst:1146
msgid ""
"Since ``table`` is a ``pointer`` to the array of ``struct_frozen`` records, "
"we can iterate over it, but we just have to make sure that our loop "
"terminates, because pointers have no size. Sooner or later it would probably "
"crash with an access violation or whatever, so it's better to break out of "
"the loop when we hit the ``NULL`` entry::"
msgstr ""
"Оскільки ``table`` є ``покажчиком`` на масив ``struct_frozen`` записів, ми "
"можемо перебирати його, але нам просто потрібно переконатися, що наш цикл "
"завершується, оскільки покажчики не мають розміру. Рано чи пізно він, "
"ймовірно, вийде з ладу через порушення прав доступу чи щось інше, тому краще "
"вийти з циклу, коли ми натиснемо запис ``NULL``::"

#: ../../library/ctypes.rst:1152
msgid ""
">>> for item in table:\n"
"...     if item.name is None:\n"
"...         break\n"
"...     print(item.name.decode(\"ascii\"), item.size)\n"
"...\n"
"_frozen_importlib 31764\n"
"_frozen_importlib_external 41499\n"
"zipimport 12345\n"
">>>"
msgstr ""
">>> for item in table:\n"
"...     if item.name is None:\n"
"...         break\n"
"...     print(item.name.decode(\"ascii\"), item.size)\n"
"...\n"
"_frozen_importlib 31764\n"
"_frozen_importlib_external 41499\n"
"zipimport 12345\n"
">>>"

#: ../../library/ctypes.rst:1162
msgid ""
"The fact that standard Python has a frozen module and a frozen package "
"(indicated by the negative ``size`` member) is not well known, it is only "
"used for testing. Try it out with ``import __hello__`` for example."
msgstr ""
"Той факт, що стандартний Python має заморожений модуль і заморожений пакет "
"(позначений від’ємним елементом ``size``), невідомий, він використовується "
"лише для тестування. Спробуйте, наприклад, ``import __hello__``."

#: ../../library/ctypes.rst:1170
msgid "Surprises"
msgstr "Сюрпризи"

#: ../../library/ctypes.rst:1172
msgid ""
"There are some edges in :mod:`ctypes` where you might expect something other "
"than what actually happens."
msgstr ""
"У :mod:`ctypes` є деякі переваги, де ви можете очікувати щось інше, ніж те, "
"що відбувається насправді."

#: ../../library/ctypes.rst:1175
msgid "Consider the following example::"
msgstr "Розглянемо такий приклад:"

#: ../../library/ctypes.rst:1177
msgid ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = (\"x\", c_int), (\"y\", c_int)\n"
"...\n"
">>> class RECT(Structure):\n"
"...     _fields_ = (\"a\", POINT), (\"b\", POINT)\n"
"...\n"
">>> p1 = POINT(1, 2)\n"
">>> p2 = POINT(3, 4)\n"
">>> rc = RECT(p1, p2)\n"
">>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n"
"1 2 3 4\n"
">>> # now swap the two points\n"
">>> rc.a, rc.b = rc.b, rc.a\n"
">>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n"
"3 4 3 4\n"
">>>"
msgstr ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = (\"x\", c_int), (\"y\", c_int)\n"
"...\n"
">>> class RECT(Structure):\n"
"...     _fields_ = (\"a\", POINT), (\"b\", POINT)\n"
"...\n"
">>> p1 = POINT(1, 2)\n"
">>> p2 = POINT(3, 4)\n"
">>> rc = RECT(p1, p2)\n"
">>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n"
"1 2 3 4\n"
">>> # now swap the two points\n"
">>> rc.a, rc.b = rc.b, rc.a\n"
">>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n"
"3 4 3 4\n"
">>>"

#: ../../library/ctypes.rst:1195
msgid ""
"Hm. We certainly expected the last statement to print ``3 4 1 2``. What "
"happened? Here are the steps of the ``rc.a, rc.b = rc.b, rc.a`` line above::"
msgstr ""
"Хм Ми, безумовно, очікували, що останній оператор виведе ``3 4 1 2``. Що "
"трапилось? Ось кроки рядка ``rc.a, rc.b = rc.b, rc.a``:"

#: ../../library/ctypes.rst:1198
msgid ""
">>> temp0, temp1 = rc.b, rc.a\n"
">>> rc.a = temp0\n"
">>> rc.b = temp1\n"
">>>"
msgstr ""
">>> temp0, temp1 = rc.b, rc.a\n"
">>> rc.a = temp0\n"
">>> rc.b = temp1\n"
">>>"

#: ../../library/ctypes.rst:1203
msgid ""
"Note that ``temp0`` and ``temp1`` are objects still using the internal "
"buffer of the ``rc`` object above. So executing ``rc.a = temp0`` copies the "
"buffer contents of ``temp0`` into ``rc`` 's buffer.  This, in turn, changes "
"the contents of ``temp1``. So, the last assignment ``rc.b = temp1``, doesn't "
"have the expected effect."
msgstr ""
"Зауважте, що ``temp0`` і ``temp1`` є об’єктами, які все ще використовують "
"внутрішній буфер об’єкта ``rc`` вище. Отже, виконання ``rc.a = temp0`` "
"копіює вміст буфера ``temp0`` у буфер ``rc``. Це, у свою чергу, змінює вміст "
"``temp1``. Отже, останнє призначення ``rc.b = temp1`` не має очікуваного "
"ефекту."

#: ../../library/ctypes.rst:1209
msgid ""
"Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays "
"doesn't *copy* the sub-object, instead it retrieves a wrapper object "
"accessing the root-object's underlying buffer."
msgstr ""
"Майте на увазі, що отримання підоб’єктів зі структур, об’єднань і масивів не "
"*копіює* підоб’єкт, натомість отримує обгортку об’єкта, який отримує доступ "
"до основного буфера кореневого об’єкта."

#: ../../library/ctypes.rst:1213
msgid ""
"Another example that may behave differently from what one would expect is "
"this::"
msgstr "Інший приклад, який може поводитися інакше, ніж очікувалося, це:"

#: ../../library/ctypes.rst:1215
msgid ""
">>> s = c_char_p()\n"
">>> s.value = b\"abc def ghi\"\n"
">>> s.value\n"
"b'abc def ghi'\n"
">>> s.value is s.value\n"
"False\n"
">>>"
msgstr ""
">>> s = c_char_p()\n"
">>> s.value = b\"abc def ghi\"\n"
">>> s.value\n"
"b'abc def ghi'\n"
">>> s.value is s.value\n"
"False\n"
">>>"

#: ../../library/ctypes.rst:1225
msgid ""
"Objects instantiated from :class:`c_char_p` can only have their value set to "
"bytes or integers."
msgstr ""
"Об’єкти, створені з :class:`c_char_p`, можуть мати значення лише байтів або "
"цілих чисел."

#: ../../library/ctypes.rst:1228
msgid ""
"Why is it printing ``False``?  ctypes instances are objects containing a "
"memory block plus some :term:`descriptor`\\s accessing the contents of the "
"memory. Storing a Python object in the memory block does not store the "
"object itself, instead the ``contents`` of the object is stored.  Accessing "
"the contents again constructs a new Python object each time!"
msgstr ""
"Чому він друкує ``False``? Екземпляри ctypes — це об’єкти, що містять блок "
"пам’яті плюс деякі :term:`descriptor`\\, що мають доступ до вмісту пам’яті. "
"Зберігання об’єкта Python у блоці пам’яті не зберігає сам об’єкт, натомість "
"зберігається ``вміст`` об’єкта. Повторний доступ до вмісту щоразу створює "
"новий об’єкт Python!"

#: ../../library/ctypes.rst:1238
msgid "Variable-sized data types"
msgstr "Типи даних змінного розміру"

#: ../../library/ctypes.rst:1240
msgid ""
":mod:`ctypes` provides some support for variable-sized arrays and structures."
msgstr ""
":mod:`ctypes` забезпечує деяку підтримку для масивів і структур змінного "
"розміру."

#: ../../library/ctypes.rst:1242
msgid ""
"The :func:`resize` function can be used to resize the memory buffer of an "
"existing ctypes object.  The function takes the object as first argument, "
"and the requested size in bytes as the second argument.  The memory block "
"cannot be made smaller than the natural memory block specified by the "
"objects type, a :exc:`ValueError` is raised if this is tried::"
msgstr ""
"Функцію :func:`resize` можна використовувати для зміни розміру буфера "
"пам’яті існуючого об’єкта ctypes. Функція приймає об’єкт як перший аргумент, "
"а запитуваний розмір у байтах як другий аргумент. Блок пам’яті не може бути "
"меншим, ніж природний блок пам’яті, визначений типом об’єкта, :exc:"
"`ValueError` виникає, якщо це спробувати::"

#: ../../library/ctypes.rst:1248
msgid ""
">>> short_array = (c_short * 4)()\n"
">>> print(sizeof(short_array))\n"
"8\n"
">>> resize(short_array, 4)\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: minimum size is 8\n"
">>> resize(short_array, 32)\n"
">>> sizeof(short_array)\n"
"32\n"
">>> sizeof(type(short_array))\n"
"8\n"
">>>"
msgstr ""
">>> short_array = (c_short * 4)()\n"
">>> print(sizeof(short_array))\n"
"8\n"
">>> resize(short_array, 4)\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: minimum size is 8\n"
">>> resize(short_array, 32)\n"
">>> sizeof(short_array)\n"
"32\n"
">>> sizeof(type(short_array))\n"
"8\n"
">>>"

#: ../../library/ctypes.rst:1262
msgid ""
"This is nice and fine, but how would one access the additional elements "
"contained in this array?  Since the type still only knows about 4 elements, "
"we get errors accessing other elements::"
msgstr ""
"Це гарно і добре, але як отримати доступ до додаткових елементів, що "
"містяться в цьому масиві? Оскільки тип все ще знає лише про 4 елементи, ми "
"отримуємо помилки під час доступу до інших елементів::"

#: ../../library/ctypes.rst:1266
msgid ""
">>> short_array[:]\n"
"[0, 0, 0, 0]\n"
">>> short_array[7]\n"
"Traceback (most recent call last):\n"
"    ...\n"
"IndexError: invalid index\n"
">>>"
msgstr ""
">>> short_array[:]\n"
"[0, 0, 0, 0]\n"
">>> short_array[7]\n"
"Traceback (most recent call last):\n"
"    ...\n"
"IndexError: invalid index\n"
">>>"

#: ../../library/ctypes.rst:1274
msgid ""
"Another way to use variable-sized data types with :mod:`ctypes` is to use "
"the dynamic nature of Python, and (re-)define the data type after the "
"required size is already known, on a case by case basis."
msgstr ""
"Інший спосіб використання типів даних змінного розміру з :mod:`ctypes` — це "
"використання динамічної природи Python і (повторне) визначення типу даних "
"після того, як потрібний розмір уже відомий, у кожному конкретному випадку."

#: ../../library/ctypes.rst:1282
msgid "ctypes reference"
msgstr "Referência ctypes"

#: ../../library/ctypes.rst:1288
msgid "Finding shared libraries"
msgstr "Пошук спільних бібліотек"

#: ../../library/ctypes.rst:1290
msgid ""
"When programming in a compiled language, shared libraries are accessed when "
"compiling/linking a program, and when the program is run."
msgstr ""
"Під час програмування скомпільованою мовою доступ до спільних бібліотек "
"здійснюється під час компіляції/зв’язування програми та під час виконання "
"програми."

#: ../../library/ctypes.rst:1293
msgid ""
"The purpose of the :func:`~ctypes.util.find_library` function is to locate a "
"library in a way similar to what the compiler or runtime loader does (on "
"platforms with several versions of a shared library the most recent should "
"be loaded), while the ctypes library loaders act like when a program is run, "
"and call the runtime loader directly."
msgstr ""
"Цель функции :func:`~ctypes.util.find_library` — найти библиотеку способом, "
"аналогичным тому, что делает компилятор или загрузчик среды выполнения (на "
"платформах с несколькими версиями общей библиотеки должна быть загружена "
"самая последняя) , в то время как загрузчики библиотеки ctypes действуют так "
"же, как при запуске программы, и напрямую вызывают загрузчик времени "
"выполнения."

#: ../../library/ctypes.rst:1299
msgid ""
"The :mod:`!ctypes.util` module provides a function which can help to "
"determine the library to load."
msgstr ""
"Модуль :mod:`!ctypes.util` предоставляет функцию, которая может помочь "
"определить библиотеку для загрузки."

#: ../../library/ctypes.rst:1307
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like *lib*, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"Спробуйте знайти бібліотеку та повернути шлях. *name* — це назва бібліотеки "
"без будь-якого префікса, як-от *lib*, суфікса, як-от ``.so``, ``.dylib`` або "
"номера версії (це форма, яка використовується для параметра компонування "
"posix :option:`!- l`). Якщо бібліотеки не знайдено, повертає ``None``."

#: ../../library/ctypes.rst:1312 ../../library/ctypes.rst:1997
msgid "The exact functionality is system dependent."
msgstr "Точна функція залежить від системи."

#: ../../library/ctypes.rst:1314
msgid ""
"On Linux, :func:`~ctypes.util.find_library` tries to run external programs "
"(``/sbin/ldconfig``, ``gcc``, ``objdump`` and ``ld``) to find the library "
"file. It returns the filename of the library file."
msgstr ""
"В Linux :func:`~ctypes.util.find_library` пытается запустить внешние "
"программы (``/sbin/ldconfig``, ``gcc``, ``objdump`` и ``ld``), чтобы найти "
"файл библиотеки. Он возвращает имя файла библиотеки."

#: ../../library/ctypes.rst:1318
msgid ""
"On Linux, the value of the environment variable ``LD_LIBRARY_PATH`` is used "
"when searching for libraries, if a library cannot be found by any other "
"means."
msgstr ""
"У Linux значення змінної середовища ``LD_LIBRARY_PATH`` використовується під "
"час пошуку бібліотек, якщо бібліотеку неможливо знайти будь-яким іншим "
"способом."

#: ../../library/ctypes.rst:1322
msgid "Here are some examples::"
msgstr "Veja alguns exemplos::"

#: ../../library/ctypes.rst:1324
msgid ""
">>> from ctypes.util import find_library\n"
">>> find_library(\"m\")\n"
"'libm.so.6'\n"
">>> find_library(\"c\")\n"
"'libc.so.6'\n"
">>> find_library(\"bz2\")\n"
"'libbz2.so.1.0'\n"
">>>"
msgstr ""
">>> from ctypes.util import find_library\n"
">>> find_library(\"m\")\n"
"'libm.so.6'\n"
">>> find_library(\"c\")\n"
"'libc.so.6'\n"
">>> find_library(\"bz2\")\n"
"'libbz2.so.1.0'\n"
">>>"

#: ../../library/ctypes.rst:1333
msgid ""
"On macOS, :func:`~ctypes.util.find_library` tries several predefined naming "
"schemes and paths to locate the library, and returns a full pathname if "
"successful::"
msgstr ""

#: ../../library/ctypes.rst:1336
msgid ""
">>> from ctypes.util import find_library\n"
">>> find_library(\"c\")\n"
"'/usr/lib/libc.dylib'\n"
">>> find_library(\"m\")\n"
"'/usr/lib/libm.dylib'\n"
">>> find_library(\"bz2\")\n"
"'/usr/lib/libbz2.dylib'\n"
">>> find_library(\"AGL\")\n"
"'/System/Library/Frameworks/AGL.framework/AGL'\n"
">>>"
msgstr ""
">>> from ctypes.util import find_library\n"
">>> find_library(\"c\")\n"
"'/usr/lib/libc.dylib'\n"
">>> find_library(\"m\")\n"
"'/usr/lib/libm.dylib'\n"
">>> find_library(\"bz2\")\n"
"'/usr/lib/libbz2.dylib'\n"
">>> find_library(\"AGL\")\n"
"'/System/Library/Frameworks/AGL.framework/AGL'\n"
">>>"

#: ../../library/ctypes.rst:1347
msgid ""
"On Windows, :func:`~ctypes.util.find_library` searches along the system "
"search path, and returns the full pathname, but since there is no predefined "
"naming scheme a call like ``find_library(\"c\")`` will fail and return "
"``None``."
msgstr ""
"В Windows :func:`~ctypes.util.find_library` выполняет поиск по системному "
"пути поиска и возвращает полный путь, но поскольку предопределенной схемы "
"именования нет, вызов типа ``find_library(\"c\")`` завершится неудачно. и "
"верните ``Нет``."

#: ../../library/ctypes.rst:1351
msgid ""
"If wrapping a shared library with :mod:`ctypes`, it *may* be better to "
"determine the shared library name at development time, and hardcode that "
"into the wrapper module instead of using :func:`~ctypes.util.find_library` "
"to locate the library at runtime."
msgstr ""
"Если вы оборачиваете общую библиотеку с помощью :mod:`ctypes`, *возможно* "
"лучше определить имя общей библиотеки во время разработки и жестко "
"запрограммировать его в модуле-оболочке вместо использования :func:`~ctypes."
"util.find_library` чтобы найти библиотеку во время выполнения."

#: ../../library/ctypes.rst:1359
msgid "Loading shared libraries"
msgstr "Завантаження спільних бібліотек"

#: ../../library/ctypes.rst:1361
msgid ""
"There are several ways to load shared libraries into the Python process.  "
"One way is to instantiate one of the following classes:"
msgstr ""
"Є кілька способів завантажити спільні бібліотеки в процес Python. Одним із "
"способів є створення екземпляра одного з наступних класів:"

#: ../../library/ctypes.rst:1367
msgid ""
"Instances of this class represent loaded shared libraries. Functions in "
"these libraries use the standard C calling convention, and are assumed to "
"return :c:expr:`int`."
msgstr ""
"Экземпляры этого класса представляют загруженные общие библиотеки. Функции в "
"этих библиотеках используют стандартное соглашение о вызовах C и, как "
"предполагается, возвращают :c:expr:`int`."

#: ../../library/ctypes.rst:1371
msgid ""
"On Windows creating a :class:`CDLL` instance may fail even if the DLL name "
"exists. When a dependent DLL of the loaded DLL is not found, a :exc:"
"`OSError` error is raised with the message *\"[WinError 126] The specified "
"module could not be found\".* This error message does not contain the name "
"of the missing DLL because the Windows API does not return this information "
"making this error hard to diagnose. To resolve this error and determine "
"which DLL is not found, you need to find the list of dependent DLLs and "
"determine which one is not found using Windows debugging and tracing tools."
msgstr ""
"У Windows створення екземпляра :class:`CDLL` може завершитися помилкою, "
"навіть якщо ім’я DLL існує. Якщо залежну DLL від завантаженої DLL не "
"знайдено, виникає помилка :exc:`OSError` із повідомленням *\"[WinError 126] "
"Не вдалося знайти вказаний модуль\".* Це повідомлення про помилку не містить "
"назви відсутня DLL, оскільки Windows API не повертає цю інформацію, що "
"ускладнює діагностику цієї помилки. Щоб усунути цю помилку та визначити, яку "
"DLL не знайдено, потрібно знайти список залежних DLL і визначити, яка з них "
"не знайдена, за допомогою засобів налагодження та трасування Windows."

#: ../../library/ctypes.rst:1383 ../../library/ctypes.rst:1408
#: ../../library/ctypes.rst:1421 ../../library/ctypes.rst:1439
msgid "The *name* parameter can now be a :term:`path-like object`."
msgstr "Параметр *name* теперь может быть :term:`объектом, похожим на путь`."

#: ../../library/ctypes.rst:1387
msgid ""
"`Microsoft DUMPBIN tool <https://docs.microsoft.com/cpp/build/reference/"
"dependents>`_ -- A tool to find DLL dependents."
msgstr ""
"`Інструмент Microsoft DUMPBIN <https://docs.microsoft.com/cpp/build/"
"reference/dependents>`_ -- Інструмент для пошуку залежних DLL."

#: ../../library/ctypes.rst:1393
msgid ""
"Instances of this class represent loaded shared libraries, functions in "
"these libraries use the ``stdcall`` calling convention, and are assumed to "
"return the windows specific :class:`HRESULT` code.  :class:`HRESULT` values "
"contain information specifying whether the function call failed or "
"succeeded, together with additional error code.  If the return value signals "
"a failure, an :class:`OSError` is automatically raised."
msgstr ""
"Экземпляры этого класса представляют собой загруженные общие библиотеки, "
"функции в этих библиотеках используют соглашение о вызовах ``stdcall`` и, "
"как предполагается, возвращают специфичный для Windows код :class:`HRESULT`. "
"Значения :class:`HRESULT` содержат информацию, определяющую, был ли вызов "
"функции неудачным или успешным, а также дополнительный код ошибки. Если "
"возвращаемое значение сигнализирует об ошибке, автоматически выдается "
"сообщение :class:`OSError`."

#: ../../library/ctypes.rst:1400 ../../library/ctypes.rst:1417
#: ../../library/ctypes.rst:1561 ../../library/ctypes.rst:1569
#: ../../library/ctypes.rst:1746 ../../library/ctypes.rst:1977
#: ../../library/ctypes.rst:1986 ../../library/ctypes.rst:2011
#: ../../library/ctypes.rst:2020 ../../library/ctypes.rst:2029
#: ../../library/ctypes.rst:2044 ../../library/ctypes.rst:2101
#: ../../library/ctypes.rst:2129 ../../library/ctypes.rst:2473
msgid "Availability"
msgstr "Disponibilidade"

#: ../../library/ctypes.rst:1402
msgid ""
":exc:`WindowsError` used to be raised, which is now an alias of :exc:"
"`OSError`."
msgstr ""
"Раньше вызывался :exc:`WindowsError`, который теперь является псевдонимом :"
"exc:`OSError`."

#: ../../library/ctypes.rst:1413
msgid ""
"Instances of this class represent loaded shared libraries, functions in "
"these libraries use the ``stdcall`` calling convention, and are assumed to "
"return :c:expr:`int` by default."
msgstr ""
"Экземпляры этого класса представляют собой загруженные общие библиотеки, "
"функции в этих библиотеках используют соглашение о вызовах ``stdcall`` и, "
"как предполагается, по умолчанию возвращают :c:expr:`int`."

#: ../../library/ctypes.rst:1424
msgid ""
"The Python :term:`global interpreter lock` is released before calling any "
"function exported by these libraries, and reacquired afterwards."
msgstr ""
":term:`global interpreter lock` Python знімається перед викликом будь-якої "
"функції, експортованої цими бібліотеками, і знову отримується після цього."

#: ../../library/ctypes.rst:1430
msgid ""
"Instances of this class behave like :class:`CDLL` instances, except that the "
"Python GIL is *not* released during the function call, and after the "
"function execution the Python error flag is checked. If the error flag is "
"set, a Python exception is raised."
msgstr ""
"Екземпляри цього класу поводяться як екземпляри :class:`CDLL`, за винятком "
"того, що GIL Python *не* звільняється під час виклику функції, а після "
"виконання функції перевіряється позначка помилки Python. Якщо встановлено "
"позначку помилки, виникає виняток Python."

#: ../../library/ctypes.rst:1435
msgid "Thus, this is only useful to call Python C api functions directly."
msgstr "Таким чином, це корисно лише для прямого виклику API-функцій Python C."

#: ../../library/ctypes.rst:1441
msgid ""
"All these classes can be instantiated by calling them with at least one "
"argument, the pathname of the shared library.  If you have an existing "
"handle to an already loaded shared library, it can be passed as the "
"``handle`` named parameter, otherwise the underlying platforms :c:func:`!"
"dlopen` or :c:func:`!LoadLibrary` function is used to load the library into "
"the process, and to get a handle to it."
msgstr ""

#: ../../library/ctypes.rst:1448
msgid ""
"The *mode* parameter can be used to specify how the library is loaded.  For "
"details, consult the :manpage:`dlopen(3)` manpage.  On Windows, *mode* is "
"ignored.  On posix systems, RTLD_NOW is always added, and is not "
"configurable."
msgstr ""
"Параметр *mode* можна використовувати для визначення способу завантаження "
"бібліотеки. Додаткову інформацію див. на сторінці довідки :manpage:"
"`dlopen(3)`. У Windows *режим* ігнорується. У системах posix RTLD_NOW завжди "
"додається та не налаштовується."

#: ../../library/ctypes.rst:1453
msgid ""
"The *use_errno* parameter, when set to true, enables a ctypes mechanism that "
"allows accessing the system :data:`errno` error number in a safe way. :mod:"
"`ctypes` maintains a thread-local copy of the systems :data:`errno` "
"variable; if you call foreign functions created with ``use_errno=True`` then "
"the :data:`errno` value before the function call is swapped with the ctypes "
"private copy, the same happens immediately after the function call."
msgstr ""

#: ../../library/ctypes.rst:1460
msgid ""
"The function :func:`ctypes.get_errno` returns the value of the ctypes "
"private copy, and the function :func:`ctypes.set_errno` changes the ctypes "
"private copy to a new value and returns the former value."
msgstr ""
"Функція :func:`ctypes.get_errno` повертає значення приватної копії ctypes, а "
"функція :func:`ctypes.set_errno` змінює приватну копію ctypes на нове "
"значення та повертає попереднє значення."

#: ../../library/ctypes.rst:1464
msgid ""
"The *use_last_error* parameter, when set to true, enables the same mechanism "
"for the Windows error code which is managed by the :func:`GetLastError` and :"
"func:`!SetLastError` Windows API functions; :func:`ctypes.get_last_error` "
"and :func:`ctypes.set_last_error` are used to request and change the ctypes "
"private copy of the windows error code."
msgstr ""
"Параметр *use_last_error*, если ему присвоено значение true, включает тот же "
"механизм для кода ошибки Windows, который управляется функциями Windows API :"
"func:`GetLastError` и :func:`!SetLastError`; :func:`ctypes.get_last_error` "
"и :func:`ctypes.set_last_error` используются для запроса и изменения частной "
"копии ctypes кода ошибки Windows."

#: ../../library/ctypes.rst:1470
msgid ""
"The *winmode* parameter is used on Windows to specify how the library is "
"loaded (since *mode* is ignored). It takes any value that is valid for the "
"Win32 API ``LoadLibraryEx`` flags parameter. When omitted, the default is to "
"use the flags that result in the most secure DLL load, which avoids issues "
"such as DLL hijacking. Passing the full path to the DLL is the safest way to "
"ensure the correct library and dependencies are loaded."
msgstr ""
"Параметр *winmode* используется в Windows для указания способа загрузки "
"библиотеки (поскольку *mode* игнорируется). Он принимает любое значение, "
"допустимое для параметра флагов Win32 API LoadLibraryEx. Если этот параметр "
"опущен, по умолчанию используются флаги, обеспечивающие наиболее безопасную "
"загрузку DLL, что позволяет избежать таких проблем, как перехват DLL. "
"Передача полного пути к DLL — это самый безопасный способ убедиться, что "
"загружена правильная библиотека и зависимости."

#: ../../library/ctypes.rst:1477
msgid "Added *winmode* parameter."
msgstr "Додано параметр *winmode*."

#: ../../library/ctypes.rst:1484
msgid ""
"Flag to use as *mode* parameter.  On platforms where this flag is not "
"available, it is defined as the integer zero."
msgstr ""
"Прапор для використання як параметр *mode*. На платформах, де цей прапорець "
"недоступний, він визначається як цілий нуль."

#: ../../library/ctypes.rst:1491
msgid ""
"Flag to use as *mode* parameter.  On platforms where this is not available, "
"it is the same as *RTLD_GLOBAL*."
msgstr ""
"Прапор для використання як параметр *mode*. На платформах, де це недоступно, "
"це те саме, що *RTLD_GLOBAL*."

#: ../../library/ctypes.rst:1498
msgid ""
"The default mode which is used to load shared libraries.  On OSX 10.3, this "
"is *RTLD_GLOBAL*, otherwise it is the same as *RTLD_LOCAL*."
msgstr ""
"Типовий режим, який використовується для завантаження спільних бібліотек. В "
"OSX 10.3 це *RTLD_GLOBAL*, інакше це те саме, що *RTLD_LOCAL*."

#: ../../library/ctypes.rst:1501
msgid ""
"Instances of these classes have no public methods.  Functions exported by "
"the shared library can be accessed as attributes or by index.  Please note "
"that accessing the function through an attribute caches the result and "
"therefore accessing it repeatedly returns the same object each time.  On the "
"other hand, accessing it through an index returns a new object each time::"
msgstr ""
"Екземпляри цих класів не мають відкритих методів. Доступ до функцій, "
"експортованих спільною бібліотекою, можна отримати як за атрибутами або за "
"індексом. Будь ласка, зверніть увагу, що доступ до функції через атрибут "
"кешує результат, тому повторний доступ повертає той самий об’єкт щоразу. З "
"іншого боку, доступ до нього через індекс кожного разу повертає новий "
"об’єкт::"

#: ../../library/ctypes.rst:1507
msgid ""
">>> from ctypes import CDLL\n"
">>> libc = CDLL(\"libc.so.6\")  # On Linux\n"
">>> libc.time == libc.time\n"
"True\n"
">>> libc['time'] == libc['time']\n"
"False"
msgstr ""
">>> from ctypes import CDLL\n"
">>> libc = CDLL(\"libc.so.6\")  # On Linux\n"
">>> libc.time == libc.time\n"
"True\n"
">>> libc['time'] == libc['time']\n"
"False"

#: ../../library/ctypes.rst:1514
msgid ""
"The following public attributes are available, their name starts with an "
"underscore to not clash with exported function names:"
msgstr ""
"Доступні такі загальнодоступні атрибути, їх імена починаються з "
"підкреслення, щоб не суперечити ім’ям експортованих функцій:"

#: ../../library/ctypes.rst:1520
msgid "The system handle used to access the library."
msgstr "Системний дескриптор, який використовується для доступу до бібліотеки."

#: ../../library/ctypes.rst:1525
msgid "The name of the library passed in the constructor."
msgstr "Ім'я бібліотеки, передане в конструктор."

#: ../../library/ctypes.rst:1527
msgid ""
"Shared libraries can also be loaded by using one of the prefabricated "
"objects, which are instances of the :class:`LibraryLoader` class, either by "
"calling the :meth:`~LibraryLoader.LoadLibrary` method, or by retrieving the "
"library as attribute of the loader instance."
msgstr ""
"Общие библиотеки также можно загрузить с помощью одного из готовых объектов, "
"которые являются экземплярами класса :class:`LibraryLoader`, либо путем "
"вызова метода :meth:`~LibraryLoader.LoadLibrary`, либо путем получения "
"библиотеки как атрибута экземпляр загрузчика."

#: ../../library/ctypes.rst:1535
msgid ""
"Class which loads shared libraries.  *dlltype* should be one of the :class:"
"`CDLL`, :class:`PyDLL`, :class:`WinDLL`, or :class:`OleDLL` types."
msgstr ""
"Клас, який завантажує спільні бібліотеки. *dlltype* має бути одним із типів :"
"class:`CDLL`, :class:`PyDLL`, :class:`WinDLL` або :class:`OleDLL`."

#: ../../library/ctypes.rst:1538
msgid ""
":meth:`!__getattr__` has special behavior: It allows loading a shared "
"library by accessing it as attribute of a library loader instance.  The "
"result is cached, so repeated attribute accesses return the same library "
"each time."
msgstr ""
":meth:`!__getattr__` имеет особое поведение: он позволяет загружать общую "
"библиотеку, обращаясь к ней как к атрибуту экземпляра загрузчика библиотеки. "
"Результат кэшируется, поэтому повторные обращения к атрибутам каждый раз "
"возвращают одну и ту же библиотеку."

#: ../../library/ctypes.rst:1544
msgid ""
"Load a shared library into the process and return it.  This method always "
"returns a new instance of the library."
msgstr ""
"Завантажте спільну бібліотеку в процес і поверніть її. Цей метод завжди "
"повертає новий екземпляр бібліотеки."

#: ../../library/ctypes.rst:1548
msgid "These prefabricated library loaders are available:"
msgstr "Ці збірні бібліотечні завантажувачі доступні:"

#: ../../library/ctypes.rst:1553
msgid "Creates :class:`CDLL` instances."
msgstr "Створює екземпляри :class:`CDLL`."

#: ../../library/ctypes.rst:1559
msgid "Creates :class:`WinDLL` instances."
msgstr "Создает экземпляры :class:`WinDLL`."

#: ../../library/ctypes.rst:1567
msgid "Creates :class:`OleDLL` instances."
msgstr "Создает экземпляры :class:`OleDLL`."

#: ../../library/ctypes.rst:1575
msgid "Creates :class:`PyDLL` instances."
msgstr "Створює екземпляри :class:`PyDLL`."

#: ../../library/ctypes.rst:1578
msgid ""
"For accessing the C Python api directly, a ready-to-use Python shared "
"library object is available:"
msgstr ""
"Для прямого доступу до API C Python доступний готовий до використання об’єкт "
"спільної бібліотеки Python:"

#: ../../library/ctypes.rst:1584
msgid ""
"An instance of :class:`PyDLL` that exposes Python C API functions as "
"attributes.  Note that all these functions are assumed to return C :c:expr:"
"`int`, which is of course not always the truth, so you have to assign the "
"correct :attr:`!restype` attribute to use these functions."
msgstr ""
"Экземпляр :class:`PyDLL`, который предоставляет функции Python C API в "
"качестве атрибутов. Обратите внимание, что предполагается, что все эти "
"функции возвращают C :c:expr:`int`, что, конечно, не всегда соответствует "
"действительности, поэтому для использования этих функций вам необходимо "
"назначить правильный атрибут :attr:`!restype`."

#: ../../library/ctypes.rst:1589 ../../library/ctypes.rst:1591
msgid ""
"Loading a library through any of these objects raises an :ref:`auditing "
"event <auditing>` ``ctypes.dlopen`` with string argument ``name``, the name "
"used to load the library."
msgstr ""
"Carregar uma biblioteca através de qualquer um desses objetos levanta um :"
"ref:`evento de auditoria <auditing>` ``ctypes.dlopen`` com o argumento "
"string ``name``, o nome usado para carregar a biblioteca."

#: ../../library/ctypes.rst:1595 ../../library/ctypes.rst:1597
msgid ""
"Accessing a function on a loaded library raises an auditing event ``ctypes."
"dlsym`` with arguments ``library`` (the library object) and ``name`` (the "
"symbol's name as a string or integer)."
msgstr ""
"Доступ до функції у завантаженій бібліотеці викликає подію аудиту ``ctypes."
"dlsym`` з аргументами ``library`` (об’єкт бібліотеки) і ``name`` (ім’я "
"символу у вигляді рядка або цілого числа)."

#: ../../library/ctypes.rst:1601 ../../library/ctypes.rst:1603
msgid ""
"In cases when only the library handle is available rather than the object, "
"accessing a function raises an auditing event ``ctypes.dlsym/handle`` with "
"arguments ``handle`` (the raw library handle) and ``name``."
msgstr ""
"У випадках, коли доступний лише дескриптор бібліотеки, а не об’єкт, доступ "
"до функції викликає подію аудиту ``ctypes.dlsym/handle`` з аргументами "
"``handle`` (необроблений дескриптор бібліотеки) і ``name``."

#: ../../library/ctypes.rst:1610
msgid "Foreign functions"
msgstr "Іноземні функції"

#: ../../library/ctypes.rst:1612
msgid ""
"As explained in the previous section, foreign functions can be accessed as "
"attributes of loaded shared libraries.  The function objects created in this "
"way by default accept any number of arguments, accept any ctypes data "
"instances as arguments, and return the default result type specified by the "
"library loader."
msgstr ""
"Как объяснялось в предыдущем разделе, доступ к внешним функциям можно "
"получить как атрибуты загруженных общих библиотек. Объекты функций, "
"созданные таким образом, по умолчанию принимают любое количество аргументов, "
"принимают любые экземпляры данных ctypes в качестве аргументов и возвращают "
"тип результата по умолчанию, указанный загрузчиком библиотеки."

#: ../../library/ctypes.rst:1617
msgid ""
"They are instances of a private local class :class:`!_FuncPtr` (not exposed "
"in :mod:`!ctypes`) which inherits from the private :class:`_CFuncPtr` class:"
msgstr ""
"Они являются экземплярами частного локального класса :class:`!_FuncPtr` (не "
"представленного в :mod:`!ctypes`), который наследуется от частного класса :"
"class:`_CFuncPtr`:"

#: ../../library/ctypes.rst:1620
msgid ""
">>> import ctypes\n"
">>> lib = ctypes.CDLL(None)\n"
">>> issubclass(lib._FuncPtr, ctypes._CFuncPtr)\n"
"True\n"
">>> lib._FuncPtr is ctypes._CFuncPtr\n"
"False"
msgstr ""
">>> import ctypes\n"
">>> lib = ctypes.CDLL(None)\n"
">>> issubclass(lib._FuncPtr, ctypes._CFuncPtr)\n"
"True\n"
">>> lib._FuncPtr is ctypes._CFuncPtr\n"
"False"

#: ../../library/ctypes.rst:1631
msgid "Base class for C callable foreign functions."
msgstr "Базовий клас для зовнішніх функцій C, що викликаються."

#: ../../library/ctypes.rst:1633
msgid ""
"Instances of foreign functions are also C compatible data types; they "
"represent C function pointers."
msgstr ""
"Примірники сторонніх функцій також є C-сумісними типами даних; вони "
"представляють покажчики функцій C."

#: ../../library/ctypes.rst:1636
msgid ""
"This behavior can be customized by assigning to special attributes of the "
"foreign function object."
msgstr ""
"Цю поведінку можна налаштувати шляхом призначення спеціальних атрибутів "
"стороннього функціонального об’єкта."

#: ../../library/ctypes.rst:1641
msgid ""
"Assign a ctypes type to specify the result type of the foreign function. Use "
"``None`` for :c:expr:`void`, a function not returning anything."
msgstr ""
"Назначьте тип ctypes, чтобы указать тип результата внешней функции. "
"Используйте None для :c:expr:`void`, функции, которая ничего не возвращает."

#: ../../library/ctypes.rst:1644
msgid ""
"It is possible to assign a callable Python object that is not a ctypes type, "
"in this case the function is assumed to return a C :c:expr:`int`, and the "
"callable will be called with this integer, allowing further processing or "
"error checking.  Using this is deprecated, for more flexible post processing "
"or error checking use a ctypes data type as :attr:`!restype` and assign a "
"callable to the :attr:`errcheck` attribute."
msgstr ""
"Можно назначить вызываемый объект Python, который не является типом ctypes, "
"в этом случае предполагается, что функция возвращает C :c:expr:`int`, и "
"вызываемый объект будет вызываться с этим целым числом, что позволяет "
"дальнейшую обработку или проверка ошибок. Использование этого параметра "
"устарело. Для более гибкой постобработки или проверки ошибок используйте тип "
"данных ctypes как :attr:`!restype` и назначьте вызываемый объект атрибуту :"
"attr:`errcheck`."

#: ../../library/ctypes.rst:1653
msgid ""
"Assign a tuple of ctypes types to specify the argument types that the "
"function accepts.  Functions using the ``stdcall`` calling convention can "
"only be called with the same number of arguments as the length of this "
"tuple; functions using the C calling convention accept additional, "
"unspecified arguments as well."
msgstr ""
"Призначте кортеж типів ctypes, щоб указати типи аргументів, які приймає "
"функція. Функції, які використовують угоду про виклики ``stdcall``, можуть "
"бути викликані лише з тією ж кількістю аргументів, що й довжина цього "
"кортежу; функції, що використовують угоду про виклики C, також приймають "
"додаткові, невизначені аргументи."

#: ../../library/ctypes.rst:1659
msgid ""
"When a foreign function is called, each actual argument is passed to the :"
"meth:`~_CData.from_param` class method of the items in the :attr:`argtypes` "
"tuple, this method allows adapting the actual argument to an object that the "
"foreign function accepts.  For example, a :class:`c_char_p` item in the :"
"attr:`argtypes` tuple will convert a string passed as argument into a bytes "
"object using ctypes conversion rules."
msgstr ""
"При вызове внешней функции каждый фактический аргумент передается методу "
"класса :meth:`~_CData.from_param` элементов кортежа :attr:`argtypes`. Этот "
"метод позволяет адаптировать фактический аргумент к объекту, который внешняя "
"функция принимает. Например, элемент :class:`c_char_p` в кортеже :attr:"
"`argtypes` преобразует строку, переданную в качестве аргумента, в объект "
"байтов, используя правила преобразования ctypes."

#: ../../library/ctypes.rst:1666
msgid ""
"New: It is now possible to put items in argtypes which are not ctypes types, "
"but each item must have a :meth:`~_CData.from_param` method which returns a "
"value usable as argument (integer, string, ctypes instance).  This allows "
"defining adapters that can adapt custom objects as function parameters."
msgstr ""
"Новое: теперь можно помещать элементы в argtypes, которые не являются типами "
"ctypes, но каждый элемент должен иметь метод :meth:`~_CData.from_param`, "
"который возвращает значение, которое можно использовать в качестве аргумента "
"(целое число, строка, экземпляр ctypes). Это позволяет определять адаптеры, "
"которые могут адаптировать пользовательские объекты в качестве параметров "
"функции."

#: ../../library/ctypes.rst:1673
msgid ""
"Assign a Python function or another callable to this attribute. The callable "
"will be called with three or more arguments:"
msgstr ""
"Призначте цьому атрибуту функцію Python або інший виклик. Викликається з "
"трьома або більше аргументами:"

#: ../../library/ctypes.rst:1680
msgid ""
"*result* is what the foreign function returns, as specified by the :attr:`!"
"restype` attribute."
msgstr ""
"*result* — это то, что возвращает внешняя функция, как указано в атрибуте :"
"attr:`!restype`."

#: ../../library/ctypes.rst:1683
msgid ""
"*func* is the foreign function object itself, this allows reusing the same "
"callable object to check or post process the results of several functions."
msgstr ""
"*func* — це сам зовнішній об’єкт функції, це дозволяє повторно "
"використовувати той самий об’єкт, що викликається, для перевірки або "
"постобробки результатів кількох функцій."

#: ../../library/ctypes.rst:1687
msgid ""
"*arguments* is a tuple containing the parameters originally passed to the "
"function call, this allows specializing the behavior on the arguments used."
msgstr ""
"*Аргументи* — це кортеж, що містить параметри, спочатку передані до виклику "
"функції, що дозволяє спеціалізувати поведінку на використовуваних аргументах."

#: ../../library/ctypes.rst:1691
msgid ""
"The object that this function returns will be returned from the foreign "
"function call, but it can also check the result value and raise an exception "
"if the foreign function call failed."
msgstr ""
"Об’єкт, який повертає ця функція, буде повернено з виклику зовнішньої "
"функції, але він також може перевірити значення результату та викликати "
"виняток, якщо виклик зовнішньої функції не вдався."

#: ../../library/ctypes.rst:1698
msgid ""
"This exception is raised when a foreign function call cannot convert one of "
"the passed arguments."
msgstr ""
"Цей виняток виникає, коли зовнішній виклик функції не може перетворити один "
"із переданих аргументів."

#: ../../library/ctypes.rst:1702 ../../library/ctypes.rst:1704
msgid ""
"On Windows, when a foreign function call raises a system exception (for "
"example, due to an access violation), it will be captured and replaced with "
"a suitable Python exception. Further, an auditing event ``ctypes."
"set_exception`` with argument ``code`` will be raised, allowing an audit "
"hook to replace the exception with its own."
msgstr ""
"В Windows, когда вызов сторонней функции вызывает системное исключение "
"(например, из-за нарушения прав доступа), оно будет перехвачено и заменено "
"подходящим исключением Python. Кроме того, будет вызвано событие аудита "
"``ctypes.set_Exception`` с аргументом ``code``, позволяющее хуку аудита "
"заменить исключение своим собственным."

#: ../../library/ctypes.rst:1710 ../../library/ctypes.rst:1712
msgid ""
"Some ways to invoke foreign function calls may raise an auditing event "
"``ctypes.call_function`` with arguments ``function pointer`` and "
"``arguments``."
msgstr ""
"Деякі способи виклику зовнішніх викликів функцій можуть викликати подію "
"аудиту ``ctypes.call_function`` з аргументами ``вказівник функції`` і "
"``аргументи``."

#: ../../library/ctypes.rst:1718
msgid "Function prototypes"
msgstr "Прототипи функцій"

#: ../../library/ctypes.rst:1720
msgid ""
"Foreign functions can also be created by instantiating function prototypes. "
"Function prototypes are similar to function prototypes in C; they describe a "
"function (return type, argument types, calling convention) without defining "
"an implementation.  The factory functions must be called with the desired "
"result type and the argument types of the function, and can be used as "
"decorator factories, and as such, be applied to functions through the "
"``@wrapper`` syntax. See :ref:`ctypes-callback-functions` for examples."
msgstr ""
"Сторонні функції також можуть бути створені шляхом інстанціювання прототипів "
"функцій. Прототипи функцій подібні до прототипів функцій у C; вони описують "
"функцію (тип повернення, типи аргументів, угоду про виклики) без визначення "
"реалізації. Фабричні функції мають викликатися з потрібним типом результату "
"та типами аргументів функції, і їх можна використовувати як фабрики "
"декораторів, і як такі застосовувати до функцій за допомогою синтаксису "
"``@wrapper``. Перегляньте :ref:`ctypes-callback-functions` для прикладів."

#: ../../library/ctypes.rst:1731
msgid ""
"The returned function prototype creates functions that use the standard C "
"calling convention.  The function will release the GIL during the call.  If "
"*use_errno* is set to true, the ctypes private copy of the system :data:"
"`errno` variable is exchanged with the real :data:`errno` value before and "
"after the call; *use_last_error* does the same for the Windows error code."
msgstr ""
"Повернений прототип функції створює функції, які використовують стандартну "
"угоду про виклик C. Функція звільнить GIL під час виклику. Якщо *use_errno* "
"має значення true, приватна копія ctypes системної змінної :data:`errno` "
"обмінюється справжнім значенням :data:`errno` до і після виклику; "
"*use_last_error* робить те саме для коду помилки Windows."

#: ../../library/ctypes.rst:1741
msgid ""
"The returned function prototype creates functions that use the ``stdcall`` "
"calling convention.  The function will release the GIL during the call.  "
"*use_errno* and *use_last_error* have the same meaning as above."
msgstr ""
"Возвращенный прототип функции создает функции, использующие соглашение о "
"вызовах stdcall. Функция освободит GIL во время вызова. *use_errno* и "
"*use_last_error* имеют то же значение, что и выше."

#: ../../library/ctypes.rst:1751
msgid ""
"The returned function prototype creates functions that use the Python "
"calling convention.  The function will *not* release the GIL during the call."
msgstr ""
"Повернений прототип функції створює функції, які використовують угоду про "
"виклики Python. Функція *не* звільняє GIL під час виклику."

#: ../../library/ctypes.rst:1754
msgid ""
"Function prototypes created by these factory functions can be instantiated "
"in different ways, depending on the type and number of the parameters in the "
"call:"
msgstr ""
"Прототипи функцій, створені цими фабричними функціями, можуть бути створені "
"різними способами, залежно від типу та кількості параметрів у виклику:"

#: ../../library/ctypes.rst:1761
msgid ""
"Returns a foreign function at the specified address which must be an integer."
msgstr ""
"Повертає зовнішню функцію за вказаною адресою, яка має бути цілим числом."

#: ../../library/ctypes.rst:1768
msgid ""
"Create a C callable function (a callback function) from a Python *callable*."
msgstr ""
"Створіть функцію виклику C (функцію зворотного виклику) з Python *callable*."

#: ../../library/ctypes.rst:1775
msgid ""
"Returns a foreign function exported by a shared library. *func_spec* must be "
"a 2-tuple ``(name_or_ordinal, library)``. The first item is the name of the "
"exported function as string, or the ordinal of the exported function as "
"small integer.  The second item is the shared library instance."
msgstr ""
"Повертає зовнішню функцію, експортовану спільною бібліотекою. *func_spec* "
"має бути 2-кортежем ``(name_or_ordinal, library)``. Перший елемент — це ім’я "
"експортованої функції у вигляді рядка або порядковий номер експортованої "
"функції у вигляді малого цілого числа. Другий елемент — екземпляр спільної "
"бібліотеки."

#: ../../library/ctypes.rst:1785
msgid ""
"Returns a foreign function that will call a COM method. *vtbl_index* is the "
"index into the virtual function table, a small non-negative integer. *name* "
"is name of the COM method. *iid* is an optional pointer to the interface "
"identifier which is used in extended error reporting."
msgstr ""
"Повертає зовнішню функцію, яка викликає метод COM. *vtbl_index* — це індекс "
"у таблиці віртуальних функцій, мале невід’ємне ціле число. *ім’я* — це ім’я "
"методу COM. *iid* — це додатковий покажчик на ідентифікатор інтерфейсу, який "
"використовується в розширеному звіті про помилки."

#: ../../library/ctypes.rst:1790
msgid ""
"COM methods use a special calling convention: They require a pointer to the "
"COM interface as first argument, in addition to those parameters that are "
"specified in the :attr:`!argtypes` tuple."
msgstr ""
"В методах COM используется специальное соглашение о вызовах: им требуется "
"указатель на интерфейс COM в качестве первого аргумента в дополнение к тем "
"параметрам, которые указаны в кортеже :attr:`!argtypes`."

#: ../../library/ctypes.rst:1794
msgid ""
"The optional *paramflags* parameter creates foreign function wrappers with "
"much more functionality than the features described above."
msgstr ""
"Необов’язковий параметр *paramflags* створює зовнішні обгортки функцій із "
"набагато більшою функціональністю, ніж функції, описані вище."

#: ../../library/ctypes.rst:1797
msgid ""
"*paramflags* must be a tuple of the same length as :attr:`~_CFuncPtr."
"argtypes`."
msgstr ""
"*paramflags* должен быть кортежем той же длины, что и :attr:`~_CFuncPtr."
"argtypes`."

#: ../../library/ctypes.rst:1799
msgid ""
"Each item in this tuple contains further information about a parameter, it "
"must be a tuple containing one, two, or three items."
msgstr ""
"Кожен елемент у цьому кортежі містить додаткову інформацію про параметр, це "
"має бути кортеж, що містить один, два або три елементи."

#: ../../library/ctypes.rst:1802
msgid ""
"The first item is an integer containing a combination of direction flags for "
"the parameter:"
msgstr ""
"Перший елемент є цілим числом, що містить комбінацію прапорів напрямку для "
"параметра:"

#: ../../library/ctypes.rst:1805
msgid "1"
msgstr "1"

#: ../../library/ctypes.rst:1806
msgid "Specifies an input parameter to the function."
msgstr "Визначає вхідний параметр для функції."

#: ../../library/ctypes.rst:1808
msgid "2"
msgstr "2"

#: ../../library/ctypes.rst:1809
msgid "Output parameter.  The foreign function fills in a value."
msgstr "Вихідний параметр. Стороння функція заповнює значення."

#: ../../library/ctypes.rst:1811
msgid "4"
msgstr "4"

#: ../../library/ctypes.rst:1812
msgid "Input parameter which defaults to the integer zero."
msgstr "Вхідний параметр, який за умовчанням дорівнює нулю."

#: ../../library/ctypes.rst:1814
msgid ""
"The optional second item is the parameter name as string.  If this is "
"specified, the foreign function can be called with named parameters."
msgstr ""
"Другим необов’язковим елементом є назва параметра у вигляді рядка. Якщо це "
"вказано, зовнішня функція може бути викликана з іменованими параметрами."

#: ../../library/ctypes.rst:1817
msgid "The optional third item is the default value for this parameter."
msgstr ""
"Додатковий третій елемент є значенням за замовчуванням для цього параметра."

#: ../../library/ctypes.rst:1820
msgid ""
"The following example demonstrates how to wrap the Windows ``MessageBoxW`` "
"function so that it supports default parameters and named arguments. The C "
"declaration from the windows header file is this::"
msgstr ""
"В следующем примере показано, как обернуть функцию Windows MessageBoxW так, "
"чтобы она поддерживала параметры по умолчанию и именованные аргументы. "
"Объявление C из файла заголовка Windows выглядит следующим образом:"

#: ../../library/ctypes.rst:1824
msgid ""
"WINUSERAPI int WINAPI\n"
"MessageBoxW(\n"
"    HWND hWnd,\n"
"    LPCWSTR lpText,\n"
"    LPCWSTR lpCaption,\n"
"    UINT uType);"
msgstr ""
"WINUSERAPI int WINAPI\n"
"MessageBoxW(\n"
"    HWND hWnd,\n"
"    LPCWSTR lpText,\n"
"    LPCWSTR lpCaption,\n"
"    UINT uType);"

#: ../../library/ctypes.rst:1831 ../../library/ctypes.rst:1854
msgid "Here is the wrapping with :mod:`ctypes`::"
msgstr "Ось обгортка за допомогою :mod:`ctypes`::"

#: ../../library/ctypes.rst:1833
msgid ""
">>> from ctypes import c_int, WINFUNCTYPE, windll\n"
">>> from ctypes.wintypes import HWND, LPCWSTR, UINT\n"
">>> prototype = WINFUNCTYPE(c_int, HWND, LPCWSTR, LPCWSTR, UINT)\n"
">>> paramflags = (1, \"hwnd\", 0), (1, \"text\", \"Hi\"), (1, \"caption\", "
"\"Hello from ctypes\"), (1, \"flags\", 0)\n"
">>> MessageBox = prototype((\"MessageBoxW\", windll.user32), paramflags)"
msgstr ""
">>> from ctypes import c_int, WINFUNCTYPE, windll\n"
">>> from ctypes.wintypes import HWND, LPCWSTR, UINT\n"
">>> prototype = WINFUNCTYPE(c_int, HWND, LPCWSTR, LPCWSTR, UINT)\n"
">>> paramflags = (1, \"hwnd\", 0), (1, \"text\", \"Hi\"), (1, \"caption\", "
"\"Hello from ctypes\"), (1, \"flags\", 0)\n"
">>> MessageBox = prototype((\"MessageBoxW\", windll.user32), paramflags)"

#: ../../library/ctypes.rst:1839
msgid "The ``MessageBox`` foreign function can now be called in these ways::"
msgstr ""
"Сторонню функцію ``MessageBox`` тепер можна викликати такими способами:"

#: ../../library/ctypes.rst:1841
msgid ""
">>> MessageBox()\n"
">>> MessageBox(text=\"Spam, spam, spam\")\n"
">>> MessageBox(flags=2, text=\"foo bar\")"
msgstr ""
">>> MessageBox()\n"
">>> MessageBox(text=\"Spam, spam, spam\")\n"
">>> MessageBox(flags=2, text=\"foo bar\")"

#: ../../library/ctypes.rst:1845
msgid ""
"A second example demonstrates output parameters.  The win32 "
"``GetWindowRect`` function retrieves the dimensions of a specified window by "
"copying them into ``RECT`` structure that the caller has to supply.  Here is "
"the C declaration::"
msgstr ""
"Другий приклад демонструє вихідні параметри. Функція ``GetWindowRect`` win32 "
"отримує розміри вказаного вікна шляхом копіювання їх у структуру ``RECT``, "
"яку має надати абонент. Ось оголошення C::"

#: ../../library/ctypes.rst:1849
msgid ""
"WINUSERAPI BOOL WINAPI\n"
"GetWindowRect(\n"
"     HWND hWnd,\n"
"     LPRECT lpRect);"
msgstr ""
"WINUSERAPI BOOL WINAPI\n"
"GetWindowRect(\n"
"     HWND hWnd,\n"
"     LPRECT lpRect);"

#: ../../library/ctypes.rst:1856
msgid ""
">>> from ctypes import POINTER, WINFUNCTYPE, windll, WinError\n"
">>> from ctypes.wintypes import BOOL, HWND, RECT\n"
">>> prototype = WINFUNCTYPE(BOOL, HWND, POINTER(RECT))\n"
">>> paramflags = (1, \"hwnd\"), (2, \"lprect\")\n"
">>> GetWindowRect = prototype((\"GetWindowRect\", windll.user32), "
"paramflags)\n"
">>>"
msgstr ""
">>> from ctypes import POINTER, WINFUNCTYPE, windll, WinError\n"
">>> from ctypes.wintypes import BOOL, HWND, RECT\n"
">>> prototype = WINFUNCTYPE(BOOL, HWND, POINTER(RECT))\n"
">>> paramflags = (1, \"hwnd\"), (2, \"lprect\")\n"
">>> GetWindowRect = prototype((\"GetWindowRect\", windll.user32), "
"paramflags)\n"
">>>"

#: ../../library/ctypes.rst:1863
msgid ""
"Functions with output parameters will automatically return the output "
"parameter value if there is a single one, or a tuple containing the output "
"parameter values when there are more than one, so the GetWindowRect function "
"now returns a RECT instance, when called."
msgstr ""
"Функції з вихідними параметрами автоматично повертатимуть значення вихідного "
"параметра, якщо є одне, або кортеж, що містить значення вихідних параметрів, "
"якщо їх декілька, тому функція GetWindowRect тепер повертає екземпляр RECT "
"під час виклику."

#: ../../library/ctypes.rst:1868
msgid ""
"Output parameters can be combined with the :attr:`~_CFuncPtr.errcheck` "
"protocol to do further output processing and error checking.  The win32 "
"``GetWindowRect`` api function returns a ``BOOL`` to signal success or "
"failure, so this function could do the error checking, and raises an "
"exception when the api call failed::"
msgstr ""
"Выходные параметры можно комбинировать с протоколом :attr:`~_CFuncPtr."
"errcheck` для дальнейшей обработки вывода и проверки ошибок. API-функция "
"``GetWindowRect`` в Win32 возвращает BOOL, чтобы сигнализировать об успехе "
"или неудаче, поэтому эта функция может выполнять проверку ошибок и вызывать "
"исключение в случае сбоя вызова API:"

#: ../../library/ctypes.rst:1873
msgid ""
">>> def errcheck(result, func, args):\n"
"...     if not result:\n"
"...         raise WinError()\n"
"...     return args\n"
"...\n"
">>> GetWindowRect.errcheck = errcheck\n"
">>>"
msgstr ""
">>> def errcheck(result, func, args):\n"
"...     if not result:\n"
"...         raise WinError()\n"
"...     return args\n"
"...\n"
">>> GetWindowRect.errcheck = errcheck\n"
">>>"

#: ../../library/ctypes.rst:1881
msgid ""
"If the :attr:`~_CFuncPtr.errcheck` function returns the argument tuple it "
"receives unchanged, :mod:`ctypes` continues the normal processing it does on "
"the output parameters.  If you want to return a tuple of window coordinates "
"instead of a ``RECT`` instance, you can retrieve the fields in the function "
"and return them instead, the normal processing will no longer take place::"
msgstr ""
"Если функция :attr:`~_CFuncPtr.errcheck` возвращает полученный кортеж "
"аргументов без изменений, :mod:`ctypes` продолжает обычную обработку "
"выходных параметров. Если вы хотите вернуть кортеж координат окна вместо "
"экземпляра RECT, вы можете получить поля в функции и вернуть их вместо "
"этого, нормальная обработка больше не будет выполняться:"

#: ../../library/ctypes.rst:1887
msgid ""
">>> def errcheck(result, func, args):\n"
"...     if not result:\n"
"...         raise WinError()\n"
"...     rc = args[1]\n"
"...     return rc.left, rc.top, rc.bottom, rc.right\n"
"...\n"
">>> GetWindowRect.errcheck = errcheck\n"
">>>"
msgstr ""
">>> def errcheck(result, func, args):\n"
"...     if not result:\n"
"...         raise WinError()\n"
"...     rc = args[1]\n"
"...     return rc.left, rc.top, rc.bottom, rc.right\n"
"...\n"
">>> GetWindowRect.errcheck = errcheck\n"
">>>"

#: ../../library/ctypes.rst:1900
msgid "Utility functions"
msgstr "Funções utilitárias"

#: ../../library/ctypes.rst:1904
msgid ""
"Returns the address of the memory buffer as integer.  *obj* must be an "
"instance of a ctypes type."
msgstr ""
"Повертає адресу буфера пам'яті як ціле число. *obj* має бути екземпляром "
"типу ctypes."

#: ../../library/ctypes.rst:1907
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.addressof`` with "
"argument ``obj``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``ctypes.addressof`` com o "
"argumento ``obj``."

#: ../../library/ctypes.rst:1912
msgid ""
"Returns the alignment requirements of a ctypes type. *obj_or_type* must be a "
"ctypes type or instance."
msgstr ""
"Повертає вимоги до вирівнювання типу ctypes. *obj_or_type* має бути типом "
"або екземпляром ctypes."

#: ../../library/ctypes.rst:1918
msgid ""
"Returns a light-weight pointer to *obj*, which must be an instance of a "
"ctypes type.  *offset* defaults to zero, and must be an integer that will be "
"added to the internal pointer value."
msgstr ""
"Повертає легкий вказівник на *obj*, який має бути екземпляром типу ctypes. "
"*offset* за замовчуванням дорівнює нулю і має бути цілим числом, яке буде "
"додано до значення внутрішнього покажчика."

#: ../../library/ctypes.rst:1922
msgid "``byref(obj, offset)`` corresponds to this C code::"
msgstr "``byref(obj, offset)`` відповідає цьому коду C::"

#: ../../library/ctypes.rst:1924
msgid "(((char *)&obj) + offset)"
msgstr "(((char *)&obj) + offset)"

#: ../../library/ctypes.rst:1926
msgid ""
"The returned object can only be used as a foreign function call parameter. "
"It behaves similar to ``pointer(obj)``, but the construction is a lot faster."
msgstr ""
"Повернений об’єкт можна використовувати лише як параметр виклику зовнішньої "
"функції. Він поводиться подібно до ``pointer(obj)``, але будівництво "
"відбувається набагато швидше."

#: ../../library/ctypes.rst:1932
msgid ""
"This function is similar to the cast operator in C. It returns a new "
"instance of *type* which points to the same memory block as *obj*.  *type* "
"must be a pointer type, and *obj* must be an object that can be interpreted "
"as a pointer."
msgstr ""
"Ця функція схожа на оператор приведення в C. Вона повертає новий екземпляр "
"*type*, який вказує на той самий блок пам’яті, що й *obj*. *type* має бути "
"типом покажчика, а *obj* має бути об’єктом, який можна інтерпретувати як "
"покажчик."

#: ../../library/ctypes.rst:1940
msgid ""
"This function creates a mutable character buffer. The returned object is a "
"ctypes array of :class:`c_char`."
msgstr ""
"Ця функція створює змінний символьний буфер. Повернений об’єкт є масивом "
"ctypes :class:`c_char`."

#: ../../library/ctypes.rst:1943
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a bytes object which will be used to initialize the array items."
msgstr ""

#: ../../library/ctypes.rst:1946
msgid ""
"If a bytes object is specified as first argument, the buffer is made one "
"item larger than its length so that the last element in the array is a NUL "
"termination character. An integer can be passed as second argument which "
"allows specifying the size of the array if the length of the bytes should "
"not be used."
msgstr ""

#: ../../library/ctypes.rst:1951
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.create_string_buffer`` "
"with arguments ``init``, ``size``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``ctypes."
"create_string_buffer`` com os argumentos ``init``, ``size``."

#: ../../library/ctypes.rst:1956
msgid ""
"This function creates a mutable unicode character buffer. The returned "
"object is a ctypes array of :class:`c_wchar`."
msgstr ""
"Ця функція створює змінний буфер символів Unicode. Повернений об’єкт є "
"масивом ctypes :class:`c_wchar`."

#: ../../library/ctypes.rst:1959
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a string which will be used to initialize the array items."
msgstr ""

#: ../../library/ctypes.rst:1962
msgid ""
"If a string is specified as first argument, the buffer is made one item "
"larger than the length of the string so that the last element in the array "
"is a NUL termination character. An integer can be passed as second argument "
"which allows specifying the size of the array if the length of the string "
"should not be used."
msgstr ""

#: ../../library/ctypes.rst:1968
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.create_unicode_buffer`` "
"with arguments ``init``, ``size``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``ctypes."
"create_unicode_buffer`` com os argumentos ``init``, ``size``."

#: ../../library/ctypes.rst:1973
msgid ""
"This function is a hook which allows implementing in-process COM servers "
"with ctypes.  It is called from the DllCanUnloadNow function that the "
"_ctypes extension dll exports."
msgstr ""
"Эта функция представляет собой перехватчик, позволяющий реализовывать "
"внутрипроцессные COM-серверы с помощью ctypes. Он вызывается из функции "
"DllCanUnloadNow, которую экспортирует dll расширения _ctypes."

#: ../../library/ctypes.rst:1982
msgid ""
"This function is a hook which allows implementing in-process COM servers "
"with ctypes.  It is called from the DllGetClassObject function that the "
"``_ctypes`` extension dll exports."
msgstr ""
"Эта функция представляет собой перехватчик, позволяющий реализовывать "
"внутрипроцессные COM-серверы с помощью ctypes. Он вызывается из функции "
"DllGetClassObject, которую экспортирует dll расширения ``_ctypes``."

#: ../../library/ctypes.rst:1992
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like ``lib``, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"Спробуйте знайти бібліотеку та повернути шлях. *ім’я* — це ім’я бібліотеки "
"без будь-яких префіксів, як-от ``lib``, суфіксів, як-от ``.so``, ``.dylib`` "
"або номера версії (це форма, яка використовується для параметра "
"компонувальника posix :option:`!-l`). Якщо бібліотеки не знайдено, повертає "
"``None``."

#: ../../library/ctypes.rst:2003
msgid ""
"Returns the filename of the VC runtime library used by Python, and by the "
"extension modules.  If the name of the library cannot be determined, "
"``None`` is returned."
msgstr ""
"Возвращает имя файла библиотеки времени выполнения VC, используемой Python и "
"модулями расширения. Если имя библиотеки невозможно определить, возвращается "
"None."

#: ../../library/ctypes.rst:2007
msgid ""
"If you need to free memory, for example, allocated by an extension module "
"with a call to the ``free(void *)``, it is important that you use the "
"function in the same library that allocated the memory."
msgstr ""
"Якщо вам потрібно звільнити пам’ять, наприклад, виділену модулем розширення "
"за допомогою виклику ``free(void *)``, важливо, щоб ви використовували "
"функцію в тій самій бібліотеці, яка виділила пам’ять."

#: ../../library/ctypes.rst:2016
msgid ""
"Returns a textual description of the error code *code*.  If no error code is "
"specified, the last error code is used by calling the Windows api function "
"GetLastError."
msgstr ""
"Возвращает текстовое описание кода ошибки *code*. Если код ошибки не указан, "
"последний код ошибки используется путем вызова функции API Windows "
"GetLastError."

#: ../../library/ctypes.rst:2025
msgid ""
"Returns the last error code set by Windows in the calling thread. This "
"function calls the Windows ``GetLastError()`` function directly, it does not "
"return the ctypes-private copy of the error code."
msgstr ""
"Возвращает последний код ошибки, установленный Windows в вызывающем потоке. "
"Эта функция напрямую вызывает функцию Windows ``GetLastError()``, она не "
"возвращает частную копию кода ошибки ctypes."

#: ../../library/ctypes.rst:2034
msgid ""
"Returns the current value of the ctypes-private copy of the system :data:"
"`errno` variable in the calling thread."
msgstr ""
"Повертає поточне значення ctypes-private копії системної змінної :data:"
"`errno` у потоці виклику."

#: ../../library/ctypes.rst:2037
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_errno`` with no "
"arguments."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``ctypes.get_errno`` sem "
"argumentos."

#: ../../library/ctypes.rst:2041
msgid ""
"Returns the current value of the ctypes-private copy of the system :data:`!"
"LastError` variable in the calling thread."
msgstr ""
"Возвращает текущее значение ctypes-private копии системной переменной :data:"
"`!LastError` в вызывающем потоке."

#: ../../library/ctypes.rst:2046
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_last_error`` with no "
"arguments."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``ctypes.get_last_error`` "
"sem argumentos."

#: ../../library/ctypes.rst:2051
msgid ""
"Same as the standard C memmove library function: copies *count* bytes from "
"*src* to *dst*. *dst* and *src* must be integers or ctypes instances that "
"can be converted to pointers."
msgstr ""
"Те саме, що стандартна функція бібліотеки C memmove: копіює *count* байти з "
"*src* до *dst*. *dst* і *src* мають бути цілими числами або екземплярами "
"ctypes, які можна перетворити на покажчики."

#: ../../library/ctypes.rst:2058
msgid ""
"Same as the standard C memset library function: fills the memory block at "
"address *dst* with *count* bytes of value *c*. *dst* must be an integer "
"specifying an address, or a ctypes instance."
msgstr ""
"Те саме, що стандартна функція бібліотеки memset C: заповнює блок пам’яті за "
"адресою *dst* *count* байтами зі значенням *c*. *dst* має бути цілим числом, "
"що визначає адресу, або екземпляр ctypes."

#: ../../library/ctypes.rst:2065
msgid ""
"Create and return a new ctypes pointer type. Pointer types are cached and "
"reused internally, so calling this function repeatedly is cheap. *type* must "
"be a ctypes type."
msgstr ""
"Создайте и верните новый тип указателя ctypes. Типы указателей кэшируются и "
"повторно используются внутри, поэтому повторный вызов этой функции обходится "
"дешево. *type* должен быть типом ctypes."

#: ../../library/ctypes.rst:2072
msgid ""
"Create a new pointer instance, pointing to *obj*. The returned object is of "
"the type ``POINTER(type(obj))``."
msgstr ""
"Создайте новый экземпляр указателя, указывающий на *obj*. Возвращаемый "
"объект имеет тип POINTER(type(obj))``."

#: ../../library/ctypes.rst:2075
msgid ""
"Note: If you just want to pass a pointer to an object to a foreign function "
"call, you should use ``byref(obj)`` which is much faster."
msgstr ""
"Примітка. Якщо ви просто хочете передати вказівник на об’єкт у зовнішній "
"виклик функції, вам слід використовувати ``byref(obj)``, що набагато швидше."

#: ../../library/ctypes.rst:2081
msgid ""
"This function resizes the internal memory buffer of *obj*, which must be an "
"instance of a ctypes type.  It is not possible to make the buffer smaller "
"than the native size of the objects type, as given by ``sizeof(type(obj))``, "
"but it is possible to enlarge the buffer."
msgstr ""
"Ця функція змінює розмір буфера внутрішньої пам’яті *obj*, який має бути "
"екземпляром типу ctypes. Неможливо зробити буфер меншим, ніж власний розмір "
"типу об’єктів, як задано ``sizeof(type(obj))``, але можна збільшити буфер."

#: ../../library/ctypes.rst:2089
msgid ""
"Set the current value of the ctypes-private copy of the system :data:`errno` "
"variable in the calling thread to *value* and return the previous value."
msgstr ""
"Установіть поточне значення ctypes-private копії системної змінної :data:"
"`errno` у викликаючому потоці на *value* і поверніть попереднє значення."

#: ../../library/ctypes.rst:2092
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_errno`` with "
"argument ``errno``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``ctypes.set_errno`` com o "
"argumento ``errno``."

#: ../../library/ctypes.rst:2097
msgid ""
"Sets the current value of the ctypes-private copy of the system :data:`!"
"LastError` variable in the calling thread to *value* and return the previous "
"value."
msgstr ""
"Устанавливает текущее значение ctypes-private копии системной переменной :"
"data:`!LastError` в вызывающем потоке в *value* и возвращает предыдущее "
"значение."

#: ../../library/ctypes.rst:2103
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_last_error`` with "
"argument ``error``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``ctypes.set_last_error`` "
"com o argumento ``error``."

#: ../../library/ctypes.rst:2108
msgid ""
"Returns the size in bytes of a ctypes type or instance memory buffer. Does "
"the same as the C ``sizeof`` operator."
msgstr ""
"Повертає розмір у байтах типу ctypes або буфера пам’яті примірника. Діє так "
"само, як і оператор C ``sizeof``."

#: ../../library/ctypes.rst:2114
msgid ""
"Return the byte string at *void \\*ptr*. If *size* is specified, it is used "
"as size, otherwise the string is assumed to be zero-terminated."
msgstr ""
"Верните строку байтов по адресу *void \\*ptr*. Если указан *size*, он "
"используется в качестве размера, в противном случае предполагается, что "
"строка заканчивается нулем."

#: ../../library/ctypes.rst:2118
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.string_at`` with "
"arguments ``ptr``, ``size``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``ctypes.string_at`` com os "
"argumentos ``ptr``, ``size``."

#: ../../library/ctypes.rst:2123
msgid ""
"This function is probably the worst-named thing in ctypes. It creates an "
"instance of :exc:`OSError`.  If *code* is not specified, ``GetLastError`` is "
"called to determine the error code. If *descr* is not specified, :func:"
"`FormatError` is called to get a textual description of the error."
msgstr ""
"Эта функция, вероятно, является самой неудачной вещью в ctypes. Он создает "
"экземпляр :exc:`OSError`. Если *code* не указан, вызывается GetLastError для "
"определения кода ошибки. Если *descr* не указан, вызывается :func:"
"`FormatError` для получения текстового описания ошибки."

#: ../../library/ctypes.rst:2131
msgid ""
"An instance of :exc:`WindowsError` used to be created, which is now an alias "
"of :exc:`OSError`."
msgstr ""
"Раньше был создан экземпляр :exc:`WindowsError`, который теперь является "
"псевдонимом :exc:`OSError`."

#: ../../library/ctypes.rst:2138
msgid ""
"Return the wide-character string at *void \\*ptr*. If *size* is specified, "
"it is used as the number of characters of the string, otherwise the string "
"is assumed to be zero-terminated."
msgstr ""
"Верните строку расширенных символов по адресу *void \\*ptr*. Если указан "
"*size*, он используется как количество символов строки, в противном случае "
"предполагается, что строка заканчивается нулем."

#: ../../library/ctypes.rst:2143
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.wstring_at`` with "
"arguments ``ptr``, ``size``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``ctypes.wstring_at`` com "
"os argumentos ``ptr``, ``size``."

#: ../../library/ctypes.rst:2149
msgid "Data types"
msgstr "Типи даних"

#: ../../library/ctypes.rst:2154
msgid ""
"This non-public class is the common base class of all ctypes data types. "
"Among other things, all ctypes type instances contain a memory block that "
"hold C compatible data; the address of the memory block is returned by the :"
"func:`addressof` helper function. Another instance variable is exposed as :"
"attr:`_objects`; this contains other Python objects that need to be kept "
"alive in case the memory block contains pointers."
msgstr ""
"Цей непублічний клас є загальним базовим класом для всіх типів даних ctypes. "
"Серед іншого, усі екземпляри типу ctypes містять блок пам’яті, який містить "
"C-сумісні дані; адреса блоку пам'яті повертається допоміжною функцією :func:"
"`addressof`. Інша змінна екземпляра представлена як :attr:`_objects`; це "
"містить інші об’єкти Python, які потрібно підтримувати в активному стані, "
"якщо блок пам’яті містить покажчики."

#: ../../library/ctypes.rst:2161
msgid ""
"Common methods of ctypes data types, these are all class methods (to be "
"exact, they are methods of the :term:`metaclass`):"
msgstr ""
"Загальні методи типів даних ctypes, це всі методи класу (точніше, це методи :"
"term:`metaclass`):"

#: ../../library/ctypes.rst:2166
msgid ""
"This method returns a ctypes instance that shares the buffer of the *source* "
"object.  The *source* object must support the writeable buffer interface.  "
"The optional *offset* parameter specifies an offset into the source buffer "
"in bytes; the default is zero.  If the source buffer is not large enough a :"
"exc:`ValueError` is raised."
msgstr ""
"Цей метод повертає екземпляр ctypes, який спільно використовує буфер об’єкта "
"*source*. Об'єкт *джерело* має підтримувати інтерфейс буфера з можливістю "
"запису. Необов'язковий параметр *offset* визначає зсув у вихідному буфері в "
"байтах; за замовчуванням дорівнює нулю. Якщо вихідний буфер недостатньо "
"великий, виникає :exc:`ValueError`."

#: ../../library/ctypes.rst:2172 ../../library/ctypes.rst:2182
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.cdata/buffer`` with "
"arguments ``pointer``, ``size``, ``offset``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``ctypes.cdata/buffer`` com "
"os argumentos ``pointer``, ``size``, ``offset``."

#: ../../library/ctypes.rst:2176
msgid ""
"This method creates a ctypes instance, copying the buffer from the *source* "
"object buffer which must be readable.  The optional *offset* parameter "
"specifies an offset into the source buffer in bytes; the default is zero.  "
"If the source buffer is not large enough a :exc:`ValueError` is raised."
msgstr ""
"Цей метод створює екземпляр ctypes, копіюючи буфер із буфера *джерельного* "
"об’єкта, який має бути читабельним. Необов'язковий параметр *offset* "
"визначає зсув у вихідному буфері в байтах; за замовчуванням дорівнює нулю. "
"Якщо вихідний буфер недостатньо великий, виникає :exc:`ValueError`."

#: ../../library/ctypes.rst:2186
msgid ""
"This method returns a ctypes type instance using the memory specified by "
"*address* which must be an integer."
msgstr ""
"Цей метод повертає екземпляр типу ctypes, використовуючи пам’ять, визначену "
"*адресою*, яка має бути цілим числом."

#: ../../library/ctypes.rst:2189 ../../library/ctypes.rst:2191
msgid ""
"This method, and others that indirectly call this method, raises an :ref:"
"`auditing event <auditing>` ``ctypes.cdata`` with argument ``address``."
msgstr ""
"Este método, e outros que indiretamente chamam este método, levantam um :ref:"
"`evento de auditoria <auditing>` ``ctypes.cdata`` com o argumento "
"``address``."

#: ../../library/ctypes.rst:2197
msgid ""
"This method adapts *obj* to a ctypes type.  It is called with the actual "
"object used in a foreign function call when the type is present in the "
"foreign function's :attr:`~_CFuncPtr.argtypes` tuple; it must return an "
"object that can be used as a function call parameter."
msgstr ""
"Этот метод адаптирует *obj* к типу ctypes. Он вызывается с фактическим "
"объектом, используемым при вызове сторонней функции, когда тип присутствует "
"в кортеже :attr:`~_CFuncPtr.argtypes` сторонней функции; он должен "
"возвращать объект, который можно использовать в качестве параметра вызова "
"функции."

#: ../../library/ctypes.rst:2202
msgid ""
"All ctypes data types have a default implementation of this classmethod that "
"normally returns *obj* if that is an instance of the type.  Some types "
"accept other objects as well."
msgstr ""
"Усі типи даних ctypes мають стандартну реалізацію цього методу класу, який "
"зазвичай повертає *obj*, якщо це екземпляр типу. Деякі типи також приймають "
"інші об’єкти."

#: ../../library/ctypes.rst:2208
msgid ""
"This method returns a ctypes type instance exported by a shared library. "
"*name* is the name of the symbol that exports the data, *library* is the "
"loaded shared library."
msgstr ""
"Цей метод повертає екземпляр типу ctypes, експортований спільною "
"бібліотекою. *name* — це ім’я символу, який експортує дані, *library* — це "
"завантажена спільна бібліотека."

#: ../../library/ctypes.rst:2212
msgid "Common instance variables of ctypes data types:"
msgstr "Загальні змінні екземплярів типів даних ctypes:"

#: ../../library/ctypes.rst:2216
msgid ""
"Sometimes ctypes data instances do not own the memory block they contain, "
"instead they share part of the memory block of a base object.  The :attr:"
"`_b_base_` read-only member is the root ctypes object that owns the memory "
"block."
msgstr ""
"Іноді екземпляри даних ctypes не володіють блоком пам’яті, який вони "
"містять, натомість вони спільно використовують частину блоку пам’яті "
"базового об’єкта. Член :attr:`_b_base_` лише для читання є кореневим "
"об’єктом ctypes, якому належить блок пам’яті."

#: ../../library/ctypes.rst:2223
msgid ""
"This read-only variable is true when the ctypes data instance has allocated "
"the memory block itself, false otherwise."
msgstr ""
"Ця змінна лише для читання є істиною, коли екземпляр даних ctypes сам "
"виділив блок пам’яті, інакше – false."

#: ../../library/ctypes.rst:2228
msgid ""
"This member is either ``None`` or a dictionary containing Python objects "
"that need to be kept alive so that the memory block contents is kept valid.  "
"This object is only exposed for debugging; never modify the contents of this "
"dictionary."
msgstr ""
"Цей член або ``None``, або словник, що містить об’єкти Python, які потрібно "
"підтримувати в активному стані, щоб вміст блоку пам’яті залишався дійсним. "
"Цей об’єкт доступний лише для налагодження; ніколи не змінюйте вміст цього "
"словника."

#: ../../library/ctypes.rst:2241
msgid ""
"This non-public class is the base class of all fundamental ctypes data "
"types. It is mentioned here because it contains the common attributes of the "
"fundamental ctypes data types.  :class:`_SimpleCData` is a subclass of :"
"class:`_CData`, so it inherits their methods and attributes. ctypes data "
"types that are not and do not contain pointers can now be pickled."
msgstr ""
"Цей закритий клас є базовим класом усіх основних типів даних ctypes. Він "
"згадується тут, оскільки він містить загальні атрибути основних типів даних "
"ctypes. :class:`_SimpleCData` є підкласом :class:`_CData`, тому він "
"успадковує їхні методи та атрибути. Типи даних ctypes, які не є та не "
"містять покажчиків, тепер можна маринувати."

#: ../../library/ctypes.rst:2247
msgid "Instances have a single attribute:"
msgstr "Екземпляри мають один атрибут:"

#: ../../library/ctypes.rst:2251
msgid ""
"This attribute contains the actual value of the instance. For integer and "
"pointer types, it is an integer, for character types, it is a single "
"character bytes object or string, for character pointer types it is a Python "
"bytes object or string."
msgstr ""
"Цей атрибут містить фактичне значення екземпляра. Для цілочисельних типів і "
"типів покажчиків це ціле число, для типів символів – об’єкт або рядок із "
"одним символом у байтах, для типів покажчиків на символи – це об’єкт або "
"рядок Python bytes."

#: ../../library/ctypes.rst:2256
msgid ""
"When the ``value`` attribute is retrieved from a ctypes instance, usually a "
"new object is returned each time.  :mod:`ctypes` does *not* implement "
"original object return, always a new object is constructed.  The same is "
"true for all other ctypes object instances."
msgstr ""
"Коли атрибут ``value`` отримується з екземпляра ctypes, зазвичай щоразу "
"повертається новий об’єкт. :mod:`ctypes` *не* реалізує повернення "
"оригінального об’єкта, завжди створюється новий об’єкт. Те саме стосується "
"всіх інших екземплярів об’єктів ctypes."

#: ../../library/ctypes.rst:2262
msgid ""
"Fundamental data types, when returned as foreign function call results, or, "
"for example, by retrieving structure field members or array items, are "
"transparently converted to native Python types.  In other words, if a "
"foreign function has a :attr:`~_CFuncPtr.restype` of :class:`c_char_p`, you "
"will always receive a Python bytes object, *not* a :class:`c_char_p` "
"instance."
msgstr ""
"Фундаментальные типы данных, возвращаемые в виде результатов вызова "
"сторонней функции или, например, путем получения элементов поля структуры "
"или элементов массива, прозрачно преобразуются в собственные типы Python. "
"Другими словами, если внешняя функция имеет :attr:`~_CFuncPtr.restype` :"
"class:`c_char_p`, вы всегда получите байтовый объект Python, *а не* "
"экземпляр :class:`c_char_p`."

#: ../../library/ctypes.rst:2270
msgid ""
"Subclasses of fundamental data types do *not* inherit this behavior. So, if "
"a foreign functions :attr:`!restype` is a subclass of :class:`c_void_p`, you "
"will receive an instance of this subclass from the function call. Of course, "
"you can get the value of the pointer by accessing the ``value`` attribute."
msgstr ""
"Подклассы фундаментальных типов данных *не* наследуют это поведение. Итак, "
"если внешняя функция :attr:`!restype` является подклассом :class:`c_void_p`, "
"вы получите экземпляр этого подкласса при вызове функции. Конечно, вы можете "
"получить значение указателя, обратившись к атрибуту value."

#: ../../library/ctypes.rst:2275
msgid "These are the fundamental ctypes data types:"
msgstr "Ось основні типи даних ctypes:"

#: ../../library/ctypes.rst:2279
msgid ""
"Represents the C :c:expr:`signed char` datatype, and interprets the value as "
"small integer.  The constructor accepts an optional integer initializer; no "
"overflow checking is done."
msgstr ""
"Представляет тип данных C :c:expr:`signed char` и интерпретирует значение "
"как небольшое целое число. Конструктор принимает необязательный "
"целочисленный инициализатор; проверка переполнения не производится."

#: ../../library/ctypes.rst:2286
msgid ""
"Represents the C :c:expr:`char` datatype, and interprets the value as a "
"single character.  The constructor accepts an optional string initializer, "
"the length of the string must be exactly one character."
msgstr ""
"Представляет тип данных C :c:expr:`char` и интерпретирует значение как один "
"символ. Конструктор принимает необязательный строковый инициализатор, длина "
"строки должна составлять ровно один символ."

#: ../../library/ctypes.rst:2293
msgid ""
"Represents the C :c:expr:`char *` datatype when it points to a zero-"
"terminated string.  For a general character pointer that may also point to "
"binary data, ``POINTER(c_char)`` must be used.  The constructor accepts an "
"integer address, or a bytes object."
msgstr ""
"Представляет тип данных C :c:expr:`char *`, когда он указывает на строку с "
"нулевым завершением. Для общего указателя символа, который также может "
"указывать на двоичные данные, необходимо использовать POINTER(c_char). "
"Конструктор принимает целочисленный адрес или байтовый объект."

#: ../../library/ctypes.rst:2301
msgid ""
"Represents the C :c:expr:`double` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""
"Представляет тип данных C :c:expr:`double`. Конструктор принимает "
"необязательный инициализатор с плавающей запятой."

#: ../../library/ctypes.rst:2307
msgid ""
"Represents the C :c:expr:`long double` datatype.  The constructor accepts an "
"optional float initializer.  On platforms where ``sizeof(long double) == "
"sizeof(double)`` it is an alias to :class:`c_double`."
msgstr ""
"Представляет тип данных C :c:expr:`long double`. Конструктор принимает "
"необязательный инициализатор с плавающей запятой. На платформах, где "
"``sizeof(long double) == sizeof(double)``, это псевдоним :class:`c_double`."

#: ../../library/ctypes.rst:2313
msgid ""
"Represents the C :c:expr:`float` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""
"Представляет тип данных C :c:expr:`float`. Конструктор принимает "
"необязательный инициализатор с плавающей запятой."

#: ../../library/ctypes.rst:2319
msgid ""
"Represents the C :c:expr:`signed int` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias to :class:`c_long`."
msgstr ""
"Представляет тип данных C :c:expr:`signed int`. Конструктор принимает "
"необязательный целочисленный инициализатор; проверка переполнения не "
"производится. На платформах, где ``sizeof(int) == sizeof(long)``, это "
"псевдоним :class:`c_long`."

#: ../../library/ctypes.rst:2326
msgid ""
"Represents the C 8-bit :c:expr:`signed int` datatype.  Usually an alias for :"
"class:`c_byte`."
msgstr ""
"Представляет 8-битный тип данных C :c:expr:`signed int`. Обычно это "
"псевдоним :class:`c_byte`."

#: ../../library/ctypes.rst:2332
msgid ""
"Represents the C 16-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_short`."
msgstr ""
"Представляет 16-битный тип данных C :c:expr:`signed int`. Обычно это "
"псевдоним :class:`c_short`."

#: ../../library/ctypes.rst:2338
msgid ""
"Represents the C 32-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_int`."
msgstr ""
"Представляет 32-битный тип данных C :c:expr:`signed int`. Обычно это "
"псевдоним :class:`c_int`."

#: ../../library/ctypes.rst:2344
msgid ""
"Represents the C 64-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_longlong`."
msgstr ""
"Представляет 64-битный тип данных C :c:expr:`signed int`. Обычно это "
"псевдоним :class:`c_longlong`."

#: ../../library/ctypes.rst:2350
msgid ""
"Represents the C :c:expr:`signed long` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done."
msgstr ""
"Представляет тип данных C :c:expr:`signed long`. Конструктор принимает "
"необязательный целочисленный инициализатор; проверка переполнения не "
"производится."

#: ../../library/ctypes.rst:2356
msgid ""
"Represents the C :c:expr:`signed long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"Представляет тип данных C :c:expr:`signed long long`. Конструктор принимает "
"необязательный целочисленный инициализатор; проверка переполнения не "
"производится."

#: ../../library/ctypes.rst:2362
msgid ""
"Represents the C :c:expr:`signed short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"Представляет тип данных C :c:expr:`signed short`. Конструктор принимает "
"необязательный целочисленный инициализатор; проверка переполнения не "
"производится."

#: ../../library/ctypes.rst:2368
msgid "Represents the C :c:type:`size_t` datatype."
msgstr "Представляє тип даних C :c:type:`size_t`."

#: ../../library/ctypes.rst:2373
msgid "Represents the C :c:type:`ssize_t` datatype."
msgstr "Представляє тип даних C :c:type:`ssize_t`."

#: ../../library/ctypes.rst:2380
msgid "Represents the C :c:type:`time_t` datatype."
msgstr "Представляет тип данных C :c:type:`time_t`."

#: ../../library/ctypes.rst:2387
msgid ""
"Represents the C :c:expr:`unsigned char` datatype, it interprets the value "
"as small integer.  The constructor accepts an optional integer initializer; "
"no overflow checking is done."
msgstr ""
"Представляет тип данных C :c:expr:`unsigned char`, он интерпретирует "
"значение как небольшое целое число. Конструктор принимает необязательный "
"целочисленный инициализатор; проверка переполнения не производится."

#: ../../library/ctypes.rst:2394
msgid ""
"Represents the C :c:expr:`unsigned int` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias for :class:`c_ulong`."
msgstr ""
"Представляет тип данных C :c:expr:`unsigned int`. Конструктор принимает "
"необязательный целочисленный инициализатор; проверка переполнения не "
"производится. На платформах, где ``sizeof(int) == sizeof(long)`` это "
"псевдоним для :class:`c_ulong`."

#: ../../library/ctypes.rst:2401
msgid ""
"Represents the C 8-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ubyte`."
msgstr ""
"Представляет 8-битный тип данных C :c:expr:`unsigned int`. Обычно это "
"псевдоним :class:`c_ubyte`."

#: ../../library/ctypes.rst:2407
msgid ""
"Represents the C 16-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ushort`."
msgstr ""
"Представляет 16-битный тип данных C :c:expr:`unsigned int`. Обычно это "
"псевдоним :class:`c_ushort`."

#: ../../library/ctypes.rst:2413
msgid ""
"Represents the C 32-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_uint`."
msgstr ""
"Представляет 32-битный тип данных C :c:expr:`unsigned int`. Обычно это "
"псевдоним :class:`c_uint`."

#: ../../library/ctypes.rst:2419
msgid ""
"Represents the C 64-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ulonglong`."
msgstr ""
"Представляет 64-битный тип данных C :c:expr:`unsigned int`. Обычно это "
"псевдоним :class:`c_ulonglong`."

#: ../../library/ctypes.rst:2425
msgid ""
"Represents the C :c:expr:`unsigned long` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"Представляет тип данных C :c:expr:`unsigned long`. Конструктор принимает "
"необязательный целочисленный инициализатор; проверка переполнения не "
"производится."

#: ../../library/ctypes.rst:2431
msgid ""
"Represents the C :c:expr:`unsigned long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"Представляет тип данных C :c:expr:`unsigned long long`. Конструктор "
"принимает необязательный целочисленный инициализатор; проверка переполнения "
"не производится."

#: ../../library/ctypes.rst:2437
msgid ""
"Represents the C :c:expr:`unsigned short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"Представляет тип данных C :c:expr:`unsigned short`. Конструктор принимает "
"необязательный целочисленный инициализатор; проверка переполнения не "
"производится."

#: ../../library/ctypes.rst:2443
msgid ""
"Represents the C :c:expr:`void *` type.  The value is represented as "
"integer. The constructor accepts an optional integer initializer."
msgstr ""
"Представляет тип C :c:expr:`void *`. Значение представляется как целое "
"число. Конструктор принимает необязательный целочисленный инициализатор."

#: ../../library/ctypes.rst:2449
msgid ""
"Represents the C :c:type:`wchar_t` datatype, and interprets the value as a "
"single character unicode string.  The constructor accepts an optional string "
"initializer, the length of the string must be exactly one character."
msgstr ""
"Представляє тип даних C :c:type:`wchar_t` і інтерпретує значення як "
"односимвольний рядок Unicode. Конструктор приймає необов’язковий "
"ініціалізатор рядка, довжина рядка має бути рівно одному символу."

#: ../../library/ctypes.rst:2456
msgid ""
"Represents the C :c:expr:`wchar_t *` datatype, which must be a pointer to a "
"zero-terminated wide character string.  The constructor accepts an integer "
"address, or a string."
msgstr ""
"Представляет тип данных C :c:expr:`wchar_t *`, который должен быть "
"указателем на строку широких символов, завершающуюся нулем. Конструктор "
"принимает целочисленный адрес или строку."

#: ../../library/ctypes.rst:2463
msgid ""
"Represent the C :c:expr:`bool` datatype (more accurately, :c:expr:`_Bool` "
"from C99).  Its value can be ``True`` or ``False``, and the constructor "
"accepts any object that has a truth value."
msgstr ""
"Представляет тип данных C :c:expr:`bool` (точнее, :c:expr:`_Bool` из C99). "
"Его значение может быть ``True`` или ``False``, и конструктор принимает "
"любой объект, имеющий значение истинности."

#: ../../library/ctypes.rst:2470
msgid ""
"Represents a :c:type:`!HRESULT` value, which contains success or error "
"information for a function or method call."
msgstr ""
"Представляет значение :c:type:`!HRESULT`, которое содержит информацию об "
"успехе или ошибке вызова функции или метода."

#: ../../library/ctypes.rst:2478
msgid ""
"Represents the C :c:expr:`PyObject *` datatype.  Calling this without an "
"argument creates a ``NULL`` :c:expr:`PyObject *` pointer."
msgstr ""
"Представляет тип данных C :c:expr:`PyObject *`. Вызов этого без аргумента "
"создает указатель ``NULL`` :c:expr:`PyObject *`."

#: ../../library/ctypes.rst:2481
msgid ""
"The :mod:`!ctypes.wintypes` module provides quite some other Windows "
"specific data types, for example :c:type:`!HWND`, :c:type:`!WPARAM`, or :c:"
"type:`!DWORD`. Some useful structures like :c:type:`!MSG` or :c:type:`!RECT` "
"are also defined."
msgstr ""
"Модуль :mod:`!ctypes.wintypes` предоставляет некоторые другие типы данных, "
"специфичные для Windows, например :c:type:`!HWND`, :c:type:`!WPARAM` или :c:"
"type:`! ДВОРД`. Также определены некоторые полезные структуры, такие как :c:"
"type:`!MSG` или :c:type:`!RECT`."

#: ../../library/ctypes.rst:2489
msgid "Structured data types"
msgstr "Tipe data terstruktur"

#: ../../library/ctypes.rst:2494
msgid "Abstract base class for unions in native byte order."
msgstr "Абстрактний базовий клас для об’єднань у рідному порядку байтів."

#: ../../library/ctypes.rst:2499
msgid "Abstract base class for unions in *big endian* byte order."
msgstr ""
"Абстрактный базовый класс для объединений в порядке байтов *big endian*."

#: ../../library/ctypes.rst:2505
msgid "Abstract base class for unions in *little endian* byte order."
msgstr ""
"Абстрактный базовый класс для объединений в порядке байтов *little endian*."

#: ../../library/ctypes.rst:2511
msgid "Abstract base class for structures in *big endian* byte order."
msgstr "Абстрактний базовий клас для структур у *великому порядку байтів*."

#: ../../library/ctypes.rst:2516
msgid "Abstract base class for structures in *little endian* byte order."
msgstr ""
"Абстрактний базовий клас для структур у порядку байтів *little endian*."

#: ../../library/ctypes.rst:2518
msgid ""
"Structures and unions with non-native byte order cannot contain pointer type "
"fields, or any other data types containing pointer type fields."
msgstr ""
"Структуры и объединения с несобственным порядком байтов не могут содержать "
"поля типа указателя или любые другие типы данных, содержащие поля типа "
"указателя."

#: ../../library/ctypes.rst:2524
msgid "Abstract base class for structures in *native* byte order."
msgstr "Абстрактний базовий клас для структур у *власному* порядку байтів."

#: ../../library/ctypes.rst:2526
msgid ""
"Concrete structure and union types must be created by subclassing one of "
"these types, and at least define a :attr:`_fields_` class variable. :mod:"
"`ctypes` will create :term:`descriptor`\\s which allow reading and writing "
"the fields by direct attribute accesses.  These are the"
msgstr ""
"Конкретні типи структури та об’єднання мають бути створені шляхом створення "
"підкласу одного з цих типів і принаймні визначення змінної класу :attr:"
"`_fields_`. :mod:`ctypes` створить :term:`descriptor`\\s, які дозволяють "
"читати та записувати поля за допомогою прямого доступу до атрибутів. Це"

#: ../../library/ctypes.rst:2534
msgid ""
"A sequence defining the structure fields.  The items must be 2-tuples or 3-"
"tuples.  The first item is the name of the field, the second item specifies "
"the type of the field; it can be any ctypes data type."
msgstr ""
"Послідовність, що визначає поля структури. Елементи мають бути 2-кортежними "
"або 3-кортежними. Перший пункт – ім’я поля, другий – тип поля; це може бути "
"будь-який тип даних ctypes."

#: ../../library/ctypes.rst:2538
msgid ""
"For integer type fields like :class:`c_int`, a third optional item can be "
"given.  It must be a small positive integer defining the bit width of the "
"field."
msgstr ""
"Для полів цілого типу, таких як :class:`c_int`, можна вказати третій "
"необов’язковий елемент. Це має бути маленьке позитивне ціле число, що "
"визначає розрядність поля."

#: ../../library/ctypes.rst:2542
msgid ""
"Field names must be unique within one structure or union.  This is not "
"checked, only one field can be accessed when names are repeated."
msgstr ""
"Імена полів мають бути унікальними в межах однієї структури чи об’єднання. "
"Це не позначено, лише одне поле доступне, якщо імена повторюються."

#: ../../library/ctypes.rst:2545
msgid ""
"It is possible to define the :attr:`_fields_` class variable *after* the "
"class statement that defines the Structure subclass, this allows creating "
"data types that directly or indirectly reference themselves::"
msgstr ""
"Можна визначити змінну класу :attr:`_fields_` *після* оператора класу, який "
"визначає підклас Structure, це дозволяє створювати типи даних, які прямо чи "
"опосередковано посилаються на себе::"

#: ../../library/ctypes.rst:2549
msgid ""
"class List(Structure):\n"
"    pass\n"
"List._fields_ = [(\"pnext\", POINTER(List)),\n"
"                 ...\n"
"                ]"
msgstr ""
"class List(Structure):\n"
"    pass\n"
"List._fields_ = [(\"pnext\", POINTER(List)),\n"
"                 ...\n"
"                ]"

#: ../../library/ctypes.rst:2555
msgid ""
"The :attr:`_fields_` class variable must, however, be defined before the "
"type is first used (an instance is created, :func:`sizeof` is called on it, "
"and so on).  Later assignments to the :attr:`_fields_` class variable will "
"raise an AttributeError."
msgstr ""
"Однак змінну класу :attr:`_fields_` потрібно визначити перед першим "
"використанням типу (створюється екземпляр, для нього викликається :func:"
"`sizeof` і так далі). Пізніше призначення змінній класу :attr:`_fields_` "
"призведе до помилки AttributeError."

#: ../../library/ctypes.rst:2560
msgid ""
"It is possible to define sub-subclasses of structure types, they inherit the "
"fields of the base class plus the :attr:`_fields_` defined in the sub-"
"subclass, if any."
msgstr ""
"Можна визначити під-підкласи структурних типів, вони успадковують поля "
"базового класу плюс :attr:`_fields_`, визначені в під-підкласі, якщо такі є."

#: ../../library/ctypes.rst:2567
msgid ""
"An optional small integer that allows overriding the alignment of structure "
"fields in the instance.  :attr:`_pack_` must already be defined when :attr:"
"`_fields_` is assigned, otherwise it will have no effect. Setting this "
"attribute to 0 is the same as not setting it at all."
msgstr ""
"Необязательное небольшое целое число, позволяющее переопределить "
"выравнивание полей структуры в экземпляре. :attr:`_pack_` должен быть уже "
"определен при назначении :attr:`_fields_`, иначе он не будет иметь никакого "
"эффекта. Установка этого атрибута в 0 — это то же самое, что не установка "
"его вообще."

#: ../../library/ctypes.rst:2575
msgid ""
"An optional sequence that lists the names of unnamed (anonymous) fields. :"
"attr:`_anonymous_` must be already defined when :attr:`_fields_` is "
"assigned, otherwise it will have no effect."
msgstr ""
"Необов’язкова послідовність, яка містить імена безіменних (анонімних) "
"полів. :attr:`_anonymous_` має бути вже визначено під час призначення :attr:"
"`_fields_`, інакше це не матиме ефекту."

#: ../../library/ctypes.rst:2579
msgid ""
"The fields listed in this variable must be structure or union type fields. :"
"mod:`ctypes` will create descriptors in the structure type that allows "
"accessing the nested fields directly, without the need to create the "
"structure or union field."
msgstr ""
"Поля, перелічені в цій змінній, мають бути структурними або об’єднаними. :"
"mod:`ctypes` створить дескриптори у структурному типі, що дозволяє отримати "
"доступ до вкладених полів безпосередньо, без необхідності створювати "
"структуру чи поле об’єднання."

#: ../../library/ctypes.rst:2584
msgid "Here is an example type (Windows)::"
msgstr "Ось приклад типу (Windows):"

#: ../../library/ctypes.rst:2586
msgid ""
"class _U(Union):\n"
"    _fields_ = [(\"lptdesc\", POINTER(TYPEDESC)),\n"
"                (\"lpadesc\", POINTER(ARRAYDESC)),\n"
"                (\"hreftype\", HREFTYPE)]\n"
"\n"
"class TYPEDESC(Structure):\n"
"    _anonymous_ = (\"u\",)\n"
"    _fields_ = [(\"u\", _U),\n"
"                (\"vt\", VARTYPE)]"
msgstr ""
"class _U(Union):\n"
"    _fields_ = [(\"lptdesc\", POINTER(TYPEDESC)),\n"
"                (\"lpadesc\", POINTER(ARRAYDESC)),\n"
"                (\"hreftype\", HREFTYPE)]\n"
"\n"
"class TYPEDESC(Structure):\n"
"    _anonymous_ = (\"u\",)\n"
"    _fields_ = [(\"u\", _U),\n"
"                (\"vt\", VARTYPE)]"

#: ../../library/ctypes.rst:2597
msgid ""
"The ``TYPEDESC`` structure describes a COM data type, the ``vt`` field "
"specifies which one of the union fields is valid.  Since the ``u`` field is "
"defined as anonymous field, it is now possible to access the members "
"directly off the TYPEDESC instance. ``td.lptdesc`` and ``td.u.lptdesc`` are "
"equivalent, but the former is faster since it does not need to create a "
"temporary union instance::"
msgstr ""
"Структура ``TYPEDESC`` описує тип даних COM, поле ``vt`` визначає, яке з "
"полів об’єднання є дійсним. Оскільки поле ``u`` визначено як анонімне поле, "
"тепер можна отримати доступ до членів безпосередньо з примірника TYPEDESC. "
"``td.lptdesc`` і ``td.u.lptdesc`` еквівалентні, але перший швидший, оскільки "
"йому не потрібно створювати тимчасовий екземпляр об’єднання::"

#: ../../library/ctypes.rst:2604
msgid ""
"td = TYPEDESC()\n"
"td.vt = VT_PTR\n"
"td.lptdesc = POINTER(some_type)\n"
"td.u.lptdesc = POINTER(some_type)"
msgstr ""
"td = TYPEDESC()\n"
"td.vt = VT_PTR\n"
"td.lptdesc = POINTER(some_type)\n"
"td.u.lptdesc = POINTER(some_type)"

#: ../../library/ctypes.rst:2609
msgid ""
"It is possible to define sub-subclasses of structures, they inherit the "
"fields of the base class.  If the subclass definition has a separate :attr:"
"`_fields_` variable, the fields specified in this are appended to the fields "
"of the base class."
msgstr ""
"Є можливість визначення суб-підкласів структур, вони успадковують поля "
"базового класу. Якщо визначення підкласу має окрему змінну :attr:`_fields_`, "
"поля, зазначені в ній, додаються до полів базового класу."

#: ../../library/ctypes.rst:2614
msgid ""
"Structure and union constructors accept both positional and keyword "
"arguments.  Positional arguments are used to initialize member fields in the "
"same order as they are appear in :attr:`_fields_`.  Keyword arguments in the "
"constructor are interpreted as attribute assignments, so they will "
"initialize :attr:`_fields_` with the same name, or create new attributes for "
"names not present in :attr:`_fields_`."
msgstr ""
"Конструктори структури та об’єднання приймають як позиційні, так і ключові "
"аргументи. Позиційні аргументи використовуються для ініціалізації полів-"
"членів у такому самому порядку, як вони з’являються в :attr:`_fields_`. "
"Аргументи ключових слів у конструкторі інтерпретуються як призначення "
"атрибутів, тому вони ініціалізують :attr:`_fields_` з тим же іменем або "
"створять нові атрибути для імен, яких немає в :attr:`_fields_`."

#: ../../library/ctypes.rst:2625
msgid "Arrays and pointers"
msgstr "Масиви та покажчики"

#: ../../library/ctypes.rst:2629
msgid "Abstract base class for arrays."
msgstr "Абстрактний базовий клас для масивів."

#: ../../library/ctypes.rst:2631
msgid ""
"The recommended way to create concrete array types is by multiplying any :"
"mod:`ctypes` data type with a non-negative integer.  Alternatively, you can "
"subclass this type and define :attr:`_length_` and :attr:`_type_` class "
"variables. Array elements can be read and written using standard subscript "
"and slice accesses; for slice reads, the resulting object is *not* itself "
"an :class:`Array`."
msgstr ""
"Рекомендований спосіб створення конкретних типів масивів — це множення будь-"
"якого типу даних :mod:`ctypes` на невід’ємне ціле число. Крім того, ви "
"можете створити підклас цього типу та визначити змінні класу :attr:"
"`_length_` і :attr:`_type_`. Елементи масиву можна читати та записувати за "
"допомогою стандартного підрядкового і зрізного доступу; для зчитування "
"фрагментів результуючий об’єкт *не* сам є :class:`Array`."

#: ../../library/ctypes.rst:2641
msgid ""
"A positive integer specifying the number of elements in the array. Out-of-"
"range subscripts result in an :exc:`IndexError`. Will be returned by :func:"
"`len`."
msgstr ""
"Додатне ціле число, що визначає кількість елементів у масиві. Індекси поза "
"діапазоном призводять до :exc:`IndexError`. Буде повернено :func:`len`."

#: ../../library/ctypes.rst:2648
msgid "Specifies the type of each element in the array."
msgstr "Визначає тип кожного елемента в масиві."

#: ../../library/ctypes.rst:2651
msgid ""
"Array subclass constructors accept positional arguments, used to initialize "
"the elements in order."
msgstr ""
"Конструктори підкласу масиву приймають позиційні аргументи, які "
"використовуються для ініціалізації елементів у порядку."

#: ../../library/ctypes.rst:2657
msgid "Private, abstract base class for pointers."
msgstr "Приватний, абстрактний базовий клас для вказівників."

#: ../../library/ctypes.rst:2659
msgid ""
"Concrete pointer types are created by calling :func:`POINTER` with the type "
"that will be pointed to; this is done automatically by :func:`pointer`."
msgstr ""
"Конкретні типи вказівників створюються шляхом виклику :func:`POINTER` із "
"типом, на який буде вказувати; це робиться автоматично за допомогою :func:"
"`pointer`."

#: ../../library/ctypes.rst:2663
msgid ""
"If a pointer points to an array, its elements can be read and written using "
"standard subscript and slice accesses.  Pointer objects have no size, so :"
"func:`len` will raise :exc:`TypeError`.  Negative subscripts will read from "
"the memory *before* the pointer (as in C), and out-of-range subscripts will "
"probably crash with an access violation (if you're lucky)."
msgstr ""
"Якщо вказівник вказує на масив, його елементи можна читати та записувати за "
"допомогою стандартного підрядкового і зрізного доступу. Об’єкти-вказівники "
"не мають розміру, тому :func:`len` викличе :exc:`TypeError`. Негативні "
"індекси читатимуться з пам’яті *перед* вказівником (як у C), а індекси поза "
"межами діапазону, ймовірно, впадуть із порушенням доступу (якщо вам "
"пощастить)."

#: ../../library/ctypes.rst:2673
msgid "Specifies the type pointed to."
msgstr "Визначає тип, на який вказується."

#: ../../library/ctypes.rst:2677
msgid ""
"Returns the object to which to pointer points.  Assigning to this attribute "
"changes the pointer to point to the assigned object."
msgstr ""
"Повертає об’єкт, на який вказує вказівник. Призначення цьому атрибуту змінює "
"вказівник на призначений об’єкт."

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2017
# Juliana Karoline <julianaklulo@gmail.com>, 2019
# Marco Rougeth <marco@rougeth.com>, 2020
# i17obot <i17obot@rougeth.com>, 2021
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 17:51+0000\n"
"PO-Revision-Date: 2017-02-16 23:17+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/logging.handlers.rst:2
msgid ":mod:`logging.handlers` --- Logging handlers"
msgstr ":mod:`logging.handlers` --- Tratadores de registro"

#: ../../library/logging.handlers.rst:10
msgid "**Source code:** :source:`Lib/logging/handlers.py`"
msgstr "**Código-fonte:** :source:`Lib/logging/handlers.py`"

#: ../../library/logging.handlers.rst:14
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr ""
"Esta página contém apenas informações de referência. Para tutoriais, por "
"favor consulte"

#: ../../library/logging.handlers.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Tutorial básico <logging-basic-tutorial>`"

#: ../../library/logging.handlers.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Tutorial avançado <logging-advanced-tutorial>`"

#: ../../library/logging.handlers.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`Livro de receitas de logging <logging-cookbook>`"

#: ../../library/logging.handlers.rst:25
msgid ""
"The following useful handlers are provided in the package. Note that three "
"of the handlers (:class:`StreamHandler`, :class:`FileHandler` and :class:"
"`NullHandler`) are actually defined in the :mod:`logging` module itself, but "
"have been documented here along with the other handlers."
msgstr ""
"Os seguintes tratadores úteis são fornecidos neste pacote. Observe que três "
"dos tratadores (:class:`StreamHandler`, :class:`FileHandler` e :class:"
"`NullHandler`) são, na verdade, definidos no próprio módulo :mod:`logging`, "
"mas foram documentados aqui junto com os outros tratadores."

#: ../../library/logging.handlers.rst:33
msgid "StreamHandler"
msgstr "StreamHandler"

#: ../../library/logging.handlers.rst:35
msgid ""
"The :class:`StreamHandler` class, located in the core :mod:`logging` "
"package, sends logging output to streams such as *sys.stdout*, *sys.stderr* "
"or any file-like object (or, more precisely, any object which supports :meth:"
"`write` and :meth:`flush` methods)."
msgstr ""
"Клас :class:`StreamHandler`, розташований у базовому пакеті :mod:`logging`, "
"надсилає вихідні дані журналу до таких потоків, як *sys.stdout*, *sys."
"stderr* або будь-якого файлоподібного об’єкта (або, точніше, , будь-який "
"об’єкт, який підтримує методи :meth:`write` і :meth:`flush`)."

#: ../../library/logging.handlers.rst:43
msgid ""
"Returns a new instance of the :class:`StreamHandler` class. If *stream* is "
"specified, the instance will use it for logging output; otherwise, *sys."
"stderr* will be used."
msgstr ""
"Повертає новий екземпляр класу :class:`StreamHandler`. Якщо вказано *потік*, "
"примірник використовуватиме його для журналювання виводу; інакше буде "
"використано *sys.stderr*."

#: ../../library/logging.handlers.rst:50
msgid ""
"If a formatter is specified, it is used to format the record. The record is "
"then written to the stream followed by :attr:`terminator`. If exception "
"information is present, it is formatted using :func:`traceback."
"print_exception` and appended to the stream."
msgstr ""
"Якщо вказано засіб форматування, він використовується для форматування "
"запису. Потім запис записується в потік, а потім :attr:`terminator`. Якщо "
"присутня інформація про винятки, вона форматується за допомогою :func:"
"`traceback.print_exception` і додається до потоку."

#: ../../library/logging.handlers.rst:58
msgid ""
"Flushes the stream by calling its :meth:`flush` method. Note that the :meth:"
"`close` method is inherited from :class:`~logging.Handler` and so does no "
"output, so an explicit :meth:`flush` call may be needed at times."
msgstr ""
"Очищає потік, викликаючи його метод :meth:`flush`. Зауважте, що метод :meth:"
"`close` успадковано від :class:`~logging.Handler` і тому не виводить, тому "
"іноді може знадобитися явний виклик :meth:`flush`."

#: ../../library/logging.handlers.rst:64
msgid ""
"Sets the instance's stream to the specified value, if it is different. The "
"old stream is flushed before the new stream is set."
msgstr ""
"Встановлює для потоку екземпляра вказане значення, якщо воно відрізняється. "
"Старий потік очищається перед встановленням нового."

#: ../../library/logging.handlers.rst:0
msgid "Parameters"
msgstr "Parâmetros"

#: ../../library/logging.handlers.rst:67
msgid "The stream that the handler should use."
msgstr "Потік, який повинен використовувати обробник."

#: ../../library/logging.handlers.rst:0
msgid "Returns"
msgstr "Retorna"

#: ../../library/logging.handlers.rst:69
msgid "the old stream, if the stream was changed, or *None* if it wasn't."
msgstr "старий потік, якщо потік було змінено, або *None*, якщо це не так."

#: ../../library/logging.handlers.rst:75
msgid ""
"String used as the terminator when writing a formatted record to a stream. "
"Default value is ``'\\n'``."
msgstr ""
"Рядок, який використовується як термінатор під час запису форматованого "
"запису в потік. Значення за замовчуванням - ``'\\n'``."

#: ../../library/logging.handlers.rst:78
msgid ""
"If you don't want a newline termination, you can set the handler instance's "
"``terminator`` attribute to the empty string."
msgstr ""
"Якщо ви не бажаєте закінчення нового рядка, ви можете встановити атрибут "
"``термінатор`` екземпляра обробника як порожній рядок."

#: ../../library/logging.handlers.rst:81
msgid "In earlier versions, the terminator was hardcoded as ``'\\n'``."
msgstr "У попередніх версіях термінатор був жорстко закодований як ``'\\n'``."

#: ../../library/logging.handlers.rst:89
msgid "FileHandler"
msgstr "FileHandler"

#: ../../library/logging.handlers.rst:91
msgid ""
"The :class:`FileHandler` class, located in the core :mod:`logging` package, "
"sends logging output to a disk file.  It inherits the output functionality "
"from :class:`StreamHandler`."
msgstr ""
"Клас :class:`FileHandler`, розташований у базовому пакеті :mod:`logging`, "
"надсилає вихідні дані журналу у файл диска. Він успадковує функцію виведення "
"від :class:`StreamHandler`."

#: ../../library/logging.handlers.rst:98
msgid ""
"Returns a new instance of the :class:`FileHandler` class. The specified file "
"is opened and used as the stream for logging. If *mode* is not specified, :"
"const:`'a'` is used.  If *encoding* is not ``None``, it is used to open the "
"file with that encoding.  If *delay* is true, then file opening is deferred "
"until the first call to :meth:`emit`. By default, the file grows "
"indefinitely. If *errors* is specified, it's used to determine how encoding "
"errors are handled."
msgstr ""

#: ../../library/logging.handlers.rst:105
#: ../../library/logging.handlers.rst:187
#: ../../library/logging.handlers.rst:335
#: ../../library/logging.handlers.rst:441
msgid ""
"As well as string values, :class:`~pathlib.Path` objects are also accepted "
"for the *filename* argument."
msgstr ""
"Окрім рядкових значень, об’єкти :class:`~pathlib.Path` також приймаються для "
"аргументу *filename*."

#: ../../library/logging.handlers.rst:109
#: ../../library/logging.handlers.rst:191
#: ../../library/logging.handlers.rst:339
#: ../../library/logging.handlers.rst:445
msgid "The *errors* parameter was added."
msgstr "Додано параметр *errors*."

#: ../../library/logging.handlers.rst:114
msgid "Closes the file."
msgstr "Menutup berkas."

#: ../../library/logging.handlers.rst:118
msgid "Outputs the record to the file."
msgstr "Виводить запис у файл."

#: ../../library/logging.handlers.rst:124
msgid "NullHandler"
msgstr "NullHandler"

#: ../../library/logging.handlers.rst:128
msgid ""
"The :class:`NullHandler` class, located in the core :mod:`logging` package, "
"does not do any formatting or output. It is essentially a 'no-op' handler "
"for use by library developers."
msgstr ""
"Клас :class:`NullHandler`, розташований у базовому пакеті :mod:`logging`, не "
"виконує жодного форматування чи виведення. По суті, це обробник \"no-op\" "
"для використання розробниками бібліотек."

#: ../../library/logging.handlers.rst:134
msgid "Returns a new instance of the :class:`NullHandler` class."
msgstr "Повертає новий екземпляр класу :class:`NullHandler`."

#: ../../library/logging.handlers.rst:138
#: ../../library/logging.handlers.rst:142
msgid "This method does nothing."
msgstr "Metode ini tidak melakukan apa pun."

#: ../../library/logging.handlers.rst:146
msgid ""
"This method returns ``None`` for the lock, since there is no underlying I/O "
"to which access needs to be serialized."
msgstr ""
"Цей метод повертає ``None`` для блокування, оскільки немає основного вводу-"
"виводу, доступ до якого потрібно серіалізувати."

#: ../../library/logging.handlers.rst:150
msgid ""
"See :ref:`library-config` for more information on how to use :class:"
"`NullHandler`."
msgstr ""
"Перегляньте :ref:`library-config`, щоб дізнатися більше про використання :"
"class:`NullHandler`."

#: ../../library/logging.handlers.rst:156
msgid "WatchedFileHandler"
msgstr "WatchedFileHandler"

#: ../../library/logging.handlers.rst:160
msgid ""
"The :class:`WatchedFileHandler` class, located in the :mod:`logging."
"handlers` module, is a :class:`FileHandler` which watches the file it is "
"logging to. If the file changes, it is closed and reopened using the file "
"name."
msgstr ""
"Клас :class:`WatchedFileHandler`, розташований у модулі :mod:`logging."
"handlers`, є :class:`FileHandler`, який стежить за файлом, до якого він "
"реєструється. Якщо файл змінюється, він закривається та знову відкривається "
"з використанням імені файлу."

#: ../../library/logging.handlers.rst:164
msgid ""
"A file change can happen because of usage of programs such as *newsyslog* "
"and *logrotate* which perform log file rotation. This handler, intended for "
"use under Unix/Linux, watches the file to see if it has changed since the "
"last emit. (A file is deemed to have changed if its device or inode have "
"changed.) If the file has changed, the old file stream is closed, and the "
"file opened to get a new stream."
msgstr ""
"Зміна файлу може статися через використання таких програм, як *newsyslog* і "
"*logrotate*, які виконують ротацію файлів журналу. Цей обробник, призначений "
"для використання в Unix/Linux, спостерігає за файлом, щоб побачити, чи він "
"змінився з часу останнього випуску. (Файл вважається зміненим, якщо його "
"пристрій або inode змінилися.) Якщо файл змінився, старий файловий потік "
"закривається, а файл відкривається, щоб отримати новий потік."

#: ../../library/logging.handlers.rst:171
msgid ""
"This handler is not appropriate for use under Windows, because under Windows "
"open log files cannot be moved or renamed - logging opens the files with "
"exclusive locks - and so there is no need for such a handler. Furthermore, "
"*ST_INO* is not supported under Windows; :func:`~os.stat` always returns "
"zero for this value."
msgstr ""
"Цей обробник не підходить для використання під Windows, оскільки під Windows "
"відкриті файли журналу не можна переміщувати або перейменовувати - "
"журналювання відкриває файли з ексклюзивними блокуваннями - і тому немає "
"потреби в такому обробнику. Крім того, *ST_INO* не підтримується в Windows; :"
"func:`~os.stat` завжди повертає нуль для цього значення."

#: ../../library/logging.handlers.rst:180
msgid ""
"Returns a new instance of the :class:`WatchedFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, :const:`'a'` is used.  If *encoding* is not ``None``, it is "
"used to open the file with that encoding.  If *delay* is true, then file "
"opening is deferred until the first call to :meth:`emit`.  By default, the "
"file grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""

#: ../../library/logging.handlers.rst:196
msgid ""
"Checks to see if the file has changed.  If it has, the existing stream is "
"flushed and closed and the file opened again, typically as a precursor to "
"outputting the record to the file."
msgstr ""
"Перевіряє, чи не змінився файл. Якщо так, наявний потік очищається та "
"закривається, а файл відкривається знову, як правило, перед виведенням "
"запису у файл."

#: ../../library/logging.handlers.rst:205
msgid ""
"Outputs the record to the file, but first calls :meth:`reopenIfNeeded` to "
"reopen the file if it has changed."
msgstr ""
"Виводить запис у файл, але спочатку викликає :meth:`reopenIfNeeded`, щоб "
"повторно відкрити файл, якщо він змінився."

#: ../../library/logging.handlers.rst:211
msgid "BaseRotatingHandler"
msgstr "BaseRotatingHandler"

#: ../../library/logging.handlers.rst:213
msgid ""
"The :class:`BaseRotatingHandler` class, located in the :mod:`logging."
"handlers` module, is the base class for the rotating file handlers, :class:"
"`RotatingFileHandler` and :class:`TimedRotatingFileHandler`. You should not "
"need to instantiate this class, but it has attributes and methods you may "
"need to override."
msgstr ""
"Клас :class:`BaseRotatingHandler`, розташований у модулі :mod:`logging."
"handlers`, є базовим класом для обертових обробників файлів, :class:"
"`RotatingFileHandler` і :class:`TimedRotatingFileHandler`. Вам не потрібно "
"створювати екземпляр цього класу, але він має атрибути та методи, які вам, "
"можливо, доведеться змінити."

#: ../../library/logging.handlers.rst:221
msgid "The parameters are as for :class:`FileHandler`. The attributes are:"
msgstr "Параметри такі ж, як і для :class:`FileHandler`. Атрибути:"

#: ../../library/logging.handlers.rst:225
msgid ""
"If this attribute is set to a callable, the :meth:`rotation_filename` method "
"delegates to this callable. The parameters passed to the callable are those "
"passed to :meth:`rotation_filename`."
msgstr ""
"Якщо для цього атрибута встановлено значення callable, метод :meth:"
"`rotation_filename` делегує цей виклик. Параметри, що передаються "
"викликаному, є тими, що передаються до :meth:`rotation_filename`."

#: ../../library/logging.handlers.rst:229
msgid ""
"The namer function is called quite a few times during rollover, so it should "
"be as simple and as fast as possible. It should also return the same output "
"every time for a given input, otherwise the rollover behaviour may not work "
"as expected."
msgstr ""
"Функція namer викликається досить багато разів під час переміщення, тому "
"вона має бути максимально простою та швидкою. Він також повинен повертати "
"той самий вихід кожного разу для даного введення, інакше поведінка "
"перекидання може працювати не так, як очікувалося."

#: ../../library/logging.handlers.rst:234
msgid ""
"It's also worth noting that care should be taken when using a namer to "
"preserve certain attributes in the filename which are used during rotation. "
"For example, :class:`RotatingFileHandler` expects to have a set of log files "
"whose names contain successive integers, so that rotation works as expected, "
"and :class:`TimedRotatingFileHandler` deletes old log files (based on the "
"``backupCount`` parameter passed to the handler's initializer) by "
"determining the oldest files to delete. For this to happen, the filenames "
"should be sortable using the date/time portion of the filename, and a namer "
"needs to respect this. (If a namer is wanted that doesn't respect this "
"scheme, it will need to be used in a subclass of :class:"
"`TimedRotatingFileHandler` which overrides the :meth:"
"`~TimedRotatingFileHandler.getFilesToDelete` method to fit in with the "
"custom naming scheme.)"
msgstr ""
"Варто також зазначити, що під час використання іменника слід бути обережним, "
"щоб зберегти певні атрибути в імені файлу, які використовуються під час "
"ротації. Наприклад, :class:`RotatingFileHandler` очікує мати набір файлів "
"журналу, імена яких містять послідовні цілі числа, щоб ротація працювала "
"належним чином, а :class:`TimedRotatingFileHandler` видаляє старі файли "
"журналу (на основі ``backupCount`` параметр, переданий ініціалізатору "
"обробника), визначаючи найстаріші файли для видалення. Щоб це сталося, назви "
"файлів мають бути сортованими за датою/часом у назві файлу, і іменувальник "
"має поважати це. (Якщо потрібен іменник, який не відповідає цій схемі, його "
"потрібно буде використовувати в підкласі :class:`TimedRotatingFileHandler`, "
"який замінює метод :meth:`~TimedRotatingFileHandler.getFilesToDelete`, щоб "
"відповідати спеціальному іменуванню схема.)"

#: ../../library/logging.handlers.rst:252
msgid ""
"If this attribute is set to a callable, the :meth:`rotate` method delegates "
"to this callable.  The parameters passed to the callable are those passed "
"to :meth:`rotate`."
msgstr ""
"Якщо цей атрибут встановлено на callable, метод :meth:`rotate` делегує цей "
"callable. Параметри, що передаються викликаному, є тими, що передаються в :"
"meth:`rotate`."

#: ../../library/logging.handlers.rst:260
msgid "Modify the filename of a log file when rotating."
msgstr "Змінити назву файлу журналу під час ротації."

#: ../../library/logging.handlers.rst:262
msgid "This is provided so that a custom filename can be provided."
msgstr "Це надається для того, щоб можна було надати власне ім’я файлу."

#: ../../library/logging.handlers.rst:264
msgid ""
"The default implementation calls the 'namer' attribute of the handler, if "
"it's callable, passing the default name to it. If the attribute isn't "
"callable (the default is ``None``), the name is returned unchanged."
msgstr ""
"Реалізація за замовчуванням викликає атрибут 'namer' обробника, якщо його "
"можна викликати, передаючи йому ім'я за замовчуванням. Якщо атрибут не можна "
"викликати (за замовчуванням ``None``), ім'я повертається без змін."

#: ../../library/logging.handlers.rst:268
msgid "The default name for the log file."
msgstr "Назва за замовчуванням для файлу журналу."

#: ../../library/logging.handlers.rst:275
msgid "When rotating, rotate the current log."
msgstr "Під час обертання обертати поточний журнал."

#: ../../library/logging.handlers.rst:277
msgid ""
"The default implementation calls the 'rotator' attribute of the handler, if "
"it's callable, passing the source and dest arguments to it. If the attribute "
"isn't callable (the default is ``None``), the source is simply renamed to "
"the destination."
msgstr ""
"Реалізація за замовчуванням викликає атрибут 'rotator' обробника, якщо його "
"можна викликати, передаючи йому аргументи джерела та призначення. Якщо "
"атрибут не можна викликати (за замовчуванням ``None``), джерело просто "
"перейменовується на призначення."

#: ../../library/logging.handlers.rst:282
msgid ""
"The source filename. This is normally the base filename, e.g. 'test.log'."
msgstr ""
"Ім'я вихідного файлу. Зазвичай це базова назва файлу, напр. 'test.log'."

#: ../../library/logging.handlers.rst:284
msgid ""
"The destination filename. This is normally what the source is rotated to, e."
"g. 'test.log.1'."
msgstr ""
"Ім'я цільового файлу. Зазвичай це те, до чого обертається джерело, напр. "
"'test.log.1'."

#: ../../library/logging.handlers.rst:289
msgid ""
"The reason the attributes exist is to save you having to subclass - you can "
"use the same callables for instances of :class:`RotatingFileHandler` and :"
"class:`TimedRotatingFileHandler`. If either the namer or rotator callable "
"raises an exception, this will be handled in the same way as any other "
"exception during an :meth:`emit` call, i.e. via the :meth:`handleError` "
"method of the handler."
msgstr ""
"Причина, чому ці атрибути існують, полягає в тому, щоб позбавити вас "
"необхідності створювати підкласи – ви можете використовувати ті самі виклики "
"для екземплярів :class:`RotatingFileHandler` і :class:"
"`TimedRotatingFileHandler`. Якщо виклик іменника або ротатора викликає "
"виняток, це буде оброблено так само, як і будь-який інший виняток під час "
"виклику :meth:`emit`, тобто через метод :meth:`handleError` обробника."

#: ../../library/logging.handlers.rst:296
msgid ""
"If you need to make more significant changes to rotation processing, you can "
"override the methods."
msgstr ""
"Якщо вам потрібно внести більш значні зміни в обробку обертання, ви можете "
"змінити методи."

#: ../../library/logging.handlers.rst:299
msgid "For an example, see :ref:`cookbook-rotator-namer`."
msgstr "Для прикладу перегляньте :ref:`cookbook-rotator-namer`."

#: ../../library/logging.handlers.rst:305
msgid "RotatingFileHandler"
msgstr "RotatingFileHandler"

#: ../../library/logging.handlers.rst:307
msgid ""
"The :class:`RotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files."
msgstr ""
"Клас :class:`RotatingFileHandler`, розташований у модулі :mod:`logging."
"handlers`, підтримує ротацію файлів журналу диска."

#: ../../library/logging.handlers.rst:313
msgid ""
"Returns a new instance of the :class:`RotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is used "
"to open the file with that encoding.  If *delay* is true, then file opening "
"is deferred until the first call to :meth:`emit`.  By default, the file "
"grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"Повертає новий екземпляр класу :class:`RotatingFileHandler`. Зазначений файл "
"відкривається та використовується як потік для реєстрації. Якщо *mode* не "
"вказано, використовується ``'a'``. Якщо *кодування* не ``None``, воно "
"використовується для відкриття файлу з таким кодуванням. Якщо *delay* має "
"значення true, то відкриття файлу відкладено до першого виклику :meth:"
"`emit`. За замовчуванням файл збільшується необмежено довго. Якщо вказано "
"*errors*, це визначає спосіб обробки помилок кодування."

#: ../../library/logging.handlers.rst:320
msgid ""
"You can use the *maxBytes* and *backupCount* values to allow the file to :"
"dfn:`rollover` at a predetermined size. When the size is about to be "
"exceeded, the file is closed and a new file is silently opened for output. "
"Rollover occurs whenever the current log file is nearly *maxBytes* in "
"length; but if either of *maxBytes* or *backupCount* is zero, rollover never "
"occurs, so you generally want to set *backupCount* to at least 1, and have a "
"non-zero *maxBytes*. When *backupCount* is non-zero, the system will save "
"old log files by appending the extensions '.1', '.2' etc., to the filename. "
"For example, with a *backupCount* of 5 and a base file name of :file:`app."
"log`, you would get :file:`app.log`, :file:`app.log.1`, :file:`app.log.2`, "
"up to :file:`app.log.5`. The file being written to is always :file:`app."
"log`.  When this file is filled, it is closed and renamed to :file:`app."
"log.1`, and if files :file:`app.log.1`, :file:`app.log.2`, etc. exist, then "
"they are renamed to :file:`app.log.2`, :file:`app.log.3` etc. respectively."
msgstr ""
"Ви можете використовувати значення *maxBytes* і *backupCount*, щоб дозволити "
"файлу :dfn:`rollover` попередньо визначеного розміру. Коли розмір майже буде "
"перевищено, файл закривається, а новий файл мовчки відкривається для "
"виведення. Перехід відбувається щоразу, коли довжина поточного файлу журналу "
"становить майже *maxBytes*; але якщо будь-яке з *maxBytes* або *backupCount* "
"дорівнює нулю, перехід ніколи не відбувається, тому зазвичай потрібно "
"встановити *backupCount* принаймні на 1 і мати ненульовий *maxBytes*. Якщо "
"*backupCount* не дорівнює нулю, система збереже старі файли журналу, додавши "
"до назви файлу розширення \".1\", \".2\" тощо. Наприклад, з *backupCount* 5 "
"і базовою назвою файлу :file:`app.log`, ви отримаєте :file:`app.log`, :file:"
"`app.log.1`, :file:`app.log.2`, до :file:`app.log.5`. Файл, у який "
"записується, завжди :file:`app.log`. Коли цей файл заповнюється, він "
"закривається та перейменовується на :file:`app.log.1`, а якщо файли :file:"
"`app.log.1`, :file:`app.log.2` тощо. існують, тоді вони перейменовуються "
"відповідно на :file:`app.log.2`, :file:`app.log.3` тощо."

#: ../../library/logging.handlers.rst:344
#: ../../library/logging.handlers.rst:450
msgid "Does a rollover, as described above."
msgstr "Робить перекидання, як описано вище."

#: ../../library/logging.handlers.rst:349
msgid ""
"Outputs the record to the file, catering for rollover as described "
"previously."
msgstr "Виводить запис у файл, обслуговуючи ролловер, як описано раніше."

#: ../../library/logging.handlers.rst:355
msgid "TimedRotatingFileHandler"
msgstr "TimedRotatingFileHandler"

#: ../../library/logging.handlers.rst:357
msgid ""
"The :class:`TimedRotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files at certain timed "
"intervals."
msgstr ""
"Клас :class:`TimedRotatingFileHandler`, розташований у модулі :mod:`logging."
"handlers`, підтримує ротацію файлів журналу диска через певні часові "
"інтервали."

#: ../../library/logging.handlers.rst:364
msgid ""
"Returns a new instance of the :class:`TimedRotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. On rotating it "
"also sets the filename suffix. Rotating happens based on the product of "
"*when* and *interval*."
msgstr ""
"Повертає новий екземпляр класу :class:`TimedRotatingFileHandler`. Зазначений "
"файл відкривається та використовується як потік для реєстрації. При "
"обертанні він також встановлює суфікс імені файлу. Обертання відбувається на "
"основі добутку *when* та *інтервалу*."

#: ../../library/logging.handlers.rst:369
msgid ""
"You can use the *when* to specify the type of *interval*. The list of "
"possible values is below.  Note that they are not case sensitive."
msgstr ""
"Ви можете використовувати *when*, щоб вказати тип *інтервалу*. Нижче "
"наведено список можливих значень. Зауважте, що вони не чутливі до регістру."

#: ../../library/logging.handlers.rst:373
msgid "Value"
msgstr "Valor"

#: ../../library/logging.handlers.rst:373
msgid "Type of interval"
msgstr "Тип інтервалу"

#: ../../library/logging.handlers.rst:373
msgid "If/how *atTime* is used"
msgstr "Якщо/як використовується *atTime*"

#: ../../library/logging.handlers.rst:375
msgid "``'S'``"
msgstr "``'S'``"

#: ../../library/logging.handlers.rst:375
msgid "Seconds"
msgstr "Detik"

#: ../../library/logging.handlers.rst:375
#: ../../library/logging.handlers.rst:377
#: ../../library/logging.handlers.rst:379
#: ../../library/logging.handlers.rst:381
msgid "Ignored"
msgstr "Ігнорується"

#: ../../library/logging.handlers.rst:377
msgid "``'M'``"
msgstr "``'M'``"

#: ../../library/logging.handlers.rst:377
msgid "Minutes"
msgstr "Menit"

#: ../../library/logging.handlers.rst:379
msgid "``'H'``"
msgstr "``'H'``"

#: ../../library/logging.handlers.rst:379
msgid "Hours"
msgstr "Horas"

#: ../../library/logging.handlers.rst:381
msgid "``'D'``"
msgstr "``'D'``"

#: ../../library/logging.handlers.rst:381
msgid "Days"
msgstr "Dias"

#: ../../library/logging.handlers.rst:383
msgid "``'W0'-'W6'``"
msgstr "``'W0'-'W6'``"

#: ../../library/logging.handlers.rst:383
msgid "Weekday (0=Monday)"
msgstr "День тижня (0=понеділок)"

#: ../../library/logging.handlers.rst:383
#: ../../library/logging.handlers.rst:386
msgid "Used to compute initial rollover time"
msgstr "Використовується для обчислення початкового часу перекидання"

#: ../../library/logging.handlers.rst:386
msgid "``'midnight'``"
msgstr "``'midnight'``"

#: ../../library/logging.handlers.rst:386
msgid "Roll over at midnight, if *atTime* not specified, else at time *atTime*"
msgstr "Перехід опівночі, якщо *atTime* не вказано, інакше в час *atTime*"

#: ../../library/logging.handlers.rst:391
msgid ""
"When using weekday-based rotation, specify 'W0' for Monday, 'W1' for "
"Tuesday, and so on up to 'W6' for Sunday. In this case, the value passed for "
"*interval* isn't used."
msgstr ""
"У разі використання ротації на основі днів тижня вкажіть \"W0\" для "
"понеділка, \"W1\" для вівторка і так далі до \"W6\" для неділі. У цьому "
"випадку значення, передане для *інтервалу*, не використовується."

#: ../../library/logging.handlers.rst:395
msgid ""
"The system will save old log files by appending extensions to the filename. "
"The extensions are date-and-time based, using the strftime format ``%Y-%m-"
"%d_%H-%M-%S`` or a leading portion thereof, depending on the rollover "
"interval."
msgstr ""
"Система збереже старі файли журналу, додавши розширення до імені файлу. "
"Розширення базуються на даті й часі з використанням формату strftime ``%Y-%m-"
"%d_%H-%M-%S`` або його початкової частини, залежно від інтервалу переходу."

#: ../../library/logging.handlers.rst:400
msgid ""
"When computing the next rollover time for the first time (when the handler "
"is created), the last modification time of an existing log file, or else the "
"current time, is used to compute when the next rotation will occur."
msgstr ""
"Під час першого обчислення часу наступного переходу (під час створення "
"обробника) для обчислення часу наступного повороту використовується час "
"останньої зміни наявного файлу журналу або поточний час."

#: ../../library/logging.handlers.rst:404
msgid ""
"If the *utc* argument is true, times in UTC will be used; otherwise local "
"time is used."
msgstr ""
"Якщо аргумент *utc* має значення true, буде використано час у UTC; інакше "
"використовується місцевий час."

#: ../../library/logging.handlers.rst:407
msgid ""
"If *backupCount* is nonzero, at most *backupCount* files will be kept, and "
"if more would be created when rollover occurs, the oldest one is deleted. "
"The deletion logic uses the interval to determine which files to delete, so "
"changing the interval may leave old files lying around."
msgstr ""
"Якщо *backupCount* не дорівнює нулю, буде збережено щонайбільше "
"*backupCount* файлів, а якщо буде створено більше під час перенесення "
"файлів, видаляється найстаріший. Логіка видалення використовує інтервал, щоб "
"визначити, які файли видаляти, тому зміна інтервалу може залишити старі "
"файли без місця."

#: ../../library/logging.handlers.rst:412
msgid ""
"If *delay* is true, then file opening is deferred until the first call to :"
"meth:`emit`."
msgstr ""
"Якщо *delay* має значення true, то відкриття файлу відкладено до першого "
"виклику :meth:`emit`."

#: ../../library/logging.handlers.rst:415
msgid ""
"If *atTime* is not ``None``, it must be a ``datetime.time`` instance which "
"specifies the time of day when rollover occurs, for the cases where rollover "
"is set to happen \"at midnight\" or \"on a particular weekday\". Note that "
"in these cases, the *atTime* value is effectively used to compute the "
"*initial* rollover, and subsequent rollovers would be calculated via the "
"normal interval calculation."
msgstr ""
"Якщо *atTime* не є ``None``, це має бути екземпляр ``datetime.time``, який "
"визначає час доби, коли відбувається перекидання, для випадків, коли "
"перекидання встановлено на \"опівночі\" або \"на певний день тижня\". "
"Зауважте, що в цих випадках значення *atTime* ефективно використовується для "
"обчислення *початкового* ролловера, а наступні ролловери обчислюватимуться "
"за допомогою звичайного обчислення інтервалу."

#: ../../library/logging.handlers.rst:422
msgid ""
"If *errors* is specified, it's used to determine how encoding errors are "
"handled."
msgstr ""
"Якщо вказано *errors*, воно використовується для визначення способу обробки "
"помилок кодування."

#: ../../library/logging.handlers.rst:425
msgid ""
"Calculation of the initial rollover time is done when the handler is "
"initialised. Calculation of subsequent rollover times is done only when "
"rollover occurs, and rollover occurs only when emitting output. If this is "
"not kept in mind, it might lead to some confusion. For example, if an "
"interval of \"every minute\" is set, that does not mean you will always see "
"log files with times (in the filename) separated by a minute; if, during "
"application execution, logging output is generated more frequently than once "
"a minute, *then* you can expect to see log files with times separated by a "
"minute. If, on the other hand, logging messages are only output once every "
"five minutes (say), then there will be gaps in the file times corresponding "
"to the minutes where no output (and hence no rollover) occurred."
msgstr ""
"Розрахунок початкового часу перекидання виконується під час ініціалізації "
"обробника. Розрахунок наступного часу ролловеру виконується лише тоді, коли "
"відбувається ролловер, а ролловер відбувається лише під час випромінювання "
"вихідних даних. Якщо цього не враховувати, це може призвести до певної "
"плутанини. Наприклад, якщо встановлено інтервал \"кожної хвилини\", це не "
"означає, що ви завжди бачитимете файли журналів із часом (у назві файлу), "
"розділеними хвилиною; якщо під час виконання програми вихідні дані журналу "
"генеруються частіше, ніж один раз на хвилину, *тоді* ви можете очікувати, що "
"побачите файли журналу з часом, розділеним хвилиною. З іншого боку, якщо "
"повідомлення журналу виводяться лише один раз кожні п’ять хвилин (скажімо), "
"тоді будуть проміжки у часі файлу, що відповідає хвилинам, коли не було "
"виведено (і, отже, не відбулося перекидання)."

#: ../../library/logging.handlers.rst:438
msgid "*atTime* parameter was added."
msgstr "Додано параметр *atTime*."

#: ../../library/logging.handlers.rst:454
msgid ""
"Outputs the record to the file, catering for rollover as described above."
msgstr "Виводить запис у файл, обслуговуючи ролловер, як описано вище."

#: ../../library/logging.handlers.rst:458
msgid ""
"Returns a list of filenames which should be deleted as part of rollover. "
"These are the absolute paths of the oldest backup log files written by the "
"handler."
msgstr ""
"Повертає список імен файлів, які слід видалити під час переміщення. Це "
"абсолютні шляхи до найстаріших резервних файлів журналу, записаних "
"обробником."

#: ../../library/logging.handlers.rst:464
msgid "SocketHandler"
msgstr "SocketHandler"

#: ../../library/logging.handlers.rst:466
msgid ""
"The :class:`SocketHandler` class, located in the :mod:`logging.handlers` "
"module, sends logging output to a network socket. The base class uses a TCP "
"socket."
msgstr ""
"Клас :class:`SocketHandler`, розташований у модулі :mod:`logging.handlers`, "
"надсилає вихідні дані журналу в мережевий сокет. Базовий клас використовує "
"сокет TCP."

#: ../../library/logging.handlers.rst:472
msgid ""
"Returns a new instance of the :class:`SocketHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""
"Повертає новий екземпляр класу :class:`SocketHandler`, призначений для "
"зв’язку з віддаленою машиною, адресу якої вказують *host* і *port*."

#: ../../library/logging.handlers.rst:475
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a TCP socket is created."
msgstr ""
"Якщо ``port`` вказано як ``None``, сокет домену Unix створюється за "
"допомогою значення в ``host`` - інакше створюється сокет TCP."

#: ../../library/logging.handlers.rst:481
msgid "Closes the socket."
msgstr "Закриває розетку."

#: ../../library/logging.handlers.rst:486
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. If the connection was previously lost, re-establishes the "
"connection. To unpickle the record at the receiving end into a :class:"
"`~logging.LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""
"Вибирає словник атрибутів запису та записує його в сокет у двійковому "
"форматі. Якщо є помилка з сокетом, мовчки скидає пакет. Якщо з’єднання було "
"втрачено, відновлює з’єднання. Щоб видалити запис на приймальному кінці в :"
"class:`~logging.LogRecord`, скористайтеся :func:`~logging.makeLogRecord` "
"функцією."

#: ../../library/logging.handlers.rst:496
msgid ""
"Handles an error which has occurred during :meth:`emit`. The most likely "
"cause is a lost connection. Closes the socket so that we can retry on the "
"next event."
msgstr ""
"Обробляє помилку, яка сталася під час :meth:`emit`. Найімовірніша причина – "
"втрата зв’язку. Закриває сокет, щоб ми могли повторити наступну подію."

#: ../../library/logging.handlers.rst:503
msgid ""
"This is a factory method which allows subclasses to define the precise type "
"of socket they want. The default implementation creates a TCP socket (:const:"
"`socket.SOCK_STREAM`)."
msgstr ""
"Це фабричний метод, який дозволяє підкласам визначати точний тип сокета, "
"який вони хочуть. Стандартна реалізація створює сокет TCP (:const:`socket."
"SOCK_STREAM`)."

#: ../../library/logging.handlers.rst:510
msgid ""
"Pickles the record's attribute dictionary in binary format with a length "
"prefix, and returns it ready for transmission across the socket. The details "
"of this operation are equivalent to::"
msgstr ""
"Вибирає словник атрибутів запису в двійковому форматі з префіксом довжини та "
"повертає його готовим для передачі через сокет. Подробиці цієї операції "
"еквівалентні:"

#: ../../library/logging.handlers.rst:518
msgid ""
"Note that pickles aren't completely secure. If you are concerned about "
"security, you may want to override this method to implement a more secure "
"mechanism. For example, you can sign pickles using HMAC and then verify them "
"on the receiving end, or alternatively you can disable unpickling of global "
"objects on the receiving end."
msgstr ""
"Зауважте, що мариновані огірки не є повністю безпечними. Якщо вас турбує "
"безпека, ви можете замінити цей метод, щоб застосувати більш безпечний "
"механізм. Наприклад, ви можете підписати соління за допомогою HMAC, а потім "
"перевірити їх на приймальній стороні, або, як альтернатива, ви можете "
"вимкнути розбирання глобальних об’єктів на приймальній стороні."

#: ../../library/logging.handlers.rst:527
msgid ""
"Send a pickled byte-string *packet* to the socket. The format of the sent "
"byte-string is as described in the documentation for :meth:`~SocketHandler."
"makePickle`."
msgstr ""
"Надішліть маринований байтовий рядок *пакет* до сокета. Формат надісланого "
"байтового рядка відповідає документації для :meth:`~SocketHandler."
"makePickle`."

#: ../../library/logging.handlers.rst:531
msgid ""
"This function allows for partial sends, which can happen when the network is "
"busy."
msgstr ""
"Ця функція дозволяє частково надсилати, що може статися, коли мережа зайнята."

#: ../../library/logging.handlers.rst:537
msgid ""
"Tries to create a socket; on failure, uses an exponential back-off "
"algorithm.  On initial failure, the handler will drop the message it was "
"trying to send.  When subsequent messages are handled by the same instance, "
"it will not try connecting until some time has passed.  The default "
"parameters are such that the initial delay is one second, and if after that "
"delay the connection still can't be made, the handler will double the delay "
"each time up to a maximum of 30 seconds."
msgstr ""
"Намагається створити сокет; у разі відмови використовує експоненціальний "
"алгоритм відстрочки. У разі початкової помилки обробник скине повідомлення, "
"яке намагався надіслати. Коли наступні повідомлення обробляються тим самим "
"екземпляром, він не намагатиметься підключитися, доки не мине деякий час. "
"Параметри за замовчуванням такі, що початкова затримка становить одну "
"секунду, і якщо після цієї затримки з’єднання все одно не вдається "
"встановити, обробник кожного разу подвоює затримку до максимум 30 секунд."

#: ../../library/logging.handlers.rst:545
msgid "This behaviour is controlled by the following handler attributes:"
msgstr "Ця поведінка контролюється такими атрибутами обробника:"

#: ../../library/logging.handlers.rst:547
msgid "``retryStart`` (initial delay, defaulting to 1.0 seconds)."
msgstr "``retryStart`` (початкова затримка, за замовчуванням 1,0 секунди)."

#: ../../library/logging.handlers.rst:548
msgid "``retryFactor`` (multiplier, defaulting to 2.0)."
msgstr "``retryFactor`` (множник, за умовчанням 2,0)."

#: ../../library/logging.handlers.rst:549
msgid "``retryMax`` (maximum delay, defaulting to 30.0 seconds)."
msgstr "``retryMax`` (максимальна затримка, за замовчуванням 30,0 секунд)."

#: ../../library/logging.handlers.rst:551
msgid ""
"This means that if the remote listener starts up *after* the handler has "
"been used, you could lose messages (since the handler won't even attempt a "
"connection until the delay has elapsed, but just silently drop messages "
"during the delay period)."
msgstr ""
"Це означає, що якщо віддалений слухач запускається *після* використання "
"обробника, ви можете втратити повідомлення (оскільки обробник навіть не "
"намагатиметься встановити з’єднання, доки не мине затримка, а лише мовчки "
"видалятиме повідомлення протягом періоду затримки)."

#: ../../library/logging.handlers.rst:560
msgid "DatagramHandler"
msgstr "DatagramHandler"

#: ../../library/logging.handlers.rst:562
msgid ""
"The :class:`DatagramHandler` class, located in the :mod:`logging.handlers` "
"module, inherits from :class:`SocketHandler` to support sending logging "
"messages over UDP sockets."
msgstr ""
"Клас :class:`DatagramHandler`, розташований у модулі :mod:`logging."
"handlers`, успадковує :class:`SocketHandler` для підтримки надсилання "
"повідомлень журналу через сокети UDP."

#: ../../library/logging.handlers.rst:569
msgid ""
"Returns a new instance of the :class:`DatagramHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""
"Повертає новий екземпляр класу :class:`DatagramHandler`, призначений для "
"зв’язку з віддаленою машиною, адресу якої вказують *host* і *port*."

#: ../../library/logging.handlers.rst:572
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a UDP socket is created."
msgstr ""
"Якщо ``port`` вказано як ``None``, сокет домену Unix створюється за "
"допомогою значення в ``host``; інакше створюється сокет UDP."

#: ../../library/logging.handlers.rst:578
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. To unpickle the record at the receiving end into a :class:`~logging."
"LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""
"Вибирає словник атрибутів запису та записує його в сокет у двійковому "
"форматі. Якщо є помилка з сокетом, мовчки скидає пакет. Щоб видалити запис "
"на приймальному кінці в :class:`~logging.LogRecord`, скористайтеся :func:"
"`~logging.makeLogRecord` функцією."

#: ../../library/logging.handlers.rst:587
msgid ""
"The factory method of :class:`SocketHandler` is here overridden to create a "
"UDP socket (:const:`socket.SOCK_DGRAM`)."
msgstr ""
"Фабричний метод :class:`SocketHandler` тут перевизначено для створення "
"сокета UDP (:const:`socket.SOCK_DGRAM`)."

#: ../../library/logging.handlers.rst:593
msgid ""
"Send a pickled byte-string to a socket. The format of the sent byte-string "
"is as described in the documentation for :meth:`SocketHandler.makePickle`."
msgstr ""
"Надіслати маринований рядок байтів до сокета. Формат надісланого байтового "
"рядка відповідає документації для :meth:`SocketHandler.makePickle`."

#: ../../library/logging.handlers.rst:600
msgid "SysLogHandler"
msgstr "SysLogHandler"

#: ../../library/logging.handlers.rst:602
msgid ""
"The :class:`SysLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a remote or local Unix syslog."
msgstr ""
"Клас :class:`SysLogHandler`, розташований у модулі :mod:`logging.handlers`, "
"підтримує надсилання повідомлень журналу до віддаленого чи локального "
"системного журналу Unix."

#: ../../library/logging.handlers.rst:608
msgid ""
"Returns a new instance of the :class:`SysLogHandler` class intended to "
"communicate with a remote Unix machine whose address is given by *address* "
"in the form of a ``(host, port)`` tuple.  If *address* is not specified, "
"``('localhost', 514)`` is used.  The address is used to open a socket.  An "
"alternative to providing a ``(host, port)`` tuple is providing an address as "
"a string, for example '/dev/log'. In this case, a Unix domain socket is used "
"to send the message to the syslog. If *facility* is not specified, :const:"
"`LOG_USER` is used. The type of socket opened depends on the *socktype* "
"argument, which defaults to :const:`socket.SOCK_DGRAM` and thus opens a UDP "
"socket. To open a TCP socket (for use with the newer syslog daemons such as "
"rsyslog), specify a value of :const:`socket.SOCK_STREAM`."
msgstr ""
"Повертає новий екземпляр класу :class:`SysLogHandler`, призначений для "
"зв’язку з віддаленою машиною Unix, адреса якої задана *адресою* у формі "
"кортежу ``(хост, порт)``. Якщо *адреса* не вказана, використовується "
"``('localhost', 514)``. Адреса використовується для відкриття сокета. "
"Альтернативою наданню кортежу ``(хост, порт)`` є надання адреси у вигляді "
"рядка, наприклад '/dev/log'. У цьому випадку для надсилання повідомлення до "
"системного журналу використовується сокет домену Unix. Якщо *facility* не "
"вказано, :const:`LOG_USER` використовується. Тип відкритого сокета залежить "
"від аргументу *socktype*, який за замовчуванням має значення :const:`socket."
"SOCK_DGRAM` і таким чином відкриває сокет UDP. Щоб відкрити сокет TCP (для "
"використання з новими демонами syslog, наприклад rsyslog), вкажіть значення :"
"const:`socket.SOCK_STREAM`."

#: ../../library/logging.handlers.rst:620
msgid ""
"Note that if your server is not listening on UDP port 514, :class:"
"`SysLogHandler` may appear not to work. In that case, check what address you "
"should be using for a domain socket - it's system dependent. For example, on "
"Linux it's usually '/dev/log' but on OS/X it's '/var/run/syslog'. You'll "
"need to check your platform and use the appropriate address (you may need to "
"do this check at runtime if your application needs to run on several "
"platforms). On Windows, you pretty much have to use the UDP option."
msgstr ""
"Зауважте, що якщо ваш сервер не прослуховує UDP-порт 514, :class:"
"`SysLogHandler` може здатися непрацюючим. У такому випадку перевірте, яку "
"адресу ви повинні використовувати для доменного сокета - це залежить від "
"системи. Наприклад, у Linux це зазвичай '/dev/log', а в OS/X це '/var/run/"
"syslog'. Вам потрібно буде перевірити свою платформу та використати "
"відповідну адресу (може знадобитися виконати цю перевірку під час виконання, "
"якщо ваша програма має працювати на кількох платформах). У Windows ви майже "
"повинні використовувати параметр UDP."

#: ../../library/logging.handlers.rst:629
msgid "*socktype* was added."
msgstr "Додано *socktype*."

#: ../../library/logging.handlers.rst:635
msgid "Closes the socket to the remote host."
msgstr "Закриває сокет для віддаленого хоста."

#: ../../library/logging.handlers.rst:640
msgid ""
"The record is formatted, and then sent to the syslog server. If exception "
"information is present, it is *not* sent to the server."
msgstr ""
"Запис форматується, а потім надсилається на сервер syslog. Якщо присутня "
"інформація про винятки, вона *не* надсилається на сервер."

#: ../../library/logging.handlers.rst:643
msgid ""
"(See: :issue:`12168`.) In earlier versions, the message sent to the syslog "
"daemons was always terminated with a NUL byte, because early versions of "
"these daemons expected a NUL terminated message - even though it's not in "
"the relevant specification (:rfc:`5424`). More recent versions of these "
"daemons don't expect the NUL byte but strip it off if it's there, and even "
"more recent daemons (which adhere more closely to RFC 5424) pass the NUL "
"byte on as part of the message."
msgstr ""
"(Див.: :issue:`12168`.) У попередніх версіях повідомлення, надіслане до "
"демонов системного журналу, завжди завершувалося нульовим байтом, оскільки "
"ранні версії цих демонів очікували повідомлення, що завершується нульовим "
"значенням, навіть якщо цього немає у відповідній специфікації (:rfc:`5424`). "
"Новіші версії цих демонов не очікують байт NUL, але видаляють його, якщо він "
"там є, і навіть новіші демони (які більше дотримуються RFC 5424) передають "
"байт NUL як частину повідомлення."

#: ../../library/logging.handlers.rst:652
msgid ""
"To enable easier handling of syslog messages in the face of all these "
"differing daemon behaviours, the appending of the NUL byte has been made "
"configurable, through the use of a class-level attribute, ``append_nul``. "
"This defaults to ``True`` (preserving the existing behaviour) but can be set "
"to ``False`` on a ``SysLogHandler`` instance in order for that instance to "
"*not* append the NUL terminator."
msgstr ""
"Щоб полегшити обробку повідомлень системного журналу, незважаючи на всі ці "
"відмінності в поведінці демона, додавання байта NUL було зроблено "
"конфігурованим за допомогою атрибута рівня класу, ``append_nul``. За "
"умовчанням це значення ``True`` (зберігаючи існуючу поведінку), але можна "
"встановити ``False`` для екземпляра ``SysLogHandler``, щоб цей екземпляр "
"*не* додавав термінатор NUL."

#: ../../library/logging.handlers.rst:659
msgid ""
"(See: :issue:`12419`.) In earlier versions, there was no facility for an "
"\"ident\" or \"tag\" prefix to identify the source of the message. This can "
"now be specified using a class-level attribute, defaulting to ``\"\"`` to "
"preserve existing behaviour, but which can be overridden on a "
"``SysLogHandler`` instance in order for that instance to prepend the ident "
"to every message handled. Note that the provided ident must be text, not "
"bytes, and is prepended to the message exactly as is."
msgstr ""
"(Див.: :issue:`12419`.) У попередніх версіях не було можливості для префікса "
"\"ident\" або \"tag\" для визначення джерела повідомлення. Тепер це можна "
"вказати за допомогою атрибута рівня класу, який за замовчуванням має "
"значення ``\"\"``, щоб зберегти існуючу поведінку, але який можна "
"перевизначити в екземплярі ``SysLogHandler``, щоб цей екземпляр додавав "
"ідентифікатор перед кожним повідомленням обробляється. Зауважте, що наданий "
"ідентифікатор має бути текстом, а не байтами, і додається до повідомлення "
"точно так, як є."

#: ../../library/logging.handlers.rst:670
msgid ""
"Encodes the facility and priority into an integer. You can pass in strings "
"or integers - if strings are passed, internal mapping dictionaries are used "
"to convert them to integers."
msgstr ""
"Кодує засіб і пріоритет у ціле число. Ви можете передавати рядки або цілі "
"числа - якщо рядки передаються, внутрішні словники відображення "
"використовуються для їх перетворення на цілі числа."

#: ../../library/logging.handlers.rst:674
msgid ""
"The symbolic ``LOG_`` values are defined in :class:`SysLogHandler` and "
"mirror the values defined in the ``sys/syslog.h`` header file."
msgstr ""
"Символічні значення ``LOG_`` визначені в :class:`SysLogHandler` і "
"відображають значення, визначені у файлі заголовка ``sys/syslog.h``."

#: ../../library/logging.handlers.rst:677
msgid "**Priorities**"
msgstr "**Пріоритети**"

#: ../../library/logging.handlers.rst:680
#: ../../library/logging.handlers.rst:702
msgid "Name (string)"
msgstr "Nama (string)"

#: ../../library/logging.handlers.rst:680
#: ../../library/logging.handlers.rst:702
msgid "Symbolic value"
msgstr "Символічне значення"

#: ../../library/logging.handlers.rst:682
msgid "``alert``"
msgstr "``alert``"

#: ../../library/logging.handlers.rst:682
msgid "LOG_ALERT"
msgstr "LOG_ALERT"

#: ../../library/logging.handlers.rst:684
msgid "``crit`` or ``critical``"
msgstr "``crit`` or ``critical``"

#: ../../library/logging.handlers.rst:684
msgid "LOG_CRIT"
msgstr "LOG_CRIT"

#: ../../library/logging.handlers.rst:686
msgid "``debug``"
msgstr "``debug``"

#: ../../library/logging.handlers.rst:686
msgid "LOG_DEBUG"
msgstr "LOG_DEBUG"

#: ../../library/logging.handlers.rst:688
msgid "``emerg`` or ``panic``"
msgstr "``emerg`` or ``panic``"

#: ../../library/logging.handlers.rst:688
msgid "LOG_EMERG"
msgstr "LOG_EMERG"

#: ../../library/logging.handlers.rst:690
msgid "``err`` or ``error``"
msgstr "``err`` ou ``error``"

#: ../../library/logging.handlers.rst:690
msgid "LOG_ERR"
msgstr "LOG_ERR"

#: ../../library/logging.handlers.rst:692
msgid "``info``"
msgstr "``info``"

#: ../../library/logging.handlers.rst:692
msgid "LOG_INFO"
msgstr "LOG_INFO"

#: ../../library/logging.handlers.rst:694
msgid "``notice``"
msgstr "``notice``"

#: ../../library/logging.handlers.rst:694
msgid "LOG_NOTICE"
msgstr "LOG_NOTICE"

#: ../../library/logging.handlers.rst:696
msgid "``warn`` or ``warning``"
msgstr "``warn`` or ``warning``"

#: ../../library/logging.handlers.rst:696
msgid "LOG_WARNING"
msgstr "LOG_WARNING"

#: ../../library/logging.handlers.rst:699
msgid "**Facilities**"
msgstr "**Інфраструктура**"

#: ../../library/logging.handlers.rst:704
msgid "``auth``"
msgstr "``auth``"

#: ../../library/logging.handlers.rst:704
msgid "LOG_AUTH"
msgstr "LOG_AUTH"

#: ../../library/logging.handlers.rst:706
msgid "``authpriv``"
msgstr "``authpriv``"

#: ../../library/logging.handlers.rst:706
msgid "LOG_AUTHPRIV"
msgstr "LOG_AUTHPRIV"

#: ../../library/logging.handlers.rst:708
msgid "``cron``"
msgstr "``cron``"

#: ../../library/logging.handlers.rst:708
msgid "LOG_CRON"
msgstr "LOG_CRON"

#: ../../library/logging.handlers.rst:710
msgid "``daemon``"
msgstr "``daemon``"

#: ../../library/logging.handlers.rst:710
msgid "LOG_DAEMON"
msgstr "LOG_DAEMON"

#: ../../library/logging.handlers.rst:712
msgid "``ftp``"
msgstr "``ftp``"

#: ../../library/logging.handlers.rst:712
msgid "LOG_FTP"
msgstr "LOG_FTP"

#: ../../library/logging.handlers.rst:714
msgid "``kern``"
msgstr "``kern``"

#: ../../library/logging.handlers.rst:714
msgid "LOG_KERN"
msgstr "LOG_KERN"

#: ../../library/logging.handlers.rst:716
msgid "``lpr``"
msgstr "``lpr``"

#: ../../library/logging.handlers.rst:716
msgid "LOG_LPR"
msgstr "LOG_LPR"

#: ../../library/logging.handlers.rst:718
msgid "``mail``"
msgstr "``mail``"

#: ../../library/logging.handlers.rst:718
msgid "LOG_MAIL"
msgstr "LOG_MAIL"

#: ../../library/logging.handlers.rst:720
msgid "``news``"
msgstr "``news``"

#: ../../library/logging.handlers.rst:720
msgid "LOG_NEWS"
msgstr "LOG_NEWS"

#: ../../library/logging.handlers.rst:722
msgid "``syslog``"
msgstr "``syslog``"

#: ../../library/logging.handlers.rst:722
msgid "LOG_SYSLOG"
msgstr "LOG_SYSLOG"

#: ../../library/logging.handlers.rst:724
msgid "``user``"
msgstr "``user``"

#: ../../library/logging.handlers.rst:724
msgid "LOG_USER"
msgstr "LOG_USER"

#: ../../library/logging.handlers.rst:726
msgid "``uucp``"
msgstr "``uucp``"

#: ../../library/logging.handlers.rst:726
msgid "LOG_UUCP"
msgstr "LOG_UUCP"

#: ../../library/logging.handlers.rst:728
msgid "``local0``"
msgstr "``local0``"

#: ../../library/logging.handlers.rst:728
msgid "LOG_LOCAL0"
msgstr "LOG_LOCAL0"

#: ../../library/logging.handlers.rst:730
msgid "``local1``"
msgstr "``local1``"

#: ../../library/logging.handlers.rst:730
msgid "LOG_LOCAL1"
msgstr "LOG_LOCAL1"

#: ../../library/logging.handlers.rst:732
msgid "``local2``"
msgstr "``local2``"

#: ../../library/logging.handlers.rst:732
msgid "LOG_LOCAL2"
msgstr "LOG_LOCAL2"

#: ../../library/logging.handlers.rst:734
msgid "``local3``"
msgstr "``local3``"

#: ../../library/logging.handlers.rst:734
msgid "LOG_LOCAL3"
msgstr "LOG_LOCAL3"

#: ../../library/logging.handlers.rst:736
msgid "``local4``"
msgstr "``local4``"

#: ../../library/logging.handlers.rst:736
msgid "LOG_LOCAL4"
msgstr "LOG_LOCAL4"

#: ../../library/logging.handlers.rst:738
msgid "``local5``"
msgstr "``local5``"

#: ../../library/logging.handlers.rst:738
msgid "LOG_LOCAL5"
msgstr "LOG_LOCAL5"

#: ../../library/logging.handlers.rst:740
msgid "``local6``"
msgstr "``local6``"

#: ../../library/logging.handlers.rst:740
msgid "LOG_LOCAL6"
msgstr "LOG_LOCAL6"

#: ../../library/logging.handlers.rst:742
msgid "``local7``"
msgstr "``local7``"

#: ../../library/logging.handlers.rst:742
msgid "LOG_LOCAL7"
msgstr "LOG_LOCAL7"

#: ../../library/logging.handlers.rst:747
msgid ""
"Maps a logging level name to a syslog priority name. You may need to "
"override this if you are using custom levels, or if the default algorithm is "
"not suitable for your needs. The default algorithm maps ``DEBUG``, ``INFO``, "
"``WARNING``, ``ERROR`` and ``CRITICAL`` to the equivalent syslog names, and "
"all other level names to 'warning'."
msgstr ""
"Зіставляє назву рівня журналювання на назву пріоритету системного журналу. "
"Можливо, вам знадобиться перевизначити це, якщо ви використовуєте спеціальні "
"рівні або якщо алгоритм за замовчуванням не підходить для ваших потреб. "
"Алгоритм за замовчуванням відображає ``DEBUG``, ``INFO``, ``WARNING``, "
"``ERROR`` і ``CRITICAL`` на еквівалентні назви системного журналу, а всі "
"інші назви рівнів на \"попередження\"."

#: ../../library/logging.handlers.rst:757
msgid "NTEventLogHandler"
msgstr "NTEventLogHandler"

#: ../../library/logging.handlers.rst:759
msgid ""
"The :class:`NTEventLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a local Windows NT, Windows "
"2000 or Windows XP event log. Before you can use it, you need Mark Hammond's "
"Win32 extensions for Python installed."
msgstr ""
"Клас :class:`NTEventLogHandler`, розташований у модулі :mod:`logging."
"handlers`, підтримує надсилання повідомлень журналу до локального журналу "
"подій Windows NT, Windows 2000 або Windows XP. Перш ніж використовувати "
"його, вам потрібно встановити розширення Win32 Марка Хаммонда для Python."

#: ../../library/logging.handlers.rst:767
msgid ""
"Returns a new instance of the :class:`NTEventLogHandler` class. The "
"*appname* is used to define the application name as it appears in the event "
"log. An appropriate registry entry is created using this name. The *dllname* "
"should give the fully qualified pathname of a .dll or .exe which contains "
"message definitions to hold in the log (if not specified, ``'win32service."
"pyd'`` is used - this is installed with the Win32 extensions and contains "
"some basic placeholder message definitions. Note that use of these "
"placeholders will make your event logs big, as the entire message source is "
"held in the log. If you want slimmer logs, you have to pass in the name of "
"your own .dll or .exe which contains the message definitions you want to use "
"in the event log). The *logtype* is one of ``'Application'``, ``'System'`` "
"or ``'Security'``, and defaults to ``'Application'``."
msgstr ""
"Повертає новий екземпляр класу :class:`NTEventLogHandler`. *Appname* "
"використовується для визначення назви програми, яка відображається в журналі "
"подій. За допомогою цього імені створюється відповідний запис реєстру. "
"*dllname* має давати повне ім’я шляху до .dll або .exe, який містить "
"визначення повідомлень для зберігання в журналі (якщо не вказано, "
"використовується ``'win32service.pyd'`` — він інсталюється з розширеннями "
"Win32 і містить деякі основні визначення повідомлень-заповнювачів. Зауважте, "
"що використання цих заповнювачів збільшить ваші журнали подій, оскільки все "
"джерело повідомлень зберігається в журналі. Якщо ви хочете мати менші "
"журнали, вам потрібно передати ім’я власної .dll або .exe, який містить "
"визначення повідомлень, які ви хочете використовувати в журналі подій). "
"*logtype* є одним із ``'Application'``, ``'System'`` або ``'Security'``, і "
"за замовчуванням ``'Application'``."

#: ../../library/logging.handlers.rst:783
msgid ""
"At this point, you can remove the application name from the registry as a "
"source of event log entries. However, if you do this, you will not be able "
"to see the events as you intended in the Event Log Viewer - it needs to be "
"able to access the registry to get the .dll name. The current version does "
"not do this."
msgstr ""
"На цьому етапі ви можете видалити назву програми з реєстру як джерело "
"записів журналу подій. Однак, якщо ви зробите це, ви не зможете побачити "
"події, як ви планували, у засобі перегляду журналу подій - йому потрібен "
"доступ до реєстру, щоб отримати назву .dll. Поточна версія цього не робить."

#: ../../library/logging.handlers.rst:792
msgid ""
"Determines the message ID, event category and event type, and then logs the "
"message in the NT event log."
msgstr ""
"Визначає ідентифікатор повідомлення, категорію події та тип події, а потім "
"записує повідомлення в журнал подій NT."

#: ../../library/logging.handlers.rst:798
msgid ""
"Returns the event category for the record. Override this if you want to "
"specify your own categories. This version returns 0."
msgstr ""
"Повертає категорію події для запису. Перевизначте це, якщо хочете вказати "
"власні категорії. Ця версія повертає 0."

#: ../../library/logging.handlers.rst:804
msgid ""
"Returns the event type for the record. Override this if you want to specify "
"your own types. This version does a mapping using the handler's typemap "
"attribute, which is set up in :meth:`__init__` to a dictionary which "
"contains mappings for :const:`DEBUG`, :const:`INFO`, :const:`WARNING`, :"
"const:`ERROR` and :const:`CRITICAL`. If you are using your own levels, you "
"will either need to override this method or place a suitable dictionary in "
"the handler's *typemap* attribute."
msgstr ""
"Повертає тип події для запису. Перевизначте це, якщо хочете вказати власні "
"типи. Ця версія виконує зіставлення за допомогою атрибута typemap обробника, "
"який встановлено в :meth:`__init__`, на словник, який містить зіставлення "
"для :const:`DEBUG`, :const:`INFO`, :const:`WARNING`, :const:`ERROR` і :const:"
"`CRITICAL`. Якщо ви використовуєте власні рівні, вам потрібно буде "
"перевизначити цей метод або розмістити відповідний словник в атрибуті "
"*typemap* обробника."

#: ../../library/logging.handlers.rst:815
msgid ""
"Returns the message ID for the record. If you are using your own messages, "
"you could do this by having the *msg* passed to the logger being an ID "
"rather than a format string. Then, in here, you could use a dictionary "
"lookup to get the message ID. This version returns 1, which is the base "
"message ID in :file:`win32service.pyd`."
msgstr ""
"Повертає ідентифікатор повідомлення для запису. Якщо ви використовуєте "
"власні повідомлення, ви можете зробити це, передавши *повідомлення* до "
"реєстратора як ідентифікатор, а не рядок формату. Тоді тут ви можете "
"скористатися пошуком у словнику, щоб отримати ідентифікатор повідомлення. Ця "
"версія повертає 1, який є основним ідентифікатором повідомлення в :file:"
"`win32service.pyd`."

#: ../../library/logging.handlers.rst:824
msgid "SMTPHandler"
msgstr "SMTPHandler"

#: ../../library/logging.handlers.rst:826
msgid ""
"The :class:`SMTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to an email address via SMTP."
msgstr ""
"Клас :class:`SMTPHandler`, розташований у модулі :mod:`logging.handlers`, "
"підтримує надсилання повідомлень журналу на адресу електронної пошти через "
"SMTP."

#: ../../library/logging.handlers.rst:832
msgid ""
"Returns a new instance of the :class:`SMTPHandler` class. The instance is "
"initialized with the from and to addresses and subject line of the email. "
"The *toaddrs* should be a list of strings. To specify a non-standard SMTP "
"port, use the (host, port) tuple format for the *mailhost* argument. If you "
"use a string, the standard SMTP port is used. If your SMTP server requires "
"authentication, you can specify a (username, password) tuple for the "
"*credentials* argument."
msgstr ""
"Повертає новий екземпляр класу :class:`SMTPHandler`. Екземпляр "
"ініціалізується адресами відправника та одержувача та рядком теми "
"електронного листа. *toaddrs* має бути списком рядків. Щоб указати "
"нестандартний порт SMTP, використовуйте формат кортежу (хост, порт) для "
"аргументу *mailhost*. Якщо ви використовуєте рядок, використовується "
"стандартний порт SMTP. Якщо ваш сервер SMTP вимагає автентифікації, ви "
"можете вказати кортеж (ім’я користувача, пароль) для аргументу *облікові "
"дані*."

#: ../../library/logging.handlers.rst:839
msgid ""
"To specify the use of a secure protocol (TLS), pass in a tuple to the "
"*secure* argument. This will only be used when authentication credentials "
"are supplied. The tuple should be either an empty tuple, or a single-value "
"tuple with the name of a keyfile, or a 2-value tuple with the names of the "
"keyfile and certificate file. (This tuple is passed to the :meth:`smtplib."
"SMTP.starttls` method.)"
msgstr ""
"Щоб указати використання безпечного протоколу (TLS), передайте кортеж "
"аргументу *secure*. Це використовуватиметься, лише якщо надано облікові дані "
"для автентифікації. Кортеж має бути або порожнім кортежем, або кортежем з "
"одним значенням з іменем файлу ключів, або кортежем із двома значеннями з "
"іменами файлу ключів і файлу сертифіката. (Цей кортеж передається в метод :"
"meth:`smtplib.SMTP.starttls`.)"

#: ../../library/logging.handlers.rst:846
msgid ""
"A timeout can be specified for communication with the SMTP server using the "
"*timeout* argument."
msgstr ""
"Тайм-аут можна вказати для зв’язку з сервером SMTP за допомогою аргументу "
"*timeout*."

#: ../../library/logging.handlers.rst:849
msgid "The *timeout* argument was added."
msgstr ""

#: ../../library/logging.handlers.rst:854
msgid "Formats the record and sends it to the specified addressees."
msgstr "Форматує запис і надсилає його вказаним адресатам."

#: ../../library/logging.handlers.rst:859
msgid ""
"If you want to specify a subject line which is record-dependent, override "
"this method."
msgstr ""
"Якщо ви хочете вказати рядок теми, який залежить від запису, замініть цей "
"метод."

#: ../../library/logging.handlers.rst:865
msgid "MemoryHandler"
msgstr "MemoryHandler"

#: ../../library/logging.handlers.rst:867
msgid ""
"The :class:`MemoryHandler` class, located in the :mod:`logging.handlers` "
"module, supports buffering of logging records in memory, periodically "
"flushing them to a :dfn:`target` handler. Flushing occurs whenever the "
"buffer is full, or when an event of a certain severity or greater is seen."
msgstr ""
"Клас :class:`MemoryHandler`, розташований у модулі :mod:`logging.handlers`, "
"підтримує буферизацію записів журналу в пам’яті, періодично скидаючи їх до "
"обробника :dfn:`target`. Очищення відбувається кожного разу, коли буфер "
"заповнений або коли спостерігається подія певної або більшої серйозності."

#: ../../library/logging.handlers.rst:872
msgid ""
":class:`MemoryHandler` is a subclass of the more general :class:"
"`BufferingHandler`, which is an abstract class. This buffers logging records "
"in memory. Whenever each record is added to the buffer, a check is made by "
"calling :meth:`shouldFlush` to see if the buffer should be flushed.  If it "
"should, then :meth:`flush` is expected to do the flushing."
msgstr ""
":class:`MemoryHandler` є підкласом більш загального :class:"
"`BufferingHandler`, який є абстрактним класом. Це буферизує записи журналу в "
"пам'яті. Кожного разу, коли кожен запис додається до буфера, виконується "
"перевірка шляхом виклику :meth:`shouldFlush`, щоб побачити, чи потрібно "
"скидати буфер. Якщо має бути, то очікується, що :meth:`flush` виконає "
"змивання."

#: ../../library/logging.handlers.rst:881
msgid ""
"Initializes the handler with a buffer of the specified capacity. Here, "
"*capacity* means the number of logging records buffered."
msgstr ""
"Ініціалізує обробник буфером зазначеної ємності. Тут *ємність* означає "
"кількість буферизованих записів журналу."

#: ../../library/logging.handlers.rst:887
msgid ""
"Append the record to the buffer. If :meth:`shouldFlush` returns true, call :"
"meth:`flush` to process the buffer."
msgstr ""
"Додайте запис до буфера. Якщо :meth:`shouldFlush` повертає true, викликайте :"
"meth:`flush` для обробки буфера."

#: ../../library/logging.handlers.rst:893
msgid ""
"You can override this to implement custom flushing behavior. This version "
"just zaps the buffer to empty."
msgstr ""

#: ../../library/logging.handlers.rst:899
msgid ""
"Return ``True`` if the buffer is up to capacity. This method can be "
"overridden to implement custom flushing strategies."
msgstr ""
"Повертає ``True``, якщо буфер вичерпано. Цей метод можна замінити, щоб "
"реалізувати власні стратегії очищення."

#: ../../library/logging.handlers.rst:905
msgid ""
"Returns a new instance of the :class:`MemoryHandler` class. The instance is "
"initialized with a buffer size of *capacity* (number of records buffered). "
"If *flushLevel* is not specified, :const:`ERROR` is used. If no *target* is "
"specified, the target will need to be set using :meth:`setTarget` before "
"this handler does anything useful. If *flushOnClose* is specified as "
"``False``, then the buffer is *not* flushed when the handler is closed. If "
"not specified or specified as ``True``, the previous behaviour of flushing "
"the buffer will occur when the handler is closed."
msgstr ""
"Повертає новий екземпляр класу :class:`MemoryHandler`. Екземпляр "
"ініціалізується з розміром буфера *ємність* (кількість буферизованих "
"записів). Якщо *flushLevel* не вказано, використовується :const:`ERROR`. "
"Якщо *ціль* не вказана, ціль потрібно буде встановити за допомогою :meth:"
"`setTarget`, перш ніж цей обробник зробить щось корисне. Якщо *flushOnClose* "
"вказано як ``False``, тоді буфер *не* очищається, коли обробник закрито. "
"Якщо не вказано або вказано як ``True``, попередня поведінка очищення буфера "
"відбуватиметься, коли обробник буде закрито."

#: ../../library/logging.handlers.rst:914
msgid "The *flushOnClose* parameter was added."
msgstr "Додано параметр *flushOnClose*."

#: ../../library/logging.handlers.rst:920
msgid "Calls :meth:`flush`, sets the target to ``None`` and clears the buffer."
msgstr "Викликає :meth:`flush`, встановлює ціль на ``None`` і очищає буфер."

#: ../../library/logging.handlers.rst:926
msgid ""
"For a :class:`MemoryHandler`, flushing means just sending the buffered "
"records to the target, if there is one. The buffer is also cleared when this "
"happens. Override if you want different behavior."
msgstr ""

#: ../../library/logging.handlers.rst:933
msgid "Sets the target handler for this handler."
msgstr "Встановлює цільовий обробник для цього обробника."

#: ../../library/logging.handlers.rst:938
msgid "Checks for buffer full or a record at the *flushLevel* or higher."
msgstr "Перевіряє заповненість буфера або запис на *flushLevel* або вище."

#: ../../library/logging.handlers.rst:944
msgid "HTTPHandler"
msgstr "HTTPHandler"

#: ../../library/logging.handlers.rst:946
msgid ""
"The :class:`HTTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a Web server, using either "
"``GET`` or ``POST`` semantics."
msgstr ""

#: ../../library/logging.handlers.rst:953
msgid ""
"Returns a new instance of the :class:`HTTPHandler` class. The *host* can be "
"of the form ``host:port``, should you need to use a specific port number.  "
"If no *method* is specified, ``GET`` is used. If *secure* is true, a HTTPS "
"connection will be used. The *context* parameter may be set to a :class:`ssl."
"SSLContext` instance to configure the SSL settings used for the HTTPS "
"connection. If *credentials* is specified, it should be a 2-tuple consisting "
"of userid and password, which will be placed in a HTTP 'Authorization' "
"header using Basic authentication. If you specify credentials, you should "
"also specify secure=True so that your userid and password are not passed in "
"cleartext across the wire."
msgstr ""
"Повертає новий екземпляр класу :class:`HTTPHandler`. *Host* може мати форму "
"``host:port``, якщо вам потрібно використовувати певний номер порту. Якщо "
"*метод* не вказано, використовується ``GET``. Якщо *secure* має значення "
"true, використовуватиметься з’єднання HTTPS. Параметр *context* може бути "
"встановлений на екземпляр :class:`ssl.SSLContext`, щоб налаштувати параметри "
"SSL, які використовуються для з’єднання HTTPS. Якщо вказано *облікові дані*, "
"це має бути 2-кортеж, що складається з ідентифікатора користувача та пароля, "
"який буде розміщено в заголовку HTTP \"Авторизація\" за допомогою базової "
"автентифікації. Якщо ви вказуєте облікові дані, ви також повинні вказати "
"secure=True, щоб ваш ідентифікатор користувача та пароль не передавалися у "
"вигляді відкритого тексту по мережі."

#: ../../library/logging.handlers.rst:964
msgid "The *context* parameter was added."
msgstr "Додано параметр *context*."

#: ../../library/logging.handlers.rst:969
msgid ""
"Provides a dictionary, based on ``record``, which is to be URL-encoded and "
"sent to the web server. The default implementation just returns ``record."
"__dict__``. This method can be overridden if e.g. only a subset of :class:"
"`~logging.LogRecord` is to be sent to the web server, or if more specific "
"customization of what's sent to the server is required."
msgstr ""
"Надає словник на основі ``запису``, який має бути закодований URL-адресою та "
"надісланий на веб-сервер. Стандартна реалізація просто повертає ``record."
"__dict__``. Цей метод можна перевизначити, якщо, наприклад, лише підмножина :"
"class:`~logging.LogRecord` має бути надіслана на веб-сервер, або якщо "
"потрібна більш точна настройка того, що надсилається на сервер."

#: ../../library/logging.handlers.rst:977
msgid ""
"Sends the record to the Web server as a URL-encoded dictionary. The :meth:"
"`mapLogRecord` method is used to convert the record to the dictionary to be "
"sent."
msgstr ""

#: ../../library/logging.handlers.rst:981
msgid ""
"Since preparing a record for sending it to a Web server is not the same as a "
"generic formatting operation, using :meth:`~logging.Handler.setFormatter` to "
"specify a :class:`~logging.Formatter` for a :class:`HTTPHandler` has no "
"effect. Instead of calling :meth:`~logging.Handler.format`, this handler "
"calls :meth:`mapLogRecord` and then :func:`urllib.parse.urlencode` to encode "
"the dictionary in a form suitable for sending to a Web server."
msgstr ""

#: ../../library/logging.handlers.rst:994
msgid "QueueHandler"
msgstr "QueueHandler"

#: ../../library/logging.handlers.rst:998
msgid ""
"The :class:`QueueHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules."
msgstr ""
"Клас :class:`QueueHandler`, розташований у модулі :mod:`logging.handlers`, "
"підтримує надсилання повідомлень журналу до черги, таких як реалізовані в "
"модулях :mod:`queue` або :mod:`multiprocessing` ."

#: ../../library/logging.handlers.rst:1002
msgid ""
"Along with the :class:`QueueListener` class, :class:`QueueHandler` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in Web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""

#: ../../library/logging.handlers.rst:1011
msgid ""
"Returns a new instance of the :class:`QueueHandler` class. The instance is "
"initialized with the queue to send messages to. The *queue* can be any queue-"
"like object; it's used as-is by the :meth:`enqueue` method, which needs to "
"know how to send messages to it. The queue is not *required* to have the "
"task tracking API, which means that you can use :class:`~queue.SimpleQueue` "
"instances for *queue*."
msgstr ""
"Повертає новий екземпляр класу :class:`QueueHandler`. Примірник "
"ініціалізується чергою для надсилання повідомлень. *Чергою* може бути будь-"
"який об’єкт, подібний до черги; він використовується як є методом :meth:"
"`enqueue`, якому потрібно знати, як йому надсилати повідомлення. Для черги "
"не *обов’язково* бути API відстеження завдань, що означає, що ви можете "
"використовувати екземпляри :class:`~queue.SimpleQueue` для *черги*."

#: ../../library/logging.handlers.rst:1021
msgid ""
"Enqueues the result of preparing the LogRecord. Should an exception occur (e."
"g. because a bounded queue has filled up), the :meth:`~logging.Handler."
"handleError` method is called to handle the error. This can result in the "
"record silently being dropped (if :attr:`logging.raiseExceptions` is "
"``False``) or a message printed to ``sys.stderr`` (if :attr:`logging."
"raiseExceptions` is ``True``)."
msgstr ""

#: ../../library/logging.handlers.rst:1030
msgid ""
"Prepares a record for queuing. The object returned by this method is "
"enqueued."
msgstr ""
"Готує запис для постановки в чергу. Об’єкт, повернутий цим методом, "
"ставиться в чергу."

#: ../../library/logging.handlers.rst:1033
msgid ""
"The base implementation formats the record to merge the message, arguments, "
"and exception information, if present.  It also removes unpickleable items "
"from the record in-place."
msgstr ""

#: ../../library/logging.handlers.rst:1037
msgid ""
"You might want to override this method if you want to convert the record to "
"a dict or JSON string, or send a modified copy of the record while leaving "
"the original intact."
msgstr ""
"Ви можете замінити цей метод, якщо хочете перетворити запис на рядок dict "
"або JSON або надіслати змінену копію запису, залишивши оригінал недоторканим."

#: ../../library/logging.handlers.rst:1043
msgid ""
"Enqueues the record on the queue using ``put_nowait()``; you may want to "
"override this if you want to use blocking behaviour, or a timeout, or a "
"customized queue implementation."
msgstr ""
"Ставить запис у чергу за допомогою put_nowait(); ви можете змінити це, якщо "
"ви хочете використовувати поведінку блокування, або тайм-аут, або "
"налаштовану реалізацію черги."

#: ../../library/logging.handlers.rst:1052
msgid "QueueListener"
msgstr "QueueListener"

#: ../../library/logging.handlers.rst:1056
msgid ""
"The :class:`QueueListener` class, located in the :mod:`logging.handlers` "
"module, supports receiving logging messages from a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules. The "
"messages are received from a queue in an internal thread and passed, on the "
"same thread, to one or more handlers for processing. While :class:"
"`QueueListener` is not itself a handler, it is documented here because it "
"works hand-in-hand with :class:`QueueHandler`."
msgstr ""
"Клас :class:`QueueListener`, розташований у модулі :mod:`logging.handlers`, "
"підтримує отримання повідомлень журналу з черги, таких як ті, що реалізовані "
"в модулях :mod:`queue` або :mod:`multiprocessing` . Повідомлення отримуються "
"з черги у внутрішньому потоці та передаються в тому самому потоці одному або "
"кільком обробникам для обробки. Хоча :class:`QueueListener` сам по собі не є "
"обробником, він задокументований тут, оскільки він працює рука об руку з :"
"class:`QueueHandler`."

#: ../../library/logging.handlers.rst:1064
msgid ""
"Along with the :class:`QueueHandler` class, :class:`QueueListener` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in Web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""

#: ../../library/logging.handlers.rst:1073
msgid ""
"Returns a new instance of the :class:`QueueListener` class. The instance is "
"initialized with the queue to send messages to and a list of handlers which "
"will handle entries placed on the queue. The queue can be any queue-like "
"object; it's passed as-is to the :meth:`dequeue` method, which needs to know "
"how to get messages from it. The queue is not *required* to have the task "
"tracking API (though it's used if available), which means that you can use :"
"class:`~queue.SimpleQueue` instances for *queue*."
msgstr ""
"Повертає новий екземпляр класу :class:`QueueListener`. Екземпляр "
"ініціалізується чергою для надсилання повідомлень і списком обробників, які "
"оброблятимуть записи, розміщені в черзі. Чергою може бути будь-який "
"чергоподібний об'єкт; він передається як є до методу :meth:`dequeue`, якому "
"потрібно знати, як отримати від нього повідомлення. Для черги не "
"*обов’язково* бути API відстеження завдань (хоча він використовується, якщо "
"доступний), що означає, що ви можете використовувати екземпляри :class:"
"`~queue.SimpleQueue` для *черги*."

#: ../../library/logging.handlers.rst:1081
msgid ""
"If ``respect_handler_level`` is ``True``, a handler's level is respected "
"(compared with the level for the message) when deciding whether to pass "
"messages to that handler; otherwise, the behaviour is as in previous Python "
"versions - to always pass each message to each handler."
msgstr ""
"Якщо ``respect_handler_level`` має значення ``True``, рівень обробника "
"враховується (порівняно з рівнем для повідомлення), коли вирішується, чи "
"передавати повідомлення цьому обробнику; інакше, поведінка така ж, як і в "
"попередніх версіях Python - завжди передавати кожне повідомлення кожному "
"обробнику."

#: ../../library/logging.handlers.rst:1086
msgid "The ``respect_handler_level`` argument was added."
msgstr "Додано аргумент ``respect_handler_level``."

#: ../../library/logging.handlers.rst:1091
msgid "Dequeues a record and return it, optionally blocking."
msgstr "Вилучає запис із черги та повертає його, за бажанням блокуючи."

#: ../../library/logging.handlers.rst:1093
msgid ""
"The base implementation uses ``get()``. You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""
"У базовій реалізації використовується ``get()``. Ви можете перевизначити цей "
"метод, якщо ви хочете використовувати тайм-аути або працювати з власними "
"реалізаціями черги."

#: ../../library/logging.handlers.rst:1099
msgid "Prepare a record for handling."
msgstr "Підготуйте протокол для обробки."

#: ../../library/logging.handlers.rst:1101
msgid ""
"This implementation just returns the passed-in record. You may want to "
"override this method if you need to do any custom marshalling or "
"manipulation of the record before passing it to the handlers."
msgstr ""
"Ця реалізація лише повертає переданий запис. Ви можете замінити цей метод, "
"якщо вам потрібно виконати будь-яку спеціальну сортування або маніпуляції із "
"записом перед передачею його обробникам."

#: ../../library/logging.handlers.rst:1107
msgid "Handle a record."
msgstr "Обробка запису."

#: ../../library/logging.handlers.rst:1109
msgid ""
"This just loops through the handlers offering them the record to handle. The "
"actual object passed to the handlers is that which is returned from :meth:"
"`prepare`."
msgstr ""
"Це просто проходить через обробники, пропонуючи їм запис для обробки. "
"Фактичний об’єкт, який передається обробникам, — це той, який повертається "
"з :meth:`prepare`."

#: ../../library/logging.handlers.rst:1115
msgid "Starts the listener."
msgstr "Memulai *listener*."

#: ../../library/logging.handlers.rst:1117
msgid ""
"This starts up a background thread to monitor the queue for LogRecords to "
"process."
msgstr ""
"Це запускає фоновий потік для моніторингу черги для обробки LogRecords."

#: ../../library/logging.handlers.rst:1122
msgid "Stops the listener."
msgstr "Menghentikan *listener*."

#: ../../library/logging.handlers.rst:1124
msgid ""
"This asks the thread to terminate, and then waits for it to do so. Note that "
"if you don't call this before your application exits, there may be some "
"records still left on the queue, which won't be processed."
msgstr ""
"Це просить потік завершити, а потім чекає, поки він це зробить. Зауважте, що "
"якщо ви не викличете це перед виходом програми, у черзі можуть залишитися "
"деякі записи, які не будуть оброблені."

#: ../../library/logging.handlers.rst:1130
msgid ""
"Writes a sentinel to the queue to tell the listener to quit. This "
"implementation uses ``put_nowait()``.  You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""
"Записує до черги дозорний, щоб сказати слухачеві вийти. Ця реалізація "
"використовує ``put_nowait()``. Ви можете перевизначити цей метод, якщо "
"хочете використовувати тайм-аути або працювати з власними реалізаціями черги."

#: ../../library/logging.handlers.rst:1141
msgid "Module :mod:`logging`"
msgstr "Módulo :mod:`logging`"

#: ../../library/logging.handlers.rst:1141
msgid "API reference for the logging module."
msgstr "Referência da API para o módulo de logging."

#: ../../library/logging.handlers.rst:1143
msgid "Module :mod:`logging.config`"
msgstr "Módulo :mod:`logging.config`"

#: ../../library/logging.handlers.rst:1144
msgid "Configuration API for the logging module."
msgstr "API de configuração para o módulo logging."

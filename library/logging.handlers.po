# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 16:41+0000\n"
"PO-Revision-Date: 2023-05-24 02:17+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/logging.handlers.rst:2
msgid ":mod:`logging.handlers` --- Logging handlers"
msgstr ":mod:`logging.handlers` --- Tratadores de registro"

#: ../../library/logging.handlers.rst:10
msgid "**Source code:** :source:`Lib/logging/handlers.py`"
msgstr "**Código-fonte:** :source:`Lib/logging/handlers.py`"

#: ../../library/logging.handlers.rst:14
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr ""
"Esta página contém apenas informações de referência. Para tutoriais, por "
"favor consulte"

#: ../../library/logging.handlers.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Tutorial básico <logging-basic-tutorial>`"

#: ../../library/logging.handlers.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Tutorial avançado <logging-advanced-tutorial>`"

#: ../../library/logging.handlers.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`Livro de receitas de logging <logging-cookbook>`"

#: ../../library/logging.handlers.rst:25
msgid ""
"The following useful handlers are provided in the package. Note that three "
"of the handlers (:class:`StreamHandler`, :class:`FileHandler` and :class:"
"`NullHandler`) are actually defined in the :mod:`logging` module itself, but "
"have been documented here along with the other handlers."
msgstr ""
"Os seguintes tratadores úteis são fornecidos neste pacote. Observe que três "
"dos tratadores (:class:`StreamHandler`, :class:`FileHandler` e :class:"
"`NullHandler`) são, na verdade, definidos no próprio módulo :mod:`logging`, "
"mas foram documentados aqui junto com os outros tratadores."

#: ../../library/logging.handlers.rst:33
msgid "StreamHandler"
msgstr "StreamHandler"

#: ../../library/logging.handlers.rst:35
msgid ""
"The :class:`StreamHandler` class, located in the core :mod:`logging` "
"package, sends logging output to streams such as *sys.stdout*, *sys.stderr* "
"or any file-like object (or, more precisely, any object which supports :meth:"
"`write` and :meth:`flush` methods)."
msgstr ""
"Клас :class:`StreamHandler`, розташований у базовому пакеті :mod:`logging`, "
"надсилає вихідні дані журналу до таких потоків, як *sys.stdout*, *sys."
"stderr* або будь-якого файлоподібного об’єкта (або, точніше, , будь-який "
"об’єкт, який підтримує методи :meth:`write` і :meth:`flush`)."

#: ../../library/logging.handlers.rst:43
msgid ""
"Returns a new instance of the :class:`StreamHandler` class. If *stream* is "
"specified, the instance will use it for logging output; otherwise, *sys."
"stderr* will be used."
msgstr ""
"Повертає новий екземпляр класу :class:`StreamHandler`. Якщо вказано *потік*, "
"примірник використовуватиме його для журналювання виводу; інакше буде "
"використано *sys.stderr*."

#: ../../library/logging.handlers.rst:50
msgid ""
"If a formatter is specified, it is used to format the record. The record is "
"then written to the stream followed by :attr:`terminator`. If exception "
"information is present, it is formatted using :func:`traceback."
"print_exception` and appended to the stream."
msgstr ""
"Якщо вказано засіб форматування, він використовується для форматування "
"запису. Потім запис записується в потік, а потім :attr:`terminator`. Якщо "
"присутня інформація про винятки, вона форматується за допомогою :func:"
"`traceback.print_exception` і додається до потоку."

#: ../../library/logging.handlers.rst:58
msgid ""
"Flushes the stream by calling its :meth:`flush` method. Note that the :meth:"
"`close` method is inherited from :class:`~logging.Handler` and so does no "
"output, so an explicit :meth:`flush` call may be needed at times."
msgstr ""
"Очищає потік, викликаючи його метод :meth:`flush`. Зауважте, що метод :meth:"
"`close` успадковано від :class:`~logging.Handler` і тому не виводить, тому "
"іноді може знадобитися явний виклик :meth:`flush`."

#: ../../library/logging.handlers.rst:64
msgid ""
"Sets the instance's stream to the specified value, if it is different. The "
"old stream is flushed before the new stream is set."
msgstr ""
"Встановлює для потоку екземпляра вказане значення, якщо воно відрізняється. "
"Старий потік очищається перед встановленням нового."

#: ../../library/logging.handlers.rst:0
msgid "Parameters"
msgstr "Parâmetros"

#: ../../library/logging.handlers.rst:67
msgid "The stream that the handler should use."
msgstr "Потік, який повинен використовувати обробник."

#: ../../library/logging.handlers.rst:0
msgid "Returns"
msgstr "Retorna"

#: ../../library/logging.handlers.rst:69
msgid "the old stream, if the stream was changed, or *None* if it wasn't."
msgstr ""

#: ../../library/logging.handlers.rst:75
msgid ""
"String used as the terminator when writing a formatted record to a stream. "
"Default value is ``'\\n'``."
msgstr ""
"Рядок, який використовується як термінатор під час запису форматованого "
"запису в потік. Значення за замовчуванням - ``'\\n'``."

#: ../../library/logging.handlers.rst:78
msgid ""
"If you don't want a newline termination, you can set the handler instance's "
"``terminator`` attribute to the empty string."
msgstr ""
"Якщо ви не бажаєте закінчення нового рядка, ви можете встановити атрибут "
"``термінатор`` екземпляра обробника як порожній рядок."

#: ../../library/logging.handlers.rst:81
msgid "In earlier versions, the terminator was hardcoded as ``'\\n'``."
msgstr "У попередніх версіях термінатор був жорстко закодований як ``'\\n'``."

#: ../../library/logging.handlers.rst:89
msgid "FileHandler"
msgstr "FileHandler"

#: ../../library/logging.handlers.rst:91
msgid ""
"The :class:`FileHandler` class, located in the core :mod:`logging` package, "
"sends logging output to a disk file.  It inherits the output functionality "
"from :class:`StreamHandler`."
msgstr ""
"Клас :class:`FileHandler`, розташований у базовому пакеті :mod:`logging`, "
"надсилає вихідні дані журналу у файл диска. Він успадковує функцію виведення "
"від :class:`StreamHandler`."

#: ../../library/logging.handlers.rst:98
msgid ""
"Returns a new instance of the :class:`FileHandler` class. The specified file "
"is opened and used as the stream for logging. If *mode* is not specified, "
"``'a'`` is used.  If *encoding* is not ``None``, it is used to open the file "
"with that encoding.  If *delay* is true, then file opening is deferred until "
"the first call to :meth:`emit`. By default, the file grows indefinitely. If "
"*errors* is specified, it's used to determine how encoding errors are "
"handled."
msgstr ""
"Возвращает новый экземпляр класса :class:`FileHandler`. Указанный файл "
"открывается и используется в качестве потока для протоколирования. Если "
"*mode* не указан, используется ``'a'``. Если *кодировка* не равна «Нет», она "
"используется для открытия файла с этой кодировкой. Если *delay* имеет "
"значение true, то открытие файла откладывается до первого вызова :meth:"
"`emit`. По умолчанию файл растет бесконечно. Если указано *errors*, оно "
"используется для определения способа обработки ошибок кодирования."

#: ../../library/logging.handlers.rst:105
#: ../../library/logging.handlers.rst:190
#: ../../library/logging.handlers.rst:338
#: ../../library/logging.handlers.rst:444
msgid ""
"As well as string values, :class:`~pathlib.Path` objects are also accepted "
"for the *filename* argument."
msgstr ""
"Окрім рядкових значень, об’єкти :class:`~pathlib.Path` також приймаються для "
"аргументу *filename*."

#: ../../library/logging.handlers.rst:109
#: ../../library/logging.handlers.rst:194
#: ../../library/logging.handlers.rst:342
#: ../../library/logging.handlers.rst:448
msgid "The *errors* parameter was added."
msgstr "Додано параметр *errors*."

#: ../../library/logging.handlers.rst:114
msgid "Closes the file."
msgstr "Menutup berkas."

#: ../../library/logging.handlers.rst:118
msgid "Outputs the record to the file."
msgstr "Виводить запис у файл."

#: ../../library/logging.handlers.rst:120
msgid ""
"Note that if the file was closed due to logging shutdown at exit and the "
"file mode is 'w', the record will not be emitted (see :issue:`42378`)."
msgstr ""
"Зауважте, що якщо файл було закрито через завершення журналювання під час "
"виходу та режим файлу \"w\", запис не буде видано (див. :issue:`42378`)."

#: ../../library/logging.handlers.rst:127
msgid "NullHandler"
msgstr "NullHandler"

#: ../../library/logging.handlers.rst:131
msgid ""
"The :class:`NullHandler` class, located in the core :mod:`logging` package, "
"does not do any formatting or output. It is essentially a 'no-op' handler "
"for use by library developers."
msgstr ""
"Клас :class:`NullHandler`, розташований у базовому пакеті :mod:`logging`, не "
"виконує жодного форматування чи виведення. По суті, це обробник \"no-op\" "
"для використання розробниками бібліотек."

#: ../../library/logging.handlers.rst:137
msgid "Returns a new instance of the :class:`NullHandler` class."
msgstr "Повертає новий екземпляр класу :class:`NullHandler`."

#: ../../library/logging.handlers.rst:141
#: ../../library/logging.handlers.rst:145
msgid "This method does nothing."
msgstr "Metode ini tidak melakukan apa pun."

#: ../../library/logging.handlers.rst:149
msgid ""
"This method returns ``None`` for the lock, since there is no underlying I/O "
"to which access needs to be serialized."
msgstr ""
"Цей метод повертає ``None`` для блокування, оскільки немає основного вводу-"
"виводу, доступ до якого потрібно серіалізувати."

#: ../../library/logging.handlers.rst:153
msgid ""
"See :ref:`library-config` for more information on how to use :class:"
"`NullHandler`."
msgstr ""
"Перегляньте :ref:`library-config`, щоб дізнатися більше про використання :"
"class:`NullHandler`."

#: ../../library/logging.handlers.rst:159
msgid "WatchedFileHandler"
msgstr "WatchedFileHandler"

#: ../../library/logging.handlers.rst:163
msgid ""
"The :class:`WatchedFileHandler` class, located in the :mod:`logging."
"handlers` module, is a :class:`FileHandler` which watches the file it is "
"logging to. If the file changes, it is closed and reopened using the file "
"name."
msgstr ""
"Клас :class:`WatchedFileHandler`, розташований у модулі :mod:`logging."
"handlers`, є :class:`FileHandler`, який стежить за файлом, до якого він "
"реєструється. Якщо файл змінюється, він закривається та знову відкривається "
"з використанням імені файлу."

#: ../../library/logging.handlers.rst:167
msgid ""
"A file change can happen because of usage of programs such as *newsyslog* "
"and *logrotate* which perform log file rotation. This handler, intended for "
"use under Unix/Linux, watches the file to see if it has changed since the "
"last emit. (A file is deemed to have changed if its device or inode have "
"changed.) If the file has changed, the old file stream is closed, and the "
"file opened to get a new stream."
msgstr ""
"Зміна файлу може статися через використання таких програм, як *newsyslog* і "
"*logrotate*, які виконують ротацію файлів журналу. Цей обробник, призначений "
"для використання в Unix/Linux, спостерігає за файлом, щоб побачити, чи він "
"змінився з часу останнього випуску. (Файл вважається зміненим, якщо його "
"пристрій або inode змінилися.) Якщо файл змінився, старий файловий потік "
"закривається, а файл відкривається, щоб отримати новий потік."

#: ../../library/logging.handlers.rst:174
msgid ""
"This handler is not appropriate for use under Windows, because under Windows "
"open log files cannot be moved or renamed - logging opens the files with "
"exclusive locks - and so there is no need for such a handler. Furthermore, "
"*ST_INO* is not supported under Windows; :func:`~os.stat` always returns "
"zero for this value."
msgstr ""
"Цей обробник не підходить для використання під Windows, оскільки під Windows "
"відкриті файли журналу не можна переміщувати або перейменовувати - "
"журналювання відкриває файли з ексклюзивними блокуваннями - і тому немає "
"потреби в такому обробнику. Крім того, *ST_INO* не підтримується в Windows; :"
"func:`~os.stat` завжди повертає нуль для цього значення."

#: ../../library/logging.handlers.rst:183
msgid ""
"Returns a new instance of the :class:`WatchedFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is used "
"to open the file with that encoding.  If *delay* is true, then file opening "
"is deferred until the first call to :meth:`emit`.  By default, the file "
"grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"Возвращает новый экземпляр класса :class:`WatchedFileHandler`. Указанный "
"файл открывается и используется в качестве потока для протоколирования. Если "
"*mode* не указан, используется ``'a'``. Если *кодировка* не равна «Нет», она "
"используется для открытия файла с этой кодировкой. Если *delay* имеет "
"значение true, то открытие файла откладывается до первого вызова :meth:"
"`emit`. По умолчанию файл растет бесконечно. Если указано *errors*, оно "
"определяет, как обрабатываются ошибки кодирования."

#: ../../library/logging.handlers.rst:199
msgid ""
"Checks to see if the file has changed.  If it has, the existing stream is "
"flushed and closed and the file opened again, typically as a precursor to "
"outputting the record to the file."
msgstr ""
"Перевіряє, чи не змінився файл. Якщо так, наявний потік очищається та "
"закривається, а файл відкривається знову, як правило, перед виведенням "
"запису у файл."

#: ../../library/logging.handlers.rst:208
msgid ""
"Outputs the record to the file, but first calls :meth:`reopenIfNeeded` to "
"reopen the file if it has changed."
msgstr ""
"Виводить запис у файл, але спочатку викликає :meth:`reopenIfNeeded`, щоб "
"повторно відкрити файл, якщо він змінився."

#: ../../library/logging.handlers.rst:214
msgid "BaseRotatingHandler"
msgstr "BaseRotatingHandler"

#: ../../library/logging.handlers.rst:216
msgid ""
"The :class:`BaseRotatingHandler` class, located in the :mod:`logging."
"handlers` module, is the base class for the rotating file handlers, :class:"
"`RotatingFileHandler` and :class:`TimedRotatingFileHandler`. You should not "
"need to instantiate this class, but it has attributes and methods you may "
"need to override."
msgstr ""
"Клас :class:`BaseRotatingHandler`, розташований у модулі :mod:`logging."
"handlers`, є базовим класом для обертових обробників файлів, :class:"
"`RotatingFileHandler` і :class:`TimedRotatingFileHandler`. Вам не потрібно "
"створювати екземпляр цього класу, але він має атрибути та методи, які вам, "
"можливо, доведеться змінити."

#: ../../library/logging.handlers.rst:224
msgid "The parameters are as for :class:`FileHandler`. The attributes are:"
msgstr "Параметри такі ж, як і для :class:`FileHandler`. Атрибути:"

#: ../../library/logging.handlers.rst:228
msgid ""
"If this attribute is set to a callable, the :meth:`rotation_filename` method "
"delegates to this callable. The parameters passed to the callable are those "
"passed to :meth:`rotation_filename`."
msgstr ""
"Якщо для цього атрибута встановлено значення callable, метод :meth:"
"`rotation_filename` делегує цей виклик. Параметри, що передаються "
"викликаному, є тими, що передаються до :meth:`rotation_filename`."

#: ../../library/logging.handlers.rst:232
msgid ""
"The namer function is called quite a few times during rollover, so it should "
"be as simple and as fast as possible. It should also return the same output "
"every time for a given input, otherwise the rollover behaviour may not work "
"as expected."
msgstr ""
"Функція namer викликається досить багато разів під час переміщення, тому "
"вона має бути максимально простою та швидкою. Він також повинен повертати "
"той самий вихід кожного разу для даного введення, інакше поведінка "
"перекидання може працювати не так, як очікувалося."

#: ../../library/logging.handlers.rst:237
msgid ""
"It's also worth noting that care should be taken when using a namer to "
"preserve certain attributes in the filename which are used during rotation. "
"For example, :class:`RotatingFileHandler` expects to have a set of log files "
"whose names contain successive integers, so that rotation works as expected, "
"and :class:`TimedRotatingFileHandler` deletes old log files (based on the "
"``backupCount`` parameter passed to the handler's initializer) by "
"determining the oldest files to delete. For this to happen, the filenames "
"should be sortable using the date/time portion of the filename, and a namer "
"needs to respect this. (If a namer is wanted that doesn't respect this "
"scheme, it will need to be used in a subclass of :class:"
"`TimedRotatingFileHandler` which overrides the :meth:"
"`~TimedRotatingFileHandler.getFilesToDelete` method to fit in with the "
"custom naming scheme.)"
msgstr ""
"Варто також зазначити, що під час використання іменника слід бути обережним, "
"щоб зберегти певні атрибути в імені файлу, які використовуються під час "
"ротації. Наприклад, :class:`RotatingFileHandler` очікує мати набір файлів "
"журналу, імена яких містять послідовні цілі числа, щоб ротація працювала "
"належним чином, а :class:`TimedRotatingFileHandler` видаляє старі файли "
"журналу (на основі ``backupCount`` параметр, переданий ініціалізатору "
"обробника), визначаючи найстаріші файли для видалення. Щоб це сталося, назви "
"файлів мають бути сортованими за датою/часом у назві файлу, і іменувальник "
"має поважати це. (Якщо потрібен іменник, який не відповідає цій схемі, його "
"потрібно буде використовувати в підкласі :class:`TimedRotatingFileHandler`, "
"який замінює метод :meth:`~TimedRotatingFileHandler.getFilesToDelete`, щоб "
"відповідати спеціальному іменуванню схема.)"

#: ../../library/logging.handlers.rst:255
msgid ""
"If this attribute is set to a callable, the :meth:`rotate` method delegates "
"to this callable.  The parameters passed to the callable are those passed "
"to :meth:`rotate`."
msgstr ""
"Якщо цей атрибут встановлено на callable, метод :meth:`rotate` делегує цей "
"callable. Параметри, що передаються викликаному, є тими, що передаються в :"
"meth:`rotate`."

#: ../../library/logging.handlers.rst:263
msgid "Modify the filename of a log file when rotating."
msgstr "Змінити назву файлу журналу під час ротації."

#: ../../library/logging.handlers.rst:265
msgid "This is provided so that a custom filename can be provided."
msgstr "Це надається для того, щоб можна було надати власне ім’я файлу."

#: ../../library/logging.handlers.rst:267
msgid ""
"The default implementation calls the 'namer' attribute of the handler, if "
"it's callable, passing the default name to it. If the attribute isn't "
"callable (the default is ``None``), the name is returned unchanged."
msgstr ""
"Реалізація за замовчуванням викликає атрибут 'namer' обробника, якщо його "
"можна викликати, передаючи йому ім'я за замовчуванням. Якщо атрибут не можна "
"викликати (за замовчуванням ``None``), ім'я повертається без змін."

#: ../../library/logging.handlers.rst:271
msgid "The default name for the log file."
msgstr "Назва за замовчуванням для файлу журналу."

#: ../../library/logging.handlers.rst:278
msgid "When rotating, rotate the current log."
msgstr "Під час обертання обертати поточний журнал."

#: ../../library/logging.handlers.rst:280
msgid ""
"The default implementation calls the 'rotator' attribute of the handler, if "
"it's callable, passing the source and dest arguments to it. If the attribute "
"isn't callable (the default is ``None``), the source is simply renamed to "
"the destination."
msgstr ""
"Реалізація за замовчуванням викликає атрибут 'rotator' обробника, якщо його "
"можна викликати, передаючи йому аргументи джерела та призначення. Якщо "
"атрибут не можна викликати (за замовчуванням ``None``), джерело просто "
"перейменовується на призначення."

#: ../../library/logging.handlers.rst:285
msgid ""
"The source filename. This is normally the base filename, e.g. 'test.log'."
msgstr ""
"Ім'я вихідного файлу. Зазвичай це базова назва файлу, напр. 'test.log'."

#: ../../library/logging.handlers.rst:287
msgid ""
"The destination filename. This is normally what the source is rotated to, e."
"g. 'test.log.1'."
msgstr ""
"Ім'я цільового файлу. Зазвичай це те, до чого обертається джерело, напр. "
"'test.log.1'."

#: ../../library/logging.handlers.rst:292
msgid ""
"The reason the attributes exist is to save you having to subclass - you can "
"use the same callables for instances of :class:`RotatingFileHandler` and :"
"class:`TimedRotatingFileHandler`. If either the namer or rotator callable "
"raises an exception, this will be handled in the same way as any other "
"exception during an :meth:`emit` call, i.e. via the :meth:`handleError` "
"method of the handler."
msgstr ""
"Причина, чому ці атрибути існують, полягає в тому, щоб позбавити вас "
"необхідності створювати підкласи – ви можете використовувати ті самі виклики "
"для екземплярів :class:`RotatingFileHandler` і :class:"
"`TimedRotatingFileHandler`. Якщо виклик іменника або ротатора викликає "
"виняток, це буде оброблено так само, як і будь-який інший виняток під час "
"виклику :meth:`emit`, тобто через метод :meth:`handleError` обробника."

#: ../../library/logging.handlers.rst:299
msgid ""
"If you need to make more significant changes to rotation processing, you can "
"override the methods."
msgstr ""
"Якщо вам потрібно внести більш значні зміни в обробку обертання, ви можете "
"змінити методи."

#: ../../library/logging.handlers.rst:302
msgid "For an example, see :ref:`cookbook-rotator-namer`."
msgstr "Для прикладу перегляньте :ref:`cookbook-rotator-namer`."

#: ../../library/logging.handlers.rst:308
msgid "RotatingFileHandler"
msgstr "RotatingFileHandler"

#: ../../library/logging.handlers.rst:310
msgid ""
"The :class:`RotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files."
msgstr ""
"Клас :class:`RotatingFileHandler`, розташований у модулі :mod:`logging."
"handlers`, підтримує ротацію файлів журналу диска."

#: ../../library/logging.handlers.rst:316
msgid ""
"Returns a new instance of the :class:`RotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is used "
"to open the file with that encoding.  If *delay* is true, then file opening "
"is deferred until the first call to :meth:`emit`.  By default, the file "
"grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"Повертає новий екземпляр класу :class:`RotatingFileHandler`. Зазначений файл "
"відкривається та використовується як потік для реєстрації. Якщо *mode* не "
"вказано, використовується ``'a'``. Якщо *кодування* не ``None``, воно "
"використовується для відкриття файлу з таким кодуванням. Якщо *delay* має "
"значення true, то відкриття файлу відкладено до першого виклику :meth:"
"`emit`. За замовчуванням файл збільшується необмежено довго. Якщо вказано "
"*errors*, це визначає спосіб обробки помилок кодування."

#: ../../library/logging.handlers.rst:323
msgid ""
"You can use the *maxBytes* and *backupCount* values to allow the file to :"
"dfn:`rollover` at a predetermined size. When the size is about to be "
"exceeded, the file is closed and a new file is silently opened for output. "
"Rollover occurs whenever the current log file is nearly *maxBytes* in "
"length; but if either of *maxBytes* or *backupCount* is zero, rollover never "
"occurs, so you generally want to set *backupCount* to at least 1, and have a "
"non-zero *maxBytes*. When *backupCount* is non-zero, the system will save "
"old log files by appending the extensions '.1', '.2' etc., to the filename. "
"For example, with a *backupCount* of 5 and a base file name of :file:`app."
"log`, you would get :file:`app.log`, :file:`app.log.1`, :file:`app.log.2`, "
"up to :file:`app.log.5`. The file being written to is always :file:`app."
"log`.  When this file is filled, it is closed and renamed to :file:`app."
"log.1`, and if files :file:`app.log.1`, :file:`app.log.2`, etc. exist, then "
"they are renamed to :file:`app.log.2`, :file:`app.log.3` etc. respectively."
msgstr ""
"Ви можете використовувати значення *maxBytes* і *backupCount*, щоб дозволити "
"файлу :dfn:`rollover` попередньо визначеного розміру. Коли розмір майже буде "
"перевищено, файл закривається, а новий файл мовчки відкривається для "
"виведення. Перехід відбувається щоразу, коли довжина поточного файлу журналу "
"становить майже *maxBytes*; але якщо будь-яке з *maxBytes* або *backupCount* "
"дорівнює нулю, перехід ніколи не відбувається, тому зазвичай потрібно "
"встановити *backupCount* принаймні на 1 і мати ненульовий *maxBytes*. Якщо "
"*backupCount* не дорівнює нулю, система збереже старі файли журналу, додавши "
"до назви файлу розширення \".1\", \".2\" тощо. Наприклад, з *backupCount* 5 "
"і базовою назвою файлу :file:`app.log`, ви отримаєте :file:`app.log`, :file:"
"`app.log.1`, :file:`app.log.2`, до :file:`app.log.5`. Файл, у який "
"записується, завжди :file:`app.log`. Коли цей файл заповнюється, він "
"закривається та перейменовується на :file:`app.log.1`, а якщо файли :file:"
"`app.log.1`, :file:`app.log.2` тощо. існують, тоді вони перейменовуються "
"відповідно на :file:`app.log.2`, :file:`app.log.3` тощо."

#: ../../library/logging.handlers.rst:347
#: ../../library/logging.handlers.rst:453
msgid "Does a rollover, as described above."
msgstr "Робить перекидання, як описано вище."

#: ../../library/logging.handlers.rst:352
msgid ""
"Outputs the record to the file, catering for rollover as described "
"previously."
msgstr "Виводить запис у файл, обслуговуючи ролловер, як описано раніше."

#: ../../library/logging.handlers.rst:358
msgid "TimedRotatingFileHandler"
msgstr "TimedRotatingFileHandler"

#: ../../library/logging.handlers.rst:360
msgid ""
"The :class:`TimedRotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files at certain timed "
"intervals."
msgstr ""
"Клас :class:`TimedRotatingFileHandler`, розташований у модулі :mod:`logging."
"handlers`, підтримує ротацію файлів журналу диска через певні часові "
"інтервали."

#: ../../library/logging.handlers.rst:367
msgid ""
"Returns a new instance of the :class:`TimedRotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. On rotating it "
"also sets the filename suffix. Rotating happens based on the product of "
"*when* and *interval*."
msgstr ""
"Повертає новий екземпляр класу :class:`TimedRotatingFileHandler`. Зазначений "
"файл відкривається та використовується як потік для реєстрації. При "
"обертанні він також встановлює суфікс імені файлу. Обертання відбувається на "
"основі добутку *when* та *інтервалу*."

#: ../../library/logging.handlers.rst:372
msgid ""
"You can use the *when* to specify the type of *interval*. The list of "
"possible values is below.  Note that they are not case sensitive."
msgstr ""
"Ви можете використовувати *when*, щоб вказати тип *інтервалу*. Нижче "
"наведено список можливих значень. Зауважте, що вони не чутливі до регістру."

#: ../../library/logging.handlers.rst:376
msgid "Value"
msgstr "Valor"

#: ../../library/logging.handlers.rst:376
msgid "Type of interval"
msgstr "Тип інтервалу"

#: ../../library/logging.handlers.rst:376
msgid "If/how *atTime* is used"
msgstr "Якщо/як використовується *atTime*"

#: ../../library/logging.handlers.rst:378
msgid "``'S'``"
msgstr "``'S'``"

#: ../../library/logging.handlers.rst:378
msgid "Seconds"
msgstr "Detik"

#: ../../library/logging.handlers.rst:378
#: ../../library/logging.handlers.rst:380
#: ../../library/logging.handlers.rst:382
#: ../../library/logging.handlers.rst:384
msgid "Ignored"
msgstr "Ігнорується"

#: ../../library/logging.handlers.rst:380
msgid "``'M'``"
msgstr "``'M'``"

#: ../../library/logging.handlers.rst:380
msgid "Minutes"
msgstr "Menit"

#: ../../library/logging.handlers.rst:382
msgid "``'H'``"
msgstr "``'H'``"

#: ../../library/logging.handlers.rst:382
msgid "Hours"
msgstr "Horas"

#: ../../library/logging.handlers.rst:384
msgid "``'D'``"
msgstr "``'D'``"

#: ../../library/logging.handlers.rst:384
msgid "Days"
msgstr "Dias"

#: ../../library/logging.handlers.rst:386
msgid "``'W0'-'W6'``"
msgstr "``'W0'-'W6'``"

#: ../../library/logging.handlers.rst:386
msgid "Weekday (0=Monday)"
msgstr "День тижня (0=понеділок)"

#: ../../library/logging.handlers.rst:386
#: ../../library/logging.handlers.rst:389
msgid "Used to compute initial rollover time"
msgstr "Використовується для обчислення початкового часу перекидання"

#: ../../library/logging.handlers.rst:389
msgid "``'midnight'``"
msgstr "``'midnight'``"

#: ../../library/logging.handlers.rst:389
msgid "Roll over at midnight, if *atTime* not specified, else at time *atTime*"
msgstr "Перехід опівночі, якщо *atTime* не вказано, інакше в час *atTime*"

#: ../../library/logging.handlers.rst:394
msgid ""
"When using weekday-based rotation, specify 'W0' for Monday, 'W1' for "
"Tuesday, and so on up to 'W6' for Sunday. In this case, the value passed for "
"*interval* isn't used."
msgstr ""
"У разі використання ротації на основі днів тижня вкажіть \"W0\" для "
"понеділка, \"W1\" для вівторка і так далі до \"W6\" для неділі. У цьому "
"випадку значення, передане для *інтервалу*, не використовується."

#: ../../library/logging.handlers.rst:398
msgid ""
"The system will save old log files by appending extensions to the filename. "
"The extensions are date-and-time based, using the strftime format ``%Y-%m-"
"%d_%H-%M-%S`` or a leading portion thereof, depending on the rollover "
"interval."
msgstr ""
"Система збереже старі файли журналу, додавши розширення до імені файлу. "
"Розширення базуються на даті й часі з використанням формату strftime ``%Y-%m-"
"%d_%H-%M-%S`` або його початкової частини, залежно від інтервалу переходу."

#: ../../library/logging.handlers.rst:403
msgid ""
"When computing the next rollover time for the first time (when the handler "
"is created), the last modification time of an existing log file, or else the "
"current time, is used to compute when the next rotation will occur."
msgstr ""
"Під час першого обчислення часу наступного переходу (під час створення "
"обробника) для обчислення часу наступного повороту використовується час "
"останньої зміни наявного файлу журналу або поточний час."

#: ../../library/logging.handlers.rst:407
msgid ""
"If the *utc* argument is true, times in UTC will be used; otherwise local "
"time is used."
msgstr ""
"Якщо аргумент *utc* має значення true, буде використано час у UTC; інакше "
"використовується місцевий час."

#: ../../library/logging.handlers.rst:410
msgid ""
"If *backupCount* is nonzero, at most *backupCount* files will be kept, and "
"if more would be created when rollover occurs, the oldest one is deleted. "
"The deletion logic uses the interval to determine which files to delete, so "
"changing the interval may leave old files lying around."
msgstr ""
"Якщо *backupCount* не дорівнює нулю, буде збережено щонайбільше "
"*backupCount* файлів, а якщо буде створено більше під час перенесення "
"файлів, видаляється найстаріший. Логіка видалення використовує інтервал, щоб "
"визначити, які файли видаляти, тому зміна інтервалу може залишити старі "
"файли без місця."

#: ../../library/logging.handlers.rst:415
msgid ""
"If *delay* is true, then file opening is deferred until the first call to :"
"meth:`emit`."
msgstr ""
"Якщо *delay* має значення true, то відкриття файлу відкладено до першого "
"виклику :meth:`emit`."

#: ../../library/logging.handlers.rst:418
msgid ""
"If *atTime* is not ``None``, it must be a ``datetime.time`` instance which "
"specifies the time of day when rollover occurs, for the cases where rollover "
"is set to happen \"at midnight\" or \"on a particular weekday\". Note that "
"in these cases, the *atTime* value is effectively used to compute the "
"*initial* rollover, and subsequent rollovers would be calculated via the "
"normal interval calculation."
msgstr ""
"Якщо *atTime* не є ``None``, це має бути екземпляр ``datetime.time``, який "
"визначає час доби, коли відбувається перекидання, для випадків, коли "
"перекидання встановлено на \"опівночі\" або \"на певний день тижня\". "
"Зауважте, що в цих випадках значення *atTime* ефективно використовується для "
"обчислення *початкового* ролловера, а наступні ролловери обчислюватимуться "
"за допомогою звичайного обчислення інтервалу."

#: ../../library/logging.handlers.rst:425
msgid ""
"If *errors* is specified, it's used to determine how encoding errors are "
"handled."
msgstr ""
"Якщо вказано *errors*, воно використовується для визначення способу обробки "
"помилок кодування."

#: ../../library/logging.handlers.rst:428
msgid ""
"Calculation of the initial rollover time is done when the handler is "
"initialised. Calculation of subsequent rollover times is done only when "
"rollover occurs, and rollover occurs only when emitting output. If this is "
"not kept in mind, it might lead to some confusion. For example, if an "
"interval of \"every minute\" is set, that does not mean you will always see "
"log files with times (in the filename) separated by a minute; if, during "
"application execution, logging output is generated more frequently than once "
"a minute, *then* you can expect to see log files with times separated by a "
"minute. If, on the other hand, logging messages are only output once every "
"five minutes (say), then there will be gaps in the file times corresponding "
"to the minutes where no output (and hence no rollover) occurred."
msgstr ""
"Розрахунок початкового часу перекидання виконується під час ініціалізації "
"обробника. Розрахунок наступного часу ролловеру виконується лише тоді, коли "
"відбувається ролловер, а ролловер відбувається лише під час випромінювання "
"вихідних даних. Якщо цього не враховувати, це може призвести до певної "
"плутанини. Наприклад, якщо встановлено інтервал \"кожної хвилини\", це не "
"означає, що ви завжди бачитимете файли журналів із часом (у назві файлу), "
"розділеними хвилиною; якщо під час виконання програми вихідні дані журналу "
"генеруються частіше, ніж один раз на хвилину, *тоді* ви можете очікувати, що "
"побачите файли журналу з часом, розділеним хвилиною. З іншого боку, якщо "
"повідомлення журналу виводяться лише один раз кожні п’ять хвилин (скажімо), "
"тоді будуть проміжки у часі файлу, що відповідає хвилинам, коли не було "
"виведено (і, отже, не відбулося перекидання)."

#: ../../library/logging.handlers.rst:441
msgid "*atTime* parameter was added."
msgstr "Додано параметр *atTime*."

#: ../../library/logging.handlers.rst:457
msgid ""
"Outputs the record to the file, catering for rollover as described above."
msgstr "Виводить запис у файл, обслуговуючи ролловер, як описано вище."

#: ../../library/logging.handlers.rst:461
msgid ""
"Returns a list of filenames which should be deleted as part of rollover. "
"These are the absolute paths of the oldest backup log files written by the "
"handler."
msgstr ""
"Повертає список імен файлів, які слід видалити під час переміщення. Це "
"абсолютні шляхи до найстаріших резервних файлів журналу, записаних "
"обробником."

#: ../../library/logging.handlers.rst:467
msgid "SocketHandler"
msgstr "SocketHandler"

#: ../../library/logging.handlers.rst:469
msgid ""
"The :class:`SocketHandler` class, located in the :mod:`logging.handlers` "
"module, sends logging output to a network socket. The base class uses a TCP "
"socket."
msgstr ""
"Клас :class:`SocketHandler`, розташований у модулі :mod:`logging.handlers`, "
"надсилає вихідні дані журналу в мережевий сокет. Базовий клас використовує "
"сокет TCP."

#: ../../library/logging.handlers.rst:475
msgid ""
"Returns a new instance of the :class:`SocketHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""
"Повертає новий екземпляр класу :class:`SocketHandler`, призначений для "
"зв’язку з віддаленою машиною, адресу якої вказують *host* і *port*."

#: ../../library/logging.handlers.rst:478
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a TCP socket is created."
msgstr ""
"Якщо ``port`` вказано як ``None``, сокет домену Unix створюється за "
"допомогою значення в ``host`` - інакше створюється сокет TCP."

#: ../../library/logging.handlers.rst:484
msgid "Closes the socket."
msgstr "Закриває розетку."

#: ../../library/logging.handlers.rst:489
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. If the connection was previously lost, re-establishes the "
"connection. To unpickle the record at the receiving end into a :class:"
"`~logging.LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""
"Вибирає словник атрибутів запису та записує його в сокет у двійковому "
"форматі. Якщо є помилка з сокетом, мовчки скидає пакет. Якщо з’єднання було "
"втрачено, відновлює з’єднання. Щоб видалити запис на приймальному кінці в :"
"class:`~logging.LogRecord`, скористайтеся :func:`~logging.makeLogRecord` "
"функцією."

#: ../../library/logging.handlers.rst:499
msgid ""
"Handles an error which has occurred during :meth:`emit`. The most likely "
"cause is a lost connection. Closes the socket so that we can retry on the "
"next event."
msgstr ""
"Обробляє помилку, яка сталася під час :meth:`emit`. Найімовірніша причина – "
"втрата зв’язку. Закриває сокет, щоб ми могли повторити наступну подію."

#: ../../library/logging.handlers.rst:506
msgid ""
"This is a factory method which allows subclasses to define the precise type "
"of socket they want. The default implementation creates a TCP socket (:const:"
"`socket.SOCK_STREAM`)."
msgstr ""
"Це фабричний метод, який дозволяє підкласам визначати точний тип сокета, "
"який вони хочуть. Стандартна реалізація створює сокет TCP (:const:`socket."
"SOCK_STREAM`)."

#: ../../library/logging.handlers.rst:513
msgid ""
"Pickles the record's attribute dictionary in binary format with a length "
"prefix, and returns it ready for transmission across the socket. The details "
"of this operation are equivalent to::"
msgstr ""
"Вибирає словник атрибутів запису в двійковому форматі з префіксом довжини та "
"повертає його готовим для передачі через сокет. Подробиці цієї операції "
"еквівалентні:"

#: ../../library/logging.handlers.rst:521
msgid ""
"Note that pickles aren't completely secure. If you are concerned about "
"security, you may want to override this method to implement a more secure "
"mechanism. For example, you can sign pickles using HMAC and then verify them "
"on the receiving end, or alternatively you can disable unpickling of global "
"objects on the receiving end."
msgstr ""
"Зауважте, що мариновані огірки не є повністю безпечними. Якщо вас турбує "
"безпека, ви можете замінити цей метод, щоб застосувати більш безпечний "
"механізм. Наприклад, ви можете підписати соління за допомогою HMAC, а потім "
"перевірити їх на приймальній стороні, або, як альтернатива, ви можете "
"вимкнути розбирання глобальних об’єктів на приймальній стороні."

#: ../../library/logging.handlers.rst:530
msgid ""
"Send a pickled byte-string *packet* to the socket. The format of the sent "
"byte-string is as described in the documentation for :meth:`~SocketHandler."
"makePickle`."
msgstr ""
"Надішліть маринований байтовий рядок *пакет* до сокета. Формат надісланого "
"байтового рядка відповідає документації для :meth:`~SocketHandler."
"makePickle`."

#: ../../library/logging.handlers.rst:534
msgid ""
"This function allows for partial sends, which can happen when the network is "
"busy."
msgstr ""
"Ця функція дозволяє частково надсилати, що може статися, коли мережа зайнята."

#: ../../library/logging.handlers.rst:540
msgid ""
"Tries to create a socket; on failure, uses an exponential back-off "
"algorithm.  On initial failure, the handler will drop the message it was "
"trying to send.  When subsequent messages are handled by the same instance, "
"it will not try connecting until some time has passed.  The default "
"parameters are such that the initial delay is one second, and if after that "
"delay the connection still can't be made, the handler will double the delay "
"each time up to a maximum of 30 seconds."
msgstr ""
"Намагається створити сокет; у разі відмови використовує експоненціальний "
"алгоритм відстрочки. У разі початкової помилки обробник скине повідомлення, "
"яке намагався надіслати. Коли наступні повідомлення обробляються тим самим "
"екземпляром, він не намагатиметься підключитися, доки не мине деякий час. "
"Параметри за замовчуванням такі, що початкова затримка становить одну "
"секунду, і якщо після цієї затримки з’єднання все одно не вдається "
"встановити, обробник кожного разу подвоює затримку до максимум 30 секунд."

#: ../../library/logging.handlers.rst:548
msgid "This behaviour is controlled by the following handler attributes:"
msgstr "Ця поведінка контролюється такими атрибутами обробника:"

#: ../../library/logging.handlers.rst:550
msgid "``retryStart`` (initial delay, defaulting to 1.0 seconds)."
msgstr "``retryStart`` (початкова затримка, за замовчуванням 1,0 секунди)."

#: ../../library/logging.handlers.rst:551
msgid "``retryFactor`` (multiplier, defaulting to 2.0)."
msgstr "``retryFactor`` (множник, за умовчанням 2,0)."

#: ../../library/logging.handlers.rst:552
msgid "``retryMax`` (maximum delay, defaulting to 30.0 seconds)."
msgstr "``retryMax`` (максимальна затримка, за замовчуванням 30,0 секунд)."

#: ../../library/logging.handlers.rst:554
msgid ""
"This means that if the remote listener starts up *after* the handler has "
"been used, you could lose messages (since the handler won't even attempt a "
"connection until the delay has elapsed, but just silently drop messages "
"during the delay period)."
msgstr ""
"Це означає, що якщо віддалений слухач запускається *після* використання "
"обробника, ви можете втратити повідомлення (оскільки обробник навіть не "
"намагатиметься встановити з’єднання, доки не мине затримка, а лише мовчки "
"видалятиме повідомлення протягом періоду затримки)."

#: ../../library/logging.handlers.rst:563
msgid "DatagramHandler"
msgstr "DatagramHandler"

#: ../../library/logging.handlers.rst:565
msgid ""
"The :class:`DatagramHandler` class, located in the :mod:`logging.handlers` "
"module, inherits from :class:`SocketHandler` to support sending logging "
"messages over UDP sockets."
msgstr ""
"Клас :class:`DatagramHandler`, розташований у модулі :mod:`logging."
"handlers`, успадковує :class:`SocketHandler` для підтримки надсилання "
"повідомлень журналу через сокети UDP."

#: ../../library/logging.handlers.rst:572
msgid ""
"Returns a new instance of the :class:`DatagramHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""
"Повертає новий екземпляр класу :class:`DatagramHandler`, призначений для "
"зв’язку з віддаленою машиною, адресу якої вказують *host* і *port*."

#: ../../library/logging.handlers.rst:575
msgid ""
"As UDP is not a streaming protocol, there is no persistent connection "
"between an instance of this handler and *host*. For this reason, when using "
"a network socket, a DNS lookup might have to be made each time an event is "
"logged, which can introduce some latency into the system. If this affects "
"you, you can do a lookup yourself and initialize this handler using the "
"looked-up IP address rather than the hostname."
msgstr ""
"Поскольку UDP не является протоколом потоковой передачи, между экземпляром "
"этого обработчика и *хостом* не существует постоянного соединения. По этой "
"причине при использовании сетевого сокета может потребоваться выполнять "
"поиск DNS каждый раз при регистрации события, что может привести к некоторой "
"задержке в системе. Если это вас затрагивает, вы можете выполнить поиск "
"самостоятельно и инициализировать этот обработчик, используя найденный IP-"
"адрес, а не имя хоста."

#: ../../library/logging.handlers.rst:582
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a UDP socket is created."
msgstr ""
"Якщо ``port`` вказано як ``None``, сокет домену Unix створюється за "
"допомогою значення в ``host``; інакше створюється сокет UDP."

#: ../../library/logging.handlers.rst:588
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. To unpickle the record at the receiving end into a :class:`~logging."
"LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""
"Вибирає словник атрибутів запису та записує його в сокет у двійковому "
"форматі. Якщо є помилка з сокетом, мовчки скидає пакет. Щоб видалити запис "
"на приймальному кінці в :class:`~logging.LogRecord`, скористайтеся :func:"
"`~logging.makeLogRecord` функцією."

#: ../../library/logging.handlers.rst:597
msgid ""
"The factory method of :class:`SocketHandler` is here overridden to create a "
"UDP socket (:const:`socket.SOCK_DGRAM`)."
msgstr ""
"Фабричний метод :class:`SocketHandler` тут перевизначено для створення "
"сокета UDP (:const:`socket.SOCK_DGRAM`)."

#: ../../library/logging.handlers.rst:603
msgid ""
"Send a pickled byte-string to a socket. The format of the sent byte-string "
"is as described in the documentation for :meth:`SocketHandler.makePickle`."
msgstr ""
"Надіслати маринований рядок байтів до сокета. Формат надісланого байтового "
"рядка відповідає документації для :meth:`SocketHandler.makePickle`."

#: ../../library/logging.handlers.rst:610
msgid "SysLogHandler"
msgstr "SysLogHandler"

#: ../../library/logging.handlers.rst:612
msgid ""
"The :class:`SysLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a remote or local Unix syslog."
msgstr ""
"Клас :class:`SysLogHandler`, розташований у модулі :mod:`logging.handlers`, "
"підтримує надсилання повідомлень журналу до віддаленого чи локального "
"системного журналу Unix."

#: ../../library/logging.handlers.rst:618
msgid ""
"Returns a new instance of the :class:`SysLogHandler` class intended to "
"communicate with a remote Unix machine whose address is given by *address* "
"in the form of a ``(host, port)`` tuple.  If *address* is not specified, "
"``('localhost', 514)`` is used.  The address is used to open a socket.  An "
"alternative to providing a ``(host, port)`` tuple is providing an address as "
"a string, for example '/dev/log'. In this case, a Unix domain socket is used "
"to send the message to the syslog. If *facility* is not specified, :const:"
"`LOG_USER` is used. The type of socket opened depends on the *socktype* "
"argument, which defaults to :const:`socket.SOCK_DGRAM` and thus opens a UDP "
"socket. To open a TCP socket (for use with the newer syslog daemons such as "
"rsyslog), specify a value of :const:`socket.SOCK_STREAM`."
msgstr ""
"Повертає новий екземпляр класу :class:`SysLogHandler`, призначений для "
"зв’язку з віддаленою машиною Unix, адреса якої задана *адресою* у формі "
"кортежу ``(хост, порт)``. Якщо *адреса* не вказана, використовується "
"``('localhost', 514)``. Адреса використовується для відкриття сокета. "
"Альтернативою наданню кортежу ``(хост, порт)`` є надання адреси у вигляді "
"рядка, наприклад '/dev/log'. У цьому випадку для надсилання повідомлення до "
"системного журналу використовується сокет домену Unix. Якщо *facility* не "
"вказано, :const:`LOG_USER` використовується. Тип відкритого сокета залежить "
"від аргументу *socktype*, який за замовчуванням має значення :const:`socket."
"SOCK_DGRAM` і таким чином відкриває сокет UDP. Щоб відкрити сокет TCP (для "
"використання з новими демонами syslog, наприклад rsyslog), вкажіть значення :"
"const:`socket.SOCK_STREAM`."

#: ../../library/logging.handlers.rst:630
msgid ""
"Note that if your server is not listening on UDP port 514, :class:"
"`SysLogHandler` may appear not to work. In that case, check what address you "
"should be using for a domain socket - it's system dependent. For example, on "
"Linux it's usually '/dev/log' but on OS/X it's '/var/run/syslog'. You'll "
"need to check your platform and use the appropriate address (you may need to "
"do this check at runtime if your application needs to run on several "
"platforms). On Windows, you pretty much have to use the UDP option."
msgstr ""
"Зауважте, що якщо ваш сервер не прослуховує UDP-порт 514, :class:"
"`SysLogHandler` може здатися непрацюючим. У такому випадку перевірте, яку "
"адресу ви повинні використовувати для доменного сокета - це залежить від "
"системи. Наприклад, у Linux це зазвичай '/dev/log', а в OS/X це '/var/run/"
"syslog'. Вам потрібно буде перевірити свою платформу та використати "
"відповідну адресу (може знадобитися виконати цю перевірку під час виконання, "
"якщо ваша програма має працювати на кількох платформах). У Windows ви майже "
"повинні використовувати параметр UDP."

#: ../../library/logging.handlers.rst:639
msgid ""
"On macOS 12.x (Monterey), Apple has changed the behaviour of their syslog "
"daemon - it no longer listens on a domain socket. Therefore, you cannot "
"expect :class:`SysLogHandler` to work on this system."
msgstr ""
"В macOS 12.x (Монтерей) Apple изменила поведение своего демона системного "
"журнала — он больше не прослушивает сокет домена. Следовательно, вы не "
"можете ожидать, что :class:`SysLogHandler` будет работать в этой системе."

#: ../../library/logging.handlers.rst:643
msgid "See :gh:`91070` for more information."
msgstr "См. :gh:`91070` для получения дополнительной информации."

#: ../../library/logging.handlers.rst:645
msgid "*socktype* was added."
msgstr "Додано *socktype*."

#: ../../library/logging.handlers.rst:651
msgid "Closes the socket to the remote host."
msgstr "Закриває сокет для віддаленого хоста."

#: ../../library/logging.handlers.rst:655
msgid ""
"Tries to create a socket and, if it's not a datagram socket, connect it to "
"the other end. This method is called during handler initialization, but it's "
"not regarded as an error if the other end isn't listening at this point - "
"the method will be called again when emitting an event, if there is no "
"socket at that point."
msgstr ""
"Пытается создать сокет и, если это не дейтаграммный сокет, подключить его к "
"другому концу. Этот метод вызывается во время инициализации обработчика, но "
"он не считается ошибкой, если другой конец в этот момент не прослушивает — "
"метод будет вызываться снова при отправке события, если в этот момент нет "
"сокета."

#: ../../library/logging.handlers.rst:665
msgid ""
"The record is formatted, and then sent to the syslog server. If exception "
"information is present, it is *not* sent to the server."
msgstr ""
"Запис форматується, а потім надсилається на сервер syslog. Якщо присутня "
"інформація про винятки, вона *не* надсилається на сервер."

#: ../../library/logging.handlers.rst:668
msgid ""
"(See: :issue:`12168`.) In earlier versions, the message sent to the syslog "
"daemons was always terminated with a NUL byte, because early versions of "
"these daemons expected a NUL terminated message - even though it's not in "
"the relevant specification (:rfc:`5424`). More recent versions of these "
"daemons don't expect the NUL byte but strip it off if it's there, and even "
"more recent daemons (which adhere more closely to RFC 5424) pass the NUL "
"byte on as part of the message."
msgstr ""
"(Див.: :issue:`12168`.) У попередніх версіях повідомлення, надіслане до "
"демонов системного журналу, завжди завершувалося нульовим байтом, оскільки "
"ранні версії цих демонів очікували повідомлення, що завершується нульовим "
"значенням, навіть якщо цього немає у відповідній специфікації (:rfc:`5424`). "
"Новіші версії цих демонов не очікують байт NUL, але видаляють його, якщо він "
"там є, і навіть новіші демони (які більше дотримуються RFC 5424) передають "
"байт NUL як частину повідомлення."

#: ../../library/logging.handlers.rst:677
msgid ""
"To enable easier handling of syslog messages in the face of all these "
"differing daemon behaviours, the appending of the NUL byte has been made "
"configurable, through the use of a class-level attribute, ``append_nul``. "
"This defaults to ``True`` (preserving the existing behaviour) but can be set "
"to ``False`` on a ``SysLogHandler`` instance in order for that instance to "
"*not* append the NUL terminator."
msgstr ""
"Щоб полегшити обробку повідомлень системного журналу, незважаючи на всі ці "
"відмінності в поведінці демона, додавання байта NUL було зроблено "
"конфігурованим за допомогою атрибута рівня класу, ``append_nul``. За "
"умовчанням це значення ``True`` (зберігаючи існуючу поведінку), але можна "
"встановити ``False`` для екземпляра ``SysLogHandler``, щоб цей екземпляр "
"*не* додавав термінатор NUL."

#: ../../library/logging.handlers.rst:684
msgid ""
"(See: :issue:`12419`.) In earlier versions, there was no facility for an "
"\"ident\" or \"tag\" prefix to identify the source of the message. This can "
"now be specified using a class-level attribute, defaulting to ``\"\"`` to "
"preserve existing behaviour, but which can be overridden on a "
"``SysLogHandler`` instance in order for that instance to prepend the ident "
"to every message handled. Note that the provided ident must be text, not "
"bytes, and is prepended to the message exactly as is."
msgstr ""
"(Див.: :issue:`12419`.) У попередніх версіях не було можливості для префікса "
"\"ident\" або \"tag\" для визначення джерела повідомлення. Тепер це можна "
"вказати за допомогою атрибута рівня класу, який за замовчуванням має "
"значення ``\"\"``, щоб зберегти існуючу поведінку, але який можна "
"перевизначити в екземплярі ``SysLogHandler``, щоб цей екземпляр додавав "
"ідентифікатор перед кожним повідомленням обробляється. Зауважте, що наданий "
"ідентифікатор має бути текстом, а не байтами, і додається до повідомлення "
"точно так, як є."

#: ../../library/logging.handlers.rst:695
msgid ""
"Encodes the facility and priority into an integer. You can pass in strings "
"or integers - if strings are passed, internal mapping dictionaries are used "
"to convert them to integers."
msgstr ""
"Кодує засіб і пріоритет у ціле число. Ви можете передавати рядки або цілі "
"числа - якщо рядки передаються, внутрішні словники відображення "
"використовуються для їх перетворення на цілі числа."

#: ../../library/logging.handlers.rst:699
msgid ""
"The symbolic ``LOG_`` values are defined in :class:`SysLogHandler` and "
"mirror the values defined in the ``sys/syslog.h`` header file."
msgstr ""
"Символічні значення ``LOG_`` визначені в :class:`SysLogHandler` і "
"відображають значення, визначені у файлі заголовка ``sys/syslog.h``."

#: ../../library/logging.handlers.rst:702
msgid "**Priorities**"
msgstr "**Пріоритети**"

#: ../../library/logging.handlers.rst:705
#: ../../library/logging.handlers.rst:727
msgid "Name (string)"
msgstr "Nama (string)"

#: ../../library/logging.handlers.rst:705
#: ../../library/logging.handlers.rst:727
msgid "Symbolic value"
msgstr "Символічне значення"

#: ../../library/logging.handlers.rst:707
msgid "``alert``"
msgstr "``alert``"

#: ../../library/logging.handlers.rst:707
msgid "LOG_ALERT"
msgstr "LOG_ALERT"

#: ../../library/logging.handlers.rst:709
msgid "``crit`` or ``critical``"
msgstr "``crit`` or ``critical``"

#: ../../library/logging.handlers.rst:709
msgid "LOG_CRIT"
msgstr "LOG_CRIT"

#: ../../library/logging.handlers.rst:711
msgid "``debug``"
msgstr "``debug``"

#: ../../library/logging.handlers.rst:711
msgid "LOG_DEBUG"
msgstr "LOG_DEBUG"

#: ../../library/logging.handlers.rst:713
msgid "``emerg`` or ``panic``"
msgstr "``emerg`` or ``panic``"

#: ../../library/logging.handlers.rst:713
msgid "LOG_EMERG"
msgstr "LOG_EMERG"

#: ../../library/logging.handlers.rst:715
msgid "``err`` or ``error``"
msgstr "``err`` ou ``error``"

#: ../../library/logging.handlers.rst:715
msgid "LOG_ERR"
msgstr "LOG_ERR"

#: ../../library/logging.handlers.rst:717
msgid "``info``"
msgstr "``info``"

#: ../../library/logging.handlers.rst:717
msgid "LOG_INFO"
msgstr "LOG_INFO"

#: ../../library/logging.handlers.rst:719
msgid "``notice``"
msgstr "``notice``"

#: ../../library/logging.handlers.rst:719
msgid "LOG_NOTICE"
msgstr "LOG_NOTICE"

#: ../../library/logging.handlers.rst:721
msgid "``warn`` or ``warning``"
msgstr "``warn`` or ``warning``"

#: ../../library/logging.handlers.rst:721
msgid "LOG_WARNING"
msgstr "LOG_WARNING"

#: ../../library/logging.handlers.rst:724
msgid "**Facilities**"
msgstr "**Інфраструктура**"

#: ../../library/logging.handlers.rst:729
msgid "``auth``"
msgstr "``auth``"

#: ../../library/logging.handlers.rst:729
msgid "LOG_AUTH"
msgstr "LOG_AUTH"

#: ../../library/logging.handlers.rst:731
msgid "``authpriv``"
msgstr "``authpriv``"

#: ../../library/logging.handlers.rst:731
msgid "LOG_AUTHPRIV"
msgstr "LOG_AUTHPRIV"

#: ../../library/logging.handlers.rst:733
msgid "``cron``"
msgstr "``cron``"

#: ../../library/logging.handlers.rst:733
msgid "LOG_CRON"
msgstr "LOG_CRON"

#: ../../library/logging.handlers.rst:735
msgid "``daemon``"
msgstr "``daemon``"

#: ../../library/logging.handlers.rst:735
msgid "LOG_DAEMON"
msgstr "LOG_DAEMON"

#: ../../library/logging.handlers.rst:737
msgid "``ftp``"
msgstr "``ftp``"

#: ../../library/logging.handlers.rst:737
msgid "LOG_FTP"
msgstr "LOG_FTP"

#: ../../library/logging.handlers.rst:739
msgid "``kern``"
msgstr "``kern``"

#: ../../library/logging.handlers.rst:739
msgid "LOG_KERN"
msgstr "LOG_KERN"

#: ../../library/logging.handlers.rst:741
msgid "``lpr``"
msgstr "``lpr``"

#: ../../library/logging.handlers.rst:741
msgid "LOG_LPR"
msgstr "LOG_LPR"

#: ../../library/logging.handlers.rst:743
msgid "``mail``"
msgstr "``mail``"

#: ../../library/logging.handlers.rst:743
msgid "LOG_MAIL"
msgstr "LOG_MAIL"

#: ../../library/logging.handlers.rst:745
msgid "``news``"
msgstr "``news``"

#: ../../library/logging.handlers.rst:745
msgid "LOG_NEWS"
msgstr "LOG_NEWS"

#: ../../library/logging.handlers.rst:747
msgid "``syslog``"
msgstr "``syslog``"

#: ../../library/logging.handlers.rst:747
msgid "LOG_SYSLOG"
msgstr "LOG_SYSLOG"

#: ../../library/logging.handlers.rst:749
msgid "``user``"
msgstr "``user``"

#: ../../library/logging.handlers.rst:749
msgid "LOG_USER"
msgstr "LOG_USER"

#: ../../library/logging.handlers.rst:751
msgid "``uucp``"
msgstr "``uucp``"

#: ../../library/logging.handlers.rst:751
msgid "LOG_UUCP"
msgstr "LOG_UUCP"

#: ../../library/logging.handlers.rst:753
msgid "``local0``"
msgstr "``local0``"

#: ../../library/logging.handlers.rst:753
msgid "LOG_LOCAL0"
msgstr "LOG_LOCAL0"

#: ../../library/logging.handlers.rst:755
msgid "``local1``"
msgstr "``local1``"

#: ../../library/logging.handlers.rst:755
msgid "LOG_LOCAL1"
msgstr "LOG_LOCAL1"

#: ../../library/logging.handlers.rst:757
msgid "``local2``"
msgstr "``local2``"

#: ../../library/logging.handlers.rst:757
msgid "LOG_LOCAL2"
msgstr "LOG_LOCAL2"

#: ../../library/logging.handlers.rst:759
msgid "``local3``"
msgstr "``local3``"

#: ../../library/logging.handlers.rst:759
msgid "LOG_LOCAL3"
msgstr "LOG_LOCAL3"

#: ../../library/logging.handlers.rst:761
msgid "``local4``"
msgstr "``local4``"

#: ../../library/logging.handlers.rst:761
msgid "LOG_LOCAL4"
msgstr "LOG_LOCAL4"

#: ../../library/logging.handlers.rst:763
msgid "``local5``"
msgstr "``local5``"

#: ../../library/logging.handlers.rst:763
msgid "LOG_LOCAL5"
msgstr "LOG_LOCAL5"

#: ../../library/logging.handlers.rst:765
msgid "``local6``"
msgstr "``local6``"

#: ../../library/logging.handlers.rst:765
msgid "LOG_LOCAL6"
msgstr "LOG_LOCAL6"

#: ../../library/logging.handlers.rst:767
msgid "``local7``"
msgstr "``local7``"

#: ../../library/logging.handlers.rst:767
msgid "LOG_LOCAL7"
msgstr "LOG_LOCAL7"

#: ../../library/logging.handlers.rst:772
msgid ""
"Maps a logging level name to a syslog priority name. You may need to "
"override this if you are using custom levels, or if the default algorithm is "
"not suitable for your needs. The default algorithm maps ``DEBUG``, ``INFO``, "
"``WARNING``, ``ERROR`` and ``CRITICAL`` to the equivalent syslog names, and "
"all other level names to 'warning'."
msgstr ""
"Зіставляє назву рівня журналювання на назву пріоритету системного журналу. "
"Можливо, вам знадобиться перевизначити це, якщо ви використовуєте спеціальні "
"рівні або якщо алгоритм за замовчуванням не підходить для ваших потреб. "
"Алгоритм за замовчуванням відображає ``DEBUG``, ``INFO``, ``WARNING``, "
"``ERROR`` і ``CRITICAL`` на еквівалентні назви системного журналу, а всі "
"інші назви рівнів на \"попередження\"."

#: ../../library/logging.handlers.rst:782
msgid "NTEventLogHandler"
msgstr "NTEventLogHandler"

#: ../../library/logging.handlers.rst:784
msgid ""
"The :class:`NTEventLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a local Windows NT, Windows "
"2000 or Windows XP event log. Before you can use it, you need Mark Hammond's "
"Win32 extensions for Python installed."
msgstr ""
"Клас :class:`NTEventLogHandler`, розташований у модулі :mod:`logging."
"handlers`, підтримує надсилання повідомлень журналу до локального журналу "
"подій Windows NT, Windows 2000 або Windows XP. Перш ніж використовувати "
"його, вам потрібно встановити розширення Win32 Марка Хаммонда для Python."

#: ../../library/logging.handlers.rst:792
msgid ""
"Returns a new instance of the :class:`NTEventLogHandler` class. The "
"*appname* is used to define the application name as it appears in the event "
"log. An appropriate registry entry is created using this name. The *dllname* "
"should give the fully qualified pathname of a .dll or .exe which contains "
"message definitions to hold in the log (if not specified, ``'win32service."
"pyd'`` is used - this is installed with the Win32 extensions and contains "
"some basic placeholder message definitions. Note that use of these "
"placeholders will make your event logs big, as the entire message source is "
"held in the log. If you want slimmer logs, you have to pass in the name of "
"your own .dll or .exe which contains the message definitions you want to use "
"in the event log). The *logtype* is one of ``'Application'``, ``'System'`` "
"or ``'Security'``, and defaults to ``'Application'``."
msgstr ""
"Повертає новий екземпляр класу :class:`NTEventLogHandler`. *Appname* "
"використовується для визначення назви програми, яка відображається в журналі "
"подій. За допомогою цього імені створюється відповідний запис реєстру. "
"*dllname* має давати повне ім’я шляху до .dll або .exe, який містить "
"визначення повідомлень для зберігання в журналі (якщо не вказано, "
"використовується ``'win32service.pyd'`` — він інсталюється з розширеннями "
"Win32 і містить деякі основні визначення повідомлень-заповнювачів. Зауважте, "
"що використання цих заповнювачів збільшить ваші журнали подій, оскільки все "
"джерело повідомлень зберігається в журналі. Якщо ви хочете мати менші "
"журнали, вам потрібно передати ім’я власної .dll або .exe, який містить "
"визначення повідомлень, які ви хочете використовувати в журналі подій). "
"*logtype* є одним із ``'Application'``, ``'System'`` або ``'Security'``, і "
"за замовчуванням ``'Application'``."

#: ../../library/logging.handlers.rst:808
msgid ""
"At this point, you can remove the application name from the registry as a "
"source of event log entries. However, if you do this, you will not be able "
"to see the events as you intended in the Event Log Viewer - it needs to be "
"able to access the registry to get the .dll name. The current version does "
"not do this."
msgstr ""
"На цьому етапі ви можете видалити назву програми з реєстру як джерело "
"записів журналу подій. Однак, якщо ви зробите це, ви не зможете побачити "
"події, як ви планували, у засобі перегляду журналу подій - йому потрібен "
"доступ до реєстру, щоб отримати назву .dll. Поточна версія цього не робить."

#: ../../library/logging.handlers.rst:817
msgid ""
"Determines the message ID, event category and event type, and then logs the "
"message in the NT event log."
msgstr ""
"Визначає ідентифікатор повідомлення, категорію події та тип події, а потім "
"записує повідомлення в журнал подій NT."

#: ../../library/logging.handlers.rst:823
msgid ""
"Returns the event category for the record. Override this if you want to "
"specify your own categories. This version returns 0."
msgstr ""
"Повертає категорію події для запису. Перевизначте це, якщо хочете вказати "
"власні категорії. Ця версія повертає 0."

#: ../../library/logging.handlers.rst:829
msgid ""
"Returns the event type for the record. Override this if you want to specify "
"your own types. This version does a mapping using the handler's typemap "
"attribute, which is set up in :meth:`__init__` to a dictionary which "
"contains mappings for :const:`DEBUG`, :const:`INFO`, :const:`WARNING`, :"
"const:`ERROR` and :const:`CRITICAL`. If you are using your own levels, you "
"will either need to override this method or place a suitable dictionary in "
"the handler's *typemap* attribute."
msgstr ""
"Повертає тип події для запису. Перевизначте це, якщо хочете вказати власні "
"типи. Ця версія виконує зіставлення за допомогою атрибута typemap обробника, "
"який встановлено в :meth:`__init__`, на словник, який містить зіставлення "
"для :const:`DEBUG`, :const:`INFO`, :const:`WARNING`, :const:`ERROR` і :const:"
"`CRITICAL`. Якщо ви використовуєте власні рівні, вам потрібно буде "
"перевизначити цей метод або розмістити відповідний словник в атрибуті "
"*typemap* обробника."

#: ../../library/logging.handlers.rst:840
msgid ""
"Returns the message ID for the record. If you are using your own messages, "
"you could do this by having the *msg* passed to the logger being an ID "
"rather than a format string. Then, in here, you could use a dictionary "
"lookup to get the message ID. This version returns 1, which is the base "
"message ID in :file:`win32service.pyd`."
msgstr ""
"Повертає ідентифікатор повідомлення для запису. Якщо ви використовуєте "
"власні повідомлення, ви можете зробити це, передавши *повідомлення* до "
"реєстратора як ідентифікатор, а не рядок формату. Тоді тут ви можете "
"скористатися пошуком у словнику, щоб отримати ідентифікатор повідомлення. Ця "
"версія повертає 1, який є основним ідентифікатором повідомлення в :file:"
"`win32service.pyd`."

#: ../../library/logging.handlers.rst:849
msgid "SMTPHandler"
msgstr "SMTPHandler"

#: ../../library/logging.handlers.rst:851
msgid ""
"The :class:`SMTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to an email address via SMTP."
msgstr ""
"Клас :class:`SMTPHandler`, розташований у модулі :mod:`logging.handlers`, "
"підтримує надсилання повідомлень журналу на адресу електронної пошти через "
"SMTP."

#: ../../library/logging.handlers.rst:857
msgid ""
"Returns a new instance of the :class:`SMTPHandler` class. The instance is "
"initialized with the from and to addresses and subject line of the email. "
"The *toaddrs* should be a list of strings. To specify a non-standard SMTP "
"port, use the (host, port) tuple format for the *mailhost* argument. If you "
"use a string, the standard SMTP port is used. If your SMTP server requires "
"authentication, you can specify a (username, password) tuple for the "
"*credentials* argument."
msgstr ""
"Повертає новий екземпляр класу :class:`SMTPHandler`. Екземпляр "
"ініціалізується адресами відправника та одержувача та рядком теми "
"електронного листа. *toaddrs* має бути списком рядків. Щоб указати "
"нестандартний порт SMTP, використовуйте формат кортежу (хост, порт) для "
"аргументу *mailhost*. Якщо ви використовуєте рядок, використовується "
"стандартний порт SMTP. Якщо ваш сервер SMTP вимагає автентифікації, ви "
"можете вказати кортеж (ім’я користувача, пароль) для аргументу *облікові "
"дані*."

#: ../../library/logging.handlers.rst:864
msgid ""
"To specify the use of a secure protocol (TLS), pass in a tuple to the "
"*secure* argument. This will only be used when authentication credentials "
"are supplied. The tuple should be either an empty tuple, or a single-value "
"tuple with the name of a keyfile, or a 2-value tuple with the names of the "
"keyfile and certificate file. (This tuple is passed to the :meth:`smtplib."
"SMTP.starttls` method.)"
msgstr ""
"Щоб указати використання безпечного протоколу (TLS), передайте кортеж "
"аргументу *secure*. Це використовуватиметься, лише якщо надано облікові дані "
"для автентифікації. Кортеж має бути або порожнім кортежем, або кортежем з "
"одним значенням з іменем файлу ключів, або кортежем із двома значеннями з "
"іменами файлу ключів і файлу сертифіката. (Цей кортеж передається в метод :"
"meth:`smtplib.SMTP.starttls`.)"

#: ../../library/logging.handlers.rst:871
msgid ""
"A timeout can be specified for communication with the SMTP server using the "
"*timeout* argument."
msgstr ""
"Тайм-аут можна вказати для зв’язку з сервером SMTP за допомогою аргументу "
"*timeout*."

#: ../../library/logging.handlers.rst:874
msgid "Added the *timeout* parameter."
msgstr "Добавлен параметр *timeout*."

#: ../../library/logging.handlers.rst:879
msgid "Formats the record and sends it to the specified addressees."
msgstr "Форматує запис і надсилає його вказаним адресатам."

#: ../../library/logging.handlers.rst:884
msgid ""
"If you want to specify a subject line which is record-dependent, override "
"this method."
msgstr ""
"Якщо ви хочете вказати рядок теми, який залежить від запису, замініть цей "
"метод."

#: ../../library/logging.handlers.rst:890
msgid "MemoryHandler"
msgstr "MemoryHandler"

#: ../../library/logging.handlers.rst:892
msgid ""
"The :class:`MemoryHandler` class, located in the :mod:`logging.handlers` "
"module, supports buffering of logging records in memory, periodically "
"flushing them to a :dfn:`target` handler. Flushing occurs whenever the "
"buffer is full, or when an event of a certain severity or greater is seen."
msgstr ""
"Клас :class:`MemoryHandler`, розташований у модулі :mod:`logging.handlers`, "
"підтримує буферизацію записів журналу в пам’яті, періодично скидаючи їх до "
"обробника :dfn:`target`. Очищення відбувається кожного разу, коли буфер "
"заповнений або коли спостерігається подія певної або більшої серйозності."

#: ../../library/logging.handlers.rst:897
msgid ""
":class:`MemoryHandler` is a subclass of the more general :class:"
"`BufferingHandler`, which is an abstract class. This buffers logging records "
"in memory. Whenever each record is added to the buffer, a check is made by "
"calling :meth:`shouldFlush` to see if the buffer should be flushed.  If it "
"should, then :meth:`flush` is expected to do the flushing."
msgstr ""
":class:`MemoryHandler` є підкласом більш загального :class:"
"`BufferingHandler`, який є абстрактним класом. Це буферизує записи журналу в "
"пам'яті. Кожного разу, коли кожен запис додається до буфера, виконується "
"перевірка шляхом виклику :meth:`shouldFlush`, щоб побачити, чи потрібно "
"скидати буфер. Якщо має бути, то очікується, що :meth:`flush` виконає "
"змивання."

#: ../../library/logging.handlers.rst:906
msgid ""
"Initializes the handler with a buffer of the specified capacity. Here, "
"*capacity* means the number of logging records buffered."
msgstr ""
"Ініціалізує обробник буфером зазначеної ємності. Тут *ємність* означає "
"кількість буферизованих записів журналу."

#: ../../library/logging.handlers.rst:912
msgid ""
"Append the record to the buffer. If :meth:`shouldFlush` returns true, call :"
"meth:`flush` to process the buffer."
msgstr ""
"Додайте запис до буфера. Якщо :meth:`shouldFlush` повертає true, викликайте :"
"meth:`flush` для обробки буфера."

#: ../../library/logging.handlers.rst:918
msgid ""
"For a :class:`BufferingHandler` instance, flushing means that it sets the "
"buffer to an empty list. This method can be overwritten to implement more "
"useful flushing behavior."
msgstr ""
"Для экземпляра :class:`BufferingHandler` очистка означает, что буфер "
"устанавливается в пустой список. Этот метод можно перезаписать, чтобы "
"реализовать более полезное поведение очистки."

#: ../../library/logging.handlers.rst:925
msgid ""
"Return ``True`` if the buffer is up to capacity. This method can be "
"overridden to implement custom flushing strategies."
msgstr ""
"Повертає ``True``, якщо буфер вичерпано. Цей метод можна замінити, щоб "
"реалізувати власні стратегії очищення."

#: ../../library/logging.handlers.rst:931
msgid ""
"Returns a new instance of the :class:`MemoryHandler` class. The instance is "
"initialized with a buffer size of *capacity* (number of records buffered). "
"If *flushLevel* is not specified, :const:`ERROR` is used. If no *target* is "
"specified, the target will need to be set using :meth:`setTarget` before "
"this handler does anything useful. If *flushOnClose* is specified as "
"``False``, then the buffer is *not* flushed when the handler is closed. If "
"not specified or specified as ``True``, the previous behaviour of flushing "
"the buffer will occur when the handler is closed."
msgstr ""
"Повертає новий екземпляр класу :class:`MemoryHandler`. Екземпляр "
"ініціалізується з розміром буфера *ємність* (кількість буферизованих "
"записів). Якщо *flushLevel* не вказано, використовується :const:`ERROR`. "
"Якщо *ціль* не вказана, ціль потрібно буде встановити за допомогою :meth:"
"`setTarget`, перш ніж цей обробник зробить щось корисне. Якщо *flushOnClose* "
"вказано як ``False``, тоді буфер *не* очищається, коли обробник закрито. "
"Якщо не вказано або вказано як ``True``, попередня поведінка очищення буфера "
"відбуватиметься, коли обробник буде закрито."

#: ../../library/logging.handlers.rst:940
msgid "The *flushOnClose* parameter was added."
msgstr "Додано параметр *flushOnClose*."

#: ../../library/logging.handlers.rst:946
msgid "Calls :meth:`flush`, sets the target to ``None`` and clears the buffer."
msgstr "Викликає :meth:`flush`, встановлює ціль на ``None`` і очищає буфер."

#: ../../library/logging.handlers.rst:952
msgid ""
"For a :class:`MemoryHandler` instance, flushing means just sending the "
"buffered records to the target, if there is one. The buffer is also cleared "
"when buffered records are sent to the target. Override if you want different "
"behavior."
msgstr ""
"Для экземпляра :class:`MemoryHandler` очистка означает просто отправку "
"буферизованных записей в цель, если таковая имеется. Буфер также очищается, "
"когда буферизованные записи отправляются в цель. Переопределите, если хотите "
"другое поведение."

#: ../../library/logging.handlers.rst:959
msgid "Sets the target handler for this handler."
msgstr "Встановлює цільовий обробник для цього обробника."

#: ../../library/logging.handlers.rst:964
msgid "Checks for buffer full or a record at the *flushLevel* or higher."
msgstr "Перевіряє заповненість буфера або запис на *flushLevel* або вище."

#: ../../library/logging.handlers.rst:970
msgid "HTTPHandler"
msgstr "HTTPHandler"

#: ../../library/logging.handlers.rst:972
msgid ""
"The :class:`HTTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a web server, using either "
"``GET`` or ``POST`` semantics."
msgstr ""
"Клас :class:`HTTPHandler`, розташований у модулі :mod:`logging.handlers`, "
"підтримує надсилання повідомлень журналу на веб-сервер, використовуючи "
"семантику ``GET`` або ``POST``."

#: ../../library/logging.handlers.rst:979
msgid ""
"Returns a new instance of the :class:`HTTPHandler` class. The *host* can be "
"of the form ``host:port``, should you need to use a specific port number.  "
"If no *method* is specified, ``GET`` is used. If *secure* is true, a HTTPS "
"connection will be used. The *context* parameter may be set to a :class:`ssl."
"SSLContext` instance to configure the SSL settings used for the HTTPS "
"connection. If *credentials* is specified, it should be a 2-tuple consisting "
"of userid and password, which will be placed in a HTTP 'Authorization' "
"header using Basic authentication. If you specify credentials, you should "
"also specify secure=True so that your userid and password are not passed in "
"cleartext across the wire."
msgstr ""
"Повертає новий екземпляр класу :class:`HTTPHandler`. *Host* може мати форму "
"``host:port``, якщо вам потрібно використовувати певний номер порту. Якщо "
"*метод* не вказано, використовується ``GET``. Якщо *secure* має значення "
"true, використовуватиметься з’єднання HTTPS. Параметр *context* може бути "
"встановлений на екземпляр :class:`ssl.SSLContext`, щоб налаштувати параметри "
"SSL, які використовуються для з’єднання HTTPS. Якщо вказано *облікові дані*, "
"це має бути 2-кортеж, що складається з ідентифікатора користувача та пароля, "
"який буде розміщено в заголовку HTTP \"Авторизація\" за допомогою базової "
"автентифікації. Якщо ви вказуєте облікові дані, ви також повинні вказати "
"secure=True, щоб ваш ідентифікатор користувача та пароль не передавалися у "
"вигляді відкритого тексту по мережі."

#: ../../library/logging.handlers.rst:990
msgid "The *context* parameter was added."
msgstr "Додано параметр *context*."

#: ../../library/logging.handlers.rst:995
msgid ""
"Provides a dictionary, based on ``record``, which is to be URL-encoded and "
"sent to the web server. The default implementation just returns ``record."
"__dict__``. This method can be overridden if e.g. only a subset of :class:"
"`~logging.LogRecord` is to be sent to the web server, or if more specific "
"customization of what's sent to the server is required."
msgstr ""
"Надає словник на основі ``запису``, який має бути закодований URL-адресою та "
"надісланий на веб-сервер. Стандартна реалізація просто повертає ``record."
"__dict__``. Цей метод можна перевизначити, якщо, наприклад, лише підмножина :"
"class:`~logging.LogRecord` має бути надіслана на веб-сервер, або якщо "
"потрібна більш точна настройка того, що надсилається на сервер."

#: ../../library/logging.handlers.rst:1003
msgid ""
"Sends the record to the web server as a URL-encoded dictionary. The :meth:"
"`mapLogRecord` method is used to convert the record to the dictionary to be "
"sent."
msgstr ""
"Надсилає запис на веб-сервер як словник із кодуванням URL-адреси. Метод :"
"meth:`mapLogRecord` використовується для перетворення запису в словник для "
"надсилання."

#: ../../library/logging.handlers.rst:1007
msgid ""
"Since preparing a record for sending it to a web server is not the same as a "
"generic formatting operation, using :meth:`~logging.Handler.setFormatter` to "
"specify a :class:`~logging.Formatter` for a :class:`HTTPHandler` has no "
"effect. Instead of calling :meth:`~logging.Handler.format`, this handler "
"calls :meth:`mapLogRecord` and then :func:`urllib.parse.urlencode` to encode "
"the dictionary in a form suitable for sending to a web server."
msgstr ""
"Оскільки підготовка запису для надсилання його на веб-сервер – це не те "
"саме, що загальна операція форматування, використання :meth:`~logging."
"Handler.setFormatter` для визначення :class:`~logging.Formatter` для :class:"
"`HTTPHandler` не має ефекту. Замість виклику :meth:`~logging.Handler."
"format`, цей обробник викликає :meth:`mapLogRecord`, а потім :func:`urllib."
"parse.urlencode`, щоб закодувати словник у формі, придатній для надсилання "
"на веб-сервер ."

#: ../../library/logging.handlers.rst:1020
msgid "QueueHandler"
msgstr "QueueHandler"

#: ../../library/logging.handlers.rst:1024
msgid ""
"The :class:`QueueHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules."
msgstr ""
"Клас :class:`QueueHandler`, розташований у модулі :mod:`logging.handlers`, "
"підтримує надсилання повідомлень журналу до черги, таких як реалізовані в "
"модулях :mod:`queue` або :mod:`multiprocessing` ."

#: ../../library/logging.handlers.rst:1028
msgid ""
"Along with the :class:`QueueListener` class, :class:`QueueHandler` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""
"Разом із класом :class:`QueueListener`, :class:`QueueHandler` можна "
"використовувати, щоб дозволити обробникам виконувати свою роботу в окремому "
"потоці від того, який веде журнал. Це важливо у веб-додатках, а також в "
"інших додатках-службах, де потоки, що обслуговують клієнтів, мають "
"відповідати якомога швидше, тоді як будь-які потенційно повільні операції "
"(такі як надсилання електронного листа через :class:`SMTPHandler`) "
"виконуються в окремому потоці."

#: ../../library/logging.handlers.rst:1037
msgid ""
"Returns a new instance of the :class:`QueueHandler` class. The instance is "
"initialized with the queue to send messages to. The *queue* can be any queue-"
"like object; it's used as-is by the :meth:`enqueue` method, which needs to "
"know how to send messages to it. The queue is not *required* to have the "
"task tracking API, which means that you can use :class:`~queue.SimpleQueue` "
"instances for *queue*."
msgstr ""
"Повертає новий екземпляр класу :class:`QueueHandler`. Примірник "
"ініціалізується чергою для надсилання повідомлень. *Чергою* може бути будь-"
"який об’єкт, подібний до черги; він використовується як є методом :meth:"
"`enqueue`, якому потрібно знати, як йому надсилати повідомлення. Для черги "
"не *обов’язково* бути API відстеження завдань, що означає, що ви можете "
"використовувати екземпляри :class:`~queue.SimpleQueue` для *черги*."

#: ../../library/logging.handlers.rst:1044
#: ../../library/logging.handlers.rst:1127
msgid ""
"If you are using :mod:`multiprocessing`, you should avoid using :class:"
"`~queue.SimpleQueue` and instead use :class:`multiprocessing.Queue`."
msgstr ""
"Если вы используете :mod:`multiprocessing`, вам следует избегать "
"использования :class:`~queue.SimpleQueue` и вместо этого использовать :class:"
"`multiprocessing.Queue`."

#: ../../library/logging.handlers.rst:1049
msgid ""
"Enqueues the result of preparing the LogRecord. Should an exception occur (e."
"g. because a bounded queue has filled up), the :meth:`~logging.Handler."
"handleError` method is called to handle the error. This can result in the "
"record silently being dropped (if :data:`logging.raiseExceptions` is "
"``False``) or a message printed to ``sys.stderr`` (if :data:`logging."
"raiseExceptions` is ``True``)."
msgstr ""
"Ставит в очередь результат подготовки LogRecord. В случае возникновения "
"исключения (например, из-за заполнения ограниченной очереди) для обработки "
"ошибки вызывается метод :meth:`~logging.Handler.handleError`. Это может "
"привести к молчаливому удалению записи (если :data:`logging.raiseExceptions` "
"имеет значение ``False``) или к выводу сообщения в ``sys.stderr`` (если :"
"data:`logging.raiseExceptions`` имеет значение `` «Правда»)."

#: ../../library/logging.handlers.rst:1058
msgid ""
"Prepares a record for queuing. The object returned by this method is "
"enqueued."
msgstr ""
"Готує запис для постановки в чергу. Об’єкт, повернутий цим методом, "
"ставиться в чергу."

#: ../../library/logging.handlers.rst:1061
msgid ""
"The base implementation formats the record to merge the message, arguments, "
"exception and stack information, if present.  It also removes unpickleable "
"items from the record in-place. Specifically, it overwrites the record's :"
"attr:`msg` and :attr:`message` attributes with the merged message (obtained "
"by calling the handler's :meth:`format` method), and sets the :attr:`args`, :"
"attr:`exc_info` and :attr:`exc_text` attributes to ``None``."
msgstr ""
"Базовая реализация форматирует запись для объединения сообщения, аргументов, "
"исключений и информации стека, если они есть. Он также удаляет неподдающиеся "
"редактированию элементы из записи на месте. В частности, он перезаписывает "
"атрибуты записи :attr:`msg` и :attr:`message` объединенным сообщением "
"(полученным путем вызова метода :meth:`format` обработчика) и устанавливает :"
"attr:`args`, : Для атрибутов attr:`exc_info` и :attr:`exc_text` установлено "
"значение ``None``."

#: ../../library/logging.handlers.rst:1069
msgid ""
"You might want to override this method if you want to convert the record to "
"a dict or JSON string, or send a modified copy of the record while leaving "
"the original intact."
msgstr ""
"Ви можете замінити цей метод, якщо хочете перетворити запис на рядок dict "
"або JSON або надіслати змінену копію запису, залишивши оригінал недоторканим."

#: ../../library/logging.handlers.rst:1073
msgid ""
"The base implementation formats the message with arguments, sets the "
"``message`` and ``msg`` attributes to the formatted message and sets the "
"``args`` and ``exc_text`` attributes to ``None`` to allow pickling and to "
"prevent further attempts at formatting. This means that a handler on the :"
"class:`QueueListener` side won't have the information to do custom "
"formatting, e.g. of exceptions. You may wish to subclass ``QueueHandler`` "
"and override this method to e.g. avoid setting ``exc_text`` to ``None``. "
"Note that the ``message`` / ``msg`` / ``args`` changes are related to "
"ensuring the record is pickleable, and you might or might not be able to "
"avoid doing that depending on whether your ``args`` are pickleable. (Note "
"that you may have to consider not only your own code but also code in any "
"libraries that you use.)"
msgstr ""
"Базовая реализация форматирует сообщение с аргументами, устанавливает "
"атрибуты ``message`` и ``msg`` для отформатированного сообщения и "
"устанавливает атрибуты ``args`` и ``exc_text`` в ``None``, чтобы разрешить "
"травление и предотвращение дальнейших попыток форматирования. Это означает, "
"что обработчик на стороне :class:`QueueListener` не будет иметь информации "
"для выполнения пользовательского форматирования, например, исключений. Вы "
"можете создать подкласс QueueHandler и переопределить этот метод, чтобы, "
"например, не устанавливать для exc_text значение None. Обратите внимание, "
"что изменения ``message``/``msg``/``args`` связаны с обеспечением "
"возможности выбора записи, и вы можете или не можете избежать этого в "
"зависимости от того, есть ли у вас ``args` ` можно мариновать. (Обратите "
"внимание, что вам, возможно, придется учитывать не только свой собственный "
"код, но и код любых библиотек, которые вы используете.)"

#: ../../library/logging.handlers.rst:1089
msgid ""
"Enqueues the record on the queue using ``put_nowait()``; you may want to "
"override this if you want to use blocking behaviour, or a timeout, or a "
"customized queue implementation."
msgstr ""
"Ставить запис у чергу за допомогою put_nowait(); ви можете змінити це, якщо "
"ви хочете використовувати поведінку блокування, або тайм-аут, або "
"налаштовану реалізацію черги."

#: ../../library/logging.handlers.rst:1098
msgid "QueueListener"
msgstr "QueueListener"

#: ../../library/logging.handlers.rst:1102
msgid ""
"The :class:`QueueListener` class, located in the :mod:`logging.handlers` "
"module, supports receiving logging messages from a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules. The "
"messages are received from a queue in an internal thread and passed, on the "
"same thread, to one or more handlers for processing. While :class:"
"`QueueListener` is not itself a handler, it is documented here because it "
"works hand-in-hand with :class:`QueueHandler`."
msgstr ""
"Клас :class:`QueueListener`, розташований у модулі :mod:`logging.handlers`, "
"підтримує отримання повідомлень журналу з черги, таких як ті, що реалізовані "
"в модулях :mod:`queue` або :mod:`multiprocessing` . Повідомлення отримуються "
"з черги у внутрішньому потоці та передаються в тому самому потоці одному або "
"кільком обробникам для обробки. Хоча :class:`QueueListener` сам по собі не є "
"обробником, він задокументований тут, оскільки він працює рука об руку з :"
"class:`QueueHandler`."

#: ../../library/logging.handlers.rst:1110
msgid ""
"Along with the :class:`QueueHandler` class, :class:`QueueListener` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""
"Разом із класом :class:`QueueHandler`, :class:`QueueListener` можна "
"використовувати, щоб дозволити обробникам виконувати свою роботу в окремому "
"потоці від того, який веде журнал. Це важливо у веб-додатках, а також в "
"інших додатках-службах, де потоки, що обслуговують клієнтів, мають "
"відповідати якомога швидше, тоді як будь-які потенційно повільні операції "
"(такі як надсилання електронного листа через :class:`SMTPHandler`) "
"виконуються в окремому потоці."

#: ../../library/logging.handlers.rst:1119
msgid ""
"Returns a new instance of the :class:`QueueListener` class. The instance is "
"initialized with the queue to send messages to and a list of handlers which "
"will handle entries placed on the queue. The queue can be any queue-like "
"object; it's passed as-is to the :meth:`dequeue` method, which needs to know "
"how to get messages from it. The queue is not *required* to have the task "
"tracking API (though it's used if available), which means that you can use :"
"class:`~queue.SimpleQueue` instances for *queue*."
msgstr ""
"Повертає новий екземпляр класу :class:`QueueListener`. Екземпляр "
"ініціалізується чергою для надсилання повідомлень і списком обробників, які "
"оброблятимуть записи, розміщені в черзі. Чергою може бути будь-який "
"чергоподібний об'єкт; він передається як є до методу :meth:`dequeue`, якому "
"потрібно знати, як отримати від нього повідомлення. Для черги не "
"*обов’язково* бути API відстеження завдань (хоча він використовується, якщо "
"доступний), що означає, що ви можете використовувати екземпляри :class:"
"`~queue.SimpleQueue` для *черги*."

#: ../../library/logging.handlers.rst:1130
msgid ""
"If ``respect_handler_level`` is ``True``, a handler's level is respected "
"(compared with the level for the message) when deciding whether to pass "
"messages to that handler; otherwise, the behaviour is as in previous Python "
"versions - to always pass each message to each handler."
msgstr ""
"Якщо ``respect_handler_level`` має значення ``True``, рівень обробника "
"враховується (порівняно з рівнем для повідомлення), коли вирішується, чи "
"передавати повідомлення цьому обробнику; інакше, поведінка така ж, як і в "
"попередніх версіях Python - завжди передавати кожне повідомлення кожному "
"обробнику."

#: ../../library/logging.handlers.rst:1135
msgid "The ``respect_handler_level`` argument was added."
msgstr "Додано аргумент ``respect_handler_level``."

#: ../../library/logging.handlers.rst:1140
msgid "Dequeues a record and return it, optionally blocking."
msgstr "Вилучає запис із черги та повертає його, за бажанням блокуючи."

#: ../../library/logging.handlers.rst:1142
msgid ""
"The base implementation uses ``get()``. You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""
"У базовій реалізації використовується ``get()``. Ви можете перевизначити цей "
"метод, якщо ви хочете використовувати тайм-аути або працювати з власними "
"реалізаціями черги."

#: ../../library/logging.handlers.rst:1148
msgid "Prepare a record for handling."
msgstr "Підготуйте протокол для обробки."

#: ../../library/logging.handlers.rst:1150
msgid ""
"This implementation just returns the passed-in record. You may want to "
"override this method if you need to do any custom marshalling or "
"manipulation of the record before passing it to the handlers."
msgstr ""
"Ця реалізація лише повертає переданий запис. Ви можете замінити цей метод, "
"якщо вам потрібно виконати будь-яку спеціальну сортування або маніпуляції із "
"записом перед передачею його обробникам."

#: ../../library/logging.handlers.rst:1156
msgid "Handle a record."
msgstr "Обробка запису."

#: ../../library/logging.handlers.rst:1158
msgid ""
"This just loops through the handlers offering them the record to handle. The "
"actual object passed to the handlers is that which is returned from :meth:"
"`prepare`."
msgstr ""
"Це просто проходить через обробники, пропонуючи їм запис для обробки. "
"Фактичний об’єкт, який передається обробникам, — це той, який повертається "
"з :meth:`prepare`."

#: ../../library/logging.handlers.rst:1164
msgid "Starts the listener."
msgstr "Memulai *listener*."

#: ../../library/logging.handlers.rst:1166
msgid ""
"This starts up a background thread to monitor the queue for LogRecords to "
"process."
msgstr ""
"Це запускає фоновий потік для моніторингу черги для обробки LogRecords."

#: ../../library/logging.handlers.rst:1171
msgid "Stops the listener."
msgstr "Menghentikan *listener*."

#: ../../library/logging.handlers.rst:1173
msgid ""
"This asks the thread to terminate, and then waits for it to do so. Note that "
"if you don't call this before your application exits, there may be some "
"records still left on the queue, which won't be processed."
msgstr ""
"Це просить потік завершити, а потім чекає, поки він це зробить. Зауважте, що "
"якщо ви не викличете це перед виходом програми, у черзі можуть залишитися "
"деякі записи, які не будуть оброблені."

#: ../../library/logging.handlers.rst:1179
msgid ""
"Writes a sentinel to the queue to tell the listener to quit. This "
"implementation uses ``put_nowait()``.  You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""
"Записує до черги дозорний, щоб сказати слухачеві вийти. Ця реалізація "
"використовує ``put_nowait()``. Ви можете перевизначити цей метод, якщо "
"хочете використовувати тайм-аути або працювати з власними реалізаціями черги."

#: ../../library/logging.handlers.rst:1190
msgid "Module :mod:`logging`"
msgstr "Módulo :mod:`logging`"

#: ../../library/logging.handlers.rst:1190
msgid "API reference for the logging module."
msgstr "Referência da API para o módulo de logging."

#: ../../library/logging.handlers.rst:1192
msgid "Module :mod:`logging.config`"
msgstr "Módulo :mod:`logging.config`"

#: ../../library/logging.handlers.rst:1193
msgid "Configuration API for the logging module."
msgstr "API de configuração para o módulo logging."

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/random.rst:2
msgid ":mod:`!random` --- Generate pseudo-random numbers"
msgstr ":mod:`!random` --- Gera números pseudoaleatórios"

#: ../../library/random.rst:7
msgid "**Source code:** :source:`Lib/random.py`"
msgstr "**Código-fonte:** :source:`Lib/random.py`"

#: ../../library/random.rst:11
msgid ""
"This module implements pseudo-random number generators for various "
"distributions."
msgstr ""
"Este módulo implementa geradores de números pseudoaleatórios para várias "
"distribuições."

#: ../../library/random.rst:14
msgid ""
"For integers, there is uniform selection from a range. For sequences, there "
"is uniform selection of a random element, a function to generate a random "
"permutation of a list in-place, and a function for random sampling without "
"replacement."
msgstr ""
"Para números inteiros, há uma seleção uniforme de um intervalo. Para "
"sequências, há uma seleção uniforme de um elemento aleatório, uma função "
"para gerar uma permutação aleatória de uma lista internamanete e uma função "
"para amostragem aleatória sem substituição."

#: ../../library/random.rst:19
msgid ""
"On the real line, there are functions to compute uniform, normal (Gaussian), "
"lognormal, negative exponential, gamma, and beta distributions. For "
"generating distributions of angles, the von Mises distribution is available."
msgstr ""
"Na linha real, existem funções para calcular distribuições uniforme, normal "
"(gaussiana), log-normal, exponencial negativa, gama e beta. Para gerar "
"distribuições de ângulos, a distribuição de von Mises está disponível."

#: ../../library/random.rst:23
msgid ""
"Almost all module functions depend on the basic function :func:`.random`, "
"which generates a random float uniformly in the half-open range ``0.0 <= X < "
"1.0``. Python uses the Mersenne Twister as the core generator.  It produces "
"53-bit precision floats and has a period of 2\\*\\*19937-1.  The underlying "
"implementation in C is both fast and threadsafe.  The Mersenne Twister is "
"one of the most extensively tested random number generators in existence.  "
"However, being completely deterministic, it is not suitable for all "
"purposes, and is completely unsuitable for cryptographic purposes."
msgstr ""
"Quase todas as funções do módulo dependem da função básica :func:`.random`, "
"que gera um ponto flutuante aleatório uniformemente no intervalo semiaberto "
"``0.0 <= X < 1.0``. Python usa o Mersenne Twister como gerador de núcleo. "
"Produz pontos flutuantes de precisão de 53 bits e possui um período de "
"2\\*\\*19937-1. A implementação subjacente em C é rápida e segura para "
"threads. O Mersenne Twister é um dos geradores de números aleatórios mais "
"amplamente testados existentes. No entanto, sendo completamente "
"determinístico, não é adequado para todos os fins e é totalmente inadequado "
"para fins criptográficos."

#: ../../library/random.rst:32
msgid ""
"The functions supplied by this module are actually bound methods of a hidden "
"instance of the :class:`random.Random` class.  You can instantiate your own "
"instances of :class:`Random` to get generators that don't share state."
msgstr ""
"As funções fornecidas por este módulo são, na verdade, métodos vinculados de "
"uma instância oculta da classe :class:`random.Random`. Você pode instanciar "
"suas próprias instâncias de :class:`Random` para obter geradores que não "
"compartilham estado."

#: ../../library/random.rst:36
msgid ""
"Class :class:`Random` can also be subclassed if you want to use a different "
"basic generator of your own devising: see the documentation on that class "
"for more details."
msgstr ""
"A classe :class:`Random` também pode ser subclassificada se você quiser usar "
"um gerador básico diferente de sua própria criação: veja a documentação "
"dessa classe para mais detalhes."

#: ../../library/random.rst:40
msgid ""
"The :mod:`random` module also provides the :class:`SystemRandom` class which "
"uses the system function :func:`os.urandom` to generate random numbers from "
"sources provided by the operating system."
msgstr ""
"O módulo :mod:`random` também fornece a classe :class:`SystemRandom` que usa "
"a função do sistema :func:`os.urandom` para gerar números aleatórios a "
"partir de fontes fornecidas pelo sistema operacional."

#: ../../library/random.rst:46
msgid ""
"The pseudo-random generators of this module should not be used for security "
"purposes.  For security or cryptographic uses, see the :mod:`secrets` module."
msgstr ""
"Os geradores pseudoaleatórios deste módulo não devem ser usados para fins de "
"segurança. Para segurança ou uso criptográfico, veja o módulo :mod:`secrets`."

#: ../../library/random.rst:52
msgid ""
"M. Matsumoto and T. Nishimura, \"Mersenne Twister: A 623-dimensionally "
"equidistributed uniform pseudorandom number generator\", ACM Transactions on "
"Modeling and Computer Simulation Vol. 8, No. 1, January pp.3--30 1998."
msgstr ""
"M. Matsumoto and T. Nishimura, \"Mersenne Twister: A 623-dimensionally "
"equidistributed uniform pseudorandom number generator\", ACM Transactions on "
"Modeling and Computer Simulation Vol. 8, No. 1, January pp.3--30 1998."

#: ../../library/random.rst:57
msgid ""
"`Complementary-Multiply-with-Carry recipe <https://code.activestate.com/"
"recipes/576707-long-period-random-number-generator/>`_ for a compatible "
"alternative random number generator with a long period and comparatively "
"simple update operations."
msgstr ""
"`Receita de Complementary-Multiply-with-Carry <https://code.activestate.com/"
"recipes/576707-long-period-random-number-generator/>`_ para um gerador de "
"números aleatórios alternativo compatível com um longo período e operações "
"de atualização comparativamente simples."

#: ../../library/random.rst:63
msgid ""
"The global random number generator and instances of :class:`Random` are "
"thread-safe. However, in the free-threaded build, concurrent calls to the "
"global generator or to the same instance of :class:`Random` may encounter "
"contention and poor performance. Consider using separate instances of :class:"
"`Random` per thread instead."
msgstr ""
"O gerador global de números aleatórios e as instâncias de :class:`Random` "
"são seguros para thread. No entanto, na construção com threads livres, "
"chamadas simultâneas ao gerador global ou à mesma instância de :class:"
"`Random` podem encontrar contenção e baixo desempenho. Considere usar "
"instâncias separadas de :class:`Random` por thread."

#: ../../library/random.rst:70
msgid "Bookkeeping functions"
msgstr "Funções de contabilidade"

#: ../../library/random.rst:74
msgid "Initialize the random number generator."
msgstr "Inicializa o gerador de números aleatórios."

#: ../../library/random.rst:76
msgid ""
"If *a* is omitted or ``None``, the current system time is used.  If "
"randomness sources are provided by the operating system, they are used "
"instead of the system time (see the :func:`os.urandom` function for details "
"on availability)."
msgstr ""
"Se *a* for omitido ou ``None``, a hora atual do sistema será usada. Se "
"fontes de aleatoriedade são fornecidas pelo sistema operacional, elas são "
"usadas no lugar da hora do sistema (consulte a função :func:`os.urandom` "
"para detalhes sobre disponibilidade)."

#: ../../library/random.rst:81
msgid "If *a* is an int, it is used directly."
msgstr "Se *a* é um int, ele é usado diretamente."

#: ../../library/random.rst:83
msgid ""
"With version 2 (the default), a :class:`str`, :class:`bytes`, or :class:"
"`bytearray` object gets converted to an :class:`int` and all of its bits are "
"used."
msgstr ""
"Com a versão 2 (o padrão), o objeto a :class:`str`, :class:`bytes` ou :class:"
"`bytearray` é convertido em um objeto :class:`int` e todos os seus bits são "
"usados."

#: ../../library/random.rst:86
msgid ""
"With version 1 (provided for reproducing random sequences from older "
"versions of Python), the algorithm for :class:`str` and :class:`bytes` "
"generates a narrower range of seeds."
msgstr ""
"Com a versão 1 (fornecida para reproduzir sequências aleatórias de versões "
"mais antigas do Python), o algoritmo para :class:`str` e :class:`bytes` gera "
"um intervalo mais restrito de sementes."

#: ../../library/random.rst:90
msgid ""
"Moved to the version 2 scheme which uses all of the bits in a string seed."
msgstr ""
"Movido para o esquema da versão 2, que usa todos os bits em uma semente de "
"strings."

#: ../../library/random.rst:93
msgid ""
"The *seed* must be one of the following types: ``None``, :class:`int`, :"
"class:`float`, :class:`str`, :class:`bytes`, or :class:`bytearray`."
msgstr ""
"*seed* deve ser um dos seguintes tipos: ``None``, :class:`int`, :class:"
"`float`, :class:`str`, :class:`bytes` ou :class:`bytearray`."

#: ../../library/random.rst:100
msgid ""
"Return an object capturing the current internal state of the generator.  "
"This object can be passed to :func:`setstate` to restore the state."
msgstr ""
"Retorna um objeto capturando o estado interno atual do gerador. Este objeto "
"pode ser passado para :func:`setstate` para restaurar o estado."

#: ../../library/random.rst:106
msgid ""
"*state* should have been obtained from a previous call to :func:`getstate`, "
"and :func:`setstate` restores the internal state of the generator to what it "
"was at the time :func:`getstate` was called."
msgstr ""
"*state* deveria ter sido obtido de uma chamada anterior para :func:"
"`getstate`, e :func:`setstate` restaura o estado interno do gerador para o "
"que era no momento que :func:`getstate` foi chamado."

#: ../../library/random.rst:112
msgid "Functions for bytes"
msgstr "Funções para bytes"

#: ../../library/random.rst:116
msgid "Generate *n* random bytes."
msgstr "Gera *n* bytes aleatórios."

#: ../../library/random.rst:118
msgid ""
"This method should not be used for generating security tokens. Use :func:"
"`secrets.token_bytes` instead."
msgstr ""
"Este método não deve ser usado para gerar tokens de segurança. Use :func:"
"`secrets.token_bytes`."

#: ../../library/random.rst:125
msgid "Functions for integers"
msgstr "Funções para inteiros"

#: ../../library/random.rst:130
msgid "Return a randomly selected element from ``range(start, stop, step)``."
msgstr ""
"Retorna um elemento selecionado aleatoriamente de ``range(start, stop, "
"step)``."

#: ../../library/random.rst:132
msgid ""
"This is roughly equivalent to ``choice(range(start, stop, step))`` but "
"supports arbitrarily large ranges and is optimized for common cases."
msgstr ""
"Isso é aproximadamente equivalente a ``choice(range(start, stop, step))`` "
"mas provê suporte a intervalos arbitrariamente grandes e é otimizado para "
"casos comuns."

#: ../../library/random.rst:135
msgid "The positional argument pattern matches the :func:`range` function."
msgstr "O padrão de argumento posicional corresponde à função :func:`range`."

#: ../../library/random.rst:137
msgid ""
"Keyword arguments should not be used because they can be interpreted in "
"unexpected ways. For example ``randrange(start=100)`` is interpreted as "
"``randrange(0, 100, 1)``."
msgstr ""
"Argumentos nomeados não devem ser usados porque podem ser interpretados de "
"maneiras inesperadas. Por exemplo ``randrange(start=100)`` é interpretado "
"como ``randrange(0, 100, 1)``."

#: ../../library/random.rst:141
msgid ""
":meth:`randrange` is more sophisticated about producing equally distributed "
"values.  Formerly it used a style like ``int(random()*n)`` which could "
"produce slightly uneven distributions."
msgstr ""
":meth:`randrange` é mais sofisticado em produzir valores igualmente "
"distribuídos. Anteriormente, usava um estilo como ``int(random()*n)``, que "
"poderia produzir distribuições ligeiramente desiguais."

#: ../../library/random.rst:146
msgid ""
"Automatic conversion of non-integer types is no longer supported. Calls such "
"as ``randrange(10.0)`` and ``randrange(Fraction(10, 1))`` now raise a :exc:"
"`TypeError`."
msgstr ""
"A conversão automática de tipos não inteiros não é mais suportada. Chamadas "
"como ``randrange(10.0)`` e ``randrange(Fraction(10, 1))`` agora levantam "
"uma :exc:`TypeError`."

#: ../../library/random.rst:153
msgid ""
"Return a random integer *N* such that ``a <= N <= b``.  Alias for "
"``randrange(a, b+1)``."
msgstr ""
"Retorna um inteiro aleatório *N* de forma que ``a <= N <= b``. Apelido para "
"``randrange(a, b+1)``."

#: ../../library/random.rst:158
msgid ""
"Returns a non-negative Python integer with *k* random bits. This method is "
"supplied with the Mersenne Twister generator and some other generators may "
"also provide it as an optional part of the API. When available, :meth:"
"`getrandbits` enables :meth:`randrange` to handle arbitrarily large ranges."
msgstr ""
"Retorna um número inteiro Python não-negativo com bits aleatórios *k*. Este "
"método é fornecido com o gerador Mersenne Twister e alguns outros geradores "
"também podem fornecê-lo como uma parte opcional da API. Quando disponível, :"
"meth:`getrandbits` permite que :meth:`randrange` manipule intervalos "
"arbitrariamente grandes."

#: ../../library/random.rst:164
msgid "This method now accepts zero for *k*."
msgstr "Este método agora aceita zero em *k*."

#: ../../library/random.rst:169
msgid "Functions for sequences"
msgstr "Funções para sequências"

#: ../../library/random.rst:173
msgid ""
"Return a random element from the non-empty sequence *seq*. If *seq* is "
"empty, raises :exc:`IndexError`."
msgstr ""
"Retorna um elemento aleatório da sequência não vazia *seq*. Se *seq* estiver "
"vazio, levanta :exc:`IndexError`."

#: ../../library/random.rst:178
msgid ""
"Return a *k* sized list of elements chosen from the *population* with "
"replacement. If the *population* is empty, raises :exc:`IndexError`."
msgstr ""
"Retorna uma lista do tamanho de *k* de elementos escolhidos da *population* "
"com substituição. Se a *population* estiver vazio, levanta :exc:`IndexError`."

#: ../../library/random.rst:181
msgid ""
"If a *weights* sequence is specified, selections are made according to the "
"relative weights.  Alternatively, if a *cum_weights* sequence is given, the "
"selections are made according to the cumulative weights (perhaps computed "
"using :func:`itertools.accumulate`).  For example, the relative weights "
"``[10, 5, 30, 5]`` are equivalent to the cumulative weights ``[10, 15, 45, "
"50]``.  Internally, the relative weights are converted to cumulative weights "
"before making selections, so supplying the cumulative weights saves work."
msgstr ""
"Se uma sequência *weights* for especificada, as seleções serão feitas de "
"acordo com os pesos relativos. Alternativamente, se uma sequência "
"*cum_weights* for fornecida, as seleções serão feitas de acordo com os pesos "
"cumulativos (talvez calculados usando :func:`itertools.accumulate`). Por "
"exemplo, os pesos relativos ``[10, 5, 30, 5]`` são equivalentes aos pesos "
"cumulativos ``[10, 15, 45, 50]``. Internamente, os pesos relativos são "
"convertidos em pesos acumulados antes de fazer seleções, portanto, fornecer "
"pesos cumulativos economiza trabalho."

#: ../../library/random.rst:190
msgid ""
"If neither *weights* nor *cum_weights* are specified, selections are made "
"with equal probability.  If a weights sequence is supplied, it must be the "
"same length as the *population* sequence.  It is a :exc:`TypeError` to "
"specify both *weights* and *cum_weights*."
msgstr ""
"Se nem *weights* nem *cum_weights* forem especificados, as seleções serão "
"feitas com igual probabilidade. Se uma sequência de pesos for fornecida, ela "
"deverá ter o mesmo comprimento que a sequência *population*. É um :exc:"
"`TypeError` para especificar ambos os *weights* e *cum_weights*."

#: ../../library/random.rst:195
msgid ""
"The *weights* or *cum_weights* can use any numeric type that interoperates "
"with the :class:`float` values returned by :func:`random` (that includes "
"integers, floats, and fractions but excludes decimals).  Weights are assumed "
"to be non-negative and finite.  A :exc:`ValueError` is raised if all weights "
"are zero."
msgstr ""
"*weights* ou *cum_weights* pode usar qualquer tipo numérico que interopera "
"com os valores :class:`float` retornados por :func:`random` (que inclui "
"inteiros, pontos flutuantes, e frações mas exclui decimais). Presume-se que "
"pesos serão não-negativos e finitos. Uma :exc:`ValueError` é levantada se "
"todos os pesos forem zero."

#: ../../library/random.rst:201
msgid ""
"For a given seed, the :func:`choices` function with equal weighting "
"typically produces a different sequence than repeated calls to :func:"
"`choice`.  The algorithm used by :func:`choices` uses floating-point "
"arithmetic for internal consistency and speed.  The algorithm used by :func:"
"`choice` defaults to integer arithmetic with repeated selections to avoid "
"small biases from round-off error."
msgstr ""
"Para uma dada semente, a função :func:`choices` com igual peso normalmente "
"produz uma sequência diferente das chamadas repetidas para :func:`choice`. O "
"algoritmo usado por :func:`choice` usa aritmética de ponto flutuante para "
"consistência e velocidade internas. O algoritmo usado por :func:`choice` "
"assume como padrão aritmética inteira com seleções repetidas para evitar "
"pequenos vieses de erro de arredondamento."

#: ../../library/random.rst:210
msgid "Raises a :exc:`ValueError` if all weights are zero."
msgstr "Levanta uma :exc:`ValueError` se todos os pesos forem zero."

#: ../../library/random.rst:216
msgid "Shuffle the sequence *x* in place."
msgstr "Embaralha a sequência *x* internamente."

#: ../../library/random.rst:218
msgid ""
"To shuffle an immutable sequence and return a new shuffled list, use "
"``sample(x, k=len(x))`` instead."
msgstr ""
"Para embaralhar uma sequência imutável e retornar uma nova lista "
"embaralhada, use ``sample(x, k=len(x))``."

#: ../../library/random.rst:221
msgid ""
"Note that even for small ``len(x)``, the total number of permutations of *x* "
"can quickly grow larger than the period of most random number generators. "
"This implies that most permutations of a long sequence can never be "
"generated.  For example, a sequence of length 2080 is the largest that can "
"fit within the period of the Mersenne Twister random number generator."
msgstr ""
"Observe que, mesmo para pequenos ``len(x)``, o número total de permutações "
"de *x* pode crescer rapidamente maior que o período da maioria dos geradores "
"de números aleatórios. Isso implica que a maioria das permutações de uma "
"longa sequência nunca pode ser gerada. Por exemplo, uma sequência de "
"comprimento 2080 é a maior que pode caber no período do gerador de números "
"aleatórios Mersenne Twister."

#: ../../library/random.rst:227
msgid "Removed the optional parameter *random*."
msgstr "Removido o parâmetro opcional *random*."

#: ../../library/random.rst:233
msgid ""
"Return a *k* length list of unique elements chosen from the population "
"sequence.  Used for random sampling without replacement."
msgstr ""
"Retorna uma lista de comprimento *k* de elementos únicos escolhidos na "
"sequência populacional. Usado para amostragem aleatória sem reposição."

#: ../../library/random.rst:236
msgid ""
"Returns a new list containing elements from the population while leaving the "
"original population unchanged.  The resulting list is in selection order so "
"that all sub-slices will also be valid random samples.  This allows raffle "
"winners (the sample) to be partitioned into grand prize and second place "
"winners (the subslices)."
msgstr ""
"Retorna uma nova lista contendo elementos da população, mantendo a população "
"original inalterada. A lista resultante está na ordem de seleção, para que "
"todas as subfatias também sejam amostras aleatórias válidas. Isso permite "
"que os vencedores do sorteio (a amostra) sejam divididos em grandes prêmios "
"e vencedores de segundo lugar (as subfatias)."

#: ../../library/random.rst:242
msgid ""
"Members of the population need not be :term:`hashable` or unique.  If the "
"population contains repeats, then each occurrence is a possible selection in "
"the sample."
msgstr ""
"Os membros da população não precisam ser :term:`hasheáveis <hasheável>` ou "
"únicos. Se a população contiver repetições, cada ocorrência é uma seleção "
"possível na amostra."

#: ../../library/random.rst:245
msgid ""
"Repeated elements can be specified one at a time or with the optional "
"keyword-only *counts* parameter.  For example, ``sample(['red', 'blue'], "
"counts=[4, 2], k=5)`` is equivalent to ``sample(['red', 'red', 'red', 'red', "
"'blue', 'blue'], k=5)``."
msgstr ""
"Elementos repetidos podem ser especificados um de cada vez ou com o "
"parâmetro somente-nomeado opcional *count*. Por exemplo, ``sample(['red', "
"'blue'], counts=[4, 2], k=5)`` é equivalente a ``sample(['red', 'red', "
"'red', 'red', 'blue', 'blue'], k=5)``."

#: ../../library/random.rst:250
msgid ""
"To choose a sample from a range of integers, use a :func:`range` object as "
"an argument.  This is especially fast and space efficient for sampling from "
"a large population:  ``sample(range(10000000), k=60)``."
msgstr ""
"Para escolher uma amostra de um intervalo de números inteiros, use um "
"objeto :func:`range` como argumento. Isso é especialmente rápido e com "
"eficiência de espaço para amostragem de uma grande população: "
"``sample(range(10000000), k=60)``."

#: ../../library/random.rst:254
msgid ""
"If the sample size is larger than the population size, a :exc:`ValueError` "
"is raised."
msgstr ""
"Se o tamanho da amostra for maior que o tamanho da população, uma :exc:"
"`ValueError` é levantada."

#: ../../library/random.rst:257
msgid "Added the *counts* parameter."
msgstr "Adicionado o parâmetro *counts*."

#: ../../library/random.rst:262
msgid ""
"The *population* must be a sequence.  Automatic conversion of sets to lists "
"is no longer supported."
msgstr ""
"*population* deve ser uma sequência. A conversão automática de conjuntos em "
"listas não é mais suportada."

#: ../../library/random.rst:266
msgid "Discrete distributions"
msgstr "Distribuições discretas"

#: ../../library/random.rst:268
msgid "The following function generates a discrete distribution."
msgstr "A função a seguir gera uma distribuição discreta."

#: ../../library/random.rst:272
msgid ""
"`Binomial distribution <https://mathworld.wolfram.com/BinomialDistribution."
"html>`_. Return the number of successes for *n* independent trials with the "
"probability of success in each trial being *p*:"
msgstr ""
"`Distribuição binomial <https://mathworld.wolfram.com/BinomialDistribution."
"html>`_. Retorna o número de sucessos para *n* tentativas independentes com "
"a probabilidade de sucesso em cada tentativa sendo *p*:"

#: ../../library/random.rst:277
msgid "Mathematically equivalent to::"
msgstr "Matematicamente equivalente a::"

#: ../../library/random.rst:279
msgid "sum(random() < p for i in range(n))"
msgstr "sum(random() < p for i in range(n))"

#: ../../library/random.rst:281
msgid ""
"The number of trials *n* should be a non-negative integer. The probability "
"of success *p* should be between ``0.0 <= p <= 1.0``. The result is an "
"integer in the range ``0 <= X <= n``."
msgstr ""
"O número de tentativas *n* deve ser um número inteiro não negativo. A "
"probabilidade de sucesso *p* deve estar entre ``0.0 <= p <= 1.0``. O "
"resultado é um número inteiro no intervalo ``0 <= X <= n``."

#: ../../library/random.rst:291
msgid "Real-valued distributions"
msgstr "Distribuições com valor real"

#: ../../library/random.rst:293
msgid ""
"The following functions generate specific real-valued distributions. "
"Function parameters are named after the corresponding variables in the "
"distribution's equation, as used in common mathematical practice; most of "
"these equations can be found in any statistics text."
msgstr ""
"As funções a seguir geram distribuições específicas com valor real. Os "
"parâmetros de função são nomeados após as variáveis correspondentes na "
"equação da distribuição, conforme usadas na prática matemática comum; a "
"maioria dessas equações pode ser encontrada em qualquer texto estatístico."

#: ../../library/random.rst:301
msgid ""
"Return the next random floating-point number in the range ``0.0 <= X < 1.0``"
msgstr ""
"Retorna o próximo número aleatório de ponto flutuante no intervalo ``0.0 <= "
"X < 1.0``."

#: ../../library/random.rst:306
msgid ""
"Return a random floating-point number *N* such that ``a <= N <= b`` for ``a "
"<= b`` and ``b <= N <= a`` for ``b < a``."
msgstr ""
"Retorna um número de ponto flutuante aleatório *N* de forma que ``a <= N <= "
"b`` para ``a <= b`` e ``b <= N <= a`` para ``b < a``."

#: ../../library/random.rst:309
msgid ""
"The end-point value ``b`` may or may not be included in the range depending "
"on floating-point rounding in the expression ``a + (b-a) * random()``."
msgstr ""
"O valor final ``b`` pode ou não ser incluído no intervalo dependendo do "
"arredondamento de ponto flutuante na expressão ``a + (b-a) * random()``."

#: ../../library/random.rst:316
msgid ""
"Return a random floating-point number *N* such that ``low <= N <= high`` and "
"with the specified *mode* between those bounds.  The *low* and *high* bounds "
"default to zero and one.  The *mode* argument defaults to the midpoint "
"between the bounds, giving a symmetric distribution."
msgstr ""
"Retorna um número de ponto flutuante aleatório *N* de forma que ``low <= N "
"<= high`` e com o *mode* especificado entre esses limites. Os limites *low* "
"e *high* são padronizados como zero e um. O argumento *mode* assume como "
"padrão o ponto médio entre os limites, fornecendo uma distribuição simétrica."

#: ../../library/random.rst:324
msgid ""
"Beta distribution.  Conditions on the parameters are ``alpha > 0`` and "
"``beta > 0``. Returned values range between 0 and 1."
msgstr ""
"Distribuição beta. As condições nos parâmetros são ``alpha > 0`` e ``beta > "
"0``. Os valores retornados variam entre 0 e 1."

#: ../../library/random.rst:330
msgid ""
"Exponential distribution.  *lambd* is 1.0 divided by the desired mean.  It "
"should be nonzero.  (The parameter would be called \"lambda\", but that is a "
"reserved word in Python.)  Returned values range from 0 to positive infinity "
"if *lambd* is positive, and from negative infinity to 0 if *lambd* is "
"negative."
msgstr ""
"Distribuição exponencial. *lambd* é 1.0 dividido pela média desejada. Deve "
"ser diferente de zero. (O parâmetro seria chamado \"lambda\", mas é uma "
"palavra reservada em Python.) Os valores retornados variam de 0 a infinito "
"positivo se *lambd* for positivo e de infinito negativo a 0 se *lambd* for "
"negativo."

#: ../../library/random.rst:336
msgid "Added the default value for ``lambd``."
msgstr "Adicionado o valor padrão para ``lambd``."

#: ../../library/random.rst:342
msgid ""
"Gamma distribution.  (*Not* the gamma function!)  The shape and scale "
"parameters, *alpha* and *beta*, must have positive values. (Calling "
"conventions vary and some sources define 'beta' as the inverse of the scale)."
msgstr ""
"Distribuição gama. (*Não* a função gama!) Os parâmetros de forma e escala, "
"*alfa* e *beta*, devem ter valores positivos. (As convenções de chamada "
"variam e algumas fontes definem 'beta' como o inverso da escala)."

#: ../../library/random.rst:347
msgid "The probability distribution function is::"
msgstr "A função de distribuição de probabilidade é::"

#: ../../library/random.rst:349
msgid ""
"          x ** (alpha - 1) * math.exp(-x / beta)\n"
"pdf(x) =  --------------------------------------\n"
"            math.gamma(alpha) * beta ** alpha"
msgstr ""
"          x ** (alpha - 1) * math.exp(-x / beta)\n"
"pdf(x) =  --------------------------------------\n"
"            math.gamma(alpha) * beta ** alpha"

#: ../../library/random.rst:356
msgid ""
"Normal distribution, also called the Gaussian distribution. *mu* is the "
"mean, and *sigma* is the standard deviation.  This is slightly faster than "
"the :func:`normalvariate` function defined below."
msgstr ""
"Distribuição normal, também chamada de distribuição gaussiana. *mu* é a "
"média e *sigma* é o desvio padrão. Isto é um pouco mais rápido que a função :"
"func:`normalvariate` definida abaixo."

#: ../../library/random.rst:361
msgid ""
"Multithreading note:  When two threads call this function simultaneously, it "
"is possible that they will receive the same return value.  This can be "
"avoided in three ways. 1) Have each thread use a different instance of the "
"random number generator. 2) Put locks around all calls. 3) Use the slower, "
"but thread-safe :func:`normalvariate` function instead."
msgstr ""
"Nota sobre multithreading: quando duas threads chamam esta função "
"simultaneamente, é possível que recebam o mesmo valor de retorno. Isso pode "
"ser evitado de três maneiras. 1) Fazer com que cada thread use uma instância "
"diferente do gerador de números aleatórios. 2) Colocar travas em todas as "
"chamadas. 3) Usar a função mais lenta, mas segura para thread :func:"
"`normalvariate`."

#: ../../library/random.rst:368 ../../library/random.rst:384
msgid "*mu* and *sigma* now have default arguments."
msgstr "*mu* e *sigma* agora têm argumentos padrão."

#: ../../library/random.rst:374
msgid ""
"Log normal distribution.  If you take the natural logarithm of this "
"distribution, you'll get a normal distribution with mean *mu* and standard "
"deviation *sigma*.  *mu* can have any value, and *sigma* must be greater "
"than zero."
msgstr ""
"Distribuição log normal. Se você usar o logaritmo natural dessa "
"distribuição, obterá uma distribuição normal com média *mu* e desvio padrão "
"*sigma*. *mu* pode ter qualquer valor e *sigma* deve ser maior que zero."

#: ../../library/random.rst:382
msgid ""
"Normal distribution.  *mu* is the mean, and *sigma* is the standard "
"deviation."
msgstr "Distribuição normal. *mu* é a média e *sigma* é o desvio padrão."

#: ../../library/random.rst:390
msgid ""
"*mu* is the mean angle, expressed in radians between 0 and 2\\*\\ *pi*, and "
"*kappa* is the concentration parameter, which must be greater than or equal "
"to zero.  If *kappa* is equal to zero, this distribution reduces to a "
"uniform random angle over the range 0 to 2\\*\\ *pi*."
msgstr ""
"*mu* é o ângulo médio, expresso em radianos entre 0 e 2\\*\\ *pi*, e *kappa* "
"é o parâmetro de concentração, que deve ser maior ou igual a zero. Se "
"*kappa* for igual a zero, essa distribuição será reduzida para um ângulo "
"aleatório uniforme no intervalo de 0 a 2\\*\\ *pi*."

#: ../../library/random.rst:398
msgid "Pareto distribution.  *alpha* is the shape parameter."
msgstr "Distribuição de Pareto. *alpha* é o parâmetro de forma."

#: ../../library/random.rst:403
msgid ""
"Weibull distribution.  *alpha* is the scale parameter and *beta* is the "
"shape parameter."
msgstr ""
"Distribuição Weibull. *alpha* é o parâmetro de escala e *beta* é o parâmetro "
"de forma."

#: ../../library/random.rst:408
msgid "Alternative Generator"
msgstr "Gerador alternativo"

#: ../../library/random.rst:412
msgid ""
"Class that implements the default pseudo-random number generator used by "
"the :mod:`random` module."
msgstr ""
"Classe que implementa o gerador de números pseudoaleatórios padrão usado "
"pelo módulo :mod:`random`."

#: ../../library/random.rst:415
msgid ""
"Formerly the *seed* could be any hashable object.  Now it is limited to: "
"``None``, :class:`int`, :class:`float`, :class:`str`, :class:`bytes`, or :"
"class:`bytearray`."
msgstr ""
"Anteriormente, o *seed* poderia ser qualquer objeto hasheável. Agora está "
"limitado a: ``None``, :class:`int`, :class:`float`, :class:`str`, :class:"
"`bytes` ou :class:`bytearray`."

#: ../../library/random.rst:420
msgid ""
"Subclasses of :class:`!Random` should override the following methods if they "
"wish to make use of a different basic generator:"
msgstr ""
"Subclasses de :class:`!Random` devem substituir os seguintes métodos se "
"desejarem fazer uso de um gerador básico diferente:"

#: ../../library/random.rst:425
msgid ""
"Override this method in subclasses to customise the :meth:`~random.seed` "
"behaviour of :class:`!Random` instances."
msgstr ""
"Substitua este método nas subclasses para personalizar o comportamento de :"
"meth:`~random.seed` das instâncias de :class:`!Random`."

#: ../../library/random.rst:430
msgid ""
"Override this method in subclasses to customise the :meth:`~random.getstate` "
"behaviour of :class:`!Random` instances."
msgstr ""
"Substitua este método nas subclasses para personalizar o comportamento de :"
"meth:`~random.getstate` das instâncias de :class:`!Random`."

#: ../../library/random.rst:435
msgid ""
"Override this method in subclasses to customise the :meth:`~random.setstate` "
"behaviour of :class:`!Random` instances."
msgstr ""
"Substitua este método nas subclasses para personalizar o comportamento de :"
"meth:`~random.setstate` das instâncias de :class:`!Random`."

#: ../../library/random.rst:440
msgid ""
"Override this method in subclasses to customise the :meth:`~random.random` "
"behaviour of :class:`!Random` instances."
msgstr ""
"Substitua este método nas subclasses para personalizar o comportamento de :"
"meth:`~random.random` das instâncias de :class:`!Random`."

#: ../../library/random.rst:443
msgid ""
"Optionally, a custom generator subclass can also supply the following method:"
msgstr ""
"Opcionalmente, uma subclasse geradora personalizada também pode fornecer o "
"seguinte método:"

#: ../../library/random.rst:447
msgid ""
"Override this method in subclasses to customise the :meth:`~random."
"getrandbits` behaviour of :class:`!Random` instances."
msgstr ""
"Substitua este método nas subclasses para personalizar o comportamento de :"
"meth:`~random.getrandbits` das instâncias de :class:`!Random`."

#: ../../library/random.rst:452
msgid ""
"Override this method in subclasses to customise the :meth:`~random."
"randbytes` behaviour of :class:`!Random` instances."
msgstr ""
"Substitua este método nas subclasses para personalizar o comportamento de :"
"meth:`~random.randbytes` das instâncias de :class:`!Random`."

#: ../../library/random.rst:458
msgid ""
"Class that uses the :func:`os.urandom` function for generating random "
"numbers from sources provided by the operating system. Not available on all "
"systems. Does not rely on software state, and sequences are not "
"reproducible. Accordingly, the :meth:`seed` method has no effect and is "
"ignored. The :meth:`getstate` and :meth:`setstate` methods raise :exc:"
"`NotImplementedError` if called."
msgstr ""
"Classe que usa a função :func:`os.urandom` para gerar números aleatórios a "
"partir de fontes fornecidas pelo sistema operacional. Não disponível em "
"todos os sistemas. Não depende do estado do software e as sequências não são "
"reproduzíveis. Assim, o método :meth:`seed` não tem efeito e é ignorado. Os "
"métodos :meth:`getstate` e :meth:`setstate` levantam :exc:"
"`NotImplementedError` se chamados."

#: ../../library/random.rst:467
msgid "Notes on Reproducibility"
msgstr "Notas sobre reprodutibilidade"

#: ../../library/random.rst:469
msgid ""
"Sometimes it is useful to be able to reproduce the sequences given by a "
"pseudo-random number generator.  By reusing a seed value, the same sequence "
"should be reproducible from run to run as long as multiple threads are not "
"running."
msgstr ""
"Às vezes, é útil poder reproduzir as sequências fornecidas por um gerador de "
"números pseudoaleatórios. Reutilizando um valor inicial, a mesma sequência "
"deve ser reproduzível de execução para execução, desde que mais de uma "
"thread não estejam em execução."

#: ../../library/random.rst:473
msgid ""
"Most of the random module's algorithms and seeding functions are subject to "
"change across Python versions, but two aspects are guaranteed not to change:"
msgstr ""
"A maioria dos algoritmos e funções de propagação do módulo aleatório está "
"sujeita a alterações nas versões de Python, mas dois aspectos são garantidos "
"para não serem alterados:"

#: ../../library/random.rst:476
msgid ""
"If a new seeding method is added, then a backward compatible seeder will be "
"offered."
msgstr ""
"Se um novo método de semeadura for adicionado, será oferecida um semeador "
"compatível com versões anteriores."

#: ../../library/random.rst:479
msgid ""
"The generator's :meth:`~Random.random` method will continue to produce the "
"same sequence when the compatible seeder is given the same seed."
msgstr ""
"O método :meth:`~Random.random` do gerador continuará produzindo a mesma "
"sequência quando o semeador compatível receber a mesma semente."

#: ../../library/random.rst:485
msgid "Examples"
msgstr "Exemplos"

#: ../../library/random.rst:487
msgid "Basic examples::"
msgstr "Exemplos básicos::"

#: ../../library/random.rst:489
msgid ""
">>> random()                          # Random float:  0.0 <= x < 1.0\n"
"0.37444887175646646\n"
"\n"
">>> uniform(2.5, 10.0)                # Random float:  2.5 <= x <= 10.0\n"
"3.1800146073117523\n"
"\n"
">>> expovariate(1 / 5)                # Interval between arrivals averaging "
"5 seconds\n"
"5.148957571865031\n"
"\n"
">>> randrange(10)                     # Integer from 0 to 9 inclusive\n"
"7\n"
"\n"
">>> randrange(0, 101, 2)              # Even integer from 0 to 100 "
"inclusive\n"
"26\n"
"\n"
">>> choice(['win', 'lose', 'draw'])   # Single random element from a "
"sequence\n"
"'draw'\n"
"\n"
">>> deck = 'ace two three four'.split()\n"
">>> shuffle(deck)                     # Shuffle a list\n"
">>> deck\n"
"['four', 'two', 'ace', 'three']\n"
"\n"
">>> sample([10, 20, 30, 40, 50], k=4) # Four samples without replacement\n"
"[40, 10, 50, 30]"
msgstr ""
">>> random()                          # Ponto flutuante aleatório:  0.0 <= x "
"< 1.0\n"
"0.37444887175646646\n"
"\n"
">>> uniform(2.5, 10.0)                # Ponto flutuante aleatório:  2.5 <= x "
"<= 10.0\n"
"3.1800146073117523\n"
"\n"
">>> expovariate(1 / 5)                # Intervalo entre chegadas com médias "
"de 5 segundos\n"
"5.148957571865031\n"
"\n"
">>> randrange(10)                     # Inteiro de 0 até 9 inclusivo\n"
"7\n"
"\n"
">>> randrange(0, 101, 2)              # Inteiro par entre 0 até 100 "
"inclusivo\n"
"26\n"
"\n"
">>> choice(['win', 'lose', 'draw'])   # Um único elemento aleatório de uma "
"sequência\n"
"'draw'\n"
"\n"
">>> deck = 'ace two three four'.split()\n"
">>> shuffle(deck)                     # Embaralha uma lista\n"
">>> deck\n"
"['four', 'two', 'ace', 'three']\n"
"\n"
">>> sample([10, 20, 30, 40, 50], k=4) # Quatro amostras sem substitutos\n"
"[40, 10, 50, 30]"

#: ../../library/random.rst:515
msgid "Simulations::"
msgstr "Simulações::"

#: ../../library/random.rst:517
msgid ""
">>> # Six roulette wheel spins (weighted sampling with replacement)\n"
">>> choices(['red', 'black', 'green'], [18, 18, 2], k=6)\n"
"['red', 'green', 'black', 'black', 'red', 'black']\n"
"\n"
">>> # Deal 20 cards without replacement from a deck\n"
">>> # of 52 playing cards, and determine the proportion of cards\n"
">>> # with a ten-value:  ten, jack, queen, or king.\n"
">>> deal = sample(['tens', 'low cards'], counts=[16, 36], k=20)\n"
">>> deal.count('tens') / 20\n"
"0.15\n"
"\n"
">>> # Estimate the probability of getting 5 or more heads from 7 spins\n"
">>> # of a biased coin that settles on heads 60% of the time.\n"
">>> sum(binomialvariate(n=7, p=0.6) >= 5 for i in range(10_000)) / 10_000\n"
"0.4169\n"
"\n"
">>> # Probability of the median of 5 samples being in middle two quartiles\n"
">>> def trial():\n"
"...     return 2_500 <= sorted(choices(range(10_000), k=5))[2] < 7_500\n"
"...\n"
">>> sum(trial() for i in range(10_000)) / 10_000\n"
"0.7958"
msgstr ""
">>> # Seis giros da roleta (amostragem ponderada com substituição)\n"
">>> choices(['red', 'black', 'green'], [18, 18, 2], k=6)\n"
"['red', 'green', 'black', 'black', 'red', 'black']\n"
"\n"
">>> # Distribui 20 cartas sem reposição de um baralho de\n"
">>> # 52 cartas e determine a proporção de cartas com\n"
">>> # valor dez: dez, valete, rainha ou rei.\n"
">>> deal = sample(['tens', 'low cards'], counts=[16, 36], k=20)\n"
">>> deal.count('tens') / 20\n"
"0.15\n"
"\n"
">>> # Estima a probabilidade de obter 5 ou mais caras em 7 giros\n"
">>> # de uma moeda viciada que cai em cara 60% das vezes.\n"
">>> sum(binomialvariate(n=7, p=0.6) >= 5 for i in range(10_000)) / 10_000\n"
"0.4169\n"
"\n"
">>> # Probabilidade da mediana de 5 amostras estar nos dois quartis do meio\n"
">>> def trial():\n"
"...     return 2_500 <= sorted(choices(range(10_000), k=5))[2] < 7_500\n"
"...\n"
">>> sum(trial() for i in range(10_000)) / 10_000\n"
"0.7958"

#: ../../library/random.rst:540
msgid ""
"Example of `statistical bootstrapping <https://en.wikipedia.org/wiki/"
"Bootstrapping_(statistics)>`_ using resampling with replacement to estimate "
"a confidence interval for the mean of a sample::"
msgstr ""
"Exemplo de `bootstrapping estatístico <https://pt.wikipedia.org/wiki/"
"Bootstrapping_(estatística)>`_ usando reamostragem com substituição para "
"estimar um intervalo de confiança para a média de uma amostra::"

#: ../../library/random.rst:544
msgid ""
"# https://www.thoughtco.com/example-of-bootstrapping-3126155\n"
"from statistics import fmean as mean\n"
"from random import choices\n"
"\n"
"data = [41, 50, 29, 37, 81, 30, 73, 63, 20, 35, 68, 22, 60, 31, 95]\n"
"means = sorted(mean(choices(data, k=len(data))) for i in range(100))\n"
"print(f'The sample mean of {mean(data):.1f} has a 90% confidence '\n"
"      f'interval from {means[5]:.1f} to {means[94]:.1f}')"
msgstr ""
"# https://www.thoughtco.com/example-of-bootstrapping-3126155\n"
"from statistics import fmean as mean\n"
"from random import choices\n"
"\n"
"data = [41, 50, 29, 37, 81, 30, 73, 63, 20, 35, 68, 22, 60, 31, 95]\n"
"means = sorted(mean(choices(data, k=len(data))) for i in range(100))\n"
"print(f'The sample mean of {mean(data):.1f} has a 90% confidence '\n"
"      f'interval from {means[5]:.1f} to {means[94]:.1f}')"

#: ../../library/random.rst:553
msgid ""
"Example of a `resampling permutation test <https://en.wikipedia.org/wiki/"
"Resampling_(statistics)#Permutation_tests>`_ to determine the statistical "
"significance or `p-value <https://en.wikipedia.org/wiki/P-value>`_ of an "
"observed difference between the effects of a drug versus a placebo::"
msgstr ""
"Exemplo de um `teste de permutação de reamostragem <https://en.wikipedia.org/"
"wiki/Resampling_(statistics)#Permutation_tests>`_ para determinar a "
"significância estatística ou `valor-p <https://pt.wikipedia.org/wiki/Valor-"
"p>`_ de uma diferença observada entre os efeitos de uma droga em comparação "
"com um placebo::"

#: ../../library/random.rst:559
msgid ""
"# Example from \"Statistics is Easy\" by Dennis Shasha and Manda Wilson\n"
"from statistics import fmean as mean\n"
"from random import shuffle\n"
"\n"
"drug = [54, 73, 53, 70, 73, 68, 52, 65, 65]\n"
"placebo = [54, 51, 58, 44, 55, 52, 42, 47, 58, 46]\n"
"observed_diff = mean(drug) - mean(placebo)\n"
"\n"
"n = 10_000\n"
"count = 0\n"
"combined = drug + placebo\n"
"for i in range(n):\n"
"    shuffle(combined)\n"
"    new_diff = mean(combined[:len(drug)]) - mean(combined[len(drug):])\n"
"    count += (new_diff >= observed_diff)\n"
"\n"
"print(f'{n} label reshufflings produced only {count} instances with a "
"difference')\n"
"print(f'at least as extreme as the observed difference of "
"{observed_diff:.1f}.')\n"
"print(f'The one-sided p-value of {count / n:.4f} leads us to reject the "
"null')\n"
"print(f'hypothesis that there is no difference between the drug and the "
"placebo.')"
msgstr ""
"# Exemplo de \"Statistics is Easy\" de Dennis Shasha e Manda Wilson\n"
"from statistics import fmean as mean\n"
"from random import shuffle\n"
"\n"
"drug = [54, 73, 53, 70, 73, 68, 52, 65, 65]\n"
"placebo = [54, 51, 58, 44, 55, 52, 42, 47, 58, 46]\n"
"observed_diff = mean(drug) - mean(placebo)\n"
"\n"
"n = 10_000\n"
"count = 0\n"
"combined = drug + placebo\n"
"for i in range(n):\n"
"    shuffle(combined)\n"
"    new_diff = mean(combined[:len(drug)]) - mean(combined[len(drug):])\n"
"    count += (new_diff >= observed_diff)\n"
"\n"
"print(f'{n} label reshufflings produced only {count} instances with a "
"difference')\n"
"print(f'at least as extreme as the observed difference of "
"{observed_diff:.1f}.')\n"
"print(f'The one-sided p-value of {count / n:.4f} leads us to reject the "
"null')\n"
"print(f'hypothesis that there is no difference between the drug and the "
"placebo.')"

#: ../../library/random.rst:580
msgid ""
"Simulation of arrival times and service deliveries for a multiserver queue::"
msgstr ""
"Simulação de tempos de chegada e entregas de serviços para uma fila "
"multisservidor::"

#: ../../library/random.rst:582
msgid ""
"from heapq import heapify, heapreplace\n"
"from random import expovariate, gauss\n"
"from statistics import mean, quantiles\n"
"\n"
"average_arrival_interval = 5.6\n"
"average_service_time = 15.0\n"
"stdev_service_time = 3.5\n"
"num_servers = 3\n"
"\n"
"waits = []\n"
"arrival_time = 0.0\n"
"servers = [0.0] * num_servers  # time when each server becomes available\n"
"heapify(servers)\n"
"for i in range(1_000_000):\n"
"    arrival_time += expovariate(1.0 / average_arrival_interval)\n"
"    next_server_available = servers[0]\n"
"    wait = max(0.0, next_server_available - arrival_time)\n"
"    waits.append(wait)\n"
"    service_duration = max(0.0, gauss(average_service_time, "
"stdev_service_time))\n"
"    service_completed = arrival_time + wait + service_duration\n"
"    heapreplace(servers, service_completed)\n"
"\n"
"print(f'Mean wait: {mean(waits):.1f}   Max wait: {max(waits):.1f}')\n"
"print('Quartiles:', [round(q, 1) for q in quantiles(waits)])"
msgstr ""
"from heapq import heapify, heapreplace\n"
"from random import expovariate, gauss\n"
"from statistics import mean, quantiles\n"
"\n"
"average_arrival_interval = 5.6\n"
"average_service_time = 15.0\n"
"stdev_service_time = 3.5\n"
"num_servers = 3\n"
"\n"
"waits = []\n"
"arrival_time = 0.0\n"
"servers = [0.0] * num_servers  # hora em que cada servidor fica disponível\n"
"heapify(servers)\n"
"for i in range(1_000_000):\n"
"    arrival_time += expovariate(1.0 / average_arrival_interval)\n"
"    next_server_available = servers[0]\n"
"    wait = max(0.0, next_server_available - arrival_time)\n"
"    waits.append(wait)\n"
"    service_duration = max(0.0, gauss(average_service_time, "
"stdev_service_time))\n"
"    service_completed = arrival_time + wait + service_duration\n"
"    heapreplace(servers, service_completed)\n"
"\n"
"print(f'Mean wait: {mean(waits):.1f}   Max wait: {max(waits):.1f}')\n"
"print('Quartiles:', [round(q, 1) for q in quantiles(waits)])"

#: ../../library/random.rst:609
msgid ""
"`Statistics for Hackers <https://www.youtube.com/watch?v=Iq9DzN6mvYA>`_ a "
"video tutorial by `Jake Vanderplas <https://us.pycon.org/2016/speaker/"
"profile/295/>`_ on statistical analysis using just a few fundamental "
"concepts including simulation, sampling, shuffling, and cross-validation."
msgstr ""
"`Statistics for Hackers <https://www.youtube.com/watch?v=Iq9DzN6mvYA>`_ um "
"tutorial em vídeo por `Jake Vanderplas <https://us.pycon.org/2016/speaker/"
"profile/295/>`_ sobre análise estatística usando apenas alguns conceitos "
"fundamentais, incluindo simulação, amostragem, embaralhamento e validação "
"cruzada."

#: ../../library/random.rst:615
msgid ""
"`Economics Simulation <https://nbviewer.org/url/norvig.com/ipython/Economics."
"ipynb>`_ a simulation of a marketplace by `Peter Norvig <https://norvig.com/"
"bio.html>`_ that shows effective use of many of the tools and distributions "
"provided by this module (gauss, uniform, sample, betavariate, choice, "
"triangular, and randrange)."
msgstr ""
"`Economics Simulation <https://nbviewer.org/url/norvig.com/ipython/Economics."
"ipynb>`_ uma simulação de um mercado por `Peter Norvig <https://norvig.com/"
"bio.html>`_ que mostra o uso eficaz de muitas das ferramentas e "
"distribuições fornecidas por este módulo (gauss, uniform, sample, "
"betavariate, choice, triangular e randrange)."

#: ../../library/random.rst:622
msgid ""
"`A Concrete Introduction to Probability (using Python) <https://nbviewer.org/"
"url/norvig.com/ipython/Probability.ipynb>`_ a tutorial by `Peter Norvig "
"<https://norvig.com/bio.html>`_ covering the basics of probability theory, "
"how to write simulations, and how to perform data analysis using Python."
msgstr ""
"`A Concrete Introduction to Probability (using Python) <https://nbviewer.org/"
"url/norvig.com/ipython/Probability.ipynb>`_ um tutorial de `Peter Norvig "
"<https://norvig.com/bio.html>`_ cobrindo os fundamentos da teoria das "
"probabilidades, como escrever simulações e como realizar análises de dados "
"usando Python."

#: ../../library/random.rst:630
msgid "Recipes"
msgstr "Receitas"

#: ../../library/random.rst:632
msgid ""
"These recipes show how to efficiently make random selections from the "
"combinatoric iterators in the :mod:`itertools` module:"
msgstr ""
"Estas receitas mostram como fazer seleções aleatórias de forma eficiente a "
"partir dos iteradores combinatórios no módulo :mod:`itertools`:"

#: ../../library/random.rst:635
msgid ""
"def random_product(*args, repeat=1):\n"
"    \"Random selection from itertools.product(*args, **kwds)\"\n"
"    pools = [tuple(pool) for pool in args] * repeat\n"
"    return tuple(map(random.choice, pools))\n"
"\n"
"def random_permutation(iterable, r=None):\n"
"    \"Random selection from itertools.permutations(iterable, r)\"\n"
"    pool = tuple(iterable)\n"
"    r = len(pool) if r is None else r\n"
"    return tuple(random.sample(pool, r))\n"
"\n"
"def random_combination(iterable, r):\n"
"    \"Random selection from itertools.combinations(iterable, r)\"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    indices = sorted(random.sample(range(n), r))\n"
"    return tuple(pool[i] for i in indices)\n"
"\n"
"def random_combination_with_replacement(iterable, r):\n"
"    \"Choose r elements with replacement.  Order the result to match the "
"iterable.\"\n"
"    # Result will be in set(itertools."
"combinations_with_replacement(iterable, r)).\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    indices = sorted(random.choices(range(n), k=r))\n"
"    return tuple(pool[i] for i in indices)"
msgstr ""
"def random_product(*args, repeat=1):\n"
"    \"Random selection from itertools.product(*args, **kwds)\"\n"
"    pools = [tuple(pool) for pool in args] * repeat\n"
"    return tuple(map(random.choice, pools))\n"
"\n"
"def random_permutation(iterable, r=None):\n"
"    \"Random selection from itertools.permutations(iterable, r)\"\n"
"    pool = tuple(iterable)\n"
"    r = len(pool) if r is None else r\n"
"    return tuple(random.sample(pool, r))\n"
"\n"
"def random_combination(iterable, r):\n"
"    \"Random selection from itertools.combinations(iterable, r)\"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    indices = sorted(random.sample(range(n), r))\n"
"    return tuple(pool[i] for i in indices)\n"
"\n"
"def random_combination_with_replacement(iterable, r):\n"
"    \"Choose r elements with replacement.  Order the result to match the "
"iterable.\"\n"
"    # Result will be in set(itertools."
"combinations_with_replacement(iterable, r)).\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    indices = sorted(random.choices(range(n), k=r))\n"
"    return tuple(pool[i] for i in indices)"

#: ../../library/random.rst:664
msgid ""
"The default :func:`.random` returns multiples of 2⁻⁵³ in the range *0.0 ≤ x "
"< 1.0*.  All such numbers are evenly spaced and are exactly representable as "
"Python floats.  However, many other representable floats in that interval "
"are not possible selections.  For example, ``0.05954861408025609`` isn't an "
"integer multiple of 2⁻⁵³."
msgstr ""
"O padrão de :func:`.random` é retornar múltiplos de 2⁻⁵³ no intervalo *0.0 ≤ "
"x < 1.0*. Todos esses números são espaçados uniformemente e são "
"representáveis exatamente como pontos flutuantes Python. No entanto, muitos "
"outros pontos flutuantes representados nesse intervalo não são seleções "
"possíveis. Por exemplo, ``0.05954861408025609`` não é um múltiplo inteiro de "
"2⁻⁵³."

#: ../../library/random.rst:670
msgid ""
"The following recipe takes a different approach.  All floats in the interval "
"are possible selections.  The mantissa comes from a uniform distribution of "
"integers in the range *2⁵² ≤ mantissa < 2⁵³*.  The exponent comes from a "
"geometric distribution where exponents smaller than *-53* occur half as "
"often as the next larger exponent."
msgstr ""
"A receita a seguir tem uma abordagem diferente. Todos os pontos flutuantes "
"no intervalo são seleções possíveis. A mantissa vem de uma distribuição "
"uniforme de inteiros no intervalo *2⁵² ≤ mantissa < 2⁵³*. O expoente vem de "
"uma distribuição geométrica onde expoentes menores que *-53* ocorrem com "
"metade da frequência do próximo expoente maior."

#: ../../library/random.rst:678
msgid ""
"from random import Random\n"
"from math import ldexp\n"
"\n"
"class FullRandom(Random):\n"
"\n"
"    def random(self):\n"
"        mantissa = 0x10_0000_0000_0000 | self.getrandbits(52)\n"
"        exponent = -53\n"
"        x = 0\n"
"        while not x:\n"
"            x = self.getrandbits(32)\n"
"            exponent += x.bit_length() - 32\n"
"        return ldexp(mantissa, exponent)"
msgstr ""
"from random import Random\n"
"from math import ldexp\n"
"\n"
"class FullRandom(Random):\n"
"\n"
"    def random(self):\n"
"        mantissa = 0x10_0000_0000_0000 | self.getrandbits(52)\n"
"        exponent = -53\n"
"        x = 0\n"
"        while not x:\n"
"            x = self.getrandbits(32)\n"
"            exponent += x.bit_length() - 32\n"
"        return ldexp(mantissa, exponent)"

#: ../../library/random.rst:692
msgid ""
"All :ref:`real valued distributions <real-valued-distributions>` in the "
"class will use the new method::"
msgstr ""
"Todas as :ref:`distribuições reais valoradas <real-valued-distributions>` na "
"classe usarão o novo método::"

#: ../../library/random.rst:695
msgid ""
">>> fr = FullRandom()\n"
">>> fr.random()\n"
"0.05954861408025609\n"
">>> fr.expovariate(0.25)\n"
"8.87925541791544"
msgstr ""
">>> fr = FullRandom()\n"
">>> fr.random()\n"
"0.05954861408025609\n"
">>> fr.expovariate(0.25)\n"
"8.87925541791544"

#: ../../library/random.rst:701
msgid ""
"The recipe is conceptually equivalent to an algorithm that chooses from all "
"the multiples of 2⁻¹⁰⁷⁴ in the range *0.0 ≤ x < 1.0*.  All such numbers are "
"evenly spaced, but most have to be rounded down to the nearest representable "
"Python float.  (The value 2⁻¹⁰⁷⁴ is the smallest positive unnormalized float "
"and is equal to ``math.ulp(0.0)``.)"
msgstr ""
"A receita é conceitualmente equivalente a um algoritmo que escolhe entre "
"todos os múltiplos de 2⁻¹⁰⁷⁴ no intervalo *0.0 ≤ x < 1.0*. Todos esses "
"números são espaçados uniformemente, mas a maioria deve ser arredondada para "
"o ponto flutuante Python representável mais próximo. (O valor 2⁻¹⁰⁷⁴ é o "
"menor ponto flutuante positivo não normalizado e é igual a ``math."
"ulp(0.0)``.)"

#: ../../library/random.rst:710
msgid ""
"`Generating Pseudo-random Floating-Point Values <https://allendowney.com/"
"research/rand/downey07randfloat.pdf>`_ a paper by Allen B. Downey describing "
"ways to generate more fine-grained floats than normally generated by :func:`."
"random`."
msgstr ""
"`Generating Pseudo-random Floating-Point Values <https://allendowney.com/"
"research/rand/downey07randfloat.pdf>`_ um artigo de Allen B. Downey "
"descrevendo formas de gerar pontos flutuantes mais refinados do que "
"normalmente gerados por :func:`.random`."

#: ../../library/random.rst:718
msgid "Command-line usage"
msgstr "Uso na linha de comando"

#: ../../library/random.rst:722
msgid "The :mod:`!random` module can be executed from the command line."
msgstr ""
"O módulo :mod:`!random` pode ser invocado como um script na linha de comando:"

#: ../../library/random.rst:724
msgid ""
"python -m random [-h] [-c CHOICE [CHOICE ...] | -i N | -f N] [input ...]"
msgstr ""
"python -m random [-h] [-c ESCOLHA [ESCOLHA ...] | -i N | -f N] [entrada ...]"

#: ../../library/random.rst:728
msgid "The following options are accepted:"
msgstr "As seguintes opções são aceitas:"

#: ../../library/random.rst:734
msgid "Show the help message and exit."
msgstr "Mostra a mensagem de ajuda e sai."

#: ../../library/random.rst:739
msgid "Print a random choice, using :meth:`choice`."
msgstr "Imprime uma escolha aleatória, usando :meth:`choice`."

#: ../../library/random.rst:744
msgid ""
"Print a random integer between 1 and N inclusive, using :meth:`randint`."
msgstr ""
"Imprime um inteiro aleatório entre 1 e N inclusive, usando :meth:`randint`."

#: ../../library/random.rst:749
msgid ""
"Print a random floating-point number between 0 and N inclusive, using :meth:"
"`uniform`."
msgstr ""
"Imprime um número de ponto flutuante aleatório entre 0 e N inclusive, "
"usando :meth:`uniform`."

#: ../../library/random.rst:752
msgid "If no options are given, the output depends on the input:"
msgstr "Se nenhuma opção for fornecida, a saída dependerá da entrada:"

#: ../../library/random.rst:754
msgid "String or multiple: same as :option:`--choice`."
msgstr "String ou vários: mesmo que :option:`--choice`."

#: ../../library/random.rst:755
msgid "Integer: same as :option:`--integer`."
msgstr "Inteiro mesmo que :option:`--integer`."

#: ../../library/random.rst:756
msgid "Float: same as :option:`--float`."
msgstr "Ponto flutuante: mesmo que :option:`--float`."

#: ../../library/random.rst:761
msgid "Command-line example"
msgstr "Exemplos na linha de comando"

#: ../../library/random.rst:763
msgid "Here are some examples of the :mod:`!random` command-line interface:"
msgstr ""
"Aqui estão alguns exemplos da interface de linha de comando :mod:`!random`:"

#: ../../library/random.rst:765
msgid ""
"$ # Choose one at random\n"
"$ python -m random egg bacon sausage spam \"Lobster Thermidor aux crevettes "
"with a Mornay sauce\"\n"
"Lobster Thermidor aux crevettes with a Mornay sauce\n"
"\n"
"$ # Random integer\n"
"$ python -m random 6\n"
"6\n"
"\n"
"$ # Random floating-point number\n"
"$ python -m random 1.8\n"
"1.7080016272295635\n"
"\n"
"$ # With explicit arguments\n"
"$ python  -m random --choice egg bacon sausage spam \"Lobster Thermidor aux "
"crevettes with a Mornay sauce\"\n"
"egg\n"
"\n"
"$ python -m random --integer 6\n"
"3\n"
"\n"
"$ python -m random --float 1.8\n"
"1.5666339105010318\n"
"\n"
"$ python -m random --integer 6\n"
"5\n"
"\n"
"$ python -m random --float 6\n"
"3.1942323316565915"
msgstr ""
"$ # Escolhe um aleatório\n"
"$ python -m random egg bacon sausage spam \"Lobster Thermidor aux crevettes "
"with a Mornay sauce\"\n"
"Lobster Thermidor aux crevettes with a Mornay sauce\n"
"\n"
"$ # Inteiro aleatório\n"
"$ python -m random 6\n"
"6\n"
"\n"
"$ # Número de ponto flutuante aleatório\n"
"$ python -m random 1.8\n"
"1.7080016272295635\n"
"\n"
"$ # Com argumentos explícitos\n"
"$ python  -m random --choice egg bacon sausage spam \"Lobster Thermidor aux "
"crevettes with a Mornay sauce\"\n"
"egg\n"
"\n"
"$ python -m random --integer 6\n"
"3\n"
"\n"
"$ python -m random --float 1.8\n"
"1.5666339105010318\n"
"\n"
"$ python -m random --integer 6\n"
"5\n"
"\n"
"$ python -m random --float 6\n"
"3.1942323316565915"

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Raphael Mendonça, 2020
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2020
# Marco Rougeth <marco@rougeth.com>, 2020
# i17obot <i17obot@rougeth.com>, 2020
# Mario Candido, 2022
# Rodrigo Cândido, 2022
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-06 22:14+0000\n"
"PO-Revision-Date: 2020-05-30 12:04+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/importlib.rst:2
msgid ":mod:`!importlib` --- The implementation of :keyword:`!import`"
msgstr ":mod:`!importlib` --- A implementação de :keyword:`!import`"

#: ../../library/importlib.rst:12
msgid "**Source code:** :source:`Lib/importlib/__init__.py`"
msgstr "**Código-fonte:** :source:`Lib/importlib/__init__.py`"

#: ../../library/importlib.rst:17
msgid "Introduction"
msgstr "Introdução"

#: ../../library/importlib.rst:19
msgid ""
"The purpose of the :mod:`importlib` package is two-fold. One is to provide "
"the implementation of the :keyword:`import` statement (and thus, by "
"extension, the :func:`__import__` function) in Python source code. This "
"provides an implementation of :keyword:`!import` which is portable to any "
"Python interpreter. This also provides an implementation which is easier to "
"comprehend than one implemented in a programming language other than Python."
msgstr ""

#: ../../library/importlib.rst:26
msgid ""
"Two, the components to implement :keyword:`import` are exposed in this "
"package, making it easier for users to create their own custom objects "
"(known generically as an :term:`importer`) to participate in the import "
"process."
msgstr ""
"Dois, os componentes para implementar :keyword:`import` são expostos neste "
"pacote, tornando mais fácil para os usuários criarem seus próprios objetos "
"personalizados (conhecidos genericamente como :term:`importador`) para "
"participar do processo de importação."

#: ../../library/importlib.rst:33
msgid ":ref:`import`"
msgstr ":ref:`import`"

#: ../../library/importlib.rst:33
msgid "The language reference for the :keyword:`import` statement."
msgstr "A referência da linguagem para a instrução :keyword:`import`."

#: ../../library/importlib.rst:38
msgid ""
"`Packages specification <https://www.python.org/doc/essays/packages/>`__"
msgstr ""
"`Especificação dos pacotes <https://www.python.org/doc/essays/packages/>`__"

#: ../../library/importlib.rst:36
msgid ""
"Original specification of packages. Some semantics have changed since the "
"writing of this document (e.g. redirecting based on ``None`` in :data:`sys."
"modules`)."
msgstr ""
"Especificação original dos pacotes. Algumas semânticas mudaram desde a "
"redação deste documento (por exemplo, redirecionamento baseado em ``None`` "
"em :data:`sys.modules`)."

#: ../../library/importlib.rst:41
msgid "The :func:`.__import__` function"
msgstr "A função :func:`.__import__`"

#: ../../library/importlib.rst:41
msgid "The :keyword:`import` statement is syntactic sugar for this function."
msgstr "A instrução :keyword:`import` é um açúcar sintático para esta função."

#: ../../library/importlib.rst:44
msgid ":pep:`235`"
msgstr ":pep:`235`"

#: ../../library/importlib.rst:44
msgid "Import on Case-Insensitive Platforms"
msgstr "Importação em plataformas que diferenciam maiúsculo de minúsculo"

#: ../../library/importlib.rst:47
msgid ":pep:`263`"
msgstr ":pep:`263`"

#: ../../library/importlib.rst:47
msgid "Defining Python Source Code Encodings"
msgstr "Definindo codificações do código-fonte do Python"

#: ../../library/importlib.rst:50
msgid ":pep:`302`"
msgstr ":pep:`302`"

#: ../../library/importlib.rst:50
msgid "New Import Hooks"
msgstr "Novos ganchos de importação"

#: ../../library/importlib.rst:53
msgid ":pep:`328`"
msgstr ":pep:`328`"

#: ../../library/importlib.rst:53
msgid "Imports: Multi-Line and Absolute/Relative"
msgstr "Importações: Multilinha e Absoluto/Relativo"

#: ../../library/importlib.rst:56
msgid ":pep:`366`"
msgstr ":pep:`366`"

#: ../../library/importlib.rst:56
msgid "Main module explicit relative imports"
msgstr "Importações relativas explícitas do módulo principal"

#: ../../library/importlib.rst:59
msgid ":pep:`420`"
msgstr ":pep:`420`"

#: ../../library/importlib.rst:59
msgid "Implicit namespace packages"
msgstr "Pacotes de espaço de nomes implícitos"

#: ../../library/importlib.rst:62
msgid ":pep:`451`"
msgstr ":pep:`451`"

#: ../../library/importlib.rst:62
msgid "A ModuleSpec Type for the Import System"
msgstr "Um tipo de ModuleSpec para o sistema de importação"

#: ../../library/importlib.rst:65
msgid ":pep:`488`"
msgstr ":pep:`488`"

#: ../../library/importlib.rst:65
msgid "Elimination of PYO files"
msgstr "Eliminação de arquivos PYO"

#: ../../library/importlib.rst:68
msgid ":pep:`489`"
msgstr ":pep:`489`"

#: ../../library/importlib.rst:68
msgid "Multi-phase extension module initialization"
msgstr "Inicialização de módulo extensão multifase"

#: ../../library/importlib.rst:71
msgid ":pep:`552`"
msgstr ":pep:`552`"

#: ../../library/importlib.rst:71
msgid "Deterministic pycs"
msgstr "pycs determinísticos"

#: ../../library/importlib.rst:74
msgid ":pep:`3120`"
msgstr ":pep:`3120`"

#: ../../library/importlib.rst:74
msgid "Using UTF-8 as the Default Source Encoding"
msgstr "Usando UFT-8 como fonte padrão de codificação"

#: ../../library/importlib.rst:76
msgid ":pep:`3147`"
msgstr ":pep:`3147`"

#: ../../library/importlib.rst:77
msgid "PYC Repository Directories"
msgstr "Diretórios de repositório de PYC"

#: ../../library/importlib.rst:81
msgid "Functions"
msgstr "Funções"

#: ../../library/importlib.rst:85
msgid "An implementation of the built-in :func:`__import__` function."
msgstr "Uma implementação da função embutida :func:`__import__`."

#: ../../library/importlib.rst:88
msgid ""
"Programmatic importing of modules should use :func:`import_module` instead "
"of this function."
msgstr ""
"A importação programática de módulos deve usar :func:`import_module` em vez "
"desta função."

#: ../../library/importlib.rst:93
msgid ""
"Import a module. The *name* argument specifies what module to import in "
"absolute or relative terms (e.g. either ``pkg.mod`` or ``..mod``). If the "
"name is specified in relative terms, then the *package* argument must be set "
"to the name of the package which is to act as the anchor for resolving the "
"package name (e.g. ``import_module('..mod', 'pkg.subpkg')`` will import "
"``pkg.mod``)."
msgstr ""
"Importa um módulo. O argumento *name* especifica qual módulo importar em "
"termos absolutos ou relativos (por exemplo, ``pkg.mod`` ou ``..mod``). Se o "
"nome for especificado em termos relativos, então o argumento *package* deve "
"ser definido como o nome do pacote que atuará como âncora para resolver o "
"nome do pacote (por exemplo, ``import_module('..mod', 'pkg.subpkg')`` "
"importará ``pkg.mod``)."

#: ../../library/importlib.rst:101
msgid ""
"The :func:`import_module` function acts as a simplifying wrapper around :"
"func:`importlib.__import__`. This means all semantics of the function are "
"derived from :func:`importlib.__import__`. The most important difference "
"between these two functions is that :func:`import_module` returns the "
"specified package or module (e.g. ``pkg.mod``), while :func:`__import__` "
"returns the top-level package or module (e.g. ``pkg``)."
msgstr ""
"A função :func:`import_module` atua como um wrapper simplificador em torno "
"de :func:`importlib.__import__`. Isso significa que toda a semântica da "
"função é derivada de :func:`importlib.__import__`. A diferença mais "
"importante entre essas duas funções é que :func:`import_module` retorna o "
"pacote ou módulo especificado (por exemplo, ``pkg.mod``), enquanto :func:"
"`__import__` retorna o pacote ou módulo de nível superior (por exemplo, "
"``pkg``)."

#: ../../library/importlib.rst:108
msgid ""
"If you are dynamically importing a module that was created since the "
"interpreter began execution (e.g., created a Python source file), you may "
"need to call :func:`invalidate_caches` in order for the new module to be "
"noticed by the import system."
msgstr ""
"Se você estiver importando dinamicamente um módulo que foi criado desde que "
"o interpretador iniciou a execução (por exemplo, criou um arquivo fonte "
"Python), você pode precisar chamar :func:`invalidate_caches` para que o novo "
"módulo seja notado pelo sistema de importação."

#: ../../library/importlib.rst:113
msgid "Parent packages are automatically imported."
msgstr "Os pacotes pai são importados automaticamente."

#: ../../library/importlib.rst:118
msgid ""
"Find the loader for a module, optionally within the specified *path*. If the "
"module is in :attr:`sys.modules`, then ``sys.modules[name].__loader__`` is "
"returned (unless the loader would be ``None`` or is not set, in which case :"
"exc:`ValueError` is raised). Otherwise a search using :attr:`sys.meta_path` "
"is done. ``None`` is returned if no loader is found."
msgstr ""

#: ../../library/importlib.rst:124
msgid ""
"A dotted name does not have its parents implicitly imported as that requires "
"loading them and that may not be desired. To properly import a submodule you "
"will need to import all parent packages of the submodule and use the correct "
"argument to *path*."
msgstr ""

#: ../../library/importlib.rst:131
msgid ""
"If ``__loader__`` is not set, raise :exc:`ValueError`, just like when the "
"attribute is set to ``None``."
msgstr ""

#: ../../library/importlib.rst:135
msgid "Use :func:`importlib.util.find_spec` instead."
msgstr ""

#: ../../library/importlib.rst:140
msgid ""
"Invalidate the internal caches of finders stored at :data:`sys.meta_path`. "
"If a finder implements ``invalidate_caches()`` then it will be called to "
"perform the invalidation.  This function should be called if any modules are "
"created/installed while your program is running to guarantee all finders "
"will notice the new module's existence."
msgstr ""
"Invalida os caches internos dos localizadores armazenados em :data:`sys."
"meta_path`. Se um localizador implementar ``invalidate_caches()`` então ele "
"será chamado para realizar a invalidação. Esta função deve ser chamada se "
"algum módulo for criado/instalado enquanto seu programa estiver em execução "
"para garantir que todos os localizadores notarão a existência do novo módulo."

#: ../../library/importlib.rst:150
msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (which can be different if re-importing "
"causes a different object to be placed in :data:`sys.modules`)."
msgstr ""
"Recarrega um *module* importado anteriormente. O argumento deve ser um "
"objeto módulo, portanto deve ter sido importado com êxito antes. Isso é útil "
"se você editou o arquivo fonte do módulo usando um editor externo e deseja "
"experimentar a nova versão sem sair do interpretador Python. O valor de "
"retorno é o objeto módulo (que pode ser diferente se a reimportação fizer "
"com que um objeto diferente seja colocado em :data:`sys.modules`)."

#: ../../library/importlib.rst:157
msgid "When :func:`reload` is executed:"
msgstr "Quando :func:`reload` é executado:"

#: ../../library/importlib.rst:159
msgid ""
"Python module's code is recompiled and the module-level code re-executed, "
"defining a new set of objects which are bound to names in the module's "
"dictionary by reusing the :term:`loader` which originally loaded the "
"module.  The ``init`` function of extension modules is not called a second "
"time."
msgstr ""
"O código do módulo Python é recompilado e o código em nível de módulo é "
"reexecutado, definindo um novo conjunto de objetos que são vinculados a "
"nomes no dicionário do módulo reutilizando o :term:`carregador` que "
"originalmente carregou o módulo. A função ``init`` dos módulos de extensão "
"não é chamada uma segunda vez."

#: ../../library/importlib.rst:165
msgid ""
"As with all other objects in Python the old objects are only reclaimed after "
"their reference counts drop to zero."
msgstr ""
"Tal como acontece com todos os outros objetos em Python, os objetos antigos "
"só são recuperados depois que suas contagens de referências caem para zero."

#: ../../library/importlib.rst:168
msgid ""
"The names in the module namespace are updated to point to any new or changed "
"objects."
msgstr ""
"Os nomes no espaço de nomes do módulo são atualizados para apontar para "
"quaisquer objetos novos ou alterados."

#: ../../library/importlib.rst:171
msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr ""
"Outras referências aos objetos antigos (como nomes externos ao módulo) não "
"são religadas para se referir aos novos objetos e devem ser atualizadas em "
"cada espaço de nomes onde ocorrem, se isso for desejado."

#: ../../library/importlib.rst:175
msgid "There are a number of other caveats:"
msgstr "Existem várias outras ressalvas:"

#: ../../library/importlib.rst:177
msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"Quando um módulo é recarregado, seu dicionário (contendo as variáveis "
"globais do módulo) é retido. As redefinições de nomes vão substituir as "
"definições antigas, portanto isso geralmente não é um problema. Se a nova "
"versão de um módulo não definir um nome definido pela versão antiga, a "
"definição antiga permanecerá. Este recurso pode ser usado para vantagem do "
"módulo se ele mantiver uma tabela global ou cache de objetos -- com uma "
"instrução :keyword:`try` ele pode testar a presença da tabela e pular sua "
"inicialização se desejar::"

#: ../../library/importlib.rst:191
msgid ""
"It is generally not very useful to reload built-in or dynamically loaded "
"modules.  Reloading :mod:`sys`, :mod:`__main__`, :mod:`builtins` and other "
"key modules is not recommended.  In many cases extension modules are not "
"designed to be initialized more than once, and may fail in arbitrary ways "
"when reloaded."
msgstr ""
"Geralmente não é muito útil recarregar módulos embutidos ou carregados "
"dinamicamente. Recarregar :mod:`sys`, :mod:`__main__`, :mod:`builtins` e "
"outros módulos principais não é recomendado. Em muitos casos, os módulos de "
"extensão não são projetados para serem inicializados mais de uma vez e podem "
"falhar de maneiras arbitrárias quando recarregados."

#: ../../library/importlib.rst:197
msgid ""
"If a module imports objects from another module using :keyword:`from` ... :"
"keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`!from` statement, another is to use :keyword:`!import` "
"and qualified names (*module.name*) instead."
msgstr ""
"Se um módulo importa objetos de outro módulo usando :keyword:`from` ... :"
"keyword:`import` ..., chamar :func:`reload` para o outro módulo não redefine "
"os objetos importados dele -- uma maneira de contornar isso é executar "
"novamente a instrução :keyword:`!from`, outra é usar :keyword:`!import` e "
"nomes qualificados (*module.name*)."

#: ../../library/importlib.rst:203
msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr ""
"Se um módulo instancia instâncias de uma classe, recarregar o módulo que "
"define a classe não afeta as definições de método das instâncias -- elas "
"continuam a usar a definição de classe antiga. O mesmo se aplica às classes "
"derivadas."

#: ../../library/importlib.rst:209
msgid ""
":exc:`ModuleNotFoundError` is raised when the module being reloaded lacks a :"
"class:`ModuleSpec`."
msgstr ""

#: ../../library/importlib.rst:215
msgid ":mod:`importlib.abc` -- Abstract base classes related to import"
msgstr ""
":mod:`importlib.abc` -- classes base abstratas relacionadas a importação"

#: ../../library/importlib.rst:220
msgid "**Source code:** :source:`Lib/importlib/abc.py`"
msgstr "**Código-fonte:** :source:`Lib/importlib/abc.py`"

#: ../../library/importlib.rst:225
msgid ""
"The :mod:`importlib.abc` module contains all of the core abstract base "
"classes used by :keyword:`import`. Some subclasses of the core abstract base "
"classes are also provided to help in implementing the core ABCs."
msgstr ""
"O módulo :mod:`importlib.abc` contém todas as principais classes base "
"abstratas usadas por :keyword:`import`. Algumas subclasses das classes base "
"abstratas principais também são fornecidas para ajudar na implementação dss "
"ABCs principais."

#: ../../library/importlib.rst:229
msgid "ABC hierarchy::"
msgstr "Hierarquia de ABC::"

#: ../../library/importlib.rst:245
msgid "An abstract base class representing a :term:`finder`."
msgstr ""

#: ../../library/importlib.rst:247
msgid "Use :class:`MetaPathFinder` or :class:`PathEntryFinder` instead."
msgstr ""

#: ../../library/importlib.rst:252
msgid ""
"An abstract method for finding a :term:`loader` for the specified module.  "
"Originally specified in :pep:`302`, this method was meant for use in :data:"
"`sys.meta_path` and in the path-based import subsystem."
msgstr ""

#: ../../library/importlib.rst:256
msgid ""
"Returns ``None`` when called instead of raising :exc:`NotImplementedError`."
msgstr ""

#: ../../library/importlib.rst:263
msgid ""
"An abstract base class representing a :term:`meta path finder`. For "
"compatibility, this is a subclass of :class:`Finder`."
msgstr ""

#: ../../library/importlib.rst:270
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  If this is a top-level import, *path* will be ``None``.  "
"Otherwise, this is a search for a subpackage or module and *path* will be "
"the value of :attr:`__path__` from the parent package. If a spec cannot be "
"found, ``None`` is returned. When passed in, ``target`` is a module object "
"that the finder may use to make a more educated guess about what spec to "
"return. :func:`importlib.util.spec_from_loader` may be useful for "
"implementing concrete ``MetaPathFinders``."
msgstr ""
"Um método abstrato para encontrar um :term:`spec <module spec>` para o "
"módulo especificado. Se esta for uma importação de nível superior, *path* "
"será ``None``. Caso contrário, esta é uma busca por um subpacote ou módulo e "
"*path* será o valor de :attr:`__path__` do pacote pai. Se uma especificação "
"não puder ser encontrada, ``None`` será retornado. Quando passado, "
"``target`` é um objeto de módulo que o localizador pode usar para fazer uma "
"estimativa mais informada sobre qual especificação retornar. :func:"
"`importlib.util.spec_from_loader` pode ser útil para implementar "
"``MetaPathFinders`` concretos."

#: ../../library/importlib.rst:284
msgid ""
"A legacy method for finding a :term:`loader` for the specified module.  If "
"this is a top-level import, *path* will be ``None``. Otherwise, this is a "
"search for a subpackage or module and *path* will be the value of :attr:"
"`__path__` from the parent package. If a loader cannot be found, ``None`` is "
"returned."
msgstr ""

#: ../../library/importlib.rst:290
msgid ""
"If :meth:`find_spec` is defined, backwards-compatible functionality is "
"provided."
msgstr ""

#: ../../library/importlib.rst:293
msgid ""
"Returns ``None`` when called instead of raising :exc:`NotImplementedError`. "
"Can use :meth:`find_spec` to provide functionality."
msgstr ""

#: ../../library/importlib.rst:298 ../../library/importlib.rst:352
#: ../../library/importlib.rst:360 ../../library/importlib.rst:1086
msgid "Use :meth:`find_spec` instead."
msgstr ""

#: ../../library/importlib.rst:303
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :func:`importlib.invalidate_caches` when "
"invalidating the caches of all finders on :data:`sys.meta_path`."
msgstr ""
"Um método opcional que, quando chamado, deve invalidar qualquer cache "
"interno usado pelo localizador. Usado por :func:`importlib."
"invalidate_caches` ao invalidar os caches de todos os localizadores em :data:"
"`sys.meta_path`."

#: ../../library/importlib.rst:307
msgid "Returns ``None`` when called instead of ``NotImplemented``."
msgstr ""

#: ../../library/importlib.rst:313
msgid ""
"An abstract base class representing a :term:`path entry finder`.  Though it "
"bears some similarities to :class:`MetaPathFinder`, ``PathEntryFinder`` is "
"meant for use only within the path-based import subsystem provided by :class:"
"`PathFinder`. This ABC is a subclass of :class:`Finder` for compatibility "
"reasons only."
msgstr ""

#: ../../library/importlib.rst:323
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  The finder will search for the module only within the :"
"term:`path entry` to which it is assigned.  If a spec cannot be found, "
"``None`` is returned.  When passed in, ``target`` is a module object that "
"the finder may use to make a more educated guess about what spec to return. :"
"func:`importlib.util.spec_from_loader` may be useful for implementing "
"concrete ``PathEntryFinders``."
msgstr ""
"Um método abstrato para encontrar um :term:`spec <module spec>` para o "
"módulo especificado. O localizador irá procurar pelo módulo apenas dentro "
"do :term:`entrada de caminho` ao qual ele está atribuído. Se uma "
"especificação não puder ser encontrada, ``None`` será retornado. Quando "
"passado, ``target`` é um objeto de módulo que o localizador pode usar para "
"fazer uma estimativa mais informada sobre qual especificação retornar. :func:"
"`importlib.util.spec_from_loader` pode ser útil para implementar "
"``PathEntryFinders`` concretos."

#: ../../library/importlib.rst:335
msgid ""
"A legacy method for finding a :term:`loader` for the specified module.  "
"Returns a 2-tuple of ``(loader, portion)`` where ``portion`` is a sequence "
"of file system locations contributing to part of a namespace package. The "
"loader may be ``None`` while specifying ``portion`` to signify the "
"contribution of the file system locations to a namespace package. An empty "
"list can be used for ``portion`` to signify the loader is not part of a "
"namespace package. If ``loader`` is ``None`` and ``portion`` is the empty "
"list then no loader or location for a namespace package were found (i.e. "
"failure to find anything for the module)."
msgstr ""

#: ../../library/importlib.rst:345
msgid ""
"If :meth:`find_spec` is defined then backwards-compatible functionality is "
"provided."
msgstr ""

#: ../../library/importlib.rst:348
msgid ""
"Returns ``(None, [])`` instead of raising :exc:`NotImplementedError`. Uses :"
"meth:`find_spec` when available to provide functionality."
msgstr ""

#: ../../library/importlib.rst:357
msgid ""
"A concrete implementation of :meth:`Finder.find_module` which is equivalent "
"to ``self.find_loader(fullname)[0]``."
msgstr ""

#: ../../library/importlib.rst:365
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :meth:`PathFinder.invalidate_caches` when "
"invalidating the caches of all cached finders."
msgstr ""

#: ../../library/importlib.rst:372
msgid ""
"An abstract base class for a :term:`loader`. See :pep:`302` for the exact "
"definition for a loader."
msgstr ""
"Uma classe base abstrata para um :term:`carregador`. Veja :pep:`302` para a "
"definição exata de um carregador."

#: ../../library/importlib.rst:375 ../../library/importlib.rst:836
msgid ""
"Loaders that wish to support resource reading should implement a "
"``get_resource_reader(fullname)`` method as specified by :class:`importlib."
"abc.ResourceReader`."
msgstr ""

#: ../../library/importlib.rst:379
msgid "Introduced the optional ``get_resource_reader()`` method."
msgstr ""

#: ../../library/importlib.rst:384
msgid ""
"A method that returns the module object to use when importing a module.  "
"This method may return ``None``, indicating that default module creation "
"semantics should take place."
msgstr ""
"Um método que retorna o objeto do módulo a ser usado ao importar um módulo. "
"Este método pode retornar ``None``, indicando que a semântica padrão de "
"criação do módulo deve ocorrer."

#: ../../library/importlib.rst:390
msgid ""
"Starting in Python 3.6, this method will not be optional when :meth:"
"`exec_module` is defined."
msgstr ""

#: ../../library/importlib.rst:396
msgid ""
"An abstract method that executes the module in its own namespace when a "
"module is imported or reloaded.  The module should already be initialized "
"when ``exec_module()`` is called. When this method exists, :meth:`~importlib."
"abc.Loader.create_module` must be defined."
msgstr ""

#: ../../library/importlib.rst:403
msgid ":meth:`~importlib.abc.Loader.create_module` must also be defined."
msgstr ":meth:`~importlib.abc.Loader.create_module` precisa ser definida."

#: ../../library/importlib.rst:408
msgid ""
"A legacy method for loading a module. If the module cannot be loaded, :exc:"
"`ImportError` is raised, otherwise the loaded module is returned."
msgstr ""

#: ../../library/importlib.rst:412
msgid ""
"If the requested module already exists in :data:`sys.modules`, that module "
"should be used and reloaded. Otherwise the loader should create a new module "
"and insert it into :data:`sys.modules` before any loading begins, to prevent "
"recursion from the import. If the loader inserted a module and the load "
"fails, it must be removed by the loader from :data:`sys.modules`; modules "
"already in :data:`sys.modules` before the loader began execution should be "
"left alone (see :func:`importlib.util.module_for_loader`)."
msgstr ""

#: ../../library/importlib.rst:421
msgid ""
"The loader should set several attributes on the module. (Note that some of "
"these attributes can change when a module is reloaded):"
msgstr ""

#: ../../library/importlib.rst:426
msgid ":attr:`__name__`"
msgstr ":attr:`__name__`"

#: ../../library/importlib.rst:426
msgid "The name of the module."
msgstr "O nome do módulo."

#: ../../library/importlib.rst:430
msgid ":attr:`__file__`"
msgstr ":attr:`__file__`"

#: ../../library/importlib.rst:429
msgid ""
"The path to where the module data is stored (not set for built-in modules)."
msgstr ""

#: ../../library/importlib.rst:434
msgid ":attr:`__cached__`"
msgstr ":attr:`__cached__`"

#: ../../library/importlib.rst:433
msgid ""
"The path to where a compiled version of the module is/should be stored (not "
"set when the attribute would be inappropriate)."
msgstr ""

#: ../../library/importlib.rst:438
msgid ":attr:`__path__`"
msgstr ":attr:`__path__`"

#: ../../library/importlib.rst:437
msgid ""
"A list of strings specifying the search path within a package. This "
"attribute is not set on modules."
msgstr ""

#: ../../library/importlib.rst:445
msgid ":attr:`__package__`"
msgstr ":attr:`__package__`"

#: ../../library/importlib.rst:441
msgid ""
"The fully-qualified name of the package under which the module was loaded as "
"a submodule (or the empty string for top-level modules). For packages, it is "
"the same as :attr:`__name__`.  The :func:`importlib.util.module_for_loader` "
"decorator can handle the details for :attr:`__package__`."
msgstr ""

#: ../../library/importlib.rst:450
msgid ":attr:`__loader__`"
msgstr ":attr:`__loader__`"

#: ../../library/importlib.rst:448
msgid ""
"The loader used to load the module. The :func:`importlib.util."
"module_for_loader` decorator can handle the details for :attr:`__package__`."
msgstr ""

#: ../../library/importlib.rst:452
msgid ""
"When :meth:`exec_module` is available then backwards-compatible "
"functionality is provided."
msgstr ""
"Quando :meth:`exec_module` está disponível, então a funcionalidade "
"compatível com versões anteriores é fornecida."

#: ../../library/importlib.rst:455
msgid ""
"Raise :exc:`ImportError` when called instead of :exc:`NotImplementedError`. "
"Functionality provided when :meth:`exec_module` is available."
msgstr ""

#: ../../library/importlib.rst:460
msgid ""
"The recommended API for loading a module is :meth:`exec_module` (and :meth:"
"`create_module`).  Loaders should implement it instead of load_module().  "
"The import machinery takes care of all the other responsibilities of "
"load_module() when exec_module() is implemented."
msgstr ""

#: ../../library/importlib.rst:469
msgid ""
"A legacy method which when implemented calculates and returns the given "
"module's repr, as a string. The module type's default repr() will use the "
"result of this method as appropriate."
msgstr ""

#: ../../library/importlib.rst:475
msgid "Made optional instead of an abstractmethod."
msgstr ""

#: ../../library/importlib.rst:478
msgid "The import machinery now takes care of this automatically."
msgstr ""

#: ../../library/importlib.rst:484
msgid ""
"An :term:`abstract base class` to provide the ability to read *resources*."
msgstr ""
"Uma :term:`classe base abstrata` para fornecer a capacidade de ler "
"*recursos*."

#: ../../library/importlib.rst:487
msgid ""
"From the perspective of this ABC, a *resource* is a binary artifact that is "
"shipped within a package. Typically this is something like a data file that "
"lives next to the ``__init__.py`` file of the package. The purpose of this "
"class is to help abstract out the accessing of such data files so that it "
"does not matter if the package and its data file(s) are stored in a e.g. zip "
"file versus on the file system."
msgstr ""
"Da perspectiva deste ABC, um *recurso* é um artefato binário que é enviado "
"dentro de um pacote. Normalmente isso é algo como um arquivo de dados que "
"fica próximo ao arquivo ``__init__.py`` do pacote. O objetivo desta classe é "
"ajudar a abstrair o acesso a tais arquivos de dados para que não importe se "
"o pacote e seu(s) arquivo(s) de dados estão armazenados em um arquivo, por "
"exemplo, zip versus no sistema de arquivos."

#: ../../library/importlib.rst:495
msgid ""
"For any of methods of this class, a *resource* argument is expected to be a :"
"term:`path-like object` which represents conceptually just a file name. This "
"means that no subdirectory paths should be included in the *resource* "
"argument. This is because the location of the package the reader is for, "
"acts as the \"directory\". Hence the metaphor for directories and file names "
"is packages and resources, respectively. This is also why instances of this "
"class are expected to directly correlate to a specific package (instead of "
"potentially representing multiple packages or a module)."
msgstr ""
"Para qualquer um dos métodos desta classe, espera-se que o argumento "
"*resource* seja um :term:`objeto caminho ou similar` que representa "
"conceitualmente apenas um nome de arquivo. Isso significa que nenhum caminho "
"de subdiretório deve ser incluído no argumento *resource*. Isso ocorre "
"porque a localização do pacote para o qual o leitor se destina, atua como o "
"\"diretório\". Portanto, a metáfora para diretórios e nomes de arquivos são "
"pacotes e recursos, respectivamente. É também por isso que se espera que as "
"instâncias dessa classe se correlacionem diretamente a um pacote específico "
"(em vez de representar potencialmente vários pacotes ou um módulo)."

#: ../../library/importlib.rst:506
msgid ""
"Loaders that wish to support resource reading are expected to provide a "
"method called ``get_resource_reader(fullname)`` which returns an object "
"implementing this ABC's interface. If the module specified by fullname is "
"not a package, this method should return :const:`None`. An object compatible "
"with this ABC should only be returned when the specified module is a package."
msgstr ""
"Carregadores que desejam oferecer suporte à leitura de recursos devem "
"fornecer um método chamado ``get_resource_reader(nomecompleto)`` que retorna "
"um objeto implementando esta interface ABC. Se o módulo especificado por "
"nomecompleto não for um pacote, este método deve retornar :const:`None`. Um "
"objeto compatível com este ABC só deve ser retornado quando o módulo "
"especificado for um pacote."

#: ../../library/importlib.rst:517
msgid ""
"Returns an opened, :term:`file-like object` for binary reading of the "
"*resource*."
msgstr ""
"Retorna um :term:`objeto arquivo ou similar` aberto para leitura binária de "
"*resource*."

#: ../../library/importlib.rst:520
msgid "If the resource cannot be found, :exc:`FileNotFoundError` is raised."
msgstr ""
"Se o recurso não puder ser encontrado, :exc:`FileNotFoundError` é levantada."

#: ../../library/importlib.rst:525
msgid "Returns the file system path to the *resource*."
msgstr "Retorna o caminho do sistema de arquivos para *resource*."

#: ../../library/importlib.rst:527
msgid ""
"If the resource does not concretely exist on the file system, raise :exc:"
"`FileNotFoundError`."
msgstr ""
"Se o recurso não existir concretamente no sistema de arquivos, levanta :exc:"
"`FileNotFoundError`."

#: ../../library/importlib.rst:532
msgid ""
"Returns ``True`` if the named *name* is considered a resource. :exc:"
"`FileNotFoundError` is raised if *name* does not exist."
msgstr ""
"Retorna ``True`` se o *name* nomeado for considerado um recurso. :exc:"
"`FileNotFoundError` é levantada se *name* não existir."

#: ../../library/importlib.rst:537
msgid ""
"Returns an :term:`iterable` of strings over the contents of the package. Do "
"note that it is not required that all names returned by the iterator be "
"actual resources, e.g. it is acceptable to return names for which :meth:"
"`is_resource` would be false."
msgstr ""
"Retorna um :term:`iterável` de strings sobre o conteúdo do pacote. Observe "
"que não é necessário que todos os nomes retornados pelo iterador sejam "
"recursos reais, por exemplo, é aceitável retornar nomes para os quais :meth:"
"`is_resource` seria falso."

#: ../../library/importlib.rst:543
msgid ""
"Allowing non-resource names to be returned is to allow for situations where "
"how a package and its resources are stored are known a priori and the non-"
"resource names would be useful. For instance, returning subdirectory names "
"is allowed so that when it is known that the package and resources are "
"stored on the file system then those subdirectory names can be used directly."
msgstr ""
"Permitir que nomes que não são recursos sejam retornados é permitir "
"situações em que a forma como um pacote e seus recursos são armazenados é "
"conhecida a priori e os nomes que não são recursos seriam úteis. Por "
"exemplo, o retorno de nomes de subdiretórios é permitido para que, quando se "
"souber que o pacote e os recursos estão armazenados no sistema de arquivos, "
"esses nomes de subdiretórios possam ser usados diretamente."

#: ../../library/importlib.rst:551
msgid "The abstract method returns an iterable of no items."
msgstr "O método abstrato retorna um iterável sem itens."

#: ../../library/importlib.rst:556
msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loading arbitrary resources from the storage back-end."
msgstr ""
"Uma classe base abstrata para um :term:`carregador` que implementa o "
"protocolo opcional :pep:`302` para carregar recursos arbitrários do back-end "
"de armazenamento."

#: ../../library/importlib.rst:560
msgid ""
"This ABC is deprecated in favour of supporting resource loading through :"
"class:`importlib.abc.ResourceReader`."
msgstr ""

#: ../../library/importlib.rst:566
msgid ""
"An abstract method to return the bytes for the data located at *path*. "
"Loaders that have a file-like storage back-end that allows storing arbitrary "
"data can implement this abstract method to give direct access to the data "
"stored. :exc:`OSError` is to be raised if the *path* cannot be found. The "
"*path* is expected to be constructed using a module's :attr:`__file__` "
"attribute or an item from a package's :attr:`__path__`."
msgstr ""
"Um método abstrato para retornar os bytes dos dados localizados em *path*. "
"Carregadores que possuem um backend de armazenamento arquivo ou similar que "
"permite o armazenamento de dados arbitrários podem implementar esse método "
"abstrato para fornecer acesso direto aos dados armazenados. :exc:`OSError` "
"deve ser levantada se o *path* não puder ser encontrado. Espera-se que o "
"*path* seja construído usando o atributo :attr:`__file__` de um módulo ou um "
"item de :attr:`__path__` de um pacote."

#: ../../library/importlib.rst:574
msgid "Raises :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Levanta :exc:`OSError` em vez de :exc:`NotImplementedError`."

#: ../../library/importlib.rst:580
msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loaders that inspect modules."
msgstr ""
"Uma classe base abstrata para um :term:`carregador` que implementa o "
"protocolo opcional da :pep:`302` para carregadores que inspecionam módulos."

#: ../../library/importlib.rst:585
msgid ""
"Return the code object for a module, or ``None`` if the module does not have "
"a code object (as would be the case, for example, for a built-in module).  "
"Raise an :exc:`ImportError` if loader cannot find the requested module."
msgstr ""
"Retorna o objeto de código para um módulo, ou ``None`` se o módulo não tiver "
"um objeto código (como seria o caso, por exemplo, para um módulo embutido). "
"Levanta um :exc:`ImportError` se o carregador não conseguir encontrar o "
"módulo solicitado."

#: ../../library/importlib.rst:591
msgid ""
"While the method has a default implementation, it is suggested that it be "
"overridden if possible for performance."
msgstr ""
"Embora o método tenha uma implementação padrão, sugere-se que ele seja "
"substituído, se possível, para desempenho."

#: ../../library/importlib.rst:597
msgid "No longer abstract and a concrete implementation is provided."
msgstr "Não é mais abstrato e uma implementação concreta é fornecida."

#: ../../library/importlib.rst:602
msgid ""
"An abstract method to return the source of a module. It is returned as a "
"text string using :term:`universal newlines`, translating all recognized "
"line separators into ``'\\n'`` characters.  Returns ``None`` if no source is "
"available (e.g. a built-in module). Raises :exc:`ImportError` if the loader "
"cannot find the module specified."
msgstr ""
"Um método abstrato para retornar a fonte de um módulo. Ele é retornado como "
"uma string de texto usando :term:`novas linhas universais`, traduzindo todos "
"os separadores de linha reconhecidos em caracteres ``'\\n'``. Retorna "
"``None`` se nenhuma fonte estiver disponível (por exemplo, um módulo "
"embutido). Levanta :exc:`ImportError` se o carregador não puder encontrar o "
"módulo especificado."

#: ../../library/importlib.rst:608 ../../library/importlib.rst:617
#: ../../library/importlib.rst:667
msgid "Raises :exc:`ImportError` instead of :exc:`NotImplementedError`."
msgstr "Levanta :exc:`ImportError` em vez de :exc:`NotImplementedError`."

#: ../../library/importlib.rst:613
msgid ""
"An abstract method to return a true value if the module is a package, a "
"false value otherwise. :exc:`ImportError` is raised if the :term:`loader` "
"cannot find the module."
msgstr ""

#: ../../library/importlib.rst:622
msgid "Create a code object from Python source."
msgstr "Cria um objeto código a partir de código-fonte Python"

#: ../../library/importlib.rst:624
msgid ""
"The *data* argument can be whatever the :func:`compile` function supports (i."
"e. string or bytes). The *path* argument should be the \"path\" to where the "
"source code originated from, which can be an abstract concept (e.g. location "
"in a zip file)."
msgstr ""
"O argumento *data* pode ser qualquer coisa a qual a função :func:`compile` "
"tenha suporte (por exemplo, string ou bytes). O argumento *path* deve ser o "
"\"caminho\" de onde o código-fonte se originou, o que pode ser um conceito "
"abstrato (por exemplo, local em um arquivo zip)."

#: ../../library/importlib.rst:629
msgid ""
"With the subsequent code object one can execute it in a module by running "
"``exec(code, module.__dict__)``."
msgstr ""
"Com o objeto de código subsequente, é possível executá-lo em um módulo "
"executando ``exec(code, module.__dict__)``."

#: ../../library/importlib.rst:634
msgid "Made the method static."
msgstr "O método foi tornado estático."

#: ../../library/importlib.rst:639
msgid "Implementation of :meth:`Loader.exec_module`."
msgstr "Implementação de :meth:`Loader.exec_module`."

#: ../../library/importlib.rst:645
msgid "Implementation of :meth:`Loader.load_module`."
msgstr "Implementação de :meth:`Loader.load_module`."

#: ../../library/importlib.rst:647
msgid "use :meth:`exec_module` instead."
msgstr "use :meth:`exec_module`."

#: ../../library/importlib.rst:653
msgid ""
"An abstract base class which inherits from :class:`InspectLoader` that, when "
"implemented, helps a module to be executed as a script. The ABC represents "
"an optional :pep:`302` protocol."
msgstr ""
"Uma classe base abstrata que herda de :class:`InspectLoader` que, quando "
"implementada, ajuda um módulo a ser executado como um script. A ABC "
"representa um protocolo opcional da :pep:`302`."

#: ../../library/importlib.rst:659
msgid ""
"An abstract method that is to return the value of :attr:`__file__` for the "
"specified module. If no path is available, :exc:`ImportError` is raised."
msgstr ""
"Um método abstrato que deve retornar o valor de :attr:`__file__` para o "
"módulo especificado. Se nenhum caminho estiver disponível, :exc:"
"`ImportError` é levantada."

#: ../../library/importlib.rst:663
msgid ""
"If source code is available, then the method should return the path to the "
"source file, regardless of whether a bytecode was used to load the module."
msgstr ""
"Se o código-fonte estiver disponível, o método deverá retornar o caminho "
"para o arquivo fonte, independentemente de um bytecode ter sido usado para "
"carregar o módulo."

#: ../../library/importlib.rst:673
msgid ""
"An abstract base class which inherits from :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, providing concrete implementations of :meth:"
"`ResourceLoader.get_data` and :meth:`ExecutionLoader.get_filename`."
msgstr ""
"Uma classe base abstrata que herda de :class:`ResourceLoader` e :class:"
"`ExecutionLoader`, fornecendo implementações concretas de :meth:"
"`ResourceLoader.get_data` e :meth:`ExecutionLoader.get_filename`."

#: ../../library/importlib.rst:677
msgid ""
"The *fullname* argument is a fully resolved name of the module the loader is "
"to handle. The *path* argument is the path to the file for the module."
msgstr ""
"O argumento *fullname* é um nome totalmente resolvido do módulo que o "
"carregador deve manipular. O argumento *path* é o caminho para o arquivo do "
"módulo."

#: ../../library/importlib.rst:684
msgid "The name of the module the loader can handle."
msgstr "O nome do módulo que o carregador pode manipular."

#: ../../library/importlib.rst:688
msgid "Path to the file of the module."
msgstr "Caminho para o arquivo do módulo"

#: ../../library/importlib.rst:692
msgid "Calls super's ``load_module()``."
msgstr "Chama ``load_module()`` do super."

#: ../../library/importlib.rst:694
msgid "Use :meth:`Loader.exec_module` instead."
msgstr "Use :meth:`Loader.exec_module`"

#: ../../library/importlib.rst:699 ../../library/importlib.rst:1285
msgid "Returns :attr:`path`."
msgstr "Retorna :attr:`path`."

#: ../../library/importlib.rst:703
msgid "Reads *path* as a binary file and returns the bytes from it."
msgstr "Lê *caminho* como um arquivo binário e retorna os bytes dele."

#: ../../library/importlib.rst:708
msgid ""
"An abstract base class for implementing source (and optionally bytecode) "
"file loading. The class inherits from both :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, requiring the implementation of:"
msgstr ""
"Uma classe base abstrata para implementar o carregamento de arquivo fonte (e "
"opcionalmente bytecode). A classe herda de :class:`ResourceLoader` e :class:"
"`ExecutionLoader`, exigindo a implementação de:"

#: ../../library/importlib.rst:712
msgid ":meth:`ResourceLoader.get_data`"
msgstr ":meth:`ResourceLoader.get_data`"

#: ../../library/importlib.rst:715
msgid ":meth:`ExecutionLoader.get_filename`"
msgstr ":meth:`ExecutionLoader.get_filename`"

#: ../../library/importlib.rst:714
msgid ""
"Should only return the path to the source file; sourceless loading is not "
"supported."
msgstr ""
"Deve retornar apenas o caminho para o arquivo fonte; o carregamento sem "
"fonte não é suportado."

#: ../../library/importlib.rst:717
msgid ""
"The abstract methods defined by this class are to add optional bytecode file "
"support. Not implementing these optional methods (or causing them to raise :"
"exc:`NotImplementedError`) causes the loader to only work with source code. "
"Implementing the methods allows the loader to work with source *and* "
"bytecode files; it does not allow for *sourceless* loading where only "
"bytecode is provided.  Bytecode files are an optimization to speed up "
"loading by removing the parsing step of Python's compiler, and so no "
"bytecode-specific API is exposed."
msgstr ""
"Os métodos abstratos definidos por esta classe são para adicionar suporte "
"opcional ao arquivo bytecode. Não implementar esses métodos opcionais (ou "
"fazer com que eles levantem :exc:`NotImplementedError`) faz com que o "
"carregador funcione apenas com código-fonte. Implementar os métodos permite "
"que o carregador funcione com arquivos de código-fonte *e* bytecode; ele não "
"permite carregamento *sem fonte* onde apenas o bytecode é fornecido. "
"Arquivos de bytecode são uma otimização para acelerar o carregamento "
"removendo a etapa de análise do compilador do Python e, portanto, nenhuma "
"API específica de bytecode é exposta."

#: ../../library/importlib.rst:728
msgid ""
"Optional abstract method which returns a :class:`dict` containing metadata "
"about the specified path.  Supported dictionary keys are:"
msgstr ""
"Método abstrato opcional que retorna um :class:`dict` contendo metadados "
"sobre o caminho especificado. As chaves de dicionário suportadas são:"

#: ../../library/importlib.rst:731
msgid ""
"``'mtime'`` (mandatory): an integer or floating-point number representing "
"the modification time of the source code;"
msgstr ""
"``'mtime'`` (obrigatório): um número inteiro ou de ponto flutuante que "
"representa o tempo de modificação do código-fonte;"

#: ../../library/importlib.rst:733
msgid "``'size'`` (optional): the size in bytes of the source code."
msgstr "``'size'`` (opcional): o tamanho em bytes do código-fonte."

#: ../../library/importlib.rst:735
msgid ""
"Any other keys in the dictionary are ignored, to allow for future "
"extensions. If the path cannot be handled, :exc:`OSError` is raised."
msgstr ""
"Quaisquer outras chaves no dicionário são ignoradas, para permitir extensões "
"futuras. Se o caminho não puder ser manipulado, :exc:`OSError` é levantada."

#: ../../library/importlib.rst:740 ../../library/importlib.rst:753
msgid "Raise :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Levanta :exc:`OSError` em vez de :exc:`NotImplementedError`."

#: ../../library/importlib.rst:745
msgid ""
"Optional abstract method which returns the modification time for the "
"specified path."
msgstr ""
"Método abstrato opcional que retorna o horário de modificação do caminho "
"especificado."

#: ../../library/importlib.rst:748
msgid ""
"This method is deprecated in favour of :meth:`path_stats`.  You don't have "
"to implement it, but it is still available for compatibility purposes. "
"Raise :exc:`OSError` if the path cannot be handled."
msgstr ""
"Este método foi descontinuado em favor de :meth:`path_stats`. Você não "
"precisa implementá-lo, mas ele ainda está disponível para fins de "
"compatibilidade. Levanta :exc:`OSError` se o caminho não puder ser "
"manipulado."

#: ../../library/importlib.rst:758
msgid ""
"Optional abstract method which writes the specified bytes to a file path. "
"Any intermediate directories which do not exist are to be created "
"automatically."
msgstr ""
"Método abstrato opcional que grava os bytes especificados em um caminho de "
"arquivo. Quaisquer diretórios intermediários que não existam devem ser "
"criados automaticamente."

#: ../../library/importlib.rst:762
msgid ""
"When writing to the path fails because the path is read-only (:attr:`errno."
"EACCES`/:exc:`PermissionError`), do not propagate the exception."
msgstr ""

#: ../../library/importlib.rst:766
msgid "No longer raises :exc:`NotImplementedError` when called."
msgstr "Não mais levanta :exc:`NotImplementedError` quando chamado."

#: ../../library/importlib.rst:771
msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
msgstr "Implementação concreta de :meth:`InspectLoader.get_code`."

#: ../../library/importlib.rst:775
msgid "Concrete implementation of :meth:`Loader.exec_module`."
msgstr "Implementação concreta de :meth:`Loader.exec_module`."

#: ../../library/importlib.rst:781
msgid "Concrete implementation of :meth:`Loader.load_module`."
msgstr "Implementação concreta de :meth:`Loader.load_module`."

#: ../../library/importlib.rst:783
msgid "Use :meth:`exec_module` instead."
msgstr "Use :meth:`exec_module`."

#: ../../library/importlib.rst:788
msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
msgstr "Implementação concreta de :meth:`InspectLoader.get_source`."

#: ../../library/importlib.rst:792
msgid ""
"Concrete implementation of :meth:`InspectLoader.is_package`. A module is "
"determined to be a package if its file path (as provided by :meth:"
"`ExecutionLoader.get_filename`) is a file named ``__init__`` when the file "
"extension is removed **and** the module name itself does not end in "
"``__init__``."
msgstr ""
"Implementação concreta de :meth:`InspectLoader.is_package`. Um módulo é "
"determinado como um pacote se seu caminho de arquivo (conforme fornecido "
"por :meth:`ExecutionLoader.get_filename`) for um arquivo chamado "
"``__init__`` quando a extensão do arquivo for removida **e** o nome do "
"módulo em si não terminar em ``__init__``."

#: ../../library/importlib.rst:800
msgid ":mod:`importlib.resources` -- Resources"
msgstr ":mod:`importlib.resources` -- Recursos"

#: ../../library/importlib.rst:805
msgid "**Source code:** :source:`Lib/importlib/resources.py`"
msgstr ""

#: ../../library/importlib.rst:811
msgid ""
"This module leverages Python's import system to provide access to "
"*resources* within *packages*.  If you can import a package, you can access "
"resources within that package.  Resources can be opened or read, in either "
"binary or text mode."
msgstr ""

#: ../../library/importlib.rst:816
msgid ""
"Resources are roughly akin to files inside directories, though it's "
"important to keep in mind that this is just a metaphor.  Resources and "
"packages **do not** have to exist as physical files and directories on the "
"file system."
msgstr ""

#: ../../library/importlib.rst:822
msgid ""
"This module provides functionality similar to `pkg_resources <https://"
"setuptools.readthedocs.io/en/latest/pkg_resources.html>`_ `Basic Resource "
"Access <http://setuptools.readthedocs.io/en/latest/pkg_resources.html#basic-"
"resource-access>`_ without the performance overhead of that package.  This "
"makes reading resources included in packages easier, with more stable and "
"consistent semantics."
msgstr ""

#: ../../library/importlib.rst:830
msgid ""
"The standalone backport of this module provides more information on `using "
"importlib.resources <http://importlib-resources.readthedocs.io/en/latest/"
"using.html>`_ and `migrating from pkg_resources to importlib.resources "
"<http://importlib-resources.readthedocs.io/en/latest/migration.html>`_."
msgstr ""

#: ../../library/importlib.rst:840
msgid "The following types are defined."
msgstr ""

#: ../../library/importlib.rst:844
msgid ""
"The ``Package`` type is defined as ``Union[str, ModuleType]``.  This means "
"that where the function describes accepting a ``Package``, you can pass in "
"either a string or a module.  Module objects must have a resolvable "
"``__spec__.submodule_search_locations`` that is not ``None``."
msgstr ""

#: ../../library/importlib.rst:851
msgid ""
"This type describes the resource names passed into the various functions in "
"this package.  This is defined as ``Union[str, os.PathLike]``."
msgstr ""

#: ../../library/importlib.rst:855
msgid "The following functions are available."
msgstr ""

#: ../../library/importlib.rst:859
msgid "Open for binary reading the *resource* within *package*."
msgstr "Abre para leitura binária o *resource* dentro do *package*."

#: ../../library/importlib.rst:861
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open "
"within *package*; it may not contain path separators and it may not have sub-"
"resources (i.e. it cannot be a directory).  This function returns a ``typing."
"BinaryIO`` instance, a binary I/O stream open for reading."
msgstr ""
"*package* é um nome ou um objeto módulo que está em conformidade com os "
"requisitos do ``Package``. *resource* é o nome do recurso a ser aberto "
"dentro de *package*; ele não pode conter separadores de caminho e não pode "
"ter sub-recursos (ou seja, não pode ser um diretório). Essa função retorna "
"uma instância de ``typing.BinaryIO``, um fluxo de E/S binário aberto para "
"leitura."

#: ../../library/importlib.rst:870
msgid ""
"Open for text reading the *resource* within *package*.  By default, the "
"resource is opened for reading as UTF-8."
msgstr ""
"Abre para leitura de texto o *resource* dentro do *package*.  Por padrão, o "
"recurso é aberto para leitura como UTF-8."

#: ../../library/importlib.rst:873
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open "
"within *package*; it may not contain path separators and it may not have sub-"
"resources (i.e. it cannot be a directory).  *encoding* and *errors* have the "
"same meaning as with built-in :func:`open`."
msgstr ""
"*package* é um nome ou um objeto módulo que está em conformidade com os "
"requisitos do ``Package``. *resource* é o nome do recurso a ser aberto "
"dentro de *package*; ele não pode conter separadores de caminho e não pode "
"ter sub-recursos (ou seja, não pode ser um diretório). *encoding* e *errors* "
"têm o mesmo significado que com :func:`open` embutido."

#: ../../library/importlib.rst:879
msgid ""
"This function returns a ``typing.TextIO`` instance, a text I/O stream open "
"for reading."
msgstr ""
"Essa função retorna uma instância de ``typing.TextIO``, um fluxo de E/S de "
"texto aberto para leitura."

#: ../../library/importlib.rst:885
msgid ""
"Read and return the contents of the *resource* within *package* as ``bytes``."
msgstr ""
"Lê e retorna o conteúdo do *resource* dentro do *package* como ``bytes``."

#: ../../library/importlib.rst:888
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open "
"within *package*; it may not contain path separators and it may not have sub-"
"resources (i.e. it cannot be a directory).  This function returns the "
"contents of the resource as :class:`bytes`."
msgstr ""
"*package* é um nome ou um objeto módulo que está em conformidade com os "
"requisitos do ``Package``. *resource* é o nome do recurso a ser aberto "
"dentro de *package*; ele não pode conter separadores de caminho e não pode "
"ter sub-recursos (ou seja, não pode ser um diretório). Essa função retorna o "
"conteúdo do recurso como :class:`bytes`."

#: ../../library/importlib.rst:897
msgid ""
"Read and return the contents of *resource* within *package* as a ``str``. By "
"default, the contents are read as strict UTF-8."
msgstr ""
"Lê e retorna o conteúdo de *resource* em *package* como ``str``. Por padrão, "
"o conteúdo é lido como UTF-8 estrito."

#: ../../library/importlib.rst:900
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open "
"within *package*; it may not contain path separators and it may not have sub-"
"resources (i.e. it cannot be a directory).  *encoding* and *errors* have the "
"same meaning as with built-in :func:`open`.  This function returns the "
"contents of the resource as :class:`str`."
msgstr ""
"*package* é um nome ou um objeto módulo que está em conformidade com os "
"requisitos do ``Package``. *resource* é o nome do recurso a ser aberto "
"dentro de *package*; ele não pode conter separadores de caminho e não pode "
"ter sub-recursos (ou seja, não pode ser um diretório). *encoding* e *errors* "
"têm o mesmo significado que com :func:`open` embutido. Esta função retorna o "
"conteúdo do recurso como :class:`str`."

#: ../../library/importlib.rst:910
msgid ""
"Return the path to the *resource* as an actual file system path.  This "
"function returns a context manager for use in a :keyword:`with` statement. "
"The context manager provides a :class:`pathlib.Path` object."
msgstr ""
"Retorna o caminho para o *resource* como um caminho real do sistema de "
"arquivos.  Essa função retorna um gerenciador de contexto para uso em uma "
"instrução :keyword:`with`. O gerenciador de contexto fornece um objeto :"
"class:`pathlib.Path`."

#: ../../library/importlib.rst:914
msgid ""
"Exiting the context manager cleans up any temporary file created when the "
"resource needs to be extracted from e.g. a zip file."
msgstr ""
"Sair do gerenciador de contexto limpa qualquer arquivo temporário criado "
"quando o recurso precisa ser extraído, por exemplo, de um arquivo zip."

#: ../../library/importlib.rst:917
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open "
"within *package*; it may not contain path separators and it may not have sub-"
"resources (i.e. it cannot be a directory)."
msgstr ""
"*package* é um nome ou um objeto módulo que está em conformidade com os "
"requisitos do ``Package``. *resource* é o nome do recurso a ser aberto "
"dentro de *package*; ele não pode conter separadores de caminho e não pode "
"ter sub-recursos (ou seja, não pode ser um diretório)."

#: ../../library/importlib.rst:925
msgid ""
"Return ``True`` if there is a resource named *name* in the package, "
"otherwise ``False``.  Remember that directories are *not* resources! "
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements."
msgstr ""

#: ../../library/importlib.rst:933
msgid ""
"Return an iterable over the named items within the package.  The iterable "
"returns :class:`str` resources (e.g. files) and non-resources (e.g. "
"directories).  The iterable does not recurse into subdirectories."
msgstr ""
"Retorna um iterável sobre os itens nomeados no pacote.  O iterável retorna :"
"class:`str` recursos (por exemplo, arquivos) e não recursos (por exemplo, "
"diretórios).  O iterável não recorre a subdiretórios."

#: ../../library/importlib.rst:937
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements."
msgstr ""
"*package* é um nome ou um objeto módulo que está em conformidade com os "
"requisitos de ``Package``."

#: ../../library/importlib.rst:942
msgid ":mod:`importlib.machinery` -- Importers and path hooks"
msgstr ":mod:`importlib.machinery` -- Importadores e ganchos de caminho"

#: ../../library/importlib.rst:947
msgid "**Source code:** :source:`Lib/importlib/machinery.py`"
msgstr "**Código-fonte:** :source:`Lib/importlib/machinery.py`"

#: ../../library/importlib.rst:951
msgid ""
"This module contains the various objects that help :keyword:`import` find "
"and load modules."
msgstr ""
"Este módulo contém vários objetos que ajudam o :keyword:`import` a localizar "
"e carregar módulos."

#: ../../library/importlib.rst:956
msgid ""
"A list of strings representing the recognized file suffixes for source "
"modules."
msgstr ""
"Uma lista de strings representando os sufixos de arquivo reconhecidos para "
"módulos em código-fonte."

#: ../../library/importlib.rst:963
msgid ""
"A list of strings representing the file suffixes for non-optimized bytecode "
"modules."
msgstr ""
"Uma lista de strings representando os sufixos de arquivo para módulos em "
"bytecode não otimizado."

#: ../../library/importlib.rst:968 ../../library/importlib.rst:978
msgid "Use :attr:`BYTECODE_SUFFIXES` instead."
msgstr "Use :attr:`BYTECODE_SUFFIXES`."

#: ../../library/importlib.rst:973
msgid ""
"A list of strings representing the file suffixes for optimized bytecode "
"modules."
msgstr ""
"Uma lista de strings representando os sufixos de arquivo para módulos em "
"bytecode otimizado."

#: ../../library/importlib.rst:983
msgid ""
"A list of strings representing the recognized file suffixes for bytecode "
"modules (including the leading dot)."
msgstr ""
"Uma lista de strings representando os sufixos de arquivo reconhecidos para "
"módulos em bytecode (incluindo com ponto no início)."

#: ../../library/importlib.rst:988
msgid "The value is no longer dependent on ``__debug__``."
msgstr "O valor não mais depende de ``__debug__``."

#: ../../library/importlib.rst:993
msgid ""
"A list of strings representing the recognized file suffixes for extension "
"modules."
msgstr ""
"Uma lista de strings representando os sufixos de arquivo reconhecidos para "
"módulos de extensão."

#: ../../library/importlib.rst:1000
msgid ""
"Returns a combined list of strings representing all file suffixes for "
"modules recognized by the standard import machinery. This is a helper for "
"code which simply needs to know if a filesystem path potentially refers to a "
"module without needing any details on the kind of module (for example, :func:"
"`inspect.getmodulename`)."
msgstr ""
"Retorna uma lista combinada de strings representando todos os sufixos de "
"arquivo para módulos reconhecidos pelo maquinário de importação padrão. Este "
"é um auxiliar para código que simplesmente precisa saber se um caminho de "
"sistema de arquivos potencialmente se refere a um módulo sem precisar de "
"detalhes sobre o tipo de módulo (por exemplo, :func:`inspect.getmodulename`)."

#: ../../library/importlib.rst:1011
msgid ""
"An :term:`importer` for built-in modules. All known built-in modules are "
"listed in :data:`sys.builtin_module_names`. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"Um :term:`importador` para módulos embutidos. Todos os módulos embutidos "
"conhecidos estão listados em :data:`sys.builtin_module_names`. Esta classe "
"implementa os ABCs :class:`importlib.abc.MetaPathFinder` e :class:`importlib."
"abc.InspectLoader`."

#: ../../library/importlib.rst:1016 ../../library/importlib.rst:1030
#: ../../library/importlib.rst:1043 ../../library/importlib.rst:1058
msgid ""
"Only class methods are defined by this class to alleviate the need for "
"instantiation."
msgstr ""
"Somente métodos de classe são definidos por esta classe para aliviar a "
"necessidade de instanciação."

#: ../../library/importlib.rst:1019
msgid ""
"As part of :pep:`489`, the builtin importer now implements :meth:`Loader."
"create_module` and :meth:`Loader.exec_module`"
msgstr ""
"Como parte da :pep:`489`, o ​​importador embutido agora implementa :meth:"
"`Loader.create_module` e :meth:`Loader.exec_module`"

#: ../../library/importlib.rst:1026
msgid ""
"An :term:`importer` for frozen modules. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"Um :term:`importador` para módulos congelados. Esta classe implementa os "
"ABCs :class:`importlib.abc.MetaPathFinder` e :class:`importlib.abc."
"InspectLoader`."

#: ../../library/importlib.rst:1033
msgid ""
"Gained :meth:`~Loader.create_module` and :meth:`~Loader.exec_module` methods."
msgstr ""
"Ganhou os métodos :meth:`~Loader.create_module` e :meth:`~Loader."
"exec_module`."

#: ../../library/importlib.rst:1040
msgid ""
":term:`Finder <finder>` for modules declared in the Windows registry.  This "
"class implements the :class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
":term:`Localizador <finder>` para módulos declarados no registro do Windows. "
"Esta classe implementa a ABC :class:`importlib.abc.MetaPathFinder`."

#: ../../library/importlib.rst:1048
msgid ""
"Use :mod:`site` configuration instead. Future versions of Python may not "
"enable this finder by default."
msgstr ""
"Use a configuração de :mod:`site` em vez disso. Versões futuras do Python "
"podem não habilitar esse localizador por padrão."

#: ../../library/importlib.rst:1055
msgid ""
"A :term:`Finder <finder>` for :data:`sys.path` and package ``__path__`` "
"attributes. This class implements the :class:`importlib.abc.MetaPathFinder` "
"ABC."
msgstr ""
"Um :term:`Localizador <finder>` para atributos :data:`sys.path` e pacote "
"``__path__``. Esta classe implementa a ABC :class:`importlib.abc."
"MetaPathFinder`."

#: ../../library/importlib.rst:1063
msgid ""
"Class method that attempts to find a :term:`spec <module spec>` for the "
"module specified by *fullname* on :data:`sys.path` or, if defined, on "
"*path*. For each path entry that is searched, :data:`sys."
"path_importer_cache` is checked. If a non-false object is found then it is "
"used as the :term:`path entry finder` to look for the module being searched "
"for. If no entry is found in :data:`sys.path_importer_cache`, then :data:"
"`sys.path_hooks` is searched for a finder for the path entry and, if found, "
"is stored in :data:`sys.path_importer_cache` along with being queried about "
"the module. If no finder is ever found then ``None`` is both stored in the "
"cache and returned."
msgstr ""
"Método de classe que tenta encontrar um :term:`spec <module spec>` para o "
"módulo especificado por *fullname* em :data:`sys.path` ou, se definido, em "
"*path*. Para cada entrada de caminho pesquisada, :data:`sys."
"path_importer_cache` é verificado. Se um objeto não falso for encontrado, "
"ele será usado como o :term:`localizador de entrada de caminho` para "
"procurar o módulo que está sendo pesquisado. Se nenhuma entrada for "
"encontrada em :data:`sys.path_importer_cache`, então :data:`sys.path_hooks` "
"será pesquisado para um localizador para a entrada de caminho e, se "
"encontrado, será armazenado em :data:`sys.path_importer_cache` junto com a "
"consulta sobre o módulo. Se nenhum localizador for encontrado, então "
"``None`` será armazenado no cache e retornado."

#: ../../library/importlib.rst:1077
msgid ""
"If the current working directory -- represented by an empty string -- is no "
"longer valid then ``None`` is returned but no value is cached in :data:`sys."
"path_importer_cache`."
msgstr ""
"Se o diretório de trabalho atual — representado por uma string vazia — não "
"for mais válido, ``None`` será retornado, mas nenhum valor será armazenado "
"em cache em :data:`sys.path_importer_cache`."

#: ../../library/importlib.rst:1084
msgid "A legacy wrapper around :meth:`find_spec`."
msgstr ""

#: ../../library/importlib.rst:1091
msgid ""
"Calls :meth:`importlib.abc.PathEntryFinder.invalidate_caches` on all finders "
"stored in :data:`sys.path_importer_cache` that define the method. Otherwise "
"entries in :data:`sys.path_importer_cache` set to ``None`` are deleted."
msgstr ""
"Chama :meth:`importlib.abc.PathEntryFinder.invalidate_caches` em todos os "
"localizadores armazenados em :data:`sys.path_importer_cache` que definem o "
"método. Caso contrário, as entradas em :data:`sys.path_importer_cache` "
"definidas como ``None`` são excluídas."

#: ../../library/importlib.rst:1096
msgid "Entries of ``None`` in :data:`sys.path_importer_cache` are deleted."
msgstr "Entradas de ``None`` em :data:`sys.path_importer_cache` são excluídas."

#: ../../library/importlib.rst:1099
msgid ""
"Calls objects in :data:`sys.path_hooks` with the current working directory "
"for ``''`` (i.e. the empty string)."
msgstr ""
"Chama objetos em :data:`sys.path_hooks` com o diretório de trabalho atual "
"para ``''`` (ou seja, a string vazia)."

#: ../../library/importlib.rst:1106
msgid ""
"A concrete implementation of :class:`importlib.abc.PathEntryFinder` which "
"caches results from the file system."
msgstr ""
"Uma implementação concreta de :class:`importlib.abc.PathEntryFinder` que "
"armazena em cache os resultados do sistema de arquivos."

#: ../../library/importlib.rst:1109
msgid ""
"The *path* argument is the directory for which the finder is in charge of "
"searching."
msgstr ""
"O argumento *path* é o diretório que o localizador é responsável por "
"pesquisar."

#: ../../library/importlib.rst:1112
msgid ""
"The *loader_details* argument is a variable number of 2-item tuples each "
"containing a loader and a sequence of file suffixes the loader recognizes. "
"The loaders are expected to be callables which accept two arguments of the "
"module's name and the path to the file found."
msgstr ""
"O argumento *loader_details* é um número variável de tuplas de 2 itens, cada "
"uma contendo um carregador e uma sequência de sufixos de arquivo que o "
"carregador reconhece. Espera-se que os carregadores sejam chamáveis ​​que "
"aceitam dois argumentos do nome do módulo e o caminho para o arquivo "
"encontrado."

#: ../../library/importlib.rst:1117
msgid ""
"The finder will cache the directory contents as necessary, making stat calls "
"for each module search to verify the cache is not outdated. Because cache "
"staleness relies upon the granularity of the operating system's state "
"information of the file system, there is a potential race condition of "
"searching for a module, creating a new file, and then searching for the "
"module the new file represents. If the operations happen fast enough to fit "
"within the granularity of stat calls, then the module search will fail. To "
"prevent this from happening, when you create a module dynamically, make sure "
"to call :func:`importlib.invalidate_caches`."
msgstr ""
"O localizador armazenará em cache o conteúdo do diretório conforme "
"necessário, fazendo chamadas de \"stat\" para cada pesquisa de módulo para "
"verificar se o cache não está desatualizado. Como a obsolescência do cache "
"depende da granularidade das informações de estado do sistema operacional do "
"sistema de arquivos, há uma condição de corrida potencial de busca por um "
"módulo, criação de um novo arquivo e, em seguida, busca pelo módulo que o "
"novo arquivo representa. Se as operações ocorrerem rápido o suficiente para "
"caber na granularidade das chamadas de \"stat\", a pesquisa do módulo "
"falhará. Para evitar que isso aconteça, ao criar um módulo dinamicamente, "
"certifique-se de chamar :func:`importlib.invalidate_caches`."

#: ../../library/importlib.rst:1131
msgid "The path the finder will search in."
msgstr "O caminho que o localizador irá procurar."

#: ../../library/importlib.rst:1135
msgid "Attempt to find the spec to handle *fullname* within :attr:`path`."
msgstr ""
"Tenta encontrar a especificação para manipular *fullname* dentro de :attr:"
"`path`."

#: ../../library/importlib.rst:1141
msgid "Attempt to find the loader to handle *fullname* within :attr:`path`."
msgstr ""

#: ../../library/importlib.rst:1145
msgid "Clear out the internal cache."
msgstr "Limpa o cache interno."

#: ../../library/importlib.rst:1149
msgid ""
"A class method which returns a closure for use on :attr:`sys.path_hooks`. An "
"instance of :class:`FileFinder` is returned by the closure using the path "
"argument given to the closure directly and *loader_details* indirectly."
msgstr ""

#: ../../library/importlib.rst:1154
msgid ""
"If the argument to the closure is not an existing directory, :exc:"
"`ImportError` is raised."
msgstr ""
"Se o argumento para a clausura não for um diretório existente, :exc:"
"`ImportError` será levantada."

#: ../../library/importlib.rst:1160
msgid ""
"A concrete implementation of :class:`importlib.abc.SourceLoader` by "
"subclassing :class:`importlib.abc.FileLoader` and providing some concrete "
"implementations of other methods."
msgstr ""
"Uma implementação concreta de :class:`importlib.abc.SourceLoader` "
"subclassificando :class:`importlib.abc.FileLoader` e fornecendo algumas "
"implementações concretas de outros métodos."

#: ../../library/importlib.rst:1168
msgid "The name of the module that this loader will handle."
msgstr "O nome do módulo que este carregador irá manipular."

#: ../../library/importlib.rst:1172
msgid "The path to the source file."
msgstr "O caminho para o arquivo fonte."

#: ../../library/importlib.rst:1176
msgid "Return ``True`` if :attr:`path` appears to be for a package."
msgstr "Retorna ``True`` se :attr:`path` parecer ser para um pacote."

#: ../../library/importlib.rst:1180
msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.path_stats`."
msgstr ""
"Implementação concreta de :meth:`importlib.abc.SourceLoader.path_stats`."

#: ../../library/importlib.rst:1184
msgid "Concrete implementation of :meth:`importlib.abc.SourceLoader.set_data`."
msgstr "Implementação concreta de :meth:`importlib.abc.SourceLoader.set_data`."

#: ../../library/importlib.rst:1188 ../../library/importlib.rst:1231
msgid ""
"Concrete implementation of :meth:`importlib.abc.Loader.load_module` where "
"specifying the name of the module to load is optional."
msgstr ""
"Implementação concreta de :meth:`importlib.abc.Loader.load_module` onde a "
"especificação do nome do módulo para carregar é opcional"

#: ../../library/importlib.rst:1193 ../../library/importlib.rst:1236
msgid "Use :meth:`importlib.abc.Loader.exec_module` instead."
msgstr "Use :meth:`importlib.abc.Loader.exec_module`."

#: ../../library/importlib.rst:1198
msgid ""
"A concrete implementation of :class:`importlib.abc.FileLoader` which can "
"import bytecode files (i.e. no source code files exist)."
msgstr ""
"Uma implementação concreta de :class:`importlib.abc.FileLoader` que pode "
"importar arquivos de bytecode (ou seja, não existem arquivos de código-"
"fonte)."

#: ../../library/importlib.rst:1201
msgid ""
"Please note that direct use of bytecode files (and thus not source code "
"files) inhibits your modules from being usable by all Python implementations "
"or new versions of Python which change the bytecode format."
msgstr ""
"Observe que o uso direto de arquivos de bytecode (e, portanto, não de "
"arquivos de código-fonte) impede que seus módulos sejam utilizáveis ​​por "
"todas as implementações do Python ou novas versões do Python que alteram o "
"formato do bytecode."

#: ../../library/importlib.rst:1210
msgid "The name of the module the loader will handle."
msgstr "O nome do módulo que o carregador vai manipular."

#: ../../library/importlib.rst:1214
msgid "The path to the bytecode file."
msgstr "O caminho para o arquivo de bytecode."

#: ../../library/importlib.rst:1218
msgid "Determines if the module is a package based on :attr:`path`."
msgstr "Determina se o módulo é um pacote baseado em :attr:`path`."

#: ../../library/importlib.rst:1222
msgid "Returns the code object for :attr:`name` created from :attr:`path`."
msgstr ""
"Retorna o objeto código para :attr:`name` criado a partir de :attr:`path`."

#: ../../library/importlib.rst:1226
msgid ""
"Returns ``None`` as bytecode files have no source when this loader is used."
msgstr ""
"Retorna ``None``, pois os arquivos de bytecode não têm código-fonte quando "
"este carregador é usado."

#: ../../library/importlib.rst:1241
msgid ""
"A concrete implementation of :class:`importlib.abc.ExecutionLoader` for "
"extension modules."
msgstr ""
"Uma implementação concreta de :class:`importlib.abc.ExecutionLoader` para "
"módulos de extensão."

#: ../../library/importlib.rst:1244
msgid ""
"The *fullname* argument specifies the name of the module the loader is to "
"support. The *path* argument is the path to the extension module's file."
msgstr ""
"O argumento *fullname* especifica o nome do módulo ao qual o carregador deve "
"dar suporte. O argumento *path* é o caminho para o arquivo do módulo de "
"extensão."

#: ../../library/importlib.rst:1251
msgid "Name of the module the loader supports."
msgstr "Nome do módulo ao qual o carregador dá suporte."

#: ../../library/importlib.rst:1255
msgid "Path to the extension module."
msgstr "Caminho para o módulo de extensão."

#: ../../library/importlib.rst:1259
msgid ""
"Creates the module object from the given specification in accordance with :"
"pep:`489`."
msgstr ""
"Cria o objeto do módulo a partir da especificação fornecida de acordo com a :"
"pep:`489`."

#: ../../library/importlib.rst:1266
msgid "Initializes the given module object in accordance with :pep:`489`."
msgstr "Inicializa o objeto do módulo fornecido de acordo com a :pep:`489`."

#: ../../library/importlib.rst:1272
msgid ""
"Returns ``True`` if the file path points to a package's ``__init__`` module "
"based on :attr:`EXTENSION_SUFFIXES`."
msgstr ""
"Retorna ``True`` se o caminho do arquivo aponta para o módulo ``__init__`` "
"de um pacote com base em :attr:`EXTENSION_SUFFIXES`."

#: ../../library/importlib.rst:1277
msgid "Returns ``None`` as extension modules lack a code object."
msgstr ""
"Retorna ``None``, pois os módulos de extensão não possuem um objeto código."

#: ../../library/importlib.rst:1281
msgid "Returns ``None`` as extension modules do not have source code."
msgstr "Retorna ``None`` pois os módulos de extensão não possuem código-fonte."

#: ../../library/importlib.rst:1292
msgid ""
"A specification for a module's import-system-related state.  This is "
"typically exposed as the module's ``__spec__`` attribute.  In the "
"descriptions below, the names in parentheses give the corresponding "
"attribute available directly on the module object. E.g. ``module.__spec__."
"origin == module.__file__``.  Note however that while the *values* are "
"usually equivalent, they can differ since there is no synchronization "
"between the two objects.  Thus it is possible to update the module's "
"``__path__`` at runtime, and this will not be automatically reflected in "
"``__spec__.submodule_search_locations``."
msgstr ""

#: ../../library/importlib.rst:1306
msgid "(``__name__``)"
msgstr ""

#: ../../library/importlib.rst:1308
msgid "A string for the fully-qualified name of the module."
msgstr ""

#: ../../library/importlib.rst:1312
msgid "(``__loader__``)"
msgstr "(``__loader__``)"

#: ../../library/importlib.rst:1314
msgid ""
"The :term:`Loader <loader>` that should be used when loading the module.  :"
"term:`Finders <finder>` should always set this."
msgstr ""

#: ../../library/importlib.rst:1319
msgid "(``__file__``)"
msgstr ""

#: ../../library/importlib.rst:1321
msgid ""
"Name of the place from which the module is loaded, e.g. \"builtin\" for "
"built-in modules and the filename for modules loaded from source. Normally "
"\"origin\" should be set, but it may be ``None`` (the default) which "
"indicates it is unspecified (e.g. for namespace packages)."
msgstr ""

#: ../../library/importlib.rst:1328
msgid "(``__path__``)"
msgstr ""

#: ../../library/importlib.rst:1330
msgid ""
"List of strings for where to find submodules, if a package (``None`` "
"otherwise)."
msgstr ""

#: ../../library/importlib.rst:1335
msgid ""
"Container of extra module-specific data for use during loading (or ``None``)."
msgstr ""

#: ../../library/importlib.rst:1340
msgid "(``__cached__``)"
msgstr "(``__cached__``)"

#: ../../library/importlib.rst:1342
msgid "String for where the compiled module should be stored (or ``None``)."
msgstr ""

#: ../../library/importlib.rst:1346
msgid "(``__package__``)"
msgstr "(``__package__``)"

#: ../../library/importlib.rst:1348
msgid ""
"(Read-only) The fully-qualified name of the package under which the module "
"should be loaded as a submodule (or the empty string for top-level modules). "
"For packages, it is the same as :attr:`__name__`."
msgstr ""

#: ../../library/importlib.rst:1354
msgid ""
"Boolean indicating whether or not the module's \"origin\" attribute refers "
"to a loadable location."
msgstr ""

#: ../../library/importlib.rst:1358
msgid ":mod:`importlib.util` -- Utility code for importers"
msgstr ""

#: ../../library/importlib.rst:1364
msgid "**Source code:** :source:`Lib/importlib/util.py`"
msgstr ""

#: ../../library/importlib.rst:1368
msgid ""
"This module contains the various objects that help in the construction of "
"an :term:`importer`."
msgstr ""

#: ../../library/importlib.rst:1373
msgid ""
"The bytes which represent the bytecode version number. If you need help with "
"loading/writing bytecode then consider :class:`importlib.abc.SourceLoader`."
msgstr ""

#: ../../library/importlib.rst:1380
msgid ""
"Return the :pep:`3147`/:pep:`488` path to the byte-compiled file associated "
"with the source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the "
"return value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python "
"3.2. The ``cpython-32`` string comes from the current magic tag (see :func:"
"`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then :exc:"
"`NotImplementedError` will be raised)."
msgstr ""

#: ../../library/importlib.rst:1387
msgid ""
"The *optimization* parameter is used to specify the optimization level of "
"the bytecode file. An empty string represents no optimization, so ``/foo/bar/"
"baz.py`` with an *optimization* of ``''`` will result in a bytecode path of "
"``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` causes the "
"interpreter's optimization level to be used. Any other value's string "
"representation is used, so ``/foo/bar/baz.py`` with an *optimization* of "
"``2`` will lead to the bytecode path of ``/foo/bar/__pycache__/baz."
"cpython-32.opt-2.pyc``. The string representation of *optimization* can only "
"be alphanumeric, else :exc:`ValueError` is raised."
msgstr ""

#: ../../library/importlib.rst:1397
msgid ""
"The *debug_override* parameter is deprecated and can be used to override the "
"system's value for ``__debug__``. A ``True`` value is the equivalent of "
"setting *optimization* to the empty string. A ``False`` value is the same as "
"setting *optimization* to ``1``. If both *debug_override* an *optimization* "
"are not ``None`` then :exc:`TypeError` is raised."
msgstr ""

#: ../../library/importlib.rst:1405
msgid ""
"The *optimization* parameter was added and the *debug_override* parameter "
"was deprecated."
msgstr ""

#: ../../library/importlib.rst:1409 ../../library/importlib.rst:1425
#: ../../library/importlib.rst:1569
msgid "Accepts a :term:`path-like object`."
msgstr "Aceita um :term:`objeto caminho ou similar`."

#: ../../library/importlib.rst:1415
msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is ``/foo/bar/__pycache__/baz."
"cpython-32.pyc`` the returned path would be ``/foo/bar/baz.py``.  *path* "
"need not exist, however if it does not conform to :pep:`3147` or :pep:`488` "
"format, a :exc:`ValueError` is raised. If :attr:`sys.implementation."
"cache_tag` is not defined, :exc:`NotImplementedError` is raised."
msgstr ""

#: ../../library/importlib.rst:1430
msgid ""
"Decode the given bytes representing source code and return it as a string "
"with universal newlines (as required by :meth:`importlib.abc.InspectLoader."
"get_source`)."
msgstr ""

#: ../../library/importlib.rst:1438
msgid "Resolve a relative module name to an absolute one."
msgstr ""

#: ../../library/importlib.rst:1440
msgid ""
"If  **name** has no leading dots, then **name** is simply returned. This "
"allows for usage such as ``importlib.util.resolve_name('sys', __spec__."
"parent)`` without doing a check to see if the **package** argument is needed."
msgstr ""

#: ../../library/importlib.rst:1445
msgid ""
":exc:`ValueError` is raised if **name** is a relative module name but "
"package is a false value (e.g. ``None`` or the empty string). :exc:"
"`ValueError` is also raised a relative name would escape its containing "
"package (e.g. requesting ``..bacon`` from within the ``spam`` package)."
msgstr ""

#: ../../library/importlib.rst:1454
msgid ""
"Find the :term:`spec <module spec>` for a module, optionally relative to the "
"specified **package** name. If the module is in :attr:`sys.modules`, then "
"``sys.modules[name].__spec__`` is returned (unless the spec would be "
"``None`` or is not set, in which case :exc:`ValueError` is raised). "
"Otherwise a search using :attr:`sys.meta_path` is done. ``None`` is returned "
"if no spec is found."
msgstr ""

#: ../../library/importlib.rst:1461
msgid ""
"If **name** is for a submodule (contains a dot), the parent module is "
"automatically imported."
msgstr ""

#: ../../library/importlib.rst:1464
msgid "**name** and **package** work the same as for :func:`import_module`."
msgstr ""

#: ../../library/importlib.rst:1468
msgid ""
"Raises :exc:`ModuleNotFoundError` instead of :exc:`AttributeError` if "
"**package** is in fact not a package (i.e. lacks a :attr:`__path__` "
"attribute)."
msgstr ""

#: ../../library/importlib.rst:1475
msgid ""
"Create a new module based on **spec** and :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."
msgstr ""

#: ../../library/importlib.rst:1478
msgid ""
"If :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"does not return ``None``, then any pre-existing attributes will not be "
"reset. Also, no :exc:`AttributeError` will be raised if triggered while "
"accessing **spec** or setting an attribute on the module."
msgstr ""

#: ../../library/importlib.rst:1483
msgid ""
"This function is preferred over using :class:`types.ModuleType` to create a "
"new module as **spec** is used to set as many import-controlled attributes "
"on the module as possible."
msgstr ""

#: ../../library/importlib.rst:1491
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to handle "
"selecting the proper module object to load with. The decorated method is "
"expected to have a call signature taking two positional arguments (e.g. "
"``load_module(self, module)``) for which the second argument will be the "
"module **object** to be used by the loader. Note that the decorator will not "
"work on static methods because of the assumption of two arguments."
msgstr ""

#: ../../library/importlib.rst:1500
msgid ""
"The decorated method will take in the **name** of the module to be loaded as "
"expected for a :term:`loader`. If the module is not found in :data:`sys."
"modules` then a new one is constructed. Regardless of where the module came "
"from, :attr:`__loader__` set to **self** and :attr:`__package__` is set "
"based on what :meth:`importlib.abc.InspectLoader.is_package` returns (if "
"available). These attributes are set unconditionally to support reloading."
msgstr ""

#: ../../library/importlib.rst:1508
msgid ""
"If an exception is raised by the decorated method and a module was added to :"
"data:`sys.modules`, then the module will be removed to prevent a partially "
"initialized module from being in left in :data:`sys.modules`. If the module "
"was already in :data:`sys.modules` then it is left alone."
msgstr ""

#: ../../library/importlib.rst:1513
msgid ""
":attr:`__loader__` and :attr:`__package__` are automatically set (when "
"possible)."
msgstr ""

#: ../../library/importlib.rst:1517
msgid ""
"Set :attr:`__name__`, :attr:`__loader__` :attr:`__package__` unconditionally "
"to support reloading."
msgstr ""

#: ../../library/importlib.rst:1521
msgid ""
"The import machinery now directly performs all the functionality provided by "
"this function."
msgstr ""

#: ../../library/importlib.rst:1527
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to set the :"
"attr:`__loader__` attribute on the returned module. If the attribute is "
"already set the decorator does nothing. It is assumed that the first "
"positional argument to the wrapped method (i.e. ``self``) is what :attr:"
"`__loader__` should be set to."
msgstr ""

#: ../../library/importlib.rst:1534
msgid ""
"Set ``__loader__`` if set to ``None``, as if the attribute does not exist."
msgstr ""

#: ../../library/importlib.rst:1538 ../../library/importlib.rst:1547
msgid "The import machinery takes care of this automatically."
msgstr ""

#: ../../library/importlib.rst:1543
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to set the :"
"attr:`__package__` attribute on the returned module. If :attr:`__package__` "
"is set and has a value other than ``None`` it will not be changed."
msgstr ""

#: ../../library/importlib.rst:1552
msgid ""
"A factory function for creating a :class:`ModuleSpec` instance based on a "
"loader.  The parameters have the same meaning as they do for ModuleSpec.  "
"The function uses available :term:`loader` APIs, such as :meth:"
"`InspectLoader.is_package`, to fill in any missing information on the spec."
msgstr ""

#: ../../library/importlib.rst:1562
msgid ""
"A factory function for creating a :class:`ModuleSpec` instance based on the "
"path to a file.  Missing information will be filled in on the spec by making "
"use of loader APIs and by the implication that the module will be file-based."
msgstr ""

#: ../../library/importlib.rst:1574
msgid ""
"Return the hash of *source_bytes* as bytes. A hash-based ``.pyc`` file "
"embeds the :func:`source_hash` of the corresponding source file's contents "
"in its header."
msgstr ""

#: ../../library/importlib.rst:1582
msgid ""
"A class which postpones the execution of the loader of a module until the "
"module has an attribute accessed."
msgstr ""

#: ../../library/importlib.rst:1585
msgid ""
"This class **only** works with loaders that define :meth:`~importlib.abc."
"Loader.exec_module` as control over what module type is used for the module "
"is required. For those same reasons, the loader's :meth:`~importlib.abc."
"Loader.create_module` method must return ``None`` or a type for which its "
"``__class__`` attribute can be mutated along with not using :term:`slots "
"<__slots__>`. Finally, modules which substitute the object placed into :attr:"
"`sys.modules` will not work as there is no way to properly replace the "
"module references throughout the interpreter safely; :exc:`ValueError` is "
"raised if such a substitution is detected."
msgstr ""

#: ../../library/importlib.rst:1596
msgid ""
"For projects where startup time is critical, this class allows for "
"potentially minimizing the cost of loading a module if it is never used. For "
"projects where startup time is not essential then use of this class is "
"**heavily** discouraged due to error messages created during loading being "
"postponed and thus occurring out of context."
msgstr ""

#: ../../library/importlib.rst:1604
msgid ""
"Began calling :meth:`~importlib.abc.Loader.create_module`, removing the "
"compatibility warning for :class:`importlib.machinery.BuiltinImporter` and :"
"class:`importlib.machinery.ExtensionFileLoader`."
msgstr ""

#: ../../library/importlib.rst:1611
msgid ""
"A static method which returns a callable that creates a lazy loader. This is "
"meant to be used in situations where the loader is passed by class instead "
"of by instance. ::"
msgstr ""

#: ../../library/importlib.rst:1624
msgid "Examples"
msgstr "Exemplos"

#: ../../library/importlib.rst:1627
msgid "Importing programmatically"
msgstr ""

#: ../../library/importlib.rst:1629
msgid ""
"To programmatically import a module, use :func:`importlib.import_module`. ::"
msgstr ""

#: ../../library/importlib.rst:1638
msgid "Checking if a module can be imported"
msgstr "Checando se o módulo pode ser importado"

#: ../../library/importlib.rst:1640
msgid ""
"If you need to find out if a module can be imported without actually doing "
"the import, then you should use :func:`importlib.util.find_spec`. ::"
msgstr ""

#: ../../library/importlib.rst:1663
msgid "Importing a source file directly"
msgstr "Importa o arquivo de origem diretamente"

#: ../../library/importlib.rst:1665
msgid ""
"To import a Python source file directly, use the following recipe (Python "
"3.5 and newer only)::"
msgstr ""
"Importação um arquivo Python diretamente da fonte, use o seguinte caminho "
"(Somente versões Python 3.5 acima)"

#: ../../library/importlib.rst:1684
msgid "Setting up an importer"
msgstr ""

#: ../../library/importlib.rst:1686
msgid ""
"For deep customizations of import, you typically want to implement an :term:"
"`importer`. This means managing both the :term:`finder` and :term:`loader` "
"side of things. For finders there are two flavours to choose from depending "
"on your needs: a :term:`meta path finder` or a :term:`path entry finder`. "
"The former is what you would put on :attr:`sys.meta_path` while the latter "
"is what you create using a :term:`path entry hook` on :attr:`sys.path_hooks` "
"which works with :attr:`sys.path` entries to potentially create a finder. "
"This example will show you how to register your own importers so that import "
"will use them (for creating an importer for yourself, read the documentation "
"for the appropriate classes defined within this package)::"
msgstr ""

#: ../../library/importlib.rst:1718
msgid "Approximating :func:`importlib.import_module`"
msgstr ""

#: ../../library/importlib.rst:1720
msgid ""
"Import itself is implemented in Python code, making it possible to expose "
"most of the import machinery through importlib. The following helps "
"illustrate the various APIs that importlib exposes by providing an "
"approximate implementation of :func:`importlib.import_module` (Python 3.4 "
"and newer for the importlib usage, Python 3.6 and newer for other parts of "
"the code). ::"
msgstr ""

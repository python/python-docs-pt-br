# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 15:02+0000\n"
"PO-Revision-Date: 2025-05-08 05:10+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/sqlite3.rst:2
msgid ":mod:`!sqlite3` --- DB-API 2.0 interface for SQLite databases"
msgstr ""
":mod:`!sqlite3` ---- interface DB-API 2.0 interface para bancos de dados "
"SQLite"

#: ../../library/sqlite3.rst:9
msgid "**Source code:** :source:`Lib/sqlite3/`"
msgstr "**Código-fonte:** :source:`Lib/sqlite3/`"

#: ../../library/sqlite3.rst:25
msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can "
"use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as "
"PostgreSQL or Oracle."
msgstr ""
"SQLite é uma biblioteca C que fornece um banco de dados leve baseado em "
"disco que não requer um processo de servidor separado e permite acessar o "
"banco de dados usando uma variante não padrão da linguagem de consulta SQL. "
"Algumas aplicações podem usar SQLite para armazenamento interno de dados. "
"Também é possível prototipar um aplicativo usando SQLite e, em seguida, "
"portar o código para um banco de dados maior, como PostgreSQL ou Oracle."

#: ../../library/sqlite3.rst:32
msgid ""
"The :mod:`!sqlite3` module was written by Gerhard Häring.  It provides an "
"SQL interface compliant with the DB-API 2.0 specification described by :pep:"
"`249`, and requires SQLite 3.15.2 or newer."
msgstr ""
"O módulo :mod:`!sqlite3` foi escrito por Gerhard Häring. Ele oferece uma "
"interface SQL compatível com a especificação DB-API 2.0 descrita pela :pep:"
"`249` e requer o SQLite 3.15.2 ou o mais recente."

#: ../../library/sqlite3.rst:36
msgid "This document includes four main sections:"
msgstr "Esse documento inclui quatro seções principais:"

#: ../../library/sqlite3.rst:38
msgid ":ref:`sqlite3-tutorial` teaches how to use the :mod:`!sqlite3` module."
msgstr ":ref:`sqlite3-tutorial` ensina como usar o módulo :mod:`!sqlite3`."

#: ../../library/sqlite3.rst:39
msgid ""
":ref:`sqlite3-reference` describes the classes and functions this module "
"defines."
msgstr ""
":ref:`sqlite3-reference` descreve as classes e funções que este módulo "
"define."

#: ../../library/sqlite3.rst:41
msgid ":ref:`sqlite3-howtos` details how to handle specific tasks."
msgstr ":ref:`sqlite3-howtos` detalha como lidar com tarefas específicas."

#: ../../library/sqlite3.rst:42
msgid ""
":ref:`sqlite3-explanation` provides in-depth background on transaction "
"control."
msgstr ""
":ref:`sqlite3-explanation` fornece informações detalhadas sobre controle de "
"transações."

#: ../../library/sqlite3.rst:47
msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

#: ../../library/sqlite3.rst:48
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr ""
"A página web do SQLite; a documentação descreve a sintaxe e os tipos de "
"dados disponíveis para o dialeto SQL suportado."

#: ../../library/sqlite3.rst:51
msgid "https://www.w3schools.com/sql/"
msgstr "https://www.w3schools.com/sql/"

#: ../../library/sqlite3.rst:52
msgid "Tutorial, reference and examples for learning SQL syntax."
msgstr "Tutoriais, referências e exemplos para aprender a sintaxe SQL."

#: ../../library/sqlite3.rst:54
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - Especificação 2.0 da API de banco de dados"

#: ../../library/sqlite3.rst:55
msgid "PEP written by Marc-André Lemburg."
msgstr "PEP escrita por Marc-André Lemburg."

#: ../../library/sqlite3.rst:68
msgid "Tutorial"
msgstr "Tutorial"

#: ../../library/sqlite3.rst:70
msgid ""
"In this tutorial, you will create a database of Monty Python movies using "
"basic :mod:`!sqlite3` functionality. It assumes a fundamental understanding "
"of database concepts, including `cursors`_ and `transactions`_."
msgstr ""
"Neste tutorial, você criará um banco de dados de filmes do Monty Python "
"usando a funcionalidade básica :mod:`!sqlite3`. Ele pressupõe uma "
"compreensão fundamental dos conceitos de banco de dados, incluindo "
"`cursores`_ e `transações`_."

#: ../../library/sqlite3.rst:75
msgid ""
"First, we need to create a new database and open a database connection to "
"allow :mod:`!sqlite3` to work with it. Call :func:`sqlite3.connect` to "
"create a connection to the database :file:`tutorial.db` in the current "
"working directory, implicitly creating it if it does not exist:"
msgstr ""
"Primeiro, precisamos criar um novo banco de dados e abrir uma conexão com o "
"banco de dados para permitir que :mod:`!sqlite3` funcione com ele. Chame :"
"func:`sqlite3.connect` para criar uma conexão com o banco de dados :file:"
"`tutorial.db` no diretório de trabalho atual, criando-o implicitamente se "
"ele não existir:"

#: ../../library/sqlite3.rst:81
msgid ""
"import sqlite3\n"
"con = sqlite3.connect(\"tutorial.db\")"
msgstr ""
"import sqlite3\n"
"con = sqlite3.connect(\"tutorial.db\")"

#: ../../library/sqlite3.rst:86
msgid ""
"The returned :class:`Connection` object ``con`` represents the connection to "
"the on-disk database."
msgstr ""
"O objeto :class:`Connection` ``con`` retornado representa a conexão com o "
"banco de dados em disco."

#: ../../library/sqlite3.rst:89
msgid ""
"In order to execute SQL statements and fetch results from SQL queries, we "
"will need to use a database cursor. Call :meth:`con.cursor() <Connection."
"cursor>` to create the :class:`Cursor`:"
msgstr ""
"Para executar instruções SQL e buscar resultados de consultas SQL, "
"precisaremos usar um cursor de banco de dados. Chame :meth:`con.cursor() "
"<Connection.cursor>` para criar o :class:`Cursor`:"

#: ../../library/sqlite3.rst:93
msgid "cur = con.cursor()"
msgstr "cur = con.cursor()"

#: ../../library/sqlite3.rst:97
msgid ""
"Now that we've got a database connection and a cursor, we can create a "
"database table ``movie`` with columns for title, release year, and review "
"score. For simplicity, we can just use column names in the table declaration "
"-- thanks to the `flexible typing`_ feature of SQLite, specifying the data "
"types is optional. Execute the ``CREATE TABLE`` statement by calling :meth:"
"`cur.execute(...) <Cursor.execute>`:"
msgstr ""
"Agora que temos uma conexão com o banco de dados e um cursor, podemos criar "
"uma tabela de banco de dados ``movie`` com colunas para título, ano de "
"lançamento e pontuação da revisão. Para simplificar, podemos apenas usar "
"nomes de colunas na declaração da tabela - graças ao recurso `tipagem "
"flexível`_ do SQLite, especificar os tipos de dados é opcional. Execute a "
"instrução ``CREATE TABLE`` chamando :meth:`cur.execute(...) <Cursor."
"execute>`:"

#: ../../library/sqlite3.rst:106
msgid "cur.execute(\"CREATE TABLE movie(title, year, score)\")"
msgstr "cur.execute(\"CREATE TABLE movie(title, year, score)\")"

#: ../../library/sqlite3.rst:113
msgid ""
"We can verify that the new table has been created by querying the "
"``sqlite_master`` table built-in to SQLite, which should now contain an "
"entry for the ``movie`` table definition (see `The Schema Table`_ for "
"details). Execute that query by calling :meth:`cur.execute(...) <Cursor."
"execute>`, assign the result to ``res``, and call :meth:`res.fetchone() "
"<Cursor.fetchone>` to fetch the resulting row:"
msgstr ""
"Podemos verificar se a nova tabela foi criada consultando a tabela embutida "
"``sqlite_master`` no SQLite, que agora deve conter uma entrada para a "
"definição da tabela ``movie`` (veja `The Schema Table`_ para detalhes). "
"Execute essa consulta chamando :meth:`cur.execute(...) <Cursor.execute>`, "
"atribua o resultado a ``res`` e chame :meth:`res.fetchone() <Cursor."
"fetchone>` para buscar a linha resultante:"

#: ../../library/sqlite3.rst:121
msgid ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master\")\n"
">>> res.fetchone()\n"
"('movie',)"
msgstr ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master\")\n"
">>> res.fetchone()\n"
"('movie',)"

#: ../../library/sqlite3.rst:127
msgid ""
"We can see that the table has been created, as the query returns a :class:"
"`tuple` containing the table's name. If we query ``sqlite_master`` for a non-"
"existent table ``spam``, :meth:`!res.fetchone` will return ``None``:"
msgstr ""
"Podemos ver que a tabela foi criada, pois a consulta retorna :class:`tuple` "
"contendo o nome da tabela. Se fizermos uma consulta ``sqlite_master`` para "
"uma tabela inexistente ``spam``, :meth:`!res.fetchone` ela retornará "
"``None``:"

#: ../../library/sqlite3.rst:132
msgid ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master WHERE name='spam'\")\n"
">>> res.fetchone() is None\n"
"True"
msgstr ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master WHERE name='spam'\")\n"
">>> res.fetchone() is None\n"
"True"

#: ../../library/sqlite3.rst:138
msgid ""
"Now, add two rows of data supplied as SQL literals by executing an "
"``INSERT`` statement, once again by calling :meth:`cur.execute(...) <Cursor."
"execute>`:"
msgstr ""
"Agora, adicione duas linhas de dados fornecidos como literais SQL executando "
"uma instrução ``INSERT``, mais uma vez chamando :meth:`cur.execute(...) "
"<Cursor.execute>`:"

#: ../../library/sqlite3.rst:142
msgid ""
"cur.execute(\"\"\"\n"
"    INSERT INTO movie VALUES\n"
"        ('Monty Python and the Holy Grail', 1975, 8.2),\n"
"        ('And Now for Something Completely Different', 1971, 7.5)\n"
"\"\"\")"
msgstr ""
"cur.execute(\"\"\"\n"
"    INSERT INTO movie VALUES\n"
"        ('Monty Python and the Holy Grail', 1975, 8.2),\n"
"        ('And Now for Something Completely Different', 1971, 7.5)\n"
"\"\"\")"

#: ../../library/sqlite3.rst:150
msgid ""
"The ``INSERT`` statement implicitly opens a transaction, which needs to be "
"committed before changes are saved in the database (see :ref:`sqlite3-"
"controlling-transactions` for details). Call :meth:`con.commit() <Connection."
"commit>` on the connection object to commit the transaction:"
msgstr ""
"A instrução ``INSERT`` abre implicitamente uma transação, que precisa ser "
"confirmada antes que as alterações sejam salvas no banco de dados (veja :ref:"
"`sqlite3-controlling-transactions` para detalhes). Chame :meth:`con.commit() "
"<Connection.commit>` no objeto de conexão para confirmar a transação:"

#: ../../library/sqlite3.rst:156
msgid "con.commit()"
msgstr "con.commit()"

#: ../../library/sqlite3.rst:160
msgid ""
"We can verify that the data was inserted correctly by executing a ``SELECT`` "
"query. Use the now-familiar :meth:`cur.execute(...) <Cursor.execute>` to "
"assign the result to ``res``, and call :meth:`res.fetchall() <Cursor."
"fetchall>` to return all resulting rows:"
msgstr ""
"Podemos verificar que os dados foram inseridos corretamente executando uma "
"consulta ``SELECT``. Use o já conhecido :meth:`cur.execute(...) <Cursor."
"execute>` para atribuir o resultado a ``res`` e chame :meth:`res.fetchall() "
"<Cursor.fetchall>` para retornar todas as linhas resultantes."

#: ../../library/sqlite3.rst:166
msgid ""
">>> res = cur.execute(\"SELECT score FROM movie\")\n"
">>> res.fetchall()\n"
"[(8.2,), (7.5,)]"
msgstr ""
">>> res = cur.execute(\"SELECT score FROM movie\")\n"
">>> res.fetchall()\n"
"[(8.2,), (7.5,)]"

#: ../../library/sqlite3.rst:172
msgid ""
"The result is a :class:`list` of two :class:`!tuple`\\s, one per row, each "
"containing that row's ``score`` value."
msgstr ""
"O resultado é uma :class:`list` de duas :class:`!tuple`\\s, uma por linha, "
"cada uma contendo o valor ``score`` dessa linha."

#: ../../library/sqlite3.rst:175
msgid ""
"Now, insert three more rows by calling :meth:`cur.executemany(...) <Cursor."
"executemany>`:"
msgstr ""
"Agora, insira mais três linhas chamando :meth:`cur.executemany(...) <Cursor."
"executemany>`:"

#: ../../library/sqlite3.rst:178
msgid ""
"data = [\n"
"    (\"Monty Python Live at the Hollywood Bowl\", 1982, 7.9),\n"
"    (\"Monty Python's The Meaning of Life\", 1983, 7.5),\n"
"    (\"Monty Python's Life of Brian\", 1979, 8.0),\n"
"]\n"
"cur.executemany(\"INSERT INTO movie VALUES(?, ?, ?)\", data)\n"
"con.commit()  # Remember to commit the transaction after executing INSERT."
msgstr ""
"data = [\n"
"    (\"Monty Python Live at the Hollywood Bowl\", 1982, 7.9),\n"
"    (\"Monty Python's The Meaning of Life\", 1983, 7.5),\n"
"    (\"Monty Python's Life of Brian\", 1979, 8.0),\n"
"]\n"
"cur.executemany(\"INSERT INTO movie VALUES(?, ?, ?)\", data)\n"
"con.commit()  # Lembre-sede executar a transação após o INSERT."

#: ../../library/sqlite3.rst:188
msgid ""
"Notice that ``?`` placeholders are used to bind ``data`` to the query. "
"Always use placeholders instead of :ref:`string formatting <tut-formatting>` "
"to bind Python values to SQL statements, to avoid `SQL injection attacks`_ "
"(see :ref:`sqlite3-placeholders` for more details)."
msgstr ""
"Observe que espaços reservados ``?`` são usados para vincular ``data`` à "
"consulta. Sempre use espaços reservados em vez de :ref:`formatação de string "
"<tut-formatting>` para vincular valores Python a instruções SQL, para evitar "
"`ataques de injeção de SQL`_ (consulte :ref:`sqlite3-placeholders` para mais "
"detalhes)."

#: ../../library/sqlite3.rst:194
msgid ""
"We can verify that the new rows were inserted by executing a ``SELECT`` "
"query, this time iterating over the results of the query:"
msgstr ""
"Podemos verificar que as novas linhas foram inseridas executando uma "
"consulta ``SELECT``, desta vez iterando sobre os resultados da consulta."

#: ../../library/sqlite3.rst:198
msgid ""
">>> for row in cur.execute(\"SELECT year, title FROM movie ORDER BY "
"year\"):\n"
"...     print(row)\n"
"(1971, 'And Now for Something Completely Different')\n"
"(1975, 'Monty Python and the Holy Grail')\n"
"(1979, \"Monty Python's Life of Brian\")\n"
"(1982, 'Monty Python Live at the Hollywood Bowl')\n"
"(1983, \"Monty Python's The Meaning of Life\")"
msgstr ""
">>> for row in cur.execute(\"SELECT year, title FROM movie ORDER BY "
"year\"):\n"
"...     print(row)\n"
"(1971, 'And Now for Something Completely Different')\n"
"(1975, 'Monty Python and the Holy Grail')\n"
"(1979, \"Monty Python's Life of Brian\")\n"
"(1982, 'Monty Python Live at the Hollywood Bowl')\n"
"(1983, \"Monty Python's The Meaning of Life\")"

#: ../../library/sqlite3.rst:208
msgid ""
"Each row is a two-item :class:`tuple` of ``(year, title)``, matching the "
"columns selected in the query."
msgstr ""
"Cada linha é uma :class:`tuple` de dois itens ``(year, title)``, "
"correspondendo às colunas selecionadas na consulta."

#: ../../library/sqlite3.rst:211
msgid ""
"Finally, verify that the database has been written to disk by calling :meth:"
"`con.close() <Connection.close>` to close the existing connection, opening a "
"new one, creating a new cursor, then querying the database:"
msgstr ""
"Finalmente, verifique se o banco de dados foi gravado no disco chamando :"
"meth:`con.close() <Connection.close>` para fechar a conexão existente, abrir "
"uma nova, criar um novo cursor e, em seguida, consultar o banco de dados."

#: ../../library/sqlite3.rst:216
msgid ""
">>> con.close()\n"
">>> new_con = sqlite3.connect(\"tutorial.db\")\n"
">>> new_cur = new_con.cursor()\n"
">>> res = new_cur.execute(\"SELECT title, year FROM movie ORDER BY score "
"DESC\")\n"
">>> title, year = res.fetchone()\n"
">>> print(f'The highest scoring Monty Python movie is {title!r}, released in "
"{year}')\n"
"The highest scoring Monty Python movie is 'Monty Python and the Holy Grail', "
"released in 1975\n"
">>> new_con.close()"
msgstr ""
">>> con.close()\n"
">>> new_con = sqlite3.connect(\"tutorial.db\")\n"
">>> new_cur = new_con.cursor()\n"
">>> res = new_cur.execute(\"SELECT title, year FROM movie ORDER BY score "
"DESC\")\n"
">>> title, year = res.fetchone()\n"
">>> print(f'The highest scoring Monty Python movie is {title!r}, released in "
"{year}')\n"
"The highest scoring Monty Python movie is 'Monty Python and the Holy Grail', "
"released in 1975\n"
">>> new_con.close()"

#: ../../library/sqlite3.rst:227
msgid ""
"You've now created an SQLite database using the :mod:`!sqlite3` module, "
"inserted data and retrieved values from it in multiple ways."
msgstr ""
"Você agora criou um banco de dados SQLite usando o módulo :mod:`!sqlite3`, "
"inseriu dados e recuperou valores dele de várias maneiras."

#: ../../library/sqlite3.rst:239
msgid ":ref:`sqlite3-howtos` for further reading:"
msgstr ":ref:`sqlite3-howtos` para leitura adicional:"

#: ../../library/sqlite3.rst:241
msgid ":ref:`sqlite3-placeholders`"
msgstr ":ref:`sqlite3-placeholders`"

#: ../../library/sqlite3.rst:242
msgid ":ref:`sqlite3-adapters`"
msgstr ":ref:`sqlite3-adapters`"

#: ../../library/sqlite3.rst:243
msgid ":ref:`sqlite3-converters`"
msgstr ":ref:`sqlite3-converters`"

#: ../../library/sqlite3.rst:244 ../../library/sqlite3.rst:618
msgid ":ref:`sqlite3-connection-context-manager`"
msgstr ":ref:`sqlite3-connection-context-manager`"

#: ../../library/sqlite3.rst:245
msgid ":ref:`sqlite3-howto-row-factory`"
msgstr ":ref:`sqlite3-howto-row-factory`"

#: ../../library/sqlite3.rst:247
msgid ""
":ref:`sqlite3-explanation` for in-depth background on transaction control."
msgstr ""
":ref:`sqlite3-explanation` para obter informações detalhadas sobre o "
"controle de transações."

#: ../../library/sqlite3.rst:252
msgid "Reference"
msgstr "Referência"

#: ../../library/sqlite3.rst:260
msgid "Module functions"
msgstr "Funções do módulo"

#: ../../library/sqlite3.rst:268
msgid "Open a connection to an SQLite database."
msgstr "Abra uma conexão com um banco de dados SQLite."

#: ../../library/sqlite3.rst:0
msgid "Parameters"
msgstr "Parâmetros"

#: ../../library/sqlite3.rst:270
msgid ""
"The path to the database file to be opened. You can pass ``\":memory:\"`` to "
"create an `SQLite database existing only in memory <https://sqlite.org/"
"inmemorydb.html>`_, and open a connection to it."
msgstr ""
"O caminho para o arquivo do banco de dados a ser aberto. Você pode passar "
"``\":memory:\"`` para criar um banco de dados `SQLite que existirá apenas na "
"memória <https://sqlite.org/inmemorydb.html>`_, e abrir uma conexão com ele."

#: ../../library/sqlite3.rst:277
msgid ""
"How many seconds the connection should wait before raising an :exc:"
"`OperationalError` when a table is locked. If another connection opens a "
"transaction to modify a table, that table will be locked until the "
"transaction is committed. Default five seconds."
msgstr ""
"Quantos segundos a conexão deve aguardar antes de levantar uma exceção :exc:"
"`OperationalError` quando uma tabela estiver bloqueada. Se outra conexão "
"abrir uma transação para modificar uma tabela, essa tabela permanecerá "
"bloqueada até que a transação seja confirmada. O padrão é cinco segundos."

#: ../../library/sqlite3.rst:284
msgid ""
"Control whether and how data types not :ref:`natively supported by SQLite "
"<sqlite3-types>` are looked up to be converted to Python types, using the "
"converters registered with :func:`register_converter`. Set it to any "
"combination (using ``|``, bitwise or) of :const:`PARSE_DECLTYPES` and :const:"
"`PARSE_COLNAMES` to enable this. Column names takes precedence over declared "
"types if both flags are set. By default (``0``), type detection is disabled."
msgstr ""
"Контролируйте, будут ли типы данных, не :ref:`изначально поддерживаемые "
"SQLite <sqlite3-types>`, искаться для преобразования в типы Python, "
"используя конвертеры, зарегистрированные с помощью :func:"
"`register_converter`. Установите его в любую комбинацию (используя ``|``, "
"побитовое ИЛИ) :const:`PARSE_DECLTYPES` и :const:`PARSE_COLNAMES`, чтобы "
"включить это. Имена столбцов имеют приоритет над объявленными типами, если "
"установлены оба флага. По умолчанию (``0``) определение типа отключено."

#: ../../library/sqlite3.rst:295
msgid ""
"Control legacy transaction handling behaviour. See :attr:`Connection."
"isolation_level` and :ref:`sqlite3-transaction-control-isolation-level` for "
"more information. Can be ``\"DEFERRED\"`` (default), ``\"EXCLUSIVE\"`` or "
"``\"IMMEDIATE\"``; or ``None`` to disable opening transactions implicitly. "
"Has no effect unless :attr:`Connection.autocommit` is set to :const:"
"`~sqlite3.LEGACY_TRANSACTION_CONTROL` (the default)."
msgstr ""
"Управляйте поведением обработки устаревших транзакций. См. :attr:`Connection."
"isolation_level` и :ref:`sqlite3-transaction-control-isolation-level` для "
"получения дополнительной информации. Может быть ``\"ОТЛОЖЕНО\"`` (по "
"умолчанию), ``\"ЭКСКЛЮЗИВНО\"`` или ``\"НЕМЕДЛЕННО\"``; или ``None``, чтобы "
"неявно запретить открытие транзакций. Не имеет никакого эффекта, если для :"
"attr:`Connection.autocommit` не установлено значение :const:`~sqlite3."
"LEGACY_TRANSACTION_CONTROL` (по умолчанию)."

#: ../../library/sqlite3.rst:305
msgid ""
"If ``True`` (default), :exc:`ProgrammingError` will be raised if the "
"database connection is used by a thread other than the one that created it. "
"If ``False``, the connection may be accessed in multiple threads; write "
"operations may need to be serialized by the user to avoid data corruption. "
"See :attr:`threadsafety` for more information."
msgstr ""
"Если ``True`` (по умолчанию), :exc:`ProgrammingError` будет вызвано, если "
"соединение с базой данных используется потоком, отличным от того, который "
"его создал. Если ``False``, доступ к соединению может осуществляться в "
"нескольких потоках; Операции записи могут потребоваться сериализовать "
"пользователю, чтобы избежать повреждения данных. См. :attr:`threadsafety` "
"для получения дополнительной информации."

#: ../../library/sqlite3.rst:314
msgid ""
"A custom subclass of :class:`Connection` to create the connection with, if "
"not the default :class:`Connection` class."
msgstr ""
"Пользовательский подкласс :class:`Connection` для создания соединения с "
"классом :class:`Connection` (если не с классом по умолчанию)."

#: ../../library/sqlite3.rst:318
msgid ""
"The number of statements that :mod:`!sqlite3` should internally cache for "
"this connection, to avoid parsing overhead. By default, 128 statements."
msgstr ""
"Число операторов, которые :mod:`!sqlite3` должен внутренне кэшировать для "
"этого соединения, чтобы избежать накладных расходов на анализ. По умолчанию "
"128 операторов."

#: ../../library/sqlite3.rst:323
msgid ""
"If set to ``True``, *database* is interpreted as a :abbr:`URI (Uniform "
"Resource Identifier)` with a file path and an optional query string. The "
"scheme part *must* be ``\"file:\"``, and the path can be relative or "
"absolute. The query string allows passing parameters to SQLite, enabling "
"various :ref:`sqlite3-uri-tricks`."
msgstr ""
"Если установлено значение True, *database* интерпретируется как :abbr:`URI "
"(универсальный идентификатор ресурса)` с путем к файлу и дополнительной "
"строкой запроса. Часть схемы *должна* быть ``\"file:\"``, а путь может быть "
"относительным или абсолютным. Строка запроса позволяет передавать параметры "
"в SQLite, используя различные трюки sqlite3-uri."

#: ../../library/sqlite3.rst:332
msgid ""
"Control :pep:`249` transaction handling behaviour. See :attr:`Connection."
"autocommit` and :ref:`sqlite3-transaction-control-autocommit` for more "
"information. *autocommit* currently defaults to :const:`~sqlite3."
"LEGACY_TRANSACTION_CONTROL`. The default will change to ``False`` in a "
"future Python release."
msgstr ""
"Управляйте :pep:`249` поведением обработки транзакций. См. :attr:`Connection."
"autocommit` и :ref:`sqlite3-transaction-control-autocommit` для получения "
"дополнительной информации. *autocommit* в настоящее время по умолчанию имеет "
"значение :const:`~sqlite3.LEGACY_TRANSACTION_CONTROL`. В будущем выпуске "
"Python значение по умолчанию изменится на «False»."

#: ../../library/sqlite3.rst:0
msgid "Return type"
msgstr "Тип возврата"

#: ../../library/sqlite3.rst:343
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect`` with argument "
"``database``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``sqlite3.connect`` com o "
"argumento ``database``."

#: ../../library/sqlite3.rst:344
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect/handle`` with "
"argument ``connection_handle``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``sqlite3.connect/handle`` "
"com o argumento ``connection_handle``."

#: ../../library/sqlite3.rst:346
msgid "Added the *uri* parameter."
msgstr "Adicionado o parâmetro *uri*."

#: ../../library/sqlite3.rst:349
msgid ""
"*database* can now also be a :term:`path-like object`, not only a string."
msgstr ""
"*database* тепер також може бути :term:`path-like object`, а не лише рядком."

#: ../../library/sqlite3.rst:352
msgid "Added the ``sqlite3.connect/handle`` auditing event."
msgstr "Додано подію аудиту ``sqlite3.connect/handle``."

#: ../../library/sqlite3.rst:355
msgid "Added the *autocommit* parameter."
msgstr "Добавлен параметр *autocommit*."

#: ../../library/sqlite3.rst:358
msgid ""
"Positional use of the parameters *timeout*, *detect_types*, "
"*isolation_level*, *check_same_thread*, *factory*, *cached_statements*, and "
"*uri* is deprecated. They will become keyword-only parameters in Python 3.15."
msgstr ""
"Позиционное использование параметров *timeout*, *detect_types*, "
"*isolation_level*, *check_same_thread*, *factory*, *cached_statements* и "
"*uri* устарело. В Python 3.15 они станут параметрами только для ключевых "
"слов."

#: ../../library/sqlite3.rst:366
msgid ""
"Return ``True`` if the string *statement* appears to contain one or more "
"complete SQL statements. No syntactic verification or parsing of any kind is "
"performed, other than checking that there are no unclosed string literals "
"and the statement is terminated by a semicolon."
msgstr ""
"Возвращайте ``True``, если строка *оператор* содержит один или несколько "
"полных операторов SQL. Никакая синтаксическая проверка или синтаксический "
"анализ не выполняется, кроме проверки отсутствия незамкнутых строковых "
"литералов и завершения оператора точкой с запятой."

#: ../../library/sqlite3.rst:372
msgid "For example:"
msgstr "Por exemplo:"

#: ../../library/sqlite3.rst:374
msgid ""
">>> sqlite3.complete_statement(\"SELECT foo FROM bar;\")\n"
"True\n"
">>> sqlite3.complete_statement(\"SELECT foo\")\n"
"False"
msgstr ""
">>> sqlite3.complete_statement(\"SELECT foo FROM bar;\")\n"
"True\n"
">>> sqlite3.complete_statement(\"SELECT foo\")\n"
"False"

#: ../../library/sqlite3.rst:381
msgid ""
"This function may be useful during command-line input to determine if the "
"entered text seems to form a complete SQL statement, or if additional input "
"is needed before calling :meth:`~Cursor.execute`."
msgstr ""
"Эта функция может быть полезна во время ввода командной строки, чтобы "
"определить, образует ли введенный текст полный оператор SQL, или требуется "
"ли дополнительный ввод перед вызовом :meth:`~Cursor.execute`."

#: ../../library/sqlite3.rst:385
msgid ""
"See :func:`!runsource` in :source:`Lib/sqlite3/__main__.py` for real-world "
"use."
msgstr ""
"См. :func:`!runsource` в :source:`Lib/sqlite3/__main__.py` для использования "
"в реальных условиях."

#: ../../library/sqlite3.rst:390
msgid ""
"Enable or disable callback tracebacks. By default you will not get any "
"tracebacks in user-defined functions, aggregates, converters, authorizer "
"callbacks etc. If you want to debug them, you can call this function with "
"*flag* set to ``True``. Afterwards, you will get tracebacks from callbacks "
"on :data:`sys.stderr`. Use ``False`` to disable the feature again."
msgstr ""
"Включите или отключите обратные трассировки обратного вызова. По умолчанию "
"вы не будете получать никаких обратных трассировок в пользовательских "
"функциях, агрегатах, конвертерах, обратных вызовах авторизатора и т. д. Если "
"вы хотите их отладить, вы можете вызвать эту функцию с *flag*, установленным "
"в ``True``. После этого вы получите обратные трассировки от обратных вызовов "
"в :data:`sys.stderr`. Используйте «False», чтобы снова отключить эту функцию."

#: ../../library/sqlite3.rst:399
msgid ""
"Errors in user-defined function callbacks are logged as unraisable "
"exceptions. Use an :func:`unraisable hook handler <sys.unraisablehook>` for "
"introspection of the failed callback."
msgstr ""
"Ошибки в обратных вызовах пользовательских функций регистрируются как "
"невызываемые исключения. Используйте :func:`unraisable обработчик перехвата "
"<sys.unraisablehook>` для самоанализа неудачного обратного вызова."

#: ../../library/sqlite3.rst:405
msgid ""
"Register an *adapter* :term:`callable` to adapt the Python type *type* into "
"an SQLite type. The adapter is called with a Python object of type *type* as "
"its sole argument, and must return a value of a :ref:`type that SQLite "
"natively understands <sqlite3-types>`."
msgstr ""
"Зарегистрируйте *адаптер* :term:`callable`, чтобы адаптировать тип *type* "
"Python к типу SQLite. Адаптер вызывается с объектом Python типа *type* в "
"качестве единственного аргумента и должен возвращать значение типа :ref:`, "
"который SQLite изначально понимает, <sqlite3-types>`."

#: ../../library/sqlite3.rst:413
msgid ""
"Register the *converter* :term:`callable` to convert SQLite objects of type "
"*typename* into a Python object of a specific type. The converter is invoked "
"for all SQLite values of type *typename*; it is passed a :class:`bytes` "
"object and should return an object of the desired Python type. Consult the "
"parameter *detect_types* of :func:`connect` for information regarding how "
"type detection works."
msgstr ""
"Зарегистрируйте *converter* :term:`callable` для преобразования объектов "
"SQLite типа *typename* в объект Python определенного типа. Конвертер "
"вызывается для всех значений SQLite типа *typename*; ему передается объект :"
"class:`bytes`, и он должен возвращать объект желаемого типа Python. "
"Обратитесь к параметру *detect_types* функции :func:`connect` для получения "
"информации о том, как работает определение типа."

#: ../../library/sqlite3.rst:421
msgid ""
"Note: *typename* and the name of the type in your query are matched case-"
"insensitively."
msgstr ""
"Примечание. *typename* и имя типа в вашем запросе сопоставляются без учета "
"регистра."

#: ../../library/sqlite3.rst:428
msgid "Module constants"
msgstr "Constantes do módulo"

#: ../../library/sqlite3.rst:432
msgid ""
"Set :attr:`~Connection.autocommit` to this constant to select old style (pre-"
"Python 3.12) transaction control behaviour. See :ref:`sqlite3-transaction-"
"control-isolation-level` for more information."
msgstr ""
"Установите для :attr:`~Connection.autocommit` эту константу, чтобы выбрать "
"поведение управления транзакциями в старом стиле (до Python 3.12). "
"Дополнительную информацию см. в разделе sqlite3-transaction-control-"
"isolation-level."

#: ../../library/sqlite3.rst:438
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function using the declared types for each column. The "
"types are declared when the database table is created. :mod:`!sqlite3` will "
"look up a converter function using the first word of the declared type as "
"the converter dictionary key. For example:"
msgstr ""
"Передайте значение этого флага в параметр *detect_types* функции :func:"
"`connect`, чтобы найти функцию конвертера, используя объявленные типы для "
"каждого столбца. Типы объявляются при создании таблицы базы данных. :mod:`!"
"sqlite3` будет искать функцию конвертера, используя первое слово "
"объявленного типа в качестве ключа словаря конвертера. Например:"

#: ../../library/sqlite3.rst:446
msgid ""
"CREATE TABLE test(\n"
"   i integer primary key,  ! will look up a converter named \"integer\"\n"
"   p point,                ! will look up a converter named \"point\"\n"
"   n number(10)            ! will look up a converter named \"number\"\n"
" )"
msgstr ""
"CREATE TABLE test(\n"
"   i integer primary key,  ! will look up a converter named \"integer\"\n"
"   p point,                ! will look up a converter named \"point\"\n"
"   n number(10)            ! will look up a converter named \"number\"\n"
" )"

#: ../../library/sqlite3.rst:454
msgid ""
"This flag may be combined with :const:`PARSE_COLNAMES` using the ``|`` "
"(bitwise or) operator."
msgstr ""
"Этот флаг можно комбинировать с :const:`PARSE_COLNAMES` с помощью оператора "
"``|`` (побитовое или)."

#: ../../library/sqlite3.rst:459
msgid ""
"Generated fields (for example ``MAX(p)``) are returned as :class:`str`. Use :"
"const:`!PARSE_COLNAMES` to enforce types for such queries."
msgstr ""
"生成的字段 (例如 ``MAX(p)``) 将作为 :class:`str` 返回。 使用 :const:`!"
"PARSE_COLNAMES` 为这样的查询设置类型。"

#: ../../library/sqlite3.rst:464
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function by using the type name, parsed from the query "
"column name, as the converter dictionary key. The query column name must be "
"wrapped in double quotes (``\"``) and the type name must be wrapped in "
"square brackets (``[]``)."
msgstr ""
"Передайте это значение флага параметру *detect_types* :func:`connect` для "
"поиска функции преобразователя, используя имя типа, проанализированное из "
"имени столбца запроса, как ключ словаря преобразователя. Имя столбца запроса "
"должно быть заключено в двойные кавычки (``\"``), а имя типа должно быть "
"заключено в квадратные скобки (``[]``)."

#: ../../library/sqlite3.rst:471
msgid ""
"SELECT MAX(p) as \"p [point]\" FROM test;  ! will look up converter \"point\""
msgstr ""
"SELECT MAX(p) as \"p [point]\" FROM test;  ! will look up converter \"point\""

#: ../../library/sqlite3.rst:475
msgid ""
"This flag may be combined with :const:`PARSE_DECLTYPES` using the ``|`` "
"(bitwise or) operator."
msgstr ""
"Этот флаг можно комбинировать с :const:`PARSE_DECLTYPES` с помощью оператора "
"``|`` (побитовое или)."

#: ../../library/sqlite3.rst:482
msgid ""
"Flags that should be returned by the *authorizer_callback* :term:`callable` "
"passed to :meth:`Connection.set_authorizer`, to indicate whether:"
msgstr ""
"Флаги, которые должны быть возвращены *authorizer_callback* :term:"
"`callable`, переданным в :meth:`Connection.set_authorizer`, чтобы указать:"

#: ../../library/sqlite3.rst:485
msgid "Access is allowed (:const:`!SQLITE_OK`),"
msgstr "Доступ разрешен (:const:`!SQLITE_OK`),"

#: ../../library/sqlite3.rst:486
msgid ""
"The SQL statement should be aborted with an error (:const:`!SQLITE_DENY`)"
msgstr ""
"Выполнение оператора SQL должно быть прервано с ошибкой (:const:`!"
"SQLITE_DENY`)"

#: ../../library/sqlite3.rst:487
msgid ""
"The column should be treated as a ``NULL`` value (:const:`!SQLITE_IGNORE`)"
msgstr ""
"Столбец следует рассматривать как значение ``NULL`` (:const:`!"
"SQLITE_IGNORE`)."

#: ../../library/sqlite3.rst:491
msgid ""
"String constant stating the supported DB-API level. Required by the DB-API. "
"Hard-coded to ``\"2.0\"``."
msgstr ""
"Рядкова константа, що вказує підтримуваний рівень DB-API. Потрібний для DB-"
"API. Жорстко закодований на ``\"2.0\"``."

#: ../../library/sqlite3.rst:496
msgid ""
"String constant stating the type of parameter marker formatting expected by "
"the :mod:`!sqlite3` module. Required by the DB-API. Hard-coded to "
"``\"qmark\"``."
msgstr ""
"Строковая константа, указывающая тип форматирования маркера параметра, "
"ожидаемый модулем :mod:`!sqlite3`. Требуется для DB-API. Жестко "
"запрограммировано в ``\"qmark\"``."

#: ../../library/sqlite3.rst:502
msgid "The ``named`` DB-API parameter style is also supported."
msgstr "Также поддерживается стиль параметров DB-API ``named``."

#: ../../library/sqlite3.rst:506
msgid ""
"Version number of the runtime SQLite library as a :class:`string <str>`."
msgstr ""
"Номер версии библиотеки времени выполнения SQLite в виде :class:`string "
"<str>`."

#: ../../library/sqlite3.rst:510
msgid ""
"Version number of the runtime SQLite library as a :class:`tuple` of :class:"
"`integers <int>`."
msgstr ""
"Номер версии библиотеки времени выполнения SQLite в виде :class:`tuple` из :"
"class:`integers <int>`."

#: ../../library/sqlite3.rst:515
msgid ""
"Integer constant required by the DB-API 2.0, stating the level of thread "
"safety the :mod:`!sqlite3` module supports. This attribute is set based on "
"the default `threading mode <https://sqlite.org/threadsafe.html>`_ the "
"underlying SQLite library is compiled with. The SQLite threading modes are:"
msgstr ""
"Целочисленная константа, требуемая DB-API 2.0, указывающая уровень "
"потокобезопасности, поддерживаемый модулем :mod:`!sqlite3`. Этот атрибут "
"устанавливается на основе `поточного режима <https://sqlite.org/threadsafe."
"html>`_ по умолчанию, с которым скомпилирована базовая библиотека SQLite. "
"Режимы потоков SQLite:"

#: ../../library/sqlite3.rst:520
msgid ""
"**Single-thread**: In this mode, all mutexes are disabled and SQLite is "
"unsafe to use in more than a single thread at once."
msgstr ""
"**Однопоточный**: в этом режиме все мьютексы отключены, и SQLite небезопасно "
"использовать более чем в одном потоке одновременно."

#: ../../library/sqlite3.rst:522
msgid ""
"**Multi-thread**: In this mode, SQLite can be safely used by multiple "
"threads provided that no single database connection is used simultaneously "
"in two or more threads."
msgstr ""
"**Многопоточный**: в этом режиме SQLite можно безопасно использовать в "
"нескольких потоках при условии, что ни одно соединение с базой данных не "
"используется одновременно в двух или более потоках."

#: ../../library/sqlite3.rst:525
msgid ""
"**Serialized**: In serialized mode, SQLite can be safely used by multiple "
"threads with no restriction."
msgstr ""
"**Сериализация**: в сериализованном режиме SQLite может безопасно "
"использоваться несколькими потоками без ограничений."

#: ../../library/sqlite3.rst:528
msgid ""
"The mappings from SQLite threading modes to DB-API 2.0 threadsafety levels "
"are as follows:"
msgstr ""
"Сопоставления режимов потоков SQLite с уровнями безопасности потоков DB-API "
"2.0 следующие:"

#: ../../library/sqlite3.rst:532
msgid "SQLite threading mode"
msgstr "Режим потоков SQLite"

#: ../../library/sqlite3.rst:532
msgid ":pep:`threadsafety <0249#threadsafety>`"
msgstr ":pep:`threadsafety <0249#threadsafety>`"

#: ../../library/sqlite3.rst:532
msgid "`SQLITE_THREADSAFE`_"
msgstr "`SQLITE_THREADSAFE`_"

#: ../../library/sqlite3.rst:532
msgid "DB-API 2.0 meaning"
msgstr "Значение DB-API 2.0"

#: ../../library/sqlite3.rst:535
msgid "single-thread"
msgstr "однопоточный"

#: ../../library/sqlite3.rst:535
msgid "0"
msgstr "0"

#: ../../library/sqlite3.rst:535
msgid "Threads may not share the module"
msgstr "Потоки не могут совместно использовать модуль"

#: ../../library/sqlite3.rst:538
msgid "multi-thread"
msgstr "многопоточный"

#: ../../library/sqlite3.rst:538 ../../library/sqlite3.rst:541
msgid "1"
msgstr "1"

#: ../../library/sqlite3.rst:538
msgid "2"
msgstr "2"

#: ../../library/sqlite3.rst:538
msgid "Threads may share the module, but not connections"
msgstr "Потоки могут совместно использовать модуль, но не соединения."

#: ../../library/sqlite3.rst:541
msgid "serialized"
msgstr "сериализованный"

#: ../../library/sqlite3.rst:541
msgid "3"
msgstr "3"

#: ../../library/sqlite3.rst:541
msgid "Threads may share the module, connections and cursors"
msgstr "Потоки могут совместно использовать модуль, соединения и курсоры."

#: ../../library/sqlite3.rst:547
msgid "Set *threadsafety* dynamically instead of hard-coding it to ``1``."
msgstr ""
"Устанавливайте *threadsafety* динамически, а не жестко запрограммируйте его "
"на «1»."

#: ../../library/sqlite3.rst:552
msgid ""
"Version number of this module as a :class:`string <str>`. This is not the "
"version of the SQLite library."
msgstr ""

#: ../../library/sqlite3.rst:555 ../../library/sqlite3.rst:565
msgid ""
"This constant used to reflect the version number of the ``pysqlite`` "
"package, a third-party library which used to upstream changes to :mod:`!"
"sqlite3`. Today, it carries no meaning or practical value."
msgstr ""

#: ../../library/sqlite3.rst:562
msgid ""
"Version number of this module as a :class:`tuple` of :class:`integers "
"<int>`. This is not the version of the SQLite library."
msgstr ""

#: ../../library/sqlite3.rst:589
msgid ""
"These constants are used for the :meth:`Connection.setconfig` and :meth:"
"`~Connection.getconfig` methods."
msgstr ""
"Эти константы используются для методов :meth:`Connection.setconfig` и :meth:"
"`~Connection.getconfig`."

#: ../../library/sqlite3.rst:592
msgid ""
"The availability of these constants varies depending on the version of "
"SQLite Python was compiled with."
msgstr ""
"Доступность этих констант зависит от версии SQLite Python, с которой был "
"скомпилирован."

#: ../../library/sqlite3.rst:599
msgid "https://www.sqlite.org/c3ref/c_dbconfig_defensive.html"
msgstr "https://www.sqlite.org/c3ref/c_dbconfig_defensive.html"

#: ../../library/sqlite3.rst:600
msgid "SQLite docs: Database Connection Configuration Options"
msgstr "Документация SQLite: Параметры конфигурации подключения к базе данных"

#: ../../library/sqlite3.rst:606
msgid "Connection objects"
msgstr "Объекты подключения"

#: ../../library/sqlite3.rst:610
msgid ""
"Each open SQLite database is represented by a ``Connection`` object, which "
"is created using :func:`sqlite3.connect`. Their main purpose is creating :"
"class:`Cursor` objects, and :ref:`sqlite3-controlling-transactions`."
msgstr ""
"Каждая открытая база данных SQLite представлена ​​объектом Connection, который "
"создается с помощью :func:`sqlite3.connect`. Их основная цель — создание "
"объектов :class:`Cursor` и :ref:`sqlite3-controlling-transactions`."

#: ../../library/sqlite3.rst:617
msgid ":ref:`sqlite3-connection-shortcuts`"
msgstr ":ref:`sqlite3-connection-shortcuts`"

#: ../../library/sqlite3.rst:623
msgid ""
"A :exc:`ResourceWarning` is emitted if :meth:`close` is not called before a :"
"class:`!Connection` object is deleted."
msgstr ""
":exc:`ResourceWarning` выдается, если :meth:`close` не вызывается перед "
"удалением объекта :class:`!Connection`."

#: ../../library/sqlite3.rst:626
msgid "An SQLite database connection has the following attributes and methods:"
msgstr "Підключення до бази даних SQLite має такі атрибути та методи:"

#: ../../library/sqlite3.rst:630
msgid ""
"Create and return a :class:`Cursor` object. The cursor method accepts a "
"single optional parameter *factory*. If supplied, this must be a :term:"
"`callable` returning an instance of :class:`Cursor` or its subclasses."
msgstr ""
"Создайте и верните объект :class:`Cursor`. Метод курсора принимает один "
"необязательный параметр *factory*. Если указано, это должен быть :term:"
"`callable`, возвращающий экземпляр :class:`Cursor` или его подклассов."

#: ../../library/sqlite3.rst:637
msgid ""
"Open a :class:`Blob` handle to an existing :abbr:`BLOB (Binary Large "
"OBject)`."
msgstr ""
"Откройте дескриптор :class:`Blob` для существующего :abbr:`BLOB (большого "
"двоичного объекта)`."

#: ../../library/sqlite3.rst:640
msgid "The name of the table where the blob is located."
msgstr "Имя таблицы, в которой находится большой двоичный объект."

#: ../../library/sqlite3.rst:643
msgid "The name of the column where the blob is located."
msgstr "Имя столбца, в котором расположен большой двоичный объект."

#: ../../library/sqlite3.rst:646
msgid "The name of the row where the blob is located."
msgstr "Имя строки, в которой находится большой двоичный объект."

#: ../../library/sqlite3.rst:649
msgid ""
"Set to ``True`` if the blob should be opened without write permissions. "
"Defaults to ``False``."
msgstr ""
"Установите значение True, если большой двоичный объект должен быть открыт "
"без разрешений на запись. По умолчанию установлено значение «False»."

#: ../../library/sqlite3.rst:654
msgid ""
"The name of the database where the blob is located. Defaults to ``\"main\"``."
msgstr ""
"Имя базы данных, в которой находится большой двоичный объект. По умолчанию "
"``\"main\"``."

#: ../../library/sqlite3.rst:0
msgid "Raises"
msgstr "Levanta"

#: ../../library/sqlite3.rst:658
msgid "When trying to open a blob in a ``WITHOUT ROWID`` table."
msgstr "При попытке открыть большой двоичный объект в таблице БЕЗ ROWID."

#: ../../library/sqlite3.rst:665
msgid ""
"The blob size cannot be changed using the :class:`Blob` class. Use the SQL "
"function ``zeroblob`` to create a blob with a fixed size."
msgstr ""
"Размер большого двоичного объекта нельзя изменить с помощью класса :class:"
"`Blob`. Используйте функцию SQL «zeroblob», чтобы создать большой двоичный "
"объект фиксированного размера."

#: ../../library/sqlite3.rst:672
msgid ""
"Commit any pending transaction to the database. If :attr:`autocommit` is "
"``True``, or there is no open transaction, this method does nothing. If :"
"attr:`!autocommit` is ``False``, a new transaction is implicitly opened if a "
"pending transaction was committed by this method."
msgstr ""
"Зафиксируйте любую ожидающую транзакцию в базе данных. Если :attr:"
"`autocommit` имеет значение ``True`` или нет открытой транзакции, этот метод "
"ничего не делает. Если :attr:`!autocommit` имеет значение ``False``, новая "
"транзакция неявно открывается, если ожидающая транзакция была зафиксирована "
"этим методом."

#: ../../library/sqlite3.rst:680
msgid ""
"Roll back to the start of any pending transaction. If :attr:`autocommit` is "
"``True``, or there is no open transaction, this method does nothing. If :"
"attr:`!autocommit` is ``False``, a new transaction is implicitly opened if a "
"pending transaction was rolled back by this method."
msgstr ""
"Откат к началу любой ожидающей транзакции. Если :attr:`autocommit` имеет "
"значение ``True`` или нет открытой транзакции, этот метод ничего не делает. "
"Если :attr:`!autocommit` имеет значение ``False``, новая транзакция неявно "
"открывается, если ожидающая транзакция была откатана этим методом."

#: ../../library/sqlite3.rst:688
msgid ""
"Close the database connection. If :attr:`autocommit` is ``False``, any "
"pending transaction is implicitly rolled back. If :attr:`!autocommit` is "
"``True`` or :data:`LEGACY_TRANSACTION_CONTROL`, no implicit transaction "
"control is executed. Make sure to :meth:`commit` before closing to avoid "
"losing pending changes."
msgstr ""
"Закройте соединение с базой данных. Если :attr:`autocommit` имеет значение "
"``False``, любая ожидающая транзакция неявно откатывается. Если :attr:`!"
"autocommit` имеет значение ``True`` или :data:`LEGACY_TRANSACTION_CONTROL`, "
"неявный контроль транзакций не выполняется. Обязательно выполните :meth:"
"`commit` перед закрытием, чтобы не потерять ожидающие изменения."

#: ../../library/sqlite3.rst:698
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.execute` on it "
"with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"Створіть новий об’єкт :class:`Cursor` і викличте :meth:`~Cursor.execute` для "
"нього з заданими *sql* і *параметрами*. Повернути новий об’єкт курсору."

#: ../../library/sqlite3.rst:704
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executemany` on "
"it with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"Створіть новий об’єкт :class:`Cursor` і викличте :meth:`~Cursor.executemany` "
"для нього з заданими *sql* і *параметрами*. Повернути новий об’єкт курсору."

#: ../../library/sqlite3.rst:710
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executescript` "
"on it with the given *sql_script*. Return the new cursor object."
msgstr ""
"Створіть новий об’єкт :class:`Cursor` і викличте :meth:`~Cursor."
"executescript` для нього за допомогою заданого *sql_script*. Повернути новий "
"об’єкт курсору."

#: ../../library/sqlite3.rst:716
msgid "Create or remove a user-defined SQL function."
msgstr "Создайте или удалите пользовательскую функцию SQL."

#: ../../library/sqlite3.rst:718
msgid "The name of the SQL function."
msgstr "O nome da função SQL."

#: ../../library/sqlite3.rst:721
msgid ""
"The number of arguments the SQL function can accept. If ``-1``, it may take "
"any number of arguments."
msgstr ""
"Количество аргументов, которые может принять функция SQL. Если ``-1``, он "
"может принимать любое количество аргументов."

#: ../../library/sqlite3.rst:725
msgid ""
"A :term:`callable` that is called when the SQL function is invoked. The "
"callable must return :ref:`a type natively supported by SQLite <sqlite3-"
"types>`. Set to ``None`` to remove an existing SQL function."
msgstr ""
":term:`callable`, который вызывается при вызове функции SQL. Вызываемый "
"объект должен возвращать :ref:`тип, изначально поддерживаемый SQLite "
"<sqlite3-types>`. Установите значение «Нет», чтобы удалить существующую "
"функцию SQL."

#: ../../library/sqlite3.rst:732
msgid ""
"If ``True``, the created SQL function is marked as `deterministic <https://"
"sqlite.org/deterministic.html>`_, which allows SQLite to perform additional "
"optimizations."
msgstr ""
"Если ``True``, созданная функция SQL помечается как ``детерминированная "
"<https://sqlite.org/deterministic.html>`_, что позволяет SQLite выполнять "
"дополнительную оптимизацию."

#: ../../library/sqlite3.rst:737
msgid "Added the *deterministic* parameter."
msgstr "Добавлен параметр *детерминированный*."

#: ../../library/sqlite3.rst:740 ../../library/sqlite3.rst:784
#: ../../library/sqlite3.rst:852 ../../library/sqlite3.rst:1131
#: ../../library/sqlite3.rst:1553 ../../library/sqlite3.rst:1596
msgid "Example:"
msgstr "Exemplo:"

#: ../../library/sqlite3.rst:742
msgid ""
">>> import hashlib\n"
">>> def md5sum(t):\n"
"...     return hashlib.md5(t).hexdigest()\n"
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.create_function(\"md5\", 1, md5sum)\n"
">>> for row in con.execute(\"SELECT md5(?)\", (b\"foo\",)):\n"
"...     print(row)\n"
"('acbd18db4cc2f85cedef654fccc4a4d8',)\n"
">>> con.close()"
msgstr ""
">>> import hashlib\n"
">>> def md5sum(t):\n"
"...     return hashlib.md5(t).hexdigest()\n"
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.create_function(\"md5\", 1, md5sum)\n"
">>> for row in con.execute(\"SELECT md5(?)\", (b\"foo\",)):\n"
"...     print(row)\n"
"('acbd18db4cc2f85cedef654fccc4a4d8',)\n"
">>> con.close()"

#: ../../library/sqlite3.rst:756
msgid ""
"Passing *name*, *narg*, and *func* as keyword arguments is deprecated. These "
"parameters will become positional-only in Python 3.15."
msgstr ""
"Передача *name*, *narg* и *func* в качестве аргументов ключевых слов не "
"рекомендуется. В Python 3.15 эти параметры станут только позиционными."

#: ../../library/sqlite3.rst:762
msgid "Create or remove a user-defined SQL aggregate function."
msgstr ""
"Создайте или удалите определяемую пользователем агрегатную функцию SQL."

#: ../../library/sqlite3.rst:764
msgid "The name of the SQL aggregate function."
msgstr "Имя агрегатной функции SQL."

#: ../../library/sqlite3.rst:767
msgid ""
"The number of arguments the SQL aggregate function can accept. If ``-1``, it "
"may take any number of arguments."
msgstr ""
"Число аргументов, которые может принять агрегатная функция SQL. Если ``-1``, "
"он может принимать любое количество аргументов."

#: ../../library/sqlite3.rst:771
msgid ""
"A class must implement the following methods:  * ``step()``: Add a row to "
"the aggregate. * ``finalize()``: Return the final result of the aggregate "
"as   :ref:`a type natively supported by SQLite <sqlite3-types>`.  The number "
"of arguments that the ``step()`` method must accept is controlled by "
"*n_arg*.  Set to ``None`` to remove an existing SQL aggregate function."
msgstr ""
"Класс должен реализовывать следующие методы: * ``step()``: добавляет строку "
"в агрегат. * ``finalize()``: Возвращает окончательный результат агрегата "
"как :ref:`тип, изначально поддерживаемый SQLite <sqlite3-types>`. Количество "
"аргументов, которые должен принимать метод ``step()``, контролируется "
"*n_arg*. Установите значение «Нет», чтобы удалить существующую агрегатную "
"функцию SQL."

#: ../../library/sqlite3.rst:772
msgid "A class must implement the following methods:"
msgstr "Uma classe deve implementar os seguintes métodos:"

#: ../../library/sqlite3.rst:774
msgid "``step()``: Add a row to the aggregate."
msgstr "``step()``: добавьте строку в агрегат."

#: ../../library/sqlite3.rst:775 ../../library/sqlite3.rst:836
msgid ""
"``finalize()``: Return the final result of the aggregate as :ref:`a type "
"natively supported by SQLite <sqlite3-types>`."
msgstr ""
"``finalize()``: Возвращает окончательный результат агрегата как :ref:`тип, "
"изначально поддерживаемый SQLite <sqlite3-types>`."

#: ../../library/sqlite3.rst:778
msgid ""
"The number of arguments that the ``step()`` method must accept is controlled "
"by *n_arg*."
msgstr ""
"Количество аргументов, которые должен принимать метод ``step()``, "
"контролируется *n_arg*."

#: ../../library/sqlite3.rst:781
msgid "Set to ``None`` to remove an existing SQL aggregate function."
msgstr ""
"Установите значение «Нет», чтобы удалить существующую агрегатную функцию SQL."

#: ../../library/sqlite3.rst:786
msgid ""
"class MySum:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        self.count += value\n"
"\n"
"    def finalize(self):\n"
"        return self.count\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_aggregate(\"mysum\", 1, MySum)\n"
"cur = con.execute(\"CREATE TABLE test(i)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(1)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(2)\")\n"
"cur.execute(\"SELECT mysum(i) FROM test\")\n"
"print(cur.fetchone()[0])\n"
"\n"
"con.close()"
msgstr ""
"class MySum:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        self.count += value\n"
"\n"
"    def finalize(self):\n"
"        return self.count\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_aggregate(\"mysum\", 1, MySum)\n"
"cur = con.execute(\"CREATE TABLE test(i)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(1)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(2)\")\n"
"cur.execute(\"SELECT mysum(i) FROM test\")\n"
"print(cur.fetchone()[0])\n"
"\n"
"con.close()"

#: ../../library/sqlite3.rst:815
msgid ""
"Passing *name*, *n_arg*, and *aggregate_class* as keyword arguments is "
"deprecated. These parameters will become positional-only in Python 3.15."
msgstr ""
"Передача *name*, *n_arg* и *aggregate_class* в качестве аргументов ключевых "
"слов устарела. В Python 3.15 эти параметры станут только позиционными."

#: ../../library/sqlite3.rst:821
msgid "Create or remove a user-defined aggregate window function."
msgstr "Создайте или удалите пользовательскую агрегатную оконную функцию."

#: ../../library/sqlite3.rst:823
msgid "The name of the SQL aggregate window function to create or remove."
msgstr ""
"Имя агрегатной оконной функции SQL, которую необходимо создать или удалить."

#: ../../library/sqlite3.rst:826
msgid ""
"The number of arguments the SQL aggregate window function can accept. If "
"``-1``, it may take any number of arguments."
msgstr ""
"Число аргументов, которые может принять агрегатная оконная функция SQL. Если "
"``-1``, он может принимать любое количество аргументов."

#: ../../library/sqlite3.rst:830
msgid ""
"A class that must implement the following methods:  * ``step()``: Add a row "
"to the current window. * ``value()``: Return the current value of the "
"aggregate. * ``inverse()``: Remove a row from the current window. * "
"``finalize()``: Return the final result of the aggregate as   :ref:`a type "
"natively supported by SQLite <sqlite3-types>`.  The number of arguments that "
"the ``step()`` and ``value()`` methods must accept is controlled by "
"*num_params*.  Set to ``None`` to remove an existing SQL aggregate window "
"function."
msgstr ""
"Класс, который должен реализовывать следующие методы: * ``step()``: "
"добавляет строку в текущее окно. * ``value()``: Возвращает текущее значение "
"агрегата. * ``inverse()``: удалить строку из текущего окна. * "
"``finalize()``: Возвращает окончательный результат агрегата как :ref:`тип, "
"изначально поддерживаемый SQLite <sqlite3-types>`. Количество аргументов, "
"которые должны принимать методы ``step()`` и ``value()``, контролируется "
"*num_params*. Установите значение «Нет», чтобы удалить существующую "
"агрегатную оконную функцию SQL."

#: ../../library/sqlite3.rst:831
msgid "A class that must implement the following methods:"
msgstr "Uma classe que deve implementar os seguintes métodos:"

#: ../../library/sqlite3.rst:833
msgid "``step()``: Add a row to the current window."
msgstr "``step()``: добавить строку в текущее окно."

#: ../../library/sqlite3.rst:834
msgid "``value()``: Return the current value of the aggregate."
msgstr "``value()``: Возвращает текущее значение агрегата."

#: ../../library/sqlite3.rst:835
msgid "``inverse()``: Remove a row from the current window."
msgstr "``inverse()``: удалить строку из текущего окна."

#: ../../library/sqlite3.rst:839
msgid ""
"The number of arguments that the ``step()`` and ``value()`` methods must "
"accept is controlled by *num_params*."
msgstr ""
"Количество аргументов, которые должны принимать методы ``step()`` и "
"``value()``, контролируется *num_params*."

#: ../../library/sqlite3.rst:842
msgid "Set to ``None`` to remove an existing SQL aggregate window function."
msgstr ""
"Установите значение «Нет», чтобы удалить существующую агрегатную оконную "
"функцию SQL."

#: ../../library/sqlite3.rst:844
msgid ""
"If used with a version of SQLite older than 3.25.0, which does not support "
"aggregate window functions."
msgstr ""
"При использовании с версией SQLite старше 3.25.0, которая не поддерживает "
"агрегатные оконные функции."

#: ../../library/sqlite3.rst:854
msgid ""
"# Example taken from https://www.sqlite.org/windowfunctions.html#udfwinfunc\n"
"class WindowSumInt:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        \"\"\"Add a row to the current window.\"\"\"\n"
"        self.count += value\n"
"\n"
"    def value(self):\n"
"        \"\"\"Return the current value of the aggregate.\"\"\"\n"
"        return self.count\n"
"\n"
"    def inverse(self, value):\n"
"        \"\"\"Remove a row from the current window.\"\"\"\n"
"        self.count -= value\n"
"\n"
"    def finalize(self):\n"
"        \"\"\"Return the final value of the aggregate.\n"
"\n"
"        Any clean-up actions should be placed here.\n"
"        \"\"\"\n"
"        return self.count\n"
"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE test(x, y)\")\n"
"values = [\n"
"    (\"a\", 4),\n"
"    (\"b\", 5),\n"
"    (\"c\", 3),\n"
"    (\"d\", 8),\n"
"    (\"e\", 1),\n"
"]\n"
"cur.executemany(\"INSERT INTO test VALUES(?, ?)\", values)\n"
"con.create_window_function(\"sumint\", 1, WindowSumInt)\n"
"cur.execute(\"\"\"\n"
"    SELECT x, sumint(y) OVER (\n"
"        ORDER BY x ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING\n"
"    ) AS sum_y\n"
"    FROM test ORDER BY x\n"
"\"\"\")\n"
"print(cur.fetchall())\n"
"con.close()"
msgstr ""
"# Example taken from https://www.sqlite.org/windowfunctions.html#udfwinfunc\n"
"class WindowSumInt:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        \"\"\"Add a row to the current window.\"\"\"\n"
"        self.count += value\n"
"\n"
"    def value(self):\n"
"        \"\"\"Return the current value of the aggregate.\"\"\"\n"
"        return self.count\n"
"\n"
"    def inverse(self, value):\n"
"        \"\"\"Remove a row from the current window.\"\"\"\n"
"        self.count -= value\n"
"\n"
"    def finalize(self):\n"
"        \"\"\"Return the final value of the aggregate.\n"
"\n"
"        Any clean-up actions should be placed here.\n"
"        \"\"\"\n"
"        return self.count\n"
"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE test(x, y)\")\n"
"values = [\n"
"    (\"a\", 4),\n"
"    (\"b\", 5),\n"
"    (\"c\", 3),\n"
"    (\"d\", 8),\n"
"    (\"e\", 1),\n"
"]\n"
"cur.executemany(\"INSERT INTO test VALUES(?, ?)\", values)\n"
"con.create_window_function(\"sumint\", 1, WindowSumInt)\n"
"cur.execute(\"\"\"\n"
"    SELECT x, sumint(y) OVER (\n"
"        ORDER BY x ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING\n"
"    ) AS sum_y\n"
"    FROM test ORDER BY x\n"
"\"\"\")\n"
"print(cur.fetchall())\n"
"con.close()"

#: ../../library/sqlite3.rst:908
msgid ""
"Create a collation named *name* using the collating function *callable*. "
"*callable* is passed two :class:`string <str>` arguments, and it should "
"return an :class:`integer <int>`:"
msgstr ""
"Створіть зіставлення під назвою *name* за допомогою функції зіставлення "
"*callable*. *callable* передається два аргументи :class:`string <str>`, і "
"він має повернути :class:`ціле число <int>`:"

#: ../../library/sqlite3.rst:912
msgid "``1`` if the first is ordered higher than the second"
msgstr "``1``, якщо перший впорядкований вище за другий"

#: ../../library/sqlite3.rst:913
msgid "``-1`` if the first is ordered lower than the second"
msgstr "``-1``, якщо перший впорядкований нижче другого"

#: ../../library/sqlite3.rst:914
msgid "``0`` if they are ordered equal"
msgstr "``0``, якщо вони в порядку рівності"

#: ../../library/sqlite3.rst:916
msgid "The following example shows a reverse sorting collation:"
msgstr "У наступному прикладі показано порівняння зворотного сортування:"

#: ../../library/sqlite3.rst:918
msgid ""
"def collate_reverse(string1, string2):\n"
"    if string1 == string2:\n"
"        return 0\n"
"    elif string1 < string2:\n"
"        return 1\n"
"    else:\n"
"        return -1\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_collation(\"reverse\", collate_reverse)\n"
"\n"
"cur = con.execute(\"CREATE TABLE test(x)\")\n"
"cur.executemany(\"INSERT INTO test(x) VALUES(?)\", [(\"a\",), (\"b\",)])\n"
"cur.execute(\"SELECT x FROM test ORDER BY x COLLATE reverse\")\n"
"for row in cur:\n"
"    print(row)\n"
"con.close()"
msgstr ""
"def collate_reverse(string1, string2):\n"
"    if string1 == string2:\n"
"        return 0\n"
"    elif string1 < string2:\n"
"        return 1\n"
"    else:\n"
"        return -1\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_collation(\"reverse\", collate_reverse)\n"
"\n"
"cur = con.execute(\"CREATE TABLE test(x)\")\n"
"cur.executemany(\"INSERT INTO test(x) VALUES(?)\", [(\"a\",), (\"b\",)])\n"
"cur.execute(\"SELECT x FROM test ORDER BY x COLLATE reverse\")\n"
"for row in cur:\n"
"    print(row)\n"
"con.close()"

#: ../../library/sqlite3.rst:944
msgid "Remove a collation function by setting *callable* to ``None``."
msgstr ""
"Удалите функцию сопоставления, установив для *callable* значение «None»."

#: ../../library/sqlite3.rst:946
msgid ""
"The collation name can contain any Unicode character.  Earlier, only ASCII "
"characters were allowed."
msgstr ""
"Имя параметра сортировки может содержать любой символ Юникода. Раньше "
"допускались только символы ASCII."

#: ../../library/sqlite3.rst:953
msgid ""
"Call this method from a different thread to abort any queries that might be "
"executing on the connection. Aborted queries will raise an :exc:"
"`OperationalError`."
msgstr ""
"Вызовите этот метод из другого потока, чтобы прервать любые запросы, которые "
"могут выполняться в соединении. Прерванные запросы вызовут ошибку :exc:"
"`OperationalError`."

#: ../../library/sqlite3.rst:960
msgid ""
"Register :term:`callable` *authorizer_callback* to be invoked for each "
"attempt to access a column of a table in the database. The callback should "
"return one of :const:`SQLITE_OK`, :const:`SQLITE_DENY`, or :const:"
"`SQLITE_IGNORE` to signal how access to the column should be handled by the "
"underlying SQLite library."
msgstr ""
"Зарегистрируйте :term:`callable` *authorizer_callback*, чтобы он вызывался "
"при каждой попытке доступа к столбцу таблицы в базе данных. Обратный вызов "
"должен возвращать один из :const:`SQLITE_OK`, :const:`SQLITE_DENY` или :"
"const:`SQLITE_IGNORE`, чтобы указать, как доступ к столбцу должен "
"обрабатываться базовой библиотекой SQLite."

#: ../../library/sqlite3.rst:967
msgid ""
"The first argument to the callback signifies what kind of operation is to be "
"authorized. The second and third argument will be arguments or ``None`` "
"depending on the first argument. The 4th argument is the name of the "
"database (\"main\", \"temp\", etc.) if applicable. The 5th argument is the "
"name of the inner-most trigger or view that is responsible for the access "
"attempt or ``None`` if this access attempt is directly from input SQL code."
msgstr ""
"Первый аргумент обратного вызова указывает, какая операция должна быть "
"авторизована. Второй и третий аргументы будут аргументами или «Нет» в "
"зависимости от первого аргумента. Четвертый аргумент — это имя базы данных "
"(«main», «temp» и т. д.), если применимо. Пятый аргумент — это имя самого "
"внутреннего триггера или представления, которое отвечает за попытку доступа, "
"или «Нет», если эта попытка доступа происходит непосредственно из входного "
"кода SQL."

#: ../../library/sqlite3.rst:974
msgid ""
"Please consult the SQLite documentation about the possible values for the "
"first argument and the meaning of the second and third argument depending on "
"the first one. All necessary constants are available in the :mod:`!sqlite3` "
"module."
msgstr ""
"Пожалуйста, обратитесь к документации SQLite о возможных значениях первого "
"аргумента и значении второго и третьего аргумента в зависимости от первого. "
"Все необходимые константы доступны в модуле :mod:`!sqlite3`."

#: ../../library/sqlite3.rst:978
msgid "Passing ``None`` as *authorizer_callback* will disable the authorizer."
msgstr "Передача None в качестве *authorizer_callback* отключит авторизатор."

#: ../../library/sqlite3.rst:980
msgid "Added support for disabling the authorizer using ``None``."
msgstr "Добавлена ​​поддержка отключения авторизатора с помощью None."

#: ../../library/sqlite3.rst:983
msgid ""
"Passing *authorizer_callback* as a keyword argument is deprecated. The "
"parameter will become positional-only in Python 3.15."
msgstr ""
"Передача *authorizer_callback* в качестве аргумента ключевого слова "
"устарела. В Python 3.15 параметр станет только позиционным."

#: ../../library/sqlite3.rst:990
msgid ""
"Register :term:`callable` *progress_handler* to be invoked for every *n* "
"instructions of the SQLite virtual machine. This is useful if you want to "
"get called from SQLite during long-running operations, for example to update "
"a GUI."
msgstr ""
"Зарегистрируйте :term:`callable` *progress_handler*, который будет "
"вызываться для каждой *n* инструкции виртуальной машины SQLite. Это полезно, "
"если вы хотите, чтобы вас вызывали из SQLite во время длительных операций, "
"например для обновления графического интерфейса."

#: ../../library/sqlite3.rst:995
msgid ""
"If you want to clear any previously installed progress handler, call the "
"method with ``None`` for *progress_handler*."
msgstr ""
"Если вы хотите очистить любой ранее установленный обработчик прогресса, "
"вызовите метод с ``None`` для *progress_handler*."

#: ../../library/sqlite3.rst:998
msgid ""
"Returning a non-zero value from the handler function will terminate the "
"currently executing query and cause it to raise a :exc:`DatabaseError` "
"exception."
msgstr ""
"Возврат ненулевого значения из функции-обработчика завершит текущий запрос и "
"вызовет исключение :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1002
msgid ""
"Passing *progress_handler* as a keyword argument is deprecated. The "
"parameter will become positional-only in Python 3.15."
msgstr ""
"Передача *progress_handler* в качестве аргумента ключевого слова устарела. В "
"Python 3.15 параметр станет только позиционным."

#: ../../library/sqlite3.rst:1009
msgid ""
"Register :term:`callable` *trace_callback* to be invoked for each SQL "
"statement that is actually executed by the SQLite backend."
msgstr ""
"Зарегистрируйте :term:`callable` *trace_callback*, чтобы он вызывался для "
"каждого оператора SQL, который фактически выполняется серверной частью "
"SQLite."

#: ../../library/sqlite3.rst:1012
msgid ""
"The only argument passed to the callback is the statement (as :class:`str`) "
"that is being executed. The return value of the callback is ignored. Note "
"that the backend does not only run statements passed to the :meth:`Cursor."
"execute` methods.  Other sources include the :ref:`transaction management "
"<sqlite3-controlling-transactions>` of the :mod:`!sqlite3` module and the "
"execution of triggers defined in the current database."
msgstr ""
"Единственный аргумент, передаваемый обратному вызову, — это оператор (как :"
"class:`str`), который выполняется. Возвращаемое значение обратного вызова "
"игнорируется. Обратите внимание, что серверная часть не только выполняет "
"операторы, переданные методам :meth:`Cursor.execute`. Другие источники "
"включают в себя :ref:`управление транзакциями <sqlite3-controlling-"
"transactions>` модуля :mod:`!sqlite3` и выполнение триггеров, определенных в "
"текущей базе данных."

#: ../../library/sqlite3.rst:1020
msgid "Passing ``None`` as *trace_callback* will disable the trace callback."
msgstr ""
"Передача None в качестве *trace_callback* отключит обратный вызов "
"трассировки."

#: ../../library/sqlite3.rst:1023
msgid ""
"Exceptions raised in the trace callback are not propagated. As a development "
"and debugging aid, use :meth:`~sqlite3.enable_callback_tracebacks` to enable "
"printing tracebacks from exceptions raised in the trace callback."
msgstr ""
"Винятки, викликані зворотним викликом трасування, не поширюються. Як "
"допомога при розробці та налагодженні використовуйте :meth:`~sqlite3."
"enable_callback_tracebacks`, щоб увімкнути друк трасування з винятків, "
"викликаних у зворотному виклику трасування."

#: ../../library/sqlite3.rst:1030
msgid ""
"Passing *trace_callback* as a keyword argument is deprecated. The parameter "
"will become positional-only in Python 3.15."
msgstr ""
"Передача *trace_callback* в качестве аргумента ключевого слова устарела. В "
"Python 3.15 параметр станет только позиционным."

#: ../../library/sqlite3.rst:1037
msgid ""
"Enable the SQLite engine to load SQLite extensions from shared libraries if "
"*enabled* is ``True``; else, disallow loading SQLite extensions. SQLite "
"extensions can define new functions, aggregates or whole new virtual table "
"implementations.  One well-known extension is the fulltext-search extension "
"distributed with SQLite."
msgstr ""
"Включите механизм SQLite для загрузки расширений SQLite из общих библиотек, "
"если *enabled* имеет значение ``True``; в противном случае запретите "
"загрузку расширений SQLite. Расширения SQLite могут определять новые "
"функции, агрегаты или совершенно новые реализации виртуальных таблиц. Одним "
"из широко известных расширений является расширение полнотекстового поиска, "
"поставляемое вместе с SQLite."

#: ../../library/sqlite3.rst:1046
msgid ""
"The :mod:`!sqlite3` module is not built with loadable extension support by "
"default, because some platforms (notably macOS) have SQLite libraries which "
"are compiled without this feature. To get loadable extension support, you "
"must pass the :option:`--enable-loadable-sqlite-extensions` option to :"
"program:`configure`."
msgstr ""
"Модуль :mod:`!sqlite3` по умолчанию не имеет поддержки загружаемых "
"расширений, поскольку на некоторых платформах (особенно macOS) есть "
"библиотеки SQLite, которые компилируются без этой функции. Чтобы получить "
"поддержку загружаемых расширений, вы должны передать параметр :option:`--"
"enable-loadable-sqlite-extensions` в :program:`configure`."

#: ../../library/sqlite3.rst:1053
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.enable_load_extension`` "
"with arguments ``connection``, ``enabled``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``sqlite3."
"enable_load_extension`` com os argumentos ``connection``, ``enabled``."

#: ../../library/sqlite3.rst:1057
msgid "Added the ``sqlite3.enable_load_extension`` auditing event."
msgstr "Додано подію аудиту sqlite3.enable_load_extension."

#: ../../library/sqlite3.rst:1063
msgid ""
"con.enable_load_extension(True)\n"
"\n"
"# Load the fulltext search extension\n"
"con.execute(\"select load_extension('./fts3.so')\")\n"
"\n"
"# alternatively you can load the extension using an API call:\n"
"# con.load_extension(\"./fts3.so\")\n"
"\n"
"# disable extension loading again\n"
"con.enable_load_extension(False)\n"
"\n"
"# example from SQLite wiki\n"
"con.execute(\"CREATE VIRTUAL TABLE recipe USING fts3(name, ingredients)\")\n"
"con.executescript(\"\"\"\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli stew', 'broccoli "
"peppers cheese tomatoes');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin stew', 'pumpkin "
"onions garlic celery');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli pie', 'broccoli "
"cheese onions flour');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin pie', 'pumpkin "
"sugar flour butter');\n"
"    \"\"\")\n"
"for row in con.execute(\"SELECT rowid, name, ingredients FROM recipe WHERE "
"name MATCH 'pie'\"):\n"
"    print(row)"
msgstr ""
"con.enable_load_extension(True)\n"
"\n"
"# Load the fulltext search extension\n"
"con.execute(\"select load_extension('./fts3.so')\")\n"
"\n"
"# alternatively you can load the extension using an API call:\n"
"# con.load_extension(\"./fts3.so\")\n"
"\n"
"# disable extension loading again\n"
"con.enable_load_extension(False)\n"
"\n"
"# example from SQLite wiki\n"
"con.execute(\"CREATE VIRTUAL TABLE recipe USING fts3(name, ingredients)\")\n"
"con.executescript(\"\"\"\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli stew', 'broccoli "
"peppers cheese tomatoes');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin stew', 'pumpkin "
"onions garlic celery');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli pie', 'broccoli "
"cheese onions flour');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin pie', 'pumpkin "
"sugar flour butter');\n"
"    \"\"\")\n"
"for row in con.execute(\"SELECT rowid, name, ingredients FROM recipe WHERE "
"name MATCH 'pie'\"):\n"
"    print(row)"

#: ../../library/sqlite3.rst:1089
msgid ""
"Load an SQLite extension from a shared library. Enable extension loading "
"with :meth:`enable_load_extension` before calling this method."
msgstr ""
"Загрузите расширение SQLite из общей библиотеки. Включите загрузку "
"расширения с помощью :meth:`enable_load_extension` перед вызовом этого "
"метода."

#: ../../library/sqlite3.rst:1093
msgid "The path to the SQLite extension."
msgstr "Путь к расширению SQLite."

#: ../../library/sqlite3.rst:1097
msgid ""
"Entry point name. If ``None`` (the default), SQLite will come up with an "
"entry point name of its own; see the SQLite docs `Loading an Extension`_ for "
"details."
msgstr ""
"Название точки входа. Если «Нет» (по умолчанию), SQLite предложит "
"собственное имя точки входа; подробности см. в документации по SQLite "
"«Загрузка расширения»."

#: ../../library/sqlite3.rst:1106
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.load_extension`` with "
"arguments ``connection``, ``path``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``sqlite3.load_extension`` "
"com os argumentos ``connection``, ``path``."

#: ../../library/sqlite3.rst:1110
msgid "Added the ``sqlite3.load_extension`` auditing event."
msgstr "Додано подію аудиту ``sqlite3.load_extension``."

#: ../../library/sqlite3.rst:1113
msgid "Added the *entrypoint* parameter."
msgstr "Добавлен параметр *entrypoint*."

#: ../../library/sqlite3.rst:1120
msgid ""
"Return an :term:`iterator` to dump the database as SQL source code. Useful "
"when saving an in-memory database for later restoration. Similar to the ``."
"dump`` command in the :program:`sqlite3` shell."
msgstr ""
"Верните :term:`iterator`, чтобы выгрузить базу данных в виде исходного кода "
"SQL. Полезно при сохранении базы данных в памяти для последующего "
"восстановления. Аналогично команде ``.dump`` в оболочке :program:`sqlite3`."

#: ../../library/sqlite3.rst:1124
msgid ""
"An optional ``LIKE`` pattern for database objects to dump, e.g. "
"``prefix_%``. If ``None`` (the default), all database objects will be "
"included."
msgstr ""
"Необязательный шаблон ``LIKE`` для объектов базы данных, которые нужно "
"выгрузить, например ``prefix_%``. Если «Нет» (по умолчанию), все объекты "
"базы данных будут включены."

#: ../../library/sqlite3.rst:1133
msgid ""
"# Convert file example.db to SQL dump file dump.sql\n"
"con = sqlite3.connect('example.db')\n"
"with open('dump.sql', 'w') as f:\n"
"    for line in con.iterdump():\n"
"        f.write('%s\\n' % line)\n"
"con.close()"
msgstr ""
"# Convert file example.db to SQL dump file dump.sql\n"
"con = sqlite3.connect('example.db')\n"
"with open('dump.sql', 'w') as f:\n"
"    for line in con.iterdump():\n"
"        f.write('%s\\n' % line)\n"
"con.close()"

#: ../../library/sqlite3.rst:1144 ../../library/sqlite3.rst:1218
msgid ":ref:`sqlite3-howto-encoding`"
msgstr ":ref:`sqlite3-howto-encoding`"

#: ../../library/sqlite3.rst:1146
msgid "Added the *filter* parameter."
msgstr "Adicionado o parâmetro *filter*."

#: ../../library/sqlite3.rst:1151
msgid "Create a backup of an SQLite database."
msgstr "Создайте резервную копию базы данных SQLite."

#: ../../library/sqlite3.rst:1153
msgid ""
"Works even if the database is being accessed by other clients or "
"concurrently by the same connection."
msgstr ""
"Работает, даже если к базе данных обращаются другие клиенты или одновременно "
"по тому же соединению."

#: ../../library/sqlite3.rst:1156
msgid "The database connection to save the backup to."
msgstr "Соединение с базой данных, в котором сохраняется резервная копия."

#: ../../library/sqlite3.rst:1159
msgid ""
"The number of pages to copy at a time. If equal to or less than ``0``, the "
"entire database is copied in a single step. Defaults to ``-1``."
msgstr ""
"Количество страниц, копируемых за один раз. Если оно равно или меньше «0», "
"вся база данных копируется за один шаг. По умолчанию ``-1``."

#: ../../library/sqlite3.rst:1165
msgid ""
"If set to a :term:`callable`, it is invoked with three integer arguments for "
"every backup iteration: the *status* of the last iteration, the *remaining* "
"number of pages still to be copied, and the *total* number of pages. "
"Defaults to ``None``."
msgstr ""
"Если установлено значение :term:`callable`, он вызывается с тремя "
"целочисленными аргументами для каждой итерации резервного копирования: "
"*статус* последней итерации, *оставшееся* количество страниц, которые еще "
"предстоит скопировать, и *общее* количество страниц. По умолчанию "
"установлено значение «Нет»."

#: ../../library/sqlite3.rst:1174
msgid ""
"The name of the database to back up. Either ``\"main\"`` (the default) for "
"the main database, ``\"temp\"`` for the temporary database, or the name of a "
"custom database as attached using the ``ATTACH DATABASE`` SQL statement."
msgstr ""
"Имя базы данных для резервного копирования. Либо ``\"main\"`` (по умолчанию) "
"для основной базы данных, ``\"temp\"`` для временной базы данных, либо имя "
"пользовательской базы данных, прикрепленное с помощью оператора SQL ``ATTACH "
"DATABASE``."

#: ../../library/sqlite3.rst:1181
msgid ""
"The number of seconds to sleep between successive attempts to back up "
"remaining pages."
msgstr ""
"Количество секунд ожидания между последовательными попытками резервного "
"копирования оставшихся страниц."

#: ../../library/sqlite3.rst:1185
msgid "Example 1, copy an existing database into another:"
msgstr "Пример 1: копирование существующей базы данных в другую:"

#: ../../library/sqlite3.rst:1187
msgid ""
"def progress(status, remaining, total):\n"
"    print(f'Copied {total-remaining} of {total} pages...')\n"
"\n"
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect('backup.db')\n"
"with dst:\n"
"    src.backup(dst, pages=1, progress=progress)\n"
"dst.close()\n"
"src.close()"
msgstr ""
"def progress(status, remaining, total):\n"
"    print(f'Copied {total-remaining} of {total} pages...')\n"
"\n"
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect('backup.db')\n"
"with dst:\n"
"    src.backup(dst, pages=1, progress=progress)\n"
"dst.close()\n"
"src.close()"

#: ../../library/sqlite3.rst:1204
msgid "Example 2, copy an existing database into a transient copy:"
msgstr "Пример 2: скопируйте существующую базу данных во временную копию:"

#: ../../library/sqlite3.rst:1206
msgid ""
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect(':memory:')\n"
"src.backup(dst)\n"
"dst.close()\n"
"src.close()"
msgstr ""
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect(':memory:')\n"
"src.backup(dst)\n"
"dst.close()\n"
"src.close()"

#: ../../library/sqlite3.rst:1222
msgid "Get a connection runtime limit."
msgstr "Получите ограничение времени выполнения соединения."

#: ../../library/sqlite3.rst:1224
msgid "The `SQLite limit category`_ to be queried."
msgstr "`Категория ограничения SQLite`_ для запроса."

#: ../../library/sqlite3.rst:1229 ../../library/sqlite3.rst:1266
msgid "If *category* is not recognised by the underlying SQLite library."
msgstr "Если *категория* не распознается базовой библиотекой SQLite."

#: ../../library/sqlite3.rst:1232
msgid ""
"Example, query the maximum length of an SQL statement for :class:"
"`Connection` ``con`` (the default is 1000000000):"
msgstr ""
"Например, запросите максимальную длину оператора SQL для :class:`Connection` "
"``con`` (по умолчанию — 1000000000):"

#: ../../library/sqlite3.rst:1242
msgid ""
">>> con.getlimit(sqlite3.SQLITE_LIMIT_SQL_LENGTH)\n"
"1000000000"
msgstr ""
">>> con.getlimit(sqlite3.SQLITE_LIMIT_SQL_LENGTH)\n"
"1000000000"

#: ../../library/sqlite3.rst:1252
msgid ""
"Set a connection runtime limit. Attempts to increase a limit above its hard "
"upper bound are silently truncated to the hard upper bound. Regardless of "
"whether or not the limit was changed, the prior value of the limit is "
"returned."
msgstr ""
"Установите ограничение времени выполнения соединения. Попытки увеличить "
"предел выше его жесткой верхней границы молча обрезаются до жесткой верхней "
"границы. Независимо от того, был ли изменен лимит, возвращается предыдущее "
"значение лимита."

#: ../../library/sqlite3.rst:1257
msgid "The `SQLite limit category`_ to be set."
msgstr "`_ Категория ограничения SQLite`_, которую необходимо установить."

#: ../../library/sqlite3.rst:1260
msgid ""
"The value of the new limit. If negative, the current limit is unchanged."
msgstr ""
"Значение нового лимита. Если отрицательно, то предел тока не изменяется."

#: ../../library/sqlite3.rst:1269
msgid ""
"Example, limit the number of attached databases to 1 for :class:`Connection` "
"``con`` (the default limit is 10):"
msgstr ""
"Например, ограничьте количество подключенных баз данных до 1 для :class:"
"`Connection` ``con`` (ограничение по умолчанию — 10):"

#: ../../library/sqlite3.rst:1272
msgid ""
">>> con.setlimit(sqlite3.SQLITE_LIMIT_ATTACHED, 1)\n"
"10\n"
">>> con.getlimit(sqlite3.SQLITE_LIMIT_ATTACHED)\n"
"1"
msgstr ""
">>> con.setlimit(sqlite3.SQLITE_LIMIT_ATTACHED, 1)\n"
"10\n"
">>> con.getlimit(sqlite3.SQLITE_LIMIT_ATTACHED)\n"
"1"

#: ../../library/sqlite3.rst:1290
msgid "Query a boolean connection configuration option."
msgstr "Запросить логический параметр конфигурации соединения."

#: ../../library/sqlite3.rst:1292 ../../library/sqlite3.rst:1303
msgid "A :ref:`SQLITE_DBCONFIG code <sqlite3-dbconfig-constants>`."
msgstr "Код SQLITE_DBCONFIG <sqlite3-dbconfig-constants>."

#: ../../library/sqlite3.rst:1301
msgid "Set a boolean connection configuration option."
msgstr "Установите логический параметр конфигурации соединения."

#: ../../library/sqlite3.rst:1306
msgid ""
"``True`` if the configuration option should be enabled (default); ``False`` "
"if it should be disabled."
msgstr ""
"``True``, если опция конфигурации должна быть включена (по умолчанию); "
"``False``, если его следует отключить."

#: ../../library/sqlite3.rst:1314
msgid ""
"Serialize a database into a :class:`bytes` object.  For an ordinary on-disk "
"database file, the serialization is just a copy of the disk file.  For an in-"
"memory database or a \"temp\" database, the serialization is the same "
"sequence of bytes which would be written to disk if that database were "
"backed up to disk."
msgstr ""
"Сериализуйте базу данных в объект :class:`bytes`. Для обычного файла базы "
"данных на диске сериализация представляет собой просто копию дискового "
"файла. Для базы данных в памяти или «временной» базы данных сериализация "
"представляет собой ту же последовательность байтов, которая была бы записана "
"на диск, если бы эта база данных была скопирована на диск."

#: ../../library/sqlite3.rst:1320
msgid "The database name to be serialized. Defaults to ``\"main\"``."
msgstr "Имя базы данных для сериализации. По умолчанию ``\"main\"``."

#: ../../library/sqlite3.rst:1328
msgid ""
"This method is only available if the underlying SQLite library has the "
"serialize API."
msgstr ""
"Этот метод доступен только в том случае, если базовая библиотека SQLite "
"имеет API сериализации."

#: ../../library/sqlite3.rst:1336
msgid ""
"Deserialize a :meth:`serialized <serialize>` database into a :class:"
"`Connection`. This method causes the database connection to disconnect from "
"database *name*, and reopen *name* as an in-memory database based on the "
"serialization contained in *data*."
msgstr ""
"Десериализовать :meth:`сериализованную <serialize>` базу данных в :class:"
"`Connection`. Этот метод приводит к отключению соединения с базой данных "
"*name* и повторному открытию *name* как базы данных в памяти на основе "
"сериализации, содержащейся в *data*."

#: ../../library/sqlite3.rst:1342
msgid "A serialized database."
msgstr "Сериализованная база данных."

#: ../../library/sqlite3.rst:1345
msgid "The database name to deserialize into. Defaults to ``\"main\"``."
msgstr "Имя базы данных для десериализации. По умолчанию ``\"main\"``."

#: ../../library/sqlite3.rst:1349
msgid ""
"If the database connection is currently involved in a read transaction or a "
"backup operation."
msgstr ""
"Если соединение с базой данных в данный момент участвует в транзакции чтения "
"или операции резервного копирования."

#: ../../library/sqlite3.rst:1353
msgid "If *data* does not contain a valid SQLite database."
msgstr "Если *data* не содержит действующую базу данных SQLite."

#: ../../library/sqlite3.rst:1356
msgid "If :func:`len(data) <len>` is larger than ``2**63 - 1``."
msgstr "Если :func:`len(data) <len>` больше, чем ``2**63 - 1``."

#: ../../library/sqlite3.rst:1361
msgid ""
"This method is only available if the underlying SQLite library has the "
"deserialize API."
msgstr ""
"Этот метод доступен только в том случае, если базовая библиотека SQLite "
"имеет API десериализации."

#: ../../library/sqlite3.rst:1368
msgid ""
"This attribute controls :pep:`249`-compliant transaction behaviour. :attr:`!"
"autocommit` has three allowed values:"
msgstr ""
"Этот атрибут управляет поведением транзакций, совместимым с :pep:`249`. :"
"attr:`!autocommit` имеет три допустимых значения:"

#: ../../library/sqlite3.rst:1371
msgid ""
"``False``: Select :pep:`249`-compliant transaction behaviour, implying that :"
"mod:`!sqlite3` ensures a transaction is always open. Use :meth:`commit` and :"
"meth:`rollback` to close transactions."
msgstr ""
"``False``: выберите поведение транзакции, совместимое с :pep:`249`, "
"подразумевая, что :mod:`!sqlite3` гарантирует, что транзакция всегда "
"открыта. Используйте :meth:`commit` и :meth:`rollback` для закрытия "
"транзакций."

#: ../../library/sqlite3.rst:1375
msgid "This is the recommended value of :attr:`!autocommit`."
msgstr "Это рекомендуемое значение :attr:`!autocommit`."

#: ../../library/sqlite3.rst:1377
msgid ""
"``True``: Use SQLite's `autocommit mode`_. :meth:`commit` and :meth:"
"`rollback` have no effect in this mode."
msgstr ""
"``True``: используйте ``режим автоматической фиксации`_ SQLite. :meth:"
"`commit` и :meth:`rollback` не действуют в этом режиме."

#: ../../library/sqlite3.rst:1380
msgid ""
":data:`LEGACY_TRANSACTION_CONTROL`: Pre-Python 3.12 (non-:pep:`249`-"
"compliant) transaction control. See :attr:`isolation_level` for more details."
msgstr ""
":data:`LEGACY_TRANSACTION_CONTROL`: Управление транзакциями до версии Python "
"3.12 (не :pep:`249`-совместимой). Дополнительную информацию см. в :attr:"
"`isolation_level`."

#: ../../library/sqlite3.rst:1384
msgid "This is currently the default value of :attr:`!autocommit`."
msgstr "В настоящее время это значение по умолчанию для :attr:`!autocommit`."

#: ../../library/sqlite3.rst:1386
msgid ""
"Changing :attr:`!autocommit` to ``False`` will open a new transaction, and "
"changing it to ``True`` will commit any pending transaction."
msgstr ""
"Изменение :attr:`!autocommit` на ``False`` откроет новую транзакцию, а "
"изменение его на ``True`` зафиксирует любую ожидающую транзакцию."

#: ../../library/sqlite3.rst:1389
msgid "See :ref:`sqlite3-transaction-control-autocommit` for more details."
msgstr ""
"Дополнительную информацию см. в :ref:`sqlite3-transaction-control-"
"autocommit`."

#: ../../library/sqlite3.rst:1393
msgid ""
"The :attr:`isolation_level` attribute has no effect unless :attr:"
"`autocommit` is :data:`LEGACY_TRANSACTION_CONTROL`."
msgstr ""
"Атрибут :attr:`isolation_level` не имеет никакого эффекта, если :attr:"
"`autocommit` не имеет значения :data:`LEGACY_TRANSACTION_CONTROL`."

#: ../../library/sqlite3.rst:1400
msgid ""
"This read-only attribute corresponds to the low-level SQLite `autocommit "
"mode`_."
msgstr ""
"Этот атрибут только для чтения соответствует низкоуровневому `режиму "
"автоматической фиксации`_ SQLite."

#: ../../library/sqlite3.rst:1403
msgid ""
"``True`` if a transaction is active (there are uncommitted changes), "
"``False`` otherwise."
msgstr ""
"``True``, если транзакция активна (есть незафиксированные изменения), "
"``False`` в противном случае."

#: ../../library/sqlite3.rst:1410
msgid ""
"Controls the :ref:`legacy transaction handling mode <sqlite3-transaction-"
"control-isolation-level>` of :mod:`!sqlite3`. If set to ``None``, "
"transactions are never implicitly opened. If set to one of ``\"DEFERRED\"``, "
"``\"IMMEDIATE\"``, or ``\"EXCLUSIVE\"``, corresponding to the underlying "
"`SQLite transaction behaviour`_, :ref:`implicit transaction management "
"<sqlite3-transaction-control-isolation-level>` is performed."
msgstr ""
"Управляет :ref:`устаревшим режимом обработки транзакций <sqlite3-transaction-"
"control-isolation-level>` :mod:`!sqlite3`. Если установлено значение None, "
"транзакции никогда не открываются неявно. Если установлено одно из "
"«ОТЛОЖЕННЫХ», «НЕМЕДЛЕННЫХ» или «ЭКСКЛЮЗИВНЫХ», соответствующих базовому "
"«поведению транзакций SQLite», :ref:`неявное управление транзакциями "
"<sqlite3 -transaction-control-isolation-level>` выполняется."

#: ../../library/sqlite3.rst:1418
msgid ""
"If not overridden by the *isolation_level* parameter of :func:`connect`, the "
"default is ``\"\"``, which is an alias for ``\"DEFERRED\"``."
msgstr ""
"Если это не переопределено параметром *isolation_level* функции :func:"
"`connect`, по умолчанию используется ``\"\"``, который является псевдонимом "
"для ``\"DEFERRED\"``."

#: ../../library/sqlite3.rst:1423
msgid ""
"Using :attr:`autocommit` to control transaction handling is recommended over "
"using :attr:`!isolation_level`. :attr:`!isolation_level` has no effect "
"unless :attr:`autocommit` is set to :data:`LEGACY_TRANSACTION_CONTROL` (the "
"default)."
msgstr ""
"Использование :attr:`autocommit` для управления обработкой транзакций "
"рекомендуется вместо использования :attr:`!isolation_level`. :attr:`!"
"isolation_level` не имеет никакого эффекта, если для :attr:`autocommit` не "
"установлено значение :data:`LEGACY_TRANSACTION_CONTROL` (по умолчанию)."

#: ../../library/sqlite3.rst:1430
msgid ""
"The initial :attr:`~Cursor.row_factory` for :class:`Cursor` objects created "
"from this connection. Assigning to this attribute does not affect the :attr:"
"`!row_factory` of existing cursors belonging to this connection, only new "
"ones. Is ``None`` by default, meaning each row is returned as a :class:"
"`tuple`."
msgstr ""
"Начальный :attr:`~Cursor.row_factory` для объектов :class:`Cursor`, "
"созданных из этого соединения. Присвоение этому атрибуту не влияет на :attr:"
"`!row_factory` существующих курсоров, принадлежащих этому соединению, а "
"только на новые. По умолчанию имеет значение None, что означает, что каждая "
"строка возвращается как :class:`tuple`."

#: ../../library/sqlite3.rst:1437 ../../library/sqlite3.rst:1723
#: ../../library/sqlite3.rst:1746
msgid "See :ref:`sqlite3-howto-row-factory` for more details."
msgstr "Consulte :ref:`sqlite3-howto-row-factory` para mais detalhes."

#: ../../library/sqlite3.rst:1441
msgid ""
"A :term:`callable` that accepts a :class:`bytes` parameter and returns a "
"text representation of it. The callable is invoked for SQLite values with "
"the ``TEXT`` data type. By default, this attribute is set to :class:`str`."
msgstr ""
":term:`callable`, который принимает параметр :class:`bytes` и возвращает его "
"текстовое представление. Вызываемый объект вызывается для значений SQLite с "
"типом данных TEXT. По умолчанию для этого атрибута установлено значение :"
"class:`str`."

#: ../../library/sqlite3.rst:1446
msgid "See :ref:`sqlite3-howto-encoding` for more details."
msgstr "Consulte :ref:`sqlite3-howto-encoding` para mais detalhes."

#: ../../library/sqlite3.rst:1450
msgid ""
"Return the total number of database rows that have been modified, inserted, "
"or deleted since the database connection was opened."
msgstr ""
"Возвращает общее количество строк базы данных, которые были изменены, "
"вставлены или удалены с момента открытия соединения с базой данных."

#: ../../library/sqlite3.rst:1457
msgid "Cursor objects"
msgstr "Курсорные объекты"

#: ../../library/sqlite3.rst:1459
msgid ""
"A ``Cursor`` object represents a `database cursor`_ which is used to execute "
"SQL statements, and manage the context of a fetch operation. Cursors are "
"created using :meth:`Connection.cursor`, or by using any of the :ref:"
"`connection shortcut methods <sqlite3-connection-shortcuts>`."
msgstr ""
"Объект «Курсор» представляет собой «курсор базы данных», который "
"используется для выполнения операторов SQL и управления контекстом операции "
"выборки. Курсоры создаются с помощью :meth:`Connection.cursor` или с помощью "
"любого из :ref:`методов ярлыков соединений <sqlite3-connection-shortcuts>`."

#: ../../library/sqlite3.rst:1466
msgid ""
"Cursor objects are :term:`iterators <iterator>`, meaning that if you :meth:"
"`~Cursor.execute` a ``SELECT`` query, you can simply iterate over the cursor "
"to fetch the resulting rows:"
msgstr ""
"Объекты курсора — это :term:`итераторы <iterator>`, что означает, что если "
"вы :meth:`~Cursor.execute` запрос ``SELECT``, вы можете просто перебирать "
"курсор для получения результирующих строк:"

#: ../../library/sqlite3.rst:1477
msgid ""
"for row in cur.execute(\"SELECT t FROM data\"):\n"
"    print(row)"
msgstr ""
"for row in cur.execute(\"SELECT t FROM data\"):\n"
"    print(row)"

#: ../../library/sqlite3.rst:1491
msgid "A :class:`Cursor` instance has the following attributes and methods."
msgstr "Екземпляр :class:`Cursor` має такі атрибути та методи."

#: ../../library/sqlite3.rst:1498
msgid ""
"Execute a single SQL statement, optionally binding Python values using :ref:"
"`placeholders <sqlite3-placeholders>`."
msgstr ""
"Выполните один оператор SQL, при необходимости привязав значения Python с "
"помощью :ref:`placeholders <sqlite3-placeholders>`."

#: ../../library/sqlite3.rst:1502
msgid "A single SQL statement."
msgstr "Один оператор SQL."

#: ../../library/sqlite3.rst:1505
msgid ""
"Python values to bind to placeholders in *sql*. A :class:`!dict` if named "
"placeholders are used. A :term:`!sequence` if unnamed placeholders are used. "
"See :ref:`sqlite3-placeholders`."
msgstr ""
"Значения Python для привязки к заполнителям в *sql*. A :class:`!dict`, если "
"используются именованные заполнители. A :term:`!sequence`, если используются "
"безымянные заполнители. См. :ref:`sqlite3-placeholders`."

#: ../../library/sqlite3.rst:1512
msgid "If *sql* contains more than one SQL statement."
msgstr ""

#: ../../library/sqlite3.rst:1515
msgid ""
"If :attr:`~Connection.autocommit` is :data:`LEGACY_TRANSACTION_CONTROL`, :"
"attr:`~Connection.isolation_level` is not ``None``, *sql* is an ``INSERT``, "
"``UPDATE``, ``DELETE``, or ``REPLACE`` statement, and there is no open "
"transaction, a transaction is implicitly opened before executing *sql*."
msgstr ""
"Если :attr:`~Connection.autocommit` равен :data:"
"`LEGACY_TRANSACTION_CONTROL`, :attr:`~Connection.isolation_level` не равен "
"``None``, *sql* — это ``INSERT``, ``UPDATE` `, ``DELETE`` или ``REPLACE`` и "
"нет открытой транзакции, транзакция неявно открывается перед выполнением "
"*sql*."

#: ../../library/sqlite3.rst:1524
msgid ""
":exc:`DeprecationWarning` is emitted if :ref:`named placeholders <sqlite3-"
"placeholders>` are used and *parameters* is a sequence instead of a :class:"
"`dict`. Starting with Python 3.14, :exc:`ProgrammingError` will be raised "
"instead."
msgstr ""

#: ../../library/sqlite3.rst:1530
msgid "Use :meth:`executescript` to execute multiple SQL statements."
msgstr ""
"Используйте :meth:`executescript` для выполнения нескольких операторов SQL."

#: ../../library/sqlite3.rst:1534
msgid ""
"For every item in *parameters*, repeatedly execute the :ref:`parameterized "
"<sqlite3-placeholders>` :abbr:`DML (Data Manipulation Language)` SQL "
"statement *sql*."
msgstr ""
"Для каждого элемента в *parameters* повторно выполните :ref:"
"`параметризованный <sqlite3-placeholders>` :abbr:`DML (язык манипулирования "
"данными)` оператор SQL *sql*."

#: ../../library/sqlite3.rst:1538
msgid "Uses the same implicit transaction handling as :meth:`~Cursor.execute`."
msgstr ""
"Использует ту же неявную обработку транзакций, что и :meth:`~Cursor.execute`."

#: ../../library/sqlite3.rst:1540
msgid "A single SQL DML statement."
msgstr "Один оператор SQL DML."

#: ../../library/sqlite3.rst:1543
msgid ""
"An :term:`!iterable` of parameters to bind with the placeholders in *sql*. "
"See :ref:`sqlite3-placeholders`."
msgstr ""
":term:`!iterable` параметров для привязки к заполнителям в *sql*. См. :ref:"
"`sqlite3-placeholders`."

#: ../../library/sqlite3.rst:1549
msgid ""
"If *sql* contains more than one SQL statement, or is not a DML statement."
msgstr ""

#: ../../library/sqlite3.rst:1555
msgid ""
"rows = [\n"
"    (\"row1\",),\n"
"    (\"row2\",),\n"
"]\n"
"# cur is an sqlite3.Cursor object\n"
"cur.executemany(\"INSERT INTO data VALUES(?)\", rows)"
msgstr ""
"rows = [\n"
"    (\"row1\",),\n"
"    (\"row2\",),\n"
"]\n"
"# cur is an sqlite3.Cursor object\n"
"cur.executemany(\"INSERT INTO data VALUES(?)\", rows)"

#: ../../library/sqlite3.rst:1570
msgid ""
"Any resulting rows are discarded, including DML statements with `RETURNING "
"clauses`_."
msgstr ""
"Любые результирующие строки отбрасываются, включая операторы DML с "
"предложениями RETURNING_."

#: ../../library/sqlite3.rst:1577
msgid ""
":exc:`DeprecationWarning` is emitted if :ref:`named placeholders <sqlite3-"
"placeholders>` are used and the items in *parameters* are sequences instead "
"of :class:`dict`\\s. Starting with Python 3.14, :exc:`ProgrammingError` will "
"be raised instead."
msgstr ""

#: ../../library/sqlite3.rst:1586
msgid ""
"Execute the SQL statements in *sql_script*. If the :attr:`~Connection."
"autocommit` is :data:`LEGACY_TRANSACTION_CONTROL` and there is a pending "
"transaction, an implicit ``COMMIT`` statement is executed first. No other "
"implicit transaction control is performed; any transaction control must be "
"added to *sql_script*."
msgstr ""
"Выполните инструкции SQL в *sql_script*. Если :attr:`~Connection.autocommit` "
"имеет значение :data:`LEGACY_TRANSACTION_CONTROL` и имеется ожидающая "
"транзакция, сначала выполняется неявный оператор ``COMMIT``. Никакого "
"другого неявного контроля транзакций не выполняется; любой контроль "
"транзакций должен быть добавлен в *sql_script*."

#: ../../library/sqlite3.rst:1594
msgid "*sql_script* must be a :class:`string <str>`."
msgstr "*sql_script* должен быть :class:`string <str>`."

#: ../../library/sqlite3.rst:1598
msgid ""
"# cur is an sqlite3.Cursor object\n"
"cur.executescript(\"\"\"\n"
"    BEGIN;\n"
"    CREATE TABLE person(firstname, lastname, age);\n"
"    CREATE TABLE book(title, author, published);\n"
"    CREATE TABLE publisher(name, address);\n"
"    COMMIT;\n"
"\"\"\")"
msgstr ""
"# cur is an sqlite3.Cursor object\n"
"cur.executescript(\"\"\"\n"
"    BEGIN;\n"
"    CREATE TABLE person(firstname, lastname, age);\n"
"    CREATE TABLE book(title, author, published);\n"
"    CREATE TABLE publisher(name, address);\n"
"    COMMIT;\n"
"\"\"\")"

#: ../../library/sqlite3.rst:1611
msgid ""
"If :attr:`~Cursor.row_factory` is ``None``, return the next row query result "
"set as a :class:`tuple`. Else, pass it to the row factory and return its "
"result. Return ``None`` if no more data is available."
msgstr ""
"Если :attr:`~Cursor.row_factory` имеет значение ``None``, вернуть следующий "
"набор результатов запроса строки как :class:`tuple`. В противном случае "
"передайте его фабрике строк и верните результат. Верните None, если данных "
"больше нет."

#: ../../library/sqlite3.rst:1619
msgid ""
"Return the next set of rows of a query result as a :class:`list`. Return an "
"empty list if no more rows are available."
msgstr ""
"Возвращает следующий набор строк результата запроса в виде :class:`list`. "
"Верните пустой список, если больше нет доступных строк."

#: ../../library/sqlite3.rst:1622
msgid ""
"The number of rows to fetch per call is specified by the *size* parameter. "
"If *size* is not given, :attr:`arraysize` determines the number of rows to "
"be fetched. If fewer than *size* rows are available, as many rows as are "
"available are returned."
msgstr ""
"Количество строк, извлекаемых за один вызов, определяется параметром *size*. "
"Если *size* не задано, :attr:`arraysize` определяет количество извлекаемых "
"строк. Если доступно меньше строк *size*, возвращается столько строк, "
"сколько доступно."

#: ../../library/sqlite3.rst:1628
msgid ""
"Note there are performance considerations involved with the *size* "
"parameter. For optimal performance, it is usually best to use the arraysize "
"attribute. If the *size* parameter is used, then it is best for it to retain "
"the same value from one :meth:`fetchmany` call to the next."
msgstr ""
"Зауважте, що з параметром *size* пов’язані міркування щодо продуктивності. "
"Для оптимальної продуктивності зазвичай найкраще використовувати атрибут "
"arraysize. Якщо використовується параметр *size*, то найкраще, щоб він "
"зберігав те саме значення від одного виклику :meth:`fetchmany` до наступного."

#: ../../library/sqlite3.rst:1635
msgid ""
"Return all (remaining) rows of a query result as a :class:`list`. Return an "
"empty list if no rows are available. Note that the :attr:`arraysize` "
"attribute can affect the performance of this operation."
msgstr ""
"Возвращает все (оставшиеся) строки результата запроса в виде :class:`list`. "
"Верните пустой список, если нет доступных строк. Обратите внимание, что "
"атрибут :attr:`arraysize` может повлиять на производительность этой операции."

#: ../../library/sqlite3.rst:1642
msgid "Close the cursor now (rather than whenever ``__del__`` is called)."
msgstr "Закрийте курсор зараз (а не під час кожного виклику ``__del__``)."

#: ../../library/sqlite3.rst:1644
msgid ""
"The cursor will be unusable from this point forward; a :exc:"
"`ProgrammingError` exception will be raised if any operation is attempted "
"with the cursor."
msgstr ""
"Курсор стане непридатним для використання з цього моменту; виняток :exc:"
"`ProgrammingError` буде викликано, якщо будь-яка операція буде виконана з "
"курсором."

#: ../../library/sqlite3.rst:1649 ../../library/sqlite3.rst:1653
msgid "Required by the DB-API. Does nothing in :mod:`!sqlite3`."
msgstr "Требуется для DB-API. Ничего не делает в :mod:`!sqlite3`."

#: ../../library/sqlite3.rst:1657
msgid ""
"Read/write attribute that controls the number of rows returned by :meth:"
"`fetchmany`. The default value is 1 which means a single row would be "
"fetched per call."
msgstr ""
"Атрибут читання/запису, який контролює кількість рядків, які повертає :meth:"
"`fetchmany`. Значення за замовчуванням дорівнює 1, що означає, що за виклик "
"буде отримано один рядок."

#: ../../library/sqlite3.rst:1662
msgid ""
"Read-only attribute that provides the SQLite database :class:`Connection` "
"belonging to the cursor.  A :class:`Cursor` object created by calling :meth:"
"`con.cursor() <Connection.cursor>` will have a :attr:`connection` attribute "
"that refers to *con*:"
msgstr ""
"Атрибут только для чтения, который предоставляет базу данных SQLite :class:"
"`Connection`, принадлежащую курсору. Объект :class:`Cursor`, созданный "
"вызовом :meth:`con.cursor() <Connection.cursor>`, будет иметь атрибут :attr:"
"`connection`, который ссылается на *con*:"

#: ../../library/sqlite3.rst:1667
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> cur = con.cursor()\n"
">>> cur.connection == con\n"
"True\n"
">>> con.close()"
msgstr ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> cur = con.cursor()\n"
">>> cur.connection == con\n"
"True\n"
">>> con.close()"

#: ../../library/sqlite3.rst:1677
msgid ""
"Read-only attribute that provides the column names of the last query. To "
"remain compatible with the Python DB API, it returns a 7-tuple for each "
"column where the last six items of each tuple are ``None``."
msgstr ""
"Атрибут только для чтения, который предоставляет имена столбцов последнего "
"запроса. Чтобы оставаться совместимым с API БД Python, он возвращает 7-"
"кортеж для каждого столбца, где последние шесть элементов каждого кортежа "
"имеют значение «Нет»."

#: ../../library/sqlite3.rst:1681
msgid "It is set for ``SELECT`` statements without any matching rows as well."
msgstr ""
"Він також встановлений для операторів ``SELECT`` без будь-яких відповідних "
"рядків."

#: ../../library/sqlite3.rst:1685
msgid ""
"Read-only attribute that provides the row id of the last inserted row. It is "
"only updated after successful ``INSERT`` or ``REPLACE`` statements using "
"the :meth:`execute` method.  For other statements, after :meth:`executemany` "
"or :meth:`executescript`, or if the insertion failed, the value of "
"``lastrowid`` is left unchanged.  The initial value of ``lastrowid`` is "
"``None``."
msgstr ""
"Атрибут только для чтения, который предоставляет идентификатор последней "
"вставленной строки. Он обновляется только после успешных операторов INSERT "
"или REPLACE с использованием метода :meth:`execute`. Для других операторов "
"после :meth:`executemany` или :meth:`executescript`, или если вставка не "
"удалась, значение ``lastrowid`` остается неизменным. Начальное значение "
"«lastrowid» — «Нет»."

#: ../../library/sqlite3.rst:1693
msgid "Inserts into ``WITHOUT ROWID`` tables are not recorded."
msgstr "Вставки в таблиці ``БЕЗ ROWID`` не записуються."

#: ../../library/sqlite3.rst:1695
msgid "Added support for the ``REPLACE`` statement."
msgstr "Додано підтримку оператора REPLACE."

#: ../../library/sqlite3.rst:1700
msgid ""
"Read-only attribute that provides the number of modified rows for "
"``INSERT``, ``UPDATE``, ``DELETE``, and ``REPLACE`` statements; is ``-1`` "
"for other statements, including :abbr:`CTE (Common Table Expression)` "
"queries. It is only updated by the :meth:`execute` and :meth:`executemany` "
"methods, after the statement has run to completion. This means that any "
"resulting rows must be fetched in order for :attr:`!rowcount` to be updated."
msgstr ""
"Атрибут только для чтения, который предоставляет количество измененных строк "
"для операторов INSERT, UPDATE, DELETE и REPLACE; для других операторов, "
"включая запросы :abbr:`CTE (Common Table Expression)`, равно ``-1``. Он "
"обновляется методами :meth:`execute` и :meth:`executemany` только после "
"завершения выполнения оператора. Это означает, что все результирующие строки "
"должны быть извлечены для обновления :attr:`!rowcount`."

#: ../../library/sqlite3.rst:1711
msgid ""
"Control how a row fetched from this :class:`!Cursor` is represented. If "
"``None``, a row is represented as a :class:`tuple`. Can be set to the "
"included :class:`sqlite3.Row`; or a :term:`callable` that accepts two "
"arguments, a :class:`Cursor` object and the :class:`!tuple` of row values, "
"and returns a custom object representing an SQLite row."
msgstr ""
"Управляйте представлением строки, полученной из этого :class:`!Cursor`. Если "
"``None``, строка представлена ​​как :class:`tuple`. Можно установить "
"включенный :class:`sqlite3.Row`; или :term:`callable`, который принимает два "
"аргумента: объект :class:`Cursor` и :class:`!tuple` значений строк, и "
"возвращает пользовательский объект, представляющий строку SQLite."

#: ../../library/sqlite3.rst:1718
msgid ""
"Defaults to what :attr:`Connection.row_factory` was set to when the :class:`!"
"Cursor` was created. Assigning to this attribute does not affect :attr:"
"`Connection.row_factory` of the parent connection."
msgstr ""
"По умолчанию установлено то, что :attr:`Connection.row_factory` было "
"установлено при создании :class:`!Cursor`. Назначение этого атрибута не "
"влияет на :attr:`Connection.row_factory` родительского соединения."

#: ../../library/sqlite3.rst:1734
msgid "Row objects"
msgstr "Строковые объекты"

#: ../../library/sqlite3.rst:1738
msgid ""
"A :class:`!Row` instance serves as a highly optimized :attr:`~Connection."
"row_factory` for :class:`Connection` objects. It supports iteration, "
"equality testing, :func:`len`, and :term:`mapping` access by column name and "
"index."
msgstr ""
"Экземпляр :class:`!Row` служит высокооптимизированной :attr:`~Connection."
"row_factory` для объектов :class:`Connection`. Он поддерживает итерацию, "
"проверку на равенство, доступ :func:`len` и :term:`mapping` по имени столбца "
"и индексу."

#: ../../library/sqlite3.rst:1743
msgid ""
"Two :class:`!Row` objects compare equal if they have identical column names "
"and values."
msgstr ""
"Два объекта :class:`!Row` сравниваются равными, если они имеют одинаковые "
"имена и значения столбцов."

#: ../../library/sqlite3.rst:1750
msgid ""
"Return a :class:`list` of column names as :class:`strings <str>`. "
"Immediately after a query, it is the first member of each tuple in :attr:"
"`Cursor.description`."
msgstr ""
"Верните список имен столбцов в виде :class:`strings <str>`. Сразу после "
"запроса он становится первым членом каждого кортежа в :attr:`Cursor."
"description`."

#: ../../library/sqlite3.rst:1754
msgid "Added support of slicing."
msgstr "Menambahkan dukungan dari pemotongan."

#: ../../library/sqlite3.rst:1761
msgid "Blob objects"
msgstr "Объекты BLOB-объектов"

#: ../../library/sqlite3.rst:1767
msgid ""
"A :class:`Blob` instance is a :term:`file-like object` that can read and "
"write data in an SQLite :abbr:`BLOB (Binary Large OBject)`. Call :func:"
"`len(blob) <len>` to get the size (number of bytes) of the blob. Use indices "
"and :term:`slices <slice>` for direct access to the blob data."
msgstr ""
"Экземпляр :class:`Blob` — это :term:`файлоподобный объект`, который может "
"читать и записывать данные в SQLite :abbr:`BLOB (большой двоичный объект)`. "
"Вызовите :func:`len(blob) <len>`, чтобы получить размер (количество байтов) "
"большого двоичного объекта. Используйте индексы и :term:`slices <slice>` для "
"прямого доступа к данным большого двоичного объекта."

#: ../../library/sqlite3.rst:1772
msgid ""
"Use the :class:`Blob` as a :term:`context manager` to ensure that the blob "
"handle is closed after use."
msgstr ""
"Используйте :class:`Blob` в качестве :term:`контекстного менеджера`, чтобы "
"гарантировать, что дескриптор BLOB-объекта будет закрыт после использования."

#: ../../library/sqlite3.rst:1775
msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE test(blob_col blob)\")\n"
"con.execute(\"INSERT INTO test(blob_col) VALUES(zeroblob(13))\")\n"
"\n"
"# Write to our blob, using two write operations:\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    blob.write(b\"hello, \")\n"
"    blob.write(b\"world.\")\n"
"    # Modify the first and last bytes of our blob\n"
"    blob[0] = ord(\"H\")\n"
"    blob[-1] = ord(\"!\")\n"
"\n"
"# Read the contents of our blob\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    greeting = blob.read()\n"
"\n"
"print(greeting)  # outputs \"b'Hello, world!'\"\n"
"con.close()"
msgstr ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE test(blob_col blob)\")\n"
"con.execute(\"INSERT INTO test(blob_col) VALUES(zeroblob(13))\")\n"
"\n"
"# Write to our blob, using two write operations:\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    blob.write(b\"hello, \")\n"
"    blob.write(b\"world.\")\n"
"    # Modify the first and last bytes of our blob\n"
"    blob[0] = ord(\"H\")\n"
"    blob[-1] = ord(\"!\")\n"
"\n"
"# Read the contents of our blob\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    greeting = blob.read()\n"
"\n"
"print(greeting)  # outputs \"b'Hello, world!'\"\n"
"con.close()"

#: ../../library/sqlite3.rst:1803
msgid "Close the blob."
msgstr "Закройте blob."

#: ../../library/sqlite3.rst:1805
msgid ""
"The blob will be unusable from this point onward.  An :class:`~sqlite3."
"Error` (or subclass) exception will be raised if any further operation is "
"attempted with the blob."
msgstr ""
"С этого момента большой двоичный объект станет непригоден для использования. "
"Исключение :class:`~sqlite3.Error` (или подкласса) будет вызвано при попытке "
"какой-либо дальнейшей операции с большим двоичным объектом."

#: ../../library/sqlite3.rst:1811
msgid ""
"Read *length* bytes of data from the blob at the current offset position. If "
"the end of the blob is reached, the data up to :abbr:`EOF (End of File)` "
"will be returned.  When *length* is not specified, or is negative, :meth:"
"`~Blob.read` will read until the end of the blob."
msgstr ""
"Считайте *длину* байтов данных из большого двоичного объекта в текущей "
"позиции смещения. Если достигнут конец большого двоичного объекта, будут "
"возвращены данные до :abbr:`EOF (конец файла)`. Если *длина* не указана или "
"имеет отрицательное значение, :meth:`~Blob.read` будет читать до конца "
"большого двоичного объекта."

#: ../../library/sqlite3.rst:1819
msgid ""
"Write *data* to the blob at the current offset.  This function cannot change "
"the blob length.  Writing beyond the end of the blob will raise :exc:"
"`ValueError`."
msgstr ""
"Запишите *данные* в большой двоичный объект по текущему смещению. Эта "
"функция не может изменить длину большого двоичного объекта. Запись за "
"пределами BLOB-объекта вызовет :exc:`ValueError`."

#: ../../library/sqlite3.rst:1825
msgid "Return the current access position of the blob."
msgstr "Верните текущую позицию доступа к большому двоичному объекту."

#: ../../library/sqlite3.rst:1829
msgid ""
"Set the current access position of the blob to *offset*.  The *origin* "
"argument defaults to :const:`os.SEEK_SET` (absolute blob positioning). Other "
"values for *origin* are :const:`os.SEEK_CUR` (seek relative to the current "
"position) and :const:`os.SEEK_END` (seek relative to the blob’s end)."
msgstr ""
"Установите текущую позицию доступа к большому двоичному объекту как "
"*offset*. Аргумент *origin* по умолчанию имеет значение :const:`os.SEEK_SET` "
"(абсолютное позиционирование больших двоичных объектов). Другими значениями "
"*origin* являются :const:`os.SEEK_CUR` (поиск относительно текущей позиции) "
"и :const:`os.SEEK_END` (поиск относительно конца большого двоичного объекта)."

#: ../../library/sqlite3.rst:1837
msgid "PrepareProtocol objects"
msgstr "Объекты подготовки протокола"

#: ../../library/sqlite3.rst:1841
msgid ""
"The PrepareProtocol type's single purpose is to act as a :pep:`246` style "
"adaption protocol for objects that can :ref:`adapt themselves <sqlite3-"
"conform>` to :ref:`native SQLite types <sqlite3-types>`."
msgstr ""
"Единственная цель типа ПодготовкаПротокол — действовать как протокол "
"адаптации стиля :pep:`246` для объектов, которые могут :ref:`адаптироваться "
"<sqlite3-conform>` к :ref:`родным типам SQLite <sqlite3-types>`."

#: ../../library/sqlite3.rst:1849
msgid "Exceptions"
msgstr "Exceções"

#: ../../library/sqlite3.rst:1851
msgid "The exception hierarchy is defined by the DB-API 2.0 (:pep:`249`)."
msgstr "Ієрархія винятків визначається DB-API 2.0 (:pep:`249`)."

#: ../../library/sqlite3.rst:1855
msgid ""
"This exception is not currently raised by the :mod:`!sqlite3` module, but "
"may be raised by applications using :mod:`!sqlite3`, for example if a user-"
"defined function truncates data while inserting. ``Warning`` is a subclass "
"of :exc:`Exception`."
msgstr ""
"Это исключение в настоящее время не вызывается модулем :mod:`!sqlite3`, но "
"может быть вызвано приложениями, использующими :mod:`!sqlite3`, например, "
"если определяемая пользователем функция усекает данные при вставке. "
"``Warning`` является подклассом :exc:`Exception`."

#: ../../library/sqlite3.rst:1862
msgid ""
"The base class of the other exceptions in this module. Use this to catch all "
"errors with one single :keyword:`except` statement. ``Error`` is a subclass "
"of :exc:`Exception`."
msgstr ""
"Базовий клас інших винятків у цьому модулі. Використовуйте це, щоб "
"перехопити всі помилки за допомогою одного оператора :keyword:`except`. "
"``Error`` є підкласом :exc:`Exception`."

#: ../../library/sqlite3.rst:1866
msgid ""
"If the exception originated from within the SQLite library, the following "
"two attributes are added to the exception:"
msgstr ""
"Если исключение возникло из библиотеки SQLite, к исключению добавляются "
"следующие два атрибута:"

#: ../../library/sqlite3.rst:1871
msgid ""
"The numeric error code from the `SQLite API <https://sqlite.org/rescode."
"html>`_"
msgstr "Числовой код ошибки из `SQLite API <https://sqlite.org/rescode.html>`_"

#: ../../library/sqlite3.rst:1878
msgid ""
"The symbolic name of the numeric error code from the `SQLite API <https://"
"sqlite.org/rescode.html>`_"
msgstr ""
"Символическое имя числового кода ошибки из `SQLite API <https://sqlite.org/"
"rescode.html>`_"

#: ../../library/sqlite3.rst:1885
msgid ""
"Exception raised for misuse of the low-level SQLite C API. In other words, "
"if this exception is raised, it probably indicates a bug in the :mod:`!"
"sqlite3` module. ``InterfaceError`` is a subclass of :exc:`Error`."
msgstr ""
"Исключение возникло из-за неправильного использования низкоуровневого API "
"SQLite C. Другими словами, если это исключение возникает, это, вероятно, "
"указывает на ошибку в модуле :mod:`!sqlite3`. ``InterfaceError`` является "
"подклассом :exc:`Error`."

#: ../../library/sqlite3.rst:1892
msgid ""
"Exception raised for errors that are related to the database. This serves as "
"the base exception for several types of database errors. It is only raised "
"implicitly through the specialised subclasses. ``DatabaseError`` is a "
"subclass of :exc:`Error`."
msgstr ""
"Виняток створено для помилок, пов’язаних із базою даних. Це служить базовим "
"винятком для кількох типів помилок бази даних. Він виникає лише неявно через "
"спеціалізовані підкласи. ``DatabaseError`` є підкласом :exc:`Error`."

#: ../../library/sqlite3.rst:1899
msgid ""
"Exception raised for errors caused by problems with the processed data, like "
"numeric values out of range, and strings which are too long. ``DataError`` "
"is a subclass of :exc:`DatabaseError`."
msgstr ""
"Виняток створено для помилок, спричинених проблемами з обробленими даними, "
"як-от числові значення поза межами діапазону та надто довгі рядки. "
"``DataError`` є підкласом :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1905
msgid ""
"Exception raised for errors that are related to the database's operation, "
"and not necessarily under the control of the programmer. For example, the "
"database path is not found, or a transaction could not be processed. "
"``OperationalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"Виняток створено для помилок, які пов’язані з роботою бази даних і не "
"обов’язково знаходяться під контролем програміста. Наприклад, шлях до бази "
"даних не знайдено або транзакцію не вдалося обробити. ``OperationalError`` є "
"підкласом :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1913
msgid ""
"Exception raised when the relational integrity of the database is affected, "
"e.g. a foreign key check fails.  It is a subclass of :exc:`DatabaseError`."
msgstr ""
"Виняток виникає, коли порушується реляційна цілісність бази даних, "
"наприклад. не вдається перевірити зовнішній ключ. Це підклас :exc:"
"`DatabaseError`."

#: ../../library/sqlite3.rst:1918
msgid ""
"Exception raised when SQLite encounters an internal error. If this is "
"raised, it may indicate that there is a problem with the runtime SQLite "
"library. ``InternalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"Виняток виникає, коли SQLite стикається з внутрішньою помилкою. Якщо це "
"виникає, це може означати, що існує проблема з бібліотекою SQLite під час "
"виконання. ``InternalError`` є підкласом :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1925
msgid ""
"Exception raised for :mod:`!sqlite3` API programming errors, for example "
"supplying the wrong number of bindings to a query, or trying to operate on a "
"closed :class:`Connection`. ``ProgrammingError`` is a subclass of :exc:"
"`DatabaseError`."
msgstr ""
"Исключение возникает из-за ошибок программирования API :mod:`!sqlite3`, "
"например, предоставления неправильного количества привязок к запросу или "
"попытки работы с закрытым :class:`Соединением`. ``ProgrammingError`` "
"является подклассом :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1932
msgid ""
"Exception raised in case a method or database API is not supported by the "
"underlying SQLite library. For example, setting *deterministic* to ``True`` "
"in :meth:`~Connection.create_function`, if the underlying SQLite library "
"does not support deterministic functions. ``NotSupportedError`` is a "
"subclass of :exc:`DatabaseError`."
msgstr ""
"Исключение возникает в случае, если метод или API базы данных не "
"поддерживается базовой библиотекой SQLite. Например, установите для "
"параметра *deterministic* значение True в :meth:`~Connection."
"create_function`, если базовая библиотека SQLite не поддерживает "
"детерминированные функции. ``NotSupportedError`` является подклассом :exc:"
"`DatabaseError`."

#: ../../library/sqlite3.rst:1942
msgid "SQLite and Python types"
msgstr "SQLite dan tipe Python"

#: ../../library/sqlite3.rst:1944
msgid ""
"SQLite natively supports the following types: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."
msgstr ""
"SQLite спочатку підтримує такі типи: ``NULL``, ``INTEGER``, ``REAL``, "
"``TEXT``, ``BLOB``."

#: ../../library/sqlite3.rst:1947
msgid ""
"The following Python types can thus be sent to SQLite without any problem:"
msgstr ""
"Таким чином, такі типи Python можна без будь-яких проблем надсилати до "
"SQLite:"

#: ../../library/sqlite3.rst:1950 ../../library/sqlite3.rst:1967
msgid "Python type"
msgstr "Tipo em Python"

#: ../../library/sqlite3.rst:1950 ../../library/sqlite3.rst:1967
msgid "SQLite type"
msgstr "Tipo em SQLite"

#: ../../library/sqlite3.rst:1952 ../../library/sqlite3.rst:1969
msgid "``None``"
msgstr "``None``"

#: ../../library/sqlite3.rst:1952 ../../library/sqlite3.rst:1969
msgid "``NULL``"
msgstr "``NULL``"

#: ../../library/sqlite3.rst:1954 ../../library/sqlite3.rst:1971
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../library/sqlite3.rst:1954 ../../library/sqlite3.rst:1971
msgid "``INTEGER``"
msgstr "``INTEGER``"

#: ../../library/sqlite3.rst:1956 ../../library/sqlite3.rst:1973
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../library/sqlite3.rst:1956 ../../library/sqlite3.rst:1973
msgid "``REAL``"
msgstr "``REAL``"

#: ../../library/sqlite3.rst:1958
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../library/sqlite3.rst:1958 ../../library/sqlite3.rst:1975
msgid "``TEXT``"
msgstr "``TEXT``"

#: ../../library/sqlite3.rst:1960 ../../library/sqlite3.rst:1978
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../library/sqlite3.rst:1960 ../../library/sqlite3.rst:1978
msgid "``BLOB``"
msgstr "``BLOB``"

#: ../../library/sqlite3.rst:1964
msgid "This is how SQLite types are converted to Python types by default:"
msgstr "Ось як типи SQLite перетворюються на типи Python за замовчуванням:"

#: ../../library/sqlite3.rst:1975
msgid "depends on :attr:`~Connection.text_factory`, :class:`str` by default"
msgstr ""
"залежить від :attr:`~Connection.text_factory`, :class:`str` за замовчуванням"

#: ../../library/sqlite3.rst:1981
msgid ""
"The type system of the :mod:`!sqlite3` module is extensible in two ways: you "
"can store additional Python types in an SQLite database via :ref:`object "
"adapters <sqlite3-adapters>`, and you can let the :mod:`!sqlite3` module "
"convert SQLite types to Python types via :ref:`converters <sqlite3-"
"converters>`."
msgstr ""
"Система типов модуля :mod:`!sqlite3` расширяется двумя способами: вы можете "
"хранить дополнительные типы Python в базе данных SQLite через :ref:`object "
"адаптеры <sqlite3-adapters>`, и вы можете позволить :mod Модуль :`!sqlite3` "
"преобразует типы SQLite в типы Python с помощью :ref:`converters <sqlite3-"
"converters>`."

#: ../../library/sqlite3.rst:1991
msgid "Default adapters and converters (deprecated)"
msgstr "Адаптеры и конвертеры по умолчанию (устарело)"

#: ../../library/sqlite3.rst:1995
msgid ""
"The default adapters and converters are deprecated as of Python 3.12. "
"Instead, use the :ref:`sqlite3-adapter-converter-recipes` and tailor them to "
"your needs."
msgstr ""
"Адаптеры и конвертеры по умолчанию устарели, начиная с Python 3.12. Вместо "
"этого используйте sqlite3-adapter-converter-recipes и адаптируйте их к своим "
"потребностям."

#: ../../library/sqlite3.rst:1999
msgid "The deprecated default adapters and converters consist of:"
msgstr "Устаревшие адаптеры и преобразователи по умолчанию состоят из:"

#: ../../library/sqlite3.rst:2001
msgid ""
"An adapter for :class:`datetime.date` objects to :class:`strings <str>` in "
"`ISO 8601`_ format."
msgstr ""
"Адаптер для объектов :class:`datetime.date` к :class:`strings <str>` в "
"формате `ISO 8601`_."

#: ../../library/sqlite3.rst:2003
msgid ""
"An adapter for :class:`datetime.datetime` objects to strings in ISO 8601 "
"format."
msgstr ""
"Адаптер для объектов :class:`datetime.datetime` к строкам в формате ISO 8601."

#: ../../library/sqlite3.rst:2005
msgid ""
"A converter for :ref:`declared <sqlite3-converters>` \"date\" types to :"
"class:`datetime.date` objects."
msgstr ""
"Конвертер для объявленных <sqlite3-converters>` типов даты в объекты :class:"
"`datetime.date`."

#: ../../library/sqlite3.rst:2007
msgid ""
"A converter for declared \"timestamp\" types to :class:`datetime.datetime` "
"objects. Fractional parts will be truncated to 6 digits (microsecond "
"precision)."
msgstr ""
"Конвертер объявленных типов «меток времени» в объекты :class:`datetime."
"datetime`. Дробные части будут усечены до 6 цифр (с точностью до "
"микросекунды)."

#: ../../library/sqlite3.rst:2013
msgid ""
"The default \"timestamp\" converter ignores UTC offsets in the database and "
"always returns a naive :class:`datetime.datetime` object. To preserve UTC "
"offsets in timestamps, either leave converters disabled, or register an "
"offset-aware converter with :func:`register_converter`."
msgstr ""
"Конвертер \"міток часу\" за замовчуванням ігнорує зміщення UTC у базі даних "
"і завжди повертає простий об’єкт :class:`datetime.datetime`. Щоб зберегти "
"зміщення UTC у мітках часу, залиште конвертери вимкненими або зареєструйте "
"конвертер із зсувом за допомогою :func:`register_converter`."

#: ../../library/sqlite3.rst:2026
msgid "Command-line interface"
msgstr "Interface de linha de comando"

#: ../../library/sqlite3.rst:2028
msgid ""
"The :mod:`!sqlite3` module can be invoked as a script, using the "
"interpreter's :option:`-m` switch, in order to provide a simple SQLite "
"shell. The argument signature is as follows::"
msgstr ""
"Модуль :mod:`!sqlite3` можно вызвать как скрипт, используя переключатель "
"интерпретатора :option:`-m`, чтобы обеспечить простую оболочку SQLite. "
"Сигнатура аргумента следующая:"

#: ../../library/sqlite3.rst:2033
msgid "python -m sqlite3 [-h] [-v] [filename] [sql]"
msgstr "python -m sqlite3 [-h] [-v] [filename] [sql]"

#: ../../library/sqlite3.rst:2035
msgid "Type ``.quit`` or CTRL-D to exit the shell."
msgstr "Введите ``.quit`` или CTRL-D, чтобы выйти из оболочки."

#: ../../library/sqlite3.rst:2041
msgid "Print CLI help."
msgstr "Распечатать справку CLI."

#: ../../library/sqlite3.rst:2045
msgid "Print underlying SQLite library version."
msgstr "Распечатайте базовую версию библиотеки SQLite."

#: ../../library/sqlite3.rst:2053
msgid "How-to guides"
msgstr "Guias de como fazer"

#: ../../library/sqlite3.rst:2058
msgid "How to use placeholders to bind values in SQL queries"
msgstr "Как использовать заполнители для привязки значений в запросах SQL"

#: ../../library/sqlite3.rst:2060
msgid ""
"SQL operations usually need to use values from Python variables. However, "
"beware of using Python's string operations to assemble queries, as they are "
"vulnerable to `SQL injection attacks`_. For example, an attacker can simply "
"close the single quote and inject ``OR TRUE`` to select all rows::"
msgstr ""
"В операциях SQL обычно необходимо использовать значения переменных Python. "
"Однако остерегайтесь использования строковых операций Python для сборки "
"запросов, поскольку они уязвимы для атак с использованием SQL-инъекций. "
"Например, злоумышленник может просто закрыть одинарную кавычку и ввести ``OR "
"TRUE``, чтобы выбрать все строки:"

#: ../../library/sqlite3.rst:2065
msgid ""
">>> # Never do this -- insecure!\n"
">>> symbol = input()\n"
"' OR TRUE; --\n"
">>> sql = \"SELECT * FROM stocks WHERE symbol = '%s'\" % symbol\n"
">>> print(sql)\n"
"SELECT * FROM stocks WHERE symbol = '' OR TRUE; --'\n"
">>> cur.execute(sql)"
msgstr ""
">>> # Never do this -- insecure!\n"
">>> symbol = input()\n"
"' OR TRUE; --\n"
">>> sql = \"SELECT * FROM stocks WHERE symbol = '%s'\" % symbol\n"
">>> print(sql)\n"
"SELECT * FROM stocks WHERE symbol = '' OR TRUE; --'\n"
">>> cur.execute(sql)"

#: ../../library/sqlite3.rst:2073
msgid ""
"Instead, use the DB-API's parameter substitution. To insert a variable into "
"a query string, use a placeholder in the string, and substitute the actual "
"values into the query by providing them as a :class:`tuple` of values to the "
"second argument of the cursor's :meth:`~Cursor.execute` method."
msgstr ""
"Вместо этого используйте подстановку параметров DB-API. Чтобы вставить "
"переменную в строку запроса, используйте заполнитель в строке и подставьте "
"фактические значения в запрос, предоставив их в виде :class:`tuple` значений "
"для второго аргумента :meth:`~Cursor курсора. .execute` метод."

#: ../../library/sqlite3.rst:2078
msgid ""
"An SQL statement may use one of two kinds of placeholders: question marks "
"(qmark style) or named placeholders (named style). For the qmark style, "
"*parameters* must be a :term:`sequence` whose length must match the number "
"of placeholders, or a :exc:`ProgrammingError` is raised. For the named "
"style, *parameters* must be an instance of a :class:`dict` (or a subclass), "
"which must contain keys for all named parameters; any extra items are "
"ignored. Here's an example of both styles:"
msgstr ""
"В операторе SQL может использоваться один из двух типов заполнителей: "
"вопросительные знаки (стиль qmark) или именованные заполнители (именованный "
"стиль). Для стиля qmark *параметры* должны быть :term:`sequence`, длина "
"которого должна соответствовать количеству заполнителей, иначе возникнет :"
"exc:`ProgrammingError`. Для именованного стиля *parameters* должен быть "
"экземпляром :class:`dict` (или подкласса), который должен содержать ключи "
"для всех именованных параметров; любые дополнительные элементы игнорируются. "
"Вот пример обоих стилей:"

#: ../../library/sqlite3.rst:2089
msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE lang(name, first_appeared)\")\n"
"\n"
"# This is the named style used with executemany():\n"
"data = (\n"
"    {\"name\": \"C\", \"year\": 1972},\n"
"    {\"name\": \"Fortran\", \"year\": 1957},\n"
"    {\"name\": \"Python\", \"year\": 1991},\n"
"    {\"name\": \"Go\", \"year\": 2009},\n"
")\n"
"cur.executemany(\"INSERT INTO lang VALUES(:name, :year)\", data)\n"
"\n"
"# This is the qmark style used in a SELECT query:\n"
"params = (1972,)\n"
"cur.execute(\"SELECT * FROM lang WHERE first_appeared = ?\", params)\n"
"print(cur.fetchall())\n"
"con.close()"
msgstr ""
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE lang(name, first_appeared)\")\n"
"\n"
"# This is the named style used with executemany():\n"
"data = (\n"
"    {\"name\": \"C\", \"year\": 1972},\n"
"    {\"name\": \"Fortran\", \"year\": 1957},\n"
"    {\"name\": \"Python\", \"year\": 1991},\n"
"    {\"name\": \"Go\", \"year\": 2009},\n"
")\n"
"cur.executemany(\"INSERT INTO lang VALUES(:name, :year)\", data)\n"
"\n"
"# This is the qmark style used in a SELECT query:\n"
"params = (1972,)\n"
"cur.execute(\"SELECT * FROM lang WHERE first_appeared = ?\", params)\n"
"print(cur.fetchall())\n"
"con.close()"

#: ../../library/sqlite3.rst:2116
msgid ""
":pep:`249` numeric placeholders are *not* supported. If used, they will be "
"interpreted as named placeholders."
msgstr ""
":pep:`249` числовые заполнители *не* поддерживаются. Если они используются, "
"они будут интерпретироваться как именованные заполнители."

#: ../../library/sqlite3.rst:2123
msgid "How to adapt custom Python types to SQLite values"
msgstr "Как адаптировать пользовательские типы Python к значениям SQLite"

#: ../../library/sqlite3.rst:2125
msgid ""
"SQLite supports only a limited set of data types natively. To store custom "
"Python types in SQLite databases, *adapt* them to one of the :ref:`Python "
"types SQLite natively understands <sqlite3-types>`."
msgstr ""
"SQLite изначально поддерживает только ограниченный набор типов данных. Чтобы "
"хранить пользовательские типы Python в базах данных SQLite, *адаптируйте* их "
"к одному из :ref:`типов Python, SQLite изначально понимает <sqlite3-types>`."

#: ../../library/sqlite3.rst:2129
msgid ""
"There are two ways to adapt Python objects to SQLite types: letting your "
"object adapt itself, or using an *adapter callable*. The latter will take "
"precedence above the former. For a library that exports a custom type, it "
"may make sense to enable that type to adapt itself. As an application "
"developer, it may make more sense to take direct control by registering "
"custom adapter functions."
msgstr ""
"Есть два способа адаптировать объекты Python к типам SQLite: позволить "
"вашему объекту адаптироваться самостоятельно или использовать *вызываемый "
"адаптер*. Последнее будет иметь приоритет над первым. Для библиотеки, "
"которая экспортирует пользовательский тип, возможно, имеет смысл разрешить "
"этому типу адаптироваться. Разработчику приложений, возможно, имеет смысл "
"взять на себя прямой контроль путем регистрации пользовательских функций "
"адаптера."

#: ../../library/sqlite3.rst:2141
msgid "How to write adaptable objects"
msgstr "Как писать адаптируемые объекты"

#: ../../library/sqlite3.rst:2143
msgid ""
"Suppose we have a :class:`!Point` class that represents a pair of "
"coordinates, ``x`` and ``y``, in a Cartesian coordinate system. The "
"coordinate pair will be stored as a text string in the database, using a "
"semicolon to separate the coordinates. This can be implemented by adding a "
"``__conform__(self, protocol)`` method which returns the adapted value. The "
"object passed to *protocol* will be of type :class:`PrepareProtocol`."
msgstr ""
"Предположим, у нас есть класс :class:`!Point`, который представляет пару "
"координат ``x`` и ``y`` в декартовой системе координат. Пара координат будет "
"храниться в базе данных в виде текстовой строки с использованием точки с "
"запятой для разделения координат. Это можно реализовать, добавив метод "
"``__conform__(self, протокол)``, который возвращает адаптированное значение. "
"Объект, передаваемый в *protocol*, будет иметь тип :class:`PrepareProtocol`."

#: ../../library/sqlite3.rst:2151
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __conform__(self, protocol):\n"
"        if protocol is sqlite3.PrepareProtocol:\n"
"            return f\"{self.x};{self.y}\"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Point(4.0, -3.2),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"
msgstr ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __conform__(self, protocol):\n"
"        if protocol is sqlite3.PrepareProtocol:\n"
"            return f\"{self.x};{self.y}\"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Point(4.0, -3.2),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"

#: ../../library/sqlite3.rst:2175
msgid "How to register adapter callables"
msgstr "Как зарегистрировать вызываемые объекты адаптера"

#: ../../library/sqlite3.rst:2177
msgid ""
"The other possibility is to create a function that converts the Python "
"object to an SQLite-compatible type. This function can then be registered "
"using :func:`register_adapter`."
msgstr ""
"Другая возможность — создать функцию, которая преобразует объект Python в "
"тип, совместимый с SQLite. Эту функцию затем можно зарегистрировать с "
"помощью :func:`register_adapter`."

#: ../../library/sqlite3.rst:2181
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"def adapt_point(point):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Point(1.0, 2.5),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"
msgstr ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"def adapt_point(point):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Point(1.0, 2.5),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"

#: ../../library/sqlite3.rst:2208
msgid "How to convert SQLite values to custom Python types"
msgstr "Как преобразовать значения SQLite в пользовательские типы Python"

#: ../../library/sqlite3.rst:2210
msgid ""
"Writing an adapter lets you convert *from* custom Python types *to* SQLite "
"values. To be able to convert *from* SQLite values *to* custom Python types, "
"we use *converters*."
msgstr ""
"Написание адаптера позволяет конвертировать *из* пользовательских типов "
"Python *в* значения SQLite. Чтобы иметь возможность конвертировать *из* "
"значений SQLite *в* пользовательские типы Python, мы используем *конвертеры*."

#: ../../library/sqlite3.rst:2215
msgid ""
"Let's go back to the :class:`!Point` class. We stored the x and y "
"coordinates separated via semicolons as strings in SQLite."
msgstr ""
"Давайте вернемся к классу :class:`!Point`. Мы сохранили координаты x и y, "
"разделенные точкой с запятой, в виде строк в SQLite."

#: ../../library/sqlite3.rst:2218
msgid ""
"First, we'll define a converter function that accepts the string as a "
"parameter and constructs a :class:`!Point` object from it."
msgstr ""
"Сначала мы определим функцию-конвертер, которая принимает строку в качестве "
"параметра и создает из нее объект :class:`!Point`."

#: ../../library/sqlite3.rst:2223
msgid ""
"Converter functions are **always** passed a :class:`bytes` object, no matter "
"the underlying SQLite data type."
msgstr ""
"Функциям преобразователя **всегда** передается объект :class:`bytes`, "
"независимо от базового типа данных SQLite."

#: ../../library/sqlite3.rst:2226
msgid ""
"def convert_point(s):\n"
"    x, y = map(float, s.split(b\";\"))\n"
"    return Point(x, y)"
msgstr ""
"def convert_point(s):\n"
"    x, y = map(float, s.split(b\";\"))\n"
"    return Point(x, y)"

#: ../../library/sqlite3.rst:2232
msgid ""
"We now need to tell :mod:`!sqlite3` when it should convert a given SQLite "
"value. This is done when connecting to a database, using the *detect_types* "
"parameter of :func:`connect`. There are three options:"
msgstr ""
"Теперь нам нужно сообщить :mod:`!sqlite3`, когда ему следует преобразовать "
"данное значение SQLite. Это делается при подключении к базе данных с "
"использованием параметра *detect_types* функции :func:`connect`. Есть три "
"варианта:"

#: ../../library/sqlite3.rst:2236
msgid "Implicit: set *detect_types* to :const:`PARSE_DECLTYPES`"
msgstr ""
"Неявно: установите для *detect_types* значение :const:`PARSE_DECLTYPES`"

#: ../../library/sqlite3.rst:2237
msgid "Explicit: set *detect_types* to :const:`PARSE_COLNAMES`"
msgstr "Явно: установите для *detect_types* значение :const:`PARSE_COLNAMES`"

#: ../../library/sqlite3.rst:2238
msgid ""
"Both: set *detect_types* to ``sqlite3.PARSE_DECLTYPES | sqlite3."
"PARSE_COLNAMES``. Column names take precedence over declared types."
msgstr ""
"Оба: установите для *detect_types* значение ``sqlite3.PARSE_DECLTYPES | "
"sqlite3.PARSE_COLNAMES``. Имена столбцов имеют приоритет над объявленными "
"типами."

#: ../../library/sqlite3.rst:2242
msgid "The following example illustrates the implicit and explicit approaches:"
msgstr "Следующий пример иллюстрирует неявный и явный подходы:"

#: ../../library/sqlite3.rst:2244
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __repr__(self):\n"
"        return f\"Point({self.x}, {self.y})\"\n"
"\n"
"def adapt_point(point):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"def convert_point(s):\n"
"    x, y = list(map(float, s.split(b\";\")))\n"
"    return Point(x, y)\n"
"\n"
"# Register the adapter and converter\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"sqlite3.register_converter(\"point\", convert_point)\n"
"\n"
"# 1) Parse using declared types\n"
"p = Point(4.0, -3.2)\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_DECLTYPES)\n"
"cur = con.execute(\"CREATE TABLE test(p point)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute(\"SELECT p FROM test\")\n"
"print(\"with declared types:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()\n"
"\n"
"# 2) Parse using column names\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_COLNAMES)\n"
"cur = con.execute(\"CREATE TABLE test(p)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute('SELECT p AS \"p [point]\" FROM test')\n"
"print(\"with column names:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()"
msgstr ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __repr__(self):\n"
"        return f\"Point({self.x}, {self.y})\"\n"
"\n"
"def adapt_point(point):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"def convert_point(s):\n"
"    x, y = list(map(float, s.split(b\";\")))\n"
"    return Point(x, y)\n"
"\n"
"# Register the adapter and converter\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"sqlite3.register_converter(\"point\", convert_point)\n"
"\n"
"# 1) Parse using declared types\n"
"p = Point(4.0, -3.2)\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_DECLTYPES)\n"
"cur = con.execute(\"CREATE TABLE test(p point)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute(\"SELECT p FROM test\")\n"
"print(\"with declared types:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()\n"
"\n"
"# 2) Parse using column names\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_COLNAMES)\n"
"cur = con.execute(\"CREATE TABLE test(p)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute('SELECT p AS \"p [point]\" FROM test')\n"
"print(\"with column names:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()"

#: ../../library/sqlite3.rst:2295
msgid "Adapter and converter recipes"
msgstr "Рецепты адаптеров и преобразователей"

#: ../../library/sqlite3.rst:2297
msgid "This section shows recipes for common adapters and converters."
msgstr ""
"В этом разделе показаны рецепты для распространенных адаптеров и "
"преобразователей."

#: ../../library/sqlite3.rst:2299
msgid ""
"import datetime\n"
"import sqlite3\n"
"\n"
"def adapt_date_iso(val):\n"
"    \"\"\"Adapt datetime.date to ISO 8601 date.\"\"\"\n"
"    return val.isoformat()\n"
"\n"
"def adapt_datetime_iso(val):\n"
"    \"\"\"Adapt datetime.datetime to timezone-naive ISO 8601 date.\"\"\"\n"
"    return val.replace(tzinfo=None).isoformat()\n"
"\n"
"def adapt_datetime_epoch(val):\n"
"    \"\"\"Adapt datetime.datetime to Unix timestamp.\"\"\"\n"
"    return int(val.timestamp())\n"
"\n"
"sqlite3.register_adapter(datetime.date, adapt_date_iso)\n"
"sqlite3.register_adapter(datetime.datetime, adapt_datetime_iso)\n"
"sqlite3.register_adapter(datetime.datetime, adapt_datetime_epoch)\n"
"\n"
"def convert_date(val):\n"
"    \"\"\"Convert ISO 8601 date to datetime.date object.\"\"\"\n"
"    return datetime.date.fromisoformat(val.decode())\n"
"\n"
"def convert_datetime(val):\n"
"    \"\"\"Convert ISO 8601 datetime to datetime.datetime object.\"\"\"\n"
"    return datetime.datetime.fromisoformat(val.decode())\n"
"\n"
"def convert_timestamp(val):\n"
"    \"\"\"Convert Unix epoch timestamp to datetime.datetime object.\"\"\"\n"
"    return datetime.datetime.fromtimestamp(int(val))\n"
"\n"
"sqlite3.register_converter(\"date\", convert_date)\n"
"sqlite3.register_converter(\"datetime\", convert_datetime)\n"
"sqlite3.register_converter(\"timestamp\", convert_timestamp)"
msgstr ""

#: ../../library/sqlite3.rst:2359
msgid "How to use connection shortcut methods"
msgstr "Как использовать методы быстрого подключения"

#: ../../library/sqlite3.rst:2361
msgid ""
"Using the :meth:`~Connection.execute`, :meth:`~Connection.executemany`, and :"
"meth:`~Connection.executescript` methods of the :class:`Connection` class, "
"your code can be written more concisely because you don't have to create the "
"(often superfluous) :class:`Cursor` objects explicitly. Instead, the :class:"
"`Cursor` objects are created implicitly and these shortcut methods return "
"the cursor objects. This way, you can execute a ``SELECT`` statement and "
"iterate over it directly using only a single call on the :class:`Connection` "
"object."
msgstr ""
"Используя методы :meth:`~Connection.execute`, :meth:`~Connection."
"executemany` и :meth:`~Connection.executescript` класса :class:`Connection`, "
"ваш код можно написать более кратко. потому что вам не нужно явно создавать "
"(часто лишние) объекты :class:`Cursor`. Вместо этого объекты :class:`Cursor` "
"создаются неявно, и эти методы быстрого доступа возвращают объекты курсора. "
"Таким образом, вы можете выполнить оператор ``SELECT`` и перебирать его "
"напрямую, используя только один вызов объекта :class:`Connection`."

#: ../../library/sqlite3.rst:2370
msgid ""
"# Create and fill the table.\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lang(name, first_appeared)\")\n"
"data = [\n"
"    (\"C++\", 1985),\n"
"    (\"Objective-C\", 1984),\n"
"]\n"
"con.executemany(\"INSERT INTO lang(name, first_appeared) VALUES(?, ?)\", "
"data)\n"
"\n"
"# Print the table contents\n"
"for row in con.execute(\"SELECT name, first_appeared FROM lang\"):\n"
"    print(row)\n"
"\n"
"print(\"I just deleted\", con.execute(\"DELETE FROM lang\").rowcount, "
"\"rows\")\n"
"\n"
"# close() is not a shortcut method and it's not called automatically;\n"
"# the connection object should be closed manually\n"
"con.close()"
msgstr ""
"# Create and fill the table.\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lang(name, first_appeared)\")\n"
"data = [\n"
"    (\"C++\", 1985),\n"
"    (\"Objective-C\", 1984),\n"
"]\n"
"con.executemany(\"INSERT INTO lang(name, first_appeared) VALUES(?, ?)\", "
"data)\n"
"\n"
"# Print the table contents\n"
"for row in con.execute(\"SELECT name, first_appeared FROM lang\"):\n"
"    print(row)\n"
"\n"
"print(\"I just deleted\", con.execute(\"DELETE FROM lang\").rowcount, "
"\"rows\")\n"
"\n"
"# close() is not a shortcut method and it's not called automatically;\n"
"# the connection object should be closed manually\n"
"con.close()"

#: ../../library/sqlite3.rst:2402
msgid "How to use the connection context manager"
msgstr "Как использовать менеджер контекста соединения"

#: ../../library/sqlite3.rst:2404
msgid ""
"A :class:`Connection` object can be used as a context manager that "
"automatically commits or rolls back open transactions when leaving the body "
"of the context manager. If the body of the :keyword:`with` statement "
"finishes without exceptions, the transaction is committed. If this commit "
"fails, or if the body of the ``with`` statement raises an uncaught "
"exception, the transaction is rolled back. If :attr:`~Connection.autocommit` "
"is ``False``, a new transaction is implicitly opened after committing or "
"rolling back."
msgstr ""
"Объект :class:`Connection` можно использовать в качестве контекстного "
"менеджера, который автоматически фиксирует или откатывает открытые "
"транзакции при выходе из тела контекстного менеджера. Если тело оператора :"
"keyword:`with` завершается без исключений, транзакция фиксируется. Если эта "
"фиксация не удалась или если тело оператора ``with`` вызывает "
"неперехваченное исключение, транзакция откатывается. Если :attr:`~Connection."
"autocommit` имеет значение ``False``, новая транзакция неявно открывается "
"после фиксации или отката."

#: ../../library/sqlite3.rst:2415
msgid ""
"If there is no open transaction upon leaving the body of the ``with`` "
"statement, or if :attr:`~Connection.autocommit` is ``True``, the context "
"manager does nothing."
msgstr ""
"Если после выхода из тела оператора ``with`` нет открытой транзакции или "
"если :attr:`~Connection.autocommit` имеет значение ``True``, контекстный "
"менеджер ничего не делает."

#: ../../library/sqlite3.rst:2420
msgid ""
"The context manager neither implicitly opens a new transaction nor closes "
"the connection. If you need a closing context manager, consider using :meth:"
"`contextlib.closing`."
msgstr ""
"Менеджер контекста не открывает новую транзакцию неявно и не закрывает "
"соединение. Если вам нужен менеджер закрывающего контекста, рассмотрите "
"возможность использования :meth:`contextlib.closing`."

#: ../../library/sqlite3.rst:2424
msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lang(id INTEGER PRIMARY KEY, name VARCHAR "
"UNIQUE)\")\n"
"\n"
"# Successful, con.commit() is called automatically afterwards\n"
"with con:\n"
"    con.execute(\"INSERT INTO lang(name) VALUES(?)\", (\"Python\",))\n"
"\n"
"# con.rollback() is called after the with block finishes with an exception,\n"
"# the exception is still raised and must be caught\n"
"try:\n"
"    with con:\n"
"        con.execute(\"INSERT INTO lang(name) VALUES(?)\", (\"Python\",))\n"
"except sqlite3.IntegrityError:\n"
"    print(\"couldn't add Python twice\")\n"
"\n"
"# Connection object used as context manager only commits or rollbacks "
"transactions,\n"
"# so the connection object should be closed manually\n"
"con.close()"
msgstr ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lang(id INTEGER PRIMARY KEY, name VARCHAR "
"UNIQUE)\")\n"
"\n"
"# Successful, con.commit() is called automatically afterwards\n"
"with con:\n"
"    con.execute(\"INSERT INTO lang(name) VALUES(?)\", (\"Python\",))\n"
"\n"
"# con.rollback() is called after the with block finishes with an exception,\n"
"# the exception is still raised and must be caught\n"
"try:\n"
"    with con:\n"
"        con.execute(\"INSERT INTO lang(name) VALUES(?)\", (\"Python\",))\n"
"except sqlite3.IntegrityError:\n"
"    print(\"couldn't add Python twice\")\n"
"\n"
"# Connection object used as context manager only commits or rollbacks "
"transactions,\n"
"# so the connection object should be closed manually\n"
"con.close()"

#: ../../library/sqlite3.rst:2454
msgid "How to work with SQLite URIs"
msgstr "Как работать с URI SQLite"

#: ../../library/sqlite3.rst:2456
msgid "Some useful URI tricks include:"
msgstr "Некоторые полезные приемы URI включают в себя:"

#: ../../library/sqlite3.rst:2458
msgid "Open a database in read-only mode:"
msgstr "Откройте базу данных в режиме только для чтения:"

#: ../../library/sqlite3.rst:2460
msgid ""
">>> con = sqlite3.connect(\"file:tutorial.db?mode=ro\", uri=True)\n"
">>> con.execute(\"CREATE TABLE readonly(data)\")\n"
"Traceback (most recent call last):\n"
"OperationalError: attempt to write a readonly database\n"
">>> con.close()"
msgstr ""
">>> con = sqlite3.connect(\"file:tutorial.db?mode=ro\", uri=True)\n"
">>> con.execute(\"CREATE TABLE readonly(data)\")\n"
"Traceback (most recent call last):\n"
"OperationalError: attempt to write a readonly database\n"
">>> con.close()"

#: ../../library/sqlite3.rst:2468
msgid ""
"Do not implicitly create a new database file if it does not already exist; "
"will raise :exc:`~sqlite3.OperationalError` if unable to create a new file:"
msgstr ""
"Не создавайте неявно новый файл базы данных, если он еще не существует; "
"вызовет :exc:`~sqlite3.OperationalError`, если не удастся создать новый файл:"

#: ../../library/sqlite3.rst:2471
msgid ""
">>> con = sqlite3.connect(\"file:nosuchdb.db?mode=rw\", uri=True)\n"
"Traceback (most recent call last):\n"
"OperationalError: unable to open database file"
msgstr ""
">>> con = sqlite3.connect(\"file:nosuchdb.db?mode=rw\", uri=True)\n"
"Traceback (most recent call last):\n"
"OperationalError: unable to open database file"

#: ../../library/sqlite3.rst:2478
msgid "Create a shared named in-memory database:"
msgstr "Создайте общую именованную базу данных в памяти:"

#: ../../library/sqlite3.rst:2480
msgid ""
"db = \"file:mem1?mode=memory&cache=shared\"\n"
"con1 = sqlite3.connect(db, uri=True)\n"
"con2 = sqlite3.connect(db, uri=True)\n"
"with con1:\n"
"    con1.execute(\"CREATE TABLE shared(data)\")\n"
"    con1.execute(\"INSERT INTO shared VALUES(28)\")\n"
"res = con2.execute(\"SELECT data FROM shared\")\n"
"assert res.fetchone() == (28,)\n"
"\n"
"con1.close()\n"
"con2.close()"
msgstr ""
"db = \"file:mem1?mode=memory&cache=shared\"\n"
"con1 = sqlite3.connect(db, uri=True)\n"
"con2 = sqlite3.connect(db, uri=True)\n"
"with con1:\n"
"    con1.execute(\"CREATE TABLE shared(data)\")\n"
"    con1.execute(\"INSERT INTO shared VALUES(28)\")\n"
"res = con2.execute(\"SELECT data FROM shared\")\n"
"assert res.fetchone() == (28,)\n"
"\n"
"con1.close()\n"
"con2.close()"

#: ../../library/sqlite3.rst:2494
msgid ""
"More information about this feature, including a list of parameters, can be "
"found in the `SQLite URI documentation`_."
msgstr ""
"Дополнительную информацию об этой функции, включая список параметров, можно "
"найти в `документации по URI SQLite`_."

#: ../../library/sqlite3.rst:2503
msgid "How to create and use row factories"
msgstr "Как создавать и использовать фабрики строк"

#: ../../library/sqlite3.rst:2505
msgid ""
"By default, :mod:`!sqlite3` represents each row as a :class:`tuple`. If a :"
"class:`!tuple` does not suit your needs, you can use the :class:`sqlite3."
"Row` class or a custom :attr:`~Cursor.row_factory`."
msgstr ""
"По умолчанию :mod:`!sqlite3` представляет каждую строку как :class:`tuple`. "
"Если :class:`!tuple` не соответствует вашим потребностям, вы можете "
"использовать класс :class:`sqlite3.Row` или собственный :attr:`~Cursor."
"row_factory`."

#: ../../library/sqlite3.rst:2510
msgid ""
"While :attr:`!row_factory` exists as an attribute both on the :class:"
"`Cursor` and the :class:`Connection`, it is recommended to set :class:"
"`Connection.row_factory`, so all cursors created from the connection will "
"use the same row factory."
msgstr ""
"Хотя :attr:`!row_factory` существует как атрибут как в :class:`Cursor`, так "
"и в :class:`Connection`, рекомендуется установить :class:`Connection."
"row_factory`, чтобы все курсоры, созданные из соединение будет использовать "
"ту же фабрику строк."

#: ../../library/sqlite3.rst:2515
msgid ""
":class:`!Row` provides indexed and case-insensitive named access to columns, "
"with minimal memory overhead and performance impact over a :class:`!tuple`. "
"To use :class:`!Row` as a row factory, assign it to the :attr:`!row_factory` "
"attribute:"
msgstr ""
":class:`!Row` обеспечивает индексированный и нечувствительный к регистру "
"именованный доступ к столбцам с минимальными затратами памяти и влиянием на "
"производительность по сравнению с :class:`!tuple`. Чтобы использовать :class:"
"`!Row` в качестве фабрики строк, назначьте его атрибуту :attr:`!row_factory`:"

#: ../../library/sqlite3.rst:2520
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = sqlite3.Row"
msgstr ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = sqlite3.Row"

#: ../../library/sqlite3.rst:2525
msgid "Queries now return :class:`!Row` objects:"
msgstr "Запросы теперь возвращают объекты :class:`!Row`:"

#: ../../library/sqlite3.rst:2527
msgid ""
">>> res = con.execute(\"SELECT 'Earth' AS name, 6378 AS radius\")\n"
">>> row = res.fetchone()\n"
">>> row.keys()\n"
"['name', 'radius']\n"
">>> row[0]         # Access by index.\n"
"'Earth'\n"
">>> row[\"name\"]    # Access by name.\n"
"'Earth'\n"
">>> row[\"RADIUS\"]  # Column names are case-insensitive.\n"
"6378\n"
">>> con.close()"
msgstr ""
">>> res = con.execute(\"SELECT 'Earth' AS name, 6378 AS radius\")\n"
">>> row = res.fetchone()\n"
">>> row.keys()\n"
"['name', 'radius']\n"
">>> row[0]         # Access by index.\n"
"'Earth'\n"
">>> row[\"name\"]    # Access by name.\n"
"'Earth'\n"
">>> row[\"RADIUS\"]  # Column names are case-insensitive.\n"
"6378\n"
">>> con.close()"

#: ../../library/sqlite3.rst:2543
msgid ""
"The ``FROM`` clause can be omitted in the ``SELECT`` statement, as in the "
"above example. In such cases, SQLite returns a single row with columns "
"defined by expressions, e.g. literals, with the given aliases ``expr AS "
"alias``."
msgstr ""
"Предложение FROM может быть опущено в операторе SELECT, как в приведенном "
"выше примере. В таких случаях SQLite возвращает одну строку со столбцами, "
"определенными выражениями, например литералами, с заданными псевдонимами "
"``expr AS alias``."

#: ../../library/sqlite3.rst:2548
msgid ""
"You can create a custom :attr:`~Cursor.row_factory` that returns each row as "
"a :class:`dict`, with column names mapped to values:"
msgstr ""
"Вы можете создать собственный :attr:`~Cursor.row_factory`, который "
"возвращает каждую строку как :class:`dict`, с именами столбцов, "
"сопоставленными со значениями:"

#: ../../library/sqlite3.rst:2551
msgid ""
"def dict_factory(cursor, row):\n"
"    fields = [column[0] for column in cursor.description]\n"
"    return {key: value for key, value in zip(fields, row)}"
msgstr ""
"def dict_factory(cursor, row):\n"
"    fields = [column[0] for column in cursor.description]\n"
"    return {key: value for key, value in zip(fields, row)}"

#: ../../library/sqlite3.rst:2557
msgid ""
"Using it, queries now return a :class:`!dict` instead of a :class:`!tuple`:"
msgstr ""
"Используя его, запросы теперь возвращают :class:`!dict` вместо :class:`!"
"tuple`:"

#: ../../library/sqlite3.rst:2559
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = dict_factory\n"
">>> for row in con.execute(\"SELECT 1 AS a, 2 AS b\"):\n"
"...     print(row)\n"
"{'a': 1, 'b': 2}\n"
">>> con.close()"
msgstr ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = dict_factory\n"
">>> for row in con.execute(\"SELECT 1 AS a, 2 AS b\"):\n"
"...     print(row)\n"
"{'a': 1, 'b': 2}\n"
">>> con.close()"

#: ../../library/sqlite3.rst:2568
msgid "The following row factory returns a :term:`named tuple`:"
msgstr "Следующая фабрика строк возвращает именованный кортеж:"

#: ../../library/sqlite3.rst:2570
msgid ""
"from collections import namedtuple\n"
"\n"
"def namedtuple_factory(cursor, row):\n"
"    fields = [column[0] for column in cursor.description]\n"
"    cls = namedtuple(\"Row\", fields)\n"
"    return cls._make(row)"
msgstr ""
"from collections import namedtuple\n"
"\n"
"def namedtuple_factory(cursor, row):\n"
"    fields = [column[0] for column in cursor.description]\n"
"    cls = namedtuple(\"Row\", fields)\n"
"    return cls._make(row)"

#: ../../library/sqlite3.rst:2579
msgid ":func:`!namedtuple_factory` can be used as follows:"
msgstr ":func:`!namedtuple_factory` можно использовать следующим образом:"

#: ../../library/sqlite3.rst:2581
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = namedtuple_factory\n"
">>> cur = con.execute(\"SELECT 1 AS a, 2 AS b\")\n"
">>> row = cur.fetchone()\n"
">>> row\n"
"Row(a=1, b=2)\n"
">>> row[0]  # Indexed access.\n"
"1\n"
">>> row.b   # Attribute access.\n"
"2\n"
">>> con.close()"
msgstr ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = namedtuple_factory\n"
">>> cur = con.execute(\"SELECT 1 AS a, 2 AS b\")\n"
">>> row = cur.fetchone()\n"
">>> row\n"
"Row(a=1, b=2)\n"
">>> row[0]  # Indexed access.\n"
"1\n"
">>> row.b   # Attribute access.\n"
"2\n"
">>> con.close()"

#: ../../library/sqlite3.rst:2595
msgid ""
"With some adjustments, the above recipe can be adapted to use a :class:"
"`~dataclasses.dataclass`, or any other custom class, instead of a :class:"
"`~collections.namedtuple`."
msgstr ""
"С некоторыми изменениями приведенный выше рецепт можно адаптировать для "
"использования :class:`~dataclasses.dataclass` или любого другого "
"пользовательского класса вместо :class:`~collections.namedtuple`."

#: ../../library/sqlite3.rst:2603
msgid "How to handle non-UTF-8 text encodings"
msgstr "Как обрабатывать текстовые кодировки, отличные от UTF-8"

#: ../../library/sqlite3.rst:2605
msgid ""
"By default, :mod:`!sqlite3` uses :class:`str` to adapt SQLite values with "
"the ``TEXT`` data type. This works well for UTF-8 encoded text, but it might "
"fail for other encodings and invalid UTF-8. You can use a custom :attr:"
"`~Connection.text_factory` to handle such cases."
msgstr ""
"По умолчанию :mod:`!sqlite3` использует :class:`str` для адаптации значений "
"SQLite к типу данных ``TEXT``. Это хорошо работает для текста в кодировке "
"UTF-8, но может не работать для других кодировок и недопустимого UTF-8. Для "
"обработки таких случаев вы можете использовать собственный :attr:"
"`~Connection.text_factory`."

#: ../../library/sqlite3.rst:2611
msgid ""
"Because of SQLite's `flexible typing`_, it is not uncommon to encounter "
"table columns with the ``TEXT`` data type containing non-UTF-8 encodings, or "
"even arbitrary data. To demonstrate, let's assume we have a database with "
"ISO-8859-2 (Latin-2) encoded text, for example a table of Czech-English "
"dictionary entries. Assuming we now have a :class:`Connection` instance :py:"
"data:`!con` connected to this database, we can decode the Latin-2 encoded "
"text using this :attr:`~Connection.text_factory`:"
msgstr ""
"Благодаря «гибкой типизации» SQLite нередко можно встретить столбцы таблицы "
"с типом данных «ТЕКСТ», содержащими кодировки, отличные от UTF-8, или даже "
"произвольные данные. Для демонстрации предположим, что у нас есть база "
"данных с текстом в кодировке ISO-8859-2 (Latin-2), например таблица статей "
"чешско-английского словаря. Предполагая, что теперь у нас есть экземпляр :"
"class:`Connection` :py:data:`!con`, подключенный к этой базе данных, мы "
"можем декодировать текст в кодировке Latin-2, используя этот :attr:"
"`~Connection.text_factory`:"

#: ../../library/sqlite3.rst:2620
msgid "con.text_factory = lambda data: str(data, encoding=\"latin2\")"
msgstr "con.text_factory = lambda data: str(data, encoding=\"latin2\")"

#: ../../library/sqlite3.rst:2624
msgid ""
"For invalid UTF-8 or arbitrary data in stored in ``TEXT`` table columns, you "
"can use the following technique, borrowed from the :ref:`unicode-howto`:"
msgstr ""
"Для недопустимых UTF-8 или произвольных данных, хранящихся в столбцах "
"таблицы ``TEXT``, вы можете использовать следующий метод, заимствованный из :"
"ref:`unicode-howto`:"

#: ../../library/sqlite3.rst:2627
msgid "con.text_factory = lambda data: str(data, errors=\"surrogateescape\")"
msgstr "con.text_factory = lambda data: str(data, errors=\"surrogateescape\")"

#: ../../library/sqlite3.rst:2633
msgid ""
"The :mod:`!sqlite3` module API does not support strings containing "
"surrogates."
msgstr ""
"API модуля :mod:`!sqlite3` не поддерживает строки, содержащие суррогаты."

#: ../../library/sqlite3.rst:2638
msgid ":ref:`unicode-howto`"
msgstr ":ref:`unicode-howto`"

#: ../../library/sqlite3.rst:2644
msgid "Explanation"
msgstr "Explicação"

#: ../../library/sqlite3.rst:2650
msgid "Transaction control"
msgstr "Controle de transações"

#: ../../library/sqlite3.rst:2652
msgid ""
":mod:`!sqlite3` offers multiple methods of controlling whether, when and how "
"database transactions are opened and closed. :ref:`sqlite3-transaction-"
"control-autocommit` is recommended, while :ref:`sqlite3-transaction-control-"
"isolation-level` retains the pre-Python 3.12 behaviour."
msgstr ""
":mod:`!sqlite3` oferece vários métodos para controlar se, quando e como as "
"transações do banco de dados são abertas e fechadas. :ref:`sqlite3-"
"transaction-control-autocommit` é recomendado, enquanto :ref:`sqlite3-"
"transaction-control-isolation-level` mantém o comportamento pré-Python 3.12."

#: ../../library/sqlite3.rst:2661
msgid "Transaction control via the ``autocommit`` attribute"
msgstr "Controle de transações através do atributo ``autocommit``"

#: ../../library/sqlite3.rst:2663
msgid ""
"The recommended way of controlling transaction behaviour is through the :"
"attr:`Connection.autocommit` attribute, which should preferably be set using "
"the *autocommit* parameter of :func:`connect`."
msgstr ""
"A forma recomendada de controlar o comportamento da transação é através do "
"atributo :attr:`Connection.autocommit`, que deve ser preferencialmente "
"definido usando o parâmetro *autocommit* de :func:`connect`."

#: ../../library/sqlite3.rst:2668
msgid ""
"It is suggested to set *autocommit* to ``False``, which implies :pep:`249`-"
"compliant transaction control. This means:"
msgstr ""
"É sugerido definir *autocommit* como ``False``, o que implica controle de "
"transação compatível com a :pep:`249`. Isso significa:"

#: ../../library/sqlite3.rst:2672
msgid ""
":mod:`!sqlite3` ensures that a transaction is always open, so :func:"
"`connect`, :meth:`Connection.commit`, and :meth:`Connection.rollback` will "
"implicitly open a new transaction (immediately after closing the pending "
"one, for the latter two). :mod:`!sqlite3` uses ``BEGIN DEFERRED`` statements "
"when opening transactions."
msgstr ""
":mod:`!sqlite3` garante que uma transação esteja sempre aberta, então :func:"
"`connect`, :meth:`Connection.commit` e :meth:`Connection.rollback` abrirão "
"implicitamente uma nova transação (imediatamente após fechando a pendência, "
"para as duas últimas). :mod:`!sqlite3` usa instruções ``BEGIN DEFERRED`` ao "
"abrir transações."

#: ../../library/sqlite3.rst:2677
msgid "Transactions should be committed explicitly using :meth:`!commit`."
msgstr "Transações devem ser executadas explicitamente usando :meth:`!commit`."

#: ../../library/sqlite3.rst:2678
msgid "Transactions should be rolled back explicitly using :meth:`!rollback`."
msgstr ""
"Transações devem ser revertidas explicitamente usando :meth:`!rollback`."

#: ../../library/sqlite3.rst:2679
msgid ""
"An implicit rollback is performed if the database is :meth:`~Connection."
"close`-ed with pending changes."
msgstr ""
"Uma reversão implícita é executada se o banco de dados estiver em estado :"
"meth:`~Connection.close` com alterações pendentes."

#: ../../library/sqlite3.rst:2682
msgid ""
"Set *autocommit* to ``True`` to enable SQLite's `autocommit mode`_. In this "
"mode, :meth:`Connection.commit` and :meth:`Connection.rollback` have no "
"effect. Note that SQLite's autocommit mode is distinct from the :pep:`249`-"
"compliant :attr:`Connection.autocommit` attribute; use :attr:`Connection."
"in_transaction` to query the low-level SQLite autocommit mode."
msgstr ""
"Defina *autocommit* como ``True`` para ativar o `modo autocommit`_ do "
"SQLite. Neste modo, :meth:`Connection.commit` e :meth:`Connection.rollback` "
"não têm efeito. Observe que o modo autocommit do SQLite é distinto do "
"atributo :attr:`Connection.autocommit` compatível com :pep:`249`; use :attr:"
"`Connection.in_transaction` para consultar o modo de confirmação automática "
"do SQLite de baixo nível."

#: ../../library/sqlite3.rst:2690
msgid ""
"Set *autocommit* to :data:`LEGACY_TRANSACTION_CONTROL` to leave transaction "
"control behaviour to the :attr:`Connection.isolation_level` attribute. See :"
"ref:`sqlite3-transaction-control-isolation-level` for more information."
msgstr ""
"Defina *autocommit* como :data:`LEGACY_TRANSACTION_CONTROL` para deixar o "
"comportamento de controle de transação para o atributo :attr:`Connection."
"isolation_level`. Veja :ref:`sqlite3-transaction-control-isolation-level` "
"para mais informações."

#: ../../library/sqlite3.rst:2699
msgid "Transaction control via the ``isolation_level`` attribute"
msgstr "Controle de transação através do atributo ``isolation_level``"

#: ../../library/sqlite3.rst:2703
msgid ""
"The recommended way of controlling transactions is via the :attr:"
"`~Connection.autocommit` attribute. See :ref:`sqlite3-transaction-control-"
"autocommit`."
msgstr ""
"A forma recomendada de controlar transações é através do atributo :attr:"
"`~Connection.autocommit`. Veja :ref:`sqlite3-transaction-control-autocommit`."

#: ../../library/sqlite3.rst:2707
msgid ""
"If :attr:`Connection.autocommit` is set to :data:"
"`LEGACY_TRANSACTION_CONTROL` (the default), transaction behaviour is "
"controlled using the :attr:`Connection.isolation_level` attribute. "
"Otherwise, :attr:`!isolation_level` has no effect."
msgstr ""
"Se :attr:`Connection.autocommit` estiver definido como :data:"
"`LEGACY_TRANSACTION_CONTROL` (o padrão), o comportamento da transação é "
"controlado usando o atributo :attr:`Connection.isolation_level`. Caso "
"contrário, :attr:`!isolation_level` não tem efeito."

#: ../../library/sqlite3.rst:2713
msgid ""
"If the connection attribute :attr:`~Connection.isolation_level` is not "
"``None``, new transactions are implicitly opened before :meth:`~Cursor."
"execute` and :meth:`~Cursor.executemany` executes ``INSERT``, ``UPDATE``, "
"``DELETE``, or ``REPLACE`` statements; for other statements, no implicit "
"transaction handling is performed. Use the :meth:`~Connection.commit` and :"
"meth:`~Connection.rollback` methods to respectively commit and roll back "
"pending transactions. You can choose the underlying `SQLite transaction "
"behaviour`_ — that is, whether and what type of ``BEGIN`` statements :mod:`!"
"sqlite3` implicitly executes – via the :attr:`~Connection.isolation_level` "
"attribute."
msgstr ""
"Se o atributo de conexão :attr:`~Connection.isolation_level` não for "
"``None``, novas transações são abertas implicitamente antes de :meth:"
"`~Cursor.execute` e :meth:`~Cursor.executemany` executa instruções "
"``INSERT``, ``UPDATE``, ``DELETE`` ou ``REPLACE``; para outras instruções, "
"nenhuma manipulação de transação implícita é executada. Use os métodos :meth:"
"`~Connection.commit` e :meth:`~Connection.rollback` para fazer commit e "
"reverter respectivamente transações pendentes. Você pode escolher o "
"`comportamento subjacente de transação do SQLite`_ -- isto é, se e que tipo "
"de instruções ``BEGIN`` do :mod:`!sqlite3` são executadas implicitamente -- "
"através do atributo :attr:`~Connection.isolation_level`."

#: ../../library/sqlite3.rst:2726
msgid ""
"If :attr:`~Connection.isolation_level` is set to ``None``, no transactions "
"are implicitly opened at all. This leaves the underlying SQLite library in "
"`autocommit mode`_, but also allows the user to perform their own "
"transaction handling using explicit SQL statements. The underlying SQLite "
"library autocommit mode can be queried using the :attr:`~Connection."
"in_transaction` attribute."
msgstr ""
"Se :attr:`~Connection.isolation_level` estiver definido como ``None``, "
"nenhuma transação será aberta implicitamente. Isso deixa a biblioteca SQLite "
"subjacente no `modo autocommit`_, mas também permite que o usuário execute "
"sua própria manipulação de transações usando instruções SQL explícitas. O "
"modo de autocommit da biblioteca SQLite subjacente pode ser consultado "
"usando o atributo :attr:`~Connection.in_transaction`."

#: ../../library/sqlite3.rst:2734
msgid ""
"The :meth:`~Cursor.executescript` method implicitly commits any pending "
"transaction before execution of the given SQL script, regardless of the "
"value of :attr:`~Connection.isolation_level`."
msgstr ""
"O método :meth:`~Cursor.executescript` compromete implicitamente qualquer "
"transação pendente antes da execução do script SQL fornecido, "
"independentemente do valor de :attr:`~Connection.isolation_level`."

#: ../../library/sqlite3.rst:2738
msgid ""
":mod:`!sqlite3` used to implicitly commit an open transaction before DDL "
"statements.  This is no longer the case."
msgstr ""
":mod:`!sqlite3` costumava fazer commit de forma implícita de uma transação "
"aberta antes das instruções DDL. Este não é mais o caso."

#: ../../library/sqlite3.rst:2742
msgid ""
"The recommended way of controlling transactions is now via the :attr:"
"`~Connection.autocommit` attribute."
msgstr ""
"A forma recomendada de controlar transações agora é através do atributo :"
"attr:`~Connection.autocommit`."

#: ../../library/sqlite3.rst:1493
msgid "? (question mark)"
msgstr "? (interrogação)"

#: ../../library/sqlite3.rst:1493 ../../library/sqlite3.rst:1494
msgid "in SQL statements"
msgstr "em instruções SQL"

#: ../../library/sqlite3.rst:1494
msgid ": (colon)"
msgstr ": (dois pontos)"

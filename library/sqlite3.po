# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 16:41+0000\n"
"PO-Revision-Date: 2023-05-24 02:19+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/sqlite3.rst:2
msgid ":mod:`sqlite3` --- DB-API 2.0 interface for SQLite databases"
msgstr ":mod:`sqlite3` --- Interface DB-API 2.0 para bancos de dados SQLite"

#: ../../library/sqlite3.rst:9
msgid "**Source code:** :source:`Lib/sqlite3/`"
msgstr "**Código-fonte:** :source:`Lib/sqlite3/`"

#: ../../library/sqlite3.rst:23
msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can "
"use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as "
"PostgreSQL or Oracle."
msgstr ""
"SQLite é uma biblioteca C que fornece um banco de dados leve baseado em "
"disco que não requer um processo de servidor separado e permite acessar o "
"banco de dados usando uma variante não padrão da linguagem de consulta SQL. "
"Algumas aplicações podem usar SQLite para armazenamento interno de dados. "
"Também é possível prototipar um aplicativo usando SQLite e, em seguida, "
"portar o código para um banco de dados maior, como PostgreSQL ou Oracle."

#: ../../library/sqlite3.rst:30
msgid ""
"The :mod:`!sqlite3` module was written by Gerhard Häring.  It provides an "
"SQL interface compliant with the DB-API 2.0 specification described by :pep:"
"`249`, and requires SQLite 3.7.15 or newer."
msgstr ""

#: ../../library/sqlite3.rst:34
msgid "This document includes four main sections:"
msgstr "Esse documento inclui quatro seções principais:"

#: ../../library/sqlite3.rst:36
msgid ":ref:`sqlite3-tutorial` teaches how to use the :mod:`!sqlite3` module."
msgstr ":ref:`sqlite3-tutorial` ensina como usar o módulo :mod:`!sqlite3`."

#: ../../library/sqlite3.rst:37
msgid ""
":ref:`sqlite3-reference` describes the classes and functions this module "
"defines."
msgstr ""
":ref:`sqlite3-reference` descreve as classes e funções que este módulo "
"define."

#: ../../library/sqlite3.rst:39
msgid ":ref:`sqlite3-howtos` details how to handle specific tasks."
msgstr ":ref:`sqlite3-howtos` detalha como lidar com tarefas específicas."

#: ../../library/sqlite3.rst:40
msgid ""
":ref:`sqlite3-explanation` provides in-depth background on transaction "
"control."
msgstr ""
":ref:`sqlite3-explanation` fornece informações detalhadas sobre controle de "
"transações."

#: ../../library/sqlite3.rst:47
msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

#: ../../library/sqlite3.rst:46
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr ""
"A página web do SQLite; a documentação descreve a sintaxe e os tipos de "
"dados disponíveis para o dialeto SQL suportado."

#: ../../library/sqlite3.rst:50
msgid "https://www.w3schools.com/sql/"
msgstr "https://www.w3schools.com/sql/"

#: ../../library/sqlite3.rst:50
msgid "Tutorial, reference and examples for learning SQL syntax."
msgstr "Tutoriais, referências e exemplos para aprender a sintaxe SQL."

#: ../../library/sqlite3.rst:52
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - Especificação 2.0 da API de banco de dados"

#: ../../library/sqlite3.rst:53
msgid "PEP written by Marc-André Lemburg."
msgstr "PEP escrita por Marc-André Lemburg."

#: ../../library/sqlite3.rst:66
msgid "Tutorial"
msgstr "Tutorial"

#: ../../library/sqlite3.rst:68
msgid ""
"In this tutorial, you will create a database of Monty Python movies using "
"basic :mod:`!sqlite3` functionality. It assumes a fundamental understanding "
"of database concepts, including `cursors`_ and `transactions`_."
msgstr ""
"Neste tutorial, você criará um banco de dados de filmes do Monty Python "
"usando a funcionalidade básica :mod:`!sqlite3`. Ele pressupõe uma "
"compreensão fundamental dos conceitos de banco de dados, incluindo "
"`cursores`_ e `transações`_."

#: ../../library/sqlite3.rst:73
msgid ""
"First, we need to create a new database and open a database connection to "
"allow :mod:`!sqlite3` to work with it. Call :func:`sqlite3.connect` to "
"create a connection to the database :file:`tutorial.db` in the current "
"working directory, implicitly creating it if it does not exist:"
msgstr ""
"Primeiro, precisamos criar um novo banco de dados e abrir uma conexão com o "
"banco de dados para permitir que :mod:`!sqlite3` funcione com ele. Chame :"
"func:`sqlite3.connect` para criar uma conexão com o banco de dados :file:"
"`tutorial.db` no diretório de trabalho atual, criando-o implicitamente se "
"ele não existir:"

#: ../../library/sqlite3.rst:84
msgid ""
"The returned :class:`Connection` object ``con`` represents the connection to "
"the on-disk database."
msgstr ""
"O objeto :class:`Connection` ``con`` retornado representa a conexão com o "
"banco de dados em disco."

#: ../../library/sqlite3.rst:87
msgid ""
"In order to execute SQL statements and fetch results from SQL queries, we "
"will need to use a database cursor. Call :meth:`con.cursor() <Connection."
"cursor>` to create the :class:`Cursor`:"
msgstr ""
"Para executar instruções SQL e buscar resultados de consultas SQL, "
"precisaremos usar um cursor de banco de dados. Chame :meth:`con.cursor() "
"<Connection.cursor>` para criar o :class:`Cursor`:"

#: ../../library/sqlite3.rst:95
msgid ""
"Now that we've got a database connection and a cursor, we can create a "
"database table ``movie`` with columns for title, release year, and review "
"score. For simplicity, we can just use column names in the table declaration "
"-- thanks to the `flexible typing`_ feature of SQLite, specifying the data "
"types is optional. Execute the ``CREATE TABLE`` statement by calling :meth:"
"`cur.execute(...) <Cursor.execute>`:"
msgstr ""
"Agora que temos uma conexão com o banco de dados e um cursor, podemos criar "
"uma tabela de banco de dados ``movie`` com colunas para título, ano de "
"lançamento e pontuação da revisão. Para simplificar, podemos apenas usar "
"nomes de colunas na declaração da tabela - graças ao recurso `tipagem "
"flexível`_ do SQLite, especificar os tipos de dados é opcional. Execute a "
"instrução ``CREATE TABLE`` chamando :meth:`cur.execute(...) <Cursor."
"execute>`:"

#: ../../library/sqlite3.rst:111
msgid ""
"We can verify that the new table has been created by querying the "
"``sqlite_master`` table built-in to SQLite, which should now contain an "
"entry for the ``movie`` table definition (see `The Schema Table`_ for "
"details). Execute that query by calling :meth:`cur.execute(...) <Cursor."
"execute>`, assign the result to ``res``, and call :meth:`res.fetchone() "
"<Cursor.fetchone>` to fetch the resulting row:"
msgstr ""
"Podemos verificar se a nova tabela foi criada consultando a tabela embutida "
"``sqlite_master`` no SQLite, que agora deve conter uma entrada para a "
"definição da tabela ``movie`` (veja `The Schema Table`_ para detalhes). "
"Execute essa consulta chamando :meth:`cur.execute(...) <Cursor.execute>`, "
"atribua o resultado a ``res`` e chame :meth:`res.fetchone() <Cursor."
"fetchone>` para buscar a linha resultante:"

#: ../../library/sqlite3.rst:125
msgid ""
"We can see that the table has been created, as the query returns a :class:"
"`tuple` containing the table's name. If we query ``sqlite_master`` for a non-"
"existent table ``spam``, :meth:`!res.fetchone()` will return ``None``:"
msgstr ""
"Podemos ver que a tabela foi criada, pois a consulta retorna uma :class:"
"`tuple` contendo o nome da tabela. Se consultarmos ``sqlite_master`` por uma "
"tabela inexistente ``spam``, :meth:`!res.fetchone()` retornará ``None``:"

#: ../../library/sqlite3.rst:136
msgid ""
"Now, add two rows of data supplied as SQL literals by executing an "
"``INSERT`` statement, once again by calling :meth:`cur.execute(...) <Cursor."
"execute>`:"
msgstr ""
"Agora, adicione duas linhas de dados fornecidos como literais SQL executando "
"uma instrução ``INSERT``, mais uma vez chamando :meth:`cur.execute(...) "
"<Cursor.execute>`:"

#: ../../library/sqlite3.rst:148
msgid ""
"The ``INSERT`` statement implicitly opens a transaction, which needs to be "
"committed before changes are saved in the database (see :ref:`sqlite3-"
"controlling-transactions` for details). Call :meth:`con.commit() <Connection."
"commit>` on the connection object to commit the transaction:"
msgstr ""
"A instrução ``INSERT`` abre implicitamente uma transação, que precisa ser "
"confirmada antes que as alterações sejam salvas no banco de dados (veja :ref:"
"`sqlite3-controlling-transactions` para detalhes). Chame :meth:`con.commit() "
"<Connection.commit>` no objeto de conexão para confirmar a transação:"

#: ../../library/sqlite3.rst:158
msgid ""
"We can verify that the data was inserted correctly by executing a ``SELECT`` "
"query. Use the now-familiar :meth:`cur.execute(...) <Cursor.execute>` to "
"assign the result to ``res``, and call :meth:`res.fetchall() <Cursor."
"fetchall>` to return all resulting rows:"
msgstr ""
"Podemos verificar que os dados foram inseridos corretamente executando uma "
"consulta ``SELECT``. Use o já conhecido :meth:`cur.execute(...) <Cursor."
"execute>` para atribuir o resultado a ``res`` e chame :meth:`res.fetchall() "
"<Cursor.fetchall>` para retornar todas as linhas resultantes."

#: ../../library/sqlite3.rst:170
msgid ""
"The result is a :class:`list` of two :class:`!tuple`\\s, one per row, each "
"containing that row's ``score`` value."
msgstr ""
"O resultado é uma :class:`list` de duas :class:`!tuple`\\s, uma por linha, "
"cada uma contendo o valor ``score`` dessa linha."

#: ../../library/sqlite3.rst:173
msgid ""
"Now, insert three more rows by calling :meth:`cur.executemany(...) <Cursor."
"executemany>`:"
msgstr ""
"Agora, insira mais três linhas chamando :meth:`cur.executemany(...) <Cursor."
"executemany>`:"

#: ../../library/sqlite3.rst:186
msgid ""
"Notice that ``?`` placeholders are used to bind ``data`` to the query. "
"Always use placeholders instead of :ref:`string formatting <tut-formatting>` "
"to bind Python values to SQL statements, to avoid `SQL injection attacks`_ "
"(see :ref:`sqlite3-placeholders` for more details)."
msgstr ""
"Observe que espaços reservados ``?`` são usados para vincular ``data`` à "
"consulta. Sempre use espaços reservados em vez de :ref:`formatação de string "
"<tut-formatting>` para vincular valores Python a instruções SQL, para evitar "
"`ataques de injeção de SQL`_ (consulte :ref:`sqlite3-placeholders` para mais "
"detalhes)."

#: ../../library/sqlite3.rst:192
msgid ""
"We can verify that the new rows were inserted by executing a ``SELECT`` "
"query, this time iterating over the results of the query:"
msgstr ""
"Podemos verificar que as novas linhas foram inseridas executando uma "
"consulta ``SELECT``, desta vez iterando sobre os resultados da consulta."

#: ../../library/sqlite3.rst:206
msgid ""
"Each row is a two-item :class:`tuple` of ``(year, title)``, matching the "
"columns selected in the query."
msgstr ""
"Cada linha é uma :class:`tuple` de dois itens ``(year, title)``, "
"correspondendo às colunas selecionadas na consulta."

#: ../../library/sqlite3.rst:209
msgid ""
"Finally, verify that the database has been written to disk by calling :meth:"
"`con.close() <Connection.close>` to close the existing connection, opening a "
"new one, creating a new cursor, then querying the database:"
msgstr ""
"Finalmente, verifique se o banco de dados foi gravado no disco chamando :"
"meth:`con.close() <Connection.close>` para fechar a conexão existente, abrir "
"uma nova, criar um novo cursor e, em seguida, consultar o banco de dados."

#: ../../library/sqlite3.rst:224
msgid ""
"You've now created an SQLite database using the :mod:`!sqlite3` module, "
"inserted data and retrieved values from it in multiple ways."
msgstr ""
"Você agora criou um banco de dados SQLite usando o módulo :mod:`!sqlite3`, "
"inseriu dados e recuperou valores dele de várias maneiras."

#: ../../library/sqlite3.rst:236
msgid ":ref:`sqlite3-howtos` for further reading:"
msgstr ":ref:`sqlite3-howtos` para leitura adicional:"

#: ../../library/sqlite3.rst:238
msgid ":ref:`sqlite3-placeholders`"
msgstr ":ref:`sqlite3-placeholders`"

#: ../../library/sqlite3.rst:239
msgid ":ref:`sqlite3-adapters`"
msgstr ":ref:`sqlite3-adapters`"

#: ../../library/sqlite3.rst:240
msgid ":ref:`sqlite3-converters`"
msgstr ":ref:`sqlite3-converters`"

#: ../../library/sqlite3.rst:241 ../../library/sqlite3.rst:558
msgid ":ref:`sqlite3-connection-context-manager`"
msgstr ":ref:`sqlite3-connection-context-manager`"

#: ../../library/sqlite3.rst:242
msgid ":ref:`sqlite3-howto-row-factory`"
msgstr ":ref:`sqlite3-howto-row-factory`"

#: ../../library/sqlite3.rst:244
msgid ""
":ref:`sqlite3-explanation` for in-depth background on transaction control."
msgstr ""
":ref:`sqlite3-explanation` para obter informações detalhadas sobre o "
"controle de transações."

#: ../../library/sqlite3.rst:249
msgid "Reference"
msgstr "Referência"

#: ../../library/sqlite3.rst:257
msgid "Module functions"
msgstr "Funções do módulo"

#: ../../library/sqlite3.rst:264
msgid "Open a connection to an SQLite database."
msgstr "Abra uma conexão com um banco de dados SQLite."

#: ../../library/sqlite3.rst:0
msgid "Parameters"
msgstr "Parâmetros"

#: ../../library/sqlite3.rst:266
msgid ""
"The path to the database file to be opened. You can pass ``\":memory:\"`` to "
"create an `SQLite database existing only in memory <https://sqlite.org/"
"inmemorydb.html>`_, and open a connection to it."
msgstr ""
"O caminho para o arquivo do banco de dados a ser aberto. Você pode passar "
"``\":memory:\"`` para criar um banco de dados `SQLite que existirá apenas na "
"memória <https://sqlite.org/inmemorydb.html>`_, e abrir uma conexão com ele."

#: ../../library/sqlite3.rst:273
msgid ""
"How many seconds the connection should wait before raising an :exc:"
"`OperationalError` when a table is locked. If another connection opens a "
"transaction to modify a table, that table will be locked until the "
"transaction is committed. Default five seconds."
msgstr ""
"Quantos segundos a conexão deve aguardar antes de levantar uma exceção :exc:"
"`OperationalError` quando uma tabela estiver bloqueada. Se outra conexão "
"abrir uma transação para modificar uma tabela, essa tabela permanecerá "
"bloqueada até que a transação seja confirmada. O padrão é cinco segundos."

#: ../../library/sqlite3.rst:280
msgid ""
"Control whether and how data types not :ref:`natively supported by SQLite "
"<sqlite3-types>` are looked up to be converted to Python types, using the "
"converters registered with :func:`register_converter`. Set it to any "
"combination (using ``|``, bitwise or) of :const:`PARSE_DECLTYPES` and :const:"
"`PARSE_COLNAMES` to enable this. Column names takes precedence over declared "
"types if both flags are set. Types cannot be detected for generated fields "
"(for example ``max(data)``), even when the *detect_types* parameter is set; :"
"class:`str` will be returned instead. By default (``0``), type detection is "
"disabled."
msgstr ""

#: ../../library/sqlite3.rst:294
msgid ""
"The :attr:`~Connection.isolation_level` of the connection, controlling "
"whether and how transactions are implicitly opened. Can be ``\"DEFERRED\"`` "
"(default), ``\"EXCLUSIVE\"`` or ``\"IMMEDIATE\"``; or ``None`` to disable "
"opening transactions implicitly. See :ref:`sqlite3-controlling-transactions` "
"for more."
msgstr ""

#: ../../library/sqlite3.rst:302
msgid ""
"If ``True`` (default), :exc:`ProgrammingError` will be raised if the "
"database connection is used by a thread other than the one that created it. "
"If ``False``, the connection may be accessed in multiple threads; write "
"operations may need to be serialized by the user to avoid data corruption. "
"See :attr:`threadsafety` for more information."
msgstr ""
"Если ``True`` (по умолчанию), :exc:`ProgrammingError` будет вызвано, если "
"соединение с базой данных используется потоком, отличным от того, который "
"его создал. Если ``False``, доступ к соединению может осуществляться в "
"нескольких потоках; Операции записи могут потребоваться сериализовать "
"пользователю, чтобы избежать повреждения данных. См. :attr:`threadsafety` "
"для получения дополнительной информации."

#: ../../library/sqlite3.rst:311
msgid ""
"A custom subclass of :class:`Connection` to create the connection with, if "
"not the default :class:`Connection` class."
msgstr ""
"Пользовательский подкласс :class:`Connection` для создания соединения с "
"классом :class:`Connection` (если не с классом по умолчанию)."

#: ../../library/sqlite3.rst:315
msgid ""
"The number of statements that :mod:`!sqlite3` should internally cache for "
"this connection, to avoid parsing overhead. By default, 128 statements."
msgstr ""
"Число операторов, которые :mod:`!sqlite3` должен внутренне кэшировать для "
"этого соединения, чтобы избежать накладных расходов на анализ. По умолчанию "
"128 операторов."

#: ../../library/sqlite3.rst:320
msgid ""
"If set to ``True``, *database* is interpreted as a :abbr:`URI (Uniform "
"Resource Identifier)` with a file path and an optional query string. The "
"scheme part *must* be ``\"file:\"``, and the path can be relative or "
"absolute. The query string allows passing parameters to SQLite, enabling "
"various :ref:`sqlite3-uri-tricks`."
msgstr ""
"Если установлено значение True, *database* интерпретируется как :abbr:`URI "
"(универсальный идентификатор ресурса)` с путем к файлу и дополнительной "
"строкой запроса. Часть схемы *должна* быть ``\"file:\"``, а путь может быть "
"относительным или абсолютным. Строка запроса позволяет передавать параметры "
"в SQLite, используя различные трюки sqlite3-uri."

#: ../../library/sqlite3.rst:0
msgid "Return type"
msgstr "Тип возврата"

#: ../../library/sqlite3.rst:331
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect`` with argument "
"``database``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``sqlite3.connect`` com o "
"argumento ``database``."

#: ../../library/sqlite3.rst:332
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect/handle`` with "
"argument ``connection_handle``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``sqlite3.connect/handle`` "
"com o argumento ``connection_handle``."

#: ../../library/sqlite3.rst:334
msgid "Added the *uri* parameter."
msgstr "Adicionado o parâmetro *uri*."

#: ../../library/sqlite3.rst:337
msgid ""
"*database* can now also be a :term:`path-like object`, not only a string."
msgstr ""
"*database* тепер також може бути :term:`path-like object`, а не лише рядком."

#: ../../library/sqlite3.rst:340
msgid "Added the ``sqlite3.connect/handle`` auditing event."
msgstr "Додано подію аудиту ``sqlite3.connect/handle``."

#: ../../library/sqlite3.rst:345
msgid ""
"Return ``True`` if the string *statement* appears to contain one or more "
"complete SQL statements. No syntactic verification or parsing of any kind is "
"performed, other than checking that there are no unclosed string literals "
"and the statement is terminated by a semicolon."
msgstr ""
"Возвращайте ``True``, если строка *оператор* содержит один или несколько "
"полных операторов SQL. Никакая синтаксическая проверка или синтаксический "
"анализ не выполняется, кроме проверки отсутствия незамкнутых строковых "
"литералов и завершения оператора точкой с запятой."

#: ../../library/sqlite3.rst:351
msgid "For example:"
msgstr "Por exemplo:"

#: ../../library/sqlite3.rst:360
msgid ""
"This function may be useful during command-line input to determine if the "
"entered text seems to form a complete SQL statement, or if additional input "
"is needed before calling :meth:`~Cursor.execute`."
msgstr ""
"Эта функция может быть полезна во время ввода командной строки, чтобы "
"определить, образует ли введенный текст полный оператор SQL, или требуется "
"ли дополнительный ввод перед вызовом :meth:`~Cursor.execute`."

#: ../../library/sqlite3.rst:366
msgid ""
"Enable or disable callback tracebacks. By default you will not get any "
"tracebacks in user-defined functions, aggregates, converters, authorizer "
"callbacks etc. If you want to debug them, you can call this function with "
"*flag* set to ``True``. Afterwards, you will get tracebacks from callbacks "
"on :data:`sys.stderr`. Use ``False`` to disable the feature again."
msgstr ""
"Включите или отключите обратные трассировки обратного вызова. По умолчанию "
"вы не будете получать никаких обратных трассировок в пользовательских "
"функциях, агрегатах, конвертерах, обратных вызовах авторизатора и т. д. Если "
"вы хотите их отладить, вы можете вызвать эту функцию с *flag*, установленным "
"в ``True``. После этого вы получите обратные трассировки от обратных вызовов "
"в :data:`sys.stderr`. Используйте «False», чтобы снова отключить эту функцию."

#: ../../library/sqlite3.rst:373
msgid ""
"Register an :func:`unraisable hook handler <sys.unraisablehook>` for an "
"improved debug experience:"
msgstr ""

#: ../../library/sqlite3.rst:398
msgid ""
"Register an *adapter* :term:`callable` to adapt the Python type *type* into "
"an SQLite type. The adapter is called with a Python object of type *type* as "
"its sole argument, and must return a value of a :ref:`type that SQLite "
"natively understands <sqlite3-types>`."
msgstr ""
"Зарегистрируйте *адаптер* :term:`callable`, чтобы адаптировать тип *type* "
"Python к типу SQLite. Адаптер вызывается с объектом Python типа *type* в "
"качестве единственного аргумента и должен возвращать значение типа :ref:`, "
"который SQLite изначально понимает, <sqlite3-types>`."

#: ../../library/sqlite3.rst:406
msgid ""
"Register the *converter* :term:`callable` to convert SQLite objects of type "
"*typename* into a Python object of a specific type. The converter is invoked "
"for all SQLite values of type *typename*; it is passed a :class:`bytes` "
"object and should return an object of the desired Python type. Consult the "
"parameter *detect_types* of :func:`connect` for information regarding how "
"type detection works."
msgstr ""
"Зарегистрируйте *converter* :term:`callable` для преобразования объектов "
"SQLite типа *typename* в объект Python определенного типа. Конвертер "
"вызывается для всех значений SQLite типа *typename*; ему передается объект :"
"class:`bytes`, и он должен возвращать объект желаемого типа Python. "
"Обратитесь к параметру *detect_types* функции :func:`connect` для получения "
"информации о том, как работает определение типа."

#: ../../library/sqlite3.rst:414
msgid ""
"Note: *typename* and the name of the type in your query are matched case-"
"insensitively."
msgstr ""
"Примечание. *typename* и имя типа в вашем запросе сопоставляются без учета "
"регистра."

#: ../../library/sqlite3.rst:421
msgid "Module constants"
msgstr "Constantes do módulo"

#: ../../library/sqlite3.rst:425
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function by using the type name, parsed from the query "
"column name, as the converter dictionary key. The type name must be wrapped "
"in square brackets (``[]``)."
msgstr ""

#: ../../library/sqlite3.rst:435
msgid ""
"This flag may be combined with :const:`PARSE_DECLTYPES` using the ``|`` "
"(bitwise or) operator."
msgstr ""
"Этот флаг можно комбинировать с :const:`PARSE_DECLTYPES` с помощью оператора "
"``|`` (побитовое или)."

#: ../../library/sqlite3.rst:440
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function using the declared types for each column. The "
"types are declared when the database table is created. :mod:`!sqlite3` will "
"look up a converter function using the first word of the declared type as "
"the converter dictionary key. For example:"
msgstr ""
"Передайте значение этого флага в параметр *detect_types* функции :func:"
"`connect`, чтобы найти функцию конвертера, используя объявленные типы для "
"каждого столбца. Типы объявляются при создании таблицы базы данных. :mod:`!"
"sqlite3` будет искать функцию конвертера, используя первое слово "
"объявленного типа в качестве ключа словаря конвертера. Например:"

#: ../../library/sqlite3.rst:456
msgid ""
"This flag may be combined with :const:`PARSE_COLNAMES` using the ``|`` "
"(bitwise or) operator."
msgstr ""
"Этот флаг можно комбинировать с :const:`PARSE_COLNAMES` с помощью оператора "
"``|`` (побитовое или)."

#: ../../library/sqlite3.rst:463
msgid ""
"Flags that should be returned by the *authorizer_callback* :term:`callable` "
"passed to :meth:`Connection.set_authorizer`, to indicate whether:"
msgstr ""
"Флаги, которые должны быть возвращены *authorizer_callback* :term:"
"`callable`, переданным в :meth:`Connection.set_authorizer`, чтобы указать:"

#: ../../library/sqlite3.rst:466
msgid "Access is allowed (:const:`!SQLITE_OK`),"
msgstr "Доступ разрешен (:const:`!SQLITE_OK`),"

#: ../../library/sqlite3.rst:467
msgid ""
"The SQL statement should be aborted with an error (:const:`!SQLITE_DENY`)"
msgstr ""
"Выполнение оператора SQL должно быть прервано с ошибкой (:const:`!"
"SQLITE_DENY`)"

#: ../../library/sqlite3.rst:468
msgid ""
"The column should be treated as a ``NULL`` value (:const:`!SQLITE_IGNORE`)"
msgstr ""
"Столбец следует рассматривать как значение ``NULL`` (:const:`!"
"SQLITE_IGNORE`)."

#: ../../library/sqlite3.rst:472
msgid ""
"String constant stating the supported DB-API level. Required by the DB-API. "
"Hard-coded to ``\"2.0\"``."
msgstr ""
"Рядкова константа, що вказує підтримуваний рівень DB-API. Потрібний для DB-"
"API. Жорстко закодований на ``\"2.0\"``."

#: ../../library/sqlite3.rst:477
msgid ""
"String constant stating the type of parameter marker formatting expected by "
"the :mod:`!sqlite3` module. Required by the DB-API. Hard-coded to "
"``\"qmark\"``."
msgstr ""
"Строковая константа, указывающая тип форматирования маркера параметра, "
"ожидаемый модулем :mod:`!sqlite3`. Требуется для DB-API. Жестко "
"запрограммировано в ``\"qmark\"``."

#: ../../library/sqlite3.rst:483
msgid "The ``named`` DB-API parameter style is also supported."
msgstr "Также поддерживается стиль параметров DB-API ``named``."

#: ../../library/sqlite3.rst:487
msgid ""
"Version number of the runtime SQLite library as a :class:`string <str>`."
msgstr ""
"Номер версии библиотеки времени выполнения SQLite в виде :class:`string "
"<str>`."

#: ../../library/sqlite3.rst:491
msgid ""
"Version number of the runtime SQLite library as a :class:`tuple` of :class:"
"`integers <int>`."
msgstr ""
"Номер версии библиотеки времени выполнения SQLite в виде :class:`tuple` из :"
"class:`integers <int>`."

#: ../../library/sqlite3.rst:496
msgid ""
"Integer constant required by the DB-API 2.0, stating the level of thread "
"safety the :mod:`!sqlite3` module supports. This attribute is set based on "
"the default `threading mode <https://sqlite.org/threadsafe.html>`_ the "
"underlying SQLite library is compiled with. The SQLite threading modes are:"
msgstr ""
"Целочисленная константа, требуемая DB-API 2.0, указывающая уровень "
"потокобезопасности, поддерживаемый модулем :mod:`!sqlite3`. Этот атрибут "
"устанавливается на основе `поточного режима <https://sqlite.org/threadsafe."
"html>`_ по умолчанию, с которым скомпилирована базовая библиотека SQLite. "
"Режимы потоков SQLite:"

#: ../../library/sqlite3.rst:501
msgid ""
"**Single-thread**: In this mode, all mutexes are disabled and SQLite is "
"unsafe to use in more than a single thread at once."
msgstr ""
"**Однопоточный**: в этом режиме все мьютексы отключены, и SQLite небезопасно "
"использовать более чем в одном потоке одновременно."

#: ../../library/sqlite3.rst:503
msgid ""
"**Multi-thread**: In this mode, SQLite can be safely used by multiple "
"threads provided that no single database connection is used simultaneously "
"in two or more threads."
msgstr ""
"**Многопоточный**: в этом режиме SQLite можно безопасно использовать в "
"нескольких потоках при условии, что ни одно соединение с базой данных не "
"используется одновременно в двух или более потоках."

#: ../../library/sqlite3.rst:506
msgid ""
"**Serialized**: In serialized mode, SQLite can be safely used by multiple "
"threads with no restriction."
msgstr ""
"**Сериализация**: в сериализованном режиме SQLite может безопасно "
"использоваться несколькими потоками без ограничений."

#: ../../library/sqlite3.rst:509
msgid ""
"The mappings from SQLite threading modes to DB-API 2.0 threadsafety levels "
"are as follows:"
msgstr ""
"Сопоставления режимов потоков SQLite с уровнями безопасности потоков DB-API "
"2.0 следующие:"

#: ../../library/sqlite3.rst:513
msgid "SQLite threading mode"
msgstr "Режим потоков SQLite"

#: ../../library/sqlite3.rst:513
msgid "`threadsafety`_"
msgstr ""

#: ../../library/sqlite3.rst:513
msgid "`SQLITE_THREADSAFE`_"
msgstr "`SQLITE_THREADSAFE`_"

#: ../../library/sqlite3.rst:513
msgid "DB-API 2.0 meaning"
msgstr "Значение DB-API 2.0"

#: ../../library/sqlite3.rst:516
msgid "single-thread"
msgstr "однопоточный"

#: ../../library/sqlite3.rst:516
msgid "0"
msgstr "0"

#: ../../library/sqlite3.rst:516
msgid "Threads may not share the module"
msgstr "Потоки не могут совместно использовать модуль"

#: ../../library/sqlite3.rst:519
msgid "multi-thread"
msgstr "многопоточный"

#: ../../library/sqlite3.rst:519 ../../library/sqlite3.rst:522
msgid "1"
msgstr "1"

#: ../../library/sqlite3.rst:519
msgid "2"
msgstr "2"

#: ../../library/sqlite3.rst:519
msgid "Threads may share the module, but not connections"
msgstr "Потоки могут совместно использовать модуль, но не соединения."

#: ../../library/sqlite3.rst:522
msgid "serialized"
msgstr "сериализованный"

#: ../../library/sqlite3.rst:522
msgid "3"
msgstr "3"

#: ../../library/sqlite3.rst:522
msgid "Threads may share the module, connections and cursors"
msgstr "Потоки могут совместно использовать модуль, соединения и курсоры."

#: ../../library/sqlite3.rst:529
msgid "Set *threadsafety* dynamically instead of hard-coding it to ``1``."
msgstr ""
"Устанавливайте *threadsafety* динамически, а не жестко запрограммируйте его "
"на «1»."

#: ../../library/sqlite3.rst:534
msgid ""
"Version number of this module as a :class:`string <str>`. This is not the "
"version of the SQLite library."
msgstr ""

#: ../../library/sqlite3.rst:539
msgid ""
"Version number of this module as a :class:`tuple` of :class:`integers "
"<int>`. This is not the version of the SQLite library."
msgstr ""

#: ../../library/sqlite3.rst:546
msgid "Connection objects"
msgstr "Объекты подключения"

#: ../../library/sqlite3.rst:550
msgid ""
"Each open SQLite database is represented by a ``Connection`` object, which "
"is created using :func:`sqlite3.connect`. Their main purpose is creating :"
"class:`Cursor` objects, and :ref:`sqlite3-controlling-transactions`."
msgstr ""
"Каждая открытая база данных SQLite представлена ​​объектом Connection, который "
"создается с помощью :func:`sqlite3.connect`. Их основная цель — создание "
"объектов :class:`Cursor` и :ref:`sqlite3-controlling-transactions`."

#: ../../library/sqlite3.rst:557
msgid ":ref:`sqlite3-connection-shortcuts`"
msgstr ":ref:`sqlite3-connection-shortcuts`"

#: ../../library/sqlite3.rst:560
msgid "An SQLite database connection has the following attributes and methods:"
msgstr "Підключення до бази даних SQLite має такі атрибути та методи:"

#: ../../library/sqlite3.rst:564
msgid ""
"Create and return a :class:`Cursor` object. The cursor method accepts a "
"single optional parameter *factory*. If supplied, this must be a :term:"
"`callable` returning an instance of :class:`Cursor` or its subclasses."
msgstr ""
"Создайте и верните объект :class:`Cursor`. Метод курсора принимает один "
"необязательный параметр *factory*. Если указано, это должен быть :term:"
"`callable`, возвращающий экземпляр :class:`Cursor` или его подклассов."

#: ../../library/sqlite3.rst:571
msgid ""
"Open a :class:`Blob` handle to an existing :abbr:`BLOB (Binary Large "
"OBject)`."
msgstr ""
"Откройте дескриптор :class:`Blob` для существующего :abbr:`BLOB (большого "
"двоичного объекта)`."

#: ../../library/sqlite3.rst:574
msgid "The name of the table where the blob is located."
msgstr "Имя таблицы, в которой находится большой двоичный объект."

#: ../../library/sqlite3.rst:577
msgid "The name of the column where the blob is located."
msgstr "Имя столбца, в котором расположен большой двоичный объект."

#: ../../library/sqlite3.rst:580
msgid "The name of the row where the blob is located."
msgstr "Имя строки, в которой находится большой двоичный объект."

#: ../../library/sqlite3.rst:583
msgid ""
"Set to ``True`` if the blob should be opened without write permissions. "
"Defaults to ``False``."
msgstr ""
"Установите значение True, если большой двоичный объект должен быть открыт "
"без разрешений на запись. По умолчанию установлено значение «False»."

#: ../../library/sqlite3.rst:588
msgid ""
"The name of the database where the blob is located. Defaults to ``\"main\"``."
msgstr ""
"Имя базы данных, в которой находится большой двоичный объект. По умолчанию "
"``\"main\"``."

#: ../../library/sqlite3.rst:0
msgid "Raises"
msgstr "Levanta"

#: ../../library/sqlite3.rst:592
msgid "When trying to open a blob in a ``WITHOUT ROWID`` table."
msgstr "При попытке открыть большой двоичный объект в таблице БЕЗ ROWID."

#: ../../library/sqlite3.rst:599
msgid ""
"The blob size cannot be changed using the :class:`Blob` class. Use the SQL "
"function ``zeroblob`` to create a blob with a fixed size."
msgstr ""
"Размер большого двоичного объекта нельзя изменить с помощью класса :class:"
"`Blob`. Используйте функцию SQL «zeroblob», чтобы создать большой двоичный "
"объект фиксированного размера."

#: ../../library/sqlite3.rst:606
msgid ""
"Commit any pending transaction to the database. If there is no open "
"transaction, this method is a no-op."
msgstr ""

#: ../../library/sqlite3.rst:611
msgid ""
"Roll back to the start of any pending transaction. If there is no open "
"transaction, this method is a no-op."
msgstr ""

#: ../../library/sqlite3.rst:616
msgid ""
"Close the database connection. Any pending transaction is not committed "
"implicitly; make sure to :meth:`commit` before closing to avoid losing "
"pending changes."
msgstr ""

#: ../../library/sqlite3.rst:623
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.execute` on it "
"with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"Створіть новий об’єкт :class:`Cursor` і викличте :meth:`~Cursor.execute` для "
"нього з заданими *sql* і *параметрами*. Повернути новий об’єкт курсору."

#: ../../library/sqlite3.rst:629
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executemany` on "
"it with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"Створіть новий об’єкт :class:`Cursor` і викличте :meth:`~Cursor.executemany` "
"для нього з заданими *sql* і *параметрами*. Повернути новий об’єкт курсору."

#: ../../library/sqlite3.rst:635
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executescript` "
"on it with the given *sql_script*. Return the new cursor object."
msgstr ""
"Створіть новий об’єкт :class:`Cursor` і викличте :meth:`~Cursor."
"executescript` для нього за допомогою заданого *sql_script*. Повернути новий "
"об’єкт курсору."

#: ../../library/sqlite3.rst:641
msgid "Create or remove a user-defined SQL function."
msgstr "Создайте или удалите пользовательскую функцию SQL."

#: ../../library/sqlite3.rst:643
msgid "The name of the SQL function."
msgstr "O nome da função SQL."

#: ../../library/sqlite3.rst:646
msgid ""
"The number of arguments the SQL function can accept. If ``-1``, it may take "
"any number of arguments."
msgstr ""
"Количество аргументов, которые может принять функция SQL. Если ``-1``, он "
"может принимать любое количество аргументов."

#: ../../library/sqlite3.rst:650
msgid ""
"A :term:`callable` that is called when the SQL function is invoked. The "
"callable must return :ref:`a type natively supported by SQLite <sqlite3-"
"types>`. Set to ``None`` to remove an existing SQL function."
msgstr ""
":term:`callable`, который вызывается при вызове функции SQL. Вызываемый "
"объект должен возвращать :ref:`тип, изначально поддерживаемый SQLite "
"<sqlite3-types>`. Установите значение «Нет», чтобы удалить существующую "
"функцию SQL."

#: ../../library/sqlite3.rst:657
msgid ""
"If ``True``, the created SQL function is marked as `deterministic <https://"
"sqlite.org/deterministic.html>`_, which allows SQLite to perform additional "
"optimizations."
msgstr ""
"Если ``True``, созданная функция SQL помечается как ``детерминированная "
"<https://sqlite.org/deterministic.html>`_, что позволяет SQLite выполнять "
"дополнительную оптимизацию."

#: ../../library/sqlite3.rst:662
msgid "If *deterministic* is used with SQLite versions older than 3.8.3."
msgstr ""

#: ../../library/sqlite3.rst:665
msgid "Added the *deterministic* parameter."
msgstr "Добавлен параметр *детерминированный*."

#: ../../library/sqlite3.rst:668 ../../library/sqlite3.rst:706
#: ../../library/sqlite3.rst:769 ../../library/sqlite3.rst:1021
#: ../../library/sqlite3.rst:1362 ../../library/sqlite3.rst:1390
msgid "Example:"
msgstr "Exemplo:"

#: ../../library/sqlite3.rst:684
msgid "Create or remove a user-defined SQL aggregate function."
msgstr ""
"Создайте или удалите определяемую пользователем агрегатную функцию SQL."

#: ../../library/sqlite3.rst:686
msgid "The name of the SQL aggregate function."
msgstr "Имя агрегатной функции SQL."

#: ../../library/sqlite3.rst:689
msgid ""
"The number of arguments the SQL aggregate function can accept. If ``-1``, it "
"may take any number of arguments."
msgstr ""
"Число аргументов, которые может принять агрегатная функция SQL. Если ``-1``, "
"он может принимать любое количество аргументов."

#: ../../library/sqlite3.rst:693
msgid ""
"A class must implement the following methods:  * ``step()``: Add a row to "
"the aggregate. * ``finalize()``: Return the final result of the aggregate "
"as   :ref:`a type natively supported by SQLite <sqlite3-types>`.  The number "
"of arguments that the ``step()`` method must accept is controlled by "
"*n_arg*.  Set to ``None`` to remove an existing SQL aggregate function."
msgstr ""
"Класс должен реализовывать следующие методы: * ``step()``: добавляет строку "
"в агрегат. * ``finalize()``: Возвращает окончательный результат агрегата "
"как :ref:`тип, изначально поддерживаемый SQLite <sqlite3-types>`. Количество "
"аргументов, которые должен принимать метод ``step()``, контролируется "
"*n_arg*. Установите значение «Нет», чтобы удалить существующую агрегатную "
"функцию SQL."

#: ../../library/sqlite3.rst:694
msgid "A class must implement the following methods:"
msgstr "Uma classe deve implementar os seguintes métodos:"

#: ../../library/sqlite3.rst:696
msgid "``step()``: Add a row to the aggregate."
msgstr "``step()``: добавьте строку в агрегат."

#: ../../library/sqlite3.rst:697 ../../library/sqlite3.rst:753
msgid ""
"``finalize()``: Return the final result of the aggregate as :ref:`a type "
"natively supported by SQLite <sqlite3-types>`."
msgstr ""
"``finalize()``: Возвращает окончательный результат агрегата как :ref:`тип, "
"изначально поддерживаемый SQLite <sqlite3-types>`."

#: ../../library/sqlite3.rst:700
msgid ""
"The number of arguments that the ``step()`` method must accept is controlled "
"by *n_arg*."
msgstr ""
"Количество аргументов, которые должен принимать метод ``step()``, "
"контролируется *n_arg*."

#: ../../library/sqlite3.rst:703
msgid "Set to ``None`` to remove an existing SQL aggregate function."
msgstr ""
"Установите значение «Нет», чтобы удалить существующую агрегатную функцию SQL."

#: ../../library/sqlite3.rst:738
msgid "Create or remove a user-defined aggregate window function."
msgstr "Создайте или удалите пользовательскую агрегатную оконную функцию."

#: ../../library/sqlite3.rst:740
msgid "The name of the SQL aggregate window function to create or remove."
msgstr ""
"Имя агрегатной оконной функции SQL, которую необходимо создать или удалить."

#: ../../library/sqlite3.rst:743
msgid ""
"The number of arguments the SQL aggregate window function can accept. If "
"``-1``, it may take any number of arguments."
msgstr ""
"Число аргументов, которые может принять агрегатная оконная функция SQL. Если "
"``-1``, он может принимать любое количество аргументов."

#: ../../library/sqlite3.rst:747
msgid ""
"A class that must implement the following methods:  * ``step()``: Add a row "
"to the current window. * ``value()``: Return the current value of the "
"aggregate. * ``inverse()``: Remove a row from the current window. * "
"``finalize()``: Return the final result of the aggregate as   :ref:`a type "
"natively supported by SQLite <sqlite3-types>`.  The number of arguments that "
"the ``step()`` and ``value()`` methods must accept is controlled by "
"*num_params*.  Set to ``None`` to remove an existing SQL aggregate window "
"function."
msgstr ""
"Класс, который должен реализовывать следующие методы: * ``step()``: "
"добавляет строку в текущее окно. * ``value()``: Возвращает текущее значение "
"агрегата. * ``inverse()``: удалить строку из текущего окна. * "
"``finalize()``: Возвращает окончательный результат агрегата как :ref:`тип, "
"изначально поддерживаемый SQLite <sqlite3-types>`. Количество аргументов, "
"которые должны принимать методы ``step()`` и ``value()``, контролируется "
"*num_params*. Установите значение «Нет», чтобы удалить существующую "
"агрегатную оконную функцию SQL."

#: ../../library/sqlite3.rst:748
msgid "A class that must implement the following methods:"
msgstr "Uma classe que deve implementar os seguintes métodos:"

#: ../../library/sqlite3.rst:750
msgid "``step()``: Add a row to the current window."
msgstr "``step()``: добавить строку в текущее окно."

#: ../../library/sqlite3.rst:751
msgid "``value()``: Return the current value of the aggregate."
msgstr "``value()``: Возвращает текущее значение агрегата."

#: ../../library/sqlite3.rst:752
msgid "``inverse()``: Remove a row from the current window."
msgstr "``inverse()``: удалить строку из текущего окна."

#: ../../library/sqlite3.rst:756
msgid ""
"The number of arguments that the ``step()`` and ``value()`` methods must "
"accept is controlled by *num_params*."
msgstr ""
"Количество аргументов, которые должны принимать методы ``step()`` и "
"``value()``, контролируется *num_params*."

#: ../../library/sqlite3.rst:759
msgid "Set to ``None`` to remove an existing SQL aggregate window function."
msgstr ""
"Установите значение «Нет», чтобы удалить существующую агрегатную оконную "
"функцию SQL."

#: ../../library/sqlite3.rst:761
msgid ""
"If used with a version of SQLite older than 3.25.0, which does not support "
"aggregate window functions."
msgstr ""
"При использовании с версией SQLite старше 3.25.0, которая не поддерживает "
"агрегатные оконные функции."

#: ../../library/sqlite3.rst:824
msgid ""
"Create a collation named *name* using the collating function *callable*. "
"*callable* is passed two :class:`string <str>` arguments, and it should "
"return an :class:`integer <int>`:"
msgstr ""
"Створіть зіставлення під назвою *name* за допомогою функції зіставлення "
"*callable*. *callable* передається два аргументи :class:`string <str>`, і "
"він має повернути :class:`ціле число <int>`:"

#: ../../library/sqlite3.rst:828
msgid "``1`` if the first is ordered higher than the second"
msgstr "``1``, якщо перший впорядкований вище за другий"

#: ../../library/sqlite3.rst:829
msgid "``-1`` if the first is ordered lower than the second"
msgstr "``-1``, якщо перший впорядкований нижче другого"

#: ../../library/sqlite3.rst:830
msgid "``0`` if they are ordered equal"
msgstr "``0``, якщо вони в порядку рівності"

#: ../../library/sqlite3.rst:832
msgid "The following example shows a reverse sorting collation:"
msgstr "У наступному прикладі показано порівняння зворотного сортування:"

#: ../../library/sqlite3.rst:860
msgid "Remove a collation function by setting *callable* to ``None``."
msgstr ""
"Удалите функцию сопоставления, установив для *callable* значение «None»."

#: ../../library/sqlite3.rst:862
msgid ""
"The collation name can contain any Unicode character.  Earlier, only ASCII "
"characters were allowed."
msgstr ""
"Имя параметра сортировки может содержать любой символ Юникода. Раньше "
"допускались только символы ASCII."

#: ../../library/sqlite3.rst:869
msgid ""
"Call this method from a different thread to abort any queries that might be "
"executing on the connection. Aborted queries will raise an :exc:"
"`OperationalError`."
msgstr ""
"Вызовите этот метод из другого потока, чтобы прервать любые запросы, которые "
"могут выполняться в соединении. Прерванные запросы вызовут ошибку :exc:"
"`OperationalError`."

#: ../../library/sqlite3.rst:876
msgid ""
"Register :term:`callable` *authorizer_callback* to be invoked for each "
"attempt to access a column of a table in the database. The callback should "
"return one of :const:`SQLITE_OK`, :const:`SQLITE_DENY`, or :const:"
"`SQLITE_IGNORE` to signal how access to the column should be handled by the "
"underlying SQLite library."
msgstr ""
"Зарегистрируйте :term:`callable` *authorizer_callback*, чтобы он вызывался "
"при каждой попытке доступа к столбцу таблицы в базе данных. Обратный вызов "
"должен возвращать один из :const:`SQLITE_OK`, :const:`SQLITE_DENY` или :"
"const:`SQLITE_IGNORE`, чтобы указать, как доступ к столбцу должен "
"обрабатываться базовой библиотекой SQLite."

#: ../../library/sqlite3.rst:883
msgid ""
"The first argument to the callback signifies what kind of operation is to be "
"authorized. The second and third argument will be arguments or ``None`` "
"depending on the first argument. The 4th argument is the name of the "
"database (\"main\", \"temp\", etc.) if applicable. The 5th argument is the "
"name of the inner-most trigger or view that is responsible for the access "
"attempt or ``None`` if this access attempt is directly from input SQL code."
msgstr ""
"Первый аргумент обратного вызова указывает, какая операция должна быть "
"авторизована. Второй и третий аргументы будут аргументами или «Нет» в "
"зависимости от первого аргумента. Четвертый аргумент — это имя базы данных "
"(«main», «temp» и т. д.), если применимо. Пятый аргумент — это имя самого "
"внутреннего триггера или представления, которое отвечает за попытку доступа, "
"или «Нет», если эта попытка доступа происходит непосредственно из входного "
"кода SQL."

#: ../../library/sqlite3.rst:890
msgid ""
"Please consult the SQLite documentation about the possible values for the "
"first argument and the meaning of the second and third argument depending on "
"the first one. All necessary constants are available in the :mod:`!sqlite3` "
"module."
msgstr ""
"Пожалуйста, обратитесь к документации SQLite о возможных значениях первого "
"аргумента и значении второго и третьего аргумента в зависимости от первого. "
"Все необходимые константы доступны в модуле :mod:`!sqlite3`."

#: ../../library/sqlite3.rst:894
msgid "Passing ``None`` as *authorizer_callback* will disable the authorizer."
msgstr "Передача None в качестве *authorizer_callback* отключит авторизатор."

#: ../../library/sqlite3.rst:896
msgid "Added support for disabling the authorizer using ``None``."
msgstr "Добавлена ​​поддержка отключения авторизатора с помощью None."

#: ../../library/sqlite3.rst:902
msgid ""
"Register :term:`callable` *progress_handler* to be invoked for every *n* "
"instructions of the SQLite virtual machine. This is useful if you want to "
"get called from SQLite during long-running operations, for example to update "
"a GUI."
msgstr ""
"Зарегистрируйте :term:`callable` *progress_handler*, который будет "
"вызываться для каждой *n* инструкции виртуальной машины SQLite. Это полезно, "
"если вы хотите, чтобы вас вызывали из SQLite во время длительных операций, "
"например для обновления графического интерфейса."

#: ../../library/sqlite3.rst:907
msgid ""
"If you want to clear any previously installed progress handler, call the "
"method with ``None`` for *progress_handler*."
msgstr ""
"Если вы хотите очистить любой ранее установленный обработчик прогресса, "
"вызовите метод с ``None`` для *progress_handler*."

#: ../../library/sqlite3.rst:910
msgid ""
"Returning a non-zero value from the handler function will terminate the "
"currently executing query and cause it to raise an :exc:`OperationalError` "
"exception."
msgstr ""

#: ../../library/sqlite3.rst:917
msgid ""
"Register :term:`callable` *trace_callback* to be invoked for each SQL "
"statement that is actually executed by the SQLite backend."
msgstr ""
"Зарегистрируйте :term:`callable` *trace_callback*, чтобы он вызывался для "
"каждого оператора SQL, который фактически выполняется серверной частью "
"SQLite."

#: ../../library/sqlite3.rst:920
msgid ""
"The only argument passed to the callback is the statement (as :class:`str`) "
"that is being executed. The return value of the callback is ignored. Note "
"that the backend does not only run statements passed to the :meth:`Cursor."
"execute` methods.  Other sources include the :ref:`transaction management "
"<sqlite3-controlling-transactions>` of the :mod:`!sqlite3` module and the "
"execution of triggers defined in the current database."
msgstr ""
"Единственный аргумент, передаваемый обратному вызову, — это оператор (как :"
"class:`str`), который выполняется. Возвращаемое значение обратного вызова "
"игнорируется. Обратите внимание, что серверная часть не только выполняет "
"операторы, переданные методам :meth:`Cursor.execute`. Другие источники "
"включают в себя :ref:`управление транзакциями <sqlite3-controlling-"
"transactions>` модуля :mod:`!sqlite3` и выполнение триггеров, определенных в "
"текущей базе данных."

#: ../../library/sqlite3.rst:928
msgid "Passing ``None`` as *trace_callback* will disable the trace callback."
msgstr ""
"Передача None в качестве *trace_callback* отключит обратный вызов "
"трассировки."

#: ../../library/sqlite3.rst:931
msgid ""
"Exceptions raised in the trace callback are not propagated. As a development "
"and debugging aid, use :meth:`~sqlite3.enable_callback_tracebacks` to enable "
"printing tracebacks from exceptions raised in the trace callback."
msgstr ""
"Винятки, викликані зворотним викликом трасування, не поширюються. Як "
"допомога при розробці та налагодженні використовуйте :meth:`~sqlite3."
"enable_callback_tracebacks`, щоб увімкнути друк трасування з винятків, "
"викликаних у зворотному виклику трасування."

#: ../../library/sqlite3.rst:941
msgid ""
"Enable the SQLite engine to load SQLite extensions from shared libraries if "
"*enabled* is ``True``; else, disallow loading SQLite extensions. SQLite "
"extensions can define new functions, aggregates or whole new virtual table "
"implementations.  One well-known extension is the fulltext-search extension "
"distributed with SQLite."
msgstr ""
"Включите механизм SQLite для загрузки расширений SQLite из общих библиотек, "
"если *enabled* имеет значение ``True``; в противном случае запретите "
"загрузку расширений SQLite. Расширения SQLite могут определять новые "
"функции, агрегаты или совершенно новые реализации виртуальных таблиц. Одним "
"из широко известных расширений является расширение полнотекстового поиска, "
"поставляемое вместе с SQLite."

#: ../../library/sqlite3.rst:950
msgid ""
"The :mod:`!sqlite3` module is not built with loadable extension support by "
"default, because some platforms (notably macOS) have SQLite libraries which "
"are compiled without this feature. To get loadable extension support, you "
"must pass the :option:`--enable-loadable-sqlite-extensions` option to :"
"program:`configure`."
msgstr ""
"Модуль :mod:`!sqlite3` по умолчанию не имеет поддержки загружаемых "
"расширений, поскольку на некоторых платформах (особенно macOS) есть "
"библиотеки SQLite, которые компилируются без этой функции. Чтобы получить "
"поддержку загружаемых расширений, вы должны передать параметр :option:`--"
"enable-loadable-sqlite-extensions` в :program:`configure`."

#: ../../library/sqlite3.rst:957
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.enable_load_extension`` "
"with arguments ``connection``, ``enabled``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``sqlite3."
"enable_load_extension`` com os argumentos ``connection``, ``enabled``."

#: ../../library/sqlite3.rst:961
msgid "Added the ``sqlite3.enable_load_extension`` auditing event."
msgstr "Додано подію аудиту sqlite3.enable_load_extension."

#: ../../library/sqlite3.rst:1004
msgid ""
"Load an SQLite extension from a shared library located at *path*. Enable "
"extension loading with :meth:`enable_load_extension` before calling this "
"method."
msgstr ""

#: ../../library/sqlite3.rst:1008
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.load_extension`` with "
"arguments ``connection``, ``path``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``sqlite3.load_extension`` "
"com os argumentos ``connection``, ``path``."

#: ../../library/sqlite3.rst:1012
msgid "Added the ``sqlite3.load_extension`` auditing event."
msgstr "Додано подію аудиту ``sqlite3.load_extension``."

#: ../../library/sqlite3.rst:1017
msgid ""
"Return an :term:`iterator` to dump the database as SQL source code. Useful "
"when saving an in-memory database for later restoration. Similar to the ``."
"dump`` command in the :program:`sqlite3` shell."
msgstr ""
"Верните :term:`iterator`, чтобы выгрузить базу данных в виде исходного кода "
"SQL. Полезно при сохранении базы данных в памяти для последующего "
"восстановления. Аналогично команде ``.dump`` в оболочке :program:`sqlite3`."

#: ../../library/sqlite3.rst:1034 ../../library/sqlite3.rst:1104
msgid ":ref:`sqlite3-howto-encoding`"
msgstr ":ref:`sqlite3-howto-encoding`"

#: ../../library/sqlite3.rst:1039
msgid "Create a backup of an SQLite database."
msgstr "Создайте резервную копию базы данных SQLite."

#: ../../library/sqlite3.rst:1041
msgid ""
"Works even if the database is being accessed by other clients or "
"concurrently by the same connection."
msgstr ""
"Работает, даже если к базе данных обращаются другие клиенты или одновременно "
"по тому же соединению."

#: ../../library/sqlite3.rst:1044
msgid "The database connection to save the backup to."
msgstr "Соединение с базой данных, в котором сохраняется резервная копия."

#: ../../library/sqlite3.rst:1047
msgid ""
"The number of pages to copy at a time. If equal to or less than ``0``, the "
"entire database is copied in a single step. Defaults to ``-1``."
msgstr ""
"Количество страниц, копируемых за один раз. Если оно равно или меньше «0», "
"вся база данных копируется за один шаг. По умолчанию ``-1``."

#: ../../library/sqlite3.rst:1053
msgid ""
"If set to a :term:`callable`, it is invoked with three integer arguments for "
"every backup iteration: the *status* of the last iteration, the *remaining* "
"number of pages still to be copied, and the *total* number of pages. "
"Defaults to ``None``."
msgstr ""
"Если установлено значение :term:`callable`, он вызывается с тремя "
"целочисленными аргументами для каждой итерации резервного копирования: "
"*статус* последней итерации, *оставшееся* количество страниц, которые еще "
"предстоит скопировать, и *общее* количество страниц. По умолчанию "
"установлено значение «Нет»."

#: ../../library/sqlite3.rst:1062
msgid ""
"The name of the database to back up. Either ``\"main\"`` (the default) for "
"the main database, ``\"temp\"`` for the temporary database, or the name of a "
"custom database as attached using the ``ATTACH DATABASE`` SQL statement."
msgstr ""
"Имя базы данных для резервного копирования. Либо ``\"main\"`` (по умолчанию) "
"для основной базы данных, ``\"temp\"`` для временной базы данных, либо имя "
"пользовательской базы данных, прикрепленное с помощью оператора SQL ``ATTACH "
"DATABASE``."

#: ../../library/sqlite3.rst:1069
msgid ""
"The number of seconds to sleep between successive attempts to back up "
"remaining pages."
msgstr ""
"Количество секунд ожидания между последовательными попытками резервного "
"копирования оставшихся страниц."

#: ../../library/sqlite3.rst:1073
msgid "Example 1, copy an existing database into another:"
msgstr "Пример 1: копирование существующей базы данных в другую:"

#: ../../library/sqlite3.rst:1092
msgid "Example 2, copy an existing database into a transient copy:"
msgstr "Пример 2: скопируйте существующую базу данных во временную копию:"

#: ../../library/sqlite3.rst:1108
msgid "Get a connection runtime limit."
msgstr "Получите ограничение времени выполнения соединения."

#: ../../library/sqlite3.rst:1110
msgid "The `SQLite limit category`_ to be queried."
msgstr "`Категория ограничения SQLite`_ для запроса."

#: ../../library/sqlite3.rst:1115 ../../library/sqlite3.rst:1152
msgid "If *category* is not recognised by the underlying SQLite library."
msgstr "Если *категория* не распознается базовой библиотекой SQLite."

#: ../../library/sqlite3.rst:1118
msgid ""
"Example, query the maximum length of an SQL statement for :class:"
"`Connection` ``con`` (the default is 1000000000):"
msgstr ""
"Например, запросите максимальную длину оператора SQL для :class:`Connection` "
"``con`` (по умолчанию — 1000000000):"

#: ../../library/sqlite3.rst:1138
msgid ""
"Set a connection runtime limit. Attempts to increase a limit above its hard "
"upper bound are silently truncated to the hard upper bound. Regardless of "
"whether or not the limit was changed, the prior value of the limit is "
"returned."
msgstr ""
"Установите ограничение времени выполнения соединения. Попытки увеличить "
"предел выше его жесткой верхней границы молча обрезаются до жесткой верхней "
"границы. Независимо от того, был ли изменен лимит, возвращается предыдущее "
"значение лимита."

#: ../../library/sqlite3.rst:1143
msgid "The `SQLite limit category`_ to be set."
msgstr "`_ Категория ограничения SQLite`_, которую необходимо установить."

#: ../../library/sqlite3.rst:1146
msgid ""
"The value of the new limit. If negative, the current limit is unchanged."
msgstr ""
"Значение нового лимита. Если отрицательно, то предел тока не изменяется."

#: ../../library/sqlite3.rst:1155
msgid ""
"Example, limit the number of attached databases to 1 for :class:`Connection` "
"``con`` (the default limit is 10):"
msgstr ""
"Например, ограничьте количество подключенных баз данных до 1 для :class:"
"`Connection` ``con`` (ограничение по умолчанию — 10):"

#: ../../library/sqlite3.rst:1172
msgid ""
"Serialize a database into a :class:`bytes` object.  For an ordinary on-disk "
"database file, the serialization is just a copy of the disk file.  For an in-"
"memory database or a \"temp\" database, the serialization is the same "
"sequence of bytes which would be written to disk if that database were "
"backed up to disk."
msgstr ""
"Сериализуйте базу данных в объект :class:`bytes`. Для обычного файла базы "
"данных на диске сериализация представляет собой просто копию дискового "
"файла. Для базы данных в памяти или «временной» базы данных сериализация "
"представляет собой ту же последовательность байтов, которая была бы записана "
"на диск, если бы эта база данных была скопирована на диск."

#: ../../library/sqlite3.rst:1178
msgid "The database name to be serialized. Defaults to ``\"main\"``."
msgstr "Имя базы данных для сериализации. По умолчанию ``\"main\"``."

#: ../../library/sqlite3.rst:1186
msgid ""
"This method is only available if the underlying SQLite library has the "
"serialize API."
msgstr ""
"Этот метод доступен только в том случае, если базовая библиотека SQLite "
"имеет API сериализации."

#: ../../library/sqlite3.rst:1194
msgid ""
"Deserialize a :meth:`serialized <serialize>` database into a :class:"
"`Connection`. This method causes the database connection to disconnect from "
"database *name*, and reopen *name* as an in-memory database based on the "
"serialization contained in *data*."
msgstr ""
"Десериализовать :meth:`сериализованную <serialize>` базу данных в :class:"
"`Connection`. Этот метод приводит к отключению соединения с базой данных "
"*name* и повторному открытию *name* как базы данных в памяти на основе "
"сериализации, содержащейся в *data*."

#: ../../library/sqlite3.rst:1200
msgid "A serialized database."
msgstr "Сериализованная база данных."

#: ../../library/sqlite3.rst:1203
msgid "The database name to deserialize into. Defaults to ``\"main\"``."
msgstr "Имя базы данных для десериализации. По умолчанию ``\"main\"``."

#: ../../library/sqlite3.rst:1207
msgid ""
"If the database connection is currently involved in a read transaction or a "
"backup operation."
msgstr ""
"Если соединение с базой данных в данный момент участвует в транзакции чтения "
"или операции резервного копирования."

#: ../../library/sqlite3.rst:1211
msgid "If *data* does not contain a valid SQLite database."
msgstr "Если *data* не содержит действующую базу данных SQLite."

#: ../../library/sqlite3.rst:1214
msgid "If :func:`len(data) <len>` is larger than ``2**63 - 1``."
msgstr "Если :func:`len(data) <len>` больше, чем ``2**63 - 1``."

#: ../../library/sqlite3.rst:1219
msgid ""
"This method is only available if the underlying SQLite library has the "
"deserialize API."
msgstr ""
"Этот метод доступен только в том случае, если базовая библиотека SQLite "
"имеет API десериализации."

#: ../../library/sqlite3.rst:1226
msgid ""
"This read-only attribute corresponds to the low-level SQLite `autocommit "
"mode`_."
msgstr ""
"Этот атрибут только для чтения соответствует низкоуровневому `режиму "
"автоматической фиксации`_ SQLite."

#: ../../library/sqlite3.rst:1229
msgid ""
"``True`` if a transaction is active (there are uncommitted changes), "
"``False`` otherwise."
msgstr ""
"``True``, если транзакция активна (есть незафиксированные изменения), "
"``False`` в противном случае."

#: ../../library/sqlite3.rst:1236
msgid ""
"This attribute controls the :ref:`transaction handling <sqlite3-controlling-"
"transactions>` performed by :mod:`!sqlite3`. If set to ``None``, "
"transactions are never implicitly opened. If set to one of ``\"DEFERRED\"``, "
"``\"IMMEDIATE\"``, or ``\"EXCLUSIVE\"``, corresponding to the underlying "
"`SQLite transaction behaviour`_, implicit :ref:`transaction management "
"<sqlite3-controlling-transactions>` is performed."
msgstr ""

#: ../../library/sqlite3.rst:1244
msgid ""
"If not overridden by the *isolation_level* parameter of :func:`connect`, the "
"default is ``\"\"``, which is an alias for ``\"DEFERRED\"``."
msgstr ""
"Если это не переопределено параметром *isolation_level* функции :func:"
"`connect`, по умолчанию используется ``\"\"``, который является псевдонимом "
"для ``\"DEFERRED\"``."

#: ../../library/sqlite3.rst:1249
msgid ""
"The initial :attr:`~Cursor.row_factory` for :class:`Cursor` objects created "
"from this connection. Assigning to this attribute does not affect the :attr:"
"`!row_factory` of existing cursors belonging to this connection, only new "
"ones. Is ``None`` by default, meaning each row is returned as a :class:"
"`tuple`."
msgstr ""
"Начальный :attr:`~Cursor.row_factory` для объектов :class:`Cursor`, "
"созданных из этого соединения. Присвоение этому атрибуту не влияет на :attr:"
"`!row_factory` существующих курсоров, принадлежащих этому соединению, а "
"только на новые. По умолчанию имеет значение None, что означает, что каждая "
"строка возвращается как :class:`tuple`."

#: ../../library/sqlite3.rst:1256 ../../library/sqlite3.rst:1516
#: ../../library/sqlite3.rst:1539
msgid "See :ref:`sqlite3-howto-row-factory` for more details."
msgstr "Consulte :ref:`sqlite3-howto-row-factory` para mais detalhes."

#: ../../library/sqlite3.rst:1260
msgid ""
"A :term:`callable` that accepts a :class:`bytes` parameter and returns a "
"text representation of it. The callable is invoked for SQLite values with "
"the ``TEXT`` data type. By default, this attribute is set to :class:`str`."
msgstr ""
":term:`callable`, который принимает параметр :class:`bytes` и возвращает его "
"текстовое представление. Вызываемый объект вызывается для значений SQLite с "
"типом данных TEXT. По умолчанию для этого атрибута установлено значение :"
"class:`str`."

#: ../../library/sqlite3.rst:1265
msgid "See :ref:`sqlite3-howto-encoding` for more details."
msgstr "Consulte :ref:`sqlite3-howto-encoding` para mais detalhes."

#: ../../library/sqlite3.rst:1269
msgid ""
"Return the total number of database rows that have been modified, inserted, "
"or deleted since the database connection was opened."
msgstr ""
"Возвращает общее количество строк базы данных, которые были изменены, "
"вставлены или удалены с момента открытия соединения с базой данных."

#: ../../library/sqlite3.rst:1276
msgid "Cursor objects"
msgstr "Курсорные объекты"

#: ../../library/sqlite3.rst:1278
msgid ""
"A ``Cursor`` object represents a `database cursor`_ which is used to execute "
"SQL statements, and manage the context of a fetch operation. Cursors are "
"created using :meth:`Connection.cursor`, or by using any of the :ref:"
"`connection shortcut methods <sqlite3-connection-shortcuts>`."
msgstr ""
"Объект «Курсор» представляет собой «курсор базы данных», который "
"используется для выполнения операторов SQL и управления контекстом операции "
"выборки. Курсоры создаются с помощью :meth:`Connection.cursor` или с помощью "
"любого из :ref:`методов ярлыков соединений <sqlite3-connection-shortcuts>`."

#: ../../library/sqlite3.rst:1285
msgid ""
"Cursor objects are :term:`iterators <iterator>`, meaning that if you :meth:"
"`~Cursor.execute` a ``SELECT`` query, you can simply iterate over the cursor "
"to fetch the resulting rows:"
msgstr ""
"Объекты курсора — это :term:`итераторы <iterator>`, что означает, что если "
"вы :meth:`~Cursor.execute` запрос ``SELECT``, вы можете просто перебирать "
"курсор для получения результирующих строк:"

#: ../../library/sqlite3.rst:1310
msgid "A :class:`Cursor` instance has the following attributes and methods."
msgstr "Екземпляр :class:`Cursor` має такі атрибути та методи."

#: ../../library/sqlite3.rst:1317
msgid ""
"Execute a single SQL statement, optionally binding Python values using :ref:"
"`placeholders <sqlite3-placeholders>`."
msgstr ""
"Выполните один оператор SQL, при необходимости привязав значения Python с "
"помощью :ref:`placeholders <sqlite3-placeholders>`."

#: ../../library/sqlite3.rst:1321
msgid "A single SQL statement."
msgstr "Один оператор SQL."

#: ../../library/sqlite3.rst:1324
msgid ""
"Python values to bind to placeholders in *sql*. A :class:`!dict` if named "
"placeholders are used. A :term:`!sequence` if unnamed placeholders are used. "
"See :ref:`sqlite3-placeholders`."
msgstr ""
"Значения Python для привязки к заполнителям в *sql*. A :class:`!dict`, если "
"используются именованные заполнители. A :term:`!sequence`, если используются "
"безымянные заполнители. См. :ref:`sqlite3-placeholders`."

#: ../../library/sqlite3.rst:1331
msgid "If *sql* contains more than one SQL statement."
msgstr ""

#: ../../library/sqlite3.rst:1334
msgid ""
"If :attr:`~Connection.isolation_level` is not ``None``, *sql* is an "
"``INSERT``, ``UPDATE``, ``DELETE``, or ``REPLACE`` statement, and there is "
"no open transaction, a transaction is implicitly opened before executing "
"*sql*."
msgstr ""

#: ../../library/sqlite3.rst:1339
msgid "Use :meth:`executescript` to execute multiple SQL statements."
msgstr ""
"Используйте :meth:`executescript` для выполнения нескольких операторов SQL."

#: ../../library/sqlite3.rst:1343
msgid ""
"For every item in *parameters*, repeatedly execute the :ref:`parameterized "
"<sqlite3-placeholders>` :abbr:`DML (Data Manipulation Language)` SQL "
"statement *sql*."
msgstr ""
"Для каждого элемента в *parameters* повторно выполните :ref:"
"`параметризованный <sqlite3-placeholders>` :abbr:`DML (язык манипулирования "
"данными)` оператор SQL *sql*."

#: ../../library/sqlite3.rst:1347
msgid "Uses the same implicit transaction handling as :meth:`~Cursor.execute`."
msgstr ""
"Использует ту же неявную обработку транзакций, что и :meth:`~Cursor.execute`."

#: ../../library/sqlite3.rst:1349
msgid "A single SQL DML statement."
msgstr "Один оператор SQL DML."

#: ../../library/sqlite3.rst:1352
msgid ""
"An :term:`!iterable` of parameters to bind with the placeholders in *sql*. "
"See :ref:`sqlite3-placeholders`."
msgstr ""
":term:`!iterable` параметров для привязки к заполнителям в *sql*. См. :ref:"
"`sqlite3-placeholders`."

#: ../../library/sqlite3.rst:1358
msgid ""
"If *sql* contains more than one SQL statement, or is not a DML statement."
msgstr ""

#: ../../library/sqlite3.rst:1375
msgid ""
"Any resulting rows are discarded, including DML statements with `RETURNING "
"clauses`_."
msgstr ""
"Любые результирующие строки отбрасываются, включая операторы DML с "
"предложениями RETURNING_."

#: ../../library/sqlite3.rst:1382
msgid ""
"Execute the SQL statements in *sql_script*. If there is a pending "
"transaction, an implicit ``COMMIT`` statement is executed first. No other "
"implicit transaction control is performed; any transaction control must be "
"added to *sql_script*."
msgstr ""

#: ../../library/sqlite3.rst:1388
msgid "*sql_script* must be a :class:`string <str>`."
msgstr "*sql_script* должен быть :class:`string <str>`."

#: ../../library/sqlite3.rst:1405
msgid ""
"If :attr:`~Cursor.row_factory` is ``None``, return the next row query result "
"set as a :class:`tuple`. Else, pass it to the row factory and return its "
"result. Return ``None`` if no more data is available."
msgstr ""
"Если :attr:`~Cursor.row_factory` имеет значение ``None``, вернуть следующий "
"набор результатов запроса строки как :class:`tuple`. В противном случае "
"передайте его фабрике строк и верните результат. Верните None, если данных "
"больше нет."

#: ../../library/sqlite3.rst:1413
msgid ""
"Return the next set of rows of a query result as a :class:`list`. Return an "
"empty list if no more rows are available."
msgstr ""
"Возвращает следующий набор строк результата запроса в виде :class:`list`. "
"Верните пустой список, если больше нет доступных строк."

#: ../../library/sqlite3.rst:1416
msgid ""
"The number of rows to fetch per call is specified by the *size* parameter. "
"If *size* is not given, :attr:`arraysize` determines the number of rows to "
"be fetched. If fewer than *size* rows are available, as many rows as are "
"available are returned."
msgstr ""
"Количество строк, извлекаемых за один вызов, определяется параметром *size*. "
"Если *size* не задано, :attr:`arraysize` определяет количество извлекаемых "
"строк. Если доступно меньше строк *size*, возвращается столько строк, "
"сколько доступно."

#: ../../library/sqlite3.rst:1422
msgid ""
"Note there are performance considerations involved with the *size* "
"parameter. For optimal performance, it is usually best to use the arraysize "
"attribute. If the *size* parameter is used, then it is best for it to retain "
"the same value from one :meth:`fetchmany` call to the next."
msgstr ""
"Зауважте, що з параметром *size* пов’язані міркування щодо продуктивності. "
"Для оптимальної продуктивності зазвичай найкраще використовувати атрибут "
"arraysize. Якщо використовується параметр *size*, то найкраще, щоб він "
"зберігав те саме значення від одного виклику :meth:`fetchmany` до наступного."

#: ../../library/sqlite3.rst:1429
msgid ""
"Return all (remaining) rows of a query result as a :class:`list`. Return an "
"empty list if no rows are available. Note that the :attr:`arraysize` "
"attribute can affect the performance of this operation."
msgstr ""
"Возвращает все (оставшиеся) строки результата запроса в виде :class:`list`. "
"Верните пустой список, если нет доступных строк. Обратите внимание, что "
"атрибут :attr:`arraysize` может повлиять на производительность этой операции."

#: ../../library/sqlite3.rst:1436
msgid "Close the cursor now (rather than whenever ``__del__`` is called)."
msgstr "Закрийте курсор зараз (а не під час кожного виклику ``__del__``)."

#: ../../library/sqlite3.rst:1438
msgid ""
"The cursor will be unusable from this point forward; a :exc:"
"`ProgrammingError` exception will be raised if any operation is attempted "
"with the cursor."
msgstr ""
"Курсор стане непридатним для використання з цього моменту; виняток :exc:"
"`ProgrammingError` буде викликано, якщо будь-яка операція буде виконана з "
"курсором."

#: ../../library/sqlite3.rst:1443 ../../library/sqlite3.rst:1447
msgid "Required by the DB-API. Does nothing in :mod:`!sqlite3`."
msgstr "Требуется для DB-API. Ничего не делает в :mod:`!sqlite3`."

#: ../../library/sqlite3.rst:1451
msgid ""
"Read/write attribute that controls the number of rows returned by :meth:"
"`fetchmany`. The default value is 1 which means a single row would be "
"fetched per call."
msgstr ""
"Атрибут читання/запису, який контролює кількість рядків, які повертає :meth:"
"`fetchmany`. Значення за замовчуванням дорівнює 1, що означає, що за виклик "
"буде отримано один рядок."

#: ../../library/sqlite3.rst:1456
msgid ""
"Read-only attribute that provides the SQLite database :class:`Connection` "
"belonging to the cursor.  A :class:`Cursor` object created by calling :meth:"
"`con.cursor() <Connection.cursor>` will have a :attr:`connection` attribute "
"that refers to *con*:"
msgstr ""
"Атрибут только для чтения, который предоставляет базу данных SQLite :class:"
"`Connection`, принадлежащую курсору. Объект :class:`Cursor`, созданный "
"вызовом :meth:`con.cursor() <Connection.cursor>`, будет иметь атрибут :attr:"
"`connection`, который ссылается на *con*:"

#: ../../library/sqlite3.rst:1470
msgid ""
"Read-only attribute that provides the column names of the last query. To "
"remain compatible with the Python DB API, it returns a 7-tuple for each "
"column where the last six items of each tuple are ``None``."
msgstr ""
"Атрибут только для чтения, который предоставляет имена столбцов последнего "
"запроса. Чтобы оставаться совместимым с API БД Python, он возвращает 7-"
"кортеж для каждого столбца, где последние шесть элементов каждого кортежа "
"имеют значение «Нет»."

#: ../../library/sqlite3.rst:1474
msgid "It is set for ``SELECT`` statements without any matching rows as well."
msgstr ""
"Він також встановлений для операторів ``SELECT`` без будь-яких відповідних "
"рядків."

#: ../../library/sqlite3.rst:1478
msgid ""
"Read-only attribute that provides the row id of the last inserted row. It is "
"only updated after successful ``INSERT`` or ``REPLACE`` statements using "
"the :meth:`execute` method.  For other statements, after :meth:`executemany` "
"or :meth:`executescript`, or if the insertion failed, the value of "
"``lastrowid`` is left unchanged.  The initial value of ``lastrowid`` is "
"``None``."
msgstr ""
"Атрибут только для чтения, который предоставляет идентификатор последней "
"вставленной строки. Он обновляется только после успешных операторов INSERT "
"или REPLACE с использованием метода :meth:`execute`. Для других операторов "
"после :meth:`executemany` или :meth:`executescript`, или если вставка не "
"удалась, значение ``lastrowid`` остается неизменным. Начальное значение "
"«lastrowid» — «Нет»."

#: ../../library/sqlite3.rst:1486
msgid "Inserts into ``WITHOUT ROWID`` tables are not recorded."
msgstr "Вставки в таблиці ``БЕЗ ROWID`` не записуються."

#: ../../library/sqlite3.rst:1488
msgid "Added support for the ``REPLACE`` statement."
msgstr "Додано підтримку оператора REPLACE."

#: ../../library/sqlite3.rst:1493
msgid ""
"Read-only attribute that provides the number of modified rows for "
"``INSERT``, ``UPDATE``, ``DELETE``, and ``REPLACE`` statements; is ``-1`` "
"for other statements, including :abbr:`CTE (Common Table Expression)` "
"queries. It is only updated by the :meth:`execute` and :meth:`executemany` "
"methods, after the statement has run to completion. This means that any "
"resulting rows must be fetched in order for :attr:`!rowcount` to be updated."
msgstr ""
"Атрибут только для чтения, который предоставляет количество измененных строк "
"для операторов INSERT, UPDATE, DELETE и REPLACE; для других операторов, "
"включая запросы :abbr:`CTE (Common Table Expression)`, равно ``-1``. Он "
"обновляется методами :meth:`execute` и :meth:`executemany` только после "
"завершения выполнения оператора. Это означает, что все результирующие строки "
"должны быть извлечены для обновления :attr:`!rowcount`."

#: ../../library/sqlite3.rst:1504
msgid ""
"Control how a row fetched from this :class:`!Cursor` is represented. If "
"``None``, a row is represented as a :class:`tuple`. Can be set to the "
"included :class:`sqlite3.Row`; or a :term:`callable` that accepts two "
"arguments, a :class:`Cursor` object and the :class:`!tuple` of row values, "
"and returns a custom object representing an SQLite row."
msgstr ""
"Управляйте представлением строки, полученной из этого :class:`!Cursor`. Если "
"``None``, строка представлена ​​как :class:`tuple`. Можно установить "
"включенный :class:`sqlite3.Row`; или :term:`callable`, который принимает два "
"аргумента: объект :class:`Cursor` и :class:`!tuple` значений строк, и "
"возвращает пользовательский объект, представляющий строку SQLite."

#: ../../library/sqlite3.rst:1511
msgid ""
"Defaults to what :attr:`Connection.row_factory` was set to when the :class:`!"
"Cursor` was created. Assigning to this attribute does not affect :attr:"
"`Connection.row_factory` of the parent connection."
msgstr ""
"По умолчанию установлено то, что :attr:`Connection.row_factory` было "
"установлено при создании :class:`!Cursor`. Назначение этого атрибута не "
"влияет на :attr:`Connection.row_factory` родительского соединения."

#: ../../library/sqlite3.rst:1527
msgid "Row objects"
msgstr "Строковые объекты"

#: ../../library/sqlite3.rst:1531
msgid ""
"A :class:`!Row` instance serves as a highly optimized :attr:`~Connection."
"row_factory` for :class:`Connection` objects. It supports iteration, "
"equality testing, :func:`len`, and :term:`mapping` access by column name and "
"index."
msgstr ""
"Экземпляр :class:`!Row` служит высокооптимизированной :attr:`~Connection."
"row_factory` для объектов :class:`Connection`. Он поддерживает итерацию, "
"проверку на равенство, доступ :func:`len` и :term:`mapping` по имени столбца "
"и индексу."

#: ../../library/sqlite3.rst:1536
msgid ""
"Two :class:`!Row` objects compare equal if they have identical column names "
"and values."
msgstr ""
"Два объекта :class:`!Row` сравниваются равными, если они имеют одинаковые "
"имена и значения столбцов."

#: ../../library/sqlite3.rst:1543
msgid ""
"Return a :class:`list` of column names as :class:`strings <str>`. "
"Immediately after a query, it is the first member of each tuple in :attr:"
"`Cursor.description`."
msgstr ""
"Верните список имен столбцов в виде :class:`strings <str>`. Сразу после "
"запроса он становится первым членом каждого кортежа в :attr:`Cursor."
"description`."

#: ../../library/sqlite3.rst:1547
msgid "Added support of slicing."
msgstr "Menambahkan dukungan dari pemotongan."

#: ../../library/sqlite3.rst:1554
msgid "Blob objects"
msgstr "Объекты BLOB-объектов"

#: ../../library/sqlite3.rst:1560
msgid ""
"A :class:`Blob` instance is a :term:`file-like object` that can read and "
"write data in an SQLite :abbr:`BLOB (Binary Large OBject)`. Call :func:"
"`len(blob) <len>` to get the size (number of bytes) of the blob. Use indices "
"and :term:`slices <slice>` for direct access to the blob data."
msgstr ""
"Экземпляр :class:`Blob` — это :term:`файлоподобный объект`, который может "
"читать и записывать данные в SQLite :abbr:`BLOB (большой двоичный объект)`. "
"Вызовите :func:`len(blob) <len>`, чтобы получить размер (количество байтов) "
"большого двоичного объекта. Используйте индексы и :term:`slices <slice>` для "
"прямого доступа к данным большого двоичного объекта."

#: ../../library/sqlite3.rst:1565
msgid ""
"Use the :class:`Blob` as a :term:`context manager` to ensure that the blob "
"handle is closed after use."
msgstr ""
"Используйте :class:`Blob` в качестве :term:`контекстного менеджера`, чтобы "
"гарантировать, что дескриптор BLOB-объекта будет закрыт после использования."

#: ../../library/sqlite3.rst:1595
msgid "Close the blob."
msgstr "Закройте blob."

#: ../../library/sqlite3.rst:1597
msgid ""
"The blob will be unusable from this point onward.  An :class:`~sqlite3."
"Error` (or subclass) exception will be raised if any further operation is "
"attempted with the blob."
msgstr ""
"С этого момента большой двоичный объект станет непригоден для использования. "
"Исключение :class:`~sqlite3.Error` (или подкласса) будет вызвано при попытке "
"какой-либо дальнейшей операции с большим двоичным объектом."

#: ../../library/sqlite3.rst:1603
msgid ""
"Read *length* bytes of data from the blob at the current offset position. If "
"the end of the blob is reached, the data up to :abbr:`EOF (End of File)` "
"will be returned.  When *length* is not specified, or is negative, :meth:"
"`~Blob.read` will read until the end of the blob."
msgstr ""
"Считайте *длину* байтов данных из большого двоичного объекта в текущей "
"позиции смещения. Если достигнут конец большого двоичного объекта, будут "
"возвращены данные до :abbr:`EOF (конец файла)`. Если *длина* не указана или "
"имеет отрицательное значение, :meth:`~Blob.read` будет читать до конца "
"большого двоичного объекта."

#: ../../library/sqlite3.rst:1611
msgid ""
"Write *data* to the blob at the current offset.  This function cannot change "
"the blob length.  Writing beyond the end of the blob will raise :exc:"
"`ValueError`."
msgstr ""
"Запишите *данные* в большой двоичный объект по текущему смещению. Эта "
"функция не может изменить длину большого двоичного объекта. Запись за "
"пределами BLOB-объекта вызовет :exc:`ValueError`."

#: ../../library/sqlite3.rst:1617
msgid "Return the current access position of the blob."
msgstr "Верните текущую позицию доступа к большому двоичному объекту."

#: ../../library/sqlite3.rst:1621
msgid ""
"Set the current access position of the blob to *offset*.  The *origin* "
"argument defaults to :const:`os.SEEK_SET` (absolute blob positioning). Other "
"values for *origin* are :const:`os.SEEK_CUR` (seek relative to the current "
"position) and :const:`os.SEEK_END` (seek relative to the blob’s end)."
msgstr ""
"Установите текущую позицию доступа к большому двоичному объекту как "
"*offset*. Аргумент *origin* по умолчанию имеет значение :const:`os.SEEK_SET` "
"(абсолютное позиционирование больших двоичных объектов). Другими значениями "
"*origin* являются :const:`os.SEEK_CUR` (поиск относительно текущей позиции) "
"и :const:`os.SEEK_END` (поиск относительно конца большого двоичного объекта)."

#: ../../library/sqlite3.rst:1629
msgid "PrepareProtocol objects"
msgstr "Объекты подготовки протокола"

#: ../../library/sqlite3.rst:1633
msgid ""
"The PrepareProtocol type's single purpose is to act as a :pep:`246` style "
"adaption protocol for objects that can :ref:`adapt themselves <sqlite3-"
"conform>` to :ref:`native SQLite types <sqlite3-types>`."
msgstr ""
"Единственная цель типа ПодготовкаПротокол — действовать как протокол "
"адаптации стиля :pep:`246` для объектов, которые могут :ref:`адаптироваться "
"<sqlite3-conform>` к :ref:`родным типам SQLite <sqlite3-types>`."

#: ../../library/sqlite3.rst:1641
msgid "Exceptions"
msgstr "Exceções"

#: ../../library/sqlite3.rst:1643
msgid "The exception hierarchy is defined by the DB-API 2.0 (:pep:`249`)."
msgstr "Ієрархія винятків визначається DB-API 2.0 (:pep:`249`)."

#: ../../library/sqlite3.rst:1647
msgid ""
"This exception is not currently raised by the :mod:`!sqlite3` module, but "
"may be raised by applications using :mod:`!sqlite3`, for example if a user-"
"defined function truncates data while inserting. ``Warning`` is a subclass "
"of :exc:`Exception`."
msgstr ""
"Это исключение в настоящее время не вызывается модулем :mod:`!sqlite3`, но "
"может быть вызвано приложениями, использующими :mod:`!sqlite3`, например, "
"если определяемая пользователем функция усекает данные при вставке. "
"``Warning`` является подклассом :exc:`Exception`."

#: ../../library/sqlite3.rst:1654
msgid ""
"The base class of the other exceptions in this module. Use this to catch all "
"errors with one single :keyword:`except` statement. ``Error`` is a subclass "
"of :exc:`Exception`."
msgstr ""
"Базовий клас інших винятків у цьому модулі. Використовуйте це, щоб "
"перехопити всі помилки за допомогою одного оператора :keyword:`except`. "
"``Error`` є підкласом :exc:`Exception`."

#: ../../library/sqlite3.rst:1658
msgid ""
"If the exception originated from within the SQLite library, the following "
"two attributes are added to the exception:"
msgstr ""
"Если исключение возникло из библиотеки SQLite, к исключению добавляются "
"следующие два атрибута:"

#: ../../library/sqlite3.rst:1663
msgid ""
"The numeric error code from the `SQLite API <https://sqlite.org/rescode."
"html>`_"
msgstr "Числовой код ошибки из `SQLite API <https://sqlite.org/rescode.html>`_"

#: ../../library/sqlite3.rst:1670
msgid ""
"The symbolic name of the numeric error code from the `SQLite API <https://"
"sqlite.org/rescode.html>`_"
msgstr ""
"Символическое имя числового кода ошибки из `SQLite API <https://sqlite.org/"
"rescode.html>`_"

#: ../../library/sqlite3.rst:1677
msgid ""
"Exception raised for misuse of the low-level SQLite C API. In other words, "
"if this exception is raised, it probably indicates a bug in the :mod:`!"
"sqlite3` module. ``InterfaceError`` is a subclass of :exc:`Error`."
msgstr ""
"Исключение возникло из-за неправильного использования низкоуровневого API "
"SQLite C. Другими словами, если это исключение возникает, это, вероятно, "
"указывает на ошибку в модуле :mod:`!sqlite3`. ``InterfaceError`` является "
"подклассом :exc:`Error`."

#: ../../library/sqlite3.rst:1684
msgid ""
"Exception raised for errors that are related to the database. This serves as "
"the base exception for several types of database errors. It is only raised "
"implicitly through the specialised subclasses. ``DatabaseError`` is a "
"subclass of :exc:`Error`."
msgstr ""
"Виняток створено для помилок, пов’язаних із базою даних. Це служить базовим "
"винятком для кількох типів помилок бази даних. Він виникає лише неявно через "
"спеціалізовані підкласи. ``DatabaseError`` є підкласом :exc:`Error`."

#: ../../library/sqlite3.rst:1691
msgid ""
"Exception raised for errors caused by problems with the processed data, like "
"numeric values out of range, and strings which are too long. ``DataError`` "
"is a subclass of :exc:`DatabaseError`."
msgstr ""
"Виняток створено для помилок, спричинених проблемами з обробленими даними, "
"як-от числові значення поза межами діапазону та надто довгі рядки. "
"``DataError`` є підкласом :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1697
msgid ""
"Exception raised for errors that are related to the database's operation, "
"and not necessarily under the control of the programmer. For example, the "
"database path is not found, or a transaction could not be processed. "
"``OperationalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"Виняток створено для помилок, які пов’язані з роботою бази даних і не "
"обов’язково знаходяться під контролем програміста. Наприклад, шлях до бази "
"даних не знайдено або транзакцію не вдалося обробити. ``OperationalError`` є "
"підкласом :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1705
msgid ""
"Exception raised when the relational integrity of the database is affected, "
"e.g. a foreign key check fails.  It is a subclass of :exc:`DatabaseError`."
msgstr ""
"Виняток виникає, коли порушується реляційна цілісність бази даних, "
"наприклад. не вдається перевірити зовнішній ключ. Це підклас :exc:"
"`DatabaseError`."

#: ../../library/sqlite3.rst:1710
msgid ""
"Exception raised when SQLite encounters an internal error. If this is "
"raised, it may indicate that there is a problem with the runtime SQLite "
"library. ``InternalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"Виняток виникає, коли SQLite стикається з внутрішньою помилкою. Якщо це "
"виникає, це може означати, що існує проблема з бібліотекою SQLite під час "
"виконання. ``InternalError`` є підкласом :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1717
msgid ""
"Exception raised for :mod:`!sqlite3` API programming errors, for example "
"supplying the wrong number of bindings to a query, or trying to operate on a "
"closed :class:`Connection`. ``ProgrammingError`` is a subclass of :exc:"
"`DatabaseError`."
msgstr ""
"Исключение возникает из-за ошибок программирования API :mod:`!sqlite3`, "
"например, предоставления неправильного количества привязок к запросу или "
"попытки работы с закрытым :class:`Соединением`. ``ProgrammingError`` "
"является подклассом :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1724
msgid ""
"Exception raised in case a method or database API is not supported by the "
"underlying SQLite library. For example, setting *deterministic* to ``True`` "
"in :meth:`~Connection.create_function`, if the underlying SQLite library "
"does not support deterministic functions. ``NotSupportedError`` is a "
"subclass of :exc:`DatabaseError`."
msgstr ""
"Исключение возникает в случае, если метод или API базы данных не "
"поддерживается базовой библиотекой SQLite. Например, установите для "
"параметра *deterministic* значение True в :meth:`~Connection."
"create_function`, если базовая библиотека SQLite не поддерживает "
"детерминированные функции. ``NotSupportedError`` является подклассом :exc:"
"`DatabaseError`."

#: ../../library/sqlite3.rst:1734
msgid "SQLite and Python types"
msgstr "SQLite dan tipe Python"

#: ../../library/sqlite3.rst:1736
msgid ""
"SQLite natively supports the following types: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."
msgstr ""
"SQLite спочатку підтримує такі типи: ``NULL``, ``INTEGER``, ``REAL``, "
"``TEXT``, ``BLOB``."

#: ../../library/sqlite3.rst:1739
msgid ""
"The following Python types can thus be sent to SQLite without any problem:"
msgstr ""
"Таким чином, такі типи Python можна без будь-яких проблем надсилати до "
"SQLite:"

#: ../../library/sqlite3.rst:1742 ../../library/sqlite3.rst:1759
msgid "Python type"
msgstr "Tipo em Python"

#: ../../library/sqlite3.rst:1742 ../../library/sqlite3.rst:1759
msgid "SQLite type"
msgstr "Tipo em SQLite"

#: ../../library/sqlite3.rst:1744 ../../library/sqlite3.rst:1761
msgid "``None``"
msgstr "``None``"

#: ../../library/sqlite3.rst:1744 ../../library/sqlite3.rst:1761
msgid "``NULL``"
msgstr "``NULL``"

#: ../../library/sqlite3.rst:1746 ../../library/sqlite3.rst:1763
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../library/sqlite3.rst:1746 ../../library/sqlite3.rst:1763
msgid "``INTEGER``"
msgstr "``INTEGER``"

#: ../../library/sqlite3.rst:1748 ../../library/sqlite3.rst:1765
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../library/sqlite3.rst:1748 ../../library/sqlite3.rst:1765
msgid "``REAL``"
msgstr "``REAL``"

#: ../../library/sqlite3.rst:1750
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../library/sqlite3.rst:1750 ../../library/sqlite3.rst:1767
msgid "``TEXT``"
msgstr "``TEXT``"

#: ../../library/sqlite3.rst:1752 ../../library/sqlite3.rst:1770
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../library/sqlite3.rst:1752 ../../library/sqlite3.rst:1770
msgid "``BLOB``"
msgstr "``BLOB``"

#: ../../library/sqlite3.rst:1756
msgid "This is how SQLite types are converted to Python types by default:"
msgstr "Ось як типи SQLite перетворюються на типи Python за замовчуванням:"

#: ../../library/sqlite3.rst:1767
msgid "depends on :attr:`~Connection.text_factory`, :class:`str` by default"
msgstr ""
"залежить від :attr:`~Connection.text_factory`, :class:`str` за замовчуванням"

#: ../../library/sqlite3.rst:1773
msgid ""
"The type system of the :mod:`!sqlite3` module is extensible in two ways: you "
"can store additional Python types in an SQLite database via :ref:`object "
"adapters <sqlite3-adapters>`, and you can let the :mod:`!sqlite3` module "
"convert SQLite types to Python types via :ref:`converters <sqlite3-"
"converters>`."
msgstr ""
"Система типов модуля :mod:`!sqlite3` расширяется двумя способами: вы можете "
"хранить дополнительные типы Python в базе данных SQLite через :ref:`object "
"адаптеры <sqlite3-adapters>`, и вы можете позволить :mod Модуль :`!sqlite3` "
"преобразует типы SQLite в типы Python с помощью :ref:`converters <sqlite3-"
"converters>`."

#: ../../library/sqlite3.rst:1783
msgid "Default adapters and converters"
msgstr ""

#: ../../library/sqlite3.rst:1785
msgid ""
"There are default adapters for the date and datetime types in the datetime "
"module. They will be sent as ISO dates/ISO timestamps to SQLite."
msgstr ""

#: ../../library/sqlite3.rst:1788
msgid ""
"The default converters are registered under the name \"date\" for :class:"
"`datetime.date` and under the name \"timestamp\" for :class:`datetime."
"datetime`."
msgstr ""

#: ../../library/sqlite3.rst:1792
msgid ""
"This way, you can use date/timestamps from Python without any additional "
"fiddling in most cases. The format of the adapters is also compatible with "
"the experimental SQLite date/time functions."
msgstr ""

#: ../../library/sqlite3.rst:1796
msgid "The following example demonstrates this."
msgstr ""

#: ../../library/sqlite3.rst:1800
msgid ""
"If a timestamp stored in SQLite has a fractional part longer than 6 numbers, "
"its value will be truncated to microsecond precision by the timestamp "
"converter."
msgstr ""

#: ../../library/sqlite3.rst:1806
msgid ""
"The default \"timestamp\" converter ignores UTC offsets in the database and "
"always returns a naive :class:`datetime.datetime` object. To preserve UTC "
"offsets in timestamps, either leave converters disabled, or register an "
"offset-aware converter with :func:`register_converter`."
msgstr ""
"Конвертер \"міток часу\" за замовчуванням ігнорує зміщення UTC у базі даних "
"і завжди повертає простий об’єкт :class:`datetime.datetime`. Щоб зберегти "
"зміщення UTC у мітках часу, залиште конвертери вимкненими або зареєструйте "
"конвертер із зсувом за допомогою :func:`register_converter`."

#: ../../library/sqlite3.rst:1815
msgid "How-to guides"
msgstr "Guias de como fazer"

#: ../../library/sqlite3.rst:1820
msgid "How to use placeholders to bind values in SQL queries"
msgstr "Как использовать заполнители для привязки значений в запросах SQL"

#: ../../library/sqlite3.rst:1822
msgid ""
"SQL operations usually need to use values from Python variables. However, "
"beware of using Python's string operations to assemble queries, as they are "
"vulnerable to `SQL injection attacks`_. For example, an attacker can simply "
"close the single quote and inject ``OR TRUE`` to select all rows::"
msgstr ""
"В операциях SQL обычно необходимо использовать значения переменных Python. "
"Однако остерегайтесь использования строковых операций Python для сборки "
"запросов, поскольку они уязвимы для атак с использованием SQL-инъекций. "
"Например, злоумышленник может просто закрыть одинарную кавычку и ввести ``OR "
"TRUE``, чтобы выбрать все строки:"

#: ../../library/sqlite3.rst:1835
msgid ""
"Instead, use the DB-API's parameter substitution. To insert a variable into "
"a query string, use a placeholder in the string, and substitute the actual "
"values into the query by providing them as a :class:`tuple` of values to the "
"second argument of the cursor's :meth:`~Cursor.execute` method."
msgstr ""
"Вместо этого используйте подстановку параметров DB-API. Чтобы вставить "
"переменную в строку запроса, используйте заполнитель в строке и подставьте "
"фактические значения в запрос, предоставив их в виде :class:`tuple` значений "
"для второго аргумента :meth:`~Cursor курсора. .execute` метод."

#: ../../library/sqlite3.rst:1840
msgid ""
"An SQL statement may use one of two kinds of placeholders: question marks "
"(qmark style) or named placeholders (named style). For the qmark style, "
"*parameters* must be a :term:`sequence` whose length must match the number "
"of placeholders, or a :exc:`ProgrammingError` is raised. For the named "
"style, *parameters* should be an instance of a :class:`dict` (or a "
"subclass), which must contain keys for all named parameters; any extra items "
"are ignored. Here's an example of both styles:"
msgstr ""

#: ../../library/sqlite3.rst:1877
msgid ""
":pep:`249` numeric placeholders are *not* supported. If used, they will be "
"interpreted as named placeholders."
msgstr ""
":pep:`249` числовые заполнители *не* поддерживаются. Если они используются, "
"они будут интерпретироваться как именованные заполнители."

#: ../../library/sqlite3.rst:1884
msgid "How to adapt custom Python types to SQLite values"
msgstr "Как адаптировать пользовательские типы Python к значениям SQLite"

#: ../../library/sqlite3.rst:1886
msgid ""
"SQLite supports only a limited set of data types natively. To store custom "
"Python types in SQLite databases, *adapt* them to one of the :ref:`Python "
"types SQLite natively understands <sqlite3-types>`."
msgstr ""
"SQLite изначально поддерживает только ограниченный набор типов данных. Чтобы "
"хранить пользовательские типы Python в базах данных SQLite, *адаптируйте* их "
"к одному из :ref:`типов Python, SQLite изначально понимает <sqlite3-types>`."

#: ../../library/sqlite3.rst:1890
msgid ""
"There are two ways to adapt Python objects to SQLite types: letting your "
"object adapt itself, or using an *adapter callable*. The latter will take "
"precedence above the former. For a library that exports a custom type, it "
"may make sense to enable that type to adapt itself. As an application "
"developer, it may make more sense to take direct control by registering "
"custom adapter functions."
msgstr ""
"Есть два способа адаптировать объекты Python к типам SQLite: позволить "
"вашему объекту адаптироваться самостоятельно или использовать *вызываемый "
"адаптер*. Последнее будет иметь приоритет над первым. Для библиотеки, "
"которая экспортирует пользовательский тип, возможно, имеет смысл разрешить "
"этому типу адаптироваться. Разработчику приложений, возможно, имеет смысл "
"взять на себя прямой контроль путем регистрации пользовательских функций "
"адаптера."

#: ../../library/sqlite3.rst:1902
msgid "How to write adaptable objects"
msgstr "Как писать адаптируемые объекты"

#: ../../library/sqlite3.rst:1904
msgid ""
"Suppose we have a :class:`!Point` class that represents a pair of "
"coordinates, ``x`` and ``y``, in a Cartesian coordinate system. The "
"coordinate pair will be stored as a text string in the database, using a "
"semicolon to separate the coordinates. This can be implemented by adding a "
"``__conform__(self, protocol)`` method which returns the adapted value. The "
"object passed to *protocol* will be of type :class:`PrepareProtocol`."
msgstr ""
"Предположим, у нас есть класс :class:`!Point`, который представляет пару "
"координат ``x`` и ``y`` в декартовой системе координат. Пара координат будет "
"храниться в базе данных в виде текстовой строки с использованием точки с "
"запятой для разделения координат. Это можно реализовать, добавив метод "
"``__conform__(self, протокол)``, который возвращает адаптированное значение. "
"Объект, передаваемый в *protocol*, будет иметь тип :class:`PrepareProtocol`."

#: ../../library/sqlite3.rst:1935
msgid "How to register adapter callables"
msgstr "Как зарегистрировать вызываемые объекты адаптера"

#: ../../library/sqlite3.rst:1937
msgid ""
"The other possibility is to create a function that converts the Python "
"object to an SQLite-compatible type. This function can then be registered "
"using :func:`register_adapter`."
msgstr ""
"Другая возможность — создать функцию, которая преобразует объект Python в "
"тип, совместимый с SQLite. Эту функцию затем можно зарегистрировать с "
"помощью :func:`register_adapter`."

#: ../../library/sqlite3.rst:1967
msgid "How to convert SQLite values to custom Python types"
msgstr "Как преобразовать значения SQLite в пользовательские типы Python"

#: ../../library/sqlite3.rst:1969
msgid ""
"Writing an adapter lets you convert *from* custom Python types *to* SQLite "
"values. To be able to convert *from* SQLite values *to* custom Python types, "
"we use *converters*."
msgstr ""
"Написание адаптера позволяет конвертировать *из* пользовательских типов "
"Python *в* значения SQLite. Чтобы иметь возможность конвертировать *из* "
"значений SQLite *в* пользовательские типы Python, мы используем *конвертеры*."

#: ../../library/sqlite3.rst:1974
msgid ""
"Let's go back to the :class:`!Point` class. We stored the x and y "
"coordinates separated via semicolons as strings in SQLite."
msgstr ""
"Давайте вернемся к классу :class:`!Point`. Мы сохранили координаты x и y, "
"разделенные точкой с запятой, в виде строк в SQLite."

#: ../../library/sqlite3.rst:1977
msgid ""
"First, we'll define a converter function that accepts the string as a "
"parameter and constructs a :class:`!Point` object from it."
msgstr ""
"Сначала мы определим функцию-конвертер, которая принимает строку в качестве "
"параметра и создает из нее объект :class:`!Point`."

#: ../../library/sqlite3.rst:1982
msgid ""
"Converter functions are **always** passed a :class:`bytes` object, no matter "
"the underlying SQLite data type."
msgstr ""
"Функциям преобразователя **всегда** передается объект :class:`bytes`, "
"независимо от базового типа данных SQLite."

#: ../../library/sqlite3.rst:1991
msgid ""
"We now need to tell :mod:`!sqlite3` when it should convert a given SQLite "
"value. This is done when connecting to a database, using the *detect_types* "
"parameter of :func:`connect`. There are three options:"
msgstr ""
"Теперь нам нужно сообщить :mod:`!sqlite3`, когда ему следует преобразовать "
"данное значение SQLite. Это делается при подключении к базе данных с "
"использованием параметра *detect_types* функции :func:`connect`. Есть три "
"варианта:"

#: ../../library/sqlite3.rst:1995
msgid "Implicit: set *detect_types* to :const:`PARSE_DECLTYPES`"
msgstr ""
"Неявно: установите для *detect_types* значение :const:`PARSE_DECLTYPES`"

#: ../../library/sqlite3.rst:1996
msgid "Explicit: set *detect_types* to :const:`PARSE_COLNAMES`"
msgstr "Явно: установите для *detect_types* значение :const:`PARSE_COLNAMES`"

#: ../../library/sqlite3.rst:1997
msgid ""
"Both: set *detect_types* to ``sqlite3.PARSE_DECLTYPES | sqlite3."
"PARSE_COLNAMES``. Column names take precedence over declared types."
msgstr ""
"Оба: установите для *detect_types* значение ``sqlite3.PARSE_DECLTYPES | "
"sqlite3.PARSE_COLNAMES``. Имена столбцов имеют приоритет над объявленными "
"типами."

#: ../../library/sqlite3.rst:2001
msgid "The following example illustrates the implicit and explicit approaches:"
msgstr "Следующий пример иллюстрирует неявный и явный подходы:"

#: ../../library/sqlite3.rst:2052
msgid "Adapter and converter recipes"
msgstr "Рецепты адаптеров и преобразователей"

#: ../../library/sqlite3.rst:2054
msgid "This section shows recipes for common adapters and converters."
msgstr ""
"В этом разделе показаны рецепты для распространенных адаптеров и "
"преобразователей."

#: ../../library/sqlite3.rst:2116
msgid "How to use connection shortcut methods"
msgstr "Как использовать методы быстрого подключения"

#: ../../library/sqlite3.rst:2118
msgid ""
"Using the :meth:`~Connection.execute`, :meth:`~Connection.executemany`, and :"
"meth:`~Connection.executescript` methods of the :class:`Connection` class, "
"your code can be written more concisely because you don't have to create the "
"(often superfluous) :class:`Cursor` objects explicitly. Instead, the :class:"
"`Cursor` objects are created implicitly and these shortcut methods return "
"the cursor objects. This way, you can execute a ``SELECT`` statement and "
"iterate over it directly using only a single call on the :class:`Connection` "
"object."
msgstr ""
"Используя методы :meth:`~Connection.execute`, :meth:`~Connection."
"executemany` и :meth:`~Connection.executescript` класса :class:`Connection`, "
"ваш код можно написать более кратко. потому что вам не нужно явно создавать "
"(часто лишние) объекты :class:`Cursor`. Вместо этого объекты :class:`Cursor` "
"создаются неявно, и эти методы быстрого доступа возвращают объекты курсора. "
"Таким образом, вы можете выполнить оператор ``SELECT`` и перебирать его "
"напрямую, используя только один вызов объекта :class:`Connection`."

#: ../../library/sqlite3.rst:2159
msgid "How to use the connection context manager"
msgstr "Как использовать менеджер контекста соединения"

#: ../../library/sqlite3.rst:2161
msgid ""
"A :class:`Connection` object can be used as a context manager that "
"automatically commits or rolls back open transactions when leaving the body "
"of the context manager. If the body of the :keyword:`with` statement "
"finishes without exceptions, the transaction is committed. If this commit "
"fails, or if the body of the ``with`` statement raises an uncaught "
"exception, the transaction is rolled back."
msgstr ""

#: ../../library/sqlite3.rst:2170
msgid ""
"If there is no open transaction upon leaving the body of the ``with`` "
"statement, the context manager is a no-op."
msgstr ""

#: ../../library/sqlite3.rst:2174
msgid ""
"The context manager neither implicitly opens a new transaction nor closes "
"the connection. If you need a closing context manager, consider using :meth:"
"`contextlib.closing`."
msgstr ""
"Менеджер контекста не открывает новую транзакцию неявно и не закрывает "
"соединение. Если вам нужен менеджер закрывающего контекста, рассмотрите "
"возможность использования :meth:`contextlib.closing`."

#: ../../library/sqlite3.rst:2208
msgid "How to work with SQLite URIs"
msgstr "Как работать с URI SQLite"

#: ../../library/sqlite3.rst:2210
msgid "Some useful URI tricks include:"
msgstr "Некоторые полезные приемы URI включают в себя:"

#: ../../library/sqlite3.rst:2212
msgid "Open a database in read-only mode:"
msgstr "Откройте базу данных в режиме только для чтения:"

#: ../../library/sqlite3.rst:2221
msgid ""
"Do not implicitly create a new database file if it does not already exist; "
"will raise :exc:`~sqlite3.OperationalError` if unable to create a new file:"
msgstr ""
"Не создавайте неявно новый файл базы данных, если он еще не существует; "
"вызовет :exc:`~sqlite3.OperationalError`, если не удастся создать новый файл:"

#: ../../library/sqlite3.rst:2231
msgid "Create a shared named in-memory database:"
msgstr "Создайте общую именованную базу данных в памяти:"

#: ../../library/sqlite3.rst:2245
msgid ""
"More information about this feature, including a list of parameters, can be "
"found in the `SQLite URI documentation`_."
msgstr ""
"Дополнительную информацию об этой функции, включая список параметров, можно "
"найти в `документации по URI SQLite`_."

#: ../../library/sqlite3.rst:2254
msgid "How to create and use row factories"
msgstr "Как создавать и использовать фабрики строк"

#: ../../library/sqlite3.rst:2256
msgid ""
"By default, :mod:`!sqlite3` represents each row as a :class:`tuple`. If a :"
"class:`!tuple` does not suit your needs, you can use the :class:`sqlite3."
"Row` class or a custom :attr:`~Cursor.row_factory`."
msgstr ""
"По умолчанию :mod:`!sqlite3` представляет каждую строку как :class:`tuple`. "
"Если :class:`!tuple` не соответствует вашим потребностям, вы можете "
"использовать класс :class:`sqlite3.Row` или собственный :attr:`~Cursor."
"row_factory`."

#: ../../library/sqlite3.rst:2261
msgid ""
"While :attr:`!row_factory` exists as an attribute both on the :class:"
"`Cursor` and the :class:`Connection`, it is recommended to set :class:"
"`Connection.row_factory`, so all cursors created from the connection will "
"use the same row factory."
msgstr ""
"Хотя :attr:`!row_factory` существует как атрибут как в :class:`Cursor`, так "
"и в :class:`Connection`, рекомендуется установить :class:`Connection."
"row_factory`, чтобы все курсоры, созданные из соединение будет использовать "
"ту же фабрику строк."

#: ../../library/sqlite3.rst:2266
msgid ""
":class:`!Row` provides indexed and case-insensitive named access to columns, "
"with minimal memory overhead and performance impact over a :class:`!tuple`. "
"To use :class:`!Row` as a row factory, assign it to the :attr:`!row_factory` "
"attribute:"
msgstr ""
":class:`!Row` обеспечивает индексированный и нечувствительный к регистру "
"именованный доступ к столбцам с минимальными затратами памяти и влиянием на "
"производительность по сравнению с :class:`!tuple`. Чтобы использовать :class:"
"`!Row` в качестве фабрики строк, назначьте его атрибуту :attr:`!row_factory`:"

#: ../../library/sqlite3.rst:2276
msgid "Queries now return :class:`!Row` objects:"
msgstr "Запросы теперь возвращают объекты :class:`!Row`:"

#: ../../library/sqlite3.rst:2293
msgid ""
"The ``FROM`` clause can be omitted in the ``SELECT`` statement, as in the "
"above example. In such cases, SQLite returns a single row with columns "
"defined by expressions, e.g. literals, with the given aliases ``expr AS "
"alias``."
msgstr ""
"Предложение FROM может быть опущено в операторе SELECT, как в приведенном "
"выше примере. В таких случаях SQLite возвращает одну строку со столбцами, "
"определенными выражениями, например литералами, с заданными псевдонимами "
"``expr AS alias``."

#: ../../library/sqlite3.rst:2298
msgid ""
"You can create a custom :attr:`~Cursor.row_factory` that returns each row as "
"a :class:`dict`, with column names mapped to values:"
msgstr ""
"Вы можете создать собственный :attr:`~Cursor.row_factory`, который "
"возвращает каждую строку как :class:`dict`, с именами столбцов, "
"сопоставленными со значениями:"

#: ../../library/sqlite3.rst:2307
msgid ""
"Using it, queries now return a :class:`!dict` instead of a :class:`!tuple`:"
msgstr ""
"Используя его, запросы теперь возвращают :class:`!dict` вместо :class:`!"
"tuple`:"

#: ../../library/sqlite3.rst:2317
msgid "The following row factory returns a :term:`named tuple`:"
msgstr "Следующая фабрика строк возвращает именованный кортеж:"

#: ../../library/sqlite3.rst:2328
msgid ":func:`!namedtuple_factory` can be used as follows:"
msgstr ":func:`!namedtuple_factory` можно использовать следующим образом:"

#: ../../library/sqlite3.rst:2343
msgid ""
"With some adjustments, the above recipe can be adapted to use a :class:"
"`~dataclasses.dataclass`, or any other custom class, instead of a :class:"
"`~collections.namedtuple`."
msgstr ""
"С некоторыми изменениями приведенный выше рецепт можно адаптировать для "
"использования :class:`~dataclasses.dataclass` или любого другого "
"пользовательского класса вместо :class:`~collections.namedtuple`."

#: ../../library/sqlite3.rst:2351
msgid "How to handle non-UTF-8 text encodings"
msgstr "Как обрабатывать текстовые кодировки, отличные от UTF-8"

#: ../../library/sqlite3.rst:2353
msgid ""
"By default, :mod:`!sqlite3` uses :class:`str` to adapt SQLite values with "
"the ``TEXT`` data type. This works well for UTF-8 encoded text, but it might "
"fail for other encodings and invalid UTF-8. You can use a custom :attr:"
"`~Connection.text_factory` to handle such cases."
msgstr ""
"По умолчанию :mod:`!sqlite3` использует :class:`str` для адаптации значений "
"SQLite к типу данных ``TEXT``. Это хорошо работает для текста в кодировке "
"UTF-8, но может не работать для других кодировок и недопустимого UTF-8. Для "
"обработки таких случаев вы можете использовать собственный :attr:"
"`~Connection.text_factory`."

#: ../../library/sqlite3.rst:2359
msgid ""
"Because of SQLite's `flexible typing`_, it is not uncommon to encounter "
"table columns with the ``TEXT`` data type containing non-UTF-8 encodings, or "
"even arbitrary data. To demonstrate, let's assume we have a database with "
"ISO-8859-2 (Latin-2) encoded text, for example a table of Czech-English "
"dictionary entries. Assuming we now have a :class:`Connection` instance :py:"
"data:`!con` connected to this database, we can decode the Latin-2 encoded "
"text using this :attr:`~Connection.text_factory`:"
msgstr ""
"Благодаря «гибкой типизации» SQLite нередко можно встретить столбцы таблицы "
"с типом данных «ТЕКСТ», содержащими кодировки, отличные от UTF-8, или даже "
"произвольные данные. Для демонстрации предположим, что у нас есть база "
"данных с текстом в кодировке ISO-8859-2 (Latin-2), например таблица статей "
"чешско-английского словаря. Предполагая, что теперь у нас есть экземпляр :"
"class:`Connection` :py:data:`!con`, подключенный к этой базе данных, мы "
"можем декодировать текст в кодировке Latin-2, используя этот :attr:"
"`~Connection.text_factory`:"

#: ../../library/sqlite3.rst:2372
msgid ""
"For invalid UTF-8 or arbitrary data in stored in ``TEXT`` table columns, you "
"can use the following technique, borrowed from the :ref:`unicode-howto`:"
msgstr ""
"Для недопустимых UTF-8 или произвольных данных, хранящихся в столбцах "
"таблицы ``TEXT``, вы можете использовать следующий метод, заимствованный из :"
"ref:`unicode-howto`:"

#: ../../library/sqlite3.rst:2381
msgid ""
"The :mod:`!sqlite3` module API does not support strings containing "
"surrogates."
msgstr ""
"API модуля :mod:`!sqlite3` не поддерживает строки, содержащие суррогаты."

#: ../../library/sqlite3.rst:2386
msgid ":ref:`unicode-howto`"
msgstr ":ref:`unicode-howto`"

#: ../../library/sqlite3.rst:2392
msgid "Explanation"
msgstr "Explicação"

#: ../../library/sqlite3.rst:2397
msgid "Transaction control"
msgstr "Controle de transações"

#: ../../library/sqlite3.rst:2399
msgid ""
"The :mod:`!sqlite3` module does not adhere to the transaction handling "
"recommended by :pep:`249`."
msgstr ""

#: ../../library/sqlite3.rst:2402
msgid ""
"If the connection attribute :attr:`~Connection.isolation_level` is not "
"``None``, new transactions are implicitly opened before :meth:`~Cursor."
"execute` and :meth:`~Cursor.executemany` executes ``INSERT``, ``UPDATE``, "
"``DELETE``, or ``REPLACE`` statements; for other statements, no implicit "
"transaction handling is performed. Use the :meth:`~Connection.commit` and :"
"meth:`~Connection.rollback` methods to respectively commit and roll back "
"pending transactions. You can choose the underlying `SQLite transaction "
"behaviour`_ — that is, whether and what type of ``BEGIN`` statements :mod:`!"
"sqlite3` implicitly executes – via the :attr:`~Connection.isolation_level` "
"attribute."
msgstr ""
"Se o atributo de conexão :attr:`~Connection.isolation_level` não for "
"``None``, novas transações são abertas implicitamente antes de :meth:"
"`~Cursor.execute` e :meth:`~Cursor.executemany` executa instruções "
"``INSERT``, ``UPDATE``, ``DELETE`` ou ``REPLACE``; para outras instruções, "
"nenhuma manipulação de transação implícita é executada. Use os métodos :meth:"
"`~Connection.commit` e :meth:`~Connection.rollback` para fazer commit e "
"reverter respectivamente transações pendentes. Você pode escolher o "
"`comportamento subjacente de transação do SQLite`_ -- isto é, se e que tipo "
"de instruções ``BEGIN`` do :mod:`!sqlite3` são executadas implicitamente -- "
"através do atributo :attr:`~Connection.isolation_level`."

#: ../../library/sqlite3.rst:2415
msgid ""
"If :attr:`~Connection.isolation_level` is set to ``None``, no transactions "
"are implicitly opened at all. This leaves the underlying SQLite library in "
"`autocommit mode`_, but also allows the user to perform their own "
"transaction handling using explicit SQL statements. The underlying SQLite "
"library autocommit mode can be queried using the :attr:`~Connection."
"in_transaction` attribute."
msgstr ""
"Se :attr:`~Connection.isolation_level` estiver definido como ``None``, "
"nenhuma transação será aberta implicitamente. Isso deixa a biblioteca SQLite "
"subjacente no `modo autocommit`_, mas também permite que o usuário execute "
"sua própria manipulação de transações usando instruções SQL explícitas. O "
"modo de autocommit da biblioteca SQLite subjacente pode ser consultado "
"usando o atributo :attr:`~Connection.in_transaction`."

#: ../../library/sqlite3.rst:2423
msgid ""
"The :meth:`~Cursor.executescript` method implicitly commits any pending "
"transaction before execution of the given SQL script, regardless of the "
"value of :attr:`~Connection.isolation_level`."
msgstr ""
"O método :meth:`~Cursor.executescript` compromete implicitamente qualquer "
"transação pendente antes da execução do script SQL fornecido, "
"independentemente do valor de :attr:`~Connection.isolation_level`."

#: ../../library/sqlite3.rst:2427
msgid ""
":mod:`!sqlite3` used to implicitly commit an open transaction before DDL "
"statements.  This is no longer the case."
msgstr ""
":mod:`!sqlite3` costumava fazer commit de forma implícita de uma transação "
"aberta antes das instruções DDL. Este não é mais o caso."

#: ../../library/sqlite3.rst:1312
msgid "? (question mark)"
msgstr "? (interrogação)"

#: ../../library/sqlite3.rst:1312 ../../library/sqlite3.rst:1313
msgid "in SQL statements"
msgstr "em instruções SQL"

#: ../../library/sqlite3.rst:1313
msgid ": (colon)"
msgstr ": (dois pontos)"

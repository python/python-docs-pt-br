# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Raphael Mendonça, 2021
# And Past <andrepgs@gmail.com>, 2021
# Adorilson Bezerra <adorilson@gmail.com>, 2024
# Pedro Fonini, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-25 14:19+0000\n"
"PO-Revision-Date: 2021-06-28 01:11+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/pickle.rst:2
msgid ":mod:`!pickle` --- Python object serialization"
msgstr ":mod:`!pickle` --- Serialização de objetos Python"

#: ../../library/pickle.rst:10
msgid "**Source code:** :source:`Lib/pickle.py`"
msgstr "**Código-fonte:** :source:`Lib/pickle.py`"

#: ../../library/pickle.rst:22
msgid ""
"The :mod:`pickle` module implements binary protocols for serializing and de-"
"serializing a Python object structure.  *\"Pickling\"* is the process "
"whereby a Python object hierarchy is converted into a byte stream, and "
"*\"unpickling\"* is the inverse operation, whereby a byte stream (from "
"a :term:`binary file` or :term:`bytes-like object`) is converted back into "
"an object hierarchy.  Pickling (and unpickling) is alternatively known as "
"\"serialization\", \"marshalling,\" [#]_ or \"flattening\"; however, to "
"avoid confusion, the terms used here are \"pickling\" and \"unpickling\"."
msgstr ""
"O módulo :mod:`pickle` implementa protocolos binários para serializar e "
"desserializar uma estrutura de objeto Python. *\"Pickling\"* é o processo "
"pelo qual uma hierarquia de objetos Python é convertida em um fluxo de "
"bytes, e *\"unpickling\"* é a operação inversa, em que um fluxo de bytes (de "
"um :term:`arquivo binário` ou :term:`objeto byte ou similar`) é convertido "
"de volta em uma hierarquia de objetos. Pickling (e unpickling) com pickle é "
"alternativamente conhecido como \"serialização\", \"marshalling\" [#]_ ou "
"\"flattening\"; no entanto, para evitar confusão, usa-se is termos "
"\"pickling\" e \"unpickling\". Nesta documentação traduzida, usaremos "
"\"serialização com pickle\" e \"desserialização com pickle\", "
"respectivamente."

#: ../../library/pickle.rst:33
msgid "The ``pickle`` module **is not secure**. Only unpickle data you trust."
msgstr ""
"O módulo ``pickle`` **não é seguro**. Desserialize com pickle apenas os "
"dados em que você confia."

#: ../../library/pickle.rst:35
msgid ""
"It is possible to construct malicious pickle data which will **execute "
"arbitrary code during unpickling**. Never unpickle data that could have come "
"from an untrusted source, or that could have been tampered with."
msgstr ""
"É possível construir dados maliciosos em pickle que irão **executar código "
"arbitrário durante o processo de desserialização com pickle**. Nunca "
"desserialize com pickle os dados que possam vir de uma fonte não confiável "
"ou que possam ter sido adulterados."

#: ../../library/pickle.rst:39
msgid ""
"Consider signing data with :mod:`hmac` if you need to ensure that it has not "
"been tampered with."
msgstr ""
"Considere assinar dados com :mod:`hmac` se você precisar garantir que eles "
"não foram adulterados."

#: ../../library/pickle.rst:42
msgid ""
"Safer serialization formats such as :mod:`json` may be more appropriate if "
"you are processing untrusted data. See :ref:`comparison-with-json`."
msgstr ""
"Formatos de serialização mais seguros como :mod:`json` podem ser mais "
"apropriados se você estiver processando dados não confiáveis. "
"Vejo :ref:`comparison-with-json`."

#: ../../library/pickle.rst:47
msgid "Relationship to other Python modules"
msgstr "Relacionamento com outros módulos Python"

#: ../../library/pickle.rst:50
msgid "Comparison with ``marshal``"
msgstr "Comparação com ``marshal``"

#: ../../library/pickle.rst:52
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, but "
"in general :mod:`pickle` should always be the preferred way to serialize "
"Python objects.  :mod:`marshal` exists primarily to support "
"Python's :file:`.pyc` files."
msgstr ""
"Python tem um módulo de serialização mais primitivo chamado :mod:`marshal`, "
"mas em geral :mod:`pickle` deve ser sempre a forma preferida de serializar "
"objetos Python. :mod:`marshal` existe principalmente para oferecer suporte a "
"arquivos :file:`.pyc` do Python."

#: ../../library/pickle.rst:57
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several significant "
"ways:"
msgstr ""
"O módulo :mod:`pickle` difere do :mod:`marshal` de várias maneiras "
"significativas:"

#: ../../library/pickle.rst:59
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be serialized "
"again. :mod:`marshal` doesn't do this."
msgstr ""
"O módulo :mod:`pickle` mantém o controle dos objetos que já serializou, para "
"que referências posteriores ao mesmo objeto não sejam serializadas "
"novamente. :mod:`marshal` não faz isso."

#: ../../library/pickle.rst:63
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  These "
"are not handled by marshal, and in fact, attempting to marshal recursive "
"objects will crash your Python interpreter.  Object sharing happens when "
"there are multiple references to the same object in different places in the "
"object hierarchy being serialized.  :mod:`pickle` stores such objects only "
"once, and ensures that all other references point to the master copy.  "
"Shared objects remain shared, which can be very important for mutable "
"objects."
msgstr ""
"Isso tem implicações tanto para objetos recursivos quanto para "
"compartilhamento de objetos. Objetos recursivos são objetos que contêm "
"referências a si mesmos. Eles não são tratados pelo marshal e, de fato, "
"tentar usar marshal em objetos recursivos irá travar seu interpretador "
"Python. O compartilhamento de objetos ocorre quando há várias referências ao "
"mesmo objeto em locais diferentes na hierarquia de objetos sendo "
"serializados. :mod:`pickle` armazena tais objetos apenas uma vez, e garante "
"que todas as outras referências apontem para a cópia mestre. Os objetos "
"compartilhados permanecem compartilhados, o que pode ser muito importante "
"para objetos mutáveis."

#: ../../library/pickle.rst:72
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their "
"instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live in "
"the same module as when the object was stored."
msgstr ""
":mod:`marshal` não pode ser usado para serializar classes definidas pelo "
"usuário e suas instâncias. :mod:`pickle` pode salvar e restaurar instâncias "
"de classe de forma transparente, no entanto, a definição de classe deve ser "
"importável e viver no mesmo módulo de quando o objeto foi armazenado."

#: ../../library/pickle.rst:77
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to "
"support :file:`.pyc` files, the Python implementers reserve the right to "
"change the serialization format in non-backwards compatible ways should the "
"need arise. The :mod:`pickle` serialization format is guaranteed to be "
"backwards compatible across Python releases provided a compatible pickle "
"protocol is chosen and pickling and unpickling code deals with Python 2 to "
"Python 3 type differences if your data is crossing that unique breaking "
"change language boundary."
msgstr ""
"O formato de serialização do :mod:`marshal` não tem garantia de "
"portabilidade entre as versões do Python. Como sua principal tarefa em vida "
"é oferecer suporte a arquivos :file:`.pyc`, os implementadores do Python se "
"reservam o direito de alterar o formato de serialização de maneiras não "
"compatíveis com versões anteriores, caso haja necessidade. O formato de "
"serialização do :mod:`pickle` tem a garantia de ser compatível com versões "
"anteriores em todas as versões do Python, desde que um protocolo pickle "
"compatível seja escolhido e o código de serialização e desserialização com "
"pickle lide com diferenças de tipo Python 2 a Python 3 se seus dados "
"estiverem cruzando aquele limite de mudança de linguagem exclusivo."

#: ../../library/pickle.rst:90
msgid "Comparison with ``json``"
msgstr "Comparação com ``json``"

#: ../../library/pickle.rst:92
msgid ""
"There are fundamental differences between the pickle protocols and `JSON "
"(JavaScript Object Notation) <https://json.org>`_:"
msgstr ""
"Existem diferenças fundamentais entre os protocolos pickle e `JSON "
"(JavaScript Object Notation) <https://json.org>`_:"

#: ../../library/pickle.rst:95
msgid ""
"JSON is a text serialization format (it outputs unicode text, although most "
"of the time it is then encoded to ``utf-8``), while pickle is a binary "
"serialization format;"
msgstr ""
"JSON é um formato de serialização de texto (ele produz texto unicode, embora "
"na maioria das vezes seja codificado para ``utf-8``), enquanto pickle é um "
"formato de serialização binário;"

#: ../../library/pickle.rst:99
msgid "JSON is human-readable, while pickle is not;"
msgstr "JSON é legível por humanos, enquanto pickle não é;"

#: ../../library/pickle.rst:101
msgid ""
"JSON is interoperable and widely used outside of the Python ecosystem, while "
"pickle is Python-specific;"
msgstr ""
"JSON é interoperável e amplamente usado fora do ecossistema Python, enquanto "
"pickle é específico para Python;"

#: ../../library/pickle.rst:104
msgid ""
"JSON, by default, can only represent a subset of the Python built-in types, "
"and no custom classes; pickle can represent an extremely large number of "
"Python types (many of them automatically, by clever usage of Python's "
"introspection facilities; complex cases can be tackled by "
"implementing :ref:`specific object APIs <pickle-inst>`);"
msgstr ""
"JSON, por padrão, só pode representar um subconjunto dos tipos embutidos do "
"Python, e nenhuma classe personalizada; pickle pode representar um número "
"extremamente grande de tipos Python (muitos deles automaticamente, pelo uso "
"inteligente dos recursos de introspecção do Python; casos complexos podem "
"ser resolvidos implementando :ref:`APIs de objetos específicos <pickle-"
"inst>`);"

#: ../../library/pickle.rst:110
msgid ""
"Unlike pickle, deserializing untrusted JSON does not in itself create an "
"arbitrary code execution vulnerability."
msgstr ""
"Ao contrário do pickle, a desserialização não confiável do JSON não cria, "
"por si só, uma vulnerabilidade de execução de código arbitrário."

#: ../../library/pickle.rst:114
msgid ""
"The :mod:`json` module: a standard library module allowing JSON "
"serialization and deserialization."
msgstr ""
"O módulo :mod:`json`: um módulo de biblioteca padrão que permite a "
"serialização e desserialização JSON."

#: ../../library/pickle.rst:121
msgid "Data stream format"
msgstr "Formato de fluxo de dados"

#: ../../library/pickle.rst:126
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards such "
"as JSON (which can't represent pointer sharing); however it means that non-"
"Python programs may not be able to reconstruct pickled Python objects."
msgstr ""
"O formato de dados usado pelo :mod:`pickle` é específico do Python. Isso tem "
"a vantagem de não haver restrições impostas por padrões externos, como JSON "
"(que não pode representar o compartilhamento de ponteiros); no entanto, isso "
"significa que programas não Python podem não ser capazes de reconstruir "
"objetos Python serializados com pickle."

#: ../../library/pickle.rst:131
msgid ""
"By default, the :mod:`pickle` data format uses a relatively compact binary "
"representation.  If you need optimal size characteristics, you can "
"efficiently :doc:`compress <archiving>` pickled data."
msgstr ""
"Por padrão, o formato de dados do :mod:`pickle` usa uma representação "
"binária relativamente compacta. Se você precisa de características de "
"tamanho ideal, pode com eficiência :doc:`comprimir <archiving>` dados "
"processados com pickle."

#: ../../library/pickle.rst:135
msgid ""
"The module :mod:`pickletools` contains tools for analyzing data streams "
"generated by :mod:`pickle`.  :mod:`pickletools` source code has extensive "
"comments about opcodes used by pickle protocols."
msgstr ""
"O módulo :mod:`pickletools` contém ferramentas para analisar fluxos de dados "
"gerados por :mod:`pickle`. O código-fonte do :mod:`pickletools` tem extensos "
"comentários sobre códigos de operações usados por protocolos de pickle."

#: ../../library/pickle.rst:139
msgid ""
"There are currently 6 different protocols which can be used for pickling. "
"The higher the protocol used, the more recent the version of Python needed "
"to read the pickle produced."
msgstr ""
"Existem atualmente 6 protocolos diferentes que podem ser usados para a "
"serialização com pickle. Quanto mais alto o protocolo usado, mais recente é "
"a versão do Python necessária para ler o pickle produzido."

#: ../../library/pickle.rst:143
msgid ""
"Protocol version 0 is the original \"human-readable\" protocol and is "
"backwards compatible with earlier versions of Python."
msgstr ""
"A versão 0 do protocolo é o protocolo original \"legível por humanos\" e é "
"compatível com versões anteriores do Python."

#: ../../library/pickle.rst:146
msgid ""
"Protocol version 1 is an old binary format which is also compatible with "
"earlier versions of Python."
msgstr ""
"A versão 1 do protocolo é um formato binário antigo que também é compatível "
"com versões anteriores do Python."

#: ../../library/pickle.rst:149
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style classes <new-style class>`.  Refer "
"to :pep:`307` for information about improvements brought by protocol 2."
msgstr ""
"A versão 2 do protocolo foi introduzida no Python 2.3. Ela fornece uma "
"serialização com pickle muito mais eficiente de :term:`classes estilo novo "
"<new-style class>`. Consulte :pep:`307` para obter informações sobre as "
"melhorias trazidas pelo protocolo 2."

#: ../../library/pickle.rst:153
msgid ""
"Protocol version 3 was added in Python 3.0.  It has explicit support "
"for :class:`bytes` objects and cannot be unpickled by Python 2.x.  This was "
"the default protocol in Python 3.0--3.7."
msgstr ""
"A versão 3 do protocolo foi adicionada ao Python 3.0. Ela tem suporte "
"explícito a objetos :class:`bytes` e não é possível desserializar com pickle "
"a partir do Python 2.x. Este era o protocolo padrão no Python 3.0--3.7."

#: ../../library/pickle.rst:157
msgid ""
"Protocol version 4 was added in Python 3.4.  It adds support for very large "
"objects, pickling more kinds of objects, and some data format "
"optimizations.  It is the default protocol starting with Python 3.8. Refer "
"to :pep:`3154` for information about improvements brought by protocol 4."
msgstr ""
"A versão 4 do protocolo foi adicionada ao Python 3.4. Ela adiciona suporte "
"para objetos muito grandes, serialização com pickle de mais tipos de objetos "
"e algumas otimizações de formato de dados. É o protocolo padrão a partir do "
"Python 3.8. Consulte :pep:`3154` para obter informações sobre as melhorias "
"trazidas pelo protocolo 4."

#: ../../library/pickle.rst:163
msgid ""
"Protocol version 5 was added in Python 3.8.  It adds support for out-of-band "
"data and speedup for in-band data.  Refer to :pep:`574` for information "
"about improvements brought by protocol 5."
msgstr ""
"A versão 5 do protocolo foi adicionada ao Python 3.8. Ela adiciona suporte a "
"dados fora da banda e aumento de velocidade para dados dentro da banda. "
"Consulte :pep:`574` para obter informações sobre as melhorias trazidas pelo "
"protocolo 5."

#: ../../library/pickle.rst:168
msgid ""
"Serialization is a more primitive notion than persistence; "
"although :mod:`pickle` reads and writes file objects, it does not handle the "
"issue of naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the byte "
"stream into an object with the same internal structure.  Perhaps the most "
"obvious thing to do with these byte streams is to write them onto a file, "
"but it is also conceivable to send them across a network or store them in a "
"database.  The :mod:`shelve` module provides a simple interface to pickle "
"and unpickle objects on DBM-style database files."
msgstr ""
"A serialização é uma noção mais primitiva do que a persistência; embora "
"o :mod:`pickle` leia e escreva objetos de arquivo, ele não lida com a "
"questão de nomear objetos persistentes, nem a questão (ainda mais "
"complicada) de acesso simultâneo a objetos persistentes. O "
"módulo :mod:`pickle` pode transformar um objeto complexo em um fluxo de "
"bytes e pode transformar o fluxo de bytes em um objeto com a mesma estrutura "
"interna. Talvez a coisa mais óbvia a fazer com esses fluxos de bytes seja "
"escrevê-los em um arquivo, mas também é concebível enviá-los através de uma "
"rede ou armazená-los em um banco de dados. O módulo :mod:`shelve` fornece "
"uma interface simples para serializar e desserializar com pickle os objetos "
"em arquivos de banco de dados no estilo DBM."

#: ../../library/pickle.rst:181
msgid "Module Interface"
msgstr "Interface do módulo"

#: ../../library/pickle.rst:183
msgid ""
"To serialize an object hierarchy, you simply call the :func:`dumps` "
"function. Similarly, to de-serialize a data stream, you call "
"the :func:`loads` function. However, if you want more control over "
"serialization and de-serialization, you can create a :class:`Pickler` or "
"an :class:`Unpickler` object, respectively."
msgstr ""
"Para serializar uma hierarquia de objeto, você simplesmente chama a "
"função :func:`dumps`. Da mesma forma, para desserializar um fluxo de dados, "
"você chama a função :func:`loads`. No entanto, se você quiser mais controle "
"sobre a serialização e desserialização, pode criar um "
"objeto :class:`Pickler` ou :class:`Unpickler`, respectivamente."

#: ../../library/pickle.rst:188
msgid "The :mod:`pickle` module provides the following constants:"
msgstr "O módulo :mod:`pickle` fornece as seguintes constantes:"

#: ../../library/pickle.rst:193
msgid ""
"An integer, the highest :ref:`protocol version <pickle-protocols>` "
"available.  This value can be passed as a *protocol* value to "
"functions :func:`dump` and :func:`dumps` as well as the :class:`Pickler` "
"constructor."
msgstr ""
"Um inteiro, a mais alta :ref:`versão de protocolo <pickle-protocols>` "
"disponível. Este valor pode ser passado como um valor de *protocol* para as "
"funções :func:`dump` e :func:`dumps`, bem como o construtor "
"de :class:`Pickler`."

#: ../../library/pickle.rst:200
msgid ""
"An integer, the default :ref:`protocol version <pickle-protocols>` used for "
"pickling.  May be less than :data:`HIGHEST_PROTOCOL`.  Currently the default "
"protocol is 4, first introduced in Python 3.4 and incompatible with previous "
"versions."
msgstr ""
"Um inteiro, a :ref:`versão de protocolo <pickle-protocols>` padrão usada "
"para a serialização com pickle. Pode ser menor que :data:`HIGHEST_PROTOCOL`. "
"Atualmente, o protocolo padrão é 4, introduzido pela primeira vez no Python "
"3.4 e incompatível com as versões anteriores."

#: ../../library/pickle.rst:207
msgid "The default protocol is 3."
msgstr "O protocolo padrão é 3."

#: ../../library/pickle.rst:211
msgid "The default protocol is 4."
msgstr "O protocolo padrão é 4."

#: ../../library/pickle.rst:213
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr ""
"O módulo :mod:`pickle` fornece as seguintes funções para tornar o processo "
"de serialização com pickle mais conveniente:"

#: ../../library/pickle.rst:218
msgid ""
"Write the pickled representation of the object *obj* to the open :term:`file "
"object` *file*.  This is equivalent to ``Pickler(file, protocol).dump(obj)``."
msgstr ""
"Escreve a representação após a serialização com pickle do objeto *obj* "
"no :term:`objeto arquivo` aberto *file*. Isso é equivalente a "
"``Pickler(file, protocol).dump(obj)``."

#: ../../library/pickle.rst:222
msgid ""
"Arguments *file*, *protocol*, *fix_imports* and *buffer_callback* have the "
"same meaning as in the :class:`Pickler` constructor."
msgstr ""
"Os argumentos *file*, *protocol*, *fix_imports* e *buffer_callback* têm o "
"mesmo sentido que no construtor de :class:`Pickler`."

#: ../../library/pickle.rst:225 ../../library/pickle.rst:236
#: ../../library/pickle.rst:328
msgid "The *buffer_callback* argument was added."
msgstr "O argumento *buffer_callback* foi adicionado."

#: ../../library/pickle.rst:230
msgid ""
"Return the pickled representation of the object *obj* as a :class:`bytes` "
"object, instead of writing it to a file."
msgstr ""
"Retorna a representação em após a serialização com pickle do objeto *obj* "
"como um objeto :class:`bytes`, ao invés de escrevê-lo em um arquivo."

#: ../../library/pickle.rst:233
msgid ""
"Arguments *protocol*, *fix_imports* and *buffer_callback* have the same "
"meaning as in the :class:`Pickler` constructor."
msgstr ""
"Os argumentos *protocol*, *fix_imports* e *buffer_callback* têm o mesmo "
"sentido que no construtor de :class:`Pickler`."

#: ../../library/pickle.rst:241
msgid ""
"Read the pickled representation of an object from the open :term:`file "
"object` *file* and return the reconstituted object hierarchy specified "
"therein. This is equivalent to ``Unpickler(file).load()``."
msgstr ""
"Lê a representação serializada com pickle de um objeto a partir "
"de :term:`objeto arquivo` aberto *file* e retorna a hierarquia de objeto "
"reconstituído especificada nele. Isso é equivalente a "
"``Unpickler(file).load()``."

#: ../../library/pickle.rst:245 ../../library/pickle.rst:260
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed.  Bytes past the pickled representation of the object are "
"ignored."
msgstr ""
"A versão do protocolo pickle é detectada automaticamente, portanto, nenhum "
"argumento de protocolo é necessário. Bytes após a representação serializada "
"com pickle do objeto são ignorados."

#: ../../library/pickle.rst:249
msgid ""
"Arguments *file*, *fix_imports*, *encoding*, *errors*, *strict* and "
"*buffers* have the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"Os argumentos *file*, *fix_imports*, *encoding*, *errors*, *strict* e "
"*buffers* têm o mesmo significado que no construtor "
"construtor :class:`Unpickler`."

#: ../../library/pickle.rst:252 ../../library/pickle.rst:267
#: ../../library/pickle.rst:433
msgid "The *buffers* argument was added."
msgstr "O argumento *buffers* foi adicionado."

#: ../../library/pickle.rst:257
msgid ""
"Return the reconstituted object hierarchy of the pickled representation "
"*data* of an object. *data* must be a :term:`bytes-like object`."
msgstr ""
"Retorna a hierarquia de objeto reconstituído da representação serializada "
"com pickle *data* de um objeto. *data* deve ser um :term:`objeto byte ou "
"similar`."

#: ../../library/pickle.rst:264
msgid ""
"Arguments *fix_imports*, *encoding*, *errors*, *strict* and *buffers* have "
"the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"Os argumentos *fix_imports*, *encoding*, *errors*, *strict* e *buffers* têm "
"o mesmo significado que no construtor construtor :class:`Unpickler`."

#: ../../library/pickle.rst:271
msgid "The :mod:`pickle` module defines three exceptions:"
msgstr "O módulo :mod:`pickle` define três exceções:"

#: ../../library/pickle.rst:275
msgid ""
"Common base class for the other pickling exceptions.  It inherits "
"from :exc:`Exception`."
msgstr ""
"Classe base comum para as outras exceções de serialização com pickle. Herda "
"de :exc:`Exception`."

#: ../../library/pickle.rst:280
msgid ""
"Error raised when an unpicklable object is encountered by :class:`Pickler`. "
"It inherits from :exc:`PickleError`."
msgstr ""
"Erro levantado quando um objeto não serializável com pickle é encontrado "
"por :class:`Pickler`. Herda de :exc:`PickleError`."

#: ../../library/pickle.rst:283
msgid ""
"Refer to :ref:`pickle-picklable` to learn what kinds of objects can be "
"pickled."
msgstr ""
"Consulte :ref:`pickle-picklable` para saber quais tipos de objetos podem ser "
"serializados com pickle."

#: ../../library/pickle.rst:288
msgid ""
"Error raised when there is a problem unpickling an object, such as a data "
"corruption or a security violation.  It inherits from :exc:`PickleError`."
msgstr ""
"Erro levantado quando há um problema ao desserializar com pickle um objeto, "
"como dados corrompidos ou violação de segurança. Herda de :exc:`PickleError`."

#: ../../library/pickle.rst:291
msgid ""
"Note that other exceptions may also be raised during unpickling, including "
"(but not necessarily limited to) AttributeError, EOFError, ImportError, and "
"IndexError."
msgstr ""
"Observe que outras exceções também podem ser levantadas durante a "
"desserialização com pickle, incluindo (mas não necessariamente limitado a) "
"AttributeError, EOFError, ImportError e IndexError."

#: ../../library/pickle.rst:296
msgid ""
"The :mod:`pickle` module exports three "
"classes, :class:`Pickler`, :class:`Unpickler` and :class:`PickleBuffer`:"
msgstr ""
"O módulo :mod:`pickle` exporta três "
"classes, :class:`Pickler`, :class:`Unpickler` e :class:`PickleBuffer`:"

#: ../../library/pickle.rst:301
msgid "This takes a binary file for writing a pickle data stream."
msgstr "Isso leva um arquivo binário a escrever um fluxo de dados pickle."

#: ../../library/pickle.rst:303
msgid ""
"The optional *protocol* argument, an integer, tells the pickler to use the "
"given protocol; supported protocols are 0 to :data:`HIGHEST_PROTOCOL`. If "
"not specified, the default is :data:`DEFAULT_PROTOCOL`.  If a negative "
"number is specified, :data:`HIGHEST_PROTOCOL` is selected."
msgstr ""
"O argumento opcional *protocol*, um inteiro, diz ao pickler para usar o "
"protocolo fornecido; os protocolos suportados são de 0 "
"a :data:`HIGHEST_PROTOCOL`. Se não for especificado, o padrão "
"é :data:`DEFAULT_PROTOCOL`. Se um número negativo for "
"especificado, :data:`HIGHEST_PROTOCOL` é selecionado."

#: ../../library/pickle.rst:308
msgid ""
"The *file* argument must have a write() method that accepts a single bytes "
"argument.  It can thus be an on-disk file opened for binary writing, "
"an :class:`io.BytesIO` instance, or any other custom object that meets this "
"interface."
msgstr ""
"O argumento *file* deve ter um método write() que aceite um argumento de um "
"único byte. Portanto, pode ser um arquivo em disco aberto para escrita "
"binária, uma instância :class:`io.BytesIO` ou qualquer outro objeto "
"personalizado que atenda a esta interface."

#: ../../library/pickle.rst:313
msgid ""
"If *fix_imports* is true and *protocol* is less than 3, pickle will try to "
"map the new Python 3 names to the old module names used in Python 2, so that "
"the pickle data stream is readable with Python 2."
msgstr ""
"Se *fix_imports* for verdadeiro e *protocolo* for menor que 3, pickle "
"tentará mapear os novos nomes do Python 3 para os nomes dos módulos antigos "
"usados no Python 2, de modo que o fluxo de dados pickle seja legível com o "
"Python 2."

#: ../../library/pickle.rst:317
msgid ""
"If *buffer_callback* is ``None`` (the default), buffer views are serialized "
"into *file* as part of the pickle stream."
msgstr ""
"Se *buffer_callback* for ``None`` (o padrão), as visualizações de buffer são "
"serializadas em *file* como parte do fluxo pickle."

#: ../../library/pickle.rst:320
msgid ""
"If *buffer_callback* is not ``None``, then it can be called any number of "
"times with a buffer view.  If the callback returns a false value (such as "
"``None``), the given buffer is :ref:`out-of-band <pickle-oob>`; otherwise "
"the buffer is serialized in-band, i.e. inside the pickle stream."
msgstr ""
"Se *buffer_callback* não for ``None``, ele pode ser chamado qualquer número "
"de vezes com uma visualização de buffer. Se essa chamada retornar um valor "
"falso (tal como ``None``), o buffer fornecido é :ref:`fora da banda <pickle-"
"oob>`; caso contrário, o buffer é serializado dentro da banda, ou seja, "
"dentro do fluxo pickle."

#: ../../library/pickle.rst:325
msgid ""
"It is an error if *buffer_callback* is not ``None`` and *protocol* is "
"``None`` or smaller than 5."
msgstr ""
"É um erro se *buffer_callback* não for ``None`` e *protocol* for ``None`` ou "
"menor que 5."

#: ../../library/pickle.rst:333
msgid ""
"Write the pickled representation of *obj* to the open file object given in "
"the constructor."
msgstr ""
"Escreve a representação serializada em pickle de *obj* no objeto arquivo "
"aberto fornecido no construtor."

#: ../../library/pickle.rst:338
msgid "Do nothing by default.  This exists so a subclass can override it."
msgstr ""
"Não faz nada por padrão. Isso existe para que uma subclasse possa substituí-"
"lo."

#: ../../library/pickle.rst:340
msgid ""
"If :meth:`persistent_id` returns ``None``, *obj* is pickled as usual.  Any "
"other value causes :class:`Pickler` to emit the returned value as a "
"persistent ID for *obj*.  The meaning of this persistent ID should be "
"defined by :meth:`Unpickler.persistent_load`.  Note that the value returned "
"by :meth:`persistent_id` cannot itself have a persistent ID."
msgstr ""
"Se :meth:`persistent_id` retornar ``None``, *obj* é serializado com pickle "
"como de costume. Qualquer outro valor faz com que :class:`Pickler` emita o "
"valor retornado como um ID persistente para *obj*. O significado deste ID "
"persistente deve ser definido por :meth:`Unpickler.persistent_load`. Observe "
"que o valor retornado por :meth:`persistent_id` não pode ter um ID "
"persistente."

#: ../../library/pickle.rst:346 ../../library/pickle.rst:451
msgid "See :ref:`pickle-persistent` for details and examples of uses."
msgstr "Consulte :ref:`pickle-persistent` para detalhes e exemplos de usos."

#: ../../library/pickle.rst:348
msgid ""
"Add the default implementation of this method in the C implementation "
"of :class:`!Pickler`."
msgstr ""
"Foi adicionada a implementação padrão desse método na implementação em C "
"da :class:`!Pickler`."

#: ../../library/pickle.rst:354
msgid ""
"A pickler object's dispatch table is a registry of *reduction functions* of "
"the kind which can be declared using :func:`copyreg.pickle`.  It is a "
"mapping whose keys are classes and whose values are reduction functions.  A "
"reduction function takes a single argument of the associated class and "
"should conform to the same interface as a :meth:`~object.__reduce__` method."
msgstr ""
"A tabela de despacho de um objeto pickler é um registro de *funções de "
"redução* do tipo que pode ser declarado usando :func:`copyreg.pickle`. É um "
"mapeamento cujas chaves são classes e cujos valores são funções de redução. "
"Uma função de redução leva um único argumento da classe associada e deve "
"estar de acordo com a mesma interface de um "
"método :meth:`~object.__reduce__`."

#: ../../library/pickle.rst:362
msgid ""
"By default, a pickler object will not have a :attr:`dispatch_table` "
"attribute, and it will instead use the global dispatch table managed by "
"the :mod:`copyreg` module. However, to customize the pickling for a specific "
"pickler object one can set the :attr:`dispatch_table` attribute to a dict-"
"like object.  Alternatively, if a subclass of :class:`Pickler` has "
"a :attr:`dispatch_table` attribute then this will be used as the default "
"dispatch table for instances of that class."
msgstr ""
"Por padrão, um objeto pickler não terá um atributo :attr:`dispatch_table`, e "
"em vez disso usará a tabela de despacho global gerenciada pelo "
"módulo :mod:`copyreg`. No entanto, para personalizar a serialização com "
"pickle de um objeto pickler específico, pode-se definir o "
"atributo :attr:`dispatch_table` para um objeto do tipo dict. "
"Alternativamente, se uma subclasse de :class:`Pickler` tem um "
"atributo :attr:`dispatch_table` então ele será usado como a tabela de "
"despacho padrão para instâncias daquela classe."

#: ../../library/pickle.rst:371
msgid "See :ref:`pickle-dispatch` for usage examples."
msgstr "Consulte :ref:`pickle-dispatch` para exemplos de uso."

#: ../../library/pickle.rst:377
msgid ""
"Special reducer that can be defined in :class:`Pickler` subclasses. This "
"method has priority over any reducer in the :attr:`dispatch_table`.  It "
"should conform to the same interface as a :meth:`~object.__reduce__` method, "
"and can optionally return :data:`NotImplemented` to fallback "
"on :attr:`dispatch_table`-registered reducers to pickle ``obj``."
msgstr ""
"Redutor especial que pode ser definido em subclasses de :class:`Pickler`. "
"Este método tem prioridade sobre qualquer redutor em :attr:`dispatch_table`. "
"Ele deve estar de acordo com a mesma interface que um "
"método :meth:`~object.__reduce__` e pode opcionalmente "
"retornar :data:`NotImplemented` como alternativa em redutores registrados "
"em :attr:`dispatch_table` para serializar com pickle ``obj``."

#: ../../library/pickle.rst:383
msgid "For a detailed example, see :ref:`reducer_override`."
msgstr "Para exemplo detalhado, consulte :ref:`reducer_override`."

#: ../../library/pickle.rst:389
msgid ""
"Deprecated. Enable fast mode if set to a true value.  The fast mode disables "
"the usage of memo, therefore speeding the pickling process by not generating "
"superfluous PUT opcodes.  It should not be used with self-referential "
"objects, doing otherwise will cause :class:`Pickler` to recurse infinitely."
msgstr ""
"Descontinuado. Ative o modo rápido se definido como um valor verdadeiro. O "
"modo rápido desabilita o uso de memo, portanto, agilizando o processo de "
"serialização com pickle por não gerar códigos de operação PUT supérfluos. "
"Ele não deve ser usado com objetos autorreferenciais, fazer o contrário fará "
"com que :class:`Pickler` recorra infinitamente."

#: ../../library/pickle.rst:395
msgid "Use :func:`pickletools.optimize` if you need more compact pickles."
msgstr ""
"Use :func:`pickletools.optimize` se você precisar de serializações com "
"pickle mais compactas."

#: ../../library/pickle.rst:400
msgid "This takes a binary file for reading a pickle data stream."
msgstr "Recebe um arquivo binário para ler um fluxo de dados pickle."

#: ../../library/pickle.rst:402
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed."
msgstr ""
"A versão do protocolo do pickle é detectada automaticamente, portanto, "
"nenhum argumento de protocolo é necessário."

#: ../../library/pickle.rst:405
msgid ""
"The argument *file* must have three methods, a read() method that takes an "
"integer argument, a readinto() method that takes a buffer argument and a "
"readline() method that requires no arguments, as in "
"the :class:`io.BufferedIOBase` interface.  Thus *file* can be an on-disk "
"file opened for binary reading, an :class:`io.BytesIO` object, or any other "
"custom object that meets this interface."
msgstr ""
"O argumento *file* deve ter três métodos: um método read() que recebe um "
"argumento inteiro, um método readinto() que recebe um argumento buffer e um "
"método readline() que não requer argumentos, como na "
"interface :class:`io.BufferedIOBase`. Assim, *file* pode ser um arquivo em "
"disco aberto para leitura binária, um objeto :class:`io.BytesIO` ou qualquer "
"outro objeto personalizado que atenda a esta interface."

#: ../../library/pickle.rst:412
msgid ""
"The optional arguments *fix_imports*, *encoding* and *errors* are used to "
"control compatibility support for pickle stream generated by Python 2. If "
"*fix_imports* is true, pickle will try to map the old Python 2 names to the "
"new names used in Python 3.  The *encoding* and *errors* tell pickle how to "
"decode 8-bit string instances pickled by Python 2; these default to 'ASCII' "
"and 'strict', respectively.  The *encoding* can be 'bytes' to read these 8-"
"bit string instances as bytes objects. Using ``encoding='latin1'`` is "
"required for unpickling NumPy arrays and instances "
"of :class:`~datetime.datetime`, :class:`~datetime.date` "
"and :class:`~datetime.time` pickled by Python 2."
msgstr ""
"Os argumentos opcionais *fix_imports*, *encoding* e *errors* são usados para "
"controlar o suporte de compatibilidade ao fluxo pickle gerado pelo Python 2. "
"Se *fix_imports* for verdadeiro, pickle tentará mapear os nomes antigos do "
"Python 2 para os novos nomes usados no Python 3. Os *encoding* e *erros* "
"dizem ao pickle como decodificar instâncias de string de 8 bits capturadas "
"pelo Python 2; o padrão é 'ASCII' e 'strict', respectivamente. O argumento "
"*encoding* pode ser 'bytes' para ler essas instâncias de string de 8 bits "
"como objetos de bytes. Usar ``encoding='latin1'`` é necessário para a "
"desserialização com pickle de vetores NumPy e instâncias "
"de :class:`~datetime.datetime`, :class:`~datetime.date` "
"e :class:`~datetime.time` serializadas com pickle pelo Python 2."

#: ../../library/pickle.rst:423
msgid ""
"If *buffers* is ``None`` (the default), then all data necessary for "
"deserialization must be contained in the pickle stream.  This means that the "
"*buffer_callback* argument was ``None`` when a :class:`Pickler` was "
"instantiated (or when :func:`dump` or :func:`dumps` was called)."
msgstr ""
"Se *buffers* for ``None`` (o padrão), todos os dados necessários para "
"desserialização devem estar contidos no fluxo pickle. Isso significa que o "
"argumento *buffer_callback* era ``None`` quando um :class:`Pickler` foi "
"instanciado (ou quando :func:`dump` ou :func:`dumps` foi chamado)."

#: ../../library/pickle.rst:428
msgid ""
"If *buffers* is not ``None``, it should be an iterable of buffer-enabled "
"objects that is consumed each time the pickle stream references an :ref:`out-"
"of-band <pickle-oob>` buffer view.  Such buffers have been given in order to "
"the *buffer_callback* of a Pickler object."
msgstr ""
"Se *buffers* for ``None``, deve ser um iterável de objetos habilitados para "
"buffer que é consumido cada vez que o fluxo de serialização com pickle faz "
"referência a uma visualização de buffer :ref:`fora da banda <pickle-oob>`. "
"Esses buffers foram fornecidos em ordem para o *buffer_callback* de um "
"objeto Pickler."

#: ../../library/pickle.rst:438
msgid ""
"Read the pickled representation of an object from the open file object given "
"in the constructor, and return the reconstituted object hierarchy specified "
"therein.  Bytes past the pickled representation of the object are ignored."
msgstr ""
"Lê a representação serializada com pickle de um objeto a partir do objeto "
"arquivo aberto fornecido no construtor e retorna a hierarquia de objeto "
"reconstituído especificada nele. Os bytes após a representação serializada "
"com pickle do objeto são ignorados."

#: ../../library/pickle.rst:445
msgid "Raise an :exc:`UnpicklingError` by default."
msgstr "Levanta um :exc:`UnpicklingError` por padrão."

#: ../../library/pickle.rst:447
msgid ""
"If defined, :meth:`persistent_load` should return the object specified by "
"the persistent ID *pid*.  If an invalid persistent ID is encountered, "
"an :exc:`UnpicklingError` should be raised."
msgstr ""
"Se definido, :meth:`persistent_load` deve retornar o objeto especificado "
"pelo ID persistente *pid*. Se um ID persistente inválido for encontrado, "
"uma :exc:`UnpicklingError` deve ser levantada."

#: ../../library/pickle.rst:453
msgid ""
"Add the default implementation of this method in the C implementation "
"of :class:`!Unpickler`."
msgstr ""
"Foi adicionada a implementação padrão desse método na implementação em C "
"da :class:`!Unpickler`."

#: ../../library/pickle.rst:459
msgid ""
"Import *module* if necessary and return the object called *name* from it, "
"where the *module* and *name* arguments are :class:`str` objects.  Note, "
"unlike its name suggests, :meth:`find_class` is also used for finding "
"functions."
msgstr ""
"Importa *module* se necessário e retorna o objeto chamado *name* dele, onde "
"os argumentos *module* e *name* são objetos :class:`str`. Observe, ao "
"contrário do que seu nome sugere, :meth:`find_class` também é usado para "
"encontrar funções."

#: ../../library/pickle.rst:464
msgid ""
"Subclasses may override this to gain control over what type of objects and "
"how they can be loaded, potentially reducing security risks. Refer "
"to :ref:`pickle-restrict` for details."
msgstr ""
"As subclasses podem substituir isso para obter controle sobre quais tipos de "
"objetos e como eles podem ser carregados, reduzindo potencialmente os riscos "
"de segurança. Confira :ref:`pickle-restrict` para detalhes."

#: ../../library/pickle.rst:468
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pickle.find_class`` with "
"arguments ``module``, ``name``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``pickle.find_class`` com "
"os argumentos ``module``, ``name``."

#: ../../library/pickle.rst:472
msgid ""
"A wrapper for a buffer representing picklable data.  *buffer* must be "
"a :ref:`buffer-providing <bufferobjects>` object, such as a :term:`bytes-"
"like object` or a N-dimensional array."
msgstr ""
"Um invólucro para um buffer que representa dados serializáveis com pickle. "
"*buffer* deve ser um objeto :ref:`provedor de buffer <bufferobjects>`, como "
"um :term:`objeto byte ou similar` ou um vetor N-dimensional."

#: ../../library/pickle.rst:476
msgid ""
":class:`PickleBuffer` is itself a buffer provider, therefore it is possible "
"to pass it to other APIs expecting a buffer-providing object, such "
"as :class:`memoryview`."
msgstr ""
":class:`PickleBuffer` é ele próprio um provedor de buffer, de forma que é "
"possível passá-lo para outras APIs que esperam um objeto provedor de buffer, "
"como :class:`memoryview`."

#: ../../library/pickle.rst:480
msgid ""
":class:`PickleBuffer` objects can only be serialized using pickle protocol 5 "
"or higher.  They are eligible for :ref:`out-of-band serialization <pickle-"
"oob>`."
msgstr ""
"Objetos :class:`PickleBuffer` só podem ser serializados usando o protocolo "
"pickle 5 ou superior. Eles são elegíveis para :ref:`serialização fora de "
"banda <pickle-oob>`."

#: ../../library/pickle.rst:488
msgid ""
"Return a :class:`memoryview` of the memory area underlying this buffer. The "
"returned object is a one-dimensional, C-contiguous memoryview with format "
"``B`` (unsigned bytes).  :exc:`BufferError` is raised if the buffer is "
"neither C- nor Fortran-contiguous."
msgstr ""
"Retorna um :class:`memoryview` da área de memória subjacente a este buffer. "
"O objeto retornado é um memoryview unidimensional, contíguo C com formato "
"``B`` (bytes não assinados). :exc:`BufferError` é levantada se o buffer não "
"for contíguo C nem Fortran."

#: ../../library/pickle.rst:495
msgid "Release the underlying buffer exposed by the PickleBuffer object."
msgstr "Libera o buffer subjacente exposto pelo objeto PickleBuffer."

#: ../../library/pickle.rst:501
msgid "What can be pickled and unpickled?"
msgstr "O que pode ser serializado e desserializado com pickle?"

#: ../../library/pickle.rst:503
msgid "The following types can be pickled:"
msgstr "Os seguintes tipos podem ser serializados com pickle:"

#: ../../library/pickle.rst:505
msgid ""
"built-in constants (``None``, ``True``, ``False``, ``Ellipsis``, "
"and :data:`NotImplemented`);"
msgstr ""
"constantes embutidas (``None``, ``True``, ``False``, ``Ellipsis`` "
"e :data:`NotImplemented`);"

#: ../../library/pickle.rst:508
msgid "integers, floating-point numbers, complex numbers;"
msgstr "inteiros, números de ponto flutuante, números complexos;"

#: ../../library/pickle.rst:510
msgid "strings, bytes, bytearrays;"
msgstr "strings, bytes, bytearrays;"

#: ../../library/pickle.rst:512
msgid ""
"tuples, lists, sets, and dictionaries containing only picklable objects;"
msgstr ""
"tuplas, listas, conjuntos e dicionários contendo apenas objetos "
"serializáveis com pickle;"

#: ../../library/pickle.rst:514
msgid ""
"functions (built-in and user-defined) accessible from the top level of a "
"module (using :keyword:`def`, not :keyword:`lambda`);"
msgstr ""
"funções (embutidas ou definidas pelo usuário) acessíveis no nível superior "
"de um módulo (usando :keyword:`def`, não :keyword:`lambda`);"

#: ../../library/pickle.rst:517
msgid "classes accessible from the top level of a module;"
msgstr "classes acessíveis no nível superior de um módulo;"

#: ../../library/pickle.rst:519
msgid ""
"instances of such classes whose the result of "
"calling :meth:`~object.__getstate__` is picklable  (see section :ref:`pickle-"
"inst` for details)."
msgstr ""
"instâncias de classes cujo o resultado da chamada "
"de :meth:`~object.__getstate__` seja serializável com pickle (veja a "
"seção :ref:`pickle-inst` para detalhes)."

#: ../../library/pickle.rst:522
msgid ""
"Attempts to pickle unpicklable objects will raise the :exc:`PicklingError` "
"exception; when this happens, an unspecified number of bytes may have "
"already been written to the underlying file.  Trying to pickle a highly "
"recursive data structure may exceed the maximum recursion depth, "
"a :exc:`RecursionError` will be raised in this case.  You can carefully "
"raise this limit with :func:`sys.setrecursionlimit`."
msgstr ""
"As tentativas de serializar objetos não serializáveis com pickle vão "
"levantar a exceção :exc:`PicklingError`; quando isso acontece, um número não "
"especificado de bytes pode já ter sido escrito no arquivo subjacente. Tentar "
"serializar com pickle uma estrutura de dados altamente recursiva pode "
"exceder a profundidade máxima de recursão, a :exc:`RecursionError` será "
"levantada neste caso. Você pode aumentar este limite cuidadosamente "
"com :func:`sys.setrecursionlimit`."

#: ../../library/pickle.rst:529
msgid ""
"Note that functions (built-in and user-defined) are pickled by "
"fully :term:`qualified name`, not by value. [#]_  This means that only the "
"function name is pickled, along with the name of the containing module and "
"classes.  Neither the function's code, nor any of its function attributes "
"are pickled.  Thus the defining module must be importable in the unpickling "
"environment, and the module must contain the named object, otherwise an "
"exception will be raised. [#]_"
msgstr ""
"Observe que as funções (embutidas e definidas pelo usuário) são serializadas "
"com pickle pelo :term:`nome qualificado`, não pelo valor. [#]_ Isso "
"significa que apenas o nome da função é serializado com pickle, junto com o "
"nome do módulo e das classes contidos. Nem o código da função, nem qualquer "
"um de seus atributos de função são serializados com pickle. Assim, o módulo "
"de definição deve ser importável no ambiente de desserialização com pickle, "
"e o módulo deve conter o objeto nomeado, caso contrário, uma exceção será "
"levantada. [#]_"

#: ../../library/pickle.rst:536
msgid ""
"Similarly, classes are pickled by fully qualified name, so the same "
"restrictions in the unpickling environment apply.  Note that none of the "
"class's code or data is pickled, so in the following example the class "
"attribute ``attr`` is not restored in the unpickling environment::"
msgstr ""
"Da mesma forma, as classes são serializadas com pickle pelo nome "
"qualificado, portanto, aplicam-se as mesmas restrições no ambiente de "
"desserialização com pickle. Observe que nenhum código ou dado da classe é "
"coletado, portanto, no exemplo a seguir, o atributo de classe ``attr`` não é "
"restaurado no ambiente de desserialização com pickle::"

#: ../../library/pickle.rst:541
msgid ""
"class Foo:\n"
"    attr = 'A class attribute'\n"
"\n"
"picklestring = pickle.dumps(Foo)"
msgstr ""
"class Foo:\n"
"    attr = 'A class attribute'\n"
"\n"
"picklestring = pickle.dumps(Foo)"

#: ../../library/pickle.rst:546
msgid ""
"These restrictions are why picklable functions and classes must be defined "
"at the top level of a module."
msgstr ""
"Essas restrições são a razão pela qual as funções e classes serializáveis "
"com pickle devem ser definidas no nível superior de um módulo."

#: ../../library/pickle.rst:549
msgid ""
"Similarly, when class instances are pickled, their class's code and data are "
"not pickled along with them.  Only the instance data are pickled.  This is "
"done on purpose, so you can fix bugs in a class or add methods to the class "
"and still load objects that were created with an earlier version of the "
"class.  If you plan to have long-lived objects that will see many versions "
"of a class, it may be worthwhile to put a version number in the objects so "
"that suitable conversions can be made by the "
"class's :meth:`~object.__setstate__` method."
msgstr ""
"Da mesma forma, quando as instâncias da classe são serializadas com pickle, "
"o código e os dados de sua classe não são serializados junto com elas. "
"Apenas os dados da instância são serializados com pickle. Isso é feito de "
"propósito para que você possa corrigir bugs em uma classe ou adicionar "
"métodos à classe e ainda carregar objetos que foram criados com uma versão "
"anterior da classe. Se você planeja ter objetos de longa duração que verão "
"muitas versões de uma classe, pode valer a pena colocar um número de versão "
"nos objetos para que as conversões adequadas possam ser feitas pelo "
"método :meth:`~object.__setstate__` da classe."

#: ../../library/pickle.rst:561
msgid "Pickling Class Instances"
msgstr "Serializando com pickle instâncias de classes"

#: ../../library/pickle.rst:565
msgid ""
"In this section, we describe the general mechanisms available to you to "
"define, customize, and control how class instances are pickled and unpickled."
msgstr ""
"Nesta seção, descrevemos os mecanismos gerais disponíveis para você definir, "
"personalizar e controlar como as instâncias de classe são serializadas e "
"desserializadas com pickle."

#: ../../library/pickle.rst:568
msgid ""
"In most cases, no additional code is needed to make instances picklable.  By "
"default, pickle will retrieve the class and the attributes of an instance "
"via introspection. When a class instance is unpickled, "
"its :meth:`~object.__init__` method is usually *not* invoked.  The default "
"behaviour first creates an uninitialized instance and then restores the "
"saved attributes.  The following code shows an implementation of this "
"behaviour::"
msgstr ""
"Na maioria dos casos, nenhum código adicional é necessário para tornar as "
"instâncias serializáveis com pickle. Por padrão, o pickle recuperará a "
"classe e os atributos de uma instância por meio de introspecção. Quando uma "
"instância de classe não está serializada com pickle, seu "
"método :meth:`~object.__init__` geralmente *não* é invocado. O comportamento "
"padrão primeiro cria uma instância não inicializada e, em seguida, restaura "
"os atributos salvos. O código a seguir mostra uma implementação desse "
"comportamento::"

#: ../../library/pickle.rst:575
msgid ""
"def save(obj):\n"
"    return (obj.__class__, obj.__dict__)\n"
"\n"
"def restore(cls, attributes):\n"
"    obj = cls.__new__(cls)\n"
"    obj.__dict__.update(attributes)\n"
"    return obj"
msgstr ""
"def save(obj):\n"
"    return (obj.__class__, obj.__dict__)\n"
"\n"
"def restore(cls, attributes):\n"
"    obj = cls.__new__(cls)\n"
"    obj.__dict__.update(attributes)\n"
"    return obj"

#: ../../library/pickle.rst:583
msgid ""
"Classes can alter the default behaviour by providing one or several special "
"methods:"
msgstr ""
"As classes podem alterar o comportamento padrão, fornecendo um ou vários "
"métodos especiais:"

#: ../../library/pickle.rst:588
msgid ""
"In protocols 2 and newer, classes that implements "
"the :meth:`__getnewargs_ex__` method can dictate the values passed to "
"the :meth:`__new__` method upon unpickling.  The method must return a pair "
"``(args, kwargs)`` where *args* is a tuple of positional arguments and "
"*kwargs* a dictionary of named arguments for constructing the object.  Those "
"will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"Nos protocolos 2 e mais recentes, as classes que implementam o "
"método :meth:`__getnewargs_ex__` podem ditar os valores passados para o "
"método :meth:`__new__` após a desserialização com pickle. O método deve "
"retornar um par ``(args, kwargs)`` onde *args* é uma tupla de argumentos "
"posicionais e *kwargs* um dicionário de argumentos nomeados para construir o "
"objeto. Esses serão passados para o método :meth:`__new__` após a "
"desserialização com pickle."

#: ../../library/pickle.rst:596
msgid ""
"You should implement this method if the :meth:`__new__` method of your class "
"requires keyword-only arguments.  Otherwise, it is recommended for "
"compatibility to implement :meth:`__getnewargs__`."
msgstr ""
"Você deve implementar este método se o método :meth:`__new__` de sua classe "
"requer argumentos somente-nomeados. Caso contrário, é recomendado para "
"compatibilidade implementar :meth:`__getnewargs__`."

#: ../../library/pickle.rst:600
msgid ":meth:`__getnewargs_ex__` is now used in protocols 2 and 3."
msgstr ":meth:`__getnewargs_ex__` é agora usado em protocolos 2 e 3."

#: ../../library/pickle.rst:606
msgid ""
"This method serves a similar purpose as :meth:`__getnewargs_ex__`, but "
"supports only positional arguments.  It must return a tuple of arguments "
"``args`` which will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"Este método serve a um propósito semelhante ao de :meth:`__getnewargs_ex__`, "
"mas tem suporte apenas a argumentos posicionais. Ele deve retornar uma tupla "
"de argumentos ``args`` que serão passados para o método :meth:`__new__` após "
"a desserialização com pickle."

#: ../../library/pickle.rst:610
msgid ""
":meth:`__getnewargs__` will not be called if :meth:`__getnewargs_ex__` is "
"defined."
msgstr ""
":meth:`__getnewargs__` não será chamado se :meth:`__getnewargs_ex__` estiver "
"definido."

#: ../../library/pickle.rst:613
msgid ""
"Before Python 3.6, :meth:`__getnewargs__` was called instead "
"of :meth:`__getnewargs_ex__` in protocols 2 and 3."
msgstr ""
"Antes do Python 3.6, :meth:`__getnewargs__` era chamado em vez "
"de :meth:`__getnewargs_ex__` nos protocolos 2 e 3."

#: ../../library/pickle.rst:620
msgid ""
"Classes can further influence how their instances are pickled by overriding "
"the method :meth:`__getstate__`.  It is called and the returned object is "
"pickled as the contents for the instance, instead of a default state. There "
"are several cases:"
msgstr ""
"Classes podem influenciar ainda mais como suas instâncias são serializadas "
"com pickle, substituindo o método :meth:`__getstate__`. Ele é chamado e o "
"objeto retornado é serializado com pickle como o conteúdo da instância, em "
"vez de um estado padrão. Existem vários casos:"

#: ../../library/pickle.rst:625
msgid ""
"For a class that has no instance :attr:`~object.__dict__` and "
"no :attr:`~object.__slots__`, the default state is ``None``."
msgstr ""
"Para uma classe que não possui instância :attr:`~object.__dict__` e não "
"possui :attr:`~object.__slots__`, o estado padrão é ``None``."

#: ../../library/pickle.rst:628
msgid ""
"For a class that has an instance :attr:`~object.__dict__` and "
"no :attr:`~object.__slots__`, the default state is ``self.__dict__``."
msgstr ""
"Para uma classe que não uma possui instância :attr:`~object.__dict__` "
"nem :attr:`~object.__slots__`, o estado padrão é ``self.__dict__``."

#: ../../library/pickle.rst:631
msgid ""
"For a class that has an instance :attr:`~object.__dict__` "
"and :attr:`~object.__slots__`, the default state is a tuple consisting of "
"two dictionaries:  ``self.__dict__``, and a dictionary mapping slot names to "
"slot values.  Only slots that have a value are included in the latter."
msgstr ""
"Para uma classe que possui uma instância :attr:`~object.__dict__` "
"e :attr:`~object.__slots__`, o estado padrão é uma tupla consistindo de dois "
"dicionários: ``self.__dict__``, e um dicionário de mapeamento de nomes de "
"slot para valores de slot. Apenas os slots que possuem um valor são "
"incluídos neste último."

#: ../../library/pickle.rst:637
msgid ""
"For a class that has :attr:`~object.__slots__` and no "
"instance :attr:`~object.__dict__`, the default state is a tuple whose first "
"item is ``None`` and whose second item is a dictionary mapping slot names to "
"slot values described in the previous bullet."
msgstr ""
"Para uma classe que possui :attr:`~object.__slots__` e "
"nenhuma :attr:`~object.__dict__` de instância, o estado padrão é uma tupla "
"cujo primeiro item é ``None`` e cujo segundo item é um dicionário mapeando "
"os nomes dos slots para os valores dos slots descritos no tópico anterior."

#: ../../library/pickle.rst:642
msgid ""
"Added the default implementation of the ``__getstate__()`` method in "
"the :class:`object` class."
msgstr ""
"Adicionada a implementação padrão do método ``__getstate__()`` na "
"classe :class:`objeto`."

#: ../../library/pickle.rst:649
msgid ""
"Upon unpickling, if the class defines :meth:`__setstate__`, it is called "
"with the unpickled state.  In that case, there is no requirement for the "
"state object to be a dictionary.  Otherwise, the pickled state must be a "
"dictionary and its items are assigned to the new instance's dictionary."
msgstr ""
"Ao desserializar com pickle, se a classe define :meth:`__setstate__`, ela é "
"chamada com o estado não desserializado. Nesse caso, não há nenhum requisito "
"para que o objeto de estado seja um dicionário. Caso contrário, o estado "
"serializado com pickle deve ser um dicionário e seus itens são atribuídos ao "
"dicionário da nova instância."

#: ../../library/pickle.rst:656
msgid ""
"If :meth:`__reduce__` returns a state with value ``None`` at pickling, "
"the :meth:`__setstate__` method will not be called upon unpickling."
msgstr ""
"Se :meth:`__reduce__` retorna um estado com valor ``None`` na serialização "
"com pickle, o método :meth:`__setstate__` não será chamado quando da "
"desserialização com pickle."

#: ../../library/pickle.rst:660
msgid ""
"Refer to the section :ref:`pickle-state` for more information about how to "
"use the methods :meth:`~object.__getstate__` "
"and :meth:`~object.__setstate__`."
msgstr ""
"Confira a seção :ref:`pickle-state` para mais informações sobre como usar os "
"métodos :meth:`~object.__getstate__` e :meth:`~object.__setstate__`."

#: ../../library/pickle.rst:665
msgid ""
"At unpickling time, some methods "
"like :meth:`~object.__getattr__`, :meth:`~object.__getattribute__`, "
"or :meth:`~object.__setattr__` may be called upon the instance.  In case "
"those methods rely on some internal invariant being true, the type should "
"implement :meth:`~object.__new__` to establish such an invariant, "
"as :meth:`~object.__init__` is not called when unpickling an instance."
msgstr ""
"Quando da desserialização com pickle, alguns métodos, "
"como :meth:`~object.__getattr__`, :meth:`~object.__getattribute__` "
"ou :meth:`~object.__setattr__`, podem ser chamados na instância. No caso "
"desses métodos dependerem de alguma invariante interna ser verdadeira, o "
"tipo deve ser implementado :meth:`~object.__new__` para estabelecer tal "
"invariante, pois :meth:`~object.__init__` não é chamada quando da "
"desserialização com pickle em uma instância."

#: ../../library/pickle.rst:674
msgid ""
"As we shall see, pickle does not use directly the methods described above.  "
"In fact, these methods are part of the copy protocol which implements "
"the :meth:`~object.__reduce__` special method.  The copy protocol provides a "
"unified interface for retrieving the data necessary for pickling and copying "
"objects. [#]_"
msgstr ""
"Como veremos, o pickle não usa diretamente os métodos descritos acima. Na "
"verdade, esses métodos são parte do protocolo de cópia que implementa o "
"método especial :meth:`~object.__reduce__`. O protocolo de cópia fornece uma "
"interface unificada para recuperar os dados necessários para serialização "
"com pickle e cópia de objetos. [#]_"

#: ../../library/pickle.rst:680
msgid ""
"Although powerful, implementing :meth:`~object.__reduce__` directly in your "
"classes is error prone.  For this reason, class designers should use the "
"high-level interface "
"(i.e., :meth:`~object.__getnewargs_ex__`, :meth:`~object.__getstate__` "
"and :meth:`~object.__setstate__`) whenever possible.  We will show, however, "
"cases where using :meth:`!__reduce__` is the only option or leads to more "
"efficient pickling or both."
msgstr ""
"Apesar de poderoso, implementar :meth:`~object.__reduce__` diretamente em "
"sua classe é algo propenso a erro. Por este motivo, designers de classe "
"devem usar a interface de alto nível (ou "
"seja, :meth:`~object.__getnewargs_ex__`, :meth:`~object.__getstate__` "
"e :meth:`~object.__setstate__`) sempre que possível. Vamos mostrar, porém, "
"casos em que o uso de :meth:`!__reduce__` é a única opção ou leva a uma "
"serialização com pickle mais eficiente, ou as ambas."

#: ../../library/pickle.rst:689
msgid ""
"The interface is currently defined as follows.  The :meth:`__reduce__` "
"method takes no argument and shall return either a string or preferably a "
"tuple (the returned object is often referred to as the \"reduce value\")."
msgstr ""
"A interface está atualmente definida da seguinte maneira. O "
"método :meth:`__reduce__` não aceita nenhum argumento e deve retornar uma "
"string ou preferencialmente uma tupla (o objeto retornado é frequentemente "
"referido como o \"valor de redução\")."

#: ../../library/pickle.rst:693
msgid ""
"If a string is returned, the string should be interpreted as the name of a "
"global variable.  It should be the object's local name relative to its "
"module; the pickle module searches the module namespace to determine the "
"object's module.  This behaviour is typically useful for singletons."
msgstr ""
"Se uma string é retornada, ela deve ser interpretada como o nome de uma "
"variável global. Deve ser o nome local do objeto relativo ao seu módulo; o "
"módulo pickle pesquisa o espaço de nomes do módulo para determinar o módulo "
"do objeto. Esse comportamento é normalmente útil para singletons."

#: ../../library/pickle.rst:698
msgid ""
"When a tuple is returned, it must be between two and six items long. "
"Optional items can either be omitted, or ``None`` can be provided as their "
"value.  The semantics of each item are in order:"
msgstr ""
"Quando uma tupla é retornada, ela deve ter entre dois e seis itens. Os itens "
"opcionais podem ser omitidos ou ``None`` pode ser fornecido como seu valor. "
"A semântica de cada item está em ordem:"

#: ../../library/pickle.rst:704
msgid ""
"A callable object that will be called to create the initial version of the "
"object."
msgstr ""
"Um objeto chamável que será chamado para criar a versão inicial do objeto."

#: ../../library/pickle.rst:707
msgid ""
"A tuple of arguments for the callable object.  An empty tuple must be given "
"if the callable does not accept any argument."
msgstr ""
"Uma tupla de argumentos para o objeto chamável. Uma tupla vazia deve ser "
"fornecida se o chamável não aceitar nenhum argumento."

#: ../../library/pickle.rst:710
msgid ""
"Optionally, the object's state, which will be passed to the "
"object's :meth:`__setstate__` method as previously described.  If the object "
"has no such method then, the value must be a dictionary and it will be added "
"to the object's :attr:`~object.__dict__` attribute."
msgstr ""
"Opcionalmente, o estado do objeto, que será passado para o "
"método :meth:`__setstate__` do objeto conforme descrito anteriormente. Se o "
"objeto não tiver tal método, o valor deve ser um dicionário e será "
"adicionado ao atributo :attr:`~object.__dict__` do objeto."

#: ../../library/pickle.rst:715
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive items. "
"These items will be appended to the object either using ``obj.append(item)`` "
"or, in batch, using ``obj.extend(list_of_items)``. This is primarily used "
"for list subclasses, but may be used by other classes as long as they "
"have :ref:`append and extend methods <typesseq-common>` with the appropriate "
"signature.  (Whether :meth:`!append` or :meth:`!extend` is used depends on "
"which pickle protocol version is used as well as the number of items to "
"append, so both must be supported.)"
msgstr ""
"Opcionalmente, um iterador (e não uma sequência) produzindo itens "
"sucessivos. Esses itens serão anexados ao objeto usando ``obj.append(item)`` "
"ou, em lote, usando ``obj.extend(list_of_items)``. Isso é usado "
"principalmente para subclasses de lista, mas pode ser usado por outras "
"classes, desde que tenham os :ref:`métodos append e extend <typesseq-"
"common>` com a assinatura apropriada. (Se :meth:`!append` ou :meth:`!extend` "
"é usado depende de qual versão do protocolo pickle é usada, bem como o "
"número de itens a anexar, então ambos devem ser suportados.)"

#: ../../library/pickle.rst:725
msgid ""
"Optionally, an iterator (not a sequence) yielding successive key-value "
"pairs.  These items will be stored to the object using ``obj[key] = "
"value``.  This is primarily used for dictionary subclasses, but may be used "
"by other classes as long as they implement :meth:`__setitem__`."
msgstr ""
"Opcionalmente, um iterador (não uma sequência) produzindo pares de valor-"
"chave sucessivos. Esses itens serão armazenados no objeto usando "
"``obj[chave]=valor``. Isso é usado principalmente para subclasses de "
"dicionário, mas pode ser usado por outras classes, desde que "
"implementem :meth:`__setitem__`."

#: ../../library/pickle.rst:730
msgid ""
"Optionally, a callable with a ``(obj, state)`` signature. This callable "
"allows the user to programmatically control the state-updating behavior of a "
"specific object, instead of using ``obj``'s static :meth:`__setstate__` "
"method. If not ``None``, this callable will have priority over "
"``obj``'s :meth:`__setstate__`."
msgstr ""
"Opcionalmente, um chamável com uma assinatura ``(obj, estado)``. Este "
"chamável permite ao usuário controlar programaticamente o comportamento de "
"atualização de estado de um objeto específico, ao invés de usar o método "
"estático :meth:`__setstate__` de ``obj``. Se não for ``None``, este chamável "
"terá prioridade sobre o :meth:`__setstate__` de ``obj``."

#: ../../library/pickle.rst:736
msgid "The optional sixth tuple item, ``(obj, state)``, was added."
msgstr "O sexto item opcional de tupla, ``(obj, estado)``, foi adicionado."

#: ../../library/pickle.rst:742
msgid ""
"Alternatively, a :meth:`__reduce_ex__` method may be defined.  The only "
"difference is this method should take a single integer argument, the "
"protocol version.  When defined, pickle will prefer it over "
"the :meth:`__reduce__` method.  In addition, :meth:`__reduce__` "
"automatically becomes a synonym for the extended version.  The main use for "
"this method is to provide backwards-compatible reduce values for older "
"Python releases."
msgstr ""
"Alternativamente, um método :meth:`__reduce_ex__` pode ser definido. A única "
"diferença é que este método deve ter um único argumento inteiro, a versão do "
"protocolo. Quando definido, pickle irá preferir isso ao "
"método :meth:`__reduce__`. Além disso, :meth:`__reduce__` automaticamente se "
"torna um sinônimo para a versão estendida. O principal uso desse método é "
"fornecer valores de redução com compatibilidade reversa para versões mais "
"antigas do Python."

#: ../../library/pickle.rst:754
msgid "Persistence of External Objects"
msgstr "Persistência de objetos externos"

#: ../../library/pickle.rst:760
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports the "
"notion of a reference to an object outside the pickled data stream.  Such "
"objects are referenced by a persistent ID, which should be either a string "
"of alphanumeric characters (for protocol 0) [#]_ or just an arbitrary object "
"(for any newer protocol)."
msgstr ""
"Para o benefício da persistência do objeto, o módulo :mod:`pickle` tem "
"suporte à noção de uma referência a um objeto fora do fluxo de dados "
"serializados com pickle. Esses objetos são referenciados por um ID "
"persistente, que deve ser uma string de caracteres alfanuméricos (para o "
"protocolo 0) [#]_ ou apenas um objeto arbitrário (para qualquer protocolo "
"mais recente)."

#: ../../library/pickle.rst:766
msgid ""
"The resolution of such persistent IDs is not defined by the :mod:`pickle` "
"module; it will delegate this resolution to the user-defined methods on the "
"pickler and unpickler, :meth:`~Pickler.persistent_id` "
"and :meth:`~Unpickler.persistent_load` respectively."
msgstr ""
"A resolução de tais IDs persistentes não é definida pelo "
"módulo :mod:`pickle`; ele vai delegar esta resolução aos métodos definidos "
"pelo usuário no selecionador e no separador, :meth:`~Pickler.persistent_id` "
"e :meth:`~Unpickler.persistent_load` respectivamente."

#: ../../library/pickle.rst:771
msgid ""
"To pickle objects that have an external persistent ID, the pickler must have "
"a custom :meth:`~Pickler.persistent_id` method that takes an object as an "
"argument and returns either ``None`` or the persistent ID for that object. "
"When ``None`` is returned, the pickler simply pickles the object as normal. "
"When a persistent ID string is returned, the pickler will pickle that "
"object, along with a marker so that the unpickler will recognize it as a "
"persistent ID."
msgstr ""
"Para serializar com pickle objetos que têm um ID externo persistente, o "
"pickler deve ter um método :meth:`~Pickler.persistent_id` personalizado que "
"recebe um objeto como um argumento e retorna ``None`` ou o ID persistente "
"para esse objeto. Quando ``None`` é retornado, o pickler simplesmente "
"serializa o objeto normalmente. Quando uma string de ID persistente é "
"retornada, o pickler serializa aquele objeto, junto com um marcador para que "
"o unpickler o reconheça como um ID persistente."

#: ../../library/pickle.rst:778
msgid ""
"To unpickle external objects, the unpickler must have a "
"custom :meth:`~Unpickler.persistent_load` method that takes a persistent ID "
"object and returns the referenced object."
msgstr ""
"Para desserializar com pickle objetos externos, o unpickler deve ter um "
"método :meth:`~Unpickler.persistent_load` personalizado que recebe um objeto "
"de ID persistente e retorna o objeto referenciado."

#: ../../library/pickle.rst:782
msgid ""
"Here is a comprehensive example presenting how persistent ID can be used to "
"pickle external objects by reference."
msgstr ""
"Aqui está um exemplo abrangente que apresenta como o ID persistente pode ser "
"usado para serializar com pickle objetos externos por referência."

#: ../../library/pickle.rst:785
msgid ""
"# Simple example presenting how persistent ID can be used to pickle\n"
"# external objects by reference.\n"
"\n"
"import pickle\n"
"import sqlite3\n"
"from collections import namedtuple\n"
"\n"
"# Simple class representing a record in our database.\n"
"MemoRecord = namedtuple(\"MemoRecord\", \"key, task\")\n"
"\n"
"class DBPickler(pickle.Pickler):\n"
"\n"
"    def persistent_id(self, obj):\n"
"        # Instead of pickling MemoRecord as a regular class instance, we "
"emit a\n"
"        # persistent ID.\n"
"        if isinstance(obj, MemoRecord):\n"
"            # Here, our persistent ID is simply a tuple, containing a tag "
"and a\n"
"            # key, which refers to a specific record in the database.\n"
"            return (\"MemoRecord\", obj.key)\n"
"        else:\n"
"            # If obj does not have a persistent ID, return None. This means "
"obj\n"
"            # needs to be pickled as usual.\n"
"            return None\n"
"\n"
"\n"
"class DBUnpickler(pickle.Unpickler):\n"
"\n"
"    def __init__(self, file, connection):\n"
"        super().__init__(file)\n"
"        self.connection = connection\n"
"\n"
"    def persistent_load(self, pid):\n"
"        # This method is invoked whenever a persistent ID is encountered.\n"
"        # Here, pid is the tuple returned by DBPickler.\n"
"        cursor = self.connection.cursor()\n"
"        type_tag, key_id = pid\n"
"        if type_tag == \"MemoRecord\":\n"
"            # Fetch the referenced record from the database and return it.\n"
"            cursor.execute(\"SELECT * FROM memos WHERE key=?\", "
"(str(key_id),))\n"
"            key, task = cursor.fetchone()\n"
"            return MemoRecord(key, task)\n"
"        else:\n"
"            # Always raises an error if you cannot return the correct "
"object.\n"
"            # Otherwise, the unpickler will think None is the object "
"referenced\n"
"            # by the persistent ID.\n"
"            raise pickle.UnpicklingError(\"unsupported persistent object\")\n"
"\n"
"\n"
"def main():\n"
"    import io\n"
"    import pprint\n"
"\n"
"    # Initialize and populate our database.\n"
"    conn = sqlite3.connect(\":memory:\")\n"
"    cursor = conn.cursor()\n"
"    cursor.execute(\"CREATE TABLE memos(key INTEGER PRIMARY KEY, task TEXT)"
"\")\n"
"    tasks = (\n"
"        'give food to fish',\n"
"        'prepare group meeting',\n"
"        'fight with a zebra',\n"
"        )\n"
"    for task in tasks:\n"
"        cursor.execute(\"INSERT INTO memos VALUES(NULL, ?)\", (task,))\n"
"\n"
"    # Fetch the records to be pickled.\n"
"    cursor.execute(\"SELECT * FROM memos\")\n"
"    memos = [MemoRecord(key, task) for key, task in cursor]\n"
"    # Save the records using our custom DBPickler.\n"
"    file = io.BytesIO()\n"
"    DBPickler(file).dump(memos)\n"
"\n"
"    print(\"Pickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"    # Update a record, just for good measure.\n"
"    cursor.execute(\"UPDATE memos SET task='learn italian' WHERE key=1\")\n"
"\n"
"    # Load the records from the pickle data stream.\n"
"    file.seek(0)\n"
"    memos = DBUnpickler(file, conn).load()\n"
"\n"
"    print(\"Unpickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"
msgstr ""
"# Exemplo simples que mostra como o ID persistente pode ser usado\n"
"# serializar com pickle objetos externos por referência.\n"
"\n"
"import pickle\n"
"import sqlite3\n"
"from collections import namedtuple\n"
"\n"
"# Classe simples que representa um registro em nosso banco de dados.\n"
"MemoRecord = namedtuple(\"MemoRecord\", \"key, task\")\n"
"\n"
"class DBPickler(pickle.Pickler):\n"
"\n"
"    def persistent_id(self, obj):\n"
"        # Em vez de conservar MemoRecord como uma instância de classe "
"regular,\n"
"        # emitimos um ID persistente.\n"
"        if isinstance(obj, MemoRecord):\n"
"            # Aqui, nosso ID persistente é simplesmente uma tupla, contendo\n"
"            # uma tag e uma chave, que se refere a um registro específico\n"
"            # no banco de dados.\n"
"            return (\"MemoRecord\", obj.key)\n"
"        else:\n"
"            # Se obj não tiver um ID persistente, retorna None. Significa "
"que\n"
"            # obj precisa ser conservado como de costume.\n"
"            return None\n"
"\n"
"\n"
"class DBUnpickler(pickle.Unpickler):\n"
"\n"
"    def __init__(self, file, connection):\n"
"        super().__init__(file)\n"
"        self.connection = connection\n"
"\n"
"    def persistent_load(self, pid):\n"
"        # Este método é invocado sempre que um ID persistente é encontrado.\n"
"        # Aqui, pid é a tupla retornada por DBPickler.\n"
"        cursor = self.connection.cursor()\n"
"        type_tag, key_id = pid\n"
"        if type_tag == \"MemoRecord\":\n"
"            # Busca o registro referenciado no banco de dados e retorna-o.\n"
"            cursor.execute(\"SELECT * FROM memos WHERE key=?\", "
"(str(key_id),))\n"
"            key, task = cursor.fetchone()\n"
"            return MemoRecord(key, task)\n"
"        else:\n"
"            # Sempre levanta um erro se você puder retornar o objeto "
"correto.\n"
"            # Caso contrário, a desserialização com pickle considerará que\n"
"            # None é o objeto referenciado pelo ID persistente.\n"
"            raise pickle.UnpicklingError(\"unsupported persistent object\")\n"
"\n"
"\n"
"def main():\n"
"    import io\n"
"    import pprint\n"
"\n"
"    # Inicializa e popula nosso banco de dados.\n"
"    conn = sqlite3.connect(\":memory:\")\n"
"    cursor = conn.cursor()\n"
"    cursor.execute(\"CREATE TABLE memos(key INTEGER PRIMARY KEY, task TEXT)"
"\")\n"
"    tasks = (\n"
"        'give food to fish',\n"
"        'prepare group meeting',\n"
"        'fight with a zebra',\n"
"        )\n"
"    for task in tasks:\n"
"        cursor.execute(\"INSERT INTO memos VALUES(NULL, ?)\", (task,))\n"
"\n"
"    # Busca os registros a serem serializados com pickle.\n"
"    cursor.execute(\"SELECT * FROM memos\")\n"
"    memos = [MemoRecord(key, task) for key, task in cursor]\n"
"    # Salva os registros usando nosso DBPickler personalizado.\n"
"    file = io.BytesIO()\n"
"    DBPickler(file).dump(memos)\n"
"\n"
"    print(\"Pickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"    # Atualiza um registro, só por precaução.\n"
"    cursor.execute(\"UPDATE memos SET task='learn italian' WHERE key=1\")\n"
"\n"
"    # Carrega os registros do fluxo de dados pickle.\n"
"    file.seek(0)\n"
"    memos = DBUnpickler(file, conn).load()\n"
"\n"
"    print(\"Unpickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"

#: ../../library/pickle.rst:790
msgid "Dispatch Tables"
msgstr "Tabelas de despacho"

#: ../../library/pickle.rst:792
msgid ""
"If one wants to customize pickling of some classes without disturbing any "
"other code which depends on pickling, then one can create a pickler with a "
"private dispatch table."
msgstr ""
"Se alguém quiser personalizar a serialização com pickle de algumas classes "
"sem perturbar nenhum outro código que dependa da serialização, pode-se criar "
"um pickler com uma tabela de despacho privada."

#: ../../library/pickle.rst:796
msgid ""
"The global dispatch table managed by the :mod:`copyreg` module is available "
"as :data:`!copyreg.dispatch_table`.  Therefore, one may choose to use a "
"modified copy of :data:`!copyreg.dispatch_table` as a private dispatch table."
msgstr ""
"A tabela de despacho global gerenciada pelo módulo :mod:`copyreg` está "
"disponível como :data:`!copyreg.dispatch_table`. Portanto, pode-se escolher "
"usar uma cópia modificada de :data:`!copyreg.dispatch_table` como uma tabela "
"de despacho privada."

#: ../../library/pickle.rst:801
msgid "For example ::"
msgstr "Por exemplo ::"

#: ../../library/pickle.rst:803
msgid ""
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)\n"
"p.dispatch_table = copyreg.dispatch_table.copy()\n"
"p.dispatch_table[SomeClass] = reduce_SomeClass"
msgstr ""
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)\n"
"p.dispatch_table = copyreg.dispatch_table.copy()\n"
"p.dispatch_table[SomeClass] = reduce_SomeClass"

#: ../../library/pickle.rst:808
msgid ""
"creates an instance of :class:`pickle.Pickler` with a private dispatch table "
"which handles the ``SomeClass`` class specially.  Alternatively, the code ::"
msgstr ""
"cria uma instância de :class:`pickle.Pickler` com uma tabela de despacho "
"privada que trata a classe ``SomeClass`` especialmente. Alternativamente, o "
"código ::"

#: ../../library/pickle.rst:812
msgid ""
"class MyPickler(pickle.Pickler):\n"
"    dispatch_table = copyreg.dispatch_table.copy()\n"
"    dispatch_table[SomeClass] = reduce_SomeClass\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)"
msgstr ""
"class MyPickler(pickle.Pickler):\n"
"    dispatch_table = copyreg.dispatch_table.copy()\n"
"    dispatch_table[SomeClass] = reduce_SomeClass\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)"

#: ../../library/pickle.rst:818
msgid ""
"does the same but all instances of ``MyPickler`` will by default share the "
"private dispatch table.  On the other hand, the code ::"
msgstr ""
"faz o mesmo, mas todas as instâncias de ``MyPickler`` compartilharão por "
"padrão a tabela de despacho privada. Por outro lado, o código ::"

#: ../../library/pickle.rst:821
msgid ""
"copyreg.pickle(SomeClass, reduce_SomeClass)\n"
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)"
msgstr ""
"copyreg.pickle(SomeClass, reduce_SomeClass)\n"
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)"

#: ../../library/pickle.rst:825
msgid ""
"modifies the global dispatch table shared by all users of the :mod:`copyreg` "
"module."
msgstr ""
"modifica a tabela de despacho global compartilhada por todos os usuários do "
"módulo :mod:`copyreg`."

#: ../../library/pickle.rst:830
msgid "Handling Stateful Objects"
msgstr "Manipulação de objetos com estado"

#: ../../library/pickle.rst:836
msgid ""
"Here's an example that shows how to modify pickling behavior for a class. "
"The :class:`!TextReader` class below opens a text file, and returns the line "
"number and line contents each time its :meth:`!readline` method is called. "
"If a :class:`!TextReader` instance is pickled, all attributes *except* the "
"file object member are saved. When the instance is unpickled, the file is "
"reopened, and reading resumes from the last location. The :meth:`!"
"__setstate__` and :meth:`!__getstate__` methods are used to implement this "
"behavior. ::"
msgstr ""
"Aqui está um exemplo que mostra como modificar o comportamento de "
"serialização com pickle de uma classe. A classe :class:`!TextReader` abaixo "
"abre um arquivo texto e retorna o número da linha e o conteúdo da linha cada "
"vez que seu método :meth:`!readline` é chamado. Se uma instância de :class:`!"
"TextReader` for selecionada, todos os atributos *exceto* o membro do objeto "
"arquivo são salvos. Quando a instância é removida, o arquivo é reaberto e a "
"leitura continua a partir do último local. Os métodos :meth:`!__setstate__` "
"e :meth:`!__getstate__` são usados para implementar este comportamento. ::"

#: ../../library/pickle.rst:844
msgid ""
"class TextReader:\n"
"    \"\"\"Print and number lines in a text file.\"\"\"\n"
"\n"
"    def __init__(self, filename):\n"
"        self.filename = filename\n"
"        self.file = open(filename)\n"
"        self.lineno = 0\n"
"\n"
"    def readline(self):\n"
"        self.lineno += 1\n"
"        line = self.file.readline()\n"
"        if not line:\n"
"            return None\n"
"        if line.endswith('\\n'):\n"
"            line = line[:-1]\n"
"        return \"%i: %s\" % (self.lineno, line)\n"
"\n"
"    def __getstate__(self):\n"
"        # Copy the object's state from self.__dict__ which contains\n"
"        # all our instance attributes. Always use the dict.copy()\n"
"        # method to avoid modifying the original state.\n"
"        state = self.__dict__.copy()\n"
"        # Remove the unpicklable entries.\n"
"        del state['file']\n"
"        return state\n"
"\n"
"    def __setstate__(self, state):\n"
"        # Restore instance attributes (i.e., filename and lineno).\n"
"        self.__dict__.update(state)\n"
"        # Restore the previously opened file's state. To do so, we need to\n"
"        # reopen it and read from it until the line count is restored.\n"
"        file = open(self.filename)\n"
"        for _ in range(self.lineno):\n"
"            file.readline()\n"
"        # Finally, save the file.\n"
"        self.file = file"
msgstr ""

#: ../../library/pickle.rst:882
msgid "A sample usage might be something like this::"
msgstr "Um exemplo de uso pode ser algo assim::"

#: ../../library/pickle.rst:884
msgid ""
">>> reader = TextReader(\"hello.txt\")\n"
">>> reader.readline()\n"
"'1: Hello world!'\n"
">>> reader.readline()\n"
"'2: I am line number two.'\n"
">>> new_reader = pickle.loads(pickle.dumps(reader))\n"
">>> new_reader.readline()\n"
"'3: Goodbye!'"
msgstr ""
">>> reader = TextReader(\"hello.txt\")\n"
">>> reader.readline()\n"
"'1: Hello world!'\n"
">>> reader.readline()\n"
"'2: I am line number two.'\n"
">>> new_reader = pickle.loads(pickle.dumps(reader))\n"
">>> new_reader.readline()\n"
"'3: Goodbye!'"

#: ../../library/pickle.rst:896
msgid "Custom Reduction for Types, Functions, and Other Objects"
msgstr "Redução personalizada para tipos, funções e outros objetos"

#: ../../library/pickle.rst:900
msgid ""
"Sometimes, :attr:`~Pickler.dispatch_table` may not be flexible enough. In "
"particular we may want to customize pickling based on another criterion than "
"the object's type, or we may want to customize the pickling of functions and "
"classes."
msgstr ""
"Às vezes, :attr:`~Pickler.dispatch_table` pode não ser flexível o "
"suficiente. Em particular, podemos querer personalizar a serialização com "
"pickle com base em outro critério que não o tipo do objeto, ou podemos "
"personalizar a serialização com pickle de funções e classes."

#: ../../library/pickle.rst:905
msgid ""
"For those cases, it is possible to subclass from the :class:`Pickler` class "
"and implement a :meth:`~Pickler.reducer_override` method. This method can "
"return an arbitrary reduction tuple (see :meth:`~object.__reduce__`). It can "
"alternatively return :data:`NotImplemented` to fallback to the traditional "
"behavior."
msgstr ""
"Para esses casos, é possível criar uma subclasse da classe :class:`Pickler` "
"e implementar um método :meth:`~Pickler.reducer_override`. Este método pode "
"retornar uma tupla de redução arbitrária (veja :meth:`~object.__reduce__`). "
"Ele pode, alternativamente, retornar :data:`NotImplemented` para retornar ao "
"comportamento tradicional."

#: ../../library/pickle.rst:910
msgid ""
"If both the :attr:`~Pickler.dispatch_table` "
"and :meth:`~Pickler.reducer_override` are defined, "
"then :meth:`~Pickler.reducer_override` method takes priority."
msgstr ""
"Se :attr:`~Pickler.dispatch_table` e :meth:`~Pickler.reducer_override` forem "
"definidos, o método :meth:`~Pickler.reducer_override` tem prioridade."

#: ../../library/pickle.rst:915
msgid ""
"For performance reasons, :meth:`~Pickler.reducer_override` may not be called "
"for the following objects: ``None``, ``True``, ``False``, and exact "
"instances "
"of :class:`int`, :class:`float`, :class:`bytes`, :class:`str`, :class:`dict`, :class:`set`, :class:`frozenset`, :class:`list` "
"and :class:`tuple`."
msgstr ""
"Por motivos de desempenho, :meth:`~Pickler.reducer_override` não pode ser "
"chamado para os seguintes objetos: ``None``, ``True``, ``False``, e as "
"instâncias exatas "
"de :class:`int`, :class:`float`, :class:`bytes`, :class:`str`, :class:`dict`, :class:`set`, :class:`frozenset`, :class:`list` "
"e :class:`tuple`."

#: ../../library/pickle.rst:921
msgid ""
"Here is a simple example where we allow pickling and reconstructing a given "
"class::"
msgstr ""
"Aqui está um exemplo simples onde permitimos serialização com pickle e "
"reconstrução de uma determinada classe:"

#: ../../library/pickle.rst:924
msgid ""
"import io\n"
"import pickle\n"
"\n"
"class MyClass:\n"
"    my_attribute = 1\n"
"\n"
"class MyPickler(pickle.Pickler):\n"
"    def reducer_override(self, obj):\n"
"        \"\"\"Custom reducer for MyClass.\"\"\"\n"
"        if getattr(obj, \"__name__\", None) == \"MyClass\":\n"
"            return type, (obj.__name__, obj.__bases__,\n"
"                          {'my_attribute': obj.my_attribute})\n"
"        else:\n"
"            # For any other object, fallback to usual reduction\n"
"            return NotImplemented\n"
"\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)\n"
"p.dump(MyClass)\n"
"\n"
"del MyClass\n"
"\n"
"unpickled_class = pickle.loads(f.getvalue())\n"
"\n"
"assert isinstance(unpickled_class, type)\n"
"assert unpickled_class.__name__ == \"MyClass\"\n"
"assert unpickled_class.my_attribute == 1"
msgstr ""
"import io\n"
"import pickle\n"
"\n"
"class MyClass:\n"
"    my_attribute = 1\n"
"\n"
"class MyPickler(pickle.Pickler):\n"
"    def reducer_override(self, obj):\n"
"        \"\"\"Redutor personalizado para MyClass.\"\"\"\n"
"        if getattr(obj, \"__name__\", None) == \"MyClass\":\n"
"            return type, (obj.__name__, obj.__bases__,\n"
"                          {'my_attribute': obj.my_attribute})\n"
"        else:\n"
"            # Para qualquer outro objeto, recorre à redução de costume\n"
"            return NotImplemented\n"
"\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)\n"
"p.dump(MyClass)\n"
"\n"
"del MyClass\n"
"\n"
"unpickled_class = pickle.loads(f.getvalue())\n"
"\n"
"assert isinstance(unpickled_class, type)\n"
"assert unpickled_class.__name__ == \"MyClass\"\n"
"assert unpickled_class.my_attribute == 1"

#: ../../library/pickle.rst:956
msgid "Out-of-band Buffers"
msgstr "Buffers fora da banda"

#: ../../library/pickle.rst:960
msgid ""
"In some contexts, the :mod:`pickle` module is used to transfer massive "
"amounts of data.  Therefore, it can be important to minimize the number of "
"memory copies, to preserve performance and resource consumption.  However, "
"normal operation of the :mod:`pickle` module, as it transforms a graph-like "
"structure of objects into a sequential stream of bytes, intrinsically "
"involves copying data to and from the pickle stream."
msgstr ""
"Em alguns contextos, o módulo :mod:`pickle` é usado para transferir grandes "
"quantidades de dados. Portanto, pode ser importante minimizar o número de "
"cópias de memória para preservar o desempenho e o consumo de recursos. No "
"entanto, a operação normal do módulo :mod:`pickle`, à medida que transforma "
"uma estrutura semelhante a um gráfico de objetos em um fluxo sequencial de "
"bytes, envolve intrinsecamente a cópia de dados de e para o fluxo pickle."

#: ../../library/pickle.rst:967
msgid ""
"This constraint can be eschewed if both the *provider* (the implementation "
"of the object types to be transferred) and the *consumer* (the "
"implementation of the communications system) support the out-of-band "
"transfer facilities provided by pickle protocol 5 and higher."
msgstr ""
"Esta restrição pode ser evitada se tanto o *fornecedor* (a implementação dos "
"tipos de objetos a serem transferidos) e o *consumidor* (a implementação do "
"sistema de comunicações) tiverem suporte aos recursos de transferência fora "
"de banda fornecidos pelo protocolo pickle 5 e superior."

#: ../../library/pickle.rst:973
msgid "Provider API"
msgstr "API de provedor"

#: ../../library/pickle.rst:975
msgid ""
"The large data objects to be pickled must implement "
"a :meth:`~object.__reduce_ex__` method specialized for protocol 5 and "
"higher, which returns a :class:`PickleBuffer` instance (instead of e.g. "
"a :class:`bytes` object) for any large data."
msgstr ""
"Os grandes objetos de dados a serem serializados com pickle devem "
"implementar um método :meth:`~object.__reduce_ex__` especializado para o "
"protocolo 5 e superior, que retorna uma instância :class:`PickleBuffer` (em "
"vez de, por exemplo, um objeto :class:`bytes`) para quaisquer dados grandes."

#: ../../library/pickle.rst:980
msgid ""
"A :class:`PickleBuffer` object *signals* that the underlying buffer is "
"eligible for out-of-band data transfer.  Those objects remain compatible "
"with normal usage of the :mod:`pickle` module.  However, consumers can also "
"opt-in to tell :mod:`pickle` that they will handle those buffers by "
"themselves."
msgstr ""
"Um objeto :class:`PickleBuffer` *sinaliza* que o buffer subjacente é "
"elegível para transferência de dados fora de banda. Esses objetos permanecem "
"compatíveis com o uso normal do módulo :mod:`pickle`. No entanto, os "
"consumidores também podem optar por dizer ao :mod:`pickle` que eles irão "
"lidar com esses buffers por conta própria."

#: ../../library/pickle.rst:987
msgid "Consumer API"
msgstr "API de consumidor"

#: ../../library/pickle.rst:989
msgid ""
"A communications system can enable custom handling of "
"the :class:`PickleBuffer` objects generated when serializing an object graph."
msgstr ""
"Um sistema de comunicação pode permitir o manuseio personalizado dos "
"objetos :class:`PickleBuffer` gerados ao serializar um grafo de objeto."

#: ../../library/pickle.rst:992
msgid ""
"On the sending side, it needs to pass a *buffer_callback* argument "
"to :class:`Pickler` (or to the :func:`dump` or :func:`dumps` function), "
"which will be called with each :class:`PickleBuffer` generated while "
"pickling the object graph.  Buffers accumulated by the *buffer_callback* "
"will not see their data copied into the pickle stream, only a cheap marker "
"will be inserted."
msgstr ""
"No lado emissor, é necessário passar um argumento *buffer_callback* "
"para :class:`Pickler` (ou para a função :func:`dump` ou :func:`dumps`), que "
"será chamada com cada :class:`PickleBuffer` gerado durante a serialização "
"com pickle do grafo do objeto. Os buffers acumulados pelo *buffer_callback* "
"não verão seus dados copiados no fluxo pickle, apenas um marcador barato "
"será inserido."

#: ../../library/pickle.rst:999
msgid ""
"On the receiving side, it needs to pass a *buffers* argument "
"to :class:`Unpickler` (or to the :func:`load` or :func:`loads` function), "
"which is an iterable of the buffers which were passed to *buffer_callback*. "
"That iterable should produce buffers in the same order as they were passed "
"to *buffer_callback*.  Those buffers will provide the data expected by the "
"reconstructors of the objects whose pickling produced the "
"original :class:`PickleBuffer` objects."
msgstr ""
"No lado receptor, é necessário passar um argumento *buffers* "
"para :class:`Unpickler` (ou para a função :func:`load` ou :func:`load`), que "
"é um iterável dos buffers que foram passado para *buffer_callback*. Esse "
"iterável deve produzir buffers na mesma ordem em que foram passados para "
"*buffer_callback*. Esses buffers fornecerão os dados esperados pelos "
"reconstrutores dos objetos cuja serialização com pickle produziu os "
"objetos :class:`PickleBuffer` originais."

#: ../../library/pickle.rst:1007
msgid ""
"Between the sending side and the receiving side, the communications system "
"is free to implement its own transfer mechanism for out-of-band buffers. "
"Potential optimizations include the use of shared memory or datatype-"
"dependent compression."
msgstr ""
"Entre o lado emissor e o lado receptor, o sistema de comunicações está livre "
"para implementar seu próprio mecanismo de transferência para buffers fora de "
"banda. As otimizações potenciais incluem o uso de memória compartilhada ou "
"compactação dependente do tipo de dados."

#: ../../library/pickle.rst:1013
msgid "Example"
msgstr "Exemplo"

#: ../../library/pickle.rst:1015
msgid ""
"Here is a trivial example where we implement a :class:`bytearray` subclass "
"able to participate in out-of-band buffer pickling::"
msgstr ""
"Aqui está um exemplo trivial onde implementamos uma subclasse "
"de :class:`bytearray` capaz de participar de serialização com pickle de "
"buffer fora de banda::"

#: ../../library/pickle.rst:1018
msgid ""
"class ZeroCopyByteArray(bytearray):\n"
"\n"
"    def __reduce_ex__(self, protocol):\n"
"        if protocol >= 5:\n"
"            return type(self)._reconstruct, (PickleBuffer(self),), None\n"
"        else:\n"
"            # PickleBuffer is forbidden with pickle protocols <= 4.\n"
"            return type(self)._reconstruct, (bytearray(self),)\n"
"\n"
"    @classmethod\n"
"    def _reconstruct(cls, obj):\n"
"        with memoryview(obj) as m:\n"
"            # Get a handle over the original buffer object\n"
"            obj = m.obj\n"
"            if type(obj) is cls:\n"
"                # Original buffer object is a ZeroCopyByteArray, return it\n"
"                # as-is.\n"
"                return obj\n"
"            else:\n"
"                return cls(obj)"
msgstr ""

#: ../../library/pickle.rst:1039
msgid ""
"The reconstructor (the ``_reconstruct`` class method) returns the buffer's "
"providing object if it has the right type.  This is an easy way to simulate "
"zero-copy behaviour on this toy example."
msgstr ""
"O reconstrutor (o método de classe ``_reconstruct``) retorna o objeto de "
"fornecimento do buffer se ele tiver o tipo correto. Esta é uma maneira fácil "
"de simular o comportamento de cópia zero neste exemplo de brinquedo."

#: ../../library/pickle.rst:1043
msgid ""
"On the consumer side, we can pickle those objects the usual way, which when "
"unserialized will give us a copy of the original object::"
msgstr ""
"Do lado consumidor, podemos serializar com pickle esses objetos da maneira "
"usual, que quando não serializados nos dará uma cópia do objeto original::"

#: ../../library/pickle.rst:1046
msgid ""
"b = ZeroCopyByteArray(b\"abc\")\n"
"data = pickle.dumps(b, protocol=5)\n"
"new_b = pickle.loads(data)\n"
"print(b == new_b)  # True\n"
"print(b is new_b)  # False: a copy was made"
msgstr ""

#: ../../library/pickle.rst:1052
msgid ""
"But if we pass a *buffer_callback* and then give back the accumulated "
"buffers when unserializing, we are able to get back the original object::"
msgstr ""
"Mas se passarmos um *buffer_callback* e, em seguida, retornarmos os buffers "
"acumulados ao desserializar, seremos capazes de recuperar o objeto original::"

#: ../../library/pickle.rst:1055
msgid ""
"b = ZeroCopyByteArray(b\"abc\")\n"
"buffers = []\n"
"data = pickle.dumps(b, protocol=5, buffer_callback=buffers.append)\n"
"new_b = pickle.loads(data, buffers=buffers)\n"
"print(b == new_b)  # True\n"
"print(b is new_b)  # True: no copy was made"
msgstr ""

#: ../../library/pickle.rst:1062
msgid ""
"This example is limited by the fact that :class:`bytearray` allocates its "
"own memory: you cannot create a :class:`bytearray` instance that is backed "
"by another object's memory.  However, third-party datatypes such as NumPy "
"arrays do not have this limitation, and allow use of zero-copy pickling (or "
"making as few copies as possible) when transferring between distinct "
"processes or systems."
msgstr ""
"Este exemplo é limitado pelo fato de que :class:`bytearray` aloca sua "
"própria memória: você não pode criar uma instância de :class:`bytearray` que "
"é apoiada pela memória de outro objeto. No entanto, tipos de dados de "
"terceiros, como arrays de NumPy, não têm essa limitação e permitem o uso de "
"serialização com pickle de cópia zero (ou fazer o mínimo de cópias possível) "
"ao transferir entre processos ou sistemas distintos."

#: ../../library/pickle.rst:1069
msgid ":pep:`574` -- Pickle protocol 5 with out-of-band data"
msgstr ":pep:`574` -- Protocolo de Pickle 5 com buffers de dados fora da banda"

#: ../../library/pickle.rst:1075
msgid "Restricting Globals"
msgstr "Restringindo globais"

#: ../../library/pickle.rst:1080
msgid ""
"By default, unpickling will import any class or function that it finds in "
"the pickle data.  For many applications, this behaviour is unacceptable as "
"it permits the unpickler to import and invoke arbitrary code.  Just consider "
"what this hand-crafted pickle data stream does when loaded::"
msgstr ""
"Por padrão, a desserialização com pickle importará qualquer classe ou função "
"que encontrar nos dados pickle. Para muitos aplicativos, esse comportamento "
"é inaceitável, pois permite que o unpickler importe e invoque código "
"arbitrário. Basta considerar o que este fluxo de dados pickle feito à mão "
"faz quando carregado::"

#: ../../library/pickle.rst:1085
msgid ""
">>> import pickle\n"
">>> pickle.loads(b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\")\n"
"hello world\n"
"0"
msgstr ""
">>> import pickle\n"
">>> pickle.loads(b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\")\n"
"hello world\n"
"0"

#: ../../library/pickle.rst:1090
msgid ""
"In this example, the unpickler imports the :func:`os.system` function and "
"then apply the string argument \"echo hello world\".  Although this example "
"is inoffensive, it is not difficult to imagine one that could damage your "
"system."
msgstr ""
"Neste exemplo, o unpickler importa a função :func:`os.system` e então aplica "
"o argumento string \"echo hello world\". Embora este exemplo seja "
"inofensivo, não é difícil imaginar um que possa danificar seu sistema."

#: ../../library/pickle.rst:1094
msgid ""
"For this reason, you may want to control what gets unpickled by "
"customizing :meth:`Unpickler.find_class`.  Unlike its name "
"suggests, :meth:`Unpickler.find_class` is called whenever a global (i.e., a "
"class or a function) is requested.  Thus it is possible to either completely "
"forbid globals or restrict them to a safe subset."
msgstr ""
"Por esta razão, você pode querer controlar o que é desserializado com pickle "
"personalizando :meth:`Unpickler.find_class`. Ao contrário do que seu nome "
"sugere, :meth:`Unpickler.find_class` é chamado sempre que um global (ou "
"seja, uma classe ou uma função) é solicitado. Assim, é possível proibir "
"completamente os globais ou restringi-los a um subconjunto seguro."

#: ../../library/pickle.rst:1100
msgid ""
"Here is an example of an unpickler allowing only few safe classes from "
"the :mod:`builtins` module to be loaded::"
msgstr ""
"Aqui está um exemplo de um unpickler que permite que apenas algumas classes "
"seguras do módulo :mod:`builtins` sejam carregadas::"

#: ../../library/pickle.rst:1103
msgid ""
"import builtins\n"
"import io\n"
"import pickle\n"
"\n"
"safe_builtins = {\n"
"    'range',\n"
"    'complex',\n"
"    'set',\n"
"    'frozenset',\n"
"    'slice',\n"
"}\n"
"\n"
"class RestrictedUnpickler(pickle.Unpickler):\n"
"\n"
"    def find_class(self, module, name):\n"
"        # Only allow safe classes from builtins.\n"
"        if module == \"builtins\" and name in safe_builtins:\n"
"            return getattr(builtins, name)\n"
"        # Forbid everything else.\n"
"        raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" %\n"
"                                     (module, name))\n"
"\n"
"def restricted_loads(s):\n"
"    \"\"\"Helper function analogous to pickle.loads().\"\"\"\n"
"    return RestrictedUnpickler(io.BytesIO(s)).load()"
msgstr ""

#: ../../library/pickle.rst:1129
msgid "A sample usage of our unpickler working as intended::"
msgstr "Um exemplo de uso do nosso unpickler funcionando como esperado::"

#: ../../library/pickle.rst:1131
msgid ""
">>> restricted_loads(pickle.dumps([1, 2, range(15)]))\n"
"[1, 2, range(0, 15)]\n"
">>> restricted_loads(b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\")\n"
"Traceback (most recent call last):\n"
"  ...\n"
"pickle.UnpicklingError: global 'os.system' is forbidden\n"
">>> restricted_loads(b'cbuiltins\\neval\\n'\n"
"...                  b'(S\\'getattr(__import__(\"os\"), \"system\")'\n"
"...                  b'(\"echo hello world\")\\'\\ntR.')\n"
"Traceback (most recent call last):\n"
"  ...\n"
"pickle.UnpicklingError: global 'builtins.eval' is forbidden"
msgstr ""

#: ../../library/pickle.rst:1148
msgid ""
"As our examples shows, you have to be careful with what you allow to be "
"unpickled.  Therefore if security is a concern, you may want to consider "
"alternatives such as the marshalling API in :mod:`xmlrpc.client` or third-"
"party solutions."
msgstr ""
"Como nossos exemplos mostram, você deve ter cuidado com o que permite que "
"seja desserializado com pickle. Portanto, se a segurança é uma preocupação, "
"você pode querer considerar alternativas como a API de marshalling "
"em :mod:`xmlrpc.client` ou soluções de terceiros."

#: ../../library/pickle.rst:1155
msgid "Performance"
msgstr "Desempenho"

#: ../../library/pickle.rst:1157
msgid ""
"Recent versions of the pickle protocol (from protocol 2 and upwards) feature "
"efficient binary encodings for several common features and built-in types. "
"Also, the :mod:`pickle` module has a transparent optimizer written in C."
msgstr ""
"Versões recentes do protocolo pickle (do protocolo 2 em diante) apresentam "
"codificações binárias eficientes para vários recursos comuns e tipos "
"embutidos. Além disso, o módulo :mod:`pickle` tem um otimizador transparente "
"escrito em C."

#: ../../library/pickle.rst:1165
msgid "Examples"
msgstr "Exemplos"

#: ../../library/pickle.rst:1167
msgid ""
"For the simplest code, use the :func:`dump` and :func:`load` functions. ::"
msgstr ""
"Para código mais simples, use as funções :func:`dump` e :func:`load`. ::"

#: ../../library/pickle.rst:1169
msgid ""
"import pickle\n"
"\n"
"# An arbitrary collection of objects supported by pickle.\n"
"data = {\n"
"    'a': [1, 2.0, 3+4j],\n"
"    'b': (\"character string\", b\"byte string\"),\n"
"    'c': {None, True, False}\n"
"}\n"
"\n"
"with open('data.pickle', 'wb') as f:\n"
"    # Pickle the 'data' dictionary using the highest protocol available.\n"
"    pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)"
msgstr ""

#: ../../library/pickle.rst:1183
msgid "The following example reads the resulting pickled data. ::"
msgstr ""
"O exemplo a seguir lê os dados resultantes em serializados com pickle. ::"

#: ../../library/pickle.rst:1185
msgid ""
"import pickle\n"
"\n"
"with open('data.pickle', 'rb') as f:\n"
"    # The protocol version used is detected automatically, so we do not\n"
"    # have to specify it.\n"
"    data = pickle.load(f)"
msgstr ""

#: ../../library/pickle.rst:1199
msgid "Module :mod:`copyreg`"
msgstr "Módulo :mod:`copyreg`"

#: ../../library/pickle.rst:1200
msgid "Pickle interface constructor registration for extension types."
msgstr "Registro de construtor de interface Pickle para tipos de extensão."

#: ../../library/pickle.rst:1202
msgid "Module :mod:`pickletools`"
msgstr "Módulo :mod:`pickletools`"

#: ../../library/pickle.rst:1203
msgid "Tools for working with and analyzing pickled data."
msgstr "Ferramentas para trabalhar e analisar dados serializados com pickle."

#: ../../library/pickle.rst:1205
msgid "Module :mod:`shelve`"
msgstr "Módulo :mod:`shelve`"

#: ../../library/pickle.rst:1206
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr "Banco de dados indexado de objetos; usa :mod:`pickle`."

#: ../../library/pickle.rst:1208
msgid "Module :mod:`copy`"
msgstr "Módulo :mod:`copy`"

#: ../../library/pickle.rst:1209
msgid "Shallow and deep object copying."
msgstr "Cópia rasa e cópia profunda de objeto."

#: ../../library/pickle.rst:1211
msgid "Module :mod:`marshal`"
msgstr "Módulo :mod:`marshal`"

#: ../../library/pickle.rst:1212
msgid "High-performance serialization of built-in types."
msgstr "Serialização de alto desempenho de tipos embutidos."

#: ../../library/pickle.rst:1216
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../library/pickle.rst:1217
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr "Não confunda isso com o módulo :mod:`marshal`"

#: ../../library/pickle.rst:1219
msgid ""
"This is why :keyword:`lambda` functions cannot be pickled:  all :keyword:`!"
"lambda` functions share the same name:  ``<lambda>``."
msgstr ""
"É por isso que funções :keyword:`lambda` não podem ser serializadas com "
"pickle: todas as funções :keyword:`!lambda` compartilham o mesmo nome:  "
"``<lambda>``."

#: ../../library/pickle.rst:1222
msgid ""
"The exception raised will likely be an :exc:`ImportError` or "
"an :exc:`AttributeError` but it could be something else."
msgstr ""
"A exceção levantada provavelmente será uma :exc:`ImportError` ou "
"uma :exc:`AttributeError`, mas poderia ser outra coisa."

#: ../../library/pickle.rst:1225
msgid ""
"The :mod:`copy` module uses this protocol for shallow and deep copying "
"operations."
msgstr ""
"O módulo :mod:`copy` usa este protocolo para operações de cópia rasa e cópia "
"profunda."

#: ../../library/pickle.rst:1228
msgid ""
"The limitation on alphanumeric characters is due to the fact that persistent "
"IDs in protocol 0 are delimited by the newline character.  Therefore if any "
"kind of newline characters occurs in persistent IDs, the resulting pickled "
"data will become unreadable."
msgstr ""
"A limitação de caracteres alfanuméricos se deve ao fato de que os IDs "
"persistentes, no protocolo 0, serem delimitados pelo caractere de nova "
"linha. Portanto, se qualquer tipo de caractere de nova linha ocorrer em IDs "
"persistentes, os dados resultantes da serialização com pickle se tornarão "
"ilegíveis."

#: ../../library/pickle.rst:12
msgid "persistence"
msgstr "persistência"

#: ../../library/pickle.rst:12
msgid "persistent"
msgstr "persistente"

#: ../../library/pickle.rst:12
msgid "objects"
msgstr "objetos"

#: ../../library/pickle.rst:12
msgid "serializing"
msgstr "serialização"

#: ../../library/pickle.rst:12
msgid "marshalling"
msgstr "marshalling"

#: ../../library/pickle.rst:12
msgid "flattening"
msgstr "flattening"

#: ../../library/pickle.rst:12
msgid "pickling"
msgstr "pickling"

#: ../../library/pickle.rst:123
msgid "External Data Representation"
msgstr "External Data Representation"

#: ../../library/pickle.rst:672
msgid "copy"
msgstr "copy"

#: ../../library/pickle.rst:672
msgid "protocol"
msgstr "protocolo"

#: ../../library/pickle.rst:756
msgid "persistent_id (pickle protocol)"
msgstr "persistent_id (protocolo pickle)"

#: ../../library/pickle.rst:756
msgid "persistent_load (pickle protocol)"
msgstr "persistent_load (protocolo pickle)"

#: ../../library/pickle.rst:832
msgid "__getstate__() (copy protocol)"
msgstr "__getstate__() (protocolo de cópia)"

#: ../../library/pickle.rst:832
msgid "__setstate__() (copy protocol)"
msgstr "__setstate__() (protocolo de cópia)"

#: ../../library/pickle.rst:1077
msgid "find_class() (pickle protocol)"
msgstr "find_class() (protocolo pickle)"

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Sheila Gomes <sheilagomes1@gmail.com>, 2021
# Marcos Wenneton Araújo <mwvda.eng@uea.edu.br>, 2021
# Gutierri Barboza <github+me@gutierri.me>, 2023
# Marco Rougeth <marco@rougeth.com>, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2023
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-01-12 14:14+0000\n"
"PO-Revision-Date: 2021-06-28 01:10+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2023\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/os.path.rst:2
msgid ":mod:`os.path` --- Common pathname manipulations"
msgstr ":mod:`os.path` --- Manipulações comuns de nomes de caminhos"

#: ../../library/os.path.rst:7
msgid ""
"**Source code:** :source:`Lib/posixpath.py` (for POSIX) and :source:`Lib/"
"ntpath.py` (for Windows)."
msgstr ""
"**Código-fonte:** :source:`Lib/posixpath.py` (para POSIX) e :source:`Lib/"
"ntpath.py` (para Windows)."

#: ../../library/os.path.rst:14
msgid ""
"This module implements some useful functions on pathnames. To read or write "
"files see :func:`open`, and for accessing the filesystem see the :mod:`os` "
"module. The path parameters can be passed as strings, or bytes, or any "
"object implementing the :class:`os.PathLike` protocol."
msgstr ""
"Este módulo implementa algumas funções úteis em nomes de caminho. Para ler "
"ou escrever arquivos veja :func:`open`, e para acessar o sistema de arquivos "
"veja o módulo :mod:`os`. Os parâmetros de caminho podem ser passados como "
"strings, ou bytes, ou qualquer objeto que implemente o protocolo :class:`os."
"PathLike`."

#: ../../library/os.path.rst:19
msgid ""
"Unlike a Unix shell, Python does not do any *automatic* path expansions. "
"Functions such as :func:`expanduser` and :func:`expandvars` can be invoked "
"explicitly when an application desires shell-like path expansion.  (See also "
"the :mod:`glob` module.)"
msgstr ""
"Ao contrário de um shell Unix, Python não faz nenhuma expansão *automática* "
"de caminho. Funções como :func:`expanduser` e :func:`expandvars` podem ser "
"invocadas explicitamente quando uma aplicação deseja uma expansão de caminho "
"no estilo do shell. (Veja também o módulo :mod:`glob`.)"

#: ../../library/os.path.rst:26
msgid "The :mod:`pathlib` module offers high-level path objects."
msgstr "O módulo :mod:`pathlib` oferece objetos de caminho de alto nível."

#: ../../library/os.path.rst:31
msgid ""
"All of these functions accept either only bytes or only string objects as "
"their parameters.  The result is an object of the same type, if a path or "
"file name is returned."
msgstr ""
"Todas essas funções aceitam apenas bytes ou apenas objetos de string como "
"seus parâmetros. O resultado é um objeto do mesmo tipo, se um caminho ou "
"nome de arquivo for retornado."

#: ../../library/os.path.rst:37
msgid ""
"Since different operating systems have different path name conventions, "
"there are several versions of this module in the standard library.  The :mod:"
"`os.path` module is always the path module suitable for the operating system "
"Python is running on, and therefore usable for local paths.  However, you "
"can also import and use the individual modules if you want to manipulate a "
"path that is *always* in one of the different formats.  They all have the "
"same interface:"
msgstr ""
"Uma vez que diferentes sistemas operacionais têm diferentes convenções de "
"nome de caminho, existem várias versões deste módulo na biblioteca padrão. O "
"módulo :mod:`os.path` é sempre o módulo de caminho adequado para o sistema "
"operacional em que o Python está sendo executado e, portanto, pode ser usado "
"para caminhos locais. No entanto, você também pode importar e usar os "
"módulos individuais se quiser manipular um caminho que esteja *sempre* em um "
"dos diferentes formatos. Todos eles têm a mesma interface:"

#: ../../library/os.path.rst:45
msgid ":mod:`posixpath` for UNIX-style paths"
msgstr ":mod:`posixpath` para caminhos no estilo UNIX"

#: ../../library/os.path.rst:46
msgid ":mod:`ntpath` for Windows paths"
msgstr ":mod:`ntpath` para caminhos do Windows"

#: ../../library/os.path.rst:51
msgid ""
":func:`exists`, :func:`lexists`, :func:`isdir`, :func:`isfile`, :func:"
"`islink`, and :func:`ismount` now return ``False`` instead of raising an "
"exception for paths that contain characters or bytes unrepresentable at the "
"OS level."
msgstr ""
":func:`exists`, :func:`lexists`, :func:`isdir`, :func:`isfile`, :func:"
"`islink` e :func:`ismount` agora retornam ``False`` em vez de levantar uma "
"exceção para caminhos que contêm caracteres ou bytes não representáveis no "
"nível de sistema de operacional."

#: ../../library/os.path.rst:59
msgid ""
"Return a normalized absolutized version of the pathname *path*. On most "
"platforms, this is equivalent to calling the function :func:`normpath` as "
"follows: ``normpath(join(os.getcwd(), path))``."
msgstr ""
"Retorna uma versão normalizada e absolutizada do nome de caminho *path*. Na "
"maioria das plataformas, isso é equivalente a chamar a função :func:"
"`normpath` da seguinte forma: ``normpath(join(os.getcwd(), path))``."

#: ../../library/os.path.rst:63 ../../library/os.path.rst:76
#: ../../library/os.path.rst:116 ../../library/os.path.rst:125
#: ../../library/os.path.rst:141 ../../library/os.path.rst:151
#: ../../library/os.path.rst:177 ../../library/os.path.rst:197
#: ../../library/os.path.rst:214 ../../library/os.path.rst:226
#: ../../library/os.path.rst:235 ../../library/os.path.rst:245
#: ../../library/os.path.rst:255 ../../library/os.path.rst:265
#: ../../library/os.path.rst:284 ../../library/os.path.rst:303
#: ../../library/os.path.rst:352 ../../library/os.path.rst:372
#: ../../library/os.path.rst:395 ../../library/os.path.rst:417
#: ../../library/os.path.rst:435 ../../library/os.path.rst:448
#: ../../library/os.path.rst:464 ../../library/os.path.rst:480
#: ../../library/os.path.rst:505 ../../library/os.path.rst:569
msgid "Accepts a :term:`path-like object`."
msgstr "Aceita um :term:`objeto caminho ou similar`."

#: ../../library/os.path.rst:69
msgid ""
"Return the base name of pathname *path*.  This is the second element of the "
"pair returned by passing *path* to the function :func:`split`.  Note that "
"the result of this function is different from the Unix :program:`basename` "
"program; where :program:`basename` for ``'/foo/bar/'`` returns ``'bar'``, "
"the :func:`basename` function returns an empty string (``''``)."
msgstr ""
"Retorna o nome base do caminho *path*. Este é o segundo elemento do par "
"retornado pela passagem de *path* para a função :func:`split`. Observe que o "
"resultado desta função é diferente do programa Unix :program:`basename`; "
"onde :program:`basename` para ``'/foo/bar/'`` retorna ``'bar'``, a função :"
"func:`basename` retorna uma string vazia (``''``)."

#: ../../library/os.path.rst:82
msgid ""
"Return the longest common sub-path of each pathname in the sequence "
"*paths*.  Raise :exc:`ValueError` if *paths* contain both absolute and "
"relative pathnames, the *paths* are on the different drives or if *paths* is "
"empty.  Unlike :func:`commonprefix`, this returns a valid path."
msgstr ""
"Retorna o subcaminho comum mais longo de cada nome de caminho na sequência "
"*paths*. Levanta :exc:`ValueError` se *path* contiverem nomes de caminho "
"absolutos e relativos, os *paths* estiverem em unidades diferentes ou se "
"*paths* estiverem vazios. Ao contrário de :func:`commonprefix`, retorna um "
"caminho válido."

#: ../../library/os.path.rst:88 ../../library/os.path.rst:415
#: ../../library/os.path.rst:427 ../../library/os.path.rst:443
#: ../../library/os.path.rst:459
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`Disponibilidade <availability>`: Unix, Windows."

#: ../../library/os.path.rst:92
msgid "Accepts a sequence of :term:`path-like objects <path-like object>`."
msgstr ""
"Aceita uma sequência de :term:`objetos caminho ou similar <path-like "
"object>`."

#: ../../library/os.path.rst:98
msgid ""
"Return the longest path prefix (taken character-by-character) that is a "
"prefix of all paths in  *list*.  If *list* is empty, return the empty string "
"(``''``)."
msgstr ""
"Retorna o prefixo de caminho mais longo (obtido caractere por caractere) que "
"é um prefixo de todos os caminhos em *list*. Se *list* estiver vazia, "
"retorna a string vazia (``''``)."

#: ../../library/os.path.rst:104
msgid ""
"This function may return invalid paths because it works a character at a "
"time.  To obtain a valid path, see :func:`commonpath`."
msgstr ""
"Esta função pode retornar caminhos inválidos porque funciona um caractere "
"por vez. Para obter um caminho válido, consulte :func:`commonpath`."

#: ../../library/os.path.rst:122
msgid ""
"Return the directory name of pathname *path*.  This is the first element of "
"the pair returned by passing *path* to the function :func:`split`."
msgstr ""
"Retorna o nome do diretório do nome de caminho *path*. Este é o primeiro "
"elemento do par retornado passando *path* para a função :func:`split`."

#: ../../library/os.path.rst:131
msgid ""
"Return ``True`` if *path* refers to an existing path or an open file "
"descriptor.  Returns ``False`` for broken symbolic links.  On some "
"platforms, this function may return ``False`` if permission is not granted "
"to execute :func:`os.stat` on the requested file, even if the *path* "
"physically exists."
msgstr ""
"Retorna ``True`` se *path* se referir a um caminho existente ou um descritor "
"de arquivo aberto. Retorna ``False`` para links simbólicos quebrados. Em "
"algumas plataformas, esta função pode retornar ``False`` se a permissão não "
"for concedida para executar :func:`os.stat` no arquivo solicitado, mesmo se "
"o *path* existir fisicamente."

#: ../../library/os.path.rst:137
msgid ""
"*path* can now be an integer: ``True`` is returned if it is an  open file "
"descriptor, ``False`` otherwise."
msgstr ""
"*path* agora pode ser um inteiro: ``True`` é retornado se for um descritor "
"de arquivo aberto, ``False`` caso contrário."

#: ../../library/os.path.rst:147
msgid ""
"Return ``True`` if *path* refers to an existing path. Returns ``True`` for "
"broken symbolic links.   Equivalent to :func:`exists` on platforms lacking :"
"func:`os.lstat`."
msgstr ""
"Retorna ``True`` se *path* se referir a um caminho existente. Retorna "
"``True`` para links simbólicos quebrados. Equivalente a :func:`exists` em "
"plataformas sem :func:`os.lstat`."

#: ../../library/os.path.rst:159
msgid ""
"On Unix and Windows, return the argument with an initial component of ``~`` "
"or ``~user`` replaced by that *user*'s home directory."
msgstr ""
"No Unix e no Windows, retorna o argumento com um componente inicial de ``~`` "
"ou ``~user`` substituído pelo diretório inicial daquele usuário *user*."

#: ../../library/os.path.rst:164
msgid ""
"On Unix, an initial ``~`` is replaced by the environment variable :envvar:"
"`HOME` if it is set; otherwise the current user's home directory is looked "
"up in the password directory through the built-in module :mod:`pwd`. An "
"initial ``~user`` is looked up directly in the password directory."
msgstr ""
"No Unix, um ``~`` no início é substituído pela variável de ambiente :envvar:"
"`HOME` se estiver definida; caso contrário, o diretório pessoal do usuário "
"atual é procurado no diretório de senha através do módulo embutido :mod:"
"`pwd`. Um ``~user`` no início é procurado diretamente no diretório de senhas."

#: ../../library/os.path.rst:169
msgid ""
"On Windows, :envvar:`USERPROFILE` will be used if set, otherwise a "
"combination of :envvar:`HOMEPATH` and :envvar:`HOMEDRIVE` will be used.  An "
"initial ``~user`` is handled by checking that the last directory component "
"of the current user's home directory matches :envvar:`USERNAME`, and "
"replacing it if so."
msgstr ""
"No Windows, :envvar:`USERPROFILE` será usada se definida; caso contrário, "
"uma combinação de :envvar:`HOMEPATH` e :envvar:`HOMEDRIVE` será usada. Um "
"``~user`` inicial é tratado verificando se o último componente do diretório "
"home do usuário atual corresponde a :envvar:`USERNAME`, e substituindo-o se "
"for o caso."

#: ../../library/os.path.rst:174
msgid ""
"If the expansion fails or if the path does not begin with a tilde, the path "
"is returned unchanged."
msgstr ""
"Se a expansão falhar ou se o caminho não começar com um til, o caminho será "
"retornado inalterado."

#: ../../library/os.path.rst:180
msgid "No longer uses :envvar:`HOME` on Windows."
msgstr "Não usa mais :envvar:`HOME` no Windows."

#: ../../library/os.path.rst:189
msgid ""
"Return the argument with environment variables expanded.  Substrings of the "
"form ``$name`` or ``${name}`` are replaced by the value of environment "
"variable *name*.  Malformed variable names and references to non-existing "
"variables are left unchanged."
msgstr ""
"Retorna o argumento com as variáveis de ambiente expandidas. Substrings da "
"forma ``$name`` ou ``${name}`` são substituídas pelo valor da variável de "
"ambiente *name*. Nomes de variáveis malformados e referências a variáveis "
"não existentes permanecem inalterados."

#: ../../library/os.path.rst:194
msgid ""
"On Windows, ``%name%`` expansions are supported in addition to ``$name`` and "
"``${name}``."
msgstr ""
"No Windows, expansões ``%name%`` são suportadas juntamente a ``$name`` e "
"``${name}``."

#: ../../library/os.path.rst:203
msgid ""
"Return the time of last access of *path*.  The return value is a floating "
"point number giving the number of seconds since the epoch (see the  :mod:"
"`time` module).  Raise :exc:`OSError` if the file does not exist or is "
"inaccessible."
msgstr ""
"Retorna a hora do último acesso de *path*. O valor de retorno é um número de "
"ponto flutuante dando o número de segundos desde a Era Unix (veja o módulo :"
"mod:`time`). Levanta :exc:`OSError` se o arquivo não existe ou está "
"inacessível."

#: ../../library/os.path.rst:210
msgid ""
"Return the time of last modification of *path*.  The return value is a "
"floating point number giving the number of seconds since the epoch (see "
"the  :mod:`time` module). Raise :exc:`OSError` if the file does not exist or "
"is inaccessible."
msgstr ""
"Retorna a hora da última modificação de *path*. O valor de retorno é um "
"número de ponto flutuante dando o número de segundos desde a Era Unix (veja "
"o módulo :mod:`time`). Levanta :exc:`OSError` se o arquivo não existe ou "
"está inacessível."

#: ../../library/os.path.rst:220
msgid ""
"Return the system's ctime which, on some systems (like Unix) is the time of "
"the last metadata change, and, on others (like Windows), is the creation "
"time for *path*. The return value is a number giving the number of seconds "
"since the epoch (see the  :mod:`time` module).  Raise :exc:`OSError` if the "
"file does not exist or is inaccessible."
msgstr ""
"Retorna o ctime do sistema que, em alguns sistemas (como Unix) é a hora da "
"última alteração de metadados, e, em outros (como Windows), é a hora de "
"criação de *path*. O valor de retorno é um número que fornece o número de "
"segundos desde a Era Unix (veja o módulo :mod:`time`). Levanta :exc:"
"`OSError` se o arquivo não existe ou está inacessível."

#: ../../library/os.path.rst:232
msgid ""
"Return the size, in bytes, of *path*.  Raise :exc:`OSError` if the file does "
"not exist or is inaccessible."
msgstr ""
"Retorna o tamanho, em bytes, de *path*. Levanta :exc:`OSError` se o arquivo "
"não existe ou está inacessível."

#: ../../library/os.path.rst:241
msgid ""
"Return ``True`` if *path* is an absolute pathname.  On Unix, that means it "
"begins with a slash, on Windows that it begins with a (back)slash after "
"chopping off a potential drive letter."
msgstr ""
"Retorna ``True`` se *path* for um nome de caminho absoluto. No Unix, isso "
"significa que começa com uma barra, no Windows começa com uma barra "
"(invertida) depois de eliminar uma possível letra de unidade."

#: ../../library/os.path.rst:251
msgid ""
"Return ``True`` if *path* is an :func:`existing <exists>` regular file. This "
"follows symbolic links, so both :func:`islink` and :func:`isfile` can be "
"true for the same path."
msgstr ""
"Retorna ``True`` se *path* for um arquivo regular :func:`existente "
"<exists>`. Isso segue links simbólicos, então :func:`islink` e :func:"
"`isfile` podem ser verdadeiros para o mesmo caminho."

#: ../../library/os.path.rst:261
msgid ""
"Return ``True`` if *path* is an :func:`existing <exists>` directory.  This "
"follows symbolic links, so both :func:`islink` and :func:`isdir` can be true "
"for the same path."
msgstr ""
"Retorna ``True`` se *path* for um diretório :func:`existente <exists>`. Isso "
"segue links simbólicos, então :func:`islink` e :func:`isdir` podem ser "
"verdadeiros para o mesmo caminho."

#: ../../library/os.path.rst:271
msgid ""
"Return ``True`` if *path* refers to an :func:`existing <lexists>` directory "
"entry that is a junction.  Always return ``False`` if junctions are not "
"supported on the current platform."
msgstr ""

#: ../../library/os.path.rst:280
msgid ""
"Return ``True`` if *path* refers to an :func:`existing <exists>` directory "
"entry that is a symbolic link.  Always ``False`` if symbolic links are not "
"supported by the Python runtime."
msgstr ""
"Retorna ``True`` se *path* se referir a uma entrada de diretório :func:"
"`existente <exists>` que é um link simbólico. Sempre ``False`` se links "
"simbólicos não forem suportados pelo tempo de execução Python."

#: ../../library/os.path.rst:290
msgid ""
"Return ``True`` if pathname *path* is a :dfn:`mount point`: a point in a "
"file system where a different file system has been mounted.  On POSIX, the "
"function checks whether *path*'s parent, :file:`{path}/..`, is on a "
"different device than *path*, or whether :file:`{path}/..` and *path* point "
"to the same i-node on the same device --- this should detect mount points "
"for all Unix and POSIX variants.  It is not able to reliably detect bind "
"mounts on the same filesystem.  On Windows, a drive letter root and a share "
"UNC are always mount points, and for any other path ``GetVolumePathName`` is "
"called to see if it is different from the input path."
msgstr ""
"Retorna ``True`` se o nome de caminho *path* for um :dfn:`ponto de "
"montagem`: um ponto em um sistema de arquivos onde um sistema de arquivos "
"diferente foi montado. No POSIX, a função verifica se o pai de *path*, :file:"
"`{path}/..`, está em um dispositivo diferente de *path*, ou se :file:"
"`{path}/..` e *path* apontam para o mesmo nó-i no mesmo dispositivo -- isso "
"deve detectar pontos de montagem para todas as variantes Unix e POSIX. Não é "
"capaz de detectar confiavelmente montagens bind no mesmo sistema de "
"arquivos. No Windows, uma raiz de letra de unidade e um UNC de "
"compartilhamento são sempre pontos de montagem e, para qualquer outro "
"caminho, ``GetVolumePathName`` é chamado para ver se é diferente do caminho "
"de entrada."

#: ../../library/os.path.rst:300
msgid "Support for detecting non-root mount points on Windows."
msgstr "Suporte para detecção de pontos de montagem não raiz no Windows."

#: ../../library/os.path.rst:309
msgid ""
"Return ``True`` if pathname *path* is located on a Windows Dev Drive. A Dev "
"Drive is optimized for developer scenarios, and offers faster performance "
"for reading and writing files. It is recommended for use for source code, "
"temporary build directories, package caches, and other IO-intensive "
"operations."
msgstr ""

#: ../../library/os.path.rst:315
msgid ""
"May raise an error for an invalid path, for example, one without a "
"recognizable drive, but returns ``False`` on platforms that do not support "
"Dev Drives. See `the Windows documentation <https://learn.microsoft.com/"
"windows/dev-drive/>`_ for information on enabling and creating Dev Drives."
msgstr ""

#: ../../library/os.path.rst:320
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Disponibilidade <availability>`: Windows."

#: ../../library/os.path.rst:327
msgid ""
"Join one or more path segments intelligently.  The return value is the "
"concatenation of *path* and all members of *\\*paths*, with exactly one "
"directory separator following each non-empty part, except the last. That is, "
"the result will only end in a separator if the last part is either empty or "
"ends in a separator. If a segment is an absolute path (which on Windows "
"requires both a drive and a root), then all previous segments are ignored "
"and joining continues from the absolute path segment."
msgstr ""
"Junta um ou mais segmentos do caminho de forma inteligente. O valor de "
"retorno é a concatenação de *path* e todos os membros de *\\*paths* com "
"exatamente um separador de diretório seguindo cada parte não vazia exceto a "
"última. Significa que o resultado só terminará em um separador se a última "
"parte estiver vazia ou terminar em um separador. Se um segmento for um "
"caminho absoluto (que no Windows requer a unidade/drive e uma raiz), todos "
"os segmentos anteriores serão ignorados e a união continuará a partir do "
"segmento do caminho absoluto."

#: ../../library/os.path.rst:335
msgid ""
"On Windows, the drive is not reset when a rooted path segment (e.g., "
"``r'\\foo'``) is encountered. If a segment is on a different drive or is an "
"absolute path, all previous segments are ignored and the drive is reset. "
"Note that since there is a current directory for each drive, ``os.path."
"join(\"c:\", \"foo\")`` represents a path relative to the current directory "
"on drive :file:`C:` (:file:`c:foo`), not :file:`c:\\\\foo`."
msgstr ""
"No Windows, a unidade não é redefinida quando um segmento de caminho raiz "
"(por exemplo, ``r'\\foo'``) é encontrado. Se um segmento contiver uma "
"unidade diferente ou um caminho absoluto, todos os segmentos anteriores "
"serão ignorados e a unidade será redefinida. Observe que, como há um "
"diretório atual para cada unidade, ``os.path.join(\"c:\", \"foo\")`` "
"representa um caminho relativo ao diretório atual na unidade :file:`C:` (:"
"file:`c:foo`), e não :file:`c:\\\\foo`."

#: ../../library/os.path.rst:342
msgid "Accepts a :term:`path-like object` for *path* and *paths*."
msgstr "Aceita um :term:`objeto caminho ou similar` para *path* e *paths*."

#: ../../library/os.path.rst:348
msgid ""
"Normalize the case of a pathname.  On Windows, convert all characters in the "
"pathname to lowercase, and also convert forward slashes to backward slashes. "
"On other operating systems, return the path unchanged."
msgstr ""
"Normaliza o estado de letras maiúsculas/minúsculas de um nome de caminho. No "
"Windows, converte todos os caracteres do nome do caminho em minúsculas e "
"também converte barras normais em barras invertidas. Em outros sistemas "
"operacionais, retorna o caminho inalterado."

#: ../../library/os.path.rst:358
msgid ""
"Normalize a pathname by collapsing redundant separators and up-level "
"references so that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all "
"become ``A/B``.  This string manipulation may change the meaning of a path "
"that contains symbolic links.  On Windows, it converts forward slashes to "
"backward slashes. To normalize case, use :func:`normcase`."
msgstr ""
"Normaliza um nome de caminho retirando separadores redundantes e referências "
"de nível superior para que ``A//B``, ``A/B/``, ``A/./B`` e ``A/foo/../B`` "
"todos se tornem ``A/B``. Essa manipulação de string pode mudar o significado "
"de um caminho que contém links simbólicos. No Windows, ele converte barras "
"normais em barras invertidas. Para normalizar o estado de letras maiúsculas/"
"minúsculas, use :func:`normcase`."

#: ../../library/os.path.rst:365
msgid ""
"On POSIX systems, in accordance with `IEEE Std 1003.1 2013 Edition; 4.13 "
"Pathname Resolution <https://pubs.opengroup.org/onlinepubs/9699919799/"
"basedefs/V1_chap04.html#tag_04_13>`_, if a pathname begins with exactly two "
"slashes, the first component following the leading characters may be "
"interpreted in an implementation-defined manner, although more than two "
"leading characters shall be treated as a single character."
msgstr ""
"Em sistemas POSIX, de acordo com `IEEE Std 1003.1 2013 Edition; 4.13 "
"Pathname Resolution <https://pubs.opengroup.org/onlinepubs/9699919799/"
"basedefs/V1_chap04.html#tag_04_13>`_, se um nome de caminho começa com "
"exatamente duas barras, o primeiro componente após os caracteres iniciais "
"pode ser interpretado em um forma definida pela implementação, embora mais "
"de dois caracteres iniciais devam ser tratados como um único caractere."

#: ../../library/os.path.rst:378
msgid ""
"Return the canonical path of the specified filename, eliminating any "
"symbolic links encountered in the path (if they are supported by the "
"operating system)."
msgstr ""
"Retorna o caminho canônico do nome do arquivo especificado, eliminando "
"quaisquer links simbólicos encontrados no caminho (se esses forem suportados "
"pelo sistema operacional)."

#: ../../library/os.path.rst:382
msgid ""
"If a path doesn't exist or a symlink loop is encountered, and *strict* is "
"``True``, :exc:`OSError` is raised. If *strict* is ``False``, the path is "
"resolved as far as possible and any remainder is appended without checking "
"whether it exists."
msgstr ""
"Se um caminho não existe ou um loop de link simbólico é encontrado, e "
"*strict* é ``True``, :exc:`OSError` é levantada. Se *strict* for ``False``, "
"o caminho será resolvido tanto quanto possível e qualquer resto é anexado "
"sem verificar se existe."

#: ../../library/os.path.rst:388
msgid ""
"This function emulates the operating system's procedure for making a path "
"canonical, which differs slightly between Windows and UNIX with respect to "
"how links and subsequent path components interact."
msgstr ""
"Esta função emula o procedimento do sistema operacional para tornar um "
"caminho canônico, que difere ligeiramente entre o Windows e o UNIX no que "
"diz respeito à interação dos links e dos componentes do caminho subsequentes."

#: ../../library/os.path.rst:392
msgid ""
"Operating system APIs make paths canonical as needed, so it's not normally "
"necessary to call this function."
msgstr ""
"As APIs do sistema operacional tornam os caminhos canônicos conforme "
"necessário, portanto, normalmente não é necessário chamar esta função."

#: ../../library/os.path.rst:398
msgid "Symbolic links and junctions are now resolved on Windows."
msgstr "Links simbólicos e junções agora são resolvidos no Windows."

#: ../../library/os.path.rst:401
msgid "The *strict* parameter was added."
msgstr "O parâmetro *script* foi adicionado."

#: ../../library/os.path.rst:407
msgid ""
"Return a relative filepath to *path* either from the current directory or "
"from an optional *start* directory.  This is a path computation:  the "
"filesystem is not accessed to confirm the existence or nature of *path* or "
"*start*.  On Windows, :exc:`ValueError` is raised when *path* and *start* "
"are on different drives."
msgstr ""
"Retorna um caminho de arquivo relativo a *caminho* do diretório atual ou de "
"um diretório *start* opcional. Este é um cálculo de caminho: o sistema de "
"arquivos não é acessado para confirmar a existência ou natureza de *path* ou "
"*start*. No Windows, :exc:`ValueError` é levantada quando *path* e *start* "
"estão em unidades diferentes."

#: ../../library/os.path.rst:413
msgid "*start* defaults to :data:`os.curdir`."
msgstr ""

#: ../../library/os.path.rst:423
msgid ""
"Return ``True`` if both pathname arguments refer to the same file or "
"directory. This is determined by the device number and i-node number and "
"raises an exception if an :func:`os.stat` call on either pathname fails."
msgstr ""
"Retorna ``True`` se ambos os argumentos de nome de caminho se referem ao "
"mesmo arquivo ou diretório. Isso é determinado pelo número do dispositivo e "
"número do nó-i e levanta uma exceção se uma chamada :func:`os.stat` em "
"qualquer um dos caminhos falhar."

#: ../../library/os.path.rst:429 ../../library/os.path.rst:445
#: ../../library/os.path.rst:461
msgid "Added Windows support."
msgstr "Adicionado suporte ao Windows."

#: ../../library/os.path.rst:432
msgid "Windows now uses the same implementation as all other platforms."
msgstr ""
"O Windows agora usa a mesma implementação que todas as outras plataformas."

#: ../../library/os.path.rst:441
msgid ""
"Return ``True`` if the file descriptors *fp1* and *fp2* refer to the same "
"file."
msgstr ""
"Retorna ``True`` se os descritores de arquivo *fp1* e *fp2* fazem referência "
"ao mesmo arquivo."

#: ../../library/os.path.rst:454
msgid ""
"Return ``True`` if the stat tuples *stat1* and *stat2* refer to the same "
"file. These structures may have been returned by :func:`os.fstat`, :func:`os."
"lstat`, or :func:`os.stat`.  This function implements the underlying "
"comparison used by :func:`samefile` and :func:`sameopenfile`."
msgstr ""
"Retorna ``True`` se as tuplas de estatísticas *stat1* e *stat2* fazem "
"referência ao mesmo arquivo. Essas estruturas podem ter sido retornadas por :"
"func:`os.fstat`, :func:`os.lstat` ou :func:`os.stat`. Esta função implementa "
"a comparação subjacente usada por :func:`samefile` e :func:`sameopenfile`."

#: ../../library/os.path.rst:470
msgid ""
"Split the pathname *path* into a pair, ``(head, tail)`` where *tail* is the "
"last pathname component and *head* is everything leading up to that.  The "
"*tail* part will never contain a slash; if *path* ends in a slash, *tail* "
"will be empty.  If there is no slash in *path*, *head* will be empty.  If "
"*path* is empty, both *head* and *tail* are empty.  Trailing slashes are "
"stripped from *head* unless it is the root (one or more slashes only).  In "
"all cases, ``join(head, tail)`` returns a path to the same location as "
"*path* (but the strings may differ).  Also see the functions :func:`dirname` "
"and :func:`basename`."
msgstr ""
"Divide o caminho *path* em um par, ``(cabeça, rabo)`` onde *rabo* é o último "
"componente do nome do caminho e *cabeça* é tudo o que leva a isso. A parte "
"*rabo* nunca conterá uma barra; se *path* terminar com uma barra, *tail* "
"ficará vazio. Se não houver uma barra no *path*, o *head* ficará vazio. Se "
"*path* estiver vazio, *cabeça* e *rabo* estarão vazios. As barras finais são "
"retiradas da *cabeça*, a menos que seja a raiz (uma ou mais barras apenas). "
"Em todos os casos, ``join(cabeça, rabo)`` retorna um caminho para o mesmo "
"local que *path* (mas as strings podem ser diferentes). Veja também as "
"funções :func:`dirname` e :func:`basename`."

#: ../../library/os.path.rst:486
msgid ""
"Split the pathname *path* into a pair ``(drive, tail)`` where *drive* is "
"either a mount point or the empty string.  On systems which do not use drive "
"specifications, *drive* will always be the empty string.  In all cases, "
"``drive + tail`` will be the same as *path*."
msgstr ""
"Divide o nome do caminho *path* em um par ``(unidade, rabo)`` onde *unidade* "
"é um ponto de montagem ou uma string vazia. Em sistemas que não usam "
"especificações de unidade, *unidade* sempre será a string vazia. Em todos os "
"casos, ``unidade + rabo`` será o mesmo que *path*."

#: ../../library/os.path.rst:491
msgid ""
"On Windows, splits a pathname into drive/UNC sharepoint and relative path."
msgstr ""
"No Windows, divide um nome de caminho em unidade/ponto de compartilhamento "
"UNC e caminho relativo."

#: ../../library/os.path.rst:493
msgid ""
"If the path contains a drive letter, drive will contain everything up to and "
"including the colon::"
msgstr ""
"Se o caminho contiver uma letra de unidade, a unidade conterá tudo, "
"incluindo os dois pontos::"

#: ../../library/os.path.rst:499
msgid ""
"If the path contains a UNC path, drive will contain the host name and share::"
msgstr ""

#: ../../library/os.path.rst:511
msgid ""
"Split the pathname *path* into a 3-item tuple ``(drive, root, tail)`` where "
"*drive* is a device name or mount point, *root* is a string of separators "
"after the drive, and *tail* is everything after the root. Any of these items "
"may be the empty string. In all cases, ``drive + root + tail`` will be the "
"same as *path*."
msgstr ""

#: ../../library/os.path.rst:517
msgid ""
"On POSIX systems, *drive* is always empty. The *root* may be empty (if "
"*path* is relative), a single forward slash (if *path* is absolute), or two "
"forward slashes (implementation-defined per `IEEE Std 1003.1-2017; 4.13 "
"Pathname Resolution <https://pubs.opengroup.org/onlinepubs/9699919799/"
"basedefs/V1_chap04.html#tag_04_13>`_.) For example::"
msgstr ""

#: ../../library/os.path.rst:530
msgid ""
"On Windows, *drive* may be empty, a drive-letter name, a UNC share, or a "
"device name. The *root* may be empty, a forward slash, or a backward slash. "
"For example::"
msgstr ""

#: ../../library/os.path.rst:544
msgid ""
"Split the pathname *path* into a pair ``(root, ext)``  such that ``root + "
"ext == path``, and the extension, *ext*, is empty or begins with a period "
"and contains at most one period."
msgstr ""
"Divida o nome do caminho *path* em um par ``(root, ext)`` de modo que ``root "
"+ ext == path``, e a extensão, *ext*, esteja vazia ou comece com um ponto e "
"contenha no máximo um período."

#: ../../library/os.path.rst:548
msgid "If the path contains no extension, *ext* will be ``''``::"
msgstr "Se o caminho não contiver extensão, *ext* será ``''``::"

#: ../../library/os.path.rst:553
msgid ""
"If the path contains an extension, then *ext* will be set to this extension, "
"including the leading period. Note that previous periods will be ignored::"
msgstr ""
"Se o caminho contiver uma extensão, *ext* será definido para esta extensão, "
"incluindo o ponto inicial. Observe que os períodos anteriores serão "
"ignorados::"

#: ../../library/os.path.rst:561
msgid ""
"Leading periods of the last component of the path are considered to be part "
"of the root::"
msgstr ""
"Os períodos iniciais do último componente do caminho são considerados parte "
"da raiz::"

#: ../../library/os.path.rst:575
msgid ""
"``True`` if arbitrary Unicode strings can be used as file names (within "
"limitations imposed by the file system)."
msgstr ""
"``True`` se strings Unicode arbitrárias podem ser usadas como nomes de "
"arquivo (dentro das limitações impostas pelo sistema de arquivos)."

#: ../../library/os.path.rst:10
msgid "path"
msgstr "caminho"

#: ../../library/os.path.rst:10
msgid "operations"
msgstr "operações"

#: ../../library/os.path.rst:155
msgid "~ (tilde)"
msgstr "~ (til)"

#: ../../library/os.path.rst:155
msgid "home directory expansion"
msgstr ""

#: ../../library/os.path.rst:162
msgid "module"
msgstr "módulo"

#: ../../library/os.path.rst:162
msgid "pwd"
msgstr ""

#: ../../library/os.path.rst:183
msgid "$ (dollar)"
msgstr "$ (dólar)"

#: ../../library/os.path.rst:183
msgid "environment variables expansion"
msgstr ""

#: ../../library/os.path.rst:183
msgid "% (percent)"
msgstr "% (porcentagem)"

#: ../../library/os.path.rst:183
msgid "environment variables expansion (Windows)"
msgstr ""

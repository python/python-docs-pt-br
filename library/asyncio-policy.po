# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 17:51+0000\n"
"PO-Revision-Date: 2018-09-18 00:23+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/asyncio-policy.rst:8
msgid "Policies"
msgstr "Políticas"

#: ../../library/asyncio-policy.rst:10
msgid ""
"An event loop policy is a global per-process object that controls the "
"management of the event loop. Each event loop has a default policy, which "
"can be changed and customized using the policy API."
msgstr ""
"Uma política de laço de eventos é um objeto global por processo que controla "
"o gerenciamento do laço de eventos. Cada laço de eventos possui uma política "
"padrão, que pode ser alterada e personalizada usando a API de política."

#: ../../library/asyncio-policy.rst:14
msgid ""
"A policy defines the notion of *context* and manages a separate event loop "
"per context. The default policy defines *context* to be the current thread."
msgstr ""
"Uma política define a noção de *contexto* e gerencia um laço de eventos "
"separado por contexto. A política padrão define *context* como a thread "
"atual."

#: ../../library/asyncio-policy.rst:18
msgid ""
"By using a custom event loop policy, the behavior of :func:"
"`get_event_loop`, :func:`set_event_loop`, and :func:`new_event_loop` "
"functions can be customized."
msgstr ""

#: ../../library/asyncio-policy.rst:22
msgid ""
"Policy objects should implement the APIs defined in the :class:"
"`AbstractEventLoopPolicy` abstract base class."
msgstr ""
"Об’єкти політики мають реалізовувати API, визначені в :class:"
"`AbstractEventLoopPolicy` абстрактному базовому класі."

#: ../../library/asyncio-policy.rst:27
msgid "Getting and Setting the Policy"
msgstr "Отримання та налаштування політики"

#: ../../library/asyncio-policy.rst:29
msgid ""
"The following functions can be used to get and set the policy for the "
"current process:"
msgstr ""
"Наступні функції можна використовувати для отримання та налаштування "
"політики для поточного процесу:"

#: ../../library/asyncio-policy.rst:34
msgid "Return the current process-wide policy."
msgstr "Retorna a política de todo o processo atual."

#: ../../library/asyncio-policy.rst:38
msgid "Set the current process-wide policy to *policy*."
msgstr "Установіть поточну політику для всього процесу на *policy*."

#: ../../library/asyncio-policy.rst:40
msgid "If *policy* is set to ``None``, the default policy is restored."
msgstr ""
"Якщо *policy* встановлено на ``None``, політика за замовчуванням буде "
"відновлена."

#: ../../library/asyncio-policy.rst:44
msgid "Policy Objects"
msgstr "Об'єкти політики"

#: ../../library/asyncio-policy.rst:46
msgid "The abstract event loop policy base class is defined as follows:"
msgstr ""
"Базовий клас політики абстрактного циклу подій визначається наступним чином:"

#: ../../library/asyncio-policy.rst:50
msgid "An abstract base class for asyncio policies."
msgstr "Абстрактний базовий клас для асинхронних політик."

#: ../../library/asyncio-policy.rst:54
msgid "Get the event loop for the current context."
msgstr "Obtém o laço de eventos para o contexto atual."

#: ../../library/asyncio-policy.rst:56
msgid ""
"Return an event loop object implementing the :class:`AbstractEventLoop` "
"interface."
msgstr ""
"Повертає об’єкт циклу подій, що реалізує інтерфейс :class:"
"`AbstractEventLoop`."

#: ../../library/asyncio-policy.rst:59 ../../library/asyncio-policy.rst:71
msgid "This method should never return ``None``."
msgstr "Цей метод ніколи не повинен повертати ``None``."

#: ../../library/asyncio-policy.rst:65
msgid "Set the event loop for the current context to *loop*."
msgstr "Define o laço de eventos do contexto atual como *loop*."

#: ../../library/asyncio-policy.rst:69
msgid "Create and return a new event loop object."
msgstr "Cria e retorna um novo objeto de laço de eventos."

#: ../../library/asyncio-policy.rst:75
msgid "Get a child process watcher object."
msgstr "Отримайте дочірній об’єкт спостереження за процесом."

#: ../../library/asyncio-policy.rst:77
msgid ""
"Return a watcher object implementing the :class:`AbstractChildWatcher` "
"interface."
msgstr ""
"Повертає об’єкт спостереження, що реалізує інтерфейс :class:"
"`AbstractChildWatcher`."

#: ../../library/asyncio-policy.rst:80 ../../library/asyncio-policy.rst:86
msgid "This function is Unix specific."
msgstr "Ця функція є специфічною для Unix."

#: ../../library/asyncio-policy.rst:84
msgid "Set the current child process watcher to *watcher*."
msgstr ""
"Встановіть для поточного спостерігача дочірнього процесу значення *watcher*."

#: ../../library/asyncio-policy.rst:89
msgid "asyncio ships with the following built-in policies:"
msgstr "asyncio поставляється з такими вбудованими політиками:"

#: ../../library/asyncio-policy.rst:94
msgid ""
"The default asyncio policy.  Uses :class:`SelectorEventLoop` on Unix and :"
"class:`ProactorEventLoop` on Windows."
msgstr ""
"Стандартна асинхронна політика. Використовує :class:`SelectorEventLoop` в "
"Unix і :class:`ProactorEventLoop` у Windows."

#: ../../library/asyncio-policy.rst:97
msgid ""
"There is no need to install the default policy manually. asyncio is "
"configured to use the default policy automatically."
msgstr ""
"Немає необхідності встановлювати стандартну політику вручну. asyncio "
"налаштовано на автоматичне використання політики за замовчуванням."

#: ../../library/asyncio-policy.rst:102
msgid "On Windows, :class:`ProactorEventLoop` is now used by default."
msgstr ""
"У Windows :class:`ProactorEventLoop` тепер використовується за замовчуванням."

#: ../../library/asyncio-policy.rst:107
msgid ""
"An alternative event loop policy that uses the :class:`SelectorEventLoop` "
"event loop implementation."
msgstr ""
"Альтернативна політика циклу подій, яка використовує реалізацію циклу подій :"
"class:`SelectorEventLoop`."

#: ../../library/asyncio-policy.rst:110 ../../library/asyncio-policy.rst:118
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Availability <availability>`: Windows."

#: ../../library/asyncio-policy.rst:115
msgid ""
"An alternative event loop policy that uses the :class:`ProactorEventLoop` "
"event loop implementation."
msgstr ""
"Альтернативна політика циклу подій, яка використовує реалізацію циклу подій :"
"class:`ProactorEventLoop`."

#: ../../library/asyncio-policy.rst:123
msgid "Process Watchers"
msgstr "Monitores de processos"

#: ../../library/asyncio-policy.rst:125
msgid ""
"A process watcher allows customization of how an event loop monitors child "
"processes on Unix. Specifically, the event loop needs to know when a child "
"process has exited."
msgstr ""
"Спостерігач процесів дозволяє налаштувати те, як цикл подій відстежує "
"дочірні процеси в Unix. Зокрема, цикл подій повинен знати, коли завершився "
"дочірній процес."

#: ../../library/asyncio-policy.rst:129
msgid ""
"In asyncio, child processes are created with :func:`create_subprocess_exec` "
"and :meth:`loop.subprocess_exec` functions."
msgstr ""
"В asyncio дочірні процеси створюються за допомогою функцій :func:"
"`create_subprocess_exec` і :meth:`loop.subprocess_exec`."

#: ../../library/asyncio-policy.rst:133
msgid ""
"asyncio defines the :class:`AbstractChildWatcher` abstract base class, which "
"child watchers should implement, and has four different implementations: :"
"class:`ThreadedChildWatcher` (configured to be used by default), :class:"
"`MultiLoopChildWatcher`, :class:`SafeChildWatcher`, and :class:"
"`FastChildWatcher`."
msgstr ""
"asyncio визначає абстрактний базовий клас :class:`AbstractChildWatcher`, "
"який повинні реалізувати дочірні спостерігачі, і має чотири різні "
"реалізації: :class:`ThreadedChildWatcher` (налаштований для використання за "
"замовчуванням), :class:`MultiLoopChildWatcher`, :class:`SafeChildWatcher` і :"
"class:`FastChildWatcher`."

#: ../../library/asyncio-policy.rst:139
msgid ""
"See also the :ref:`Subprocess and Threads <asyncio-subprocess-threads>` "
"section."
msgstr ""
"Veja também a seção :ref:`Subprocesso e Threads <asyncio-subprocess-"
"threads>`."

#: ../../library/asyncio-policy.rst:142
msgid ""
"The following two functions can be used to customize the child process "
"watcher implementation used by the asyncio event loop:"
msgstr ""
"Наступні дві функції можна використовувати для налаштування реалізації "
"спостерігача дочірніх процесів, що використовується циклом асинхронних подій:"

#: ../../library/asyncio-policy.rst:147
msgid "Return the current child watcher for the current policy."
msgstr "Повертає поточний дочірній спостерігач для поточної політики."

#: ../../library/asyncio-policy.rst:151
msgid ""
"Set the current child watcher to *watcher* for the current policy.  "
"*watcher* must implement methods defined in the :class:"
"`AbstractChildWatcher` base class."
msgstr ""
"Установіть для поточного дочірнього спостерігача значення *watcher* для "
"поточної політики. *watcher* повинен реалізовувати методи, визначені в "
"базовому класі :class:`AbstractChildWatcher`."

#: ../../library/asyncio-policy.rst:156
msgid ""
"Third-party event loops implementations might not support custom child "
"watchers.  For such event loops, using :func:`set_child_watcher` might be "
"prohibited or have no effect."
msgstr ""
"Реалізації сторонніх циклів подій можуть не підтримувати користувацькі "
"дочірні спостерігачі. Для таких циклів подій використання :func:"
"`set_child_watcher` може бути заборонено або не матиме ефекту."

#: ../../library/asyncio-policy.rst:164
msgid "Register a new child handler."
msgstr "Зареєструвати нового дочірнього обробника."

#: ../../library/asyncio-policy.rst:166
msgid ""
"Arrange for ``callback(pid, returncode, *args)`` to be called when a process "
"with PID equal to *pid* terminates.  Specifying another callback for the "
"same process replaces the previous handler."
msgstr ""
"Організуйте виклик ``callback(pid, returncode, *args)`` під час завершення "
"процесу з PID, рівним *pid*. Зазначення іншого зворотного виклику для того "
"самого процесу замінює попередній обробник."

#: ../../library/asyncio-policy.rst:171
msgid "The *callback* callable must be thread-safe."
msgstr "Функція *callback* має бути потокобезпечною."

#: ../../library/asyncio-policy.rst:175
msgid "Removes the handler for process with PID equal to *pid*."
msgstr "Remove o manipulador para processo com PID igual a *pid*."

#: ../../library/asyncio-policy.rst:177
msgid ""
"The function returns ``True`` if the handler was successfully removed, "
"``False`` if there was nothing to remove."
msgstr ""
"Функція повертає ``True``, якщо обробник було успішно видалено, ``False``, "
"якщо не було нічого для видалення."

#: ../../library/asyncio-policy.rst:182
msgid "Attach the watcher to an event loop."
msgstr "Приєднайте спостерігач до циклу подій."

#: ../../library/asyncio-policy.rst:184
msgid ""
"If the watcher was previously attached to an event loop, then it is first "
"detached before attaching to the new loop."
msgstr ""
"Якщо спостерігач був раніше приєднаний до циклу подій, то він спочатку "
"від'єднується перед приєднанням до нового циклу."

#: ../../library/asyncio-policy.rst:187
msgid "Note: loop may be ``None``."
msgstr "Примітка: цикл може бути ``None``."

#: ../../library/asyncio-policy.rst:191
msgid "Return ``True`` if the watcher is ready to use."
msgstr "Повертає ``True``, якщо спостерігач готовий до використання."

#: ../../library/asyncio-policy.rst:193
msgid ""
"Spawning a subprocess with *inactive* current child watcher raises :exc:"
"`RuntimeError`."
msgstr ""
"Gerar um subprocesso com um monitor *inativo* para o filho atual, levanta :"
"exc:`RuntimeError`."

#: ../../library/asyncio-policy.rst:200
msgid "Close the watcher."
msgstr "Закрийте спостерігач."

#: ../../library/asyncio-policy.rst:202
msgid ""
"This method has to be called to ensure that underlying resources are cleaned-"
"up."
msgstr ""
"Цей метод потрібно викликати, щоб переконатися, що базові ресурси очищені."

#: ../../library/asyncio-policy.rst:207
msgid ""
"This implementation starts a new waiting thread for every subprocess spawn."
msgstr ""
"Ця реалізація запускає новий потік очікування для кожного породження "
"підпроцесу."

#: ../../library/asyncio-policy.rst:209
msgid ""
"It works reliably even when the asyncio event loop is run in a non-main OS "
"thread."
msgstr ""
"Він працює надійно, навіть якщо цикл асинхронних подій виконується в "
"неосновному потоці ОС."

#: ../../library/asyncio-policy.rst:211
msgid ""
"There is no noticeable overhead when handling a big number of children "
"(*O(1)* each time a child terminates), but starting a thread per process "
"requires extra memory."
msgstr ""
"Немає помітних накладних витрат при обробці великої кількості дітей (*O(1)* "
"кожного разу, коли дитина завершується), але для запуску потоку для кожного "
"процесу потрібна додаткова пам’ять."

#: ../../library/asyncio-policy.rst:214
msgid "This watcher is used by default."
msgstr "Цей спостерігач використовується за замовчуванням."

#: ../../library/asyncio-policy.rst:220
msgid ""
"This implementation registers a :py:data:`SIGCHLD` signal handler on "
"instantiation. That can break third-party code that installs a custom "
"handler for :py:data:`SIGCHLD` signal."
msgstr ""
"Ця реалізація реєструє обробник сигналу :py:data:`SIGCHLD` під час створення "
"екземпляра. Це може порушити код третьої сторони, який встановлює "
"спеціальний обробник для сигналу :py:data:`SIGCHLD`."

#: ../../library/asyncio-policy.rst:224 ../../library/asyncio-policy.rst:242
msgid ""
"The watcher avoids disrupting other code spawning processes by polling every "
"process explicitly on a :py:data:`SIGCHLD` signal."
msgstr ""
"Спостерігач уникає порушення інших процесів створення коду, явно опитуючи "
"кожен процес за сигналом :py:data:`SIGCHLD`."

#: ../../library/asyncio-policy.rst:227
msgid ""
"There is no limitation for running subprocesses from different threads once "
"the watcher is installed."
msgstr ""
"Немає обмежень для запуску підпроцесів з різних потоків після встановлення "
"спостерігача."

#: ../../library/asyncio-policy.rst:230
msgid ""
"The solution is safe but it has a significant overhead when handling a big "
"number of processes (*O(n)* each time a :py:data:`SIGCHLD` is received)."
msgstr ""
"Рішення є безпечним, але воно має значні витрати під час обробки великої "
"кількості процесів (*O(n)* щоразу, коли отримується :py:data:`SIGCHLD`)."

#: ../../library/asyncio-policy.rst:238
msgid ""
"This implementation uses active event loop from the main thread to handle :"
"py:data:`SIGCHLD` signal. If the main thread has no running event loop "
"another thread cannot spawn a subprocess (:exc:`RuntimeError` is raised)."
msgstr ""
"Ця реалізація використовує активний цикл подій з основного потоку для "
"обробки сигналу :py:data:`SIGCHLD`. Якщо основний потік не має запущеного "
"циклу подій, інший потік не може породити підпроцес (виникає :exc:"
"`RuntimeError`)."

#: ../../library/asyncio-policy.rst:245
msgid ""
"This solution is as safe as :class:`MultiLoopChildWatcher` and has the same "
"*O(N)* complexity but requires a running event loop in the main thread to "
"work."
msgstr ""
"Це рішення таке ж безпечне, як і :class:`MultiLoopChildWatcher`, і має таку "
"ж складність *O(N)*, але для роботи потрібен запущений цикл подій у "
"головному потоці."

#: ../../library/asyncio-policy.rst:250
msgid ""
"This implementation reaps every terminated processes by calling ``os."
"waitpid(-1)`` directly, possibly breaking other code spawning processes and "
"waiting for their termination."
msgstr ""
"Ця реалізація збирає всі завершені процеси шляхом безпосереднього виклику "
"``os.waitpid(-1)``, можливо, порушуючи інші процеси породження коду та "
"чекаючи їх завершення."

#: ../../library/asyncio-policy.rst:254
msgid ""
"There is no noticeable overhead when handling a big number of children "
"(*O(1)* each time a child terminates)."
msgstr ""
"Немає помітних накладних витрат при обробці великої кількості дітей (*O(1)* "
"кожного разу, коли дитина завершує роботу)."

#: ../../library/asyncio-policy.rst:257
msgid ""
"This solution requires a running event loop in the main thread to work, as :"
"class:`SafeChildWatcher`."
msgstr ""
"Для роботи цього рішення потрібен запущений цикл подій у головному потоці, "
"як :class:`SafeChildWatcher`."

#: ../../library/asyncio-policy.rst:262
msgid ""
"This implementation polls process file descriptors (pidfds) to await child "
"process termination. In some respects, :class:`PidfdChildWatcher` is a "
"\"Goldilocks\" child watcher implementation. It doesn't require signals or "
"threads, doesn't interfere with any processes launched outside the event "
"loop, and scales linearly with the number of subprocesses launched by the "
"event loop. The main disadvantage is that pidfds are specific to Linux, and "
"only work on recent (5.3+) kernels."
msgstr ""
"Ця реалізація опитує дескриптори файлів процесу (pidfds) для очікування "
"завершення дочірнього процесу. У деяких відношеннях :class:"
"`PidfdChildWatcher` є реалізацією дочірнього спостерігача \"Золотовласка\". "
"Він не потребує сигналів чи потоків, не заважає жодним процесам, запущеним "
"поза циклом подій, і масштабується лінійно залежно від кількості "
"підпроцесів, запущених циклом подій. Основним недоліком є те, що pidfds є "
"специфічними для Linux і працюють лише на останніх (5.3+) ядрах."

#: ../../library/asyncio-policy.rst:274
msgid "Custom Policies"
msgstr "Спеціальна політика"

#: ../../library/asyncio-policy.rst:276
msgid ""
"To implement a new event loop policy, it is recommended to subclass :class:"
"`DefaultEventLoopPolicy` and override the methods for which custom behavior "
"is wanted, e.g.::"
msgstr ""
"Щоб запровадити нову політику циклу подій, рекомендується створити підклас :"
"class:`DefaultEventLoopPolicy` і перевизначити методи, для яких потрібна "
"спеціальна поведінка, наприклад::"

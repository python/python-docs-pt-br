# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 17:51+0000\n"
"PO-Revision-Date: 2017-02-16 23:14+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/imp.rst:2
msgid ":mod:`imp` --- Access the :ref:`import <importsystem>` internals"
msgstr ":mod:`imp` --- 访问 :ref:`import <importsystem>` 内部对象"

#: ../../library/imp.rst:8
msgid "**Source code:** :source:`Lib/imp.py`"
msgstr "**Código-fonte:** :source:`Lib/imp.py`"

#: ../../library/imp.rst:10
msgid "The :mod:`imp` module is deprecated in favor of :mod:`importlib`."
msgstr "Модуль :mod:`imp` застарів на користь :mod:`importlib`."

#: ../../library/imp.rst:17
msgid ""
"This module provides an interface to the mechanisms used to implement the :"
"keyword:`import` statement.  It defines the following constants and "
"functions:"
msgstr ""
"Цей модуль надає інтерфейс для механізмів, що використовуються для "
"реалізації оператора :keyword:`import`. Він визначає такі константи та "
"функції:"

#: ../../library/imp.rst:25
msgid ""
"Return the magic string value used to recognize byte-compiled code files (:"
"file:`.pyc` files).  (This value may be different for each Python version.)"
msgstr ""
"Повертає магічне значення рядка, яке використовується для розпізнавання "
"файлів зі скомпільованим кодом (:file:`.pyc` файли). (Це значення може "
"відрізнятися для кожної версії Python.)"

#: ../../library/imp.rst:28
msgid "Use :attr:`importlib.util.MAGIC_NUMBER` instead."
msgstr "Натомість використовуйте :attr:`importlib.util.MAGIC_NUMBER`."

#: ../../library/imp.rst:34
msgid ""
"Return a list of 3-element tuples, each describing a particular type of "
"module. Each triple has the form ``(suffix, mode, type)``, where *suffix* is "
"a string to be appended to the module name to form the filename to search "
"for, *mode* is the mode string to pass to the built-in :func:`open` function "
"to open the file (this can be ``'r'`` for text files or ``'rb'`` for binary "
"files), and *type* is the file type, which has one of the values :const:"
"`PY_SOURCE`, :const:`PY_COMPILED`, or :const:`C_EXTENSION`, described below."
msgstr ""
"Повертає список 3-елементних кортежів, кожен з яких описує певний тип "
"модуля. Кожна трійка має вигляд ``(суфікс, режим, тип)``, де *суфікс* — це "
"рядок, який додається до назви модуля, щоб сформувати назву файлу для "
"пошуку, *mode* — це рядок режиму, який передається до вбудована функція :"
"func:`open` для відкриття файлу (це може бути ``'r'`` для текстових файлів "
"або ``'rb'`` для бінарних файлів), а *type* — це тип файлу, який має одне зі "
"значень :const:`PY_SOURCE`, :const:`PY_COMPILED` або :const:`C_EXTENSION`, "
"описаних нижче."

#: ../../library/imp.rst:43
msgid "Use the constants defined on :mod:`importlib.machinery` instead."
msgstr ""
"Натомість використовуйте константи, визначені в :mod:`importlib.machinery`."

#: ../../library/imp.rst:49
msgid ""
"Try to find the module *name*.  If *path* is omitted or ``None``, the list "
"of directory names given by ``sys.path`` is searched, but first a few "
"special places are searched: the function tries to find a built-in module "
"with the given name (:const:`C_BUILTIN`), then a frozen module (:const:"
"`PY_FROZEN`), and on some systems some other places are looked in as well "
"(on Windows, it looks in the registry which may point to a specific file)."
msgstr ""
"Спробуйте знайти *ім’я* модуля. Якщо *path* пропущено або ``None``, пошук "
"здійснюється за списком імен каталогів, наданим ``sys.path``, але спочатку "
"виконується пошук у кількох спеціальних місцях: функція намагається знайти "
"вбудований модуль за допомогою дане ім’я (:const:`C_BUILTIN`), потім "
"заморожений модуль (:const:`PY_FROZEN`), а в деяких системах також "
"переглядаються деякі інші місця (у Windows шукається в реєстрі, який може "
"вказувати на певний файл)."

#: ../../library/imp.rst:56
msgid ""
"Otherwise, *path* must be a list of directory names; each directory is "
"searched for files with any of the suffixes returned by :func:`get_suffixes` "
"above.  Invalid names in the list are silently ignored (but all list items "
"must be strings)."
msgstr ""
"В іншому випадку *path* має бути списком імен каталогів; у кожному каталозі "
"шукаються файли з будь-якими суфіксами, які повертає :func:`get_suffixes` "
"вище. Недійсні імена в списку мовчки ігноруються (але всі елементи списку "
"мають бути рядками)."

#: ../../library/imp.rst:61
msgid ""
"If search is successful, the return value is a 3-element tuple ``(file, "
"pathname, description)``:"
msgstr ""
"Якщо пошук пройшов успішно, повертається значення 3-елементного кортежу "
"``(файл, шлях, опис)``:"

#: ../../library/imp.rst:64
msgid ""
"*file* is an open :term:`file object` positioned at the beginning, "
"*pathname* is the pathname of the file found, and *description* is a 3-"
"element tuple as contained in the list returned by :func:`get_suffixes` "
"describing the kind of module found."
msgstr ""
"*file* — це відкритий :term:`file object`, розташований на початку, "
"*pathname* — це шлях до знайденого файлу, а *description* — це 3-елементний "
"кортеж, який міститься у списку, який повертає :func:`get_suffixes`, що "
"описує вид знайденого модуля."

#: ../../library/imp.rst:69
msgid ""
"If the module is built-in or frozen then *file* and *pathname* are both "
"``None`` and the *description* tuple contains empty strings for its suffix "
"and mode; the module type is indicated as given in parentheses above.  If "
"the search is unsuccessful, :exc:`ImportError` is raised.  Other exceptions "
"indicate problems with the arguments or environment."
msgstr ""
"Якщо модуль вбудований або заморожений, тоді *file* і *pathname* мають "
"значення ``None``, а кортеж *description* містить порожні рядки для свого "
"суфікса та режиму; тип модуля вказано у дужках вище. Якщо пошук невдалий, "
"виникає :exc:`ImportError`. Інші винятки вказують на проблеми з аргументами "
"або середовищем."

#: ../../library/imp.rst:75
msgid ""
"If the module is a package, *file* is ``None``, *pathname* is the package "
"path and the last item in the *description* tuple is :const:`PKG_DIRECTORY`."
msgstr ""
"Якщо модуль є пакетом, *file* має значення ``None``, *pathname* — це шлях до "
"пакета, а останнім елементом у кортежі *description* є :const:"
"`PKG_DIRECTORY`."

#: ../../library/imp.rst:78
msgid ""
"This function does not handle hierarchical module names (names containing "
"dots).  In order to find *P.M*, that is, submodule *M* of package *P*, use :"
"func:`find_module` and :func:`load_module` to find and load package *P*, and "
"then use :func:`find_module` with the *path* argument set to ``P.__path__``. "
"When *P* itself has a dotted name, apply this recipe recursively."
msgstr ""
"Ця функція не обробляє ієрархічні імена модулів (імена, що містять крапки). "
"Щоб знайти *P.M*, тобто підмодуль *M* пакета *P*, використовуйте :func:"
"`find_module` і :func:`load_module`, щоб знайти та завантажити пакет *P*, а "
"потім використовуйте :func:`find_module` з аргументом *path*, встановленим "
"на ``P.__path__``. Якщо *P* має назву з крапками, застосовуйте цей рецепт "
"рекурсивно."

#: ../../library/imp.rst:84
msgid ""
"Use :func:`importlib.util.find_spec` instead unless Python 3.3 compatibility "
"is required, in which case use :func:`importlib.find_loader`. For example "
"usage of the former case, see the :ref:`importlib-examples` section of the :"
"mod:`importlib` documentation."
msgstr ""
"Використовуйте :func:`importlib.util.find_spec` замість цього, якщо не "
"потрібна сумісність з Python 3.3, у такому випадку використовуйте :func:"
"`importlib.find_loader`. Для прикладу використання першого випадку дивіться "
"розділ :ref:`importlib-examples` документації :mod:`importlib`."

#: ../../library/imp.rst:94
msgid ""
"Load a module that was previously found by :func:`find_module` (or by an "
"otherwise conducted search yielding compatible results).  This function does "
"more than importing the module: if the module was already imported, it will "
"reload the module!  The *name* argument indicates the full module name "
"(including the package name, if this is a submodule of a package).  The "
"*file* argument is an open file, and *pathname* is the corresponding file "
"name; these can be ``None`` and ``''``, respectively, when the module is a "
"package or not being loaded from a file.  The *description* argument is a "
"tuple, as would be returned by :func:`get_suffixes`, describing what kind of "
"module must be loaded."
msgstr ""
"Завантажте модуль, який раніше було знайдено за допомогою :func:"
"`find_module` (або за допомогою іншого здійсненого пошуку, що дає сумісні "
"результати). Ця функція робить більше, ніж імпорт модуля: якщо модуль уже "
"було імпортовано, він перезавантажить модуль! Аргумент *name* вказує на "
"повну назву модуля (включно з назвою пакета, якщо це підмодуль пакета). "
"Аргумент *file* — це відкритий файл, а *pathname* — ім’я відповідного файлу; "
"вони можуть бути ``None`` і ``''`` відповідно, якщо модуль є пакетом або не "
"завантажується з файлу. Аргумент *description* є кортежем, який повертає :"
"func:`get_suffixes`, описуючи тип модуля, який потрібно завантажити."

#: ../../library/imp.rst:105
msgid ""
"If the load is successful, the return value is the module object; otherwise, "
"an exception (usually :exc:`ImportError`) is raised."
msgstr ""
"Якщо завантаження пройшло успішно, повертається значення об’єкта модуля; "
"інакше виникає виняток (зазвичай :exc:`ImportError`)."

#: ../../library/imp.rst:108
msgid ""
"**Important:** the caller is responsible for closing the *file* argument, if "
"it was not ``None``, even when an exception is raised.  This is best done "
"using a :keyword:`try` ... :keyword:`finally` statement."
msgstr ""
"**Важливо:** абонент, що викликає, відповідає за закриття аргументу *file*, "
"якщо він не був ``None``, навіть якщо виникає виняток. Найкраще це зробити "
"за допомогою оператора :keyword:`try` ... :keyword:`finally`."

#: ../../library/imp.rst:112
msgid ""
"If previously used in conjunction with :func:`imp.find_module` then consider "
"using :func:`importlib.import_module`, otherwise use the loader returned by "
"the replacement you chose for :func:`imp.find_module`. If you called :func:"
"`imp.load_module` and related functions directly with file path arguments "
"then use a combination of :func:`importlib.util.spec_from_file_location` "
"and :func:`importlib.util.module_from_spec`. See the :ref:`importlib-"
"examples` section of the :mod:`importlib` documentation for details of the "
"various approaches."
msgstr ""
"Якщо раніше використовувався в поєднанні з :func:`imp.find_module`, "
"розгляньте можливість використання :func:`importlib.import_module`, інакше "
"використовуйте завантажувач, повернутий заміною, яку ви вибрали для :func:"
"`imp.find_module`. Якщо ви викликали :func:`imp.load_module` та пов’язані "
"функції безпосередньо з аргументами шляху до файлу, тоді використовуйте "
"комбінацію :func:`importlib.util.spec_from_file_location` та :func:"
"`importlib.util.module_from_spec`. Перегляньте розділ :ref:`importlib-"
"examples` документації :mod:`importlib` для детальної інформації про різні "
"підходи."

#: ../../library/imp.rst:126
msgid ""
"Return a new empty module object called *name*.  This object is *not* "
"inserted in ``sys.modules``."
msgstr ""
"Повертає новий порожній об’єкт модуля під назвою *name*. Цей об’єкт *не* "
"вставляється в ``sys.modules``."

#: ../../library/imp.rst:129
msgid "Use :func:`importlib.util.module_from_spec` instead."
msgstr "Натомість використовуйте :func:`importlib.util.module_from_spec`."

#: ../../library/imp.rst:135
msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (the same as the *module* argument)."
msgstr ""
"Перезавантажте раніше імпортований *модуль*. Аргумент має бути об’єктом "
"модуля, тому він має бути успішно імпортований раніше. Це корисно, якщо ви "
"відредагували вихідний файл модуля за допомогою зовнішнього редактора і "
"хочете випробувати нову версію, не виходячи з інтерпретатора Python. "
"Поверненим значенням є об’єкт модуля (те саме, що аргумент *module*)."

#: ../../library/imp.rst:141
msgid "When ``reload(module)`` is executed:"
msgstr "Коли виконується ``reload(module)``:"

#: ../../library/imp.rst:143
msgid ""
"Python modules' code is recompiled and the module-level code reexecuted, "
"defining a new set of objects which are bound to names in the module's "
"dictionary.  The ``init`` function of extension modules is not called a "
"second time."
msgstr ""
"Код модулів Python перекомпілюється, а код рівня модуля повторно "
"виконується, визначаючи новий набір об’єктів, які прив’язані до імен у "
"словнику модуля. Функція ``init`` модулів розширення не викликається вдруге."

#: ../../library/imp.rst:148
msgid ""
"As with all other objects in Python the old objects are only reclaimed after "
"their reference counts drop to zero."
msgstr ""
"Tal como acontece com todos os outros objetos em Python, os objetos antigos "
"só são recuperados depois que suas contagens de referências caem para zero."

#: ../../library/imp.rst:151
msgid ""
"The names in the module namespace are updated to point to any new or changed "
"objects."
msgstr ""
"Os nomes no espaço de nomes do módulo são atualizados para apontar para "
"quaisquer objetos novos ou alterados."

#: ../../library/imp.rst:154
msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr ""
"Outras referências aos objetos antigos (como nomes externos ao módulo) não "
"são religadas para se referir aos novos objetos e devem ser atualizadas em "
"cada espaço de nomes onde ocorrem, se isso for desejado."

#: ../../library/imp.rst:158
msgid "There are a number of other caveats:"
msgstr "Existem várias outras ressalvas:"

#: ../../library/imp.rst:160
msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"Quando um módulo é recarregado, seu dicionário (contendo as variáveis "
"globais do módulo) é retido. As redefinições de nomes vão substituir as "
"definições antigas, portanto isso geralmente não é um problema. Se a nova "
"versão de um módulo não definir um nome definido pela versão antiga, a "
"definição antiga permanecerá. Este recurso pode ser usado para vantagem do "
"módulo se ele mantiver uma tabela global ou cache de objetos -- com uma "
"instrução :keyword:`try` ele pode testar a presença da tabela e pular sua "
"inicialização se desejar::"

#: ../../library/imp.rst:173
msgid ""
"It is legal though generally not very useful to reload built-in or "
"dynamically loaded modules, except for :mod:`sys`, :mod:`__main__` and :mod:"
"`builtins`. In many cases, however, extension modules are not designed to be "
"initialized more than once, and may fail in arbitrary ways when reloaded."
msgstr ""
"Перезавантажувати вбудовані або динамічно завантажувані модулі, за винятком :"
"mod:`sys`, :mod:`__main__` і :mod:`builtins`, є законним, хоча загалом не "
"дуже корисно. Однак у багатьох випадках модулі розширення не призначені для "
"ініціалізації більше ніж один раз і можуть виходити з ладу довільним чином "
"під час перезавантаження."

#: ../../library/imp.rst:178
msgid ""
"If a module imports objects from another module using :keyword:`from` ... :"
"keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`!from` statement, another is to use :keyword:`!import` "
"and qualified names (*module*.*name*) instead."
msgstr ""
"Якщо модуль імпортує об’єкти з іншого модуля за допомогою :keyword:"
"`from` ... :keyword:`import` ..., виклик :func:`reload` для іншого модуля не "
"перевизначає об’єкти, імпортовані з нього --- один спосіб обійти це — "
"повторно виконати оператор :keyword:`!from`, інший — використати замість "
"нього :keyword:`!import` і кваліфіковані імена (*module*.*name*)."

#: ../../library/imp.rst:184
msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr ""
"Se um módulo instancia instâncias de uma classe, recarregar o módulo que "
"define a classe não afeta as definições de método das instâncias -- elas "
"continuam a usar a definição de classe antiga. O mesmo se aplica às classes "
"derivadas."

#: ../../library/imp.rst:188
msgid ""
"Relies on both ``__name__`` and ``__loader__`` being defined on the module "
"being reloaded instead of just ``__name__``."
msgstr ""
"Покладається на те, що ``__name__`` і ``__loader__`` визначені в модулі, "
"який перезавантажується, а не просто ``__name__``."

#: ../../library/imp.rst:192
msgid "Use :func:`importlib.reload` instead."
msgstr "Натомість використовуйте :func:`importlib.reload`."

#: ../../library/imp.rst:196
msgid ""
"The following functions are conveniences for handling :pep:`3147` byte-"
"compiled file paths."
msgstr ""
"Наступні функції є зручними для обробки шляхів :pep:`3147` скомпільованих "
"файлів."

#: ../../library/imp.rst:203
msgid ""
"Return the :pep:`3147` path to the byte-compiled file associated with the "
"source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the return "
"value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python 3.2. "
"The ``cpython-32`` string comes from the current magic tag (see :func:"
"`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then :exc:"
"`NotImplementedError` will be raised). By passing in ``True`` or ``False`` "
"for *debug_override* you can override the system's value for ``__debug__``, "
"leading to optimized bytecode."
msgstr ""
"Поверніть шлях :pep:`3147` до скомпільованого файлу, пов’язаного з вихідним "
"*шляхом*. Наприклад, якщо *path* є ``/foo/bar/baz.py``, значення, що "
"повертається, буде ``/foo/bar/__pycache__/baz.cpython-32.pyc`` для Python "
"3.2. Рядок ``cpython-32`` походить від поточного магічного тегу (див. :func:"
"`get_tag`; якщо :attr:`sys.implementation.cache_tag` не визначено, тоді буде "
"викликана :exc:`NotImplementedError`). Передаючи ``True`` або ``False`` для "
"*debug_override*, ви можете змінити системне значення для ``__debug__``, що "
"призведе до оптимізації байт-коду."

#: ../../library/imp.rst:212
msgid "*path* need not exist."
msgstr "*шлях* не повинен існувати."

#: ../../library/imp.rst:214
msgid ""
"If :attr:`sys.implementation.cache_tag` is ``None``, then :exc:"
"`NotImplementedError` is raised."
msgstr ""
"Якщо :attr:`sys.implementation.cache_tag` має значення ``None``, тоді "
"виникає :exc:`NotImplementedError`."

#: ../../library/imp.rst:218
msgid "Use :func:`importlib.util.cache_from_source` instead."
msgstr "Натомість використовуйте :func:`importlib.util.cache_from_source`."

#: ../../library/imp.rst:221
msgid "The *debug_override* parameter no longer creates a ``.pyo`` file."
msgstr "Параметр *debug_override* більше не створює файл ``.pyo``."

#: ../../library/imp.rst:227
msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is ``/foo/bar/__pycache__/baz."
"cpython-32.pyc`` the returned path would be ``/foo/bar/baz.py``.  *path* "
"need not exist, however if it does not conform to :pep:`3147` format, a :exc:"
"`ValueError` is raised. If :attr:`sys.implementation.cache_tag` is not "
"defined, :exc:`NotImplementedError` is raised."
msgstr ""
"Враховуючи *шлях* до імені файлу :pep:`3147`, поверніть пов’язаний шлях до "
"файлу вихідного коду. Наприклад, якщо *шлях* є ``/foo/bar/__pycache__/baz."
"cpython-32.pyc``, повернутий шлях буде ``/foo/bar/baz.py``. *path* не "
"обов’язково існує, однак, якщо він не відповідає формату :pep:`3147`, "
"виникає :exc:`ValueError`. Якщо :attr:`sys.implementation.cache_tag` не "
"визначено, виникає :exc:`NotImplementedError`."

#: ../../library/imp.rst:235
msgid ""
"Raise :exc:`NotImplementedError` when :attr:`sys.implementation.cache_tag` "
"is not defined."
msgstr ""
"Викликати :exc:`NotImplementedError`, коли :attr:`sys.implementation."
"cache_tag` не визначено."

#: ../../library/imp.rst:239
msgid "Use :func:`importlib.util.source_from_cache` instead."
msgstr "Натомість використовуйте :func:`importlib.util.source_from_cache`."

#: ../../library/imp.rst:245
msgid ""
"Return the :pep:`3147` magic tag string matching this version of Python's "
"magic number, as returned by :func:`get_magic`."
msgstr ""
"Повертає рядок магічного тегу :pep:`3147`, що відповідає цій версії "
"магічного числа Python, яке повертає :func:`get_magic`."

#: ../../library/imp.rst:248
msgid ""
"Use :attr:`sys.implementation.cache_tag` directly starting in Python 3.3."
msgstr ""
"Використовуйте :attr:`sys.implementation.cache_tag` безпосередньо, починаючи "
"з Python 3.3."

#: ../../library/imp.rst:253
msgid ""
"The following functions help interact with the import system's internal "
"locking mechanism.  Locking semantics of imports are an implementation "
"detail which may vary from release to release.  However, Python ensures that "
"circular imports work without any deadlocks."
msgstr ""
"Наступні функції допомагають взаємодіяти з внутрішнім механізмом блокування "
"системи імпорту. Семантика блокування імпорту є деталлю реалізації, яка може "
"відрізнятися від випуску до випуску. Однак Python гарантує, що циклічний "
"імпорт працює без будь-яких взаємоблокувань."

#: ../../library/imp.rst:261
msgid ""
"Return ``True`` if the global import lock is currently held, else ``False``. "
"On platforms without threads, always return ``False``."
msgstr ""
"Повертає ``True``, якщо наразі утримується глобальне блокування імпорту, "
"інакше ``False``. На платформах без потоків завжди повертайте ``False``."

#: ../../library/imp.rst:264
msgid ""
"On platforms with threads, a thread executing an import first holds a global "
"import lock, then sets up a per-module lock for the rest of the import.  "
"This blocks other threads from importing the same module until the original "
"import completes, preventing other threads from seeing incomplete module "
"objects constructed by the original thread.  An exception is made for "
"circular imports, which by construction have to expose an incomplete module "
"object at some point."
msgstr ""
"На платформах із потоками потік, який виконує імпорт, спочатку утримує "
"глобальне блокування імпорту, а потім встановлює блокування кожного модуля "
"для решти імпорту. Це блокує інші потоки від імпорту того самого модуля до "
"завершення оригінального імпорту, не даючи іншим потокам побачити "
"незавершені об’єкти модуля, створені вихідним потоком. Виняток зроблено для "
"циклічного імпорту, який за своєю конструкцією в певний момент має відкрити "
"незавершений об’єкт модуля."

#: ../../library/imp.rst:272 ../../library/imp.rst:292
#: ../../library/imp.rst:305
msgid ""
"The locking scheme has changed to per-module locks for the most part.  A "
"global import lock is kept for some critical tasks, such as initializing the "
"per-module locks."
msgstr ""
"Схема блокування здебільшого змінена на помодульні блокування. Глобальне "
"блокування імпорту зберігається для деяких критичних завдань, таких як "
"ініціалізація блокувань для кожного модуля."

#: ../../library/imp.rst:282
msgid ""
"Acquire the interpreter's global import lock for the current thread. This "
"lock should be used by import hooks to ensure thread-safety when importing "
"modules."
msgstr ""
"Отримати глобальне блокування імпорту інтерпретатора для поточного потоку. "
"Це блокування має використовуватися гаками імпорту, щоб забезпечити безпеку "
"потоків під час імпорту модулів."

#: ../../library/imp.rst:286
msgid ""
"Once a thread has acquired the import lock, the same thread may acquire it "
"again without blocking; the thread must release it once for each time it has "
"acquired it."
msgstr ""
"Як тільки потік отримав блокування імпорту, той самий потік може отримати "
"його знову без блокування; потік повинен звільнити його один раз за кожен "
"раз, коли він його отримав."

#: ../../library/imp.rst:290
msgid "On platforms without threads, this function does nothing."
msgstr "На платформах без потоків ця функція нічого не робить."

#: ../../library/imp.rst:302
msgid ""
"Release the interpreter's global import lock. On platforms without threads, "
"this function does nothing."
msgstr ""
"Звільніть глобальне блокування імпорту інтерпретатора. На платформах без "
"потоків ця функція нічого не робить."

#: ../../library/imp.rst:313
msgid ""
"The following constants with integer values, defined in this module, are "
"used to indicate the search result of :func:`find_module`."
msgstr ""
"Наступні константи з цілими значеннями, визначені в цьому модулі, "
"використовуються для позначення результату пошуку :func:`find_module`."

#: ../../library/imp.rst:319
msgid "The module was found as a source file."
msgstr "Модуль знайдено як вихідний файл."

#: ../../library/imp.rst:326
msgid "The module was found as a compiled code object file."
msgstr "Модуль знайдено як скомпільований об’єктний файл коду."

#: ../../library/imp.rst:333
msgid "The module was found as dynamically loadable shared library."
msgstr ""
"Модуль було знайдено як спільну бібліотеку, що динамічно завантажується."

#: ../../library/imp.rst:340
msgid "The module was found as a package directory."
msgstr "Модуль знайдено як каталог пакунків."

#: ../../library/imp.rst:347
msgid "The module was found as a built-in module."
msgstr "Модуль знайдено як вбудований модуль."

#: ../../library/imp.rst:354
msgid "The module was found as a frozen module."
msgstr "Модуль було знайдено як заморожений."

#: ../../library/imp.rst:361
msgid ""
"The :class:`NullImporter` type is a :pep:`302` import hook that handles non-"
"directory path strings by failing to find any modules.  Calling this type "
"with an existing directory or empty string raises :exc:`ImportError`. "
"Otherwise, a :class:`NullImporter` instance is returned."
msgstr ""
"Тип :class:`NullImporter` — це :pep:`302` хук імпорту, який обробляє рядки "
"шляху, не пов’язані з каталогом, не знаходячи жодного модуля. Виклик цього "
"типу з наявним каталогом або порожнім рядком викликає :exc:`ImportError`. В "
"іншому випадку повертається екземпляр :class:`NullImporter`."

#: ../../library/imp.rst:366
msgid "Instances have only one method:"
msgstr "Примірники мають лише один метод:"

#: ../../library/imp.rst:370
msgid ""
"This method always returns ``None``, indicating that the requested module "
"could not be found."
msgstr ""
"Цей метод завжди повертає ``None``, вказуючи, що запитуваний модуль не "
"вдалося знайти."

#: ../../library/imp.rst:373
msgid ""
"``None`` is inserted into ``sys.path_importer_cache`` instead of an instance "
"of :class:`NullImporter`."
msgstr ""
"``None`` вставляється в ``sys.path_importer_cache`` замість екземпляра :"
"class:`NullImporter`."

#: ../../library/imp.rst:377
msgid "Insert ``None`` into ``sys.path_importer_cache`` instead."
msgstr "Натомість вставте ``None`` у ``sys.path_importer_cache``."

#: ../../library/imp.rst:384
msgid "Examples"
msgstr "Exemplos"

#: ../../library/imp.rst:386
msgid ""
"The following function emulates what was the standard import statement up to "
"Python 1.4 (no hierarchical module names).  (This *implementation* wouldn't "
"work in that version, since :func:`find_module` has been extended and :func:"
"`load_module` has been added in 1.4.) ::"
msgstr ""
"Наступна функція емулює те, що було стандартним оператором імпорту до Python "
"1.4 (без ієрархічних імен модулів). (Ця *реалізація* не працюватиме в цій "
"версії, оскільки :func:`find_module` було розширено, а :func:`load_module` "
"додано у 1.4.) ::"

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 16:02+0000\n"
"PO-Revision-Date: 2025-07-18 20:09+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/configparser.rst:2
msgid ":mod:`configparser` --- Configuration file parser"
msgstr ""

#: ../../library/configparser.rst:14
msgid "**Source code:** :source:`Lib/configparser.py`"
msgstr "**Código-fonte:** :source:`Lib/configparser.py`"

#: ../../library/configparser.rst:24
msgid ""
"This module provides the :class:`ConfigParser` class which implements a "
"basic configuration language which provides a structure similar to what's "
"found in Microsoft Windows INI files.  You can use this to write Python "
"programs which can be customized by end users easily."
msgstr ""
"Este módulo fornece a classe :class:`ConfigParser` que implementa uma "
"linguagem de configuração básica que fornece uma estrutura semelhante à "
"encontrada nos arquivos INI do Microsoft Windows. Você pode usar isso para "
"escrever programas Python que podem ser facilmente personalizados pelos "
"usuários finais."

#: ../../library/configparser.rst:31
msgid ""
"This library does *not* interpret or write the value-type prefixes used in "
"the Windows Registry extended version of INI syntax."
msgstr ""
"Esta biblioteca *não* interpreta nem escreve os prefixos de tipo de valor "
"usados na versão estendida do Registro do Windows da sintaxe INI."

#: ../../library/configparser.rst:38
msgid "Module :mod:`shlex`"
msgstr "Módulo :mod:`shlex`"

#: ../../library/configparser.rst:37
msgid ""
"Support for creating Unix shell-like mini-languages which can be used as an "
"alternate format for application configuration files."
msgstr ""

#: ../../library/configparser.rst:41
msgid "Module :mod:`json`"
msgstr "Módulo :mod:`json`"

#: ../../library/configparser.rst:41
msgid ""
"The json module implements a subset of JavaScript syntax which can also be "
"used for this purpose."
msgstr ""

#: ../../library/configparser.rst:56
msgid "Quick Start"
msgstr "Início rápido"

#: ../../library/configparser.rst:58
msgid "Let's take a very basic configuration file that looks like this:"
msgstr "Vamos pegar um arquivo de configuração bem básico parecido com este:"

#: ../../library/configparser.rst:75
msgid ""
"The structure of INI files is described `in the following section "
"<#supported-ini-file-structure>`_.  Essentially, the file consists of "
"sections, each of which contains keys with values. :mod:`configparser` "
"classes can read and write such files.  Let's start by creating the above "
"configuration file programmatically."
msgstr ""
"A estrutura dos arquivos INI é descrita `na seção seguinte <#supported-ini-"
"file-structure>`_. Essencialmente, o arquivo consiste em seções, cada uma "
"contendo chaves com valores. As classes :mod:`configparser` podem ler e "
"escrever tais arquivos. Vamos começar criando o arquivo de configuração "
"acima programaticamente."

#: ../../library/configparser.rst:99
msgid ""
"As you can see, we can treat a config parser much like a dictionary. There "
"are differences, `outlined later <#mapping-protocol-access>`_, but the "
"behavior is very close to what you would expect from a dictionary."
msgstr ""
"Como você pode ver, podemos tratar um analisador sintático de configuração "
"como um dicionário. Existem diferenças, `descritas posteriormente <#mapping-"
"protocol-access>`_, mas o comportamento é muito próximo do que você "
"esperaria de um dicionário."

#: ../../library/configparser.rst:103
msgid ""
"Now that we have created and saved a configuration file, let's read it back "
"and explore the data it holds."
msgstr ""
"Agora que criamos e salvamos um arquivo de configuração, vamos lê-lo e "
"explorar os dados que ele contém."

#: ../../library/configparser.rst:138
msgid ""
"As we can see above, the API is pretty straightforward.  The only bit of "
"magic involves the ``DEFAULT`` section which provides default values for all "
"other sections [1]_.  Note also that keys in sections are case-insensitive "
"and stored in lowercase [1]_."
msgstr ""
"Como podemos ver acima, a API é bastante simples. A única mágica envolve a "
"seção ``DEFAULT`` que fornece valores padrão para todas as outras seções "
"[1]_. Observe também que as chaves nas seções não diferenciam maiúsculas de "
"minúsculas e são armazenadas em letras minúsculas [1]_."

#: ../../library/configparser.rst:143
msgid ""
"It is possible to read several configurations into a single :class:"
"`ConfigParser`, where the most recently added configuration has the highest "
"priority. Any conflicting keys are taken from the more recent configuration "
"while the previously existing keys are retained."
msgstr ""

#: ../../library/configparser.rst:164
msgid ""
"This behaviour is equivalent to a :meth:`ConfigParser.read` call with "
"several files passed to the *filenames* parameter."
msgstr ""
"Este comportamento é equivalente a uma chamada :meth:`ConfigParser.read` com "
"vários arquivos passados para o parâmetro *filenames*."

#: ../../library/configparser.rst:169
msgid "Supported Datatypes"
msgstr "Tipos de dados suportados"

#: ../../library/configparser.rst:171
msgid ""
"Config parsers do not guess datatypes of values in configuration files, "
"always storing them internally as strings.  This means that if you need "
"other datatypes, you should convert on your own:"
msgstr ""
"Os analisadores sintáticos de configuração não adivinham os tipos de dados "
"dos valores nos arquivos de configuração, sempre os armazenando internamente "
"como strings. Isso significa que se você precisar de outros tipos de dados, "
"deverá converter por conta própria:"

#: ../../library/configparser.rst:182
msgid ""
"Since this task is so common, config parsers provide a range of handy getter "
"methods to handle integers, floats and booleans.  The last one is the most "
"interesting because simply passing the value to ``bool()`` would do no good "
"since ``bool('False')`` is still ``True``.  This is why config parsers also "
"provide :meth:`~ConfigParser.getboolean`.  This method is case-insensitive "
"and recognizes Boolean values from ``'yes'``/``'no'``, ``'on'``/``'off'``, "
"``'true'``/``'false'`` and ``'1'``/``'0'`` [1]_.  For example:"
msgstr ""
"Como essa tarefa é tão comum, os analisadores sintáticos de configuração "
"fornecem uma variedade de métodos getter úteis para manipular com números "
"inteiros, pontos flutuantes e booleanos. O último é o mais interessante "
"porque simplesmente passar o valor para ``bool()`` não adiantaria nada já "
"que ``bool('False')`` ainda é ``True``. É por isso que os analisadores "
"sintáticos de configuração também fornecem :meth:`~ConfigParser.getboolean`. "
"Este método não diferencia maiúsculas de minúsculas e reconhece valores "
"booleanos de ``'yes'``/``'no'``, ``'on'``/``'off'``, ``'true'`` /``'false'`` "
"e ``'1'``/``'0'`` [1]_. Por exemplo:"

#: ../../library/configparser.rst:199
msgid ""
"Apart from :meth:`~ConfigParser.getboolean`, config parsers also provide "
"equivalent :meth:`~ConfigParser.getint` and :meth:`~ConfigParser.getfloat` "
"methods.  You can register your own converters and customize the provided "
"ones. [1]_"
msgstr ""
"Além de :meth:`~ConfigParser.getboolean`, os analisadores sintáticos de "
"configuração também fornecem métodos :meth:`~ConfigParser.getint` e :meth:"
"`~ConfigParser.getfloat` equivalentes. Você pode registrar seus próprios "
"conversores e personalizar os fornecidos. [1]_"

#: ../../library/configparser.rst:205
msgid "Fallback Values"
msgstr "Valores reservas"

#: ../../library/configparser.rst:207
msgid ""
"As with a dictionary, you can use a section's :meth:`get` method to provide "
"fallback values:"
msgstr ""

#: ../../library/configparser.rst:220
msgid ""
"Please note that default values have precedence over fallback values. For "
"instance, in our example the ``'CompressionLevel'`` key was specified only "
"in the ``'DEFAULT'`` section.  If we try to get it from the section "
"``'topsecret.server.example'``, we will always get the default, even if we "
"specify a fallback:"
msgstr ""
"Observe que os valores padrão têm precedência sobre os valores substitutos. "
"Por exemplo, em nosso exemplo a chave ``'CompressionLevel'`` foi "
"especificada apenas na seção ``'DEFAULT'``. Se tentarmos obtê-lo na seção "
"``'topsecret.server.example'``, sempre obteremos o padrão, mesmo se "
"especificarmos um substituto:"

#: ../../library/configparser.rst:231
msgid ""
"One more thing to be aware of is that the parser-level :meth:`get` method "
"provides a custom, more complex interface, maintained for backwards "
"compatibility.  When using this method, a fallback value can be provided via "
"the ``fallback`` keyword-only argument:"
msgstr ""

#: ../../library/configparser.rst:242
msgid ""
"The same ``fallback`` argument can be used with the :meth:`~ConfigParser."
"getint`, :meth:`~ConfigParser.getfloat` and :meth:`~ConfigParser.getboolean` "
"methods, for example:"
msgstr ""
"O mesmo argumento ``fallback`` pode ser usado com os métodos :meth:"
"`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat` e :meth:"
"`~ConfigParser.getboolean`, por exemplo:"

#: ../../library/configparser.rst:258
msgid "Supported INI File Structure"
msgstr "Estrutura dos arquivos INI"

#: ../../library/configparser.rst:260
msgid ""
"A configuration file consists of sections, each led by a ``[section]`` "
"header, followed by key/value entries separated by a specific string (``=`` "
"or ``:`` by default [1]_).  By default, section names are case sensitive but "
"keys are not [1]_.  Leading and trailing whitespace is removed from keys and "
"values. Values can be omitted if the parser is configured to allow it [1]_, "
"in which case the key/value delimiter may also be left out.  Values can also "
"span multiple lines, as long as they are indented deeper than the first line "
"of the value.  Depending on the parser's mode, blank lines may be treated as "
"parts of multiline values or ignored."
msgstr ""
"Um arquivo de configuração consiste em seções, cada uma liderada por um "
"cabeçalho ``[section]``, seguido por entradas de chave/valor separadas por "
"uma string específica (``=`` ou ``:`` por padrão [1]_) . Por padrão, os "
"nomes das seções diferenciam maiúsculas de minúsculas, mas as chaves não "
"[1]_. Os espaços em branco à esquerda e à direita são removidos das chaves e "
"dos valores. Os valores podem ser omitidos se o analisador sintático estiver "
"configurado para permitir [1]_, caso em que o delimitador chave/valor também "
"pode ser omitido. Os valores também podem abranger várias linhas, desde que "
"sejam indentados de forma mais profunda que a primeira linha do valor. "
"Dependendo do modo do analisador sintático, as linhas em branco podem ser "
"tratadas como partes de valores multilinhas ou ignoradas."

#: ../../library/configparser.rst:270
msgid ""
"By default,  a valid section name can be any string that does not contain '\\"
"\\n' or ']'. To change this, see :attr:`ConfigParser.SECTCRE`."
msgstr ""

#: ../../library/configparser.rst:273
msgid ""
"Configuration files may include comments, prefixed by specific characters "
"(``#`` and ``;`` by default [1]_).  Comments may appear on their own on an "
"otherwise empty line, possibly indented. [1]_"
msgstr ""
"Os arquivos de configuração podem incluir comentários, prefixados por "
"caracteres específicos (``#`` e ``;`` por padrão [1]_). Os comentários podem "
"aparecer sozinhos em uma linha vazia, possivelmente identados. [1]_"

#: ../../library/configparser.rst:277 ../../library/configparser.rst:340
msgid "For example:"
msgstr "Por exemplo:"

#: ../../library/configparser.rst:325
msgid "Interpolation of values"
msgstr "Interpolação de valores"

#: ../../library/configparser.rst:327
msgid ""
"On top of the core functionality, :class:`ConfigParser` supports "
"interpolation.  This means values can be preprocessed before returning them "
"from ``get()`` calls."
msgstr ""
"Além da funcionalidade principal, :class:`ConfigParser` oferece suporte a "
"interpolação. Isso significa que os valores podem ser pré-processados antes "
"de retorná-los das chamadas ``get()``."

#: ../../library/configparser.rst:335
msgid ""
"The default implementation used by :class:`ConfigParser`.  It enables values "
"to contain format strings which refer to other values in the same section, "
"or values in the special default section [1]_.  Additional default values "
"can be provided on initialization."
msgstr ""
"A implementação padrão usada por :class:`ConfigParser`. Ele permite que os "
"valores contenham strings de formato que se referem a outros valores na "
"mesma seção ou valores na seção padrão especial [1]_. Valores padrão "
"adicionais podem ser fornecidos na inicialização."

#: ../../library/configparser.rst:353
msgid ""
"In the example above, :class:`ConfigParser` with *interpolation* set to "
"``BasicInterpolation()`` would resolve ``%(home_dir)s`` to the value of "
"``home_dir`` (``/Users`` in this case).  ``%(my_dir)s`` in effect would "
"resolve to ``/Users/lumberjack``.  All interpolations are done on demand so "
"keys used in the chain of references do not have to be specified in any "
"specific order in the configuration file."
msgstr ""
"No exemplo acima, :class:`ConfigParser` com *interpolation* definido como "
"``BasicInterpolation()`` resolveria ``%(home_dir)s`` para o valor de "
"``home_dir`` (``/Users`` neste caso). ``%(my_dir)s`` na verdade resolveria "
"para ``/Users/lumberjack``. Todas as interpolações são feitas sob demanda, "
"portanto as chaves usadas na cadeia de referências não precisam ser "
"especificadas em nenhuma ordem específica no arquivo de configuração."

#: ../../library/configparser.rst:360
msgid ""
"With ``interpolation`` set to ``None``, the parser would simply return "
"``%(my_dir)s/Pictures`` as the value of ``my_pictures`` and ``%(home_dir)s/"
"lumberjack`` as the value of ``my_dir``."
msgstr ""
"Com ``interpolation`` definido como ``None``, o analisador sintático "
"simplesmente retornaria ``%(my_dir)s/Pictures`` como o valor de "
"``my_pictures`` e ``%(home_dir)s/lumberjack`` como o valor de ``my_dir``."

#: ../../library/configparser.rst:368
msgid ""
"An alternative handler for interpolation which implements a more advanced "
"syntax, used for instance in ``zc.buildout``.  Extended interpolation is "
"using ``${section:option}`` to denote a value from a foreign section. "
"Interpolation can span multiple levels.  For convenience, if the ``section:"
"`` part is omitted, interpolation defaults to the current section (and "
"possibly the default values from the special section)."
msgstr ""
"Um manipulador alternativo para interpolação que implementa uma sintaxe mais "
"avançada, usada, por exemplo, em ``zc.buildout``. A interpolação estendida "
"usa ``${section:option}`` para denotar um valor de uma seção estrangeira. A "
"interpolação pode abranger vários níveis. Por conveniência, se a parte "
"``section:`` for omitida, a interpolação será padronizada para a seção atual "
"(e possivelmente para os valores padrão da seção especial)."

#: ../../library/configparser.rst:375
msgid ""
"For example, the configuration specified above with basic interpolation, "
"would look like this with extended interpolation:"
msgstr ""
"Por exemplo, a configuração especificada acima com interpolação básica "
"ficaria assim com interpolação estendida:"

#: ../../library/configparser.rst:389
msgid "Values from other sections can be fetched as well:"
msgstr "Valores de outras seções também podem ser obtidos:"

#: ../../library/configparser.rst:411
msgid "Mapping Protocol Access"
msgstr "Acesso através do protocolo de mapeamento"

#: ../../library/configparser.rst:415
msgid ""
"Mapping protocol access is a generic name for functionality that enables "
"using custom objects as if they were dictionaries.  In case of :mod:"
"`configparser`, the mapping interface implementation is using the "
"``parser['section']['option']`` notation."
msgstr ""
"Acesso através do protocolo de mapeamento é um nome genérico para "
"funcionalidade que permite usar objetos personalizados como se fossem "
"dicionários. No caso de :mod:`configparser`, a implementação da interface de "
"mapeamento está usando a notação ``parser['section']['option']``."

#: ../../library/configparser.rst:420
msgid ""
"``parser['section']`` in particular returns a proxy for the section's data "
"in the parser.  This means that the values are not copied but they are taken "
"from the original parser on demand.  What's even more important is that when "
"values are changed on a section proxy, they are actually mutated in the "
"original parser."
msgstr ""
"``parser['section']`` em particular retorna um intermediário para os dados "
"da seção no analisador sintático. Isso significa que os valores não são "
"copiados, mas obtidos do analisador sintático original sob demanda. O que é "
"ainda mais importante é que quando os valores são alterados em um "
"intermediário de seção, eles são, na verdade, modificados no analisador "
"sintático original."

#: ../../library/configparser.rst:426
msgid ""
":mod:`configparser` objects behave as close to actual dictionaries as "
"possible. The mapping interface is complete and adheres to the :class:"
"`~collections.abc.MutableMapping` ABC. However, there are a few differences "
"that should be taken into account:"
msgstr ""
"Os objetos :mod:`configparser` se comportam o mais próximo possível dos "
"dicionários reais. A interface de mapeamento é completa e segue a ABC :class:"
"`~collections.abc.MutableMapping`. No entanto, existem algumas diferenças "
"que devem ser levadas em consideração:"

#: ../../library/configparser.rst:431
msgid ""
"By default, all keys in sections are accessible in a case-insensitive manner "
"[1]_.  E.g. ``for option in parser[\"section\"]`` yields only "
"``optionxform``'ed option key names.  This means lowercased keys by "
"default.  At the same time, for a section that holds the key ``'a'``, both "
"expressions return ``True``::"
msgstr ""
"Por padrão, todas as chaves nas seções são acessíveis sem distinção entre "
"maiúsculas e minúsculas [1]_. Por exemplo. ``for option in "
"parser[\"section\"]`` produz apenas nomes de chaves de opção "
"``optionxform``\\ ada. Isso significa chaves em letras minúsculas por "
"padrão. Ao mesmo tempo, para uma seção que contém a chave ``'a'``, ambas as "
"expressões retornam ``True``::"

#: ../../library/configparser.rst:439
msgid ""
"All sections include ``DEFAULTSECT`` values as well which means that ``."
"clear()`` on a section may not leave the section visibly empty.  This is "
"because default values cannot be deleted from the section (because "
"technically they are not there).  If they are overridden in the section, "
"deleting causes the default value to be visible again.  Trying to delete a "
"default value causes a :exc:`KeyError`."
msgstr ""
"Todas as seções também incluem valores ``DEFAULTSECT``, o que significa que "
"``.clear()`` em uma seção não pode deixá-la visivelmente vazia. Isso ocorre "
"porque os valores padrão não podem ser excluídos da seção (porque "
"tecnicamente eles não estão lá). Se eles forem substituídos na seção, a "
"exclusão fará com que o valor padrão fique visível novamente. Tentar excluir "
"um valor padrão causa um :exc:`KeyError`."

#: ../../library/configparser.rst:446
msgid "``DEFAULTSECT`` cannot be removed from the parser:"
msgstr "``DEFAULTSECT`` não pode ser removido do analisador sintático:"

#: ../../library/configparser.rst:448
msgid "trying to delete it raises :exc:`ValueError`,"
msgstr "tentar excluí-lo levanta :exc:`ValueError`,"

#: ../../library/configparser.rst:450
msgid "``parser.clear()`` leaves it intact,"
msgstr "``parser.clear()`` deixa-o intacto,"

#: ../../library/configparser.rst:452
msgid "``parser.popitem()`` never returns it."
msgstr "``parser.popitem()`` nunca o retorna."

#: ../../library/configparser.rst:454
msgid ""
"``parser.get(section, option, **kwargs)`` - the second argument is **not** a "
"fallback value.  Note however that the section-level ``get()`` methods are "
"compatible both with the mapping protocol and the classic configparser API."
msgstr ""
"``parser.get(section, option, **kwargs)`` - o segundo argumento **não** é um "
"valor substituto. Observe, entretanto, que os métodos ``get()`` em nível de "
"seção são compatíveis tanto com o protocolo de mapeamento quanto com a API "
"clássica do configparser."

#: ../../library/configparser.rst:458
msgid ""
"``parser.items()`` is compatible with the mapping protocol (returns a list "
"of *section_name*, *section_proxy* pairs including the DEFAULTSECT).  "
"However, this method can also be invoked with arguments: ``parser."
"items(section, raw, vars)``.  The latter call returns a list of *option*, "
"*value* pairs for a specified ``section``, with all interpolations expanded "
"(unless ``raw=True`` is provided)."
msgstr ""
"``parser.items()`` é compatível com o protocolo de mapeamento (retorna uma "
"lista de pares *section_name*, *section_proxy* incluindo o DEFAULTSECT). "
"Entretanto, este método também pode ser invocado com argumentos: ``parser."
"items(section, raw, vars)``. A última chamada retorna uma lista de pares "
"*option*, *value* para uma ``section`` especificada, com todas as "
"interpolações expandidas (a menos que ``raw=True`` seja fornecido)."

#: ../../library/configparser.rst:465
msgid ""
"The mapping protocol is implemented on top of the existing legacy API so "
"that subclasses overriding the original interface still should have mappings "
"working as expected."
msgstr ""
"O protocolo de mapeamento é implementado sobre a API legada existente para "
"que as subclasses que substituem a interface original ainda tenham "
"mapeamentos funcionando conforme o esperado."

#: ../../library/configparser.rst:471
msgid "Customizing Parser Behaviour"
msgstr "Personalizando o comportamento do analisador sintático"

#: ../../library/configparser.rst:473
msgid ""
"There are nearly as many INI format variants as there are applications using "
"it. :mod:`configparser` goes a long way to provide support for the largest "
"sensible set of INI styles available.  The default functionality is mainly "
"dictated by historical background and it's very likely that you will want to "
"customize some of the features."
msgstr ""
"Existem quase tantas variantes de formato INI quanto aplicações que o "
"utilizam. :mod:`configparser` percorre um longo caminho para fornecer "
"suporte para o maior conjunto sensato de estilos INI disponíveis. A "
"funcionalidade padrão é determinada principalmente pelo histórico e é muito "
"provável que você queira personalizar alguns dos recursos."

#: ../../library/configparser.rst:479
msgid ""
"The most common way to change the way a specific config parser works is to "
"use the :meth:`__init__` options:"
msgstr ""

#: ../../library/configparser.rst:482
msgid "*defaults*, default value: ``None``"
msgstr "*defaults*, valor padrão: ``None``"

#: ../../library/configparser.rst:484
msgid ""
"This option accepts a dictionary of key-value pairs which will be initially "
"put in the ``DEFAULT`` section.  This makes for an elegant way to support "
"concise configuration files that don't specify values which are the same as "
"the documented default."
msgstr ""
"Esta opção aceita um dicionário de pares chave-valor que será inicialmente "
"colocado na seção ``DEFAULT``. Isso é uma maneira elegante de oferecer "
"suporte a arquivos de configuração concisos que não especificam valores "
"iguais ao padrão documentado."

#: ../../library/configparser.rst:489
msgid ""
"Hint: if you want to specify default values for a specific section, use :"
"meth:`read_dict` before you read the actual file."
msgstr ""

#: ../../library/configparser.rst:492
msgid "*dict_type*, default value: :class:`dict`"
msgstr "*dict_type*, valor padrão: :class:`dict`"

#: ../../library/configparser.rst:494
msgid ""
"This option has a major impact on how the mapping protocol will behave and "
"how the written configuration files look.  With the standard dictionary, "
"every section is stored in the order they were added to the parser.  Same "
"goes for options within sections."
msgstr ""
"Esta opção tem um grande impacto no comportamento do protocolo de mapeamento "
"e na aparência dos arquivos de configuração gravados. Com o dicionário "
"padrão, cada seção é armazenada na ordem em que foram adicionadas ao "
"analisador sintático. O mesmo vale para opções dentro das seções."

#: ../../library/configparser.rst:499
msgid ""
"An alternative dictionary type can be used for example to sort sections and "
"options on write-back."
msgstr ""
"Um tipo de dicionário alternativo pode ser usado, por exemplo, para ordenar "
"as seções e opções ao fazer *write-back*."

#: ../../library/configparser.rst:502
msgid ""
"Please note: there are ways to add a set of key-value pairs in a single "
"operation.  When you use a regular dictionary in those operations, the order "
"of the keys will be ordered.  For example:"
msgstr ""
"Observação: existem maneiras de adicionar um conjunto de pares de valores-"
"chave em uma única operação. Quando você usa um dicionário regular nessas "
"operações, a classificação das chaves será ordenada. Por exemplo:"

#: ../../library/configparser.rst:524
msgid "*allow_no_value*, default value: ``False``"
msgstr "*allow_no_value*, valor padrão: ``False``"

#: ../../library/configparser.rst:526
msgid ""
"Some configuration files are known to include settings without values, but "
"which otherwise conform to the syntax supported by :mod:`configparser`.  The "
"*allow_no_value* parameter to the constructor can be used to indicate that "
"such values should be accepted:"
msgstr ""
"Alguns arquivos de configuração são conhecidos por incluir configurações sem "
"valores, mas que de outra forma estão em conformidade com a sintaxe "
"suportada por :mod:`configparser`. O parâmetro *allow_no_value* para o "
"construtor pode ser usado para indicar que tais valores devem ser aceitos:"

#: ../../library/configparser.rst:561
msgid "*delimiters*, default value: ``('=', ':')``"
msgstr "*delimiters*, valor padrão: ``('=', ':')``"

#: ../../library/configparser.rst:563
msgid ""
"Delimiters are substrings that delimit keys from values within a section. "
"The first occurrence of a delimiting substring on a line is considered a "
"delimiter.  This means values (but not keys) can contain the delimiters."
msgstr ""
"Delimitadores são substrings que delimitam chaves de valores dentro de uma "
"seção. A primeira ocorrência de uma substring delimitadora em uma linha é "
"considerada um delimitador. Isso significa que os valores (mas não as "
"chaves) podem conter os delimitadores."

#: ../../library/configparser.rst:567
msgid ""
"See also the *space_around_delimiters* argument to :meth:`ConfigParser."
"write`."
msgstr ""
"Veja também o argumento *space_around_delimiters* para :meth:`ConfigParser."
"write`."

#: ../../library/configparser.rst:570
msgid "*comment_prefixes*, default value: ``('#', ';')``"
msgstr "*comment_prefixes*, valor padrão: ``('#', ';')``"

#: ../../library/configparser.rst:572
msgid "*inline_comment_prefixes*, default value: ``None``"
msgstr "*inline_comment_prefixes*, valor padrão: ``None``"

#: ../../library/configparser.rst:574
msgid ""
"Comment prefixes are strings that indicate the start of a valid comment "
"within a config file. *comment_prefixes* are used only on otherwise empty "
"lines (optionally indented) whereas *inline_comment_prefixes* can be used "
"after every valid value (e.g. section names, options and empty lines as "
"well).  By default inline comments are disabled and ``'#'`` and ``';'`` are "
"used as prefixes for whole line comments."
msgstr ""
"Prefixos de comentários são strings que indicam o início de um comentário "
"válido em um arquivo de configuração. *comment_prefixes* são usados apenas "
"em linhas vazias (opcionalmente indentadas), enquanto "
"*inline_comment_prefixes* pode ser usado após cada valor válido (por "
"exemplo, nomes de seções, opções e linhas vazias também). Por padrão, os "
"comentários embutidos estão desabilitados e ``'#'`` e ``';'`` são usados "
"como prefixos para comentários de linha inteira."

#: ../../library/configparser.rst:581
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``comment_prefixes=('#',';')`` and ``inline_comment_prefixes=(';',)``."
msgstr ""
"Nas versões anteriores do :mod:`configparser`, o comportamento correspondia "
"a ``comment_prefixes=('#',';')`` e ``inline_comment_prefixes=(';',)``."

#: ../../library/configparser.rst:585
msgid ""
"Please note that config parsers don't support escaping of comment prefixes "
"so using *inline_comment_prefixes* may prevent users from specifying option "
"values with characters used as comment prefixes.  When in doubt, avoid "
"setting *inline_comment_prefixes*.  In any circumstances, the only way of "
"storing comment prefix characters at the beginning of a line in multiline "
"values is to interpolate the prefix, for example::"
msgstr ""
"Observe que os analisadores sintáticos de configuração não oferecem suporte "
"a escape de prefixos de comentários, portanto, usar "
"*inline_comment_prefixes* pode impedir que os usuários especifiquem valores "
"de opção com caracteres usados como prefixos de comentários. Em caso de "
"dúvida, evite definir *inline_comment_prefixes*. Em qualquer circunstância, "
"a única maneira de armazenar caracteres de prefixo de comentário no início "
"de uma linha em valores multilinha é interpolar o prefixo, por exemplo::"

#: ../../library/configparser.rst:631
msgid "*strict*, default value: ``True``"
msgstr "*strict*, valor padrão: ``True``"

#: ../../library/configparser.rst:633
msgid ""
"When set to ``True``, the parser will not allow for any section or option "
"duplicates while reading from a single source (using :meth:`read_file`, :"
"meth:`read_string` or :meth:`read_dict`).  It is recommended to use strict "
"parsers in new applications."
msgstr ""

#: ../../library/configparser.rst:638
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``strict=False``."
msgstr ""
"Nas versões anteriores do :mod:`configparser`, o comportamento correspondia "
"a ``strict=False``."

#: ../../library/configparser.rst:642
msgid "*empty_lines_in_values*, default value: ``True``"
msgstr "*empty_lines_in_values*, valor padrão: ``True``"

#: ../../library/configparser.rst:644
msgid ""
"In config parsers, values can span multiple lines as long as they are "
"indented more than the key that holds them.  By default parsers also let "
"empty lines to be parts of values.  At the same time, keys can be "
"arbitrarily indented themselves to improve readability.  In consequence, "
"when configuration files get big and complex, it is easy for the user to "
"lose track of the file structure.  Take for instance:"
msgstr ""
"Em analisadores sintáticos de configuração, os valores podem abranger várias "
"linhas, desde que sejam mais indentados do que a chave que os contém. Por "
"padrão, os analisadores sintáticos também permitem que linhas vazias façam "
"parte de valores. Ao mesmo tempo, as chaves podem ser indentados "
"arbitrariamente para melhorar a legibilidade. Consequentemente, quando os "
"arquivos de configuração ficam grandes e complexos, é fácil para o usuário "
"perder o controle da estrutura do arquivo. Tomemos por exemplo:"

#: ../../library/configparser.rst:659
msgid ""
"This can be especially problematic for the user to see if she's using a "
"proportional font to edit the file.  That is why when your application does "
"not need values with empty lines, you should consider disallowing them.  "
"This will make empty lines split keys every time.  In the example above, it "
"would produce two keys, ``key`` and ``this``."
msgstr ""
"Isso pode ser especialmente problemático para o usuário ver se está usando "
"uma fonte proporcional para editar o arquivo. É por isso que quando sua "
"aplicação não precisa de valores com linhas vazias, você deve considerar "
"proibi-los. Isso fará com que as linhas vazias dividam as chaves sempre. No "
"exemplo acima, seriam produzidas duas chaves, ``key`` e ``this``."

#: ../../library/configparser.rst:665
msgid ""
"*default_section*, default value: ``configparser.DEFAULTSECT`` (that is: "
"``\"DEFAULT\"``)"
msgstr ""
"*default_section*, valor padrão: ``configparser.DEFAULTSECT`` (isto é: "
"``\"DEFAULT\"``)"

#: ../../library/configparser.rst:668
msgid ""
"The convention of allowing a special section of default values for other "
"sections or interpolation purposes is a powerful concept of this library, "
"letting users create complex declarative configurations.  This section is "
"normally called ``\"DEFAULT\"`` but this can be customized to point to any "
"other valid section name.  Some typical values include: ``\"general\"`` or "
"``\"common\"``.  The name provided is used for recognizing default sections "
"when reading from any source and is used when writing configuration back to "
"a file.  Its current value can be retrieved using the ``parser_instance."
"default_section`` attribute and may be modified at runtime (i.e. to convert "
"files from one format to another)."
msgstr ""
"A convenção de permitir uma seção especial de valores padrão para outras "
"seções ou fins de interpolação é um conceito poderoso desta biblioteca, "
"permitindo aos usuários criar configurações declarativas complexas. Esta "
"seção normalmente é chamada de ``\"DEFAULT\"``, mas pode ser personalizada "
"para apontar para qualquer outro nome de seção válido. Alguns valores "
"típicos incluem: ``\"general\"`` ou ``\"common\"``. O nome fornecido é usado "
"para reconhecer seções padrão ao ler de qualquer fonte e é usado ao gravar a "
"configuração em um arquivo. Seu valor atual pode ser recuperado usando o "
"atributo ``parser_instance.default_section`` e pode ser modificado em tempo "
"de execução (ou seja, para converter arquivos de um formato para outro)."

#: ../../library/configparser.rst:679
msgid "*interpolation*, default value: ``configparser.BasicInterpolation``"
msgstr "*interpolation*, valor padrão: ``configparser.BasicInterpolation``"

#: ../../library/configparser.rst:681
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_. :class:"
"`RawConfigParser` has a default value of ``None``."
msgstr ""
"O comportamento de interpolação pode ser personalizado fornecendo um "
"manipulador personalizado por meio do argumento *interpolation*. ``None`` "
"pode ser usado para desligar completamente a interpolação, "
"``ExtendedInterpolation()`` fornece uma variante mais avançada inspirada em "
"``zc.buildout``. Mais sobre o assunto na `seção de documentação dedicada "
"<#interpolation-of-values>`_. :class:`RawConfigParser` tem um valor padrão "
"de ``None``."

#: ../../library/configparser.rst:688
msgid "*converters*, default value: not set"
msgstr "*converters*, valor padrão: não definido"

#: ../../library/configparser.rst:690
msgid ""
"Config parsers provide option value getters that perform type conversion.  "
"By default :meth:`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat`, "
"and :meth:`~ConfigParser.getboolean` are implemented.  Should other getters "
"be desirable, users may define them in a subclass or pass a dictionary where "
"each key is a name of the converter and each value is a callable "
"implementing said conversion.  For instance, passing ``{'decimal': decimal."
"Decimal}`` would add :meth:`getdecimal` on both the parser object and all "
"section proxies.  In other words, it will be possible to write both "
"``parser_instance.getdecimal('section', 'key', fallback=0)`` and "
"``parser_instance['section'].getdecimal('key', 0)``."
msgstr ""

#: ../../library/configparser.rst:701
msgid ""
"If the converter needs to access the state of the parser, it can be "
"implemented as a method on a config parser subclass.  If the name of this "
"method starts with ``get``, it will be available on all section proxies, in "
"the dict-compatible form (see the ``getdecimal()`` example above)."
msgstr ""
"Se o conversor precisar acessar o estado do analisador sintático, ele poderá "
"ser implementado como um método em uma subclasse do analisador sintático de "
"configuração. Se o nome deste método começar com ``get``, ele estará "
"disponível em todos os intermediários de seção, na forma compatível com dict "
"(veja o exemplo ``getdecimal()`` acima)."

#: ../../library/configparser.rst:706
msgid ""
"More advanced customization may be achieved by overriding default values of "
"these parser attributes.  The defaults are defined on the classes, so they "
"may be overridden by subclasses or by attribute assignment."
msgstr ""
"Uma personalização mais avançada pode ser obtida substituindo os valores "
"padrão desses atributos do analisador sintático. Os padrões são definidos "
"nas classes, portanto podem ser substituídos por subclasses ou por "
"atribuição de atributos."

#: ../../library/configparser.rst:712
msgid ""
"By default when using :meth:`~ConfigParser.getboolean`, config parsers "
"consider the following values ``True``: ``'1'``, ``'yes'``, ``'true'``, "
"``'on'`` and the following values ``False``: ``'0'``, ``'no'``, ``'false'``, "
"``'off'``.  You can override this by specifying a custom dictionary of "
"strings and their Boolean outcomes. For example:"
msgstr ""
"Por padrão, ao usar :meth:`~ConfigParser.getboolean`, os analisadores "
"sintáticos de configuração consideram os seguintes valores ``True``: "
"``'1'``, ``'yes'``, ``'true'``, ``'on'`` e os seguintes valores ``False``: "
"``'0'``, ``'no'``, ``'false'``, ``'off'``. Você pode substituir isso "
"especificando um dicionário personalizado de strings e seus resultados "
"booleanos. Por exemplo:"

#: ../../library/configparser.rst:730
msgid ""
"Other typical Boolean pairs include ``accept``/``reject`` or ``enabled``/"
"``disabled``."
msgstr ""
"Outros pares booleanos típicos incluem ``accept``/``reject`` ou ``enabled``/"
"``disabled``."

#: ../../library/configparser.rst:736
msgid ""
"This method transforms option names on every read, get, or set operation.  "
"The default converts the name to lowercase.  This also means that when a "
"configuration file gets written, all keys will be lowercase.  Override this "
"method if that's unsuitable. For example:"
msgstr ""
"Este método transforma nomes de opções em cada operação de leitura, obtenção "
"ou definição. O padrão converte o nome em letras minúsculas. Isso também "
"significa que quando um arquivo de configuração for gravado, todas as chaves "
"estarão em letras minúsculas. Substitua esse método se for inadequado. Por "
"exemplo:"

#: ../../library/configparser.rst:766
msgid ""
"The optionxform function transforms option names to a canonical form. This "
"should be an idempotent function: if the name is already in canonical form, "
"it should be returned unchanged."
msgstr ""
"A função optionxform transforma nomes de opções em um formato canônico. Esta "
"deve ser uma função idempotente: se o nome já estiver na forma canônica, "
"deverá ser retornado inalterado."

#: ../../library/configparser.rst:773
msgid ""
"A compiled regular expression used to parse section headers.  The default "
"matches ``[section]`` to the name ``\"section\"``.  Whitespace is considered "
"part of the section name, thus ``[  larch  ]`` will be read as a section of "
"name ``\"  larch  \"``.  Override this attribute if that's unsuitable.  For "
"example:"
msgstr ""
"Uma expressão regular compilada usada para analisar cabeçalhos de seção. O "
"padrão corresponde a ``[section]`` para o nome ``\"section\"``. O espaço em "
"branco é considerado parte do nome da seção, portanto ``[  larch  ]`` será "
"lido como uma seção de nome ``\"  larch  \"``. Substitua esse atributo se "
"for inadequado. Por exemplo:"

#: ../../library/configparser.rst:801
msgid ""
"While ConfigParser objects also use an ``OPTCRE`` attribute for recognizing "
"option lines, it's not recommended to override it because that would "
"interfere with constructor options *allow_no_value* and *delimiters*."
msgstr ""
"Embora os objetos ConfigParser também usem um atributo ``OPTCRE`` para "
"reconhecer linhas de opção, não é recomendado substituí-lo porque isso "
"interferiria nas opções do construtor *allow_no_value* e *delimiters*."

#: ../../library/configparser.rst:807
msgid "Legacy API Examples"
msgstr "Exemplos de APIs legadas"

#: ../../library/configparser.rst:809
msgid ""
"Mainly because of backwards compatibility concerns, :mod:`configparser` "
"provides also a legacy API with explicit ``get``/``set`` methods.  While "
"there are valid use cases for the methods outlined below, mapping protocol "
"access is preferred for new projects.  The legacy API is at times more "
"advanced, low-level and downright counterintuitive."
msgstr ""
"Principalmente por questões de compatibilidade com versões anteriores, :mod:"
"`configparser` fornece também uma API legada com métodos ``get``/``set`` "
"explícitos. Embora existam casos de uso válidos para os métodos descritos "
"abaixo, o acesso ao protocolo de mapeamento é preferido para novos projetos. "
"A API legada é às vezes mais avançada, de baixo nível e totalmente "
"contraintuitiva."

#: ../../library/configparser.rst:815
msgid "An example of writing to a configuration file::"
msgstr "Um exemplo de escrita em um arquivo de configuração::"

#: ../../library/configparser.rst:838
msgid "An example of reading the configuration file again::"
msgstr "Um exemplo de leitura do arquivo de configuração novamente::"

#: ../../library/configparser.rst:856
msgid "To get interpolation, use :class:`ConfigParser`::"
msgstr "Para obter interpolação, use :class:`ConfigParser`::"

#: ../../library/configparser.rst:889
msgid ""
"Default values are available in both types of ConfigParsers.  They are used "
"in interpolation if an option used is not defined elsewhere. ::"
msgstr ""
"Os valores padrão estão disponíveis em ambos os tipos de ConfigParsers. Eles "
"são usados em interpolação se uma opção usada não estiver definida em outro "
"lugar. ::"

#: ../../library/configparser.rst:907
msgid "ConfigParser Objects"
msgstr "Objetos ConfigParser"

#: ../../library/configparser.rst:911
msgid ""
"The main configuration parser.  When *defaults* is given, it is initialized "
"into the dictionary of intrinsic defaults.  When *dict_type* is given, it "
"will be used to create the dictionary objects for the list of sections, for "
"the options within a section, and for the default values."
msgstr ""
"O principal analisador sintático de configuração. Quando *defaults* é "
"fornecido, ele é inicializado no dicionário de padrões intrínsecos. Quando "
"*dict_type* for fornecido, ele será usado para criar os objetos dicionário "
"para a lista de seções, para as opções dentro de uma seção e para os valores "
"padrão."

#: ../../library/configparser.rst:916
msgid ""
"When *delimiters* is given, it is used as the set of substrings that divide "
"keys from values.  When *comment_prefixes* is given, it will be used as the "
"set of substrings that prefix comments in otherwise empty lines. Comments "
"can be indented.  When *inline_comment_prefixes* is given, it will be used "
"as the set of substrings that prefix comments in non-empty lines."
msgstr ""
"Quando *delimiters* são fornecidos, eles são usados como o conjunto de "
"substrings que dividem chaves de valores. Quando *comment_prefixes* for "
"fornecido, ele será usado como o conjunto de substrings que prefixam "
"comentários em linhas vazias. Os comentários podem ser indentados. Quando "
"*inline_comment_prefixes* for fornecido, ele será usado como o conjunto de "
"substrings que prefixam comentários em linhas não vazias."

#: ../../library/configparser.rst:922
msgid ""
"When *strict* is ``True`` (the default), the parser won't allow for any "
"section or option duplicates while reading from a single source (file, "
"string or dictionary), raising :exc:`DuplicateSectionError` or :exc:"
"`DuplicateOptionError`.  When *empty_lines_in_values* is ``False`` (default: "
"``True``), each empty line marks the end of an option.  Otherwise, internal "
"empty lines of a multiline option are kept as part of the value. When "
"*allow_no_value* is ``True`` (default: ``False``), options without values "
"are accepted; the value held for these is ``None`` and they are serialized "
"without the trailing delimiter."
msgstr ""
"Quando *strict* for ``True`` (o padrão), o analisador sintático não "
"permitirá nenhuma seção ou opção duplicada durante a leitura de uma única "
"fonte (arquivo, string ou dicionário), levantando :exc:"
"`DuplicateSectionError` ou :exc:`DuplicateOptionError`. Quando "
"*empty_lines_in_values* é ``False`` (padrão: ``True``), cada linha vazia "
"marca o fim de uma opção. Caso contrário, as linhas vazias internas de uma "
"opção multilinha serão mantidas como parte do valor. Quando *allow_no_value* "
"for ``True`` (padrão: ``False``), opções sem valores serão aceitas; o valor "
"mantido para estes é ``None`` e eles são serializados sem o delimitador "
"final."

#: ../../library/configparser.rst:932
msgid ""
"When *default_section* is given, it specifies the name for the special "
"section holding default values for other sections and interpolation purposes "
"(normally named ``\"DEFAULT\"``).  This value can be retrieved and changed "
"on runtime using the ``default_section`` instance attribute."
msgstr ""

#: ../../library/configparser.rst:937
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_."
msgstr ""
"O comportamento de interpolação pode ser personalizado fornecendo um "
"manipulador personalizado por meio do argumento *interpolation*. ``None`` "
"pode ser usado para desligar completamente a interpolação, "
"``ExtendedInterpolation()`` fornece uma variante mais avançada inspirada em "
"``zc.buildout``. Mais sobre o assunto na `seção de documentação dedicada "
"<#interpolation-of-values>`_."

#: ../../library/configparser.rst:943
msgid ""
"All option names used in interpolation will be passed through the :meth:"
"`optionxform` method just like any other option name reference.  For "
"example, using the default implementation of :meth:`optionxform` (which "
"converts option names to lower case), the values ``foo %(bar)s`` and ``foo "
"%(BAR)s`` are equivalent."
msgstr ""
"Todos os nomes de opções usados na interpolação serão passados através do "
"método :meth:`optionxform` assim como qualquer outra referência de nome de "
"opção. Por exemplo, usando a implementação padrão de :meth:`optionxform` "
"(que converte nomes de opções para letras minúsculas), os valores ``foo "
"%(bar)s`` e ``foo %(BAR)s`` são equivalentes."

#: ../../library/configparser.rst:949
msgid ""
"When *converters* is given, it should be a dictionary where each key "
"represents the name of a type converter and each value is a callable "
"implementing the conversion from string to the desired datatype.  Every "
"converter gets its own corresponding :meth:`get*()` method on the parser "
"object and section proxies."
msgstr ""

#: ../../library/configparser.rst:955
msgid "The default *dict_type* is :class:`collections.OrderedDict`."
msgstr "O padrão *dict_type* é :class:`collections.OrderedDict`."

#: ../../library/configparser.rst:958
msgid ""
"*allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* and *interpolation* were added."
msgstr ""
"*allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* e *interpolation* foram "
"adicionados."

#: ../../library/configparser.rst:963
msgid "The *converters* argument was added."
msgstr "O argumento *converters* foi adicionado."

#: ../../library/configparser.rst:966
msgid ""
"The *defaults* argument is read with :meth:`read_dict()`, providing "
"consistent behavior across the parser: non-string keys and values are "
"implicitly converted to strings."
msgstr ""
"O argumento *defaults* é lido com :meth:`read_dict()`, fornecendo um "
"comportamento consistente em todo o analisador: chaves e valores que não são "
"de string são convertidos implicitamente em strings."

#: ../../library/configparser.rst:971 ../../library/configparser.rst:1256
msgid ""
"The default *dict_type* is :class:`dict`, since it now preserves insertion "
"order."
msgstr ""
"O *dict_type* padrão é :class:`dict`, pois agora preserva a ordem de "
"inserção."

#: ../../library/configparser.rst:977
msgid "Return a dictionary containing the instance-wide defaults."
msgstr "Retorna um dicionário contendo os padrões de toda a instância."

#: ../../library/configparser.rst:982
msgid ""
"Return a list of the sections available; the *default section* is not "
"included in the list."
msgstr ""
"Retorna uma lista das seções disponíveis; a *seção padrão* não está incluída "
"na lista."

#: ../../library/configparser.rst:988
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised.  The name of "
"the section must be a string; if not, :exc:`TypeError` is raised."
msgstr ""
"Adiciona uma seção de nome *section* à instância. Se já existir uma seção "
"com o nome fornecido, :exc:`DuplicateSectionError` será levantada. Se o nome "
"da *seção padrão* for passado, :exc:`ValueError` será levantada. O nome da "
"seção deve ser uma string; caso contrário, :exc:`TypeError` será levantada."

#: ../../library/configparser.rst:993
msgid "Non-string section names raise :exc:`TypeError`."
msgstr "Nomes de seções sem string levantam :exc:`TypeError`."

#: ../../library/configparser.rst:999
msgid ""
"Indicates whether the named *section* is present in the configuration. The "
"*default section* is not acknowledged."
msgstr ""
"Indica se a *section* nomeada está presente na configuração. A *seção "
"padrão* não é reconhecida."

#: ../../library/configparser.rst:1005
msgid "Return a list of options available in the specified *section*."
msgstr "Retorna uma lista de opções disponíveis na *section* especificada."

#: ../../library/configparser.rst:1010
msgid ""
"If the given *section* exists, and contains the given *option*, return :"
"const:`True`; otherwise return :const:`False`.  If the specified *section* "
"is :const:`None` or an empty string, DEFAULT is assumed."
msgstr ""
"Se a *section* fornecida existir e contiver a *option* fornecida, retorna :"
"const:`True`; caso contrário, retorna :const:`False`. Se a *section* "
"especificada for :const:`None` ou uma string vazia, DEFAULT será presumido."

#: ../../library/configparser.rst:1017
msgid ""
"Attempt to read and parse an iterable of filenames, returning a list of "
"filenames which were successfully parsed."
msgstr ""
"Tenta ler e analisar um iterável de nomes de arquivos, retornando uma lista "
"de nomes de arquivos que foram analisados com sucesso."

#: ../../library/configparser.rst:1020
msgid ""
"If *filenames* is a string, a :class:`bytes` object or a :term:`path-like "
"object`, it is treated as a single filename.  If a file named in *filenames* "
"cannot be opened, that file will be ignored.  This is designed so that you "
"can specify an iterable of potential configuration file locations (for "
"example, the current directory, the user's home directory, and some system-"
"wide directory), and all existing configuration files in the iterable will "
"be read."
msgstr ""
"Se *filenames* for uma string, um objeto :class:`bytes` ou um :term:`objeto "
"caminho ou similar`, este parâmetro será tratado como um único nome de "
"arquivo. Se um arquivo nomeado em *filenames* não puder ser aberto, esse "
"arquivo será ignorado. Isso foi projetado para que você possa especificar um "
"iterável de possíveis locais de arquivo de configuração (por exemplo, o "
"diretório atual, o diretório inicial do usuário e algum diretório de todo o "
"sistema) e todos os arquivos de configuração existentes no iterável serão "
"lidos."

#: ../../library/configparser.rst:1029
msgid ""
"If none of the named files exist, the :class:`ConfigParser` instance will "
"contain an empty dataset.  An application which requires initial values to "
"be loaded from a file should load the required file or files using :meth:"
"`read_file` before calling :meth:`read` for any optional files::"
msgstr ""
"Se nenhum dos arquivos nomeados existir, a instância :class:`ConfigParser` "
"conterá um conjunto de dados vazio. Uma aplicação que requer que valores "
"iniciais sejam carregados de um arquivo deve carregar o arquivo ou arquivos "
"necessários usando :meth:`read_file` antes de chamar :meth:`read` para "
"quaisquer arquivos opcionais::"

#: ../../library/configparser.rst:1042
msgid ""
"The *encoding* parameter.  Previously, all files were read using the default "
"encoding for :func:`open`."
msgstr ""

#: ../../library/configparser.rst:1046
msgid "The *filenames* parameter accepts a :term:`path-like object`."
msgstr "O parâmetro *filenames* aceita um :term:`objeto caminho ou similar`."

#: ../../library/configparser.rst:1049
msgid "The *filenames* parameter accepts a :class:`bytes` object."
msgstr "O parâmetro *filenames* aceita um objeto :class:`bytes`."

#: ../../library/configparser.rst:1055
msgid ""
"Read and parse configuration data from *f* which must be an iterable "
"yielding Unicode strings (for example files opened in text mode)."
msgstr ""
"Lê e analisa dados de configuração de *f* que devem ser iteráveis, "
"produzindo strings Unicode (por exemplo, arquivos abertos em modo texto)."

#: ../../library/configparser.rst:1058
msgid ""
"Optional argument *source* specifies the name of the file being read.  If "
"not given and *f* has a :attr:`name` attribute, that is used for *source*; "
"the default is ``'<???>'``."
msgstr ""

#: ../../library/configparser.rst:1062
msgid "Replaces :meth:`readfp`."
msgstr "Substitui :meth:`readfp`."

#: ../../library/configparser.rst:1067
msgid "Parse configuration data from a string."
msgstr "Analisa dados de configuração de uma string."

#: ../../library/configparser.rst:1069
msgid ""
"Optional argument *source* specifies a context-specific name of the string "
"passed.  If not given, ``'<string>'`` is used.  This should commonly be a "
"filesystem path or a URL."
msgstr ""
"O argumento opcional *source* especifica um nome específico do contexto da "
"string passada. Se não for fornecido, ``'<string>'`` será usado. Geralmente "
"deve ser um caminho do sistema de arquivos ou uma URL."

#: ../../library/configparser.rst:1078
msgid ""
"Load configuration from any object that provides a dict-like ``items()`` "
"method.  Keys are section names, values are dictionaries with keys and "
"values that should be present in the section.  If the used dictionary type "
"preserves order, sections and their keys will be added in order. Values are "
"automatically converted to strings."
msgstr ""
"Carrega a configuração de qualquer objeto que forneça um método ``items()`` "
"dict ou similar. Chaves são nomes de seções, valores são dicionários com "
"chaves e valores que devem estar presentes na seção. Se o tipo de dicionário "
"usado preservar a ordem, as seções e suas chaves serão adicionadas em ordem. "
"Os valores são convertidos automaticamente em strings."

#: ../../library/configparser.rst:1084
msgid ""
"Optional argument *source* specifies a context-specific name of the "
"dictionary passed.  If not given, ``<dict>`` is used."
msgstr ""
"O argumento opcional *source* especifica um nome específico do contexto do "
"dicionário passado. Se não for fornecido, ``<dict>`` será usado."

#: ../../library/configparser.rst:1087
msgid "This method can be used to copy state between parsers."
msgstr ""
"Este método pode ser usado para copiar o estado entre analisadores "
"sintáticos."

#: ../../library/configparser.rst:1094
msgid ""
"Get an *option* value for the named *section*.  If *vars* is provided, it "
"must be a dictionary.  The *option* is looked up in *vars* (if provided), "
"*section*, and in *DEFAULTSECT* in that order.  If the key is not found and "
"*fallback* is provided, it is used as a fallback value.  ``None`` can be "
"provided as a *fallback* value."
msgstr ""
"Obtém um valor de *option* para a *section* nomeada. Se *vars* for "
"fornecido, deverá ser um dicionário. A *option* é pesquisada em *vars* (se "
"fornecido), *section* e em *DEFAULTSECT* nesta ordem. Se a chave não for "
"encontrada e *fallback* for fornecido, ele será usado como um valor "
"alternativo. ``None`` pode ser fornecido como um valor *fallback*."

#: ../../library/configparser.rst:1100
msgid ""
"All the ``'%'`` interpolations are expanded in the return values, unless the "
"*raw* argument is true.  Values for interpolation keys are looked up in the "
"same manner as the option."
msgstr ""
"Todas as interpolações ``'%'`` são expandidas nos valores de retorno, a "
"menos que o argumento *raw* seja verdadeiro. Os valores das chaves de "
"interpolação são consultados da mesma maneira que a opção."

#: ../../library/configparser.rst:1104
msgid ""
"Arguments *raw*, *vars* and *fallback* are keyword only to protect users "
"from trying to use the third argument as the *fallback* fallback (especially "
"when using the mapping protocol)."
msgstr ""
"Os argumentos *raw*, *vars* e *fallback* são palavras somente-nomeadas para "
"proteger os usuários de tentarem usar o terceiro argumento como substituto "
"*fallback* (especialmente ao usar o protocolo de mapeamento)."

#: ../../library/configparser.rst:1112
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to an integer.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"Um método de conveniência que força a *option* na *section* especificada ser "
"um número inteiro. Veja :meth:`get` para explicação de *raw*, *vars* e "
"*fallback*."

#: ../../library/configparser.rst:1119
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a floating point number.  See :meth:`get` for explanation of *raw*, "
"*vars* and *fallback*."
msgstr ""

#: ../../library/configparser.rst:1126
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a Boolean value.  Note that the accepted values for the option are "
"``'1'``, ``'yes'``, ``'true'``, and ``'on'``, which cause this method to "
"return ``True``, and ``'0'``, ``'no'``, ``'false'``, and ``'off'``, which "
"cause it to return ``False``.  These string values are checked in a case-"
"insensitive manner.  Any other value will cause it to raise :exc:"
"`ValueError`.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"Um método de conveniência que força a *option* na *section* especificada a "
"um valor booleano. Observe que os valores aceitos para a opção são ``'1'``, "
"``'yes'``, ``'true'``, e ``'on'``, o que fazem com que este método retorne "
"``True``, e ``'0'``, ``'no'``, ``'false'``, e ``'off'``, o que fazem com que "
"ele retorne ``False``. Esses valores de string são verificados sem distinção "
"entre maiúsculas e minúsculas. Qualquer outro valor fará com que ele "
"levante :exc:`ValueError`. Veja :meth:`get` para explicação de *raw*, *vars* "
"e *fallback*."

#: ../../library/configparser.rst:1139
msgid ""
"When *section* is not given, return a list of *section_name*, "
"*section_proxy* pairs, including DEFAULTSECT."
msgstr ""
"Quando *section* não é fornecido, retorna uma lista de pares *section_name*, "
"*section_proxy*, incluindo DEFAULTSECT."

#: ../../library/configparser.rst:1142
msgid ""
"Otherwise, return a list of *name*, *value* pairs for the options in the "
"given *section*.  Optional arguments have the same meaning as for the :meth:"
"`get` method."
msgstr ""
"Caso contrário, retorna uma lista de pares *name*, *value* para as opções na "
"*section* fornecida. Argumentos opcionais têm o mesmo significado do método :"
"meth:`get`."

#: ../../library/configparser.rst:1146
msgid ""
"Items present in *vars* no longer appear in the result.  The previous "
"behaviour mixed actual parser options with variables provided for "
"interpolation."
msgstr ""
"Os itens presentes em *vars* não aparecem mais no resultado. O comportamento "
"anterior misturava opções reais do analisador sintático com variáveis "
"fornecidas para interpolação."

#: ../../library/configparser.rst:1154
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  *option* and *value* must be "
"strings; if not, :exc:`TypeError` is raised."
msgstr ""
"Se a seção fornecida existir, defina a opção fornecida com o valor "
"especificado; caso contrário, levanta :exc:`NoSectionError`. *option* e "
"*value* devem ser strings; caso contrário, :exc:`TypeError` será levantada."

#: ../../library/configparser.rst:1161
msgid ""
"Write a representation of the configuration to the specified :term:`file "
"object`, which must be opened in text mode (accepting strings).  This "
"representation can be parsed by a future :meth:`read` call.  If "
"*space_around_delimiters* is true, delimiters between keys and values are "
"surrounded by spaces."
msgstr ""
"Escreve uma representação da configuração no :term:`objeto arquivo` "
"especificado, que deve ser aberto em modo texto (aceitando strings). Esta "
"representação pode ser analisada por uma futura chamada :meth:`read`. Se "
"*space_around_delimiters* for verdadeiro, os delimitadores entre chaves e "
"valores serão envoltos por espaços."

#: ../../library/configparser.rst:1169
msgid ""
"Comments in the original configuration file are not preserved when writing "
"the configuration back. What is considered a comment, depends on the given "
"values for *comment_prefix* and *inline_comment_prefix*."
msgstr ""
"Os comentários no arquivo de configuração original não são preservados ao "
"escrever a configuração. O que é considerado um comentário depende dos "
"valores fornecidos para *comment_prefix* e *inline_comment_prefix*."

#: ../../library/configparser.rst:1177
msgid ""
"Remove the specified *option* from the specified *section*.  If the section "
"does not exist, raise :exc:`NoSectionError`.  If the option existed to be "
"removed, return :const:`True`; otherwise return :const:`False`."
msgstr ""
"Remove a *option* especificada da *section* especificada. Se a seção não "
"existir, levanta :exc:`NoSectionError`. Se existisse a opção de ser "
"removida, retorna :const:`True`; caso contrário, retorna :const:`False`."

#: ../../library/configparser.rst:1185
msgid ""
"Remove the specified *section* from the configuration.  If the section in "
"fact existed, return ``True``.  Otherwise return ``False``."
msgstr ""
"Remove a *section* especificada da configuração. Se a seção de fato existiu, "
"retorna ``True``. Caso contrário, retorna ``False``."

#: ../../library/configparser.rst:1191
msgid ""
"Transforms the option name *option* as found in an input file or as passed "
"in by client code to the form that should be used in the internal "
"structures.  The default implementation returns a lower-case version of "
"*option*; subclasses may override this or client code can set an attribute "
"of this name on instances to affect this behavior."
msgstr ""
"Transforma o nome da opção *option* conforme encontrado em um arquivo de "
"entrada ou conforme passado pelo código do cliente no formato que deve ser "
"usado nas estruturas internas. A implementação padrão retorna uma versão em "
"minúsculas de *option*; subclasses podem substituir isso ou o código do "
"cliente pode definir um atributo com esse nome nas instâncias para afetar "
"esse comportamento."

#: ../../library/configparser.rst:1197
msgid ""
"You don't need to subclass the parser to use this method, you can also set "
"it on an instance, to a function that takes a string argument and returns a "
"string.  Setting it to ``str``, for example, would make option names case "
"sensitive::"
msgstr ""
"Você não precisa criar uma subclasse do analisador sintático para usar esse "
"método; você também pode configurá-lo em uma instância, para uma função que "
"recebe um argumento de string e retorna uma string. Definir como ``str``, "
"por exemplo, faria com que sejam diferenciadas as letras maiúsculas das "
"minúsculas nos nomes das opções::"

#: ../../library/configparser.rst:1205
msgid ""
"Note that when reading configuration files, whitespace around the option "
"names is stripped before :meth:`optionxform` is called."
msgstr ""
"Observe que ao ler arquivos de configuração, os espaços em branco ao redor "
"dos nomes das opções são removidos antes de :meth:`optionxform` ser chamado."

#: ../../library/configparser.rst:1211
msgid "Use :meth:`read_file` instead."
msgstr ""

#: ../../library/configparser.rst:1214
msgid ""
":meth:`readfp` now iterates on *fp* instead of calling ``fp.readline()``."
msgstr ""

#: ../../library/configparser.rst:1217
msgid ""
"For existing code calling :meth:`readfp` with arguments which don't support "
"iteration, the following generator may be used as a wrapper around the file-"
"like object::"
msgstr ""

#: ../../library/configparser.rst:1227
msgid ""
"Instead of ``parser.readfp(fp)`` use ``parser."
"read_file(readline_generator(fp))``."
msgstr ""

#: ../../library/configparser.rst:1233
msgid ""
"The maximum depth for recursive interpolation for :meth:`get` when the *raw* "
"parameter is false.  This is relevant only when the default *interpolation* "
"is used."
msgstr ""

#: ../../library/configparser.rst:1241
msgid "RawConfigParser Objects"
msgstr "Objetos RawConfigParser"

#: ../../library/configparser.rst:1251
msgid ""
"Legacy variant of the :class:`ConfigParser`.  It has interpolation disabled "
"by default and allows for non-string section names, option names, and values "
"via its unsafe ``add_section`` and ``set`` methods, as well as the legacy "
"``defaults=`` keyword argument handling."
msgstr ""
"Variante legada do :class:`ConfigParser`. Ela tem a interpolação "
"desabilitada por padrão e permite nomes de seções não-string, nomes de "
"opções e valores através de seus métodos inseguros ``add_section`` e "
"``set``, bem como o tratamento de argumentos nomeados legados ``defaults=`` ."

#: ../../library/configparser.rst:1261
msgid ""
"Consider using :class:`ConfigParser` instead which checks types of the "
"values to be stored internally.  If you don't want interpolation, you can "
"use ``ConfigParser(interpolation=None)``."
msgstr ""
"Considere usar :class:`ConfigParser`, que verifica os tipos de valores a "
"serem armazenados internamente. Se você não quiser interpolação, você pode "
"usar ``ConfigParser(interpolation=None)``."

#: ../../library/configparser.rst:1268
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised."
msgstr ""
"Adiciona uma seção chamada *section* à instância. Se já existir uma seção "
"com o nome fornecido, :exc:`DuplicateSectionError` será levantada. Se o nome "
"da *seção padrão* for passado, :exc:`ValueError` será levantada."

#: ../../library/configparser.rst:1272
msgid ""
"Type of *section* is not checked which lets users create non-string named "
"sections.  This behaviour is unsupported and may cause internal errors."
msgstr ""
"O tipo da *section* não está marcado, o que permite aos usuários criar "
"seções nomeadas sem string. Este comportamento não é compatível e pode "
"causar erros internos."

#: ../../library/configparser.rst:1278
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  While it is possible to use :class:"
"`RawConfigParser` (or :class:`ConfigParser` with *raw* parameters set to "
"true) for *internal* storage of non-string values, full functionality "
"(including interpolation and output to files) can only be achieved using "
"string values."
msgstr ""
"Se a seção fornecida existir, defina a opção fornecida com o valor "
"especificado; caso contrário, levanta :exc:`NoSectionError`. Embora seja "
"possível usar :class:`RawConfigParser` (ou :class:`ConfigParser` com "
"parâmetros *raw* definidos como verdadeiro) para armazenamento *interno* de "
"valores não-string, funcionalidade completa (incluindo interpolação e saída "
"para arquivos) só pode ser alcançado usando valores de string."

#: ../../library/configparser.rst:1285
msgid ""
"This method lets users assign non-string values to keys internally.  This "
"behaviour is unsupported and will cause errors when attempting to write to a "
"file or get it in non-raw mode.  **Use the mapping protocol API** which does "
"not allow such assignments to take place."
msgstr ""
"Este método permite que os usuários atribuam valores não-string às chaves "
"internamente. Este comportamento não é suportado e causará erros ao tentar "
"escrever em um arquivo ou obtê-lo no modo não bruto. **Use a API do "
"protocolo de mapeamento** que não permite que tais atribuições ocorram."

#: ../../library/configparser.rst:1292
msgid "Exceptions"
msgstr "Exceções"

#: ../../library/configparser.rst:1296
msgid "Base class for all other :mod:`configparser` exceptions."
msgstr "Classe base para todas as outras exceções do :mod:`configparser`."

#: ../../library/configparser.rst:1301
msgid "Exception raised when a specified section is not found."
msgstr "Exceção levantada quando uma seção especificada não é encontrada."

#: ../../library/configparser.rst:1306
msgid ""
"Exception raised if :meth:`add_section` is called with the name of a section "
"that is already present or in strict parsers when a section if found more "
"than once in a single input file, string or dictionary."
msgstr ""

#: ../../library/configparser.rst:1310
msgid ""
"Optional ``source`` and ``lineno`` attributes and arguments to :meth:"
"`__init__` were added."
msgstr ""

#: ../../library/configparser.rst:1317
msgid ""
"Exception raised by strict parsers if a single option appears twice during "
"reading from a single file, string or dictionary. This catches misspellings "
"and case sensitivity-related errors, e.g. a dictionary may have two keys "
"representing the same case-insensitive configuration key."
msgstr ""
"Exceção levantada por analisadores sintáticos estritos se uma única opção "
"aparecer duas vezes durante a leitura de um único arquivo, string ou "
"dicionário. Isso detecta erros ortográficos e erros relacionados a "
"diferenciação de letras maiúsculas e minúsculas como, p. ex., um dicionário "
"pode ter duas chaves representando a mesma chave de configuração que não "
"diferencia maiúsculas de minúsculas."

#: ../../library/configparser.rst:1325
msgid ""
"Exception raised when a specified option is not found in the specified "
"section."
msgstr ""
"Exceção levantada quando uma opção especificada não é encontrada na seção "
"especificada."

#: ../../library/configparser.rst:1331
msgid ""
"Base class for exceptions raised when problems occur performing string "
"interpolation."
msgstr ""
"Classe base para exceções levantadas quando ocorrem problemas ao executar a "
"interpolação de strings."

#: ../../library/configparser.rst:1337
msgid ""
"Exception raised when string interpolation cannot be completed because the "
"number of iterations exceeds :const:`MAX_INTERPOLATION_DEPTH`.  Subclass of :"
"exc:`InterpolationError`."
msgstr ""
"Exceção levantada quando a interpolação de string não pode ser concluída "
"porque o número de iterações excede :const:`MAX_INTERPOLATION_DEPTH`. "
"Subclasse de :exc:`InterpolationError`."

#: ../../library/configparser.rst:1344
msgid ""
"Exception raised when an option referenced from a value does not exist. "
"Subclass of :exc:`InterpolationError`."
msgstr ""
"Exceção levantada quando uma opção referenciada a partir de um valor não "
"existe. Subclasse de :exc:`InterpolationError`."

#: ../../library/configparser.rst:1350
msgid ""
"Exception raised when the source text into which substitutions are made does "
"not conform to the required syntax.  Subclass of :exc:`InterpolationError`."
msgstr ""
"Exceção levantada quando o texto fonte no qual são feitas as substituições "
"não está em conformidade com a sintaxe exigida. Subclasse de :exc:"
"`InterpolationError`."

#: ../../library/configparser.rst:1356
msgid ""
"Exception raised when attempting to parse a file which has no section "
"headers."
msgstr ""
"Exceção levantada ao tentar analisar um arquivo que não possui cabeçalhos de "
"seção."

#: ../../library/configparser.rst:1362
msgid "Exception raised when errors occur attempting to parse a file."
msgstr "Exceção levantada quando ocorrem erros ao tentar analisar um arquivo."

#: ../../library/configparser.rst:1364
msgid ""
"The ``filename`` attribute and :meth:`__init__` argument were renamed to "
"``source`` for consistency."
msgstr ""

#: ../../library/configparser.rst:1370
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../library/configparser.rst:1371
msgid ""
"Config parsers allow for heavy customization.  If you are interested in "
"changing the behaviour outlined by the footnote reference, consult the "
"`Customizing Parser Behaviour`_ section."
msgstr ""
"Os analisadores sintáticos de configuração permitem muita personalização. "
"Caso você tenha interesse em alterar o comportamento descrito na referência "
"da nota de rodapé, consulte a seção `Personalizando o comportamento do "
"analisador sintático`_."

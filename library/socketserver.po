# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-03-07 16:17+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/socketserver.rst:2
msgid ":mod:`socketserver` --- A framework for network servers"
msgstr ""

#: ../../library/socketserver.rst:7
msgid "**Source code:** :source:`Lib/socketserver.py`"
msgstr "**Código-fonte:** :source:`Lib/socketserver.py`"

#: ../../library/socketserver.rst:11
msgid ""
"The :mod:`socketserver` module simplifies the task of writing network "
"servers."
msgstr ""
"O módulo :mod:`socketserver` simplifica a tarefa de escrever servidores de "
"rede."

#: ../../library/socketserver.rst:13
msgid "There are four basic concrete server classes:"
msgstr "Existem quatro classes básicas de servidores concretos:"

#: ../../library/socketserver.rst:18
msgid ""
"This uses the internet TCP protocol, which provides for continuous streams "
"of data between the client and server. If *bind_and_activate* is true, the "
"constructor automatically attempts to invoke :meth:`~BaseServer.server_bind` "
"and :meth:`~BaseServer.server_activate`.  The other parameters are passed to "
"the :class:`BaseServer` base class."
msgstr ""
"Isso usa o protocolo TCP da internet, que fornece fluxos contínuos de dados "
"entre o cliente e o servidor. Se *bind_and_activate* for true, o construtor "
"tenta automaticamente invocar :meth:`~BaseServer.server_bind` e :meth:"
"`~BaseServer.server_activate`. Os outros parâmetros são passados para a "
"classe base :class:`BaseServer`."

#: ../../library/socketserver.rst:28
msgid ""
"This uses datagrams, which are discrete packets of information that may "
"arrive out of order or be lost while in transit.  The parameters are the "
"same as for :class:`TCPServer`."
msgstr ""
"Isso usa datagramas, que são pacotes discretos de informações que podem "
"chegar fora de ordem ou ser perdidos durante o trânsito. Os parâmetros são "
"os mesmos de :class:`TCPServer`."

#: ../../library/socketserver.rst:36
msgid ""
"These more infrequently used classes are similar to the TCP and UDP classes, "
"but use Unix domain sockets; they're not available on non-Unix platforms.  "
"The parameters are the same as for :class:`TCPServer`."
msgstr ""
"Essas classes usadas com menos frequência são semelhantes às classes TCP e "
"UDP, mas usam soquetes de domínio Unix; elas não estão disponíveis em "
"plataformas não Unix. Os parâmetros são os mesmos de :class:`TCPServer`."

#: ../../library/socketserver.rst:42
msgid ""
"These four classes process requests :dfn:`synchronously`; each request must "
"be completed before the next request can be started.  This isn't suitable if "
"each request takes a long time to complete, because it requires a lot of "
"computation, or because it returns a lot of data which the client is slow to "
"process.  The solution is to create a separate process or thread to handle "
"each request; the :class:`ForkingMixIn` and :class:`ThreadingMixIn` mix-in "
"classes can be used to support asynchronous behaviour."
msgstr ""
"Essas quatro classes processam solicitações :dfn:`synchronously`; cada "
"solicitação deve ser concluída antes que a próxima solicitação possa ser "
"iniciada. Isso não é adequado se cada solicitação demorar muito para ser "
"concluída, porque exige muita computação ou porque retorna muitos dados que "
"o cliente demora a processar. A solução é criar um processo ou thread "
"separado para lidar com cada solicitação; as classes misturadas :class:"
"`ForkingMixIn` e :class:`ThreadingMixIn` podem ser usadas para oferecer "
"suporte ao comportamento assíncrono."

#: ../../library/socketserver.rst:50
msgid ""
"Creating a server requires several steps.  First, you must create a request "
"handler class by subclassing the :class:`BaseRequestHandler` class and "
"overriding its :meth:`~BaseRequestHandler.handle` method; this method will "
"process incoming requests.  Second, you must instantiate one of the server "
"classes, passing it the server's address and the request handler class. It "
"is recommended to use the server in a :keyword:`with` statement. Then call "
"the :meth:`~BaseServer.handle_request` or :meth:`~BaseServer.serve_forever` "
"method of the server object to process one or many requests.  Finally, call :"
"meth:`~BaseServer.server_close` to close the socket (unless you used a :"
"keyword:`!with` statement)."
msgstr ""
"Criar um servidor requer várias etapas. Primeiro, você deve criar uma classe "
"de manipulador de solicitação estendendo a classe :class:"
"`BaseRequestHandler` e substituindo seu método :meth:`~BaseRequestHandler."
"handle`; esse método processará as solicitações recebidas. Segundo, você "
"deve instanciar uma das classes de servidor, passando a ela o endereço do "
"servidor e a classe de manipulador de solicitação. É recomendável usar o "
"servidor em uma instrução :keyword:`with`. Em seguida, chame o método :meth:"
"`~BaseServer.handle_request` ou :meth:`~BaseServer.serve_forever` do objeto "
"do servidor para processar uma ou muitas solicitações. Finalmente, chame :"
"meth:`~BaseServer.server_close` para fechar o soquete (a menos que você "
"tenha usado uma instrução :keyword:`!with`)."

#: ../../library/socketserver.rst:62
msgid ""
"When inheriting from :class:`ThreadingMixIn` for threaded connection "
"behavior, you should explicitly declare how you want your threads to behave "
"on an abrupt shutdown.  The :class:`ThreadingMixIn` class defines an "
"attribute *daemon_threads*, which indicates whether or not the server should "
"wait for thread termination.  You should set the flag explicitly if you "
"would like threads to behave autonomously; the default is :const:`False`, "
"meaning that Python will not exit until all threads created by :class:"
"`ThreadingMixIn` have exited."
msgstr ""
"Ao herdar de :class:`ThreadingMixIn` para comportamento de conexão em "
"threads, você deve declarar explicitamente como quer que suas threads se "
"comportem em um desligamento abrupto. A classe :class:`ThreadingMixIn` "
"define um atributo *daemon_threads*, que indica se o servidor deve ou não "
"esperar pelo término da thread. Você deve definir o sinalizador "
"explicitamente se quiser que as threads se comportem de forma autônoma; o "
"padrão é :const:`False`, o que significa que o Python não sairá até que "
"todas as threads criadas por :class:`ThreadingMixIn` tenham sido encerradas."

#: ../../library/socketserver.rst:71
msgid ""
"Server classes have the same external methods and attributes, no matter what "
"network protocol they use."
msgstr ""
"As classes de servidor têm os mesmos métodos e atributos externos, não "
"importa qual protocolo de rede eles usam."

#: ../../library/socketserver.rst:76
msgid "Server Creation Notes"
msgstr "Notas sobre criação do servidor"

#: ../../library/socketserver.rst:78
msgid ""
"There are five classes in an inheritance diagram, four of which represent "
"synchronous servers of four types::"
msgstr ""
"Existem cinco classes em um diagrama de herança, quatro das quais "
"representam servidores síncronos de quatro tipos:"

#: ../../library/socketserver.rst:95
msgid ""
"Note that :class:`UnixDatagramServer` derives from :class:`UDPServer`, not "
"from :class:`UnixStreamServer` --- the only difference between an IP and a "
"Unix server is the address family."
msgstr ""
"Observe que :class:`UnixDatagramServer` deriva de :class:`UDPServer`, não "
"de :class:`UnixStreamServer` --- a única diferença entre um IP e um servidor "
"Unix é a família de endereços."

#: ../../library/socketserver.rst:103
msgid ""
"Forking and threading versions of each type of server can be created using "
"these mix-in classes.  For instance, :class:`ThreadingUDPServer` is created "
"as follows::"
msgstr ""
"Versões de fork e threads de cada tipo de servidor podem ser criadas usando "
"essas classes mix-in. Por exemplo, :class:`ThreadingUDPServer` é criado da "
"seguinte forma::"

#: ../../library/socketserver.rst:110
msgid ""
"The mix-in class comes first, since it overrides a method defined in :class:"
"`UDPServer`.  Setting the various attributes also changes the behavior of "
"the underlying server mechanism."
msgstr ""
"A classe mix-in vem primeiro, pois ela substitui um método definido em :"
"class:`UDPServer`. Definir os vários atributos também altera o comportamento "
"do mecanismo de servidor subjacente."

#: ../../library/socketserver.rst:114
msgid ""
":class:`ForkingMixIn` and the Forking classes mentioned below are only "
"available on POSIX platforms that support :func:`~os.fork`."
msgstr ""
":class:`ForkingMixIn` e as classes Forking mencionadas abaixo estão "
"disponíveis apenas em plataformas POSIX que oferecem suporte a :func:`~os."
"fork`."

#: ../../library/socketserver.rst:117
msgid ""
":meth:`socketserver.ForkingMixIn.server_close` waits until all child "
"processes complete, except if :attr:`socketserver.ForkingMixIn."
"block_on_close` attribute is false."
msgstr ""

#: ../../library/socketserver.rst:121
msgid ""
":meth:`socketserver.ThreadingMixIn.server_close` waits until all non-daemon "
"threads complete, except if :attr:`socketserver.ThreadingMixIn."
"block_on_close` attribute is false. Use daemonic threads by setting :data:"
"`ThreadingMixIn.daemon_threads` to ``True`` to not wait until threads "
"complete."
msgstr ""

#: ../../library/socketserver.rst:130
msgid ""
":meth:`socketserver.ForkingMixIn.server_close` and :meth:`socketserver."
"ThreadingMixIn.server_close` now waits until all child processes and non-"
"daemonic threads complete. Add a new :attr:`socketserver.ForkingMixIn."
"block_on_close` class attribute to opt-in for the pre-3.7 behaviour."
msgstr ""

#: ../../library/socketserver.rst:142
msgid "These classes are pre-defined using the mix-in classes."
msgstr "Essas classes são predefinidas usando as classes mix-in."

#: ../../library/socketserver.rst:145
msgid ""
"To implement a service, you must derive a class from :class:"
"`BaseRequestHandler` and redefine its :meth:`~BaseRequestHandler.handle` "
"method. You can then run various versions of the service by combining one of "
"the server classes with your request handler class.  The request handler "
"class must be different for datagram or stream services.  This can be hidden "
"by using the handler subclasses :class:`StreamRequestHandler` or :class:"
"`DatagramRequestHandler`."
msgstr ""
"Para implementar um serviço, você deve derivar uma classe de :class:"
"`BaseRequestHandler` e redefinir seu método :meth:`~BaseRequestHandler."
"handle`. Você pode então executar várias versões do serviço combinando uma "
"das classes de servidor com sua classe de manipulador de solicitação. A "
"classe de manipulador de solicitação deve ser diferente para serviços de "
"datagrama ou fluxo. Isso pode ser ocultado usando as subclasses de "
"manipulador :class:`StreamRequestHandler` ou :class:`DatagramRequestHandler`."

#: ../../library/socketserver.rst:153
msgid ""
"Of course, you still have to use your head!  For instance, it makes no sense "
"to use a forking server if the service contains state in memory that can be "
"modified by different requests, since the modifications in the child process "
"would never reach the initial state kept in the parent process and passed to "
"each child.  In this case, you can use a threading server, but you will "
"probably have to use locks to protect the integrity of the shared data."
msgstr ""
"Claro, você ainda tem que usar sua cabeça! Por exemplo, não faz sentido usar "
"um servidor de Forking se o serviço contém estado na memória que pode ser "
"modificado por diferentes solicitações, já que as modificações no processo "
"filho nunca atingiriam o estado inicial mantido no processo pai e passado "
"para cada filho. Neste caso, você pode usar um servidor de Threading, mas "
"provavelmente terá que usar travas para proteger a integridade dos dados "
"compartilhados."

#: ../../library/socketserver.rst:160
msgid ""
"On the other hand, if you are building an HTTP server where all data is "
"stored externally (for instance, in the file system), a synchronous class "
"will essentially render the service \"deaf\" while one request is being "
"handled -- which may be for a very long time if a client is slow to receive "
"all the data it has requested.  Here a threading or forking server is "
"appropriate."
msgstr ""
"Por outro lado, se você estiver construindo um servidor HTTP onde todos os "
"dados são armazenados externamente (por exemplo, no sistema de arquivos), "
"uma classe síncrona essencialmente tornará o serviço \"surdo\" enquanto uma "
"solicitação estiver sendo manipulada -- o que pode ser por um tempo muito "
"longo se um cliente for lento para receber todos os dados que solicitou. "
"Aqui, um servidor de Threading ou Forking é apropriado."

#: ../../library/socketserver.rst:166
msgid ""
"In some cases, it may be appropriate to process part of a request "
"synchronously, but to finish processing in a forked child depending on the "
"request data.  This can be implemented by using a synchronous server and "
"doing an explicit fork in the request handler class :meth:"
"`~BaseRequestHandler.handle` method."
msgstr ""
"Em alguns casos, pode ser apropriado processar parte de uma solicitação de "
"forma síncrona, mas terminar o processamento em um filho bifurcado "
"dependendo dos dados da solicitação. Isso pode ser implementado usando um "
"servidor síncrono e fazendo uma bifurcação explícita no método da classe do "
"manipulador de solicitações :meth:`~BaseRequestHandler.handle`."

#: ../../library/socketserver.rst:171
msgid ""
"Another approach to handling multiple simultaneous requests in an "
"environment that supports neither threads nor :func:`~os.fork` (or where "
"these are too expensive or inappropriate for the service) is to maintain an "
"explicit table of partially finished requests and to use :mod:`selectors` to "
"decide which request to work on next (or whether to handle a new incoming "
"request).  This is particularly important for stream services where each "
"client can potentially be connected for a long time (if threads or "
"subprocesses cannot be used).  See :mod:`asyncore` for another way to manage "
"this."
msgstr ""

#: ../../library/socketserver.rst:185
msgid "Server Objects"
msgstr "Objetos Server"

#: ../../library/socketserver.rst:189
msgid ""
"This is the superclass of all Server objects in the module.  It defines the "
"interface, given below, but does not implement most of the methods, which is "
"done in subclasses.  The two parameters are stored in the respective :attr:"
"`server_address` and :attr:`RequestHandlerClass` attributes."
msgstr ""
"Esta é a superclasse de todos os objetos Server no módulo. Ela define a "
"interface, dada abaixo, mas não implementa a maioria dos métodos, o que é "
"feito em subclasses. Os dois parâmetros são armazenados nos respectivos "
"atributos :attr:`server_address` e :attr:`RequestHandlerClass`."

#: ../../library/socketserver.rst:197
msgid ""
"Return an integer file descriptor for the socket on which the server is "
"listening.  This function is most commonly passed to :mod:`selectors`, to "
"allow monitoring multiple servers in the same process."
msgstr ""
"Retorna um descritor de arquivo inteiro para o soquete no qual o servidor "
"está escutando. Esta função é mais comumente passada para :mod:`selectors`, "
"para permitir o monitoramento de múltiplos servidores no mesmo processo."

#: ../../library/socketserver.rst:204
msgid ""
"Process a single request.  This function calls the following methods in "
"order: :meth:`get_request`, :meth:`verify_request`, and :meth:"
"`process_request`.  If the user-provided :meth:`~BaseRequestHandler.handle` "
"method of the handler class raises an exception, the server's :meth:"
"`handle_error` method will be called.  If no request is received within :"
"attr:`timeout` seconds, :meth:`handle_timeout` will be called and :meth:"
"`handle_request` will return."
msgstr ""
"Processa uma única solicitação. Esta função chama os seguintes métodos em "
"ordem: :meth:`get_request`, :meth:`verify_request` e :meth:"
"`process_request`. Se o método :meth:`~BaseRequestHandler.handle` fornecido "
"pelo usuário da classe manipuladora levantar uma exceção, o método :meth:"
"`handle_error` do servidor será chamado. Se nenhuma solicitação for recebida "
"dentro de :attr:`timeout` segundos, :meth:`handle_timeout` será chamado e :"
"meth:`handle_request` retornará."

#: ../../library/socketserver.rst:216
msgid ""
"Handle requests until an explicit :meth:`shutdown` request.  Poll for "
"shutdown every *poll_interval* seconds. Ignores the :attr:`timeout` "
"attribute.  It also calls :meth:`service_actions`, which may be used by a "
"subclass or mixin to provide actions specific to a given service.  For "
"example, the :class:`ForkingMixIn` class uses :meth:`service_actions` to "
"clean up zombie child processes."
msgstr ""
"Manipula solicitações até uma solicitação explícita :meth:`shutdown`. Sonda "
"para desligamento a cada *poll_interval* segundos. Ignora o atributo :attr:"
"`timeout`. Ele também chama :meth:`service_actions`, que pode ser usado por "
"uma subclasse ou mixin para fornecer ações específicas para um determinado "
"serviço. Por exemplo, a classe :class:`ForkingMixIn` usa :meth:"
"`service_actions` para limpar processos filhos zumbis."

#: ../../library/socketserver.rst:224
msgid "Added ``service_actions`` call to the ``serve_forever`` method."
msgstr "Adicionada chamada ``service_actions`` ao método ``serve_forever``."

#: ../../library/socketserver.rst:230
msgid ""
"This is called in the :meth:`serve_forever` loop. This method can be "
"overridden by subclasses or mixin classes to perform actions specific to a "
"given service, such as cleanup actions."
msgstr ""
"Isso é chamado no laço :meth:`serve_forever`. Este método pode ser "
"substituído por subclasses ou classes mixin para executar ações específicas "
"para um determinado serviço, como ações de limpeza."

#: ../../library/socketserver.rst:238
msgid ""
"Tell the :meth:`serve_forever` loop to stop and wait until it does. :meth:"
"`shutdown` must be called while :meth:`serve_forever` is running in a "
"different thread otherwise it will deadlock."
msgstr ""
"Diz ao laço :meth:`serve_forever` para parar e esperar até que isso "
"aconteça. :meth:`shutdown` deve ser chamado enquanto :meth:`serve_forever` "
"estiver em execução em um thread diferente, caso contrário, ocorrerá um "
"impasse."

#: ../../library/socketserver.rst:245
msgid "Clean up the server. May be overridden."
msgstr "Limpa o servidor. Pode ser substituído."

#: ../../library/socketserver.rst:250
msgid ""
"The family of protocols to which the server's socket belongs. Common "
"examples are :const:`socket.AF_INET` and :const:`socket.AF_UNIX`."
msgstr ""

#: ../../library/socketserver.rst:256
msgid ""
"The user-provided request handler class; an instance of this class is "
"created for each request."
msgstr ""
"A classe de manipulador de solicitações fornecida pelo usuário; uma "
"instância dessa classe é criada para cada solicitação."

#: ../../library/socketserver.rst:262
msgid ""
"The address on which the server is listening.  The format of addresses "
"varies depending on the protocol family; see the documentation for the :mod:"
"`socket` module for details.  For internet protocols, this is a tuple "
"containing a string giving the address, and an integer port number: "
"``('127.0.0.1', 80)``, for example."
msgstr ""
"O endereço no qual o servidor está escutando. O formato dos endereços varia "
"dependendo da família do protocolo; veja a documentação do módulo :mod:"
"`socket` para detalhes. Para protocolos de internet, esta é uma tupla "
"contendo uma string dando o endereço e um número de porta inteiro: "
"``('127.0.0.1', 80)``, por exemplo."

#: ../../library/socketserver.rst:271
msgid ""
"The socket object on which the server will listen for incoming requests."
msgstr "O objeto soquete no qual o servidor ouve para solicitações recebidas."

#: ../../library/socketserver.rst:274
msgid "The server classes support the following class variables:"
msgstr ""
"As classes de servidor oferecem suporte às seguintes variáveis de classe:"

#: ../../library/socketserver.rst:280
msgid ""
"Whether the server will allow the reuse of an address.  This defaults to :"
"const:`False`, and can be set in subclasses to change the policy."
msgstr ""
"Se o servidor permitirá a reutilização de um endereço. O padrão é :const:"
"`False`, e pode ser definido em subclasses para alterar a política."

#: ../../library/socketserver.rst:286
msgid ""
"The size of the request queue.  If it takes a long time to process a single "
"request, any requests that arrive while the server is busy are placed into a "
"queue, up to :attr:`request_queue_size` requests.  Once the queue is full, "
"further requests from clients will get a \"Connection denied\" error.  The "
"default value is usually 5, but this can be overridden by subclasses."
msgstr ""
"O tamanho da fila de requisições. Se levar muito tempo para processar uma "
"única requisição, todas as requisições que chegarem enquanto o servidor "
"estiver ocupado serão colocadas em uma fila, até :attr:`request_queue_size` "
"requisições. Quando a fila estiver cheia, outras requisições de clientes "
"receberão um erro \"Conexão negada\". O valor padrão é geralmente 5, mas "
"isso pode ser substituído por subclasses."

#: ../../library/socketserver.rst:295
msgid ""
"The type of socket used by the server; :const:`socket.SOCK_STREAM` and :"
"const:`socket.SOCK_DGRAM` are two common values."
msgstr ""
"O tipo de soquete usado pelo servidor; :const:`socket.SOCK_STREAM` e :const:"
"`socket.SOCK_DGRAM` são dois valores comuns."

#: ../../library/socketserver.rst:301
msgid ""
"Timeout duration, measured in seconds, or :const:`None` if no timeout is "
"desired.  If :meth:`handle_request` receives no incoming requests within the "
"timeout period, the :meth:`handle_timeout` method is called."
msgstr ""
"Duração do tempo limite, medida em segundos, ou :const:`None` se nenhum "
"tempo limite for desejado. Se :meth:`handle_request` não receber nenhuma "
"requisição de entrada dentro do período de tempo limite, o método :meth:"
"`handle_timeout` será chamado."

#: ../../library/socketserver.rst:306
msgid ""
"There are various server methods that can be overridden by subclasses of "
"base server classes like :class:`TCPServer`; these methods aren't useful to "
"external users of the server object."
msgstr ""
"Existem vários métodos de servidor que podem ser substituídos por subclasses "
"de classes de servidor base, como :class:`TCPServer`; esses métodos não são "
"úteis para usuários externos do objeto de servidor."

#: ../../library/socketserver.rst:315
msgid ""
"Actually processes the request by instantiating :attr:`RequestHandlerClass` "
"and calling its :meth:`~BaseRequestHandler.handle` method."
msgstr ""
"Na verdade, processa a solicitação instanciando :attr:`RequestHandlerClass` "
"e chamando seu método :meth:`~BaseRequestHandler.handle`."

#: ../../library/socketserver.rst:321
msgid ""
"Must accept a request from the socket, and return a 2-tuple containing the "
"*new* socket object to be used to communicate with the client, and the "
"client's address."
msgstr ""
"Deve aceitar uma solicitação do soquete e retornar uma tupla de 2 elementos "
"contendo o *novo* objeto de soquete a ser usado para se comunicar com o "
"cliente e o endereço do cliente."

#: ../../library/socketserver.rst:328
msgid ""
"This function is called if the :meth:`~BaseRequestHandler.handle` method of "
"a :attr:`RequestHandlerClass` instance raises an exception.  The default "
"action is to print the traceback to standard error and continue handling "
"further requests."
msgstr ""
"Esta função é chamada se o método :meth:`~BaseRequestHandler.handle` de uma "
"instância :attr:`RequestHandlerClass` levanta uma exceção. A ação padrão é "
"exibir o traceback para erro padrão e continuar manipulando solicitações "
"futuras."

#: ../../library/socketserver.rst:333
msgid "Now only called for exceptions derived from the :exc:`Exception` class."
msgstr ""
"Agora é chamada apenas para exceções derivadas da classe :exc:`Exception`."

#: ../../library/socketserver.rst:340
msgid ""
"This function is called when the :attr:`timeout` attribute has been set to a "
"value other than :const:`None` and the timeout period has passed with no "
"requests being received.  The default action for forking servers is to "
"collect the status of any child processes that have exited, while in "
"threading servers this method does nothing."
msgstr ""
"Esta função é chamada quando o atributo :attr:`timeout` foi definido para um "
"valor diferente de :const:`None` e o período de timeout passou sem que "
"nenhuma solicitação tenha sido recebida. A ação padrão para servidores de "
"bifurcação é coletar o status de quaisquer processos filhos que tenham "
"saído, enquanto em servidores de threading esse método não faz nada."

#: ../../library/socketserver.rst:349
msgid ""
"Calls :meth:`finish_request` to create an instance of the :attr:"
"`RequestHandlerClass`.  If desired, this function can create a new process "
"or thread to handle the request; the :class:`ForkingMixIn` and :class:"
"`ThreadingMixIn` classes do this."
msgstr ""
"Chama :meth:`finish_request` para criar uma instância de :attr:"
"`RequestHandlerClass`. Se desejado, esta função pode criar um novo processo "
"ou thread para manipular a solicitação; as classes :class:`ForkingMixIn` e :"
"class:`ThreadingMixIn` fazem isso."

#: ../../library/socketserver.rst:361
msgid ""
"Called by the server's constructor to activate the server.  The default "
"behavior for a TCP server just invokes :meth:`~socket.socket.listen` on the "
"server's socket.  May be overridden."
msgstr ""
"Chamado pelo construtor do servidor para ativar o servidor. O comportamento "
"padrão para um servidor TCP apenas invoca :meth:`~socket.socket.listen` no "
"soquete do servidor. Pode ser substituído."

#: ../../library/socketserver.rst:368
msgid ""
"Called by the server's constructor to bind the socket to the desired "
"address. May be overridden."
msgstr ""
"Chamada pelo construtor do servidor para vincular o soquete ao endereço "
"desejado. Pode ser substituída."

#: ../../library/socketserver.rst:374
msgid ""
"Must return a Boolean value; if the value is :const:`True`, the request will "
"be processed, and if it's :const:`False`, the request will be denied.  This "
"function can be overridden to implement access controls for a server. The "
"default implementation always returns :const:`True`."
msgstr ""
"Deve retornar um valor booleano; se o valor for :const:`True`, a solicitação "
"será processada, e se for :const:`False`, a solicitação será negada. Esta "
"função pode ser substituída para implementar controles de acesso para um "
"servidor. A implementação padrão sempre retorna :const:`True`."

#: ../../library/socketserver.rst:380
msgid ""
"Support for the :term:`context manager` protocol was added.  Exiting the "
"context manager is equivalent to calling :meth:`server_close`."
msgstr ""
"Foi adicionado suporte para o protocolo :term:`gerenciador de contexto`. "
"Sair do gerenciador de contexto é equivalente a chamar :meth:`server_close`."

#: ../../library/socketserver.rst:386
msgid "Request Handler Objects"
msgstr "Objetos manipulador de requisições"

#: ../../library/socketserver.rst:390
msgid ""
"This is the superclass of all request handler objects.  It defines the "
"interface, given below.  A concrete request handler subclass must define a "
"new :meth:`handle` method, and can override any of the other methods.  A new "
"instance of the subclass is created for each request."
msgstr ""
"Esta é a superclasse de todos os objetos manipulador de requisições. Ela "
"define a interface, dada abaixo. Uma subclasse concreta do manipulador de "
"requisições deve definir um novo método :meth:`handle` e pode substituir "
"qualquer um dos outros métodos. Uma nova instância da subclasse é criada "
"para cada requisição."

#: ../../library/socketserver.rst:399
msgid ""
"Called before the :meth:`handle` method to perform any initialization "
"actions required.  The default implementation does nothing."
msgstr ""
"Chamada antes do método :meth:`handle` para executar quaisquer ações de "
"inicialização necessárias. A implementação padrão não faz nada."

#: ../../library/socketserver.rst:405
msgid ""
"This function must do all the work required to service a request.  The "
"default implementation does nothing.  Several instance attributes are "
"available to it; the request is available as :attr:`self.request`; the "
"client address as :attr:`self.client_address`; and the server instance as :"
"attr:`self.server`, in case it needs access to per-server information."
msgstr ""

#: ../../library/socketserver.rst:411
msgid ""
"The type of :attr:`self.request` is different for datagram or stream "
"services.  For stream services, :attr:`self.request` is a socket object; for "
"datagram services, :attr:`self.request` is a pair of string and socket."
msgstr ""

#: ../../library/socketserver.rst:418
msgid ""
"Called after the :meth:`handle` method to perform any clean-up actions "
"required.  The default implementation does nothing.  If :meth:`setup` raises "
"an exception, this function will not be called."
msgstr ""
"Chamada após o método :meth:`handle` para executar quaisquer ações de "
"limpeza necessárias. A implementação padrão não faz nada. Se :meth:`setup` "
"levanta uma exceção, esta função não será chamada."

#: ../../library/socketserver.rst:426
msgid ""
"These :class:`BaseRequestHandler` subclasses override the :meth:"
"`~BaseRequestHandler.setup` and :meth:`~BaseRequestHandler.finish` methods, "
"and provide :attr:`self.rfile` and :attr:`self.wfile` attributes. The :attr:"
"`self.rfile` and :attr:`self.wfile` attributes can be read or written, "
"respectively, to get the request data or return data to the client. The :"
"attr:`!rfile` attributes support the :class:`io.BufferedIOBase` readable "
"interface, and :attr:`!wfile` attributes support the :class:`!io."
"BufferedIOBase` writable interface."
msgstr ""

#: ../../library/socketserver.rst:435
msgid ""
":attr:`StreamRequestHandler.wfile` also supports the :class:`io."
"BufferedIOBase` writable interface."
msgstr ""

#: ../../library/socketserver.rst:441
msgid "Examples"
msgstr "Exemplos"

#: ../../library/socketserver.rst:444
msgid ":class:`socketserver.TCPServer` Example"
msgstr "Exemplo de :class:`socketserver.TCPServer`"

#: ../../library/socketserver.rst:446 ../../library/socketserver.rst:545
msgid "This is the server side::"
msgstr "Este é o lado do servidor::"

#: ../../library/socketserver.rst:476
msgid ""
"An alternative request handler class that makes use of streams (file-like "
"objects that simplify communication by providing the standard file "
"interface)::"
msgstr ""
"Uma classe de manipulador de solicitações alternativa que faz uso de fluxos "
"(objetos arquivo ou similar que simplificam a comunicação ao fornecer a "
"interface de arquivo padrão)::"

#: ../../library/socketserver.rst:491
msgid ""
"The difference is that the ``readline()`` call in the second handler will "
"call ``recv()`` multiple times until it encounters a newline character, "
"while the single ``recv()`` call in the first handler will just return what "
"has been sent from the client in one ``sendall()`` call."
msgstr ""

#: ../../library/socketserver.rst:497 ../../library/socketserver.rst:569
msgid "This is the client side::"
msgstr "Este é o lado do cliente::"

#: ../../library/socketserver.rst:518 ../../library/socketserver.rst:644
msgid "The output of the example should look something like this:"
msgstr "A saída do exemplo deve se parecer com algo como isso:"

#: ../../library/socketserver.rst:520
msgid "Server:"
msgstr "Servidor:"

#: ../../library/socketserver.rst:530
msgid "Client:"
msgstr "Cliente:"

#: ../../library/socketserver.rst:543
msgid ":class:`socketserver.UDPServer` Example"
msgstr "Exemplo :class:`socketserver.UDPServer`"

#: ../../library/socketserver.rst:588
msgid ""
"The output of the example should look exactly like for the TCP server "
"example."
msgstr ""
"A saída do exemplo deve ser exatamente igual à do exemplo do servidor TCP."

#: ../../library/socketserver.rst:592
msgid "Asynchronous Mixins"
msgstr "Mixins assíncronos"

#: ../../library/socketserver.rst:594
msgid ""
"To build asynchronous handlers, use the :class:`ThreadingMixIn` and :class:"
"`ForkingMixIn` classes."
msgstr ""
"Para construir manipuladores assíncronos, use as classes :class:"
"`ThreadingMixIn` e :class:`ForkingMixIn`."

#: ../../library/socketserver.rst:597
msgid "An example for the :class:`ThreadingMixIn` class::"
msgstr "Um exemplo para a classe :class:`ThreadingMixIn`::"

#: ../../library/socketserver.rst:655
msgid ""
"The :class:`ForkingMixIn` class is used in the same way, except that the "
"server will spawn a new process for each request. Available only on POSIX "
"platforms that support :func:`~os.fork`."
msgstr ""
"A classe :class:`ForkingMixIn` é usada da mesma forma, exceto que o servidor "
"gerará um novo processo para cada solicitação. Disponível apenas em "
"plataformas POSIX que oferecem suporte a :func:`~os.fork`."

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Marco Rougeth <marco@rougeth.com>, 2021
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2021
# Italo Penaforte <italo.penaforte@gmail.com>, 2021
# And Past <andrepgs@gmail.com>, 2021
# Leticia Portella <leportella@gmail.com>, 2023
# Pedro Fonini, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-08 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 01:10+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/optparse.rst:2
msgid ":mod:`!optparse` --- Parser for command line options"
msgstr ""
":mod:`!optparse` --- Analisador sintático para opções de linha de comando"

#: ../../library/optparse.rst:11
msgid "**Source code:** :source:`Lib/optparse.py`"
msgstr "**Código-fonte:** :source:`Lib/optparse.py`"

#: ../../library/optparse.rst:13
msgid ""
"The :mod:`optparse` module is :term:`soft deprecated` and will not be "
"developed further; development will continue with the :mod:`argparse` module."
msgstr ""
"O módulo :mod:`optparse` está :term:`suavemente descontinuado` e não será "
"mais desenvolvido; o desenvolvimento continuará com o módulo :mod:`argparse`."

#: ../../library/optparse.rst:20
msgid ""
":mod:`optparse` is a more convenient, flexible, and powerful library for "
"parsing command-line options than the old :mod:`getopt` module.  :mod:"
"`optparse` uses a more declarative style of command-line parsing: you create "
"an instance of :class:`OptionParser`, populate it with options, and parse "
"the command line. :mod:`optparse` allows users to specify options in the "
"conventional GNU/POSIX syntax, and additionally generates usage and help "
"messages for you."
msgstr ""
":mod:`optparse` é uma biblioteca mais conveniente, flexível e poderosa para "
"analisar opções de linha de comando do que o antigo módulo :mod:`getopt`. :"
"mod:`optparse` usa um estilo mais declarativo de análise de linha de "
"comando: você cria uma instância de :class:`OptionParser`, preenche-a com "
"opções e analisa a linha de comando. :mod:`optparse` permite que os usuários "
"especifiquem opções na sintaxe convencional GNU/POSIX e, adicionalmente, "
"gera mensagens de uso e ajuda para você."

#: ../../library/optparse.rst:27
msgid "Here's an example of using :mod:`optparse` in a simple script::"
msgstr "Aqui está um exemplo de uso de :mod:`optparse` em um script simples::"

#: ../../library/optparse.rst:29
msgid ""
"from optparse import OptionParser\n"
"...\n"
"parser = OptionParser()\n"
"parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n"
"                  help=\"write report to FILE\", metavar=\"FILE\")\n"
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_false\", dest=\"verbose\", default=True,\n"
"                  help=\"don't print status messages to stdout\")\n"
"\n"
"(options, args) = parser.parse_args()"
msgstr ""
"from optparse import OptionParser\n"
"...\n"
"parser = OptionParser()\n"
"parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n"
"                  help=\"write report to FILE\", metavar=\"FILE\")\n"
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_false\", dest=\"verbose\", default=True,\n"
"                  help=\"don't print status messages to stdout\")\n"
"\n"
"(options, args) = parser.parse_args()"

#: ../../library/optparse.rst:40
msgid ""
"With these few lines of code, users of your script can now do the \"usual "
"thing\" on the command-line, for example::"
msgstr ""
"Com essas poucas linhas de código, os usuários do seu script agora podem "
"fazer \"coisas comuns\" na linha de comando, por exemplo:"

#: ../../library/optparse.rst:43
msgid "<yourscript> --file=outfile -q"
msgstr "<seuscript> --file=outfile -q"

#: ../../library/optparse.rst:45
msgid ""
"As it parses the command line, :mod:`optparse` sets attributes of the "
"``options`` object returned by :meth:`~OptionParser.parse_args` based on "
"user-supplied command-line values.  When :meth:`~OptionParser.parse_args` "
"returns from parsing this command line, ``options.filename`` will be "
"``\"outfile\"`` and ``options.verbose`` will be ``False``.  :mod:`optparse` "
"supports both long and short options, allows short options to be merged "
"together, and allows options to be associated with their arguments in a "
"variety of ways.  Thus, the following command lines are all equivalent to "
"the above example::"
msgstr ""
"Ao analisar a linha de comando, :mod:`optparse` define atributos do objeto "
"``options`` retornado por :meth:`~OptionParser.parse_args` com base nos "
"valores de linha de comando fornecidos pelo usuário. Quando :meth:"
"`~OptionParser.parse_args` retorna da análise desta linha de comando, "
"``options.filename`` será ``\"outfile\"`` e ``options.verbose`` será "
"``False``. :mod:`optparse` provê as opções longas e curtas, permite que "
"opções curtas sejam mescladas e permite que opções sejam associadas a seus "
"argumentos de várias maneiras. Portanto, as seguintes linhas de comando são "
"todas equivalentes ao exemplo acima::"

#: ../../library/optparse.rst:54
msgid ""
"<yourscript> -f outfile --quiet\n"
"<yourscript> --quiet --file outfile\n"
"<yourscript> -q -foutfile\n"
"<yourscript> -qfoutfile"
msgstr ""
"<seuscript> -f outfile --quiet\n"
"<seuscript> --quiet --file outfile\n"
"<seuscript> -q -foutfile\n"
"<seuscript> -qfoutfile"

#: ../../library/optparse.rst:59
msgid "Additionally, users can run one of the following ::"
msgstr "Além disso, os usuários podem executar um dos seguintes:"

#: ../../library/optparse.rst:61
msgid ""
"<yourscript> -h\n"
"<yourscript> --help"
msgstr ""
"<seuscript> -h\n"
"<seuscript> --help"

#: ../../library/optparse.rst:64
msgid ""
"and :mod:`optparse` will print out a brief summary of your script's options:"
msgstr "e :mod:`optparse` vai exibir um breve resumo das opções do seu script:"

#: ../../library/optparse.rst:66
msgid ""
"Usage: <yourscript> [options]\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -f FILE, --file=FILE  write report to FILE\n"
"  -q, --quiet           don't print status messages to stdout"
msgstr ""
"Usage: <seuscript> [options]\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -f FILE, --file=FILE  write report to FILE\n"
"  -q, --quiet           don't print status messages to stdout"

#: ../../library/optparse.rst:75
msgid ""
"where the value of *yourscript* is determined at runtime (normally from "
"``sys.argv[0]``)."
msgstr ""
"onde o valor de *seuscript* é determinado em tempo de execução (normalmente "
"de ``sys.argv[0]``)."

#: ../../library/optparse.rst:82
msgid "Background"
msgstr "Contexto"

#: ../../library/optparse.rst:84
msgid ""
":mod:`optparse` was explicitly designed to encourage the creation of "
"programs with straightforward, conventional command-line interfaces.  To "
"that end, it supports only the most common command-line syntax and semantics "
"conventionally used under Unix.  If you are unfamiliar with these "
"conventions, read this section to acquaint yourself with them."
msgstr ""
":mod:`optparse` foi explicitamente projetado para encorajar a criação de "
"programas com interfaces de linha de comando diretas e convencionais. Para "
"esse fim, ele provê apenas a sintaxe e a semântica de linha de comando mais "
"comuns convencionalmente usadas no Unix. Se você não estiver familiarizado "
"com essas convenções, leia esta seção para se familiarizar com elas."

#: ../../library/optparse.rst:94
msgid "Terminology"
msgstr "Terminologia"

#: ../../library/optparse.rst:96
msgid "argument"
msgstr "argumento"

#: ../../library/optparse.rst:97
msgid ""
"a string entered on the command-line, and passed by the shell to ``execl()`` "
"or ``execv()``.  In Python, arguments are elements of ``sys.argv[1:]`` "
"(``sys.argv[0]`` is the name of the program being executed).  Unix shells "
"also use the term \"word\"."
msgstr ""
"uma string inserida na linha de comando e passada pelo shell para "
"``execl()`` ou ``execv()``. Em Python, argumentos são elementos de ``sys."
"argv[1:]`` (``sys.argv[0]`` é o nome do programa que está sendo executado). "
"Shells Unix também usam o termo \"word\"."

#: ../../library/optparse.rst:102
msgid ""
"It is occasionally desirable to substitute an argument list other than ``sys."
"argv[1:]``, so you should read \"argument\" as \"an element of ``sys."
"argv[1:]``, or of some other list provided as a substitute for ``sys."
"argv[1:]``\"."
msgstr ""
"Ocasionalmente, é desejável substituir uma lista de argumentos diferente de "
"``sys.argv[1:]``, então você deve ler \"argumento\" como \"um elemento de "
"``sys.argv[1:]``, ou de alguma outra lista fornecida como um substituto para "
"``sys.argv[1:]``\"."

#: ../../library/optparse.rst:107
msgid "option"
msgstr "opção"

#: ../../library/optparse.rst:108
msgid ""
"an argument used to supply extra information to guide or customize the "
"execution of a program.  There are many different syntaxes for options; the "
"traditional Unix syntax is a hyphen (\"-\") followed by a single letter, e."
"g. ``-x`` or ``-F``.  Also, traditional Unix syntax allows multiple options "
"to be merged into a single argument, e.g. ``-x -F`` is equivalent to ``-"
"xF``.  The GNU project introduced ``--`` followed by a series of hyphen-"
"separated words, e.g. ``--file`` or ``--dry-run``.  These are the only two "
"option syntaxes provided by :mod:`optparse`."
msgstr ""
"um argumento usado para fornecer informações extras para guiar ou "
"personalizar a execução de um programa. Existem muitas sintaxes diferentes "
"para opções; a sintaxe tradicional do Unix é um hífen (\"-\") seguido por "
"uma única letra, por exemplo, ``-x`` ou ``-F``. Além disso, a sintaxe "
"tradicional do Unix permite que várias opções sejam mescladas em um único "
"argumento, por exemplo, ``-x -F`` é equivalente a ``-xF``. O projeto GNU "
"introduziu ``--`` seguido por uma série de palavras separadas por hífen, por "
"exemplo, ``--file`` ou ``--dry-run``. Essas são as únicas duas sintaxes de "
"opção fornecidas por :mod:`optparse`."

#: ../../library/optparse.rst:117
msgid "Some other option syntaxes that the world has seen include:"
msgstr "Algumas outras sintaxes de opções que o mundo viu incluem:"

#: ../../library/optparse.rst:119
msgid ""
"a hyphen followed by a few letters, e.g. ``-pf`` (this is *not* the same as "
"multiple options merged into a single argument)"
msgstr ""
"um hífen seguido por algumas letras, por exemplo ``-pf`` (isso *não* é o "
"mesmo que várias opções mescladas em um único argumento)"

#: ../../library/optparse.rst:122
msgid ""
"a hyphen followed by a whole word, e.g. ``-file`` (this is technically "
"equivalent to the previous syntax, but they aren't usually seen in the same "
"program)"
msgstr ""
"um hífen seguido por uma palavra completa, por exemplo ``-file`` (isso é "
"tecnicamente equivalente à sintaxe anterior, mas eles geralmente não são "
"vistos no mesmo programa)"

#: ../../library/optparse.rst:126
msgid ""
"a plus sign followed by a single letter, or a few letters, or a word, e.g. "
"``+f``, ``+rgb``"
msgstr ""
"um sinal de mais seguido por uma única letra, ou algumas letras, ou uma "
"palavra, por exemplo ``+f``, ``+rgb``"

#: ../../library/optparse.rst:129
msgid ""
"a slash followed by a letter, or a few letters, or a word, e.g. ``/f``, ``/"
"file``"
msgstr ""
"uma barra seguida de uma letra, ou algumas letras, ou uma palavra, por "
"exemplo ``/f``, ``/file``"

#: ../../library/optparse.rst:132
msgid ""
"These option syntaxes are not supported by :mod:`optparse`, and they never "
"will be.  This is deliberate: the first three are non-standard on any "
"environment, and the last only makes sense if you're exclusively targeting "
"Windows or certain legacy platforms (e.g. VMS, MS-DOS)."
msgstr ""
"Essas sintaxes de opção não são suportadas por :mod:`optparse`, e nunca "
"serão. Isso é proposital: as três primeiras não são padrão em nenhum "
"ambiente, e a última só faz sentido se você estiver mirando exclusivamente "
"no Windows ou em certas plataformas legadas (por exemplo, VMS, MS-DOS)."

#: ../../library/optparse.rst:137
msgid "option argument"
msgstr "argumento de opção"

#: ../../library/optparse.rst:138
msgid ""
"an argument that follows an option, is closely associated with that option, "
"and is consumed from the argument list when that option is. With :mod:"
"`optparse`, option arguments may either be in a separate argument from their "
"option:"
msgstr ""
"um argumento que segue uma opção, está intimamente associado a essa opção e "
"é consumido da lista de argumentos quando essa opção é. Com :mod:`optparse`, "
"os argumentos de opção podem estar em um argumento separado de sua opção:"

#: ../../library/optparse.rst:143
msgid ""
"-f foo\n"
"--file foo"
msgstr ""
"-f foo\n"
"--file foo"

#: ../../library/optparse.rst:148
msgid "or included in the same argument:"
msgstr "ou incluídos no mesmo argumento:"

#: ../../library/optparse.rst:150
msgid ""
"-ffoo\n"
"--file=foo"
msgstr ""
"-ffoo\n"
"--file=foo"

#: ../../library/optparse.rst:155
msgid ""
"Typically, a given option either takes an argument or it doesn't. Lots of "
"people want an \"optional option arguments\" feature, meaning that some "
"options will take an argument if they see it, and won't if they don't.  This "
"is somewhat controversial, because it makes parsing ambiguous: if ``-a`` "
"takes an optional argument and ``-b`` is another option entirely, how do we "
"interpret ``-ab``?  Because of this ambiguity, :mod:`optparse` does not "
"support this feature."
msgstr ""
"Normalmente, uma opção dada ou aceita um argumento ou não. Muitas pessoas "
"querem um recurso de \"argumentos opcionais de opção\", o que significa que "
"algumas opções aceitarão um argumento se o virem, e não aceitarão se não o "
"virem. Isso é um tanto controverso, porque torna a análise ambígua: se ``-"
"a`` aceita um argumento opcional e ``-b`` é outra opção inteiramente "
"diferente, como interpretamos ``-ab``? Por causa dessa ambiguidade, :mod:"
"`optparse` não provê esse recurso."

#: ../../library/optparse.rst:163
msgid "positional argument"
msgstr "argumento posicional"

#: ../../library/optparse.rst:164
msgid ""
"something leftover in the argument list after options have been parsed, i.e. "
"after options and their arguments have been parsed and removed from the "
"argument list."
msgstr ""
"algo que sobrou na lista de argumentos depois que as opções foram "
"analisadas, ou seja, depois que as opções e seus argumentos foram analisados ​​"
"e removidos da lista de argumentos."

#: ../../library/optparse.rst:168
msgid "required option"
msgstr "opção obrigatória"

#: ../../library/optparse.rst:169
msgid ""
"an option that must be supplied on the command-line; note that the phrase "
"\"required option\" is self-contradictory in English.  :mod:`optparse` "
"doesn't prevent you from implementing required options, but doesn't give you "
"much help at it either."
msgstr ""
"uma opção que deve ser fornecida na linha de comando; observe que a frase "
"\"opção obrigatória\" é autocontraditória em inglês. :mod:`optparse` não "
"impede que você implemente opções obrigatórias, mas também não ajuda muito "
"nisso."

#: ../../library/optparse.rst:174
msgid "For example, consider this hypothetical command-line::"
msgstr "Por exemplo, considere esta linha de comando hipotética:"

#: ../../library/optparse.rst:176
msgid "prog -v --report report.txt foo bar"
msgstr "prog -v --report report.txt foo bar"

#: ../../library/optparse.rst:178
msgid ""
"``-v`` and ``--report`` are both options.  Assuming that ``--report`` takes "
"one argument, ``report.txt`` is an option argument.  ``foo`` and ``bar`` are "
"positional arguments."
msgstr ""
"``-v`` e ``--report`` são ambas opções. Supondo que ``--report`` receba um "
"argumento, ``report.txt`` é um argumento de opção. ``foo`` e ``bar`` são "
"argumentos posicionais."

#: ../../library/optparse.rst:186
msgid "What are options for?"
msgstr "Para que servem as opções?"

#: ../../library/optparse.rst:188
msgid ""
"Options are used to provide extra information to tune or customize the "
"execution of a program.  In case it wasn't clear, options are usually "
"*optional*.  A program should be able to run just fine with no options "
"whatsoever.  (Pick a random program from the Unix or GNU toolsets.  Can it "
"run without any options at all and still make sense?  The main exceptions "
"are ``find``, ``tar``, and ``dd``\\ ---all of which are mutant oddballs that "
"have been rightly criticized for their non-standard syntax and confusing "
"interfaces.)"
msgstr ""
"As opções são usadas para fornecer informações extras para ajustar ou "
"personalizar a execução de um programa. Caso não tenha ficado claro, as "
"opções geralmente são *opcionais*. Um programa deve ser capaz de executar "
"muito bem sem nenhuma opção. (Escolha um programa aleatório dos conjuntos de "
"ferramentas Unix ou GNU. Ele pode ser executado sem nenhuma opção e ainda "
"fazer sentido? As principais exceções são ``find``, ``tar`` e ``dd`` --- "
"todos eles são mutantes excêntricos que foram corretamente criticados por "
"sua sintaxe não padrão e interfaces confusas.)"

#: ../../library/optparse.rst:196
msgid ""
"Lots of people want their programs to have \"required options\".  Think "
"about it. If it's required, then it's *not optional*!  If there is a piece "
"of information that your program absolutely requires in order to run "
"successfully, that's what positional arguments are for."
msgstr ""
"Muitas pessoas querem que seus programas tenham \"opções obrigatórias\". "
"Pense nisso. Se é obrigatório, então *não é opcional*! Se há uma informação "
"que seu programa absolutamente requer para ser executado com sucesso, é para "
"isso que servem os argumentos posicionais."

#: ../../library/optparse.rst:201
msgid ""
"As an example of good command-line interface design, consider the humble "
"``cp`` utility, for copying files.  It doesn't make much sense to try to "
"copy files without supplying a destination and at least one source. Hence, "
"``cp`` fails if you run it with no arguments.  However, it has a flexible, "
"useful syntax that does not require any options at all::"
msgstr ""
"Como um exemplo de bom design de interface de linha de comando, considere o "
"humilde utilitário ``cp``, para copiar arquivos. Não faz muito sentido "
"tentar copiar arquivos sem fornecer um destino e pelo menos uma fonte. "
"Portanto, ``cp`` falha se você executá-lo sem argumentos. No entanto, ele "
"tem uma sintaxe flexível e útil que não requer nenhuma opção::"

#: ../../library/optparse.rst:207
msgid ""
"cp SOURCE DEST\n"
"cp SOURCE ... DEST-DIR"
msgstr ""
"cp ORIGEM DESTINO\n"
"cp ORIGEM ... DIRETÓRIO"

#: ../../library/optparse.rst:210
msgid ""
"You can get pretty far with just that.  Most ``cp`` implementations provide "
"a bunch of options to tweak exactly how the files are copied: you can "
"preserve mode and modification time, avoid following symlinks, ask before "
"clobbering existing files, etc.  But none of this distracts from the core "
"mission of ``cp``, which is to copy either one file to another, or several "
"files to another directory."
msgstr ""
"Você pode ir bem longe só com isso. A maioria das implementações de ``cp`` "
"fornece um monte de opções para ajustar exatamente como os arquivos são "
"copiados: você pode preservar o modo e o tempo de modificação, evitar seguir "
"links simbólicos, perguntar antes de destruir arquivos existentes, etc. Mas "
"nada disso distrai da missão principal de ``cp``, que é copiar um arquivo "
"para outro, ou vários arquivos para outro diretório."

#: ../../library/optparse.rst:221
msgid "What are positional arguments for?"
msgstr "Para que servem os argumentos posicionais?"

#: ../../library/optparse.rst:223
msgid ""
"Positional arguments are for those pieces of information that your program "
"absolutely, positively requires to run."
msgstr ""
"Argumentos posicionais são para aquelas informações que seu programa "
"absolutamente e positivamente requer para ser executado."

#: ../../library/optparse.rst:226
msgid ""
"A good user interface should have as few absolute requirements as possible.  "
"If your program requires 17 distinct pieces of information in order to run "
"successfully, it doesn't much matter *how* you get that information from the "
"user---most people will give up and walk away before they successfully run "
"the program.  This applies whether the user interface is a command-line, a "
"configuration file, or a GUI: if you make that many demands on your users, "
"most of them will simply give up."
msgstr ""
"Uma boa interface de usuário deve ter o mínimo de requisitos absolutos "
"possível. Se seu programa requer 17 informações distintas para ser executado "
"com sucesso, não importa muito *como* você obtém essas informações do "
"usuário --- a maioria das pessoas desistirá e irá embora antes de executar o "
"programa com sucesso. Isso se aplica se a interface de usuário for uma linha "
"de comando, um arquivo de configuração ou uma GUI: se você fizer tantas "
"exigências aos seus usuários, a maioria deles simplesmente desistirá."

#: ../../library/optparse.rst:234
msgid ""
"In short, try to minimize the amount of information that users are "
"absolutely required to supply---use sensible defaults whenever possible.  Of "
"course, you also want to make your programs reasonably flexible.  That's "
"what options are for.  Again, it doesn't matter if they are entries in a "
"config file, widgets in the \"Preferences\" dialog of a GUI, or command-line "
"options---the more options you implement, the more flexible your program is, "
"and the more complicated its implementation becomes.  Too much flexibility "
"has drawbacks as well, of course; too many options can overwhelm users and "
"make your code much harder to maintain."
msgstr ""
"Em resumo, tente minimizar a quantidade de informações que os usuários são "
"absolutamente obrigados a fornecer --- use padrões sensatos sempre que "
"possível. Claro, você também quer tornar seus programas razoavelmente "
"flexíveis. É para isso que servem as opções. Novamente, não importa se são "
"entradas em um arquivo de configuração, widgets no diálogo \"Preferências\" "
"de uma GUI ou opções de linha de comando --- quanto mais opções você "
"implementar, mais flexível será seu programa e mais complicada se tornará "
"sua implementação. Muita flexibilidade também tem desvantagens, é claro; "
"muitas opções podem sobrecarregar os usuários e tornar seu código muito mais "
"difícil de manter."

#: ../../library/optparse.rst:247
msgid "Tutorial"
msgstr "Tutorial"

#: ../../library/optparse.rst:249
msgid ""
"While :mod:`optparse` is quite flexible and powerful, it's also "
"straightforward to use in most cases.  This section covers the code patterns "
"that are common to any :mod:`optparse`\\ -based program."
msgstr ""
"Embora :mod:`optparse` seja bastante flexível e poderoso, ele também é "
"simples de usar na maioria dos casos. Esta seção abrange os padrões de "
"código que são comuns a qualquer programa baseado em :mod:`optparse`."

#: ../../library/optparse.rst:253
msgid ""
"First, you need to import the OptionParser class; then, early in the main "
"program, create an OptionParser instance::"
msgstr ""
"Primeiro, você precisa importar a classe OptionParser; então, no início do "
"programa principal, crie uma instância de OptionParser::"

#: ../../library/optparse.rst:256
msgid ""
"from optparse import OptionParser\n"
"...\n"
"parser = OptionParser()"
msgstr ""
"from optparse import OptionParser\n"
"...\n"
"parser = OptionParser()"

#: ../../library/optparse.rst:260
msgid "Then you can start defining options.  The basic syntax is::"
msgstr "Então você pode começar a definir opções. A sintaxe básica é::"

#: ../../library/optparse.rst:262
msgid ""
"parser.add_option(opt_str, ...,\n"
"                  attr=value, ...)"
msgstr ""
"parser.add_option(opt_str, ...,\n"
"                  attr=value, ...)"

#: ../../library/optparse.rst:265
msgid ""
"Each option has one or more option strings, such as ``-f`` or ``--file``, "
"and several option attributes that tell :mod:`optparse` what to expect and "
"what to do when it encounters that option on the command line."
msgstr ""
"Cada opção tem uma ou mais strings de opção, como ``-f`` ou ``--file``, e "
"vários atributos de opção que informam ao :mod:`optparse` o que esperar e o "
"que fazer quando encontrar essa opção na linha de comando."

#: ../../library/optparse.rst:269
msgid ""
"Typically, each option will have one short option string and one long option "
"string, e.g.::"
msgstr ""
"Normalmente, cada opção terá uma sequência de opções curta e uma sequência "
"de opções longa, por exemplo::"

#: ../../library/optparse.rst:272
msgid "parser.add_option(\"-f\", \"--file\", ...)"
msgstr "parser.add_option(\"-f\", \"--file\", ...)"

#: ../../library/optparse.rst:274
msgid ""
"You're free to define as many short option strings and as many long option "
"strings as you like (including zero), as long as there is at least one "
"option string overall."
msgstr ""
"Você tem a liberdade de definir quantas strings de opções curtas e longas "
"quiser (incluindo zero), desde que haja pelo menos uma string de opção no "
"geral."

#: ../../library/optparse.rst:278
msgid ""
"The option strings passed to :meth:`OptionParser.add_option` are effectively "
"labels for the option defined by that call.  For brevity, we will frequently "
"refer to *encountering an option* on the command line; in reality, :mod:"
"`optparse` encounters *option strings* and looks up options from them."
msgstr ""
"As strings de opção passadas para :meth:`OptionParser.add_option` são "
"efetivamente rótulos para a opção definida por essa chamada. Para resumir, "
"frequentemente nos referiremos a *encontrar uma opção* na linha de comando; "
"na realidade, :mod:`optparse` encontra *strings de opção* e procura opções a "
"partir delas."

#: ../../library/optparse.rst:284
msgid ""
"Once all of your options are defined, instruct :mod:`optparse` to parse your "
"program's command line::"
msgstr ""
"Depois que todas as suas opções estiverem definidas, instrua :mod:`optparse` "
"para analisar a linha de comando do seu programa::"

#: ../../library/optparse.rst:287
msgid "(options, args) = parser.parse_args()"
msgstr "(options, args) = parser.parse_args()"

#: ../../library/optparse.rst:289
msgid ""
"(If you like, you can pass a custom argument list to :meth:`~OptionParser."
"parse_args`, but that's rarely necessary: by default it uses ``sys."
"argv[1:]``.)"
msgstr ""
"(Se desejar, você pode passar uma lista de argumentos personalizada para :"
"meth:`~OptionParser.parse_args`, mas isso raramente é necessário: por "
"padrão, ele usa ``sys.argv[1:]``.)"

#: ../../library/optparse.rst:292
msgid ":meth:`~OptionParser.parse_args` returns two values:"
msgstr ":meth:`~OptionParser.parse_args` retorna dois valores:"

#: ../../library/optparse.rst:294
msgid ""
"``options``, an object containing values for all of your options---e.g. if "
"``--file`` takes a single string argument, then ``options.file`` will be the "
"filename supplied by the user, or ``None`` if the user did not supply that "
"option"
msgstr ""
"``options``, um objeto que contém valores para todas as suas opções --- por "
"exemplo, se ``--file`` receber um único argumento de string, então ``options."
"file`` será o nome do arquivo fornecido pelo usuário, ou ``None`` se o "
"usuário não forneceu essa opção"

#: ../../library/optparse.rst:299
msgid ""
"``args``, the list of positional arguments leftover after parsing options"
msgstr ""
"``args``, a lista de argumentos posicionais restantes após a análise de "
"opções"

#: ../../library/optparse.rst:301
msgid ""
"This tutorial section only covers the four most important option "
"attributes: :attr:`~Option.action`, :attr:`~Option.type`, :attr:`~Option."
"dest` (destination), and :attr:`~Option.help`. Of these, :attr:`~Option."
"action` is the most fundamental."
msgstr ""
"Esta seção do tutorial abrange apenas os quatro atributos de opção mais "
"importantes: :attr:`~Option.action`, :attr:`~Option.type`, :attr:`~Option."
"dest` (destino) e :attr:`~Option.help`. Destes, :attr:`~Option.action` é o "
"mais fundamental."

#: ../../library/optparse.rst:310
msgid "Understanding option actions"
msgstr "Compreendendo as ações de opções"

#: ../../library/optparse.rst:312
msgid ""
"Actions tell :mod:`optparse` what to do when it encounters an option on the "
"command line.  There is a fixed set of actions hard-coded into :mod:"
"`optparse`; adding new actions is an advanced topic covered in section :ref:"
"`optparse-extending-optparse`.  Most actions tell :mod:`optparse` to store a "
"value in some variable---for example, take a string from the command line "
"and store it in an attribute of ``options``."
msgstr ""
"Ações dizem ao :mod:`optparse` o que fazer quando ele encontra uma opção na "
"linha de comando. Há um conjunto fixo de ações codificadas em :mod:"
"`optparse`; adicionar novas ações é um tópico avançado abordado na seção :"
"ref:`optparse-extending-optparse`. A maioria das ações diz ao :mod:"
"`optparse` para armazenar um valor em alguma variável --- por exemplo, pegue "
"uma string da linha de comando e armazene-a em um atributo de ``options``."

#: ../../library/optparse.rst:319
msgid ""
"If you don't specify an option action, :mod:`optparse` defaults to ``store``."
msgstr ""
"Se você não especificar uma ação de opção, :mod:`optparse` assumirá como "
"padrão ``store``."

#: ../../library/optparse.rst:325
msgid "The store action"
msgstr "A ação store"

#: ../../library/optparse.rst:327
msgid ""
"The most common option action is ``store``, which tells :mod:`optparse` to "
"take the next argument (or the remainder of the current argument), ensure "
"that it is of the correct type, and store it to your chosen destination."
msgstr ""
"A ação de opção mais comum é ``store``, que diz ao :mod:`optparse` para "
"pegar o próximo argumento (ou o restante do argumento atual), garantir que "
"seja do tipo correto e armazená-lo no destino escolhido."

#: ../../library/optparse.rst:331
msgid "For example::"
msgstr "Por exemplo::"

#: ../../library/optparse.rst:333
msgid ""
"parser.add_option(\"-f\", \"--file\",\n"
"                  action=\"store\", type=\"string\", dest=\"filename\")"
msgstr ""
"parser.add_option(\"-f\", \"--file\",\n"
"                  action=\"store\", type=\"string\", dest=\"filename\")"

#: ../../library/optparse.rst:336
msgid ""
"Now let's make up a fake command line and ask :mod:`optparse` to parse it::"
msgstr ""
"Agora vamos criar uma linha de comando falsa e pedir ao :mod:`optparse` para "
"analisá-la::"

#: ../../library/optparse.rst:338
msgid ""
"args = [\"-f\", \"foo.txt\"]\n"
"(options, args) = parser.parse_args(args)"
msgstr ""
"args = [\"-f\", \"foo.txt\"]\n"
"(options, args) = parser.parse_args(args)"

#: ../../library/optparse.rst:341
msgid ""
"When :mod:`optparse` sees the option string ``-f``, it consumes the next "
"argument, ``foo.txt``, and stores it in ``options.filename``.  So, after "
"this call to :meth:`~OptionParser.parse_args`, ``options.filename`` is "
"``\"foo.txt\"``."
msgstr ""
"Quando :mod:`optparse` vê a string de opção ``-f``, ele consome o próximo "
"argumento, ``foo.txt``, e o armazena em ``options.filename``. Então, após "
"essa chamada para :meth:`~OptionParser.parse_args`, ``options.filename`` é "
"``\"foo.txt\"``."

#: ../../library/optparse.rst:345
msgid ""
"Some other option types supported by :mod:`optparse` are ``int`` and "
"``float``. Here's an option that expects an integer argument::"
msgstr ""
"Alguns outros tipos de opção suportados por :mod:`optparse` são ``int`` e "
"``float``. Aqui está uma opção que espera um argumento inteiro::"

#: ../../library/optparse.rst:348
msgid "parser.add_option(\"-n\", type=\"int\", dest=\"num\")"
msgstr "parser.add_option(\"-n\", type=\"int\", dest=\"num\")"

#: ../../library/optparse.rst:350
msgid ""
"Note that this option has no long option string, which is perfectly "
"acceptable. Also, there's no explicit action, since the default is ``store``."
msgstr ""
"Note que esta opção não tem uma string de opção longa, o que é perfeitamente "
"aceitável. Além disso, não há nenhuma ação explícita, já que o padrão é "
"``store``."

#: ../../library/optparse.rst:353
msgid ""
"Let's parse another fake command-line.  This time, we'll jam the option "
"argument right up against the option: since ``-n42`` (one argument) is "
"equivalent to ``-n 42`` (two arguments), the code ::"
msgstr ""
"Vamos analisar outra linha de comando falsa. Desta vez, vamos colocar o "
"argumento de opção bem perto da opção: já que ``-n42`` (um argumento) "
"equivale a ``-n 42`` (dois argumentos), o código ::"

#: ../../library/optparse.rst:357
msgid ""
"(options, args) = parser.parse_args([\"-n42\"])\n"
"print(options.num)"
msgstr ""
"(options, args) = parser.parse_args([\"-n42\"])\n"
"print(options.num)"

#: ../../library/optparse.rst:360
msgid "will print ``42``."
msgstr "vai exibir ``42``."

#: ../../library/optparse.rst:362
msgid ""
"If you don't specify a type, :mod:`optparse` assumes ``string``.  Combined "
"with the fact that the default action is ``store``, that means our first "
"example can be a lot shorter::"
msgstr ""
"Se você não especificar um tipo, :mod:`optparse` presume ``string``. "
"Combinado com o fato de que a ação padrão é ``store``, isso significa que "
"nosso primeiro exemplo pode ser muito mais curto::"

#: ../../library/optparse.rst:366
msgid "parser.add_option(\"-f\", \"--file\", dest=\"filename\")"
msgstr "parser.add_option(\"-f\", \"--file\", dest=\"filename\")"

#: ../../library/optparse.rst:368
msgid ""
"If you don't supply a destination, :mod:`optparse` figures out a sensible "
"default from the option strings: if the first long option string is ``--foo-"
"bar``, then the default destination is ``foo_bar``.  If there are no long "
"option strings, :mod:`optparse` looks at the first short option string: the "
"default destination for ``-f`` is ``f``."
msgstr ""
"Se você não fornecer um destino, :mod:`optparse` descobre um padrão sensato "
"a partir das strings de opção: se a primeira string de opção longa for ``--"
"foo-bar``, então o destino padrão é ``foo_bar``. Se não houver strings de "
"opção longas, :mod:`optparse` olha para a primeira string de opção curta: o "
"destino padrão para ``-f`` é ``f``."

#: ../../library/optparse.rst:374
msgid ""
":mod:`optparse` also includes the built-in ``complex`` type.  Adding types "
"is covered in section :ref:`optparse-extending-optparse`."
msgstr ""
":mod:`optparse` também inclui o tipo ``complex`` embutido. Adicionar tipos é "
"abordado na seção :ref:`optparse-extending-optparse`."

#: ../../library/optparse.rst:381
msgid "Handling boolean (flag) options"
msgstr "Manipulando opções (sinalizadores) booleanas"

#: ../../library/optparse.rst:383
msgid ""
"Flag options---set a variable to true or false when a particular option is "
"seen---are quite common.  :mod:`optparse` supports them with two separate "
"actions, ``store_true`` and ``store_false``.  For example, you might have a "
"``verbose`` flag that is turned on with ``-v`` and off with ``-q``::"
msgstr ""
"Opções de sinalizador --- define uma variável como true ou false quando uma "
"opção específica é vista --- são bem comuns. :mod:`optparse` suporta-as com "
"duas ações separadas, ``store_true`` e ``store_false``. Por exemplo, você "
"pode ter um sinalizador ``verbose`` que é ativado com ``-v`` e desativado "
"com ``-q``::"

#: ../../library/optparse.rst:388
msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\")\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\")"
msgstr ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\")\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\")"

#: ../../library/optparse.rst:391
msgid ""
"Here we have two different options with the same destination, which is "
"perfectly OK.  (It just means you have to be a bit careful when setting "
"default values---see below.)"
msgstr ""
"Aqui temos duas opções diferentes com o mesmo destino, o que é perfeitamente "
"OK. (Isso significa apenas que você tem que ter um pouco de cuidado ao "
"definir valores padrão — veja abaixo.)"

#: ../../library/optparse.rst:395
msgid ""
"When :mod:`optparse` encounters ``-v`` on the command line, it sets "
"``options.verbose`` to ``True``; when it encounters ``-q``, ``options."
"verbose`` is set to ``False``."
msgstr ""
"Quando :mod:`optparse` encontra ``-v`` na linha de comando, ele define "
"``options.verbose`` como ``True``; quando encontra ``-q``, ``options."
"verbose`` é definido como ``False``."

#: ../../library/optparse.rst:403
msgid "Other actions"
msgstr "Outras ações"

#: ../../library/optparse.rst:405
msgid "Some other actions supported by :mod:`optparse` are:"
msgstr "Algumas outras ações suportadas por :mod:`optparse` são:"

#: ../../library/optparse.rst:407 ../../library/optparse.rst:929
msgid "``\"store_const\"``"
msgstr "``\"store_const\"``"

#: ../../library/optparse.rst:408 ../../library/optparse.rst:930
msgid "store a constant value, pre-set via :attr:`Option.const`"
msgstr "armazena um valor constante, predefinido via :attr:`Option.const`"

#: ../../library/optparse.rst:410 ../../library/optparse.rst:938
msgid "``\"append\"``"
msgstr "``\"append\"``"

#: ../../library/optparse.rst:411 ../../library/optparse.rst:939
msgid "append this option's argument to a list"
msgstr "anexa o argumento desta opção a uma lista"

#: ../../library/optparse.rst:413 ../../library/optparse.rst:944
msgid "``\"count\"``"
msgstr "``\"count\"``"

#: ../../library/optparse.rst:414 ../../library/optparse.rst:945
msgid "increment a counter by one"
msgstr "incrementa um contador em um"

#: ../../library/optparse.rst:416 ../../library/optparse.rst:947
msgid "``\"callback\"``"
msgstr "``\"callback\"``"

#: ../../library/optparse.rst:417 ../../library/optparse.rst:948
msgid "call a specified function"
msgstr "chama uma função especificada"

#: ../../library/optparse.rst:419
msgid ""
"These are covered in section :ref:`optparse-reference-guide`, and section :"
"ref:`optparse-option-callbacks`."
msgstr ""
"Elas são abordadas na seção :ref:`optparse-reference-guide` e na seção :ref:"
"`optparse-option-callbacks`."

#: ../../library/optparse.rst:426
msgid "Default values"
msgstr "Valores padrão"

#: ../../library/optparse.rst:428
msgid ""
"All of the above examples involve setting some variable (the "
"\"destination\") when certain command-line options are seen.  What happens "
"if those options are never seen?  Since we didn't supply any defaults, they "
"are all set to ``None``.  This is usually fine, but sometimes you want more "
"control.  :mod:`optparse` lets you supply a default value for each "
"destination, which is assigned before the command line is parsed."
msgstr ""
"Todos os exemplos acima envolvem a configuração de alguma variável (o "
"\"destino\") quando certas opções de linha de comando são vistas. O que "
"acontece se essas opções nunca forem vistas? Como não fornecemos nenhum "
"padrão, todas elas são definidas como ``None``. Isso geralmente é bom, mas "
"às vezes você quer mais controle. :mod:`optparse` permite que você forneça "
"um valor padrão para cada destino, que é atribuído antes da análise da linha "
"de comando."

#: ../../library/optparse.rst:435
msgid ""
"First, consider the verbose/quiet example.  If we want :mod:`optparse` to "
"set ``verbose`` to ``True`` unless ``-q`` is seen, then we can do this::"
msgstr ""
"Primeiro, considere o exemplo de verbose/quiet. Se quisermos que :mod:"
"`optparse` defina ``verbose`` como ``True`` a menos que ``-q`` seja visto, "
"então podemos fazer isso::"

#: ../../library/optparse.rst:438
msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\", "
"default=True)\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\")"
msgstr ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\", "
"default=True)\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\")"

#: ../../library/optparse.rst:441
msgid ""
"Since default values apply to the *destination* rather than to any "
"particular option, and these two options happen to have the same "
"destination, this is exactly equivalent::"
msgstr ""
"Como os valores padrão se aplicam ao *destino* e não a qualquer opção "
"específica, e essas duas opções têm o mesmo destino, isso é exatamente "
"equivalente::"

#: ../../library/optparse.rst:445
msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\")\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\", "
"default=True)"
msgstr ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\")\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\", "
"default=True)"

#: ../../library/optparse.rst:448
msgid "Consider this::"
msgstr "Considere isso::"

#: ../../library/optparse.rst:450
msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\", "
"default=False)\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\", "
"default=True)"
msgstr ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\", "
"default=False)\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\", "
"default=True)"

#: ../../library/optparse.rst:453
msgid ""
"Again, the default value for ``verbose`` will be ``True``: the last default "
"value supplied for any particular destination is the one that counts."
msgstr ""
"Novamente, o valor padrão para ``verbose`` será ``True``: o último valor "
"padrão fornecido para qualquer destino específico é o que conta."

#: ../../library/optparse.rst:456
msgid ""
"A clearer way to specify default values is the :meth:`set_defaults` method "
"of OptionParser, which you can call at any time before calling :meth:"
"`~OptionParser.parse_args`::"
msgstr ""
"Uma maneira mais clara de especificar valores padrão é o método :meth:"
"`set_defaults` do OptionParser, que você pode chamar a qualquer momento "
"antes de chamar :meth:`~OptionParser.parse_args`::"

#: ../../library/optparse.rst:460
msgid ""
"parser.set_defaults(verbose=True)\n"
"parser.add_option(...)\n"
"(options, args) = parser.parse_args()"
msgstr ""
"parser.set_defaults(verbose=True)\n"
"parser.add_option(...)\n"
"(options, args) = parser.parse_args()"

#: ../../library/optparse.rst:464
msgid ""
"As before, the last value specified for a given option destination is the "
"one that counts.  For clarity, try to use one method or the other of setting "
"default values, not both."
msgstr ""
"Como antes, o último valor especificado para um destino de opção dado é o "
"que conta. Para maior clareza, tente usar um método ou outro de configuração "
"de valores padrão, não ambos."

#: ../../library/optparse.rst:472
msgid "Generating help"
msgstr "Gerando texto de ajuda"

#: ../../library/optparse.rst:474
msgid ""
":mod:`optparse`'s ability to generate help and usage text automatically is "
"useful for creating user-friendly command-line interfaces.  All you have to "
"do is supply a :attr:`~Option.help` value for each option, and optionally a "
"short usage message for your whole program.  Here's an OptionParser "
"populated with user-friendly (documented) options::"
msgstr ""
"A capacidade do :mod:`optparse` de gerar texto de ajuda e uso "
"automaticamente é útil para criar interfaces de linha de comando amigáveis ​​"
"ao usuário. Tudo o que você precisa fazer é fornecer um valor :attr:`~Option."
"help` para cada opção e, opcionalmente, uma curta mensagem de uso para todo "
"o seu programa. Aqui está um OptionParser preenchido com opções amigáveis "
"(documentadas) ​​ao usuário::"

#: ../../library/optparse.rst:480
msgid ""
"usage = \"usage: %prog [options] arg1 arg2\"\n"
"parser = OptionParser(usage=usage)\n"
"parser.add_option(\"-v\", \"--verbose\",\n"
"                  action=\"store_true\", dest=\"verbose\", default=True,\n"
"                  help=\"make lots of noise [default]\")\n"
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_false\", dest=\"verbose\",\n"
"                  help=\"be vewwy quiet (I'm hunting wabbits)\")\n"
"parser.add_option(\"-f\", \"--filename\",\n"
"                  metavar=\"FILE\", help=\"write output to FILE\")\n"
"parser.add_option(\"-m\", \"--mode\",\n"
"                  default=\"intermediate\",\n"
"                  help=\"interaction mode: novice, intermediate, \"\n"
"                       \"or expert [default: %default]\")"
msgstr ""
"usage = \"usage: %prog [options] arg1 arg2\"\n"
"parser = OptionParser(usage=usage)\n"
"parser.add_option(\"-v\", \"--verbose\",\n"
"                  action=\"store_true\", dest=\"verbose\", default=True,\n"
"                  help=\"make lots of noise [default]\")\n"
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_false\", dest=\"verbose\",\n"
"                  help=\"be vewwy quiet (I'm hunting wabbits)\")\n"
"parser.add_option(\"-f\", \"--filename\",\n"
"                  metavar=\"FILE\", help=\"write output to FILE\")\n"
"parser.add_option(\"-m\", \"--mode\",\n"
"                  default=\"intermediate\",\n"
"                  help=\"interaction mode: novice, intermediate, \"\n"
"                       \"or expert [default: %default]\")"

#: ../../library/optparse.rst:495
msgid ""
"If :mod:`optparse` encounters either ``-h`` or ``--help`` on the command-"
"line, or if you just call :meth:`parser.print_help`, it prints the following "
"to standard output:"
msgstr ""
"Se :mod:`optparse` encontrar ``-h`` ou ``--help`` na linha de comando, ou se "
"você apenas chamar :meth:`parser.print_help`, ele exibe o seguinte na saída "
"padrão:"

#: ../../library/optparse.rst:499
msgid ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or\n"
"                        expert [default: intermediate]"
msgstr ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or\n"
"                        expert [default: intermediate]"

#: ../../library/optparse.rst:512
msgid ""
"(If the help output is triggered by a help option, :mod:`optparse` exits "
"after printing the help text.)"
msgstr ""
"(Se a saída de ajuda for acionada por uma opção de ajuda, :mod:`optparse` "
"sai após imprimir o texto de ajuda.)"

#: ../../library/optparse.rst:515
msgid ""
"There's a lot going on here to help :mod:`optparse` generate the best "
"possible help message:"
msgstr ""
"Há muita coisa acontecendo aqui para ajudar :mod:`optparse` a gerar a melhor "
"mensagem de ajuda possível:"

#: ../../library/optparse.rst:518
msgid "the script defines its own usage message::"
msgstr "o script define sua própria mensagem de uso::"

#: ../../library/optparse.rst:520
msgid "usage = \"usage: %prog [options] arg1 arg2\""
msgstr "usage = \"usage: %prog [options] arg1 arg2\""

#: ../../library/optparse.rst:522
msgid ""
":mod:`optparse` expands ``%prog`` in the usage string to the name of the "
"current program, i.e. ``os.path.basename(sys.argv[0])``.  The expanded "
"string is then printed before the detailed option help."
msgstr ""
":mod:`optparse` expande ``%prog`` na string de uso para o nome do programa "
"atual, ou seja, ``os.path.basename(sys.argv[0])``. A string expandida é "
"então exibida antes da ajuda detalhada da opção."

#: ../../library/optparse.rst:526
msgid ""
"If you don't supply a usage string, :mod:`optparse` uses a bland but "
"sensible default: ``\"Usage: %prog [options]\"``, which is fine if your "
"script doesn't take any positional arguments."
msgstr ""
"Se você não fornecer uma string de uso, :mod:`optparse` usa um padrão "
"simples, mas sensato: ``\"Usage: %prog [options]\"``, o que é bom se seu "
"script não aceita nenhum argumento posicional."

#: ../../library/optparse.rst:530
msgid ""
"every option defines a help string, and doesn't worry about line-wrapping---"
"\\ :mod:`optparse` takes care of wrapping lines and making the help output "
"look good."
msgstr ""
"cada opção define uma string de ajuda e não se preocupa com quebra de linha "
"--- :mod:`optparse` cuida da quebra de linhas e faz com que a saída de ajuda "
"tenha uma boa aparência."

#: ../../library/optparse.rst:534
msgid ""
"options that take a value indicate this fact in their automatically "
"generated help message, e.g. for the \"mode\" option::"
msgstr ""
"opções que assumem um valor indicam esse fato em sua mensagem de ajuda "
"gerada automaticamente, por exemplo, para a opção \"mode\"::"

#: ../../library/optparse.rst:537
msgid "-m MODE, --mode=MODE"
msgstr "-m MODE, --mode=MODE"

#: ../../library/optparse.rst:539
msgid ""
"Here, \"MODE\" is called the meta-variable: it stands for the argument that "
"the user is expected to supply to ``-m``/``--mode``.  By default, :mod:"
"`optparse` converts the destination variable name to uppercase and uses that "
"for the meta-variable.  Sometimes, that's not what you want---for example, "
"the ``--filename`` option explicitly sets ``metavar=\"FILE\"``, resulting in "
"this automatically generated option description::"
msgstr ""
"Aqui, \"MODE\" é chamado de metavariável: ele representa o argumento que o "
"usuário deve fornecer para ``-m``/``--mode``. Por padrão, :mod:`optparse` "
"converte o nome da variável de destino para maiúsculas e usa isso para a "
"metavariável. Às vezes, não é isso que você quer --- por exemplo, a opção "
"``--filename`` define explicitamente ``metavar=\"FILE\"``, resultando nesta "
"descrição de opção gerada automaticamente::"

#: ../../library/optparse.rst:546
msgid "-f FILE, --filename=FILE"
msgstr "-f FILE, --filename=FILE"

#: ../../library/optparse.rst:548
msgid ""
"This is important for more than just saving space, though: the manually "
"written help text uses the meta-variable ``FILE`` to clue the user in that "
"there's a connection between the semi-formal syntax ``-f FILE`` and the "
"informal semantic description \"write output to FILE\". This is a simple but "
"effective way to make your help text a lot clearer and more useful for end "
"users."
msgstr ""
"Isso é importante para mais do que apenas economizar espaço: o texto de "
"ajuda escrito manualmente usa a metavariável ``FILE`` para dar uma pista ao "
"usuário de que há uma conexão entre a sintaxe semiformal ``-f FILE`` e a "
"descrição semântica informal como, por exemplo, \"write output to FILE\". "
"Essa é uma maneira simples, mas eficaz, de tornar seu texto de ajuda muito "
"mais claro e útil para usuários finais."

#: ../../library/optparse.rst:554
msgid ""
"options that have a default value can include ``%default`` in the help "
"string---\\ :mod:`optparse` will replace it with :func:`str` of the option's "
"default value.  If an option has no default value (or the default value is "
"``None``), ``%default`` expands to ``none``."
msgstr ""
"opções que têm um valor padrão podem incluir ``%default`` na string de ajuda "
"--- :mod:`optparse` vai substituí-lo por :func:`str` do valor padrão da "
"opção. Se uma opção não tiver um valor padrão (ou o valor padrão for "
"``None``), ``%default`` expande para ``none``."

#: ../../library/optparse.rst:560
msgid "Grouping Options"
msgstr "Agrupando opções"

#: ../../library/optparse.rst:562
msgid ""
"When dealing with many options, it is convenient to group these options for "
"better help output.  An :class:`OptionParser` can contain several option "
"groups, each of which can contain several options."
msgstr ""
"Ao lidar com muitas opções, é conveniente agrupar essas opções para melhor "
"saída de ajuda. Um :class:`OptionParser` pode conter vários grupos de "
"opções, cada um dos quais pode conter várias opções."

#: ../../library/optparse.rst:566
msgid "An option group is obtained using the class :class:`OptionGroup`:"
msgstr "Um grupo de opções é obtido usando a classe :class:`OptionGroup`:"

#: ../../library/optparse.rst:570 ../../library/optparse.rst:1641
msgid "where"
msgstr "onde"

#: ../../library/optparse.rst:572
msgid ""
"parser is the :class:`OptionParser` instance the group will be inserted in to"
msgstr ""
"*parser* é a instância :class:`OptionParser` na qual o grupo será inserido"

#: ../../library/optparse.rst:574
msgid "title is the group title"
msgstr "*title* é o título do grupo"

#: ../../library/optparse.rst:575
msgid "description, optional, is a long description of the group"
msgstr "*description*, opcional, é uma descrição longa do grupo"

#: ../../library/optparse.rst:577
msgid ""
":class:`OptionGroup` inherits from :class:`OptionContainer` (like :class:"
"`OptionParser`) and so the :meth:`add_option` method can be used to add an "
"option to the group."
msgstr ""
":class:`OptionGroup` herda de :class:`OptionContainer` (como :class:"
"`OptionParser`) e, portanto, o método :meth:`add_option` pode ser usado para "
"adicionar uma opção ao grupo."

#: ../../library/optparse.rst:581
msgid ""
"Once all the options are declared, using the :class:`OptionParser` method :"
"meth:`add_option_group` the group is added to the previously defined parser."
msgstr ""
"Depois que todas as opções são declaradas, usando o método :class:"
"`OptionParser` :meth:`add_option_group` o grupo é adicionado ao analisador "
"definido anteriormente."

#: ../../library/optparse.rst:584
msgid ""
"Continuing with the parser defined in the previous section, adding an :class:"
"`OptionGroup` to a parser is easy::"
msgstr ""
"Continuando com o analisador definido na seção anterior, adicionar um :class:"
"`OptionGroup` a um analisador é fácil::"

#: ../../library/optparse.rst:587
msgid ""
"group = OptionGroup(parser, \"Dangerous Options\",\n"
"                    \"Caution: use these options at your own risk.  \"\n"
"                    \"It is believed that some of them bite.\")\n"
"group.add_option(\"-g\", action=\"store_true\", help=\"Group option.\")\n"
"parser.add_option_group(group)"
msgstr ""
"group = OptionGroup(parser, \"Dangerous Options\",\n"
"                    \"Caution: use these options at your own risk.  \"\n"
"                    \"It is believed that some of them bite.\")\n"
"group.add_option(\"-g\", action=\"store_true\", help=\"Group option.\")\n"
"parser.add_option_group(group)"

#: ../../library/optparse.rst:593
msgid "This would result in the following help output:"
msgstr "Isso resultaria na seguinte saída de texto de ajuda:"

#: ../../library/optparse.rst:595
msgid ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or\n"
"                        expert [default: intermediate]\n"
"\n"
"  Dangerous Options:\n"
"    Caution: use these options at your own risk.  It is believed that some\n"
"    of them bite.\n"
"\n"
"    -g                  Group option."
msgstr ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or\n"
"                        expert [default: intermediate]\n"
"\n"
"  Dangerous Options:\n"
"    Caution: use these options at your own risk.  It is believed that some\n"
"    of them bite.\n"
"\n"
"    -g                  Group option."

#: ../../library/optparse.rst:614
msgid ""
"A bit more complete example might involve using more than one group: still "
"extending the previous example::"
msgstr ""
"Um exemplo um pouco mais completo pode envolver o uso de mais de um grupo: "
"ainda estendendo o exemplo anterior::"

#: ../../library/optparse.rst:617
msgid ""
"group = OptionGroup(parser, \"Dangerous Options\",\n"
"                    \"Caution: use these options at your own risk.  \"\n"
"                    \"It is believed that some of them bite.\")\n"
"group.add_option(\"-g\", action=\"store_true\", help=\"Group option.\")\n"
"parser.add_option_group(group)\n"
"\n"
"group = OptionGroup(parser, \"Debug Options\")\n"
"group.add_option(\"-d\", \"--debug\", action=\"store_true\",\n"
"                 help=\"Print debug information\")\n"
"group.add_option(\"-s\", \"--sql\", action=\"store_true\",\n"
"                 help=\"Print all SQL statements executed\")\n"
"group.add_option(\"-e\", action=\"store_true\", help=\"Print every action "
"done\")\n"
"parser.add_option_group(group)"
msgstr ""
"group = OptionGroup(parser, \"Dangerous Options\",\n"
"                    \"Caution: use these options at your own risk.  \"\n"
"                    \"It is believed that some of them bite.\")\n"
"group.add_option(\"-g\", action=\"store_true\", help=\"Group option.\")\n"
"parser.add_option_group(group)\n"
"\n"
"group = OptionGroup(parser, \"Debug Options\")\n"
"group.add_option(\"-d\", \"--debug\", action=\"store_true\",\n"
"                 help=\"Print debug information\")\n"
"group.add_option(\"-s\", \"--sql\", action=\"store_true\",\n"
"                 help=\"Print all SQL statements executed\")\n"
"group.add_option(\"-e\", action=\"store_true\", help=\"Print every action "
"done\")\n"
"parser.add_option_group(group)"

#: ../../library/optparse.rst:631
msgid "that results in the following output:"
msgstr "que resulta na seguinte saída:"

#: ../../library/optparse.rst:633
msgid ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or expert\n"
"                        [default: intermediate]\n"
"\n"
"  Dangerous Options:\n"
"    Caution: use these options at your own risk.  It is believed that some\n"
"    of them bite.\n"
"\n"
"    -g                  Group option.\n"
"\n"
"  Debug Options:\n"
"    -d, --debug         Print debug information\n"
"    -s, --sql           Print all SQL statements executed\n"
"    -e                  Print every action done"
msgstr ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or expert\n"
"                        [default: intermediate]\n"
"\n"
"  Dangerous Options:\n"
"    Caution: use these options at your own risk.  It is believed that some\n"
"    of them bite.\n"
"\n"
"    -g                  Group option.\n"
"\n"
"  Debug Options:\n"
"    -d, --debug         Print debug information\n"
"    -s, --sql           Print all SQL statements executed\n"
"    -e                  Print every action done"

#: ../../library/optparse.rst:657
msgid ""
"Another interesting method, in particular when working programmatically with "
"option groups is:"
msgstr ""
"Outro método interessante, especialmente ao trabalhar programaticamente com "
"grupos de opções, é:"

#: ../../library/optparse.rst:662
msgid ""
"Return the :class:`OptionGroup` to which the short or long option string "
"*opt_str* (e.g. ``'-o'`` or ``'--option'``) belongs. If there's no such :"
"class:`OptionGroup`, return ``None``."
msgstr ""
"Retorna o objeto :class:`OptionGroup` ao qual a string de opção curta ou "
"longa *opt_str* (por exemplo, ``'-o'`` ou ``'--option'``) pertence. Se não "
"houver tal :class:`OptionGroup`, retorna ``None``."

#: ../../library/optparse.rst:669
msgid "Printing a version string"
msgstr "Exibindo uma string de versão"

#: ../../library/optparse.rst:671
msgid ""
"Similar to the brief usage string, :mod:`optparse` can also print a version "
"string for your program.  You have to supply the string as the ``version`` "
"argument to OptionParser::"
msgstr ""
"Similar à string breve de uso, :mod:`optparse` também pode exibir uma string "
"de versão para seu programa. Você tem que fornecer a string como o argumento "
"``version`` para OptionParser::"

#: ../../library/optparse.rst:675
msgid "parser = OptionParser(usage=\"%prog [-f] [-q]\", version=\"%prog 1.0\")"
msgstr ""
"parser = OptionParser(usage=\"%prog [-f] [-q]\", version=\"%prog 1.0\")"

#: ../../library/optparse.rst:677
msgid ""
"``%prog`` is expanded just like it is in ``usage``.  Apart from that, "
"``version`` can contain anything you like.  When you supply it, :mod:"
"`optparse` automatically adds a ``--version`` option to your parser. If it "
"encounters this option on the command line, it expands your ``version`` "
"string (by replacing ``%prog``), prints it to stdout, and exits."
msgstr ""
"``%prog`` é expandido assim como em ``usage``. Além disso, ``version`` pode "
"conter qualquer coisa que você quiser. Quando você o fornece, :mod:"
"`optparse` adiciona automaticamente uma opção ``--version`` ao seu "
"analisador. Se ele encontrar essa opção na linha de comando, ele expande sua "
"string ``version`` (substituindo ``%prog``), exibindo-a no stdout e sai."

#: ../../library/optparse.rst:683
msgid "For example, if your script is called ``/usr/bin/foo``:"
msgstr "Por exemplo, se o seu script for chamado ``/usr/bin/foo``:"

#: ../../library/optparse.rst:685
msgid ""
"$ /usr/bin/foo --version\n"
"foo 1.0"
msgstr ""
"$ /usr/bin/foo --version\n"
"foo 1.0"

#: ../../library/optparse.rst:690
msgid ""
"The following two methods can be used to print and get the ``version`` "
"string:"
msgstr ""
"Os dois métodos a seguir podem ser usados ​​para exibir e obter a string "
"``version``:"

#: ../../library/optparse.rst:694
msgid ""
"Print the version message for the current program (``self.version``) to "
"*file* (default stdout).  As with :meth:`print_usage`, any occurrence of "
"``%prog`` in ``self.version`` is replaced with the name of the current "
"program.  Does nothing if ``self.version`` is empty or undefined."
msgstr ""
"Exibe a mensagem de versão para o programa atual (``self.version``) em "
"*file* (stdout padrão). Assim como em :meth:`print_usage`, qualquer "
"ocorrência de ``%prog`` em ``self.version`` é substituída pelo nome do "
"programa atual. Não faz nada se ``self.version`` estiver vazio ou indefinido."

#: ../../library/optparse.rst:701
msgid ""
"Same as :meth:`print_version` but returns the version string instead of "
"printing it."
msgstr ""
"O mesmo que :meth:`print_version`, mas retorna a string da versão em vez de "
"exibi-la."

#: ../../library/optparse.rst:708
msgid "How :mod:`optparse` handles errors"
msgstr "Como :mod:`optparse` trata erros"

#: ../../library/optparse.rst:710
msgid ""
"There are two broad classes of errors that :mod:`optparse` has to worry "
"about: programmer errors and user errors.  Programmer errors are usually "
"erroneous calls to :func:`OptionParser.add_option`, e.g. invalid option "
"strings, unknown option attributes, missing option attributes, etc.  These "
"are dealt with in the usual way: raise an exception (either :exc:`optparse."
"OptionError` or :exc:`TypeError`) and let the program crash."
msgstr ""
"Existem duas classes amplas de erros com os quais :mod:`optparse` precisa se "
"preocupar: erros do programador e erros do usuário. Erros do programador "
"geralmente são chamadas errôneas para :func:`OptionParser.add_option`, por "
"exemplo, strings de opção inválidas, atributos de opção desconhecidos, "
"atributos de opção ausentes, etc. Eles são tratados da maneira usual: "
"levanta uma exceção (seja :exc:`optparse.OptionError` ou :exc:`TypeError`) e "
"deixe o programa travar."

#: ../../library/optparse.rst:717
msgid ""
"Handling user errors is much more important, since they are guaranteed to "
"happen no matter how stable your code is.  :mod:`optparse` can automatically "
"detect some user errors, such as bad option arguments (passing ``-n 4x`` "
"where ``-n`` takes an integer argument), missing arguments (``-n`` at the "
"end of the command line, where ``-n`` takes an argument of any type).  Also, "
"you can call :func:`OptionParser.error` to signal an application-defined "
"error condition::"
msgstr ""
"Lidar com erros do usuário é muito mais importante, pois eles certamente "
"acontecerão não importa quão estável seu código seja. :mod:`optparse` pode "
"detectar automaticamente alguns erros do usuário, como argumentos de opção "
"ruins (passando ``-n 4x`` onde ``-n`` recebe um argumento inteiro), "
"argumentos ausentes (``-n`` no final da linha de comando, onde ``-n`` recebe "
"um argumento de qualquer tipo). Além disso, você pode chamar :func:"
"`OptionParser.error` para sinalizar uma condição de erro definida pelo "
"aplicativo::"

#: ../../library/optparse.rst:725
msgid ""
"(options, args) = parser.parse_args()\n"
"...\n"
"if options.a and options.b:\n"
"    parser.error(\"options -a and -b are mutually exclusive\")"
msgstr ""
"(options, args) = parser.parse_args()\n"
"...\n"
"if options.a and options.b:\n"
"    parser.error(\"options -a and -b are mutually exclusive\")"

#: ../../library/optparse.rst:730
msgid ""
"In either case, :mod:`optparse` handles the error the same way: it prints "
"the program's usage message and an error message to standard error and exits "
"with error status 2."
msgstr ""
"Em ambos os casos, :mod:`optparse` lida com o erro da mesma maneira: ele "
"imprime a mensagem de uso do programa e uma mensagem de erro no erro padrão "
"e sai com o status de erro 2."

#: ../../library/optparse.rst:734
msgid ""
"Consider the first example above, where the user passes ``4x`` to an option "
"that takes an integer:"
msgstr ""
"Considere o primeiro exemplo acima, onde o usuário passa ``4x`` para uma "
"opção que aceita um inteiro:"

#: ../../library/optparse.rst:737
msgid ""
"$ /usr/bin/foo -n 4x\n"
"Usage: foo [options]\n"
"\n"
"foo: error: option -n: invalid integer value: '4x'"
msgstr ""
"$ /usr/bin/foo -n 4x\n"
"Usage: foo [options]\n"
"\n"
"foo: error: option -n: invalid integer value: '4x'"

#: ../../library/optparse.rst:744
msgid "Or, where the user fails to pass a value at all:"
msgstr "Ou, quando o usuário não passa nenhum valor:"

#: ../../library/optparse.rst:746
msgid ""
"$ /usr/bin/foo -n\n"
"Usage: foo [options]\n"
"\n"
"foo: error: -n option requires an argument"
msgstr ""
"$ /usr/bin/foo -n\n"
"Usage: foo [options]\n"
"\n"
"foo: error: -n option requires an argument"

#: ../../library/optparse.rst:753
msgid ""
":mod:`optparse`\\ -generated error messages take care always to mention the "
"option involved in the error; be sure to do the same when calling :func:"
"`OptionParser.error` from your application code."
msgstr ""
"As mensagens de erro geradas pelo :mod:`optparse` tomam o cuidado de sempre "
"mencionar a opção envolvida no erro; certifique-se de fazer o mesmo ao "
"chamar :func:`OptionParser.error` do código do sua aplicação."

#: ../../library/optparse.rst:757
msgid ""
"If :mod:`optparse`'s default error-handling behaviour does not suit your "
"needs, you'll need to subclass OptionParser and override its :meth:"
"`~OptionParser.exit` and/or :meth:`~OptionParser.error` methods."
msgstr ""
"Se o comportamento padrão de tratamento de erros do :mod:`optparse` não "
"atender às suas necessidades, você precisará criar uma subclasse de "
"OptionParser e substituir seus métodos :meth:`~OptionParser.exit` e/ou :meth:"
"`~OptionParser.error`."

#: ../../library/optparse.rst:765
msgid "Putting it all together"
msgstr "Juntando tudo"

#: ../../library/optparse.rst:767
msgid "Here's what :mod:`optparse`\\ -based scripts usually look like::"
msgstr ""
"Veja como os scripts baseados no :mod:`optparse` geralmente se parecem::"

#: ../../library/optparse.rst:769
msgid ""
"from optparse import OptionParser\n"
"...\n"
"def main():\n"
"    usage = \"usage: %prog [options] arg\"\n"
"    parser = OptionParser(usage)\n"
"    parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n"
"                      help=\"read data from FILENAME\")\n"
"    parser.add_option(\"-v\", \"--verbose\",\n"
"                      action=\"store_true\", dest=\"verbose\")\n"
"    parser.add_option(\"-q\", \"--quiet\",\n"
"                      action=\"store_false\", dest=\"verbose\")\n"
"    ...\n"
"    (options, args) = parser.parse_args()\n"
"    if len(args) != 1:\n"
"        parser.error(\"incorrect number of arguments\")\n"
"    if options.verbose:\n"
"        print(\"reading %s...\" % options.filename)\n"
"    ...\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"
msgstr ""
"from optparse import OptionParser\n"
"...\n"
"def main():\n"
"    usage = \"usage: %prog [options] arg\"\n"
"    parser = OptionParser(usage)\n"
"    parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n"
"                      help=\"read data from FILENAME\")\n"
"    parser.add_option(\"-v\", \"--verbose\",\n"
"                      action=\"store_true\", dest=\"verbose\")\n"
"    parser.add_option(\"-q\", \"--quiet\",\n"
"                      action=\"store_false\", dest=\"verbose\")\n"
"    ...\n"
"    (options, args) = parser.parse_args()\n"
"    if len(args) != 1:\n"
"        parser.error(\"incorrect number of arguments\")\n"
"    if options.verbose:\n"
"        print(\"reading %s...\" % options.filename)\n"
"    ...\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"

#: ../../library/optparse.rst:795
msgid "Reference Guide"
msgstr "Guia de referência"

#: ../../library/optparse.rst:801
msgid "Creating the parser"
msgstr "Criando o analisador sintático"

#: ../../library/optparse.rst:803
msgid ""
"The first step in using :mod:`optparse` is to create an OptionParser "
"instance."
msgstr ""
"O primeiro passo para usar o :mod:`optparse` é criar uma instância de "
"OptionParser."

#: ../../library/optparse.rst:807
msgid ""
"The OptionParser constructor has no required arguments, but a number of "
"optional keyword arguments.  You should always pass them as keyword "
"arguments, i.e. do not rely on the order in which the arguments are declared."
msgstr ""
"O construtor do OptionParser não tem argumentos obrigatórios, mas vários "
"argumentos nomeados opcionais. Você deve sempre passá-los como argumentos "
"nomeados, ou seja, não confie na ordem em que os argumentos são declarados."

#: ../../library/optparse.rst:811
msgid "``usage`` (default: ``\"%prog [options]\"``)"
msgstr "``usage`` (padrão: ``\"%prog [options]\"``)"

#: ../../library/optparse.rst:812
msgid ""
"The usage summary to print when your program is run incorrectly or with a "
"help option.  When :mod:`optparse` prints the usage string, it expands "
"``%prog`` to ``os.path.basename(sys.argv[0])`` (or to ``prog`` if you passed "
"that keyword argument).  To suppress a usage message, pass the special "
"value :const:`optparse.SUPPRESS_USAGE`."
msgstr ""
"O resumo de uso para exibir quando seu programa é executado incorretamente "
"ou com uma opção de ajuda. Quando :mod:`optparse` exibe a string de uso, ele "
"expande ``%prog`` para ``os.path.basename(sys.argv[0])`` (ou para ``prog`` "
"se você passou esse argumento nomeado). Para suprimir uma mensagem de uso, "
"passe o valor especial :const:`optparse.SUPPRESS_USAGE`."

#: ../../library/optparse.rst:818
msgid "``option_list`` (default: ``[]``)"
msgstr "``option_list`` (padrão: ``[]``)"

#: ../../library/optparse.rst:819
msgid ""
"A list of Option objects to populate the parser with.  The options in "
"``option_list`` are added after any options in ``standard_option_list`` (a "
"class attribute that may be set by OptionParser subclasses), but before any "
"version or help options. Deprecated; use :meth:`add_option` after creating "
"the parser instead."
msgstr ""
"Uma lista de objetos Option para preencher o analisador sintático. As opções "
"em ``option_list`` são adicionadas após quaisquer opções em "
"``standard_option_list`` (um atributo de classe que pode ser definido por "
"subclasses de OptionParser), mas antes de quaisquer opções de versão ou "
"ajuda. Descontinuado; use :meth:`add_option` após criar o analisador "
"sintático."

#: ../../library/optparse.rst:825
msgid "``option_class`` (default: optparse.Option)"
msgstr "``option_class`` (padrão: optparse.Option)"

#: ../../library/optparse.rst:826
msgid "Class to use when adding options to the parser in :meth:`add_option`."
msgstr ""
"Classe para usar ao adicionar opções ao analisador sintático em :meth:"
"`add_option`."

#: ../../library/optparse.rst:828
msgid "``version`` (default: ``None``)"
msgstr "``version`` (padrão: ``None``)"

#: ../../library/optparse.rst:829
msgid ""
"A version string to print when the user supplies a version option. If you "
"supply a true value for ``version``, :mod:`optparse` automatically adds a "
"version option with the single option string ``--version``.  The substring "
"``%prog`` is expanded the same as for ``usage``."
msgstr ""
"Uma string de versão para exibir quando o usuário fornece uma opção de "
"versão. Se você fornecer um valor true para ``version``, :mod:`optparse` "
"adiciona automaticamente uma opção de versão com a string de opção única ``--"
"version``. A substring ``%prog`` é expandida da mesma forma que para "
"``usage``."

#: ../../library/optparse.rst:834
msgid "``conflict_handler`` (default: ``\"error\"``)"
msgstr "``conflict_handler`` (padrão: ``\"error\"``)"

#: ../../library/optparse.rst:835
msgid ""
"Specifies what to do when options with conflicting option strings are added "
"to the parser; see section :ref:`optparse-conflicts-between-options`."
msgstr ""
"Especifica o que fazer quando opções com strings de opções conflitantes são "
"adicionadas ao analisador sintático; consulte a seção :ref:`optparse-"
"conflicts-between-options`."

#: ../../library/optparse.rst:839
msgid "``description`` (default: ``None``)"
msgstr "``description`` (padrão: ``None``)"

#: ../../library/optparse.rst:840
msgid ""
"A paragraph of text giving a brief overview of your program. :mod:`optparse` "
"reformats this paragraph to fit the current terminal width and prints it "
"when the user requests help (after ``usage``, but before the list of "
"options)."
msgstr ""
"Um parágrafo de texto que fornece uma breve visão geral do seu programa. :"
"mod:`optparse` reformata este parágrafo para ajustá-lo à largura atual do "
"terminal e o exibe quando o usuário solicita ajuda (depois de ``usage``, mas "
"antes da lista de opções)."

#: ../../library/optparse.rst:845
msgid "``formatter`` (default: a new :class:`IndentedHelpFormatter`)"
msgstr "``formatter`` (padrão: um novo :class:`IndentedHelpFormatter`)"

#: ../../library/optparse.rst:846
msgid ""
"An instance of optparse.HelpFormatter that will be used for printing help "
"text.  :mod:`optparse` provides two concrete classes for this purpose: "
"IndentedHelpFormatter and TitledHelpFormatter."
msgstr ""
"Uma instância de optparse.HelpFormatter que será usada para exibir um texto "
"de ajuda. :mod:`optparse` fornece duas classes concretas para essa "
"finalidade: IndentedHelpFormatter e TitledHelpFormatter."

#: ../../library/optparse.rst:850
msgid "``add_help_option`` (default: ``True``)"
msgstr "``add_help_option`` (padrão: ``True``)"

#: ../../library/optparse.rst:851
msgid ""
"If true, :mod:`optparse` will add a help option (with option strings ``-h`` "
"and ``--help``) to the parser."
msgstr ""
"Se verdadeiro, :mod:`optparse` adicionará uma opção de ajuda (com strings de "
"opção ``-h`` e ``--help``) ao analisador sintático."

#: ../../library/optparse.rst:854
msgid "``prog``"
msgstr "``prog``"

#: ../../library/optparse.rst:855
msgid ""
"The string to use when expanding ``%prog`` in ``usage`` and ``version`` "
"instead of ``os.path.basename(sys.argv[0])``."
msgstr ""
"A string a ser usada ao expandir ``%prog`` em ``usage`` e ``version`` em vez "
"de ``os.path.basename(sys.argv[0])``."

#: ../../library/optparse.rst:858
msgid "``epilog`` (default: ``None``)"
msgstr "``epilog`` (padrão: ``None``)"

#: ../../library/optparse.rst:859
msgid "A paragraph of help text to print after the option help."
msgstr "Um parágrafo de texto de ajuda para exibir após a ajuda da opção."

#: ../../library/optparse.rst:864
msgid "Populating the parser"
msgstr "Preenchendo o analisador sintático"

#: ../../library/optparse.rst:866
msgid ""
"There are several ways to populate the parser with options.  The preferred "
"way is by using :meth:`OptionParser.add_option`, as shown in section :ref:"
"`optparse-tutorial`.  :meth:`add_option` can be called in one of two ways:"
msgstr ""
"Há várias maneiras de preencher o analisador sintático com opções. A maneira "
"preferida é usando :meth:`OptionParser.add_option`, como mostrado na seção :"
"ref:`optparse-tutorial`. :meth:`add_option` pode ser chamado de uma das duas "
"maneiras:"

#: ../../library/optparse.rst:870
msgid "pass it an Option instance (as returned by :func:`make_option`)"
msgstr ""
"passar uma instância de Option (conforme retornado por :func:`make_option`)"

#: ../../library/optparse.rst:872
msgid ""
"pass it any combination of positional and keyword arguments that are "
"acceptable to :func:`make_option` (i.e., to the Option constructor), and it "
"will create the Option instance for you"
msgstr ""
"passar qualquer combinação de argumentos nomeados e posicionais que sejam "
"aceitáveis ​​para :func:`make_option` (ou seja, para o construtor de Option), "
"e ela criará a instância de Option para você"

#: ../../library/optparse.rst:876
msgid ""
"The other alternative is to pass a list of pre-constructed Option instances "
"to the OptionParser constructor, as in::"
msgstr ""
"A outra alternativa é passar uma lista de instâncias de Option pré-"
"construídas para o construtor de OptionParser, como em:"

#: ../../library/optparse.rst:879
msgid ""
"option_list = [\n"
"    make_option(\"-f\", \"--filename\",\n"
"                action=\"store\", type=\"string\", dest=\"filename\"),\n"
"    make_option(\"-q\", \"--quiet\",\n"
"                action=\"store_false\", dest=\"verbose\"),\n"
"    ]\n"
"parser = OptionParser(option_list=option_list)"
msgstr ""
"option_list = [\n"
"    make_option(\"-f\", \"--filename\",\n"
"                action=\"store\", type=\"string\", dest=\"filename\"),\n"
"    make_option(\"-q\", \"--quiet\",\n"
"                action=\"store_false\", dest=\"verbose\"),\n"
"    ]\n"
"parser = OptionParser(option_list=option_list)"

#: ../../library/optparse.rst:887
msgid ""
"(:func:`make_option` is a factory function for creating Option instances; "
"currently it is an alias for the Option constructor.  A future version of :"
"mod:`optparse` may split Option into several classes, and :func:"
"`make_option` will pick the right class to instantiate.  Do not instantiate "
"Option directly.)"
msgstr ""
"(:func:`make_option` é uma função de fábrica para criar instâncias de "
"Option; atualmente é um apelido para o construtor de Option. Uma versão "
"futura de :mod:`optparse` pode dividir Option em várias classes, e :func:"
"`make_option` escolherá a classe certa para instanciar. Não instancie Option "
"diretamente.)"

#: ../../library/optparse.rst:896
msgid "Defining options"
msgstr "Definindo as opções"

#: ../../library/optparse.rst:898
msgid ""
"Each Option instance represents a set of synonymous command-line option "
"strings, e.g. ``-f`` and ``--file``.  You can specify any number of short or "
"long option strings, but you must specify at least one overall option string."
msgstr ""
"Cada instância de Option representa um conjunto de strings de opções de "
"linha de comando sinônimas, por exemplo, ``-f`` e ``--file``. Você pode "
"especificar qualquer número de strings de opções curtas ou longas, mas deve "
"especificar pelo menos uma string de opção geral."

#: ../../library/optparse.rst:902
msgid ""
"The canonical way to create an :class:`Option` instance is with the :meth:"
"`add_option` method of :class:`OptionParser`."
msgstr ""
"A maneira canônica de criar uma instância de :class:`Option` é com o método :"
"meth:`add_option` de :class:`OptionParser`."

#: ../../library/optparse.rst:908
msgid "To define an option with only a short option string::"
msgstr "Para definir uma opção com apenas uma sequência de opções curta:"

#: ../../library/optparse.rst:910
msgid "parser.add_option(\"-f\", attr=value, ...)"
msgstr "parser.add_option(\"-f\", attr=value, ...)"

#: ../../library/optparse.rst:912
msgid "And to define an option with only a long option string::"
msgstr "E para definir uma opção com apenas uma longa sequência de opções::"

#: ../../library/optparse.rst:914
msgid "parser.add_option(\"--foo\", attr=value, ...)"
msgstr "parser.add_option(\"--foo\", attr=value, ...)"

#: ../../library/optparse.rst:916
msgid ""
"The keyword arguments define attributes of the new Option object.  The most "
"important option attribute is :attr:`~Option.action`, and it largely "
"determines which other attributes are relevant or required.  If you pass "
"irrelevant option attributes, or fail to pass required ones, :mod:`optparse` "
"raises an :exc:`OptionError` exception explaining your mistake."
msgstr ""
"Os argumentos nomeados definem atributos do novo objeto Option. O atributo "
"option mais importante é :attr:`~Option.action`, e ele determina amplamente "
"quais outros atributos são relevantes ou obrigatórios. Se você passar "
"atributos option irrelevantes, ou deixar de passar os obrigatórios, :mod:"
"`optparse` levanta uma exceção :exc:`OptionError` explicando seu erro."

#: ../../library/optparse.rst:922
msgid ""
"An option's *action* determines what :mod:`optparse` does when it encounters "
"this option on the command-line.  The standard option actions hard-coded "
"into :mod:`optparse` are:"
msgstr ""
"A *action* de uma opção determina o que :mod:`optparse` faz quando encontra "
"essa opção na linha de comando. As ações de opção padrão codificadas no :mod:"
"`optparse` são:"

#: ../../library/optparse.rst:926
msgid "``\"store\"``"
msgstr "``\"store\"``"

#: ../../library/optparse.rst:927
msgid "store this option's argument (default)"
msgstr "armazena o argumento desta opção (padrão)"

#: ../../library/optparse.rst:932
msgid "``\"store_true\"``"
msgstr "``\"store_true\"``"

#: ../../library/optparse.rst:933
msgid "store ``True``"
msgstr "armazena ``True``"

#: ../../library/optparse.rst:935
msgid "``\"store_false\"``"
msgstr "``\"store_false\"``"

#: ../../library/optparse.rst:936
msgid "store ``False``"
msgstr "armazena ``False``"

#: ../../library/optparse.rst:941
msgid "``\"append_const\"``"
msgstr "``\"append_const\"``"

#: ../../library/optparse.rst:942
msgid "append a constant value to a list, pre-set via :attr:`Option.const`"
msgstr ""
"anexar um valor constante a uma lista, predefinido via :attr:`Option.const`"

#: ../../library/optparse.rst:950 ../../library/optparse.rst:1245
msgid "``\"help\"``"
msgstr "``\"help\"``"

#: ../../library/optparse.rst:951
msgid ""
"print a usage message including all options and the documentation for them"
msgstr ""
"exibe uma mensagem de uso incluindo todas as opções e a documentação para "
"elas"

#: ../../library/optparse.rst:953
msgid ""
"(If you don't supply an action, the default is ``\"store\"``.  For this "
"action, you may also supply :attr:`~Option.type` and :attr:`~Option.dest` "
"option attributes; see :ref:`optparse-standard-option-actions`.)"
msgstr ""
"(Se você não fornecer uma ação, o padrão é ``\"store\"``. Para esta ação, "
"você também pode fornecer os atributos de opção :attr:`~Option.type` e :attr:"
"`~Option.dest`; consulte :ref:`optparse-standard-option-actions`.)"

#: ../../library/optparse.rst:957
msgid ""
"As you can see, most actions involve storing or updating a value somewhere. :"
"mod:`optparse` always creates a special object for this, conventionally "
"called ``options``, which is an instance of :class:`optparse.Values`."
msgstr ""
"Como você pode ver, a maioria das ações envolve armazenar ou atualizar um "
"valor em algum lugar. :mod:`optparse` sempre cria um objeto especial para "
"isso, convencionalmente chamado de ``options``, que é uma instância de :"
"class:`optparse.Values`."

#: ../../library/optparse.rst:963
msgid ""
"An object holding parsed argument names and values as attributes. Normally "
"created by calling when calling :meth:`OptionParser.parse_args`, and can be "
"overridden by a custom subclass passed to the *values* argument of :meth:"
"`OptionParser.parse_args` (as described in :ref:`optparse-parsing-"
"arguments`)."
msgstr ""
"Um objeto que contém nomes e valores de argumentos analisados ​​como "
"atributos. Normalmente criado chamando ao chamar :meth:`OptionParser."
"parse_args`, e pode ser substituído por uma subclasse personalizada passada "
"para o argumento *values* de :meth:`OptionParser.parse_args` (conforme "
"descrito em :ref:`optparse-parsing-arguments`)."

#: ../../library/optparse.rst:968
msgid ""
"Option arguments (and various other values) are stored as attributes of this "
"object, according to the :attr:`~Option.dest` (destination) option attribute."
msgstr ""
"Argumentos de opção (e vários outros valores) são armazenados como atributos "
"deste objeto, de acordo com o atributo de opção :attr:`~Option.dest` "
"(destino)."

#: ../../library/optparse.rst:972
msgid "For example, when you call ::"
msgstr "Por exemplo, quando você chama ::"

#: ../../library/optparse.rst:974
msgid "parser.parse_args()"
msgstr "parser.parse_args()"

#: ../../library/optparse.rst:976
msgid ""
"one of the first things :mod:`optparse` does is create the ``options`` "
"object::"
msgstr ""
"uma das primeiras coisas que :mod:`optparse` faz é criar o objeto "
"``options``::"

#: ../../library/optparse.rst:978
msgid "options = Values()"
msgstr "options = Values()"

#: ../../library/optparse.rst:980
msgid "If one of the options in this parser is defined with ::"
msgstr "Se uma das opções neste analisador sintático for definida com ::"

#: ../../library/optparse.rst:982
msgid ""
"parser.add_option(\"-f\", \"--file\", action=\"store\", type=\"string\", "
"dest=\"filename\")"
msgstr ""
"parser.add_option(\"-f\", \"--file\", action=\"store\", type=\"string\", "
"dest=\"filename\")"

#: ../../library/optparse.rst:984
msgid "and the command-line being parsed includes any of the following::"
msgstr ""
"e a linha de comando que está sendo analisada inclui qualquer um dos "
"seguintes:"

#: ../../library/optparse.rst:986
msgid ""
"-ffoo\n"
"-f foo\n"
"--file=foo\n"
"--file foo"
msgstr ""
"-ffoo\n"
"-f foo\n"
"--file=foo\n"
"--file foo"

#: ../../library/optparse.rst:991
msgid ""
"then :mod:`optparse`, on seeing this option, will do the equivalent of ::"
msgstr "então :mod:`optparse`, ao ver esta opção, fará o equivalente a ::"

#: ../../library/optparse.rst:993
msgid "options.filename = \"foo\""
msgstr "options.filename = \"foo\""

#: ../../library/optparse.rst:995
msgid ""
"The :attr:`~Option.type` and :attr:`~Option.dest` option attributes are "
"almost as important as :attr:`~Option.action`, but :attr:`~Option.action` is "
"the only one that makes sense for *all* options."
msgstr ""
"Os atributos de opção :attr:`~Option.type` e :attr:`~Option.dest` são quase "
"tão importantes quanto :attr:`~Option.action`, mas :attr:`~Option.action` é "
"o único que faz sentido para *todas* as opções."

#: ../../library/optparse.rst:1003
msgid "Option attributes"
msgstr "Atributos da classe Option"

#: ../../library/optparse.rst:1007
msgid ""
"A single command line argument, with various attributes passed by keyword to "
"the constructor. Normally created with :meth:`OptionParser.add_option` "
"rather than directly, and can be overridden by a custom class via the "
"*option_class* argument to :class:`OptionParser`."
msgstr ""
"Um único argumento de linha de comando, com vários atributos passados ​​como "
"nomeados para o construtor. Normalmente criado com :meth:`OptionParser."
"add_option` em vez de diretamente, e pode ser substituído por uma classe "
"personalizada por meio do argumento *option_class* para :class:"
"`OptionParser`."

#: ../../library/optparse.rst:1013
msgid ""
"The following option attributes may be passed as keyword arguments to :meth:"
"`OptionParser.add_option`.  If you pass an option attribute that is not "
"relevant to a particular option, or fail to pass a required option "
"attribute, :mod:`optparse` raises :exc:`OptionError`."
msgstr ""
"Os seguintes atributos de opção podem ser passados ​​como argumentos nomeados "
"para :meth:`OptionParser.add_option`. Se você passar um atributo de opção "
"que não seja relevante para uma opção específica, ou deixar de passar um "
"atributo de opção obrigatório, :mod:`optparse` levanta :exc:`OptionError`."

#: ../../library/optparse.rst:1020
msgid "(default: ``\"store\"``)"
msgstr "(padrão: ``\"store\"``)"

#: ../../library/optparse.rst:1022
msgid ""
"Determines :mod:`optparse`'s behaviour when this option is seen on the "
"command line; the available options are documented :ref:`here <optparse-"
"standard-option-actions>`."
msgstr ""
"Determina o comportamento de :mod:`optparse` quando esta opção é vista na "
"linha de comando; as opções disponíveis estão documentadas :ref:`aqui "
"<optparse-standard-option-actions>`."

#: ../../library/optparse.rst:1028
msgid "(default: ``\"string\"``)"
msgstr "(padrão: ``\"string\"``)"

#: ../../library/optparse.rst:1030
msgid ""
"The argument type expected by this option (e.g., ``\"string\"`` or "
"``\"int\"``); the available option types are documented :ref:`here <optparse-"
"standard-option-types>`."
msgstr ""
"O tipo de argumento esperado por esta opção (por exemplo, ``\"string\"`` ou "
"``\"int\"``); os tipos de opções disponíveis estão documentados :ref:`aqui "
"<optparse-standard-option-types>`."

#: ../../library/optparse.rst:1036 ../../library/optparse.rst:1086
msgid "(default: derived from option strings)"
msgstr "(padrão: derivado de strings de opção)"

#: ../../library/optparse.rst:1038
msgid ""
"If the option's action implies writing or modifying a value somewhere, this "
"tells :mod:`optparse` where to write it: :attr:`~Option.dest` names an "
"attribute of the ``options`` object that :mod:`optparse` builds as it parses "
"the command line."
msgstr ""
"Se a ação da opção implicar escrever ou modificar um valor em algum lugar, "
"isso informa ao :mod:`optparse` onde escrevê-lo: :attr:`~Option.dest` nomeia "
"um atributo do objeto ``options`` que o :mod:`optparse` constrói ao analisar "
"a linha de comando."

#: ../../library/optparse.rst:1045
msgid ""
"The value to use for this option's destination if the option is not seen on "
"the command line.  See also :meth:`OptionParser.set_defaults`."
msgstr ""
"O valor para usar para o destino desta opção se a opção não for vista na "
"linha de comando. Veja também :meth:`OptionParser.set_defaults`."

#: ../../library/optparse.rst:1050
msgid "(default: 1)"
msgstr "(padrão: 1)"

#: ../../library/optparse.rst:1052
msgid ""
"How many arguments of type :attr:`~Option.type` should be consumed when this "
"option is seen.  If > 1, :mod:`optparse` will store a tuple of values to :"
"attr:`~Option.dest`."
msgstr ""
"Quantos argumentos do tipo :attr:`~Option.type` devem ser consumidos quando "
"esta opção for vista. Se > 1, :mod:`optparse` armazenará uma tupla de "
"valores em :attr:`~Option.dest`."

#: ../../library/optparse.rst:1058
msgid "For actions that store a constant value, the constant value to store."
msgstr ""
"Para ações que armazenam um valor constante, o valor constante a ser "
"armazenado."

#: ../../library/optparse.rst:1062
msgid ""
"For options of type ``\"choice\"``, the list of strings the user may choose "
"from."
msgstr ""
"Para opções do tipo ``\"choice\"``, a lista de strings que o usuário pode "
"escolher."

#: ../../library/optparse.rst:1067
msgid ""
"For options with action ``\"callback\"``, the callable to call when this "
"option is seen.  See section :ref:`optparse-option-callbacks` for detail on "
"the arguments passed to the callable."
msgstr ""
"Para opções com ação ``\"callback\"``, o chamável para chamar quando esta "
"opção for vista. Veja a seção :ref:`optparse-option-callbacks` para detalhes "
"sobre os argumentos passados ​​para o chamável."

#: ../../library/optparse.rst:1074
msgid ""
"Additional positional and keyword arguments to pass to ``callback`` after "
"the four standard callback arguments."
msgstr ""
"Argumentos nomeados e posicionais adicionais para passar para ``callback`` "
"após os quatro argumentos de retorno de chamada padrão."

#: ../../library/optparse.rst:1079
msgid ""
"Help text to print for this option when listing all available options after "
"the user supplies a :attr:`~Option.help` option (such as ``--help``).  If no "
"help text is supplied, the option will be listed without help text.  To hide "
"this option, use the special value :const:`optparse.SUPPRESS_HELP`."
msgstr ""
"Texto de ajuda para exibir para esta opção ao listar todas as opções "
"disponíveis após o usuário fornecer uma opção :attr:`~Option.help` (como ``--"
"help``). Se nenhum texto de ajuda for fornecido, a opção será listada sem "
"texto de ajuda. Para ocultar esta opção, use o valor especial :const:"
"`optparse.SUPPRESS_HELP`."

#: ../../library/optparse.rst:1088
msgid ""
"Stand-in for the option argument(s) to use when printing help text.  See "
"section :ref:`optparse-tutorial` for an example."
msgstr ""
"Substituto para o(s) argumento(s) de opção a ser(em) usado(s) ao exibir "
"texto de ajuda. Veja a seção :ref:`optparse-tutorial` para um exemplo."

#: ../../library/optparse.rst:1095
msgid "Standard option actions"
msgstr "Ações de opção padrão"

#: ../../library/optparse.rst:1097
msgid ""
"The various option actions all have slightly different requirements and "
"effects. Most actions have several relevant option attributes which you may "
"specify to guide :mod:`optparse`'s behaviour; a few have required "
"attributes, which you must specify for any option using that action."
msgstr ""
"As várias ações de opção têm requisitos e efeitos ligeiramente diferentes. A "
"maioria das ações tem vários atributos de opção relevantes que você pode "
"especificar para guiar o comportamento de :mod:`optparse`; algumas têm "
"atributos obrigatórios, que você deve especificar para qualquer opção que "
"use essa ação."

#: ../../library/optparse.rst:1102
msgid ""
"``\"store\"`` [relevant: :attr:`~Option.type`, :attr:`~Option.dest`, :attr:"
"`~Option.nargs`, :attr:`~Option.choices`]"
msgstr ""
"``\"store\"`` [relevante: :attr:`~Option.type`, :attr:`~Option.dest`, :attr:"
"`~Option.nargs`, :attr:`~Option.choices`]"

#: ../../library/optparse.rst:1105
msgid ""
"The option must be followed by an argument, which is converted to a value "
"according to :attr:`~Option.type` and stored in :attr:`~Option.dest`.  If :"
"attr:`~Option.nargs` > 1, multiple arguments will be consumed from the "
"command line; all will be converted according to :attr:`~Option.type` and "
"stored to :attr:`~Option.dest` as a tuple.  See the :ref:`optparse-standard-"
"option-types` section."
msgstr ""
"A opção deve ser seguida por um argumento, que é convertido em um valor de "
"acordo com :attr:`~Option.type` e armazenado em :attr:`~Option.dest`. Se :"
"attr:`~Option.nargs` > 1, vários argumentos serão consumidos da linha de "
"comando; todos serão convertidos de acordo com :attr:`~Option.type` e "
"armazenados em :attr:`~Option.dest` como uma tupla. Veja a seção :ref:"
"`optparse-standard-option-types`."

#: ../../library/optparse.rst:1112
msgid ""
"If :attr:`~Option.choices` is supplied (a list or tuple of strings), the "
"type defaults to ``\"choice\"``."
msgstr ""
"Se :attr:`~Option.choices` for fornecido (uma lista ou tupla de strings), o "
"tipo padrão será ``\"choice\"``."

#: ../../library/optparse.rst:1115
msgid "If :attr:`~Option.type` is not supplied, it defaults to ``\"string\"``."
msgstr ""
"Se :attr:`~Option.type` não for fornecido, o padrão será ``\"string\"``."

#: ../../library/optparse.rst:1117
msgid ""
"If :attr:`~Option.dest` is not supplied, :mod:`optparse` derives a "
"destination from the first long option string (e.g., ``--foo-bar`` implies "
"``foo_bar``). If there are no long option strings, :mod:`optparse` derives a "
"destination from the first short option string (e.g., ``-f`` implies ``f``)."
msgstr ""
"Se :attr:`~Option.dest` não for fornecido, :mod:`optparse` deriva um destino "
"da primeira string de opção longa (por exemplo, ``--foo-bar`` implica "
"``foo_bar``). Se não houver strings de opção longas, :mod:`optparse` deriva "
"um destino da primeira string de opção curta (por exemplo, ``-f`` implica "
"``f``)."

#: ../../library/optparse.rst:1122 ../../library/optparse.rst:1142
#: ../../library/optparse.rst:1164 ../../library/optparse.rst:1182
#: ../../library/optparse.rst:1221 ../../library/optparse.rst:1259
msgid "Example::"
msgstr "Exemplo::"

#: ../../library/optparse.rst:1124
msgid ""
"parser.add_option(\"-f\")\n"
"parser.add_option(\"-p\", type=\"float\", nargs=3, dest=\"point\")"
msgstr ""
"parser.add_option(\"-f\")\n"
"parser.add_option(\"-p\", type=\"float\", nargs=3, dest=\"point\")"

#: ../../library/optparse.rst:1127
msgid "As it parses the command line ::"
msgstr "Como ele analisa a linha de comando ::"

#: ../../library/optparse.rst:1129
msgid "-f foo.txt -p 1 -3.5 4 -fbar.txt"
msgstr "-f foo.txt -p 1 -3.5 4 -fbar.txt"

#: ../../library/optparse.rst:1131
msgid ":mod:`optparse` will set ::"
msgstr ":mod:`optparse` vai definir ::"

#: ../../library/optparse.rst:1133
msgid ""
"options.f = \"foo.txt\"\n"
"options.point = (1.0, -3.5, 4.0)\n"
"options.f = \"bar.txt\""
msgstr ""
"options.f = \"foo.txt\"\n"
"options.point = (1.0, -3.5, 4.0)\n"
"options.f = \"bar.txt\""

#: ../../library/optparse.rst:1137
msgid ""
"``\"store_const\"`` [required: :attr:`~Option.const`; relevant: :attr:"
"`~Option.dest`]"
msgstr ""
"``\"store_const\"`` [obrigatório: :attr:`~Option.const`; relevante: :attr:"
"`~Option.dest`]"

#: ../../library/optparse.rst:1140
msgid "The value :attr:`~Option.const` is stored in :attr:`~Option.dest`."
msgstr "O valor de :attr:`~Option.const` é armazenado em :attr:`~Option.dest`."

#: ../../library/optparse.rst:1144
msgid ""
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_const\", const=0, dest=\"verbose\")\n"
"parser.add_option(\"-v\", \"--verbose\",\n"
"                  action=\"store_const\", const=1, dest=\"verbose\")\n"
"parser.add_option(\"--noisy\",\n"
"                  action=\"store_const\", const=2, dest=\"verbose\")"
msgstr ""
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_const\", const=0, dest=\"verbose\")\n"
"parser.add_option(\"-v\", \"--verbose\",\n"
"                  action=\"store_const\", const=1, dest=\"verbose\")\n"
"parser.add_option(\"--noisy\",\n"
"                  action=\"store_const\", const=2, dest=\"verbose\")"

#: ../../library/optparse.rst:1151
msgid "If ``--noisy`` is seen, :mod:`optparse` will set  ::"
msgstr "Se ``--noisy`` é encontrado, :mod:`optparse` vai definir ::"

#: ../../library/optparse.rst:1153
msgid "options.verbose = 2"
msgstr "options.verbose = 2"

#: ../../library/optparse.rst:1155
msgid "``\"store_true\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"store_true\"`` [relevante: :attr:`~Option.dest`]"

#: ../../library/optparse.rst:1157
msgid ""
"A special case of ``\"store_const\"`` that stores ``True`` to :attr:`~Option."
"dest`."
msgstr ""
"Um caso especial de ``\"store_const\"`` que armazena ``True`` em :attr:"
"`~Option.dest`."

#: ../../library/optparse.rst:1160
msgid "``\"store_false\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"store_false\"`` [relevante: :attr:`~Option.dest`]"

#: ../../library/optparse.rst:1162
msgid "Like ``\"store_true\"``, but stores ``False``."
msgstr "Como ``\"store_true\"``, mas armazenad ``False``."

#: ../../library/optparse.rst:1166
msgid ""
"parser.add_option(\"--clobber\", action=\"store_true\", dest=\"clobber\")\n"
"parser.add_option(\"--no-clobber\", action=\"store_false\", dest=\"clobber\")"
msgstr ""
"parser.add_option(\"--clobber\", action=\"store_true\", dest=\"clobber\")\n"
"parser.add_option(\"--no-clobber\", action=\"store_false\", dest=\"clobber\")"

#: ../../library/optparse.rst:1169
msgid ""
"``\"append\"`` [relevant: :attr:`~Option.type`, :attr:`~Option.dest`, :attr:"
"`~Option.nargs`, :attr:`~Option.choices`]"
msgstr ""
"``\"append\"`` [relevante: :attr:`~Option.type`, :attr:`~Option.dest`, :attr:"
"`~Option.nargs`, :attr:`~Option.choices`]"

#: ../../library/optparse.rst:1172
msgid ""
"The option must be followed by an argument, which is appended to the list "
"in :attr:`~Option.dest`.  If no default value for :attr:`~Option.dest` is "
"supplied, an empty list is automatically created when :mod:`optparse` first "
"encounters this option on the command-line.  If :attr:`~Option.nargs` > 1, "
"multiple arguments are consumed, and a tuple of length :attr:`~Option.nargs` "
"is appended to :attr:`~Option.dest`."
msgstr ""
"A opção deve ser seguida por um argumento, que é anexado à lista em :attr:"
"`~Option.dest`. Se nenhum valor padrão para :attr:`~Option.dest` for "
"fornecido, uma lista vazia será criada automaticamente quando :mod:"
"`optparse` encontrar esta opção pela primeira vez na linha de comando. Se :"
"attr:`~Option.nargs` > 1, vários argumentos serão consumidos e uma tupla de "
"comprimento :attr:`~Option.nargs` será anexada a :attr:`~Option.dest`."

#: ../../library/optparse.rst:1179
msgid ""
"The defaults for :attr:`~Option.type` and :attr:`~Option.dest` are the same "
"as for the ``\"store\"`` action."
msgstr ""
"Os padrões para :attr:`~Option.type` e :attr:`~Option.dest` são os mesmos da "
"ação ``\"store\"``."

#: ../../library/optparse.rst:1184
msgid ""
"parser.add_option(\"-t\", \"--tracks\", action=\"append\", type=\"int\")"
msgstr ""
"parser.add_option(\"-t\", \"--tracks\", action=\"append\", type=\"int\")"

#: ../../library/optparse.rst:1186
msgid ""
"If ``-t3`` is seen on the command-line, :mod:`optparse` does the equivalent "
"of::"
msgstr ""
"Se ``-t3`` for encontrado na linha de comando, :mod:`optparse` faz o "
"equivalente a::"

#: ../../library/optparse.rst:1189
msgid ""
"options.tracks = []\n"
"options.tracks.append(int(\"3\"))"
msgstr ""
"options.tracks = []\n"
"options.tracks.append(int(\"3\"))"

#: ../../library/optparse.rst:1192
msgid "If, a little later on, ``--tracks=4`` is seen, it does::"
msgstr "Se, um pouco mais tarde, ``--tracks=4`` for encontrado, ele faz::"

#: ../../library/optparse.rst:1194
msgid "options.tracks.append(int(\"4\"))"
msgstr "options.tracks.append(int(\"4\"))"

#: ../../library/optparse.rst:1196
msgid ""
"The ``append`` action calls the ``append`` method on the current value of "
"the option.  This means that any default value specified must have an "
"``append`` method.  It also means that if the default value is non-empty, "
"the default elements will be present in the parsed value for the option, "
"with any values from the command line appended after those default values::"
msgstr ""
"A ação ``append`` chama o método ``append`` no valor atual da opção. Isso "
"significa que qualquer valor padrão especificado deve ter um método "
"``append``. Isso também significa que se o valor padrão não for vazio, os "
"elementos padrão estarão presentes no valor analisado para a opção, com "
"quaisquer valores da linha de comando anexados após esses valores padrão::"

#: ../../library/optparse.rst:1202
msgid ""
">>> parser.add_option(\"--files\", action=\"append\", default=['~/.mypkg/"
"defaults'])\n"
">>> opts, args = parser.parse_args(['--files', 'overrides.mypkg'])\n"
">>> opts.files\n"
"['~/.mypkg/defaults', 'overrides.mypkg']"
msgstr ""
">>> parser.add_option(\"--files\", action=\"append\", default=['~/.mypkg/"
"defaults'])\n"
">>> opts, args = parser.parse_args(['--files', 'overrides.mypkg'])\n"
">>> opts.files\n"
"['~/.mypkg/defaults', 'overrides.mypkg']"

#: ../../library/optparse.rst:1207
msgid ""
"``\"append_const\"`` [required: :attr:`~Option.const`; relevant: :attr:"
"`~Option.dest`]"
msgstr ""
"``\"append_const\"`` [obrigatório: :attr:`~Option.const`; relevante: :attr:"
"`~Option.dest`]"

#: ../../library/optparse.rst:1210
msgid ""
"Like ``\"store_const\"``, but the value :attr:`~Option.const` is appended "
"to :attr:`~Option.dest`; as with ``\"append\"``, :attr:`~Option.dest` "
"defaults to ``None``, and an empty list is automatically created the first "
"time the option is encountered."
msgstr ""
"Como ``\"store_const\"``, mas o valor de :attr:`~Option.const` é anexado a :"
"attr:`~Option.dest`; assim como em ``\"append\"``, :attr:`~Option.dest` "
"assume como padrão ``None``, e uma lista vazia é criada automaticamente na "
"primeira vez que a opção é encontrada."

#: ../../library/optparse.rst:1215
msgid "``\"count\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"count\"`` [relevante: :attr:`~Option.dest`]"

#: ../../library/optparse.rst:1217
msgid ""
"Increment the integer stored at :attr:`~Option.dest`.  If no default value "
"is supplied, :attr:`~Option.dest` is set to zero before being incremented "
"the first time."
msgstr ""
"Incrementa o inteiro armazenado em :attr:`~Option.dest`. Se nenhum valor "
"padrão for fornecido, :attr:`~Option.dest` é definido como zero antes de ser "
"incrementado pela primeira vez."

#: ../../library/optparse.rst:1223
msgid "parser.add_option(\"-v\", action=\"count\", dest=\"verbosity\")"
msgstr "parser.add_option(\"-v\", action=\"count\", dest=\"verbosity\")"

#: ../../library/optparse.rst:1225
msgid ""
"The first time ``-v`` is seen on the command line, :mod:`optparse` does the "
"equivalent of::"
msgstr ""
"A primeira vez que ``-v`` é encontrado na linha de comando, :mod:`optparse` "
"faz o equivalente a::"

#: ../../library/optparse.rst:1228
msgid ""
"options.verbosity = 0\n"
"options.verbosity += 1"
msgstr ""
"options.verbosity = 0\n"
"options.verbosity += 1"

#: ../../library/optparse.rst:1231
msgid "Every subsequent occurrence of ``-v`` results in  ::"
msgstr "Cada ocorrência subsequente de ``-v`` resulta em ::"

#: ../../library/optparse.rst:1233
msgid "options.verbosity += 1"
msgstr "options.verbosity += 1"

#: ../../library/optparse.rst:1235
msgid ""
"``\"callback\"`` [required: :attr:`~Option.callback`; relevant: :attr:"
"`~Option.type`, :attr:`~Option.nargs`, :attr:`~Option.callback_args`, :attr:"
"`~Option.callback_kwargs`]"
msgstr ""
"``\"callback\"`` [obrigatório: :attr:`~Option.callback`; relevante: :attr:"
"`~Option.type`, :attr:`~Option.nargs`, :attr:`~Option.callback_args`, :attr:"
"`~Option.callback_kwargs`]"

#: ../../library/optparse.rst:1239
msgid ""
"Call the function specified by :attr:`~Option.callback`, which is called "
"as ::"
msgstr ""
"Chama a função especificada por :attr:`~Option.callback`, que é chamada "
"como ::"

#: ../../library/optparse.rst:1241 ../../library/optparse.rst:1639
msgid "func(option, opt_str, value, parser, *args, **kwargs)"
msgstr "func(option, opt_str, value, parser, *args, **kwargs)"

#: ../../library/optparse.rst:1243
msgid "See section :ref:`optparse-option-callbacks` for more detail."
msgstr "Veja a seção :ref:`optparse-option-callbacks` para mais detalhes."

#: ../../library/optparse.rst:1247
msgid ""
"Prints a complete help message for all the options in the current option "
"parser.  The help message is constructed from the ``usage`` string passed to "
"OptionParser's constructor and the :attr:`~Option.help` string passed to "
"every option."
msgstr ""
"Exibe uma mensagem de ajuda completa para todas as opções no analisador "
"sintático de opções atual. A mensagem de ajuda é construída a partir da "
"string ``usage`` passada para o construtor do OptionParser e da string :attr:"
"`~Option.help` passada para cada opção."

#: ../../library/optparse.rst:1252
msgid ""
"If no :attr:`~Option.help` string is supplied for an option, it will still "
"be listed in the help message.  To omit an option entirely, use the special "
"value :const:`optparse.SUPPRESS_HELP`."
msgstr ""
"Se nenhuma string de :attr:`~Option.help` for fornecida para uma opção, ela "
"ainda será listada na mensagem de ajuda. Para omitir uma opção "
"completamente, use o valor especial :const:`optparse.SUPPRESS_HELP`."

#: ../../library/optparse.rst:1256
msgid ""
":mod:`optparse` automatically adds a :attr:`~Option.help` option to all "
"OptionParsers, so you do not normally need to create one."
msgstr ""
":mod:`optparse` adiciona automaticamente uma opção :attr:`~Option.help` a "
"todos as instâncias de OptionParsers, então normalmente você não precisa "
"criar uma."

#: ../../library/optparse.rst:1261
msgid ""
"from optparse import OptionParser, SUPPRESS_HELP\n"
"\n"
"# usually, a help option is added automatically, but that can\n"
"# be suppressed using the add_help_option argument\n"
"parser = OptionParser(add_help_option=False)\n"
"\n"
"parser.add_option(\"-h\", \"--help\", action=\"help\")\n"
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\",\n"
"                  help=\"Be moderately verbose\")\n"
"parser.add_option(\"--file\", dest=\"filename\",\n"
"                  help=\"Input file to read data from\")\n"
"parser.add_option(\"--secret\", help=SUPPRESS_HELP)"
msgstr ""
"from optparse import OptionParser, SUPPRESS_HELP\n"
"\n"
"# geralmente, uma opção de ajuda é adicionada\n"
"# automaticamente, mas que podem ser suprimida\n"
"# usando o argumento add_help_option\n"
"parser = OptionParser(add_help_option=False)\n"
"\n"
"parser.add_option(\"-h\", \"--help\", action=\"help\")\n"
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\",\n"
"                  help=\"Be moderately verbose\")\n"
"parser.add_option(\"--file\", dest=\"filename\",\n"
"                  help=\"Input file to read data from\")\n"
"parser.add_option(\"--secret\", help=SUPPRESS_HELP)"

#: ../../library/optparse.rst:1274
msgid ""
"If :mod:`optparse` sees either ``-h`` or ``--help`` on the command line, it "
"will print something like the following help message to stdout (assuming "
"``sys.argv[0]`` is ``\"foo.py\"``):"
msgstr ""
"Se :mod:`optparse` encontrar ``-h`` ou ``--help`` na linha de comando, ele "
"vai exibir algo como a seguinte mensagem de ajuda no stdout (presumindo que "
"``sys.argv[0]`` é ``\"foo.py\"``):"

#: ../../library/optparse.rst:1278
msgid ""
"Usage: foo.py [options]\n"
"\n"
"Options:\n"
"  -h, --help        Show this help message and exit\n"
"  -v                Be moderately verbose\n"
"  --file=FILENAME   Input file to read data from"
msgstr ""
"Usage: foo.py [options]\n"
"\n"
"Options:\n"
"  -h, --help        Show this help message and exit\n"
"  -v                Be moderately verbose\n"
"  --file=FILENAME   Input file to read data from"

#: ../../library/optparse.rst:1287
msgid ""
"After printing the help message, :mod:`optparse` terminates your process "
"with ``sys.exit(0)``."
msgstr ""
"Após exibir a mensagem de ajuda, :mod:`optparse` encerra seu processo com "
"``sys.exit(0)``."

#: ../../library/optparse.rst:1290
msgid "``\"version\"``"
msgstr "``\"version\"``"

#: ../../library/optparse.rst:1292
msgid ""
"Prints the version number supplied to the OptionParser to stdout and exits. "
"The version number is actually formatted and printed by the "
"``print_version()`` method of OptionParser.  Generally only relevant if the "
"``version`` argument is supplied to the OptionParser constructor.  As with :"
"attr:`~Option.help` options, you will rarely create ``version`` options, "
"since :mod:`optparse` automatically adds them when needed."
msgstr ""
"Exibe o número da versão fornecido à instância de OptionParser para stdout e "
"sai. O número da versão é realmente formatado e exibido pelo método "
"``print_version()`` do OptionParser. Geralmente, é relevante somente se o "
"argumento ``version`` for fornecido ao construtor de OptionParser. Assim "
"como com as opções de :attr:`~Option.help`, você raramente criará opções "
"``version``, já que :mod:`optparse` as adiciona automaticamente quando "
"necessário."

#: ../../library/optparse.rst:1303
msgid "Standard option types"
msgstr "Tipos de opção padrão"

#: ../../library/optparse.rst:1305
msgid ""
":mod:`optparse` has five built-in option types: ``\"string\"``, ``\"int\"``, "
"``\"choice\"``, ``\"float\"`` and ``\"complex\"``.  If you need to add new "
"option types, see section :ref:`optparse-extending-optparse`."
msgstr ""
":mod:`optparse` tem cinco tipos de opções embutidos: ``\"string\"``, "
"``\"int\"``, ``\"choice\"``, ``\"float\"`` e ``\"complex\"``. Se você "
"precisar adicionar novos tipos de opções, veja a seção :ref:`optparse-"
"extending-optparse`."

#: ../../library/optparse.rst:1309
msgid ""
"Arguments to string options are not checked or converted in any way: the "
"text on the command line is stored in the destination (or passed to the "
"callback) as-is."
msgstr ""
"Os argumentos para opções de string não são verificados ou convertidos de "
"forma alguma: o texto na linha de comando é armazenado no destino (ou "
"passado para a função de retorno) como está."

#: ../../library/optparse.rst:1312
msgid "Integer arguments (type ``\"int\"``) are parsed as follows:"
msgstr ""
"Argumentos inteiros (tipo ``\"int\"``) são analisados ​​da seguinte forma:"

#: ../../library/optparse.rst:1314
msgid "if the number starts with ``0x``, it is parsed as a hexadecimal number"
msgstr ""
"se o número começar com ``0x``, ele será analisado como um número hexadecimal"

#: ../../library/optparse.rst:1316
msgid "if the number starts with ``0``, it is parsed as an octal number"
msgstr "se o número começar com ``0``, ele será analisado como um número octal"

#: ../../library/optparse.rst:1318
msgid "if the number starts with ``0b``, it is parsed as a binary number"
msgstr ""
"se o número começar com ``0b``, ele será analisado como um número binário"

#: ../../library/optparse.rst:1320
msgid "otherwise, the number is parsed as a decimal number"
msgstr "caso contrário, o número é analisado como um número decimal"

#: ../../library/optparse.rst:1323
msgid ""
"The conversion is done by calling :func:`int` with the appropriate base (2, "
"8, 10, or 16).  If this fails, so will :mod:`optparse`, although with a more "
"useful error message."
msgstr ""
"A conversão é feita chamando :func:`int` com a base apropriada (2, 8, 10 ou "
"16). Se isso falhar, :mod:`optparse` também falhará, embora com uma mensagem "
"de erro mais útil."

#: ../../library/optparse.rst:1327
msgid ""
"``\"float\"`` and ``\"complex\"`` option arguments are converted directly "
"with :func:`float` and :func:`complex`, with similar error-handling."
msgstr ""
"Os argumentos de opção ``\"float\"`` e ``\"complex\"`` são convertidos "
"diretamente com :func:`float` e :func:`complex`, com tratamento de erros "
"semelhante."

#: ../../library/optparse.rst:1330
msgid ""
"``\"choice\"`` options are a subtype of ``\"string\"`` options.  The :attr:"
"`~Option.choices` option attribute (a sequence of strings) defines the set "
"of allowed option arguments.  :func:`optparse.check_choice` compares user-"
"supplied option arguments against this master list and raises :exc:"
"`OptionValueError` if an invalid string is given."
msgstr ""
"As opções ``\"choice\"`` são um subtipo das opções ``\"string\"``. O "
"atributo da opção :attr:`~Option.choices` (uma sequência de strings) define "
"o conjunto de argumentos de opção permitidos. :func:`optparse.check_choice` "
"compara os argumentos de opção fornecidos pelo usuário com esta lista mestre "
"e levanta :exc:`OptionValueError` se uma string inválida for fornecida."

#: ../../library/optparse.rst:1340
msgid "Parsing arguments"
msgstr "Análise de argumentos"

#: ../../library/optparse.rst:1342
msgid ""
"The whole point of creating and populating an OptionParser is to call its :"
"meth:`~OptionParser.parse_args` method."
msgstr ""
"O objetivo de criar e preencher uma instância de OptionParser é chamar seu "
"método :meth:`~OptionParser.parse_args`."

#: ../../library/optparse.rst:1347
msgid "Parse the command-line options found in *args*."
msgstr "Analisa as opções de linha de comando encontradas em *args*."

#: ../../library/optparse.rst:1349
msgid "The input parameters are"
msgstr "Os parâmetros de entrada são"

#: ../../library/optparse.rst:1351 ../../library/optparse.rst:1365
#: ../../library/optparse.rst:1683
msgid "``args``"
msgstr "``args``"

#: ../../library/optparse.rst:1352
msgid "the list of arguments to process (default: ``sys.argv[1:]``)"
msgstr "a lista de argumentos para processar (padrão: ``sys.argv[1:]``)"

#: ../../library/optparse.rst:1354
msgid "``values``"
msgstr "``values``"

#: ../../library/optparse.rst:1355
msgid ""
"a :class:`Values` object to store option arguments in (default: a new "
"instance of :class:`Values`) -- if you give an existing object, the option "
"defaults will not be initialized on it"
msgstr ""
"um objeto :class:`Values` para armazenar argumentos de opção (padrão: uma "
"nova instância de :class:`Values`) -- se você fornecer um objeto existente, "
"os padrões de opção não serão inicializados nele"

#: ../../library/optparse.rst:1359
msgid "and the return value is a pair ``(options, args)`` where"
msgstr "e o valor de retorno é um par ``(options, args)`` sendo"

#: ../../library/optparse.rst:1361
msgid "``options``"
msgstr "``options``"

#: ../../library/optparse.rst:1362
msgid ""
"the same object that was passed in as *values*, or the ``optparse.Values`` "
"instance created by :mod:`optparse`"
msgstr ""
"o mesmo objeto que foi passado como *values*, ou a instância ``optparse."
"Values`` criada por :mod:`optparse`"

#: ../../library/optparse.rst:1366
msgid "the leftover positional arguments after all options have been processed"
msgstr ""
"os argumentos posicionais restantes depois que todas as opções foram "
"processadas"

#: ../../library/optparse.rst:1368
msgid ""
"The most common usage is to supply neither keyword argument.  If you supply "
"``values``, it will be modified with repeated :func:`setattr` calls (roughly "
"one for every option argument stored to an option destination) and returned "
"by :meth:`~OptionParser.parse_args`."
msgstr ""
"O uso mais comum é não fornecer nenhum argumento nomeado. Se você fornecer "
"``values``, ele será modificado com chamadas repetidas de :func:`setattr` "
"(aproximadamente uma para cada argumento de opção armazenado em um destino "
"de opção) e retornado por :meth:`~OptionParser.parse_args`."

#: ../../library/optparse.rst:1373
msgid ""
"If :meth:`~OptionParser.parse_args` encounters any errors in the argument "
"list, it calls the OptionParser's :meth:`error` method with an appropriate "
"end-user error message. This ultimately terminates your process with an exit "
"status of 2 (the traditional Unix exit status for command-line errors)."
msgstr ""
"Se :meth:`~OptionParser.parse_args` encontrar algum erro na lista de "
"argumentos, ele chama o método :meth:`error` da instância de OptionParser "
"com uma mensagem de erro apropriada para o usuário final. Isso, em última "
"análise, encerra seu processo com um status de saída 2 (o status de saída "
"tradicional do Unix para erros de linha de comando)."

#: ../../library/optparse.rst:1382
msgid "Querying and manipulating your option parser"
msgstr "Consultando e manipulando seu analisador sintático de opções"

#: ../../library/optparse.rst:1384
msgid ""
"The default behavior of the option parser can be customized slightly, and "
"you can also poke around your option parser and see what's there.  "
"OptionParser provides several methods to help you out:"
msgstr ""
"O comportamento padrão do analisador sintático de opções pode ser "
"ligeiramente personalizado, e você também pode dar uma olhada no seu "
"analisador de opções e ver o que há lá. A classe OptionParser fornece vários "
"métodos para ajudar você:"

#: ../../library/optparse.rst:1390
msgid ""
"Set parsing to stop on the first non-option.  For example, if ``-a`` and ``-"
"b`` are both simple options that take no arguments, :mod:`optparse` normally "
"accepts this syntax::"
msgstr ""
"Define a análise para parar na primeira não opção. Por exemplo, se ``-a`` e "
"``-b`` forem ambas opções simples que não aceitam argumentos, :mod:"
"`optparse` normalmente aceita esta sintaxe::"

#: ../../library/optparse.rst:1394
msgid "prog -a arg1 -b arg2"
msgstr "prog -a arg1 -b arg2"

#: ../../library/optparse.rst:1396
msgid "and treats it as equivalent to  ::"
msgstr "e trata-a como equivalente a ::"

#: ../../library/optparse.rst:1398
msgid "prog -a -b arg1 arg2"
msgstr "prog -a -b arg1 arg2"

#: ../../library/optparse.rst:1400
msgid ""
"To disable this feature, call :meth:`disable_interspersed_args`.  This "
"restores traditional Unix syntax, where option parsing stops with the first "
"non-option argument."
msgstr ""
"Para desabilitar esse recurso, chame :meth:`disable_interspersed_args`. Isso "
"restaura a sintaxe Unix tradicional, onde a análise de opções para com o "
"primeiro argumento não-opcional."

#: ../../library/optparse.rst:1404
msgid ""
"Use this if you have a command processor which runs another command which "
"has options of its own and you want to make sure these options don't get "
"confused.  For example, each command might have a different set of options."
msgstr ""
"Use isto se você tiver um processador de comando que executa outro comando "
"que tem opções próprias e você quer ter certeza de que essas opções não "
"fiquem confusas. Por exemplo, cada comando pode ter um conjunto diferente de "
"opções."

#: ../../library/optparse.rst:1410
msgid ""
"Set parsing to not stop on the first non-option, allowing interspersing "
"switches with command arguments.  This is the default behavior."
msgstr ""
"Define a análise para não parar na primeira não opção, permitindo intercalar "
"alternadores com argumentos de comando. Esse é o comportamento padrão."

#: ../../library/optparse.rst:1415
msgid ""
"Returns the Option instance with the option string *opt_str*, or ``None`` if "
"no options have that option string."
msgstr ""
"Retorna a instância de Option com a string de opção *opt_str*, ou ``None`` "
"se nenhuma opção tiver essa string de opção."

#: ../../library/optparse.rst:1420
msgid ""
"Return ``True`` if the OptionParser has an option with option string "
"*opt_str* (e.g., ``-q`` or ``--verbose``)."
msgstr ""
"Retorna ``True`` se o objeto OptionParser tiver uma opção com string de "
"opção *opt_str* (por exemplo, ``-q`` ou ``--verbose``)."

#: ../../library/optparse.rst:1425
msgid ""
"If the :class:`OptionParser` has an option corresponding to *opt_str*, that "
"option is removed.  If that option provided any other option strings, all of "
"those option strings become invalid. If *opt_str* does not occur in any "
"option belonging to this :class:`OptionParser`, raises :exc:`ValueError`."
msgstr ""
"Se o :class:`OptionParser` tiver uma opção correspondente a *opt_str*, essa "
"opção será removida. Se essa opção fornecer quaisquer outras strings de "
"opção, todas essas strings de opção se tornarão inválidas. Se *opt_str* não "
"ocorrer em nenhuma opção pertencente a este :class:`OptionParser`, levanta :"
"exc:`ValueError`."

#: ../../library/optparse.rst:1434
msgid "Conflicts between options"
msgstr "Conflitos entre opções"

#: ../../library/optparse.rst:1436
msgid ""
"If you're not careful, it's easy to define options with conflicting option "
"strings::"
msgstr ""
"Se você não tomar cuidado, é fácil definir opções com strings de opções "
"conflitantes::"

#: ../../library/optparse.rst:1439
msgid ""
"parser.add_option(\"-n\", \"--dry-run\", ...)\n"
"...\n"
"parser.add_option(\"-n\", \"--noisy\", ...)"
msgstr ""
"parser.add_option(\"-n\", \"--dry-run\", ...)\n"
"...\n"
"parser.add_option(\"-n\", \"--noisy\", ...)"

#: ../../library/optparse.rst:1443
msgid ""
"(This is particularly true if you've defined your own OptionParser subclass "
"with some standard options.)"
msgstr ""
"(Isto é particularmente verdadeiro se você definiu sua própria subclasse de "
"OptionParser com algumas opções padrão.)"

#: ../../library/optparse.rst:1446
msgid ""
"Every time you add an option, :mod:`optparse` checks for conflicts with "
"existing options.  If it finds any, it invokes the current conflict-handling "
"mechanism. You can set the conflict-handling mechanism either in the "
"constructor::"
msgstr ""
"Toda vez que você adiciona uma opção, :mod:`optparse` verifica se há "
"conflitos com opções existentes. Se encontrar algum, ele invoca o mecanismo "
"de tratamento de conflitos atual. Você pode definir o mecanismo de "
"tratamento de conflitos no construtor::"

#: ../../library/optparse.rst:1450
msgid "parser = OptionParser(..., conflict_handler=handler)"
msgstr "parser = OptionParser(..., conflict_handler=handler)"

#: ../../library/optparse.rst:1452
msgid "or with a separate call::"
msgstr "ou com uma chamada separada::"

#: ../../library/optparse.rst:1454
msgid "parser.set_conflict_handler(handler)"
msgstr "parser.set_conflict_handler(handler)"

#: ../../library/optparse.rst:1456
msgid "The available conflict handlers are:"
msgstr "Os manipuladores de conflitos disponíveis são:"

#: ../../library/optparse.rst:1458
msgid "``\"error\"`` (default)"
msgstr "``\"error\"`` (padrão)"

#: ../../library/optparse.rst:1459
msgid ""
"assume option conflicts are a programming error and raise :exc:"
"`OptionConflictError`"
msgstr ""
"presume que os conflitos de opções são um erro de programação e levanta :exc:"
"`OptionConflictError`"

#: ../../library/optparse.rst:1462
msgid "``\"resolve\"``"
msgstr "``\"resolve\"``"

#: ../../library/optparse.rst:1463
msgid "resolve option conflicts intelligently (see below)"
msgstr "resolve conflitos de opções de forma inteligente (veja abaixo)"

#: ../../library/optparse.rst:1466
msgid ""
"As an example, let's define an :class:`OptionParser` that resolves conflicts "
"intelligently and add conflicting options to it::"
msgstr ""
"Como exemplo, vamos definir um :class:`OptionParser` que resolve conflitos "
"de forma inteligente e adiciona opções conflitantes a ele::"

#: ../../library/optparse.rst:1469
msgid ""
"parser = OptionParser(conflict_handler=\"resolve\")\n"
"parser.add_option(\"-n\", \"--dry-run\", ..., help=\"do no harm\")\n"
"parser.add_option(\"-n\", \"--noisy\", ..., help=\"be noisy\")"
msgstr ""
"parser = OptionParser(conflict_handler=\"resolve\")\n"
"parser.add_option(\"-n\", \"--dry-run\", ..., help=\"do no harm\")\n"
"parser.add_option(\"-n\", \"--noisy\", ..., help=\"be noisy\")"

#: ../../library/optparse.rst:1473
msgid ""
"At this point, :mod:`optparse` detects that a previously added option is "
"already using the ``-n`` option string.  Since ``conflict_handler`` is "
"``\"resolve\"``, it resolves the situation by removing ``-n`` from the "
"earlier option's list of option strings.  Now ``--dry-run`` is the only way "
"for the user to activate that option.  If the user asks for help, the help "
"message will reflect that::"
msgstr ""
"Neste ponto, :mod:`optparse` detecta que uma opção adicionada anteriormente "
"já está usando a string de opção ``-n``. Como ``conflict_handler`` é "
"``\"resolve\"``, ele resolve a situação removendo ``-n`` da lista de strings "
"de opção da opção anterior. Agora ``--dry-run`` é a única maneira do usuário "
"ativar essa opção. Se o usuário pedir ajuda, a mensagem de ajuda refletirá "
"isso::"

#: ../../library/optparse.rst:1479
msgid ""
"Options:\n"
"  --dry-run     do no harm\n"
"  ...\n"
"  -n, --noisy   be noisy"
msgstr ""
"Options:\n"
"  --dry-run     do no harm\n"
"  ...\n"
"  -n, --noisy   be noisy"

#: ../../library/optparse.rst:1484
msgid ""
"It's possible to whittle away the option strings for a previously added "
"option until there are none left, and the user has no way of invoking that "
"option from the command-line.  In that case, :mod:`optparse` removes that "
"option completely, so it doesn't show up in help text or anywhere else. "
"Carrying on with our existing OptionParser::"
msgstr ""
"É possível reduzir as strings de opção para uma opção adicionada "
"anteriormente até que não haja mais nenhuma, e o usuário não tenha como "
"invocar essa opção da linha de comando. Nesse caso, :mod:`optparse` remove "
"essa opção completamente, então ela não aparece no texto de ajuda ou em "
"nenhum outro lugar. Continuando com nosso objeto OptionParser existente::"

#: ../../library/optparse.rst:1490
msgid "parser.add_option(\"--dry-run\", ..., help=\"new dry-run option\")"
msgstr "parser.add_option(\"--dry-run\", ..., help=\"new dry-run option\")"

#: ../../library/optparse.rst:1492
msgid ""
"At this point, the original ``-n``/``--dry-run`` option is no longer "
"accessible, so :mod:`optparse` removes it, leaving this help text::"
msgstr ""
"Neste ponto, a opção original ``-n``/``--dry-run`` não está mais acessível, "
"então :mod:`optparse` a remove, deixando este texto de ajuda::"

#: ../../library/optparse.rst:1495
msgid ""
"Options:\n"
"  ...\n"
"  -n, --noisy   be noisy\n"
"  --dry-run     new dry-run option"
msgstr ""
"Options:\n"
"  ...\n"
"  -n, --noisy   be noisy\n"
"  --dry-run     new dry-run option"

#: ../../library/optparse.rst:1504
msgid "Cleanup"
msgstr "Limpeza"

#: ../../library/optparse.rst:1506
msgid ""
"OptionParser instances have several cyclic references.  This should not be a "
"problem for Python's garbage collector, but you may wish to break the cyclic "
"references explicitly by calling :meth:`~OptionParser.destroy` on your "
"OptionParser once you are done with it.  This is particularly useful in long-"
"running applications where large object graphs are reachable from your "
"OptionParser."
msgstr ""
"As instâncias de OptionParser têm várias referências cíclicas. Isso não deve "
"ser um problema para o coletor de lixo do Python, mas você pode desejar "
"quebrar as referências cíclicas explicitamente chamando :meth:`~OptionParser."
"destroy` no seu OptionParser quando terminar de usá-lo. Isso é "
"particularmente útil em aplicações de longa execução, onde gráficos de "
"objetos grandes podem ser acessados ​​do seu OptionParser."

#: ../../library/optparse.rst:1517
msgid "Other methods"
msgstr "Outros métodos"

#: ../../library/optparse.rst:1519
msgid "OptionParser supports several other public methods:"
msgstr "OptionParser provê vários outros métodos públicos:"

#: ../../library/optparse.rst:1523
msgid ""
"Set the usage string according to the rules described above for the "
"``usage`` constructor keyword argument.  Passing ``None`` sets the default "
"usage string; use :const:`optparse.SUPPRESS_USAGE` to suppress a usage "
"message."
msgstr ""
"Defina a string de uso de acordo com as regras descritas acima para o "
"argumento nomeado do construtor ``usage``. Passar ``None`` define a string "
"de uso padrão; use :const:`optparse.SUPPRESS_USAGE` para suprimir uma "
"mensagem de uso."

#: ../../library/optparse.rst:1529
msgid ""
"Print the usage message for the current program (``self.usage``) to *file* "
"(default stdout).  Any occurrence of the string ``%prog`` in ``self.usage`` "
"is replaced with the name of the current program.  Does nothing if ``self."
"usage`` is empty or not defined."
msgstr ""
"Exibe a mensagem de uso para o programa atual (``self.usage``) em *file* "
"(stdout padrão). Qualquer ocorrência da string ``%prog`` em ``self.usage`` é "
"substituída pelo nome do programa atual. Não faz nada se ``self.usage`` "
"estiver vazio ou não definido."

#: ../../library/optparse.rst:1536
msgid ""
"Same as :meth:`print_usage` but returns the usage string instead of printing "
"it."
msgstr ""
"O mesmo que :meth:`print_usage`, mas retorna a string de uso em vez de exibi-"
"la."

#: ../../library/optparse.rst:1541
msgid ""
"Set default values for several option destinations at once.  Using :meth:"
"`set_defaults` is the preferred way to set default values for options, since "
"multiple options can share the same destination.  For example, if several "
"\"mode\" options all set the same destination, any one of them can set the "
"default, and the last one wins::"
msgstr ""
"Define valores padrão para vários destinos de opção de uma vez. Usar :meth:"
"`set_defaults` é a maneira preferida de definir valores padrão para opções, "
"já que várias opções podem compartilhar o mesmo destino. Por exemplo, se "
"várias opções de \"modo\" definirem o mesmo destino, qualquer uma delas pode "
"definir o padrão, e a última vence::"

#: ../../library/optparse.rst:1547
msgid ""
"parser.add_option(\"--advanced\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"advanced\",\n"
"                  default=\"novice\")    # overridden below\n"
"parser.add_option(\"--novice\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"novice\",\n"
"                  default=\"advanced\")  # overrides above setting"
msgstr ""
"parser.add_option(\"--advanced\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"advanced\",\n"
"                  default=\"novice\")    # substituída abaixo\n"
"parser.add_option(\"--novice\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"novice\",\n"
"                  default=\"advanced\")  # substitui a configuração acima"

#: ../../library/optparse.rst:1554
msgid "To avoid this confusion, use :meth:`set_defaults`::"
msgstr "Para evitar essa confusão, use :meth:`set_defaults`::"

#: ../../library/optparse.rst:1556
msgid ""
"parser.set_defaults(mode=\"advanced\")\n"
"parser.add_option(\"--advanced\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"advanced\")\n"
"parser.add_option(\"--novice\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"novice\")"
msgstr ""
"parser.set_defaults(mode=\"advanced\")\n"
"parser.add_option(\"--advanced\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"advanced\")\n"
"parser.add_option(\"--novice\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"novice\")"

#: ../../library/optparse.rst:1566
msgid "Option Callbacks"
msgstr "Funções de retorno de opção"

#: ../../library/optparse.rst:1568
msgid ""
"When :mod:`optparse`'s built-in actions and types aren't quite enough for "
"your needs, you have two choices: extend :mod:`optparse` or define a "
"callback option. Extending :mod:`optparse` is more general, but overkill for "
"a lot of simple cases.  Quite often a simple callback is all you need."
msgstr ""
"Quando as ações e tipos embutidos de :mod:`optparse` não são o bastante para "
"suas necessidades, você tem duas escolhas: estender :mod:`optparse` ou "
"definir uma opção de retorno de chamada. Estender :mod:`optparse` é mais "
"geral, mas exagero para muitos casos simples. Muitas vezes, um retorno de "
"chamada simples é tudo o que você precisa."

#: ../../library/optparse.rst:1573
msgid "There are two steps to defining a callback option:"
msgstr "Há duas etapas para definir uma opção de retorno de chamada:"

#: ../../library/optparse.rst:1575
msgid "define the option itself using the ``\"callback\"`` action"
msgstr "definir a opção em si usando a ação ``\"callback\"``"

#: ../../library/optparse.rst:1577
msgid ""
"write the callback; this is a function (or method) that takes at least four "
"arguments, as described below"
msgstr ""
"escrever o função de retorno; esta é uma função (ou método) que recebe pelo "
"menos quatro argumentos, conforme descrito abaixo"

#: ../../library/optparse.rst:1584
msgid "Defining a callback option"
msgstr "Definindo uma opção de retorno de chamada"

#: ../../library/optparse.rst:1586
msgid ""
"As always, the easiest way to define a callback option is by using the :meth:"
"`OptionParser.add_option` method.  Apart from :attr:`~Option.action`, the "
"only option attribute you must specify is ``callback``, the function to "
"call::"
msgstr ""
"Como sempre, a maneira mais fácil de definir uma opção de retorno de chamada "
"é usando o método :meth:`OptionParser.add_option`. Além de :attr:`~Option."
"action`, o único atributo de opção que você deve especificar é ``callback``, "
"a função a ser chamada::"

#: ../../library/optparse.rst:1590
msgid "parser.add_option(\"-c\", action=\"callback\", callback=my_callback)"
msgstr "parser.add_option(\"-c\", action=\"callback\", callback=my_callback)"

#: ../../library/optparse.rst:1592
msgid ""
"``callback`` is a function (or other callable object), so you must have "
"already defined ``my_callback()`` when you create this callback option. In "
"this simple case, :mod:`optparse` doesn't even know if ``-c`` takes any "
"arguments, which usually means that the option takes no arguments---the mere "
"presence of ``-c`` on the command-line is all it needs to know.  In some "
"circumstances, though, you might want your callback to consume an arbitrary "
"number of command-line arguments.  This is where writing callbacks gets "
"tricky; it's covered later in this section."
msgstr ""
"``callback`` é uma função (ou outro objeto chamável), então você já deve ter "
"definido ``my_callback()`` quando criar esta opção de retorno de chamada. "
"Neste caso simples, :mod:`optparse` nem sabe se ``-c`` aceita argumentos, o "
"que geralmente significa que a opção não aceita argumentos --- a mera "
"presença de ``-c`` na linha de comando é tudo o que ela precisa saber. Em "
"algumas circunstâncias, no entanto, você pode querer que seu retorno de "
"chamada consuma um número arbitrário de argumentos de linha de comando. É "
"aqui que escrever retornos de chamada fica complicado; isso é abordado mais "
"adiante nesta seção."

#: ../../library/optparse.rst:1601
msgid ""
":mod:`optparse` always passes four particular arguments to your callback, "
"and it will only pass additional arguments if you specify them via :attr:"
"`~Option.callback_args` and :attr:`~Option.callback_kwargs`.  Thus, the "
"minimal callback function signature is::"
msgstr ""
":mod:`optparse` sempre passa quatro argumentos particulares para seu retorno "
"de chamada, e ele só passará argumentos adicionais se você especificá-los "
"via :attr:`~Option.callback_args` e :attr:`~Option.callback_kwargs`. Assim, "
"a assinatura mínima da função de retorno de chamada é::"

#: ../../library/optparse.rst:1606
msgid "def my_callback(option, opt, value, parser):"
msgstr "def my_callback(option, opt, value, parser):"

#: ../../library/optparse.rst:1608
msgid "The four arguments to a callback are described below."
msgstr "Os quatro argumentos para um retorno de chamada são descritos abaixo."

#: ../../library/optparse.rst:1610
msgid ""
"There are several other option attributes that you can supply when you "
"define a callback option:"
msgstr ""
"Há vários outros atributos de opção que você pode fornecer ao definir uma "
"opção de retorno de chamada:"

#: ../../library/optparse.rst:1613
msgid ":attr:`~Option.type`"
msgstr ":attr:`~Option.type`"

#: ../../library/optparse.rst:1614
msgid ""
"has its usual meaning: as with the ``\"store\"`` or ``\"append\"`` actions, "
"it instructs :mod:`optparse` to consume one argument and convert it to :attr:"
"`~Option.type`.  Rather than storing the converted value(s) anywhere, "
"though, :mod:`optparse` passes it to your callback function."
msgstr ""
"tem seu significado usual: como com as ações ``\"store\"`` ou "
"``\"append\"``, ele instrui :mod:`optparse` a consumir um argumento e "
"convertê-lo para :attr:`~Option.type`. Em vez de armazenar o(s) valor(es) "
"convertido(s) em qualquer lugar, no entanto, :mod:`optparse` os passa para "
"sua função de retorno de chamada."

#: ../../library/optparse.rst:1619
msgid ":attr:`~Option.nargs`"
msgstr ":attr:`~Option.nargs`"

#: ../../library/optparse.rst:1620
msgid ""
"also has its usual meaning: if it is supplied and > 1, :mod:`optparse` will "
"consume :attr:`~Option.nargs` arguments, each of which must be convertible "
"to :attr:`~Option.type`.  It then passes a tuple of converted values to your "
"callback."
msgstr ""
"também tem seu significado usual: se for fornecido e > 1, :mod:`optparse` "
"consumirá argumentos :attr:`~Option.nargs`, cada um dos quais deve ser "
"conversível para :attr:`~Option.type`. Em seguida, ele passa uma tupla de "
"valores convertidos para seu retorno de chamada."

#: ../../library/optparse.rst:1625
msgid ":attr:`~Option.callback_args`"
msgstr ":attr:`~Option.callback_args`"

#: ../../library/optparse.rst:1626
msgid "a tuple of extra positional arguments to pass to the callback"
msgstr ""
"uma tupla de argumentos posicionais extras para passar para a função de "
"retorno"

#: ../../library/optparse.rst:1628
msgid ":attr:`~Option.callback_kwargs`"
msgstr ":attr:`~Option.callback_kwargs`"

#: ../../library/optparse.rst:1629
msgid "a dictionary of extra keyword arguments to pass to the callback"
msgstr ""
"um dicionário de argumentos nomeados extras para passar para a função de "
"retorno"

#: ../../library/optparse.rst:1635
msgid "How callbacks are called"
msgstr "Como os retornos de chamada são chamados"

#: ../../library/optparse.rst:1637
msgid "All callbacks are called as follows::"
msgstr "Todos os retornos de chamada são chamados da seguinte forma:"

#: ../../library/optparse.rst:1643
msgid "``option``"
msgstr "``option``"

#: ../../library/optparse.rst:1644
msgid "is the Option instance that's calling the callback"
msgstr "é a instância de Option que está chamando o retorno de chamada"

#: ../../library/optparse.rst:1646
msgid "``opt_str``"
msgstr "``opt_str``"

#: ../../library/optparse.rst:1647
msgid ""
"is the option string seen on the command-line that's triggering the "
"callback. (If an abbreviated long option was used, ``opt_str`` will be the "
"full, canonical option string---e.g. if the user puts ``--foo`` on the "
"command-line as an abbreviation for ``--foobar``, then ``opt_str`` will be "
"``\"--foobar\"``.)"
msgstr ""
"é a string de opção vista na linha de comando que está acionando o retorno "
"de chamada. (Se uma opção longa abreviada foi usada, ``opt_str`` será a "
"string de opção canônica completa --- por exemplo, se o usuário colocar ``--"
"foo`` na linha de comando como uma abreviação para ``--foobar``, então "
"``opt_str`` será ``\"--foobar\"``.)"

#: ../../library/optparse.rst:1653
msgid "``value``"
msgstr "``value``"

#: ../../library/optparse.rst:1654
msgid ""
"is the argument to this option seen on the command-line.  :mod:`optparse` "
"will only expect an argument if :attr:`~Option.type` is set; the type of "
"``value`` will be the type implied by the option's type.  If :attr:`~Option."
"type` for this option is ``None`` (no argument expected), then ``value`` "
"will be ``None``.  If :attr:`~Option.nargs` > 1, ``value`` will be a tuple "
"of values of the appropriate type."
msgstr ""
"é o argumento para esta opção visto na linha de comando. :mod:`optparse` só "
"esperará um argumento se :attr:`~Option.type` estiver definido; o tipo de "
"``value`` será o tipo implícito pelo tipo da opção. Se :attr:`~Option.type` "
"para esta opção for ``None`` (nenhum argumento esperado), então ``value`` "
"será ``None``. Se :attr:`~Option.nargs` > 1, ``value`` será uma tupla de "
"valores do tipo apropriado."

#: ../../library/optparse.rst:1660
msgid "``parser``"
msgstr "``parser``"

#: ../../library/optparse.rst:1661
msgid ""
"is the OptionParser instance driving the whole thing, mainly useful because "
"you can access some other interesting data through its instance attributes:"
msgstr ""
"é a instância OptionParser que controla tudo, útil principalmente porque "
"você pode acessar alguns outros dados interessantes por meio de seus "
"atributos de instância:"

#: ../../library/optparse.rst:1664
msgid "``parser.largs``"
msgstr "``parser.largs``"

#: ../../library/optparse.rst:1665
msgid ""
"the current list of leftover arguments, ie. arguments that have been "
"consumed but are neither options nor option arguments. Feel free to modify "
"``parser.largs``, e.g. by adding more arguments to it.  (This list will "
"become ``args``, the second return value of :meth:`~OptionParser."
"parse_args`.)"
msgstr ""
"a lista atual de argumentos restantes, ou seja, argumentos que foram "
"consumidos, mas não são opções nem argumentos de opção. Sinta-se à vontade "
"para modificar ``parser.largs``, por exemplo, adicionando mais argumentos a "
"ele. (Esta lista se tornará ``args``, o segundo valor de retorno de :meth:"
"`~OptionParser.parse_args`.)"

#: ../../library/optparse.rst:1670
msgid "``parser.rargs``"
msgstr "``parser.rargs``"

#: ../../library/optparse.rst:1671
msgid ""
"the current list of remaining arguments, ie. with ``opt_str`` and ``value`` "
"(if applicable) removed, and only the arguments following them still there.  "
"Feel free to modify ``parser.rargs``, e.g. by consuming more arguments."
msgstr ""
"a lista atual de argumentos restantes, ou seja, com ``opt_str`` e ``value`` "
"(se aplicável) removidos, e apenas os argumentos que os seguem ainda lá. "
"Sinta-se à vontade para modificar ``parser.rargs``, por exemplo, consumindo "
"mais argumentos."

#: ../../library/optparse.rst:1676
msgid "``parser.values``"
msgstr "``parser.values``"

#: ../../library/optparse.rst:1677
msgid ""
"the object where option values are by default stored (an instance of "
"optparse.OptionValues).  This lets callbacks use the same mechanism as the "
"rest of :mod:`optparse` for storing option values; you don't need to mess "
"around with globals or closures.  You can also access or modify the value(s) "
"of any options already encountered on the command-line."
msgstr ""
"o objeto onde os valores de opção são armazenados por padrão (uma instância "
"de optparse.OptionValues). Isso permite que as função de retorno usem o "
"mesmo mecanismo que o resto de :mod:`optparse` para armazenar valores de "
"opção; você não precisa mexer com globais ou closures. Você também pode "
"acessar ou modificar o(s) valor(es) de quaisquer opções já encontradas na "
"linha de comando."

#: ../../library/optparse.rst:1684
msgid ""
"is a tuple of arbitrary positional arguments supplied via the :attr:`~Option."
"callback_args` option attribute."
msgstr ""
"é uma tupla de argumentos posicionais arbitrários fornecidos por meio do "
"atributo de opção :attr:`~Option.callback_args`."

#: ../../library/optparse.rst:1687
msgid "``kwargs``"
msgstr "``kwargs``"

#: ../../library/optparse.rst:1688
msgid ""
"is a dictionary of arbitrary keyword arguments supplied via :attr:`~Option."
"callback_kwargs`."
msgstr ""
"é um dicionário de argumentos nomeados arbitrários fornecidos via :attr:"
"`~Option.callback_kwargs`."

#: ../../library/optparse.rst:1695
msgid "Raising errors in a callback"
msgstr "Levantando erros em uma função de retorno"

#: ../../library/optparse.rst:1697
msgid ""
"The callback function should raise :exc:`OptionValueError` if there are any "
"problems with the option or its argument(s).  :mod:`optparse` catches this "
"and terminates the program, printing the error message you supply to "
"stderr.  Your message should be clear, concise, accurate, and mention the "
"option at fault. Otherwise, the user will have a hard time figuring out what "
"they did wrong."
msgstr ""
"A função de retorno de chamada deve levantar :exc:`OptionValueError` se "
"houver algum problema com a opção ou seu(s) argumento(s). :mod:`optparse` "
"captura isso e encerra o programa, exibindo a mensagem de erro que você "
"fornece para stderr. Sua mensagem deve ser clara, concisa, precisa e "
"mencionar a opção com defeito. Caso contrário, o usuário terá dificuldade em "
"descobrir o que fez de errado."

#: ../../library/optparse.rst:1707
msgid "Callback example 1: trivial callback"
msgstr "Exemplo de função de retorno 1: retorno de chamada trivial"

#: ../../library/optparse.rst:1709
msgid ""
"Here's an example of a callback option that takes no arguments, and simply "
"records that the option was seen::"
msgstr ""
"Aqui está um exemplo de uma opção de retorno de chamada que não aceita "
"argumentos e simplesmente registra que a opção foi vista:"

#: ../../library/optparse.rst:1712
msgid ""
"def record_foo_seen(option, opt_str, value, parser):\n"
"    parser.values.saw_foo = True\n"
"\n"
"parser.add_option(\"--foo\", action=\"callback\", callback=record_foo_seen)"
msgstr ""
"def record_foo_seen(option, opt_str, value, parser):\n"
"    parser.values.saw_foo = True\n"
"\n"
"parser.add_option(\"--foo\", action=\"callback\", callback=record_foo_seen)"

#: ../../library/optparse.rst:1717
msgid "Of course, you could do that with the ``\"store_true\"`` action."
msgstr "Claro, você pode fazer isso com a ação ``\"store_true\"``."

#: ../../library/optparse.rst:1723
msgid "Callback example 2: check option order"
msgstr "Exemplo de função de retorno 2: verificar a ordem das opções"

#: ../../library/optparse.rst:1725
msgid ""
"Here's a slightly more interesting example: record the fact that ``-a`` is "
"seen, but blow up if it comes after ``-b`` in the command-line.  ::"
msgstr ""
"Aqui está um exemplo um pouco mais interessante: registra o fato de que ``-"
"a`` é visto, mas explode se ele vier depois de ``-b`` na linha de comando. ::"

#: ../../library/optparse.rst:1728
msgid ""
"def check_order(option, opt_str, value, parser):\n"
"    if parser.values.b:\n"
"        raise OptionValueError(\"can't use -a after -b\")\n"
"    parser.values.a = 1\n"
"...\n"
"parser.add_option(\"-a\", action=\"callback\", callback=check_order)\n"
"parser.add_option(\"-b\", action=\"store_true\", dest=\"b\")"
msgstr ""
"def check_order(option, opt_str, value, parser):\n"
"    if parser.values.b:\n"
"        raise OptionValueError(\"can't use -a after -b\")\n"
"    parser.values.a = 1\n"
"...\n"
"parser.add_option(\"-a\", action=\"callback\", callback=check_order)\n"
"parser.add_option(\"-b\", action=\"store_true\", dest=\"b\")"

#: ../../library/optparse.rst:1740
msgid "Callback example 3: check option order (generalized)"
msgstr ""
"Exemplo 3 de função de retorno: verificar a ordem das opções (generalizada)"

#: ../../library/optparse.rst:1742
msgid ""
"If you want to reuse this callback for several similar options (set a flag, "
"but blow up if ``-b`` has already been seen), it needs a bit of work: the "
"error message and the flag that it sets must be generalized.  ::"
msgstr ""
"Se você quiser reutilizar essa função de retorno para várias opções "
"semelhantes (definir um sinalizador, mas explodir se ``-b`` já tiver sido "
"visto), será preciso um pouco de trabalho: a mensagem de erro e o "
"sinalizador que ele define devem ser generalizados. ::"

#: ../../library/optparse.rst:1746
msgid ""
"def check_order(option, opt_str, value, parser):\n"
"    if parser.values.b:\n"
"        raise OptionValueError(\"can't use %s after -b\" % opt_str)\n"
"    setattr(parser.values, option.dest, 1)\n"
"...\n"
"parser.add_option(\"-a\", action=\"callback\", callback=check_order, "
"dest='a')\n"
"parser.add_option(\"-b\", action=\"store_true\", dest=\"b\")\n"
"parser.add_option(\"-c\", action=\"callback\", callback=check_order, "
"dest='c')"
msgstr ""
"def check_order(option, opt_str, value, parser):\n"
"    if parser.values.b:\n"
"        raise OptionValueError(\"can't use %s after -b\" % opt_str)\n"
"    setattr(parser.values, option.dest, 1)\n"
"...\n"
"parser.add_option(\"-a\", action=\"callback\", callback=check_order, "
"dest='a')\n"
"parser.add_option(\"-b\", action=\"store_true\", dest=\"b\")\n"
"parser.add_option(\"-c\", action=\"callback\", callback=check_order, "
"dest='c')"

#: ../../library/optparse.rst:1759
msgid "Callback example 4: check arbitrary condition"
msgstr "Exemplo de função de retorno 4: verificar uma condição arbitrária"

#: ../../library/optparse.rst:1761
msgid ""
"Of course, you could put any condition in there---you're not limited to "
"checking the values of already-defined options.  For example, if you have "
"options that should not be called when the moon is full, all you have to do "
"is this::"
msgstr ""
"Claro, você pode colocar qualquer condição ali---você não está limitado a "
"verificar os valores de opções já definidas. Por exemplo, se você tem opções "
"que não devem ser chamadas quando a lua está cheia, tudo o que você tem a "
"fazer é isto::"

#: ../../library/optparse.rst:1765
msgid ""
"def check_moon(option, opt_str, value, parser):\n"
"    if is_moon_full():\n"
"        raise OptionValueError(\"%s option invalid when moon is full\"\n"
"                               % opt_str)\n"
"    setattr(parser.values, option.dest, 1)\n"
"...\n"
"parser.add_option(\"--foo\",\n"
"                  action=\"callback\", callback=check_moon, dest=\"foo\")"
msgstr ""
"def check_moon(option, opt_str, value, parser):\n"
"    if is_moon_full():\n"
"        raise OptionValueError(\"%s option invalid when moon is full\"\n"
"                               % opt_str)\n"
"    setattr(parser.values, option.dest, 1)\n"
"...\n"
"parser.add_option(\"--foo\",\n"
"                  action=\"callback\", callback=check_moon, dest=\"foo\")"

#: ../../library/optparse.rst:1774
msgid ""
"(The definition of ``is_moon_full()`` is left as an exercise for the reader.)"
msgstr ""
"(A definição de ``is_moon_full()`` é deixada como um exercício para o "
"leitor.)"

#: ../../library/optparse.rst:1780
msgid "Callback example 5: fixed arguments"
msgstr "Exemplo de função de retorno 5: argumentos fixos"

#: ../../library/optparse.rst:1782
msgid ""
"Things get slightly more interesting when you define callback options that "
"take a fixed number of arguments.  Specifying that a callback option takes "
"arguments is similar to defining a ``\"store\"`` or ``\"append\"`` option: "
"if you define :attr:`~Option.type`, then the option takes one argument that "
"must be convertible to that type; if you further define :attr:`~Option."
"nargs`, then the option takes :attr:`~Option.nargs` arguments."
msgstr ""
"As coisas ficam um pouco mais interessantes quando você define opções de "
"retorno de chamada que aceitam um número fixo de argumentos. Especificar que "
"uma opção de retorno de chamada aceita argumentos é semelhante a definir uma "
"opção ``\"store\"`` ou ``\"append\"``: se você definir :attr:`~Option.type`, "
"então a opção aceita um argumento que deve ser conversível para esse tipo; "
"se você definir ainda :attr:`~Option.nargs`, então a opção aceita "
"argumentos :attr:`~Option.nargs`."

#: ../../library/optparse.rst:1789
msgid ""
"Here's an example that just emulates the standard ``\"store\"`` action::"
msgstr "Aqui está um exemplo que apenas emula a ação padrão ``\"store\"``::"

#: ../../library/optparse.rst:1791
msgid ""
"def store_value(option, opt_str, value, parser):\n"
"    setattr(parser.values, option.dest, value)\n"
"...\n"
"parser.add_option(\"--foo\",\n"
"                  action=\"callback\", callback=store_value,\n"
"                  type=\"int\", nargs=3, dest=\"foo\")"
msgstr ""
"def store_value(option, opt_str, value, parser):\n"
"    setattr(parser.values, option.dest, value)\n"
"...\n"
"parser.add_option(\"--foo\",\n"
"                  action=\"callback\", callback=store_value,\n"
"                  type=\"int\", nargs=3, dest=\"foo\")"

#: ../../library/optparse.rst:1798
msgid ""
"Note that :mod:`optparse` takes care of consuming 3 arguments and converting "
"them to integers for you; all you have to do is store them.  (Or whatever; "
"obviously you don't need a callback for this example.)"
msgstr ""
"Note que :mod:`optparse` cuida de consumir 3 argumentos e convertê-los em "
"números inteiros para você; tudo o que você precisa fazer é armazená-los. "
"(Ou o que for; obviamente você não precisa de uma função de retorno de "
"chamada para este exemplo.)"

#: ../../library/optparse.rst:1806
msgid "Callback example 6: variable arguments"
msgstr "Exemplo de função de retorno 6: argumentos variáveis"

#: ../../library/optparse.rst:1808
msgid ""
"Things get hairy when you want an option to take a variable number of "
"arguments. For this case, you must write a callback, as :mod:`optparse` "
"doesn't provide any built-in capabilities for it.  And you have to deal with "
"certain intricacies of conventional Unix command-line parsing that :mod:"
"`optparse` normally handles for you.  In particular, callbacks should "
"implement the conventional rules for bare ``--`` and ``-`` arguments:"
msgstr ""
"As coisas ficam complicadas quando você quer que uma opção receba um número "
"variável de argumentos. Para esse caso, você deve escrever uma função de "
"retorno, pois :mod:`optparse` não fornece nenhuma capacidade embutida para "
"ele. E você tem que lidar com certas complexidades da análise sintática de "
"linha de comando Unix convencional que :mod:`optparse` normalmente lida para "
"você. Em particular, as funções de retorno devem implementar as regras "
"convencionais para argumentos ``--`` e ``-`` simples:"

#: ../../library/optparse.rst:1815
msgid "either ``--`` or ``-`` can be option arguments"
msgstr "``--`` ou ``-`` podem ser argumentos de opção"

#: ../../library/optparse.rst:1817
msgid ""
"bare ``--`` (if not the argument to some option): halt command-line "
"processing and discard the ``--``"
msgstr ""
"``--`` apenas (se não for o argumento para alguma opção): interrompe o "
"processamento da linha de comando e descarta o ``--``"

#: ../../library/optparse.rst:1820
msgid ""
"bare ``-`` (if not the argument to some option): halt command-line "
"processing but keep the ``-`` (append it to ``parser.largs``)"
msgstr ""
"``-`` apenas (se não for o argumento para alguma opção): interrompe o "
"processamento da linha de comando, mas mantém o ``-`` (anexa-o a ``parser."
"largs``)"

#: ../../library/optparse.rst:1823
msgid ""
"If you want an option that takes a variable number of arguments, there are "
"several subtle, tricky issues to worry about.  The exact implementation you "
"choose will be based on which trade-offs you're willing to make for your "
"application (which is why :mod:`optparse` doesn't support this sort of thing "
"directly)."
msgstr ""
"Se você quiser uma opção que aceite um número variável de argumentos, há "
"várias questões sutis e complicadas com as quais se preocupar. A "
"implementação exata que você escolher será baseada em quais compensações "
"você está disposto a fazer para sua aplicação (é por isso que :mod:"
"`optparse` não oferece suporte a esse tipo de coisa diretamente)."

#: ../../library/optparse.rst:1829
msgid ""
"Nevertheless, here's a stab at a callback for an option with variable "
"arguments::"
msgstr ""
"No entanto, aqui vai uma tentativa de função de retorno para uma opção com "
"argumentos variáveis:"

#: ../../library/optparse.rst:1832
msgid ""
"def vararg_callback(option, opt_str, value, parser):\n"
"    assert value is None\n"
"    value = []\n"
"\n"
"    def floatable(str):\n"
"        try:\n"
"            float(str)\n"
"            return True\n"
"        except ValueError:\n"
"            return False\n"
"\n"
"    for arg in parser.rargs:\n"
"        # stop on --foo like options\n"
"        if arg[:2] == \"--\" and len(arg) > 2:\n"
"            break\n"
"        # stop on -a, but not on -3 or -3.0\n"
"        if arg[:1] == \"-\" and len(arg) > 1 and not floatable(arg):\n"
"            break\n"
"        value.append(arg)\n"
"\n"
"    del parser.rargs[:len(value)]\n"
"    setattr(parser.values, option.dest, value)\n"
"\n"
"...\n"
"parser.add_option(\"-c\", \"--callback\", dest=\"vararg_attr\",\n"
"                  action=\"callback\", callback=vararg_callback)"
msgstr ""
"def vararg_callback(option, opt_str, value, parser):\n"
"    assert value is None\n"
"    value = []\n"
"\n"
"    def floatable(str):\n"
"        try:\n"
"            float(str)\n"
"            return True\n"
"        except ValueError:\n"
"            return False\n"
"\n"
"    for arg in parser.rargs:\n"
"        # para em --foo como opções\n"
"        if arg[:2] == \"--\" and len(arg) > 2:\n"
"            break\n"
"        # para em -a, mas não em -3 ou -3.0\n"
"        if arg[:1] == \"-\" and len(arg) > 1 and not floatable(arg):\n"
"            break\n"
"        value.append(arg)\n"
"\n"
"    del parser.rargs[:len(value)]\n"
"    setattr(parser.values, option.dest, value)\n"
"\n"
"...\n"
"parser.add_option(\"-c\", \"--callback\", dest=\"vararg_attr\",\n"
"                  action=\"callback\", callback=vararg_callback)"

#: ../../library/optparse.rst:1863
msgid "Extending :mod:`optparse`"
msgstr "Estendendo :mod:`optparse`"

#: ../../library/optparse.rst:1865
msgid ""
"Since the two major controlling factors in how :mod:`optparse` interprets "
"command-line options are the action and type of each option, the most likely "
"direction of extension is to add new actions and new types."
msgstr ""
"Como os dois principais fatores de controle sobre como :mod:`optparse` "
"interpreta as opções de linha de comando são a ação e o tipo de cada opção, "
"a direção mais provável de extensão é adicionar novas ações e novos tipos."

#: ../../library/optparse.rst:1873
msgid "Adding new types"
msgstr "Adicionando novos tipos"

#: ../../library/optparse.rst:1875
msgid ""
"To add new types, you need to define your own subclass of :mod:`optparse`'s :"
"class:`Option` class.  This class has a couple of attributes that define :"
"mod:`optparse`'s types: :attr:`~Option.TYPES` and :attr:`~Option."
"TYPE_CHECKER`."
msgstr ""
"Para adicionar novos tipos, você precisa definir sua própria subclasse da "
"classe :class:`Option` de :mod:`optparse`. Esta classe tem alguns atributos "
"que definem os tipos de :mod:`optparse`: :attr:`~Option.TYPES` e :attr:"
"`~Option.TYPE_CHECKER`."

#: ../../library/optparse.rst:1881
msgid ""
"A tuple of type names; in your subclass, simply define a new tuple :attr:"
"`TYPES` that builds on the standard one."
msgstr ""
"Uma tupla de nomes de tipos; na sua subclasse, basta definir uma nova tupla :"
"attr:`TYPES` que se baseia na tupla padrão."

#: ../../library/optparse.rst:1886
msgid ""
"A dictionary mapping type names to type-checking functions.  A type-checking "
"function has the following signature::"
msgstr ""
"Um dicionário que mapeia nomes de tipos para funções de verificação de "
"tipos. Uma função de verificação de tipos tem a seguinte assinatura::"

#: ../../library/optparse.rst:1889
msgid "def check_mytype(option, opt, value)"
msgstr "def check_mytype(option, opt, value)"

#: ../../library/optparse.rst:1891
msgid ""
"where ``option`` is an :class:`Option` instance, ``opt`` is an option string "
"(e.g., ``-f``), and ``value`` is the string from the command line that must "
"be checked and converted to your desired type.  ``check_mytype()`` should "
"return an object of the hypothetical type ``mytype``.  The value returned by "
"a type-checking function will wind up in the OptionValues instance returned "
"by :meth:`OptionParser.parse_args`, or be passed to a callback as the "
"``value`` parameter."
msgstr ""
"sendo ``option`` uma instância :class:`Option`, ``opt`` é uma string de "
"opção (por exemplo, ``-f``), e ``value`` é a string da linha de comando que "
"deve ser verificada e convertida para o tipo desejado. ``check_mytype()`` "
"deve retornar um objeto do tipo hipotético ``mytype``. O valor retornado por "
"uma função de verificação de tipo acabará na instância OptionValues ​​"
"retornada por :meth:`OptionParser.parse_args`, ou será passado para uma "
"função de retorno como o parâmetro ``value``."

#: ../../library/optparse.rst:1899
msgid ""
"Your type-checking function should raise :exc:`OptionValueError` if it "
"encounters any problems.  :exc:`OptionValueError` takes a single string "
"argument, which is passed as-is to :class:`OptionParser`'s :meth:`error` "
"method, which in turn prepends the program name and the string ``\"error:"
"\"`` and prints everything to stderr before terminating the process."
msgstr ""
"Sua função de verificação de tipo deve levantar :exc:`OptionValueError` se "
"encontrar algum problema. :exc:`OptionValueError` recebe um único argumento "
"de string, que é passado como está para o método :meth:`error` do :class:"
"`OptionParser`, que por sua vez adiciona o nome do programa e a string "
"``\"error:\"`` e exibe tudo no stderr antes de encerrar o processo."

#: ../../library/optparse.rst:1905
msgid ""
"Here's a silly example that demonstrates adding a ``\"complex\"`` option "
"type to parse Python-style complex numbers on the command line.  (This is "
"even sillier than it used to be, because :mod:`optparse` 1.3 added built-in "
"support for complex numbers, but never mind.)"
msgstr ""
"Aqui está um exemplo bobo que demonstra a adição de um tipo de opção "
"``\"complex\"`` para analisar números complexos no estilo Python na linha de "
"comando. (Isso é ainda mais bobo do que costumava ser, porque :mod:"
"`optparse` 1.3 adicionou suporte embutido para números complexos, mas não "
"importa.)"

#: ../../library/optparse.rst:1910
msgid "First, the necessary imports::"
msgstr "Primeiro, as importações necessárias::"

#: ../../library/optparse.rst:1912
msgid ""
"from copy import copy\n"
"from optparse import Option, OptionValueError"
msgstr ""
"from copy import copy\n"
"from optparse import Option, OptionValueError"

#: ../../library/optparse.rst:1915
msgid ""
"You need to define your type-checker first, since it's referred to later (in "
"the :attr:`~Option.TYPE_CHECKER` class attribute of your Option subclass)::"
msgstr ""
"Você precisa definir seu verificador de tipo primeiro, pois ele será "
"referenciado mais tarde (no atributo de classe :attr:`~Option.TYPE_CHECKER` "
"da sua subclasse de Option)::"

#: ../../library/optparse.rst:1918
msgid ""
"def check_complex(option, opt, value):\n"
"    try:\n"
"        return complex(value)\n"
"    except ValueError:\n"
"        raise OptionValueError(\n"
"            \"option %s: invalid complex value: %r\" % (opt, value))"
msgstr ""
"def check_complex(option, opt, value):\n"
"    try:\n"
"        return complex(value)\n"
"    except ValueError:\n"
"        raise OptionValueError(\n"
"            \"option %s: invalid complex value: %r\" % (opt, value))"

#: ../../library/optparse.rst:1925
msgid "Finally, the Option subclass::"
msgstr "Finalmente, a subclasse de Option::"

#: ../../library/optparse.rst:1927
msgid ""
"class MyOption (Option):\n"
"    TYPES = Option.TYPES + (\"complex\",)\n"
"    TYPE_CHECKER = copy(Option.TYPE_CHECKER)\n"
"    TYPE_CHECKER[\"complex\"] = check_complex"
msgstr ""
"class MyOption (Option):\n"
"    TYPES = Option.TYPES + (\"complex\",)\n"
"    TYPE_CHECKER = copy(Option.TYPE_CHECKER)\n"
"    TYPE_CHECKER[\"complex\"] = check_complex"

#: ../../library/optparse.rst:1932
msgid ""
"(If we didn't make a :func:`copy` of :attr:`Option.TYPE_CHECKER`, we would "
"end up modifying the :attr:`~Option.TYPE_CHECKER` attribute of :mod:"
"`optparse`'s Option class.  This being Python, nothing stops you from doing "
"that except good manners and common sense.)"
msgstr ""
"(Se não fizéssemos uma :func:`copy` de :attr:`Option.TYPE_CHECKER`, "
"acabaríamos modificando o atributo :attr:`~Option.TYPE_CHECKER` da classe "
"Option de :mod:`optparse`. Sendo Python, nada impede você de fazer isso, "
"exceto boas maneiras e bom senso.)"

#: ../../library/optparse.rst:1937
msgid ""
"That's it!  Now you can write a script that uses the new option type just "
"like any other :mod:`optparse`\\ -based script, except you have to instruct "
"your OptionParser to use MyOption instead of Option::"
msgstr ""
"Pronto! Agora você pode escrever um script que usa o novo tipo de opção como "
"qualquer outro script baseado em :mod:`optparse`, exceto que você tem que "
"instruir seu OptionParser a usar MyOption em vez de Option::"

#: ../../library/optparse.rst:1941
msgid ""
"parser = OptionParser(option_class=MyOption)\n"
"parser.add_option(\"-c\", type=\"complex\")"
msgstr ""
"parser = OptionParser(option_class=MyOption)\n"
"parser.add_option(\"-c\", type=\"complex\")"

#: ../../library/optparse.rst:1944
msgid ""
"Alternately, you can build your own option list and pass it to OptionParser; "
"if you don't use :meth:`add_option` in the above way, you don't need to tell "
"OptionParser which option class to use::"
msgstr ""
"Como alternativa, você pode criar sua própria lista de opções e passá-la "
"para o OptionParser; se você não usar :meth:`add_option` da maneira acima, "
"não precisa informar ao OptionParser qual classe de opção usar::"

#: ../../library/optparse.rst:1948
msgid ""
"option_list = [MyOption(\"-c\", action=\"store\", type=\"complex\", "
"dest=\"c\")]\n"
"parser = OptionParser(option_list=option_list)"
msgstr ""
"option_list = [MyOption(\"-c\", action=\"store\", type=\"complex\", "
"dest=\"c\")]\n"
"parser = OptionParser(option_list=option_list)"

#: ../../library/optparse.rst:1955
msgid "Adding new actions"
msgstr ""

#: ../../library/optparse.rst:1957
msgid ""
"Adding new actions is a bit trickier, because you have to understand that :"
"mod:`optparse` has a couple of classifications for actions:"
msgstr ""

#: ../../library/optparse.rst:1960
msgid "\"store\" actions"
msgstr ""

#: ../../library/optparse.rst:1961
msgid ""
"actions that result in :mod:`optparse` storing a value to an attribute of "
"the current OptionValues instance; these options require a :attr:`~Option."
"dest` attribute to be supplied to the Option constructor."
msgstr ""

#: ../../library/optparse.rst:1965
msgid "\"typed\" actions"
msgstr ""

#: ../../library/optparse.rst:1966
msgid ""
"actions that take a value from the command line and expect it to be of a "
"certain type; or rather, a string that can be converted to a certain type. "
"These options require a :attr:`~Option.type` attribute to the Option "
"constructor."
msgstr ""

#: ../../library/optparse.rst:1971
msgid ""
"These are overlapping sets: some default \"store\" actions are "
"``\"store\"``, ``\"store_const\"``, ``\"append\"``, and ``\"count\"``, while "
"the default \"typed\" actions are ``\"store\"``, ``\"append\"``, and "
"``\"callback\"``."
msgstr ""

#: ../../library/optparse.rst:1975
msgid ""
"When you add an action, you need to categorize it by listing it in at least "
"one of the following class attributes of Option (all are lists of strings):"
msgstr ""

#: ../../library/optparse.rst:1980
msgid "All actions must be listed in ACTIONS."
msgstr ""

#: ../../library/optparse.rst:1984
msgid "\"store\" actions are additionally listed here."
msgstr ""

#: ../../library/optparse.rst:1988
msgid "\"typed\" actions are additionally listed here."
msgstr ""

#: ../../library/optparse.rst:1992
msgid ""
"Actions that always take a type (i.e. whose options always take a value) are "
"additionally listed here.  The only effect of this is that :mod:`optparse` "
"assigns the default type, ``\"string\"``, to options with no explicit type "
"whose action is listed in :attr:`ALWAYS_TYPED_ACTIONS`."
msgstr ""

#: ../../library/optparse.rst:1997
msgid ""
"In order to actually implement your new action, you must override Option's :"
"meth:`take_action` method and add a case that recognizes your action."
msgstr ""

#: ../../library/optparse.rst:2000
msgid ""
"For example, let's add an ``\"extend\"`` action.  This is similar to the "
"standard ``\"append\"`` action, but instead of taking a single value from "
"the command-line and appending it to an existing list, ``\"extend\"`` will "
"take multiple values in a single comma-delimited string, and extend an "
"existing list with them.  That is, if ``--names`` is an ``\"extend\"`` "
"option of type ``\"string\"``, the command line ::"
msgstr ""

#: ../../library/optparse.rst:2007
msgid "--names=foo,bar --names blah --names ding,dong"
msgstr ""

#: ../../library/optparse.rst:2009
msgid "would result in a list  ::"
msgstr ""

#: ../../library/optparse.rst:2011
msgid "[\"foo\", \"bar\", \"blah\", \"ding\", \"dong\"]"
msgstr ""

#: ../../library/optparse.rst:2013
msgid "Again we define a subclass of Option::"
msgstr ""

#: ../../library/optparse.rst:2015
msgid ""
"class MyOption(Option):\n"
"\n"
"    ACTIONS = Option.ACTIONS + (\"extend\",)\n"
"    STORE_ACTIONS = Option.STORE_ACTIONS + (\"extend\",)\n"
"    TYPED_ACTIONS = Option.TYPED_ACTIONS + (\"extend\",)\n"
"    ALWAYS_TYPED_ACTIONS = Option.ALWAYS_TYPED_ACTIONS + (\"extend\",)\n"
"\n"
"    def take_action(self, action, dest, opt, value, values, parser):\n"
"        if action == \"extend\":\n"
"            lvalue = value.split(\",\")\n"
"            values.ensure_value(dest, []).extend(lvalue)\n"
"        else:\n"
"            Option.take_action(\n"
"                self, action, dest, opt, value, values, parser)"
msgstr ""

#: ../../library/optparse.rst:2030
msgid "Features of note:"
msgstr ""

#: ../../library/optparse.rst:2032
msgid ""
"``\"extend\"`` both expects a value on the command-line and stores that "
"value somewhere, so it goes in both :attr:`~Option.STORE_ACTIONS` and :attr:"
"`~Option.TYPED_ACTIONS`."
msgstr ""

#: ../../library/optparse.rst:2036
msgid ""
"to ensure that :mod:`optparse` assigns the default type of ``\"string\"`` to "
"``\"extend\"`` actions, we put the ``\"extend\"`` action in :attr:`~Option."
"ALWAYS_TYPED_ACTIONS` as well."
msgstr ""

#: ../../library/optparse.rst:2040
msgid ""
":meth:`MyOption.take_action` implements just this one new action, and passes "
"control back to :meth:`Option.take_action` for the standard :mod:`optparse` "
"actions."
msgstr ""

#: ../../library/optparse.rst:2044
msgid ""
"``values`` is an instance of the optparse_parser.Values class, which "
"provides the very useful :meth:`ensure_value` method. :meth:`ensure_value` "
"is essentially :func:`getattr` with a safety valve; it is called as ::"
msgstr ""

#: ../../library/optparse.rst:2048
msgid "values.ensure_value(attr, value)"
msgstr ""

#: ../../library/optparse.rst:2050
msgid ""
"If the ``attr`` attribute of ``values`` doesn't exist or is ``None``, then "
"ensure_value() first sets it to ``value``, and then returns ``value``. This "
"is very handy for actions like ``\"extend\"``, ``\"append\"``, and "
"``\"count\"``, all of which accumulate data in a variable and expect that "
"variable to be of a certain type (a list for the first two, an integer for "
"the latter).  Using :meth:`ensure_value` means that scripts using your "
"action don't have to worry about setting a default value for the option "
"destinations in question; they can just leave the default as ``None`` and :"
"meth:`ensure_value` will take care of getting it right when it's needed."
msgstr ""

#: ../../library/optparse.rst:2061
msgid "Exceptions"
msgstr "Exceções"

#: ../../library/optparse.rst:2065
msgid ""
"Raised if an :class:`Option` instance is created with invalid or "
"inconsistent arguments."
msgstr ""

#: ../../library/optparse.rst:2070
msgid "Raised if conflicting options are added to an :class:`OptionParser`."
msgstr ""

#: ../../library/optparse.rst:2074
msgid "Raised if an invalid option value is encountered on the command line."
msgstr ""

#: ../../library/optparse.rst:2078
msgid "Raised if an invalid option is passed on the command line."
msgstr ""

#: ../../library/optparse.rst:2082
msgid "Raised if an ambiguous option is passed on the command line."
msgstr ""

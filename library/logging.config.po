# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 17:51+0000\n"
"PO-Revision-Date: 2017-02-16 23:16+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/logging.config.rst:2
msgid ":mod:`logging.config` --- Logging configuration"
msgstr ":mod:`logging.config` --- Налаштування журналювання"

#: ../../library/logging.config.rst:10
msgid "**Source code:** :source:`Lib/logging/config.py`"
msgstr "**Código-fonte:** :source:`Lib/logging/config.py`"

#: ../../library/logging.config.rst:14
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr ""
"Esta página contém apenas informações de referência. Para tutoriais, por "
"favor consulte"

#: ../../library/logging.config.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Tutorial básico <logging-basic-tutorial>`"

#: ../../library/logging.config.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Tutorial avançado <logging-advanced-tutorial>`"

#: ../../library/logging.config.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`Livro de receitas de logging <logging-cookbook>`"

#: ../../library/logging.config.rst:23
msgid "This section describes the API for configuring the logging module."
msgstr "Esta seção descreve a API para configuração do módulo logging."

#: ../../library/logging.config.rst:28
msgid "Configuration functions"
msgstr "Funções de configuração"

#: ../../library/logging.config.rst:30
msgid ""
"The following functions configure the logging module. They are located in "
"the :mod:`logging.config` module.  Their use is optional --- you can "
"configure the logging module using these functions or by making calls to the "
"main API (defined in :mod:`logging` itself) and defining handlers which are "
"declared either in :mod:`logging` or :mod:`logging.handlers`."
msgstr ""
"Os seguintes função configuram o módulo  logging. Elas estão localizadas no "
"módulo :mod:`logging.config`. Seu uso é opcional --- você pode configurar o "
"módulo logging usando essas funções ou fazendo chamadas para o API principal "
"(definido no próprio :mod:`logging`) e definindo manipuladores que são "
"declarados em :mod:`logging` ou :mod:`logging.handlers`."

#: ../../library/logging.config.rst:38
msgid ""
"Takes the logging configuration from a dictionary.  The contents of this "
"dictionary are described in :ref:`logging-config-dictschema` below."
msgstr ""
"Obtém a configuração de logging de um dicionário. O conteúdo desse "
"dicionário está descrito em :ref:`logging-config-dictschema` abaixo."

#: ../../library/logging.config.rst:42
msgid ""
"If an error is encountered during configuration, this function will raise a :"
"exc:`ValueError`, :exc:`TypeError`, :exc:`AttributeError` or :exc:"
"`ImportError` with a suitably descriptive message.  The following is a "
"(possibly incomplete) list of conditions which will raise an error:"
msgstr ""
"Якщо під час налаштування буде виявлено помилку, ця функція викличе :exc:"
"`ValueError`, :exc:`TypeError`, :exc:`AttributeError` або :exc:`ImportError` "
"із відповідним описовим повідомленням. Нижче наведено (можливо, неповний) "
"список умов, які викличуть помилку:"

#: ../../library/logging.config.rst:48
msgid ""
"A ``level`` which is not a string or which is a string not corresponding to "
"an actual logging level."
msgstr ""
"``Рівень``, який не є рядком або є рядком, що не відповідає фактичному рівню "
"реєстрації."

#: ../../library/logging.config.rst:50
msgid "A ``propagate`` value which is not a boolean."
msgstr "Значення ``розповсюдження``, яке не є логічним."

#: ../../library/logging.config.rst:51
msgid "An id which does not have a corresponding destination."
msgstr "Ідентифікатор, який не має відповідного адресата."

#: ../../library/logging.config.rst:52
msgid "A non-existent handler id found during an incremental call."
msgstr ""
"Під час інкрементного виклику виявлено ідентифікатор неіснуючого обробника."

#: ../../library/logging.config.rst:53
msgid "An invalid logger name."
msgstr "Недійсне ім'я реєстратора."

#: ../../library/logging.config.rst:54
msgid "Inability to resolve to an internal or external object."
msgstr "Нездатність вирішити внутрішній або зовнішній об'єкт."

#: ../../library/logging.config.rst:56
msgid ""
"Parsing is performed by the :class:`DictConfigurator` class, whose "
"constructor is passed the dictionary used for configuration, and has a :meth:"
"`configure` method.  The :mod:`logging.config` module has a callable "
"attribute :attr:`dictConfigClass` which is initially set to :class:"
"`DictConfigurator`. You can replace the value of :attr:`dictConfigClass` "
"with a suitable implementation of your own."
msgstr ""
"Розбір виконується класом :class:`DictConfigurator`, конструктор якого "
"передає словник, який використовується для налаштування, і має метод :meth:"
"`configure`. Модуль :mod:`logging.config` має викликаний атрибут :attr:"
"`dictConfigClass`, який початково встановлено на :class:`DictConfigurator`. "
"Ви можете замінити значення :attr:`dictConfigClass` відповідною власною "
"реалізацією."

#: ../../library/logging.config.rst:64
msgid ""
":func:`dictConfig` calls :attr:`dictConfigClass` passing the specified "
"dictionary, and then calls the :meth:`configure` method on the returned "
"object to put the configuration into effect::"
msgstr ""
":func:`dictConfig` викликає :attr:`dictConfigClass`, передаючи вказаний "
"словник, а потім викликає метод :meth:`configure` для повернутого об’єкта, "
"щоб застосувати конфігурацію:"

#: ../../library/logging.config.rst:71
msgid ""
"For example, a subclass of :class:`DictConfigurator` could call "
"``DictConfigurator.__init__()`` in its own :meth:`__init__()`, then set up "
"custom prefixes which would be usable in the subsequent :meth:`configure` "
"call. :attr:`dictConfigClass` would be bound to this new subclass, and then :"
"func:`dictConfig` could be called exactly as in the default, uncustomized "
"state."
msgstr ""
"Наприклад, підклас :class:`DictConfigurator` може викликати "
"``DictConfigurator.__init__()`` у власному :meth:`__init__()`, а потім "
"налаштувати спеціальні префікси, які можна буде використовувати в наступних "
"виклик :meth:`configure`. :attr:`dictConfigClass` буде прив’язано до цього "
"нового підкласу, а потім :func:`dictConfig` можна буде викликати точно так "
"само, як у типовому, неналаштованому стані."

#: ../../library/logging.config.rst:82
msgid ""
"Reads the logging configuration from a :mod:`configparser`\\-format file. "
"The format of the file should be as described in :ref:`logging-config-"
"fileformat`. This function can be called several times from an application, "
"allowing an end user to select from various pre-canned configurations (if "
"the developer provides a mechanism to present the choices and load the "
"chosen configuration)."
msgstr ""
"Читає конфігурацію журналювання з файлу у форматі :mod:`configparser`\\. "
"Формат файлу має бути таким, як описано в :ref:`logging-config-fileformat`. "
"Цю функцію можна викликати кілька разів із програми, дозволяючи кінцевому "
"користувачеві вибирати з різних попередньо готових конфігурацій (якщо "
"розробник надає механізм для представлення варіантів і завантаження вибраної "
"конфігурації)."

#: ../../library/logging.config.rst:0
msgid "Parameters"
msgstr "Parâmetros"

#: ../../library/logging.config.rst:90
msgid ""
"A filename, or a file-like object, or an instance derived from :class:"
"`~configparser.RawConfigParser`. If a ``RawConfigParser``-derived instance "
"is passed, it is used as is. Otherwise, a :class:`~configparser."
"Configparser` is instantiated, and the configuration read by it from the "
"object passed in ``fname``. If that has a :meth:`readline` method, it is "
"assumed to be a file-like object and read using :meth:`~configparser."
"ConfigParser.read_file`; otherwise, it is assumed to be a filename and "
"passed to :meth:`~configparser.ConfigParser.read`."
msgstr ""

#: ../../library/logging.config.rst:102
msgid ""
"Defaults to be passed to the ConfigParser can be specified in this argument."
msgstr ""

#: ../../library/logging.config.rst:105
msgid ""
"If specified as ``False``, loggers which exist when this call is made are "
"left enabled. The default is ``True`` because this enables old behaviour in "
"a backward-compatible way. This behaviour is to disable any existing non-"
"root loggers unless they or their ancestors are explicitly named in the "
"logging configuration."
msgstr ""

#: ../../library/logging.config.rst:114
msgid ""
"An instance of a subclass of :class:`~configparser.RawConfigParser` is now "
"accepted as a value for ``fname``. This facilitates:"
msgstr ""

#: ../../library/logging.config.rst:118
msgid ""
"Use of a configuration file where logging configuration is just part of the "
"overall application configuration."
msgstr ""
"Використання файлу конфігурації, де конфігурація журналювання є лише "
"частиною загальної конфігурації програми."

#: ../../library/logging.config.rst:120
msgid ""
"Use of a configuration read from a file, and then modified by the using "
"application (e.g. based on command-line parameters or other aspects of the "
"runtime environment) before being passed to ``fileConfig``."
msgstr ""
"Використання конфігурації, зчитаної з файлу, а потім зміненої програмою-"
"користувачем (наприклад, на основі параметрів командного рядка або інших "
"аспектів середовища виконання) перед передачею в ``fileConfig``."

#: ../../library/logging.config.rst:126
msgid ""
"Starts up a socket server on the specified port, and listens for new "
"configurations. If no port is specified, the module's default :const:"
"`DEFAULT_LOGGING_CONFIG_PORT` is used. Logging configurations will be sent "
"as a file suitable for processing by :func:`dictConfig` or :func:"
"`fileConfig`. Returns a :class:`~threading.Thread` instance on which you can "
"call :meth:`~threading.Thread.start` to start the server, and which you can :"
"meth:`~threading.Thread.join` when appropriate. To stop the server, call :"
"func:`stopListening`."
msgstr ""
"Запускає сервер сокетів на вказаному порту та очікує нових конфігурацій. "
"Якщо порт не вказано, використовується модуль за замовчуванням :const:"
"`DEFAULT_LOGGING_CONFIG_PORT`. Конфігурації журналу будуть надіслані як "
"файл, придатний для обробки за допомогою :func:`dictConfig` або :func:"
"`fileConfig`. Повертає екземпляр :class:`~threading.Thread`, на якому ви "
"можете викликати :meth:`~threading.Thread.start`, щоб запустити сервер, і до "
"якого ви можете :meth:`~threading.Thread.join`, коли потрібно . Щоб зупинити "
"сервер, викличте :func:`stopListening`."

#: ../../library/logging.config.rst:135
msgid ""
"The ``verify`` argument, if specified, should be a callable which should "
"verify whether bytes received across the socket are valid and should be "
"processed. This could be done by encrypting and/or signing what is sent "
"across the socket, such that the ``verify`` callable can perform signature "
"verification and/or decryption. The ``verify`` callable is called with a "
"single argument - the bytes received across the socket - and should return "
"the bytes to be processed, or ``None`` to indicate that the bytes should be "
"discarded. The returned bytes could be the same as the passed in bytes (e.g. "
"when only verification is done), or they could be completely different "
"(perhaps if decryption were performed)."
msgstr ""
"Аргумент ``verify``, якщо вказано, має бути викликом, який повинен "
"перевіряти, чи байти, отримані через сокет, є дійсними та чи їх потрібно "
"обробити. Це можна зробити, зашифрувавши та/або підписавши те, що "
"надсилається через сокет, щоб виклик ``verify`` міг виконувати перевірку "
"підпису та/або дешифрування. Викликається ``verify`` викликається з єдиним "
"аргументом - байтами, отриманими через сокет - і має повертати байти для "
"обробки, або ``None``, щоб вказати, що байти слід відкинути. Повернуті байти "
"можуть бути такими самими, як передані в байтах (наприклад, коли виконується "
"лише перевірка), або вони можуть бути зовсім іншими (можливо, якщо було "
"виконано дешифрування)."

#: ../../library/logging.config.rst:146
msgid ""
"To send a configuration to the socket, read in the configuration file and "
"send it to the socket as a sequence of bytes preceded by a four-byte length "
"string packed in binary using ``struct.pack('>L', n)``."
msgstr ""
"Щоб надіслати конфігурацію до сокета, прочитайте файл конфігурації та "
"надішліть його до сокета як послідовність байтів, яким передує "
"чотирибайтовий рядок, упакований у двійковому вигляді за допомогою ``struct."
"pack('>L', n)``."

#: ../../library/logging.config.rst:154
msgid ""
"Because portions of the configuration are passed through :func:`eval`, use "
"of this function may open its users to a security risk. While the function "
"only binds to a socket on ``localhost``, and so does not accept connections "
"from remote machines, there are scenarios where untrusted code could be run "
"under the account of the process which calls :func:`listen`. Specifically, "
"if the process calling :func:`listen` runs on a multi-user machine where "
"users cannot trust each other, then a malicious user could arrange to run "
"essentially arbitrary code in a victim user's process, simply by connecting "
"to the victim's :func:`listen` socket and sending a configuration which runs "
"whatever code the attacker wants to have executed in the victim's process. "
"This is especially easy to do if the default port is used, but not hard even "
"if a different port is used. To avoid the risk of this happening, use the "
"``verify`` argument to :func:`listen` to prevent unrecognised configurations "
"from being applied."
msgstr ""
"Оскільки частини конфігурації передаються через :func:`eval`, використання "
"цієї функції може піддати користувачам ризик безпеки. Хоча функція "
"прив’язується лише до сокета на ``localhost`` і тому не приймає з’єднання з "
"віддалених машин, існують сценарії, коли ненадійний код може запускатися під "
"обліковим записом процесу, який викликає :func:`listen`. Зокрема, якщо "
"процес, який викликає :func:`listen`, виконується на багатокористувацькій "
"машині, де користувачі не можуть довіряти один одному, тоді зловмисник може "
"організувати запуск практично довільного коду в процесі користувача-жертви, "
"просто підключившись до жертви :func:`listen` сокет і надсилання "
"конфігурації, яка запускає будь-який код, який зловмисник хоче виконати в "
"процесі жертви. Це особливо легко зробити, якщо використовується стандартний "
"порт, але не важко, навіть якщо використовується інший порт. Щоб уникнути "
"цього ризику, використовуйте аргумент ``verify`` для :func:`listen`, щоб "
"запобігти застосуванню нерозпізнаних конфігурацій."

#: ../../library/logging.config.rst:170
msgid "The ``verify`` argument was added."
msgstr "Додано аргумент ``перевірити``."

#: ../../library/logging.config.rst:175
msgid ""
"If you want to send configurations to the listener which don't disable "
"existing loggers, you will need to use a JSON format for the configuration, "
"which will use :func:`dictConfig` for configuration. This method allows you "
"to specify ``disable_existing_loggers`` as ``False`` in the configuration "
"you send."
msgstr ""
"Якщо ви хочете надіслати конфігурації прослухувачу, які не вимикають існуючі "
"реєстратори, вам потрібно буде використовувати формат JSON для конфігурації, "
"яка використовуватиме :func:`dictConfig` для конфігурації. Цей метод "
"дозволяє вказати ``disable_existing_loggers`` як ``False`` у конфігурації, "
"яку ви надсилаєте."

#: ../../library/logging.config.rst:184
msgid ""
"Stops the listening server which was created with a call to :func:`listen`. "
"This is typically called before calling :meth:`join` on the return value "
"from :func:`listen`."
msgstr ""
"Зупиняє сервер прослуховування, створений за допомогою виклику :func:"
"`listen`. Це зазвичай викликається перед викликом :meth:`join` для значення, "
"яке повертає :func:`listen`."

#: ../../library/logging.config.rst:190
msgid "Security considerations"
msgstr "Considerações de segurança"

#: ../../library/logging.config.rst:192
msgid ""
"The logging configuration functionality tries to offer convenience, and in "
"part this is done by offering the ability to convert text in configuration "
"files into Python objects used in logging configuration - for example, as "
"described in :ref:`logging-config-dict-userdef`. However, these same "
"mechanisms (importing callables from user-defined modules and calling them "
"with parameters from the configuration) could be used to invoke any code you "
"like, and for this reason you should treat configuration files from "
"untrusted sources with *extreme caution* and satisfy yourself that nothing "
"bad can happen if you load them, before actually loading them."
msgstr ""
"Функціональність конфігурації журналювання намагається запропонувати "
"зручність, і частково це робиться, пропонуючи можливість перетворювати текст "
"у конфігураційних файлах на об’єкти Python, які використовуються в "
"конфігурації журналювання - наприклад, як описано в :ref:`logging-config-"
"dict-userdef`. Однак ці самі механізми (імпорт викликів із визначених "
"користувачем модулів і виклик їх із параметрами з конфігурації) можна "
"використовувати для виклику будь-якого коду, який вам подобається, і з цієї "
"причини ви повинні поводитися з конфігураційними файлами з ненадійних джерел "
"з *надзвичайною обережністю* і переконайтеся, що нічого поганого не "
"станеться, якщо ви їх завантажите, перш ніж завантажувати їх."

#: ../../library/logging.config.rst:206
msgid "Configuration dictionary schema"
msgstr "Схема словника конфігурації"

#: ../../library/logging.config.rst:208
msgid ""
"Describing a logging configuration requires listing the various objects to "
"create and the connections between them; for example, you may create a "
"handler named 'console' and then say that the logger named 'startup' will "
"send its messages to the 'console' handler. These objects aren't limited to "
"those provided by the :mod:`logging` module because you might write your own "
"formatter or handler class. The parameters to these classes may also need to "
"include external objects such as ``sys.stderr``.  The syntax for describing "
"these objects and connections is defined in :ref:`logging-config-dict-"
"connections` below."
msgstr ""
"Опис конфігурації журналювання вимагає переліку різних об’єктів для "
"створення та зв’язків між ними; наприклад, ви можете створити обробник під "
"назвою \"console\", а потім сказати, що реєстратор під назвою \"startup\" "
"надсилатиме свої повідомлення до обробника \"console\". Ці об’єкти не "
"обмежуються об’єктами, наданими модулем :mod:`logging`, оскільки ви можете "
"написати власний формататор або клас обробника. Параметри цих класів можуть "
"також потребувати включення зовнішніх об’єктів, таких як ``sys.stderr``. "
"Синтаксис для опису цих об’єктів і з’єднань визначено в :ref:`logging-config-"
"dict-connections` нижче."

#: ../../library/logging.config.rst:220
msgid "Dictionary Schema Details"
msgstr "Подробиці схеми словника"

#: ../../library/logging.config.rst:222
msgid ""
"The dictionary passed to :func:`dictConfig` must contain the following keys:"
msgstr "Словник, переданий до :func:`dictConfig`, повинен містити такі ключі:"

#: ../../library/logging.config.rst:225
msgid ""
"*version* - to be set to an integer value representing the schema version.  "
"The only valid value at present is 1, but having this key allows the schema "
"to evolve while still preserving backwards compatibility."
msgstr ""
"*version* - має бути встановлено ціле значення, що представляє версію схеми. "
"Єдиним дійсним значенням наразі є 1, але наявність цього ключа дозволяє "
"схемі розвиватися, зберігаючи зворотну сумісність."

#: ../../library/logging.config.rst:230
msgid ""
"All other keys are optional, but if present they will be interpreted as "
"described below.  In all cases below where a 'configuring dict' is "
"mentioned, it will be checked for the special ``'()'`` key to see if a "
"custom instantiation is required.  If so, the mechanism described in :ref:"
"`logging-config-dict-userdef` below is used to create an instance; "
"otherwise, the context is used to determine what to instantiate."
msgstr ""
"Усі інші ключі необов’язкові, але якщо вони присутні, вони "
"інтерпретуватимуться, як описано нижче. У всіх випадках, наведених нижче, де "
"згадується \"налаштування dict\", буде перевірено наявність спеціального "
"ключа ``'()''``, щоб побачити, чи потрібен власний екземпляр. Якщо так, "
"механізм, описаний у :ref:`logging-config-dict-userdef` нижче, "
"використовується для створення екземпляра; інакше контекст використовується "
"для визначення того, що створити екземпляр."

#: ../../library/logging.config.rst:237
msgid ""
"*formatters* - the corresponding value will be a dict in which each key is a "
"formatter id and each value is a dict describing how to configure the "
"corresponding :class:`~logging.Formatter` instance."
msgstr ""
"*formatters* - відповідне значення буде dict, у якому кожен ключ є "
"ідентифікатором formatter, а кожне значення є dict, що описує, як "
"налаштувати відповідний екземпляр :class:`~logging.Formatter`."

#: ../../library/logging.config.rst:241
msgid ""
"The configuring dict is searched for keys ``format`` and ``datefmt`` (with "
"defaults of ``None``) and these are used to construct a :class:`~logging."
"Formatter` instance."
msgstr ""

#: ../../library/logging.config.rst:245
msgid ""
"a ``validate`` key (with default of ``True``) can be added into the "
"``formatters`` section of the configuring dict, this is to validate the "
"format."
msgstr ""

#: ../../library/logging.config.rst:250
msgid ""
"*filters* - the corresponding value will be a dict in which each key is a "
"filter id and each value is a dict describing how to configure the "
"corresponding Filter instance."
msgstr ""
"*filters* — відповідне значення буде диктовим словом, у якому кожен ключ є "
"ідентифікатором фільтра, а кожне значення — диктовим кодом, що описує, як "
"налаштувати відповідний екземпляр фільтра."

#: ../../library/logging.config.rst:254
msgid ""
"The configuring dict is searched for the key ``name`` (defaulting to the "
"empty string) and this is used to construct a :class:`logging.Filter` "
"instance."
msgstr ""
"Dict конфігурації шукається за ключем ``name`` (за замовчуванням порожній "
"рядок), і це використовується для створення екземпляра :class:`logging."
"Filter`."

#: ../../library/logging.config.rst:258
msgid ""
"*handlers* - the corresponding value will be a dict in which each key is a "
"handler id and each value is a dict describing how to configure the "
"corresponding Handler instance."
msgstr ""
"*обробники* – відповідним значенням буде dict, у якому кожен ключ є "
"ідентифікатором обробника, а кожне значення є dict, що описує, як "
"налаштувати відповідний екземпляр Handler."

#: ../../library/logging.config.rst:262 ../../library/logging.config.rst:304
msgid "The configuring dict is searched for the following keys:"
msgstr "У диктофоні налаштування виконується пошук таких ключів:"

#: ../../library/logging.config.rst:264
msgid ""
"``class`` (mandatory).  This is the fully qualified name of the handler "
"class."
msgstr "``клас`` (обов'язковий). Це повна назва класу обробника."

#: ../../library/logging.config.rst:267
msgid "``level`` (optional).  The level of the handler."
msgstr "``рівень`` (необов'язково). Рівень обробника."

#: ../../library/logging.config.rst:269
msgid "``formatter`` (optional).  The id of the formatter for this handler."
msgstr ""
"``форматувальник`` (необов'язковий). Ідентифікатор форматера для цього "
"обробника."

#: ../../library/logging.config.rst:272
msgid "``filters`` (optional).  A list of ids of the filters for this handler."
msgstr ""
"``фільтри`` (необов'язково). Список ідентифікаторів фільтрів для цього "
"обробника."

#: ../../library/logging.config.rst:275
msgid ""
"All *other* keys are passed through as keyword arguments to the handler's "
"constructor.  For example, given the snippet:"
msgstr ""
"Усі *інші* ключі передаються як аргументи ключового слова до конструктора "
"обробника. Наприклад, враховуючи фрагмент:"

#: ../../library/logging.config.rst:294
msgid ""
"the handler with id ``console`` is instantiated as a :class:`logging."
"StreamHandler`, using ``sys.stdout`` as the underlying stream.  The handler "
"with id ``file`` is instantiated as a :class:`logging.handlers."
"RotatingFileHandler` with the keyword arguments ``filename='logconfig.log', "
"maxBytes=1024, backupCount=3``."
msgstr ""
"обробник з ідентифікатором ``console`` створюється як :class:`logging."
"StreamHandler`, використовуючи ``sys.stdout`` як базовий потік. Обробник з "
"ідентифікатором ``file`` створюється як :class:`logging.handlers."
"RotatingFileHandler` з ключовими аргументами ``filename='logconfig.log', "
"maxBytes=1024, backupCount=3``."

#: ../../library/logging.config.rst:300
msgid ""
"*loggers* - the corresponding value will be a dict in which each key is a "
"logger name and each value is a dict describing how to configure the "
"corresponding Logger instance."
msgstr ""
"*loggers* - відповідне значення буде dict, у якому кожен ключ є іменем "
"logger, а кожне значення є dict, що описує, як налаштувати відповідний "
"екземпляр Logger."

#: ../../library/logging.config.rst:306
msgid "``level`` (optional).  The level of the logger."
msgstr "``рівень`` (необов'язково). Рівень лісоруба."

#: ../../library/logging.config.rst:308
msgid "``propagate`` (optional).  The propagation setting of the logger."
msgstr ""
"``propagate`` (необов'язковий). Налаштування розповсюдження реєстратора."

#: ../../library/logging.config.rst:310
msgid "``filters`` (optional).  A list of ids of the filters for this logger."
msgstr ""
"``фільтри`` (необов'язково). Список ідентифікаторів фільтрів для цього "
"реєстратора."

#: ../../library/logging.config.rst:313
msgid ""
"``handlers`` (optional).  A list of ids of the handlers for this logger."
msgstr ""
"``обробники`` (необов'язково). Список ідентифікаторів обробників для цього "
"реєстратора."

#: ../../library/logging.config.rst:316
msgid ""
"The specified loggers will be configured according to the level, "
"propagation, filters and handlers specified."
msgstr ""
"Зазначені реєстратори буде налаштовано відповідно до вказаного рівня, "
"розповсюдження, фільтрів і обробників."

#: ../../library/logging.config.rst:319
msgid ""
"*root* - this will be the configuration for the root logger. Processing of "
"the configuration will be as for any logger, except that the ``propagate`` "
"setting will not be applicable."
msgstr ""
"*root* - це буде конфігурація для root logger. Обробка конфігурації "
"відбуватиметься так само, як і для будь-якого реєстратора, за винятком того, "
"що параметр ``propagate`` не застосовуватиметься."

#: ../../library/logging.config.rst:323
msgid ""
"*incremental* - whether the configuration is to be interpreted as "
"incremental to the existing configuration.  This value defaults to "
"``False``, which means that the specified configuration replaces the "
"existing configuration with the same semantics as used by the existing :func:"
"`fileConfig` API."
msgstr ""
"*incremental* – чи конфігурація має інтерпретуватися як додаткова до "
"існуючої конфігурації. За замовчуванням це значення має значення ``False``, "
"що означає, що вказана конфігурація замінює існуючу конфігурацію з тією "
"самою семантикою, яку використовує існуючий API :func:`fileConfig`."

#: ../../library/logging.config.rst:329
msgid ""
"If the specified value is ``True``, the configuration is processed as "
"described in the section on :ref:`logging-config-dict-incremental`."
msgstr ""
"Якщо вказане значення ``True``, конфігурація обробляється, як описано в "
"розділі про :ref:`logging-config-dict-incremental`."

#: ../../library/logging.config.rst:332
msgid ""
"*disable_existing_loggers* - whether any existing non-root loggers are to be "
"disabled. This setting mirrors the parameter of the same name in :func:"
"`fileConfig`. If absent, this parameter defaults to ``True``. This value is "
"ignored if *incremental* is ``True``."
msgstr ""
"*disable_existing_loggers* - чи потрібно вимкнути існуючі некореневі "
"реєстратори. Цей параметр відображає однойменний параметр у :func:"
"`fileConfig`. Якщо цей параметр відсутній, цей параметр за замовчуванням має "
"значення ``True``. Це значення ігнорується, якщо *incremental* має значення "
"``True``."

#: ../../library/logging.config.rst:340
msgid "Incremental Configuration"
msgstr "Інкрементна конфігурація"

#: ../../library/logging.config.rst:342
msgid ""
"It is difficult to provide complete flexibility for incremental "
"configuration.  For example, because objects such as filters and formatters "
"are anonymous, once a configuration is set up, it is not possible to refer "
"to such anonymous objects when augmenting a configuration."
msgstr ""
"Важко забезпечити повну гнучкість для поступової конфігурації. Наприклад, "
"оскільки такі об’єкти, як фільтри та засоби форматування, є анонімними, "
"після налаштування конфігурації неможливо посилатися на такі анонімні "
"об’єкти під час розширення конфігурації."

#: ../../library/logging.config.rst:348
msgid ""
"Furthermore, there is not a compelling case for arbitrarily altering the "
"object graph of loggers, handlers, filters, formatters at run-time, once a "
"configuration is set up; the verbosity of loggers and handlers can be "
"controlled just by setting levels (and, in the case of loggers, propagation "
"flags).  Changing the object graph arbitrarily in a safe way is problematic "
"in a multi-threaded environment; while not impossible, the benefits are not "
"worth the complexity it adds to the implementation."
msgstr ""
"Крім того, немає переконливих аргументів для довільної зміни графа об’єктів "
"реєстраторів, обробників, фільтрів, форматувальників під час виконання, коли "
"конфігурацію встановлено; докладністю реєстраторів і обробників можна "
"керувати, просто встановлюючи рівні (і, у випадку реєстраторів, позначки "
"поширення). Довільна зміна графа об’єктів у безпечний спосіб проблематична в "
"багатопоточному середовищі; Хоча це не неможливо, переваги не варті "
"складності, яку це додає до впровадження."

#: ../../library/logging.config.rst:357
msgid ""
"Thus, when the ``incremental`` key of a configuration dict is present and is "
"``True``, the system will completely ignore any ``formatters`` and "
"``filters`` entries, and process only the ``level`` settings in the "
"``handlers`` entries, and the ``level`` and ``propagate`` settings in the "
"``loggers`` and ``root`` entries."
msgstr ""
"Таким чином, коли ``incremental`` ключ конфігураційного dict присутній і "
"``True``, система повністю ігноруватиме будь-які ``formatters`` і "
"``filters`` записи, і оброблятиме лише параметри ``level`` в записах "
"``handlers``, а ``level`` і ``propagate`` параметри в ``loggers`` і ``root`` "
"записи."

#: ../../library/logging.config.rst:363
msgid ""
"Using a value in the configuration dict lets configurations to be sent over "
"the wire as pickled dicts to a socket listener. Thus, the logging verbosity "
"of a long-running application can be altered over time with no need to stop "
"and restart the application."
msgstr ""
"Використання значення в конфігураційному диктофоні дозволяє надсилати "
"конфігурації по дроту як маріновані диктофони до слухача сокета. Таким "
"чином, докладність журналу тривалої програми може бути змінена з часом без "
"необхідності зупиняти та перезапускати програму."

#: ../../library/logging.config.rst:371
msgid "Object connections"
msgstr "Об'єктні зв'язки"

#: ../../library/logging.config.rst:373
msgid ""
"The schema describes a set of logging objects - loggers, handlers, "
"formatters, filters - which are connected to each other in an object graph.  "
"Thus, the schema needs to represent connections between the objects.  For "
"example, say that, once configured, a particular logger has attached to it a "
"particular handler.  For the purposes of this discussion, we can say that "
"the logger represents the source, and the handler the destination, of a "
"connection between the two.  Of course in the configured objects this is "
"represented by the logger holding a reference to the handler.  In the "
"configuration dict, this is done by giving each destination object an id "
"which identifies it unambiguously, and then using the id in the source "
"object's configuration to indicate that a connection exists between the "
"source and the destination object with that id."
msgstr ""
"Схема описує набір об’єктів журналювання – реєстратори, обробники, засоби "
"форматування, фільтри – які з’єднані один з одним у графі об’єктів. Таким "
"чином, схема повинна представляти зв'язки між об'єктами. Наприклад, скажіть, "
"що після налаштування певний реєстратор приєднав до нього певний обробник. "
"Для цілей цього обговорення ми можемо сказати, що реєстратор представляє "
"джерело, а обробник — призначення з’єднання між ними. Звичайно, у "
"налаштованих об’єктах це представлено реєстратором, що містить посилання на "
"обробник. У dict конфігурації це робиться шляхом надання кожному об’єкту "
"призначення ідентифікатора, який однозначно ідентифікує його, а потім "
"використання ідентифікатора в конфігурації об’єкта джерела, щоб вказати, що "
"між джерелом і об’єктом призначення існує зв’язок із цим ідентифікатором."

#: ../../library/logging.config.rst:387
msgid "So, for example, consider the following YAML snippet:"
msgstr "Отже, наприклад, розглянемо наступний фрагмент коду YAML:"

#: ../../library/logging.config.rst:408
msgid ""
"(Note: YAML used here because it's a little more readable than the "
"equivalent Python source form for the dictionary.)"
msgstr ""
"(Примітка: тут використовується YAML, оскільки він трохи легший для читання, "
"ніж еквівалентна вихідна форма Python для словника.)"

#: ../../library/logging.config.rst:411
msgid ""
"The ids for loggers are the logger names which would be used "
"programmatically to obtain a reference to those loggers, e.g. ``foo.bar."
"baz``.  The ids for Formatters and Filters can be any string value (such as "
"``brief``, ``precise`` above) and they are transient, in that they are only "
"meaningful for processing the configuration dictionary and used to determine "
"connections between objects, and are not persisted anywhere when the "
"configuration call is complete."
msgstr ""
"Ідентифікатори для реєстраторів — це імена реєстраторів, які "
"використовуватимуться програмно для отримання посилання на ці реєстратори, "
"наприклад. ``foo.bar.baz``. Ідентифікатори для Formatters і Filters можуть "
"бути будь-якими рядковими значеннями (наприклад, ``brief``, ``precise`` "
"вище), і вони тимчасові, оскільки вони мають значення лише для обробки "
"словника конфігурації та використовуються для визначення зв’язків між "
"об’єктами , і ніде не зберігаються після завершення виклику налаштування."

#: ../../library/logging.config.rst:419
msgid ""
"The above snippet indicates that logger named ``foo.bar.baz`` should have "
"two handlers attached to it, which are described by the handler ids ``h1`` "
"and ``h2``. The formatter for ``h1`` is that described by id ``brief``, and "
"the formatter for ``h2`` is that described by id ``precise``."
msgstr ""
"Наведений вище фрагмент вказує, що реєстратор під назвою ``foo.bar.baz`` "
"повинен мати два прикріплених до нього обробника, які описуються "
"ідентифікаторами обробника ``h1`` і ``h2``. Форматування для ``h1`` описано "
"ідентифікатором ``brief``, а засіб форматування для ``h2`` описано "
"ідентифікатором ``precise``."

#: ../../library/logging.config.rst:429
msgid "User-defined objects"
msgstr "Визначені користувачем об'єкти"

#: ../../library/logging.config.rst:431
msgid ""
"The schema supports user-defined objects for handlers, filters and "
"formatters.  (Loggers do not need to have different types for different "
"instances, so there is no support in this configuration schema for user-"
"defined logger classes.)"
msgstr ""
"Схема підтримує визначені користувачем об’єкти для обробників, фільтрів і "
"форматувальників. (Логерам не обов’язково мати різні типи для різних "
"екземплярів, тому в цій схемі конфігурації немає підтримки для визначених "
"користувачем класів журналів.)"

#: ../../library/logging.config.rst:436
msgid ""
"Objects to be configured are described by dictionaries which detail their "
"configuration.  In some places, the logging system will be able to infer "
"from the context how an object is to be instantiated, but when a user-"
"defined object is to be instantiated, the system will not know how to do "
"this.  In order to provide complete flexibility for user-defined object "
"instantiation, the user needs to provide a 'factory' - a callable which is "
"called with a configuration dictionary and which returns the instantiated "
"object. This is signalled by an absolute import path to the factory being "
"made available under the special key ``'()'``.  Here's a concrete example:"
msgstr ""
"Об'єкти, які потрібно конфігурувати, описуються словниками, які детально "
"описують їх конфігурацію. У деяких місцях система журналювання зможе зробити "
"висновок із контексту, як об’єкт має бути створений, але коли потрібно "
"створити екземпляр об’єкта, визначеного користувачем, система не знатиме, як "
"це зробити. Для того, щоб забезпечити повну гнучкість створення екземплярів "
"визначеного користувачем об’єкта, користувачеві необхідно надати \"фабрику\" "
"— виклик, який викликається зі словником конфігурації та повертає створений "
"об’єкт. Про це свідчить абсолютний шлях імпорту до фабрики, доступний за "
"допомогою спеціального ключа ``'()'``. Ось конкретний приклад:"

#: ../../library/logging.config.rst:462
msgid ""
"The above YAML snippet defines three formatters.  The first, with id "
"``brief``, is a standard :class:`logging.Formatter` instance with the "
"specified format string.  The second, with id ``default``, has a longer "
"format and also defines the time format explicitly, and will result in a :"
"class:`logging.Formatter` initialized with those two format strings.  Shown "
"in Python source form, the ``brief`` and ``default`` formatters have "
"configuration sub-dictionaries::"
msgstr ""
"Наведений вище фрагмент YAML визначає три засоби форматування. Перший, з "
"ідентифікатором ``brief``, є стандартним екземпляром :class:`logging."
"Formatter` із вказаним рядком формату. Другий, з ідентифікатором "
"``default``, має довший формат і також явно визначає формат часу, і призведе "
"до :class:`logging.Formatter`, ініціалізованого цими двома рядками формату. "
"Показано у вихідній формі Python, засоби форматування ``brief`` і "
"``default`` мають підсловники конфігурації::"

#: ../../library/logging.config.rst:474
msgid "and::"
msgstr "e::"

#: ../../library/logging.config.rst:481
msgid ""
"respectively, and as these dictionaries do not contain the special key "
"``'()'``, the instantiation is inferred from the context: as a result, "
"standard :class:`logging.Formatter` instances are created.  The "
"configuration sub-dictionary for the third formatter, with id ``custom``, "
"is::"
msgstr ""
"відповідно, і оскільки ці словники не містять спеціального ключа ``'()'``, "
"примірник виводиться з контексту: у результаті створюються стандартні "
"екземпляри :class:`logging.Formatter`. Підсловник конфігурації для третього "
"засобу форматування з ідентифікатором ``custom``:"

#: ../../library/logging.config.rst:494
msgid ""
"and this contains the special key ``'()'``, which means that user-defined "
"instantiation is wanted.  In this case, the specified factory callable will "
"be used. If it is an actual callable it will be used directly - otherwise, "
"if you specify a string (as in the example) the actual callable will be "
"located using normal import mechanisms. The callable will be called with the "
"**remaining** items in the configuration sub-dictionary as keyword "
"arguments.  In the above example, the formatter with id ``custom`` will be "
"assumed to be returned by the call::"
msgstr ""
"і це містить спеціальний ключ ``'()'``, що означає, що потрібне створення, "
"визначене користувачем. У цьому випадку буде використано вказаний фабричний "
"виклик. Якщо це фактичний виклик, він використовуватиметься безпосередньо - "
"інакше, якщо ви вкажете рядок (як у прикладі), фактичний виклик буде "
"знайдено за допомогою звичайних механізмів імпорту. Об’єкт виклику буде "
"викликано з **рештою** елементів у підсловнику конфігурації як ключових "
"аргументів. У наведеному вище прикладі буде припущено, що програма "
"форматування з ідентифікатором ``custom`` повертається викликом::"

#: ../../library/logging.config.rst:506
msgid ""
"The key ``'()'`` has been used as the special key because it is not a valid "
"keyword parameter name, and so will not clash with the names of the keyword "
"arguments used in the call.  The ``'()'`` also serves as a mnemonic that the "
"corresponding value is a callable."
msgstr ""
"Ключ ``'()'`` використовувався як спеціальний ключ, оскільки він не є "
"дійсним ім'ям параметра ключового слова, і тому не буде конфліктувати з "
"назвами аргументів ключового слова, які використовуються у виклику. ``'()'`` "
"також служить мнемонічною ознакою того, що відповідне значення є викликом."

#: ../../library/logging.config.rst:515
msgid "Access to external objects"
msgstr "Доступ до зовнішніх об'єктів"

#: ../../library/logging.config.rst:517
msgid ""
"There are times where a configuration needs to refer to objects external to "
"the configuration, for example ``sys.stderr``.  If the configuration dict is "
"constructed using Python code, this is straightforward, but a problem arises "
"when the configuration is provided via a text file (e.g. JSON, YAML).  In a "
"text file, there is no standard way to distinguish ``sys.stderr`` from the "
"literal string ``'sys.stderr'``.  To facilitate this distinction, the "
"configuration system looks for certain special prefixes in string values and "
"treat them specially.  For example, if the literal string ``'ext://sys."
"stderr'`` is provided as a value in the configuration, then the ``ext://`` "
"will be stripped off and the remainder of the value processed using normal "
"import mechanisms."
msgstr ""
"Бувають випадки, коли конфігурація потребує посилання на об’єкти, зовнішні "
"щодо конфігурації, наприклад ``sys.stderr``. Якщо dict конфігурації створено "
"за допомогою коду Python, це просто, але проблема виникає, коли конфігурація "
"надається через текстовий файл (наприклад, JSON, YAML). У текстовому файлі "
"немає стандартного способу відрізнити ``sys.stderr`` від літерального рядка "
"``'sys.stderr'``. Щоб полегшити це розрізнення, система конфігурації шукає "
"певні спеціальні префікси в рядкових значеннях і обробляє їх спеціальним "
"чином. Наприклад, якщо літеральний рядок ``'ext://sys.stderr'`` надається як "
"значення в конфігурації, тоді ``ext://`` буде видалено, а залишок значення "
"оброблено за допомогою звичайних механізмів імпорту."

#: ../../library/logging.config.rst:530
msgid ""
"The handling of such prefixes is done in a way analogous to protocol "
"handling: there is a generic mechanism to look for prefixes which match the "
"regular expression ``^(?P<prefix>[a-z]+)://(?P<suffix>.*)$`` whereby, if the "
"``prefix`` is recognised, the ``suffix`` is processed in a prefix-dependent "
"manner and the result of the processing replaces the string value.  If the "
"prefix is not recognised, then the string value will be left as-is."
msgstr ""
"Обробка таких префіксів виконується аналогічно до обробки протоколів: існує "
"загальний механізм пошуку префіксів, які відповідають регулярному виразу "
"``^(?P <prefix> [a-z]+)://(?P <suffix> .* )$``, таким чином, якщо "
"``префікс`` розпізнається, ``суфікс`` обробляється залежно від префікса, і "
"результат обробки замінює значення рядка. Якщо префікс не розпізнається, "
"значення рядка залишиться без змін."

#: ../../library/logging.config.rst:542
msgid "Access to internal objects"
msgstr "Доступ до внутрішніх об'єктів"

#: ../../library/logging.config.rst:544
msgid ""
"As well as external objects, there is sometimes also a need to refer to "
"objects in the configuration.  This will be done implicitly by the "
"configuration system for things that it knows about.  For example, the "
"string value ``'DEBUG'`` for a ``level`` in a logger or handler will "
"automatically be converted to the value ``logging.DEBUG``, and the "
"``handlers``, ``filters`` and ``formatter`` entries will take an object id "
"and resolve to the appropriate destination object."
msgstr ""
"Окрім зовнішніх об’єктів, інколи виникає потреба звертатися до об’єктів у "
"конфігурації. Це буде зроблено неявно системою конфігурації для речей, про "
"які вона знає. Наприклад, рядкове значення ``'DEBUG`` для ``level`` у "
"реєстраторі або обробнику буде автоматично перетворено на значення ``logging."
"DEBUG``, а ``обробники``, ``Записи filters`` і ``formatter`` прийматимуть "
"ідентифікатор об’єкта та вирішуватимуть відповідний об’єкт призначення."

#: ../../library/logging.config.rst:552
msgid ""
"However, a more generic mechanism is needed for user-defined objects which "
"are not known to the :mod:`logging` module.  For example, consider :class:"
"`logging.handlers.MemoryHandler`, which takes a ``target`` argument which is "
"another handler to delegate to. Since the system already knows about this "
"class, then in the configuration, the given ``target`` just needs to be the "
"object id of the relevant target handler, and the system will resolve to the "
"handler from the id.  If, however, a user defines a ``my.package.MyHandler`` "
"which has an ``alternate`` handler, the configuration system would not know "
"that the ``alternate`` referred to a handler.  To cater for this, a generic "
"resolution system allows the user to specify:"
msgstr ""
"Однак для визначених користувачем об’єктів, які не відомі модулю :mod:"
"`logging`, потрібен більш загальний механізм. Наприклад, розглянемо :class:"
"`logging.handlers.MemoryHandler`, який приймає аргумент ``target``, який є "
"іншим обробником для делегування. Оскільки системі вже відомо про цей клас, "
"то в конфігурації даний ``target`` має бути просто ідентифікатором об’єкта "
"відповідного цільового обробника, і система вирішить обробник з "
"ідентифікатора. Проте, якщо користувач визначає ``my.package.MyHandler``, "
"який має ``альтернативний`` обробник, система конфігурації не знатиме, що "
"``альтернативний`` посилається на обробник. Для цього загальна система "
"роздільної здатності дозволяє користувачеві вказати:"

#: ../../library/logging.config.rst:574
msgid ""
"The literal string ``'cfg://handlers.file'`` will be resolved in an "
"analogous way to strings with the ``ext://`` prefix, but looking in the "
"configuration itself rather than the import namespace.  The mechanism allows "
"access by dot or by index, in a similar way to that provided by ``str."
"format``.  Thus, given the following snippet:"
msgstr ""
"Літеральний рядок ``'cfg://handlers.file`` буде розв’язано аналогічно до "
"рядків із префіксом ``ext://``, але в самій конфігурації, а не в просторі "
"імен імпорту. Механізм дозволяє доступ за крапкою або за індексом, подібно "
"до того, що надається ``str.format``. Таким чином, враховуючи наступний "
"фрагмент:"

#: ../../library/logging.config.rst:592
msgid ""
"in the configuration, the string ``'cfg://handlers'`` would resolve to the "
"dict with key ``handlers``, the string ``'cfg://handlers.email`` would "
"resolve to the dict with key ``email`` in the ``handlers`` dict, and so on.  "
"The string ``'cfg://handlers.email.toaddrs[1]`` would resolve to ``'dev_team."
"domain.tld'`` and the string ``'cfg://handlers.email.toaddrs[0]'`` would "
"resolve to the value ``'support_team@domain.tld'``. The ``subject`` value "
"could be accessed using either ``'cfg://handlers.email.subject'`` or, "
"equivalently, ``'cfg://handlers.email[subject]'``.  The latter form only "
"needs to be used if the key contains spaces or non-alphanumeric characters.  "
"If an index value consists only of decimal digits, access will be attempted "
"using the corresponding integer value, falling back to the string value if "
"needed."
msgstr ""

#: ../../library/logging.config.rst:606
msgid ""
"Given a string ``cfg://handlers.myhandler.mykey.123``, this will resolve to "
"``config_dict['handlers']['myhandler']['mykey']['123']``. If the string is "
"specified as ``cfg://handlers.myhandler.mykey[123]``, the system will "
"attempt to retrieve the value from ``config_dict['handlers']['myhandler']"
"['mykey'][123]``, and fall back to ``config_dict['handlers']['myhandler']"
"['mykey']['123']`` if that fails."
msgstr ""
"Якщо вказати рядок ``cfg://handlers.myhandler.mykey.123``, це буде виведено "
"в ``config_dict['handlers']['myhandler']['mykey']['123']``. Якщо рядок "
"указано як ``cfg://handlers.myhandler.mykey[123]``, система спробує отримати "
"значення з ``config_dict['handlers']['myhandler']['mykey'] [123]`` і "
"повернутися до ``config_dict['handlers']['myhandler']['mykey']['123']``, "
"якщо це не вдасться."

#: ../../library/logging.config.rst:618
msgid "Import resolution and custom importers"
msgstr "Роздільна здатність імпорту та спеціальні імпортери"

#: ../../library/logging.config.rst:620
msgid ""
"Import resolution, by default, uses the builtin :func:`__import__` function "
"to do its importing. You may want to replace this with your own importing "
"mechanism: if so, you can replace the :attr:`importer` attribute of the :"
"class:`DictConfigurator` or its superclass, the :class:`BaseConfigurator` "
"class. However, you need to be careful because of the way functions are "
"accessed from classes via descriptors. If you are using a Python callable to "
"do your imports, and you want to define it at class level rather than "
"instance level, you need to wrap it with :func:`staticmethod`. For example::"
msgstr ""
"Роздільна здатність імпорту за замовчуванням використовує вбудовану функцію :"
"func:`__import__` для здійснення імпорту. Ви можете замінити це власним "
"механізмом імпорту: якщо так, ви можете замінити атрибут :attr:`importer` :"
"class:`DictConfigurator` або його суперкласу, класу :class:"
"`BaseConfigurator`. Однак вам потрібно бути обережним через спосіб доступу "
"до функцій із класів через дескриптори. Якщо ви використовуєте виклик Python "
"для виконання імпорту, і ви хочете визначити його на рівні класу, а не на "
"рівні екземпляра, вам потрібно обернути його за допомогою :func:"
"`staticmethod`. Наприклад::"

#: ../../library/logging.config.rst:635
msgid ""
"You don't need to wrap with :func:`staticmethod` if you're setting the "
"import callable on a configurator *instance*."
msgstr ""
"Вам не потрібно використовувати :func:`staticmethod`, якщо ви встановлюєте "
"виклик імпорту в *примірнику* конфігуратора."

#: ../../library/logging.config.rst:642
msgid "Configuration file format"
msgstr "Formato do arquivo de configuração"

#: ../../library/logging.config.rst:644
msgid ""
"The configuration file format understood by :func:`fileConfig` is based on :"
"mod:`configparser` functionality. The file must contain sections called "
"``[loggers]``, ``[handlers]`` and ``[formatters]`` which identify by name "
"the entities of each type which are defined in the file. For each such "
"entity, there is a separate section which identifies how that entity is "
"configured.  Thus, for a logger named ``log01`` in the ``[loggers]`` "
"section, the relevant configuration details are held in a section "
"``[logger_log01]``. Similarly, a handler called ``hand01`` in the "
"``[handlers]`` section will have its configuration held in a section called "
"``[handler_hand01]``, while a formatter called ``form01`` in the "
"``[formatters]`` section will have its configuration specified in a section "
"called ``[formatter_form01]``. The root logger configuration must be "
"specified in a section called ``[logger_root]``."
msgstr ""
"Формат файлу конфігурації, який розуміє :func:`fileConfig`, базується на "
"функціях :mod:`configparser`. Файл має містити розділи під назвою "
"``[реєстратори]``, ``[обробники]`` і ``[formatters]``, які ідентифікують за "
"назвою сутності кожного типу, визначені у файлі. Для кожної такої сутності "
"існує окремий розділ, який визначає, як цю сутність налаштовано. Таким "
"чином, для реєстратора з назвою ``log01`` у розділі ``[loggers]`` відповідні "
"деталі конфігурації зберігаються в розділі ``[logger_log01]``. Подібним "
"чином конфігурація обробника під назвою ``hand01`` у розділі ``[handlers]`` "
"зберігатиметься в розділі ``[handler_hand01]``, а програма форматування під "
"назвою ``form01`` у ``Конфігурація розділу [formatters]`` буде вказана в "
"розділі під назвою ``[formatter_form01]``. Конфігурацію кореневого "
"реєстратора необхідно вказати в розділі під назвою ``[logger_root]``."

#: ../../library/logging.config.rst:659
msgid ""
"The :func:`fileConfig` API is older than the :func:`dictConfig` API and does "
"not provide functionality to cover certain aspects of logging. For example, "
"you cannot configure :class:`~logging.Filter` objects, which provide for "
"filtering of messages beyond simple integer levels, using :func:"
"`fileConfig`. If you need to have instances of :class:`~logging.Filter` in "
"your logging configuration, you will need to use :func:`dictConfig`. Note "
"that future enhancements to configuration functionality will be added to :"
"func:`dictConfig`, so it's worth considering transitioning to this newer API "
"when it's convenient to do so."
msgstr ""
"API :func:`fileConfig` старіший за API :func:`dictConfig` і не надає "
"функціональних можливостей для охоплення певних аспектів журналювання. "
"Наприклад, ви не можете налаштувати об’єкти :class:`~logging.Filter`, які "
"забезпечують фільтрацію повідомлень за межами простих цілих рівнів, за "
"допомогою :func:`fileConfig`. Якщо вам потрібно мати екземпляри :class:"
"`~logging.Filter` у конфігурації журналювання, вам потрібно буде "
"використовувати :func:`dictConfig`. Зауважте, що майбутні вдосконалення "
"функціональності конфігурації буде додано до :func:`dictConfig`, тому варто "
"подумати про перехід на цей новий API, коли це буде зручно."

#: ../../library/logging.config.rst:669
msgid "Examples of these sections in the file are given below."
msgstr "Приклади цих розділів у файлі наведені нижче."

#: ../../library/logging.config.rst:682
msgid ""
"The root logger must specify a level and a list of handlers. An example of a "
"root logger section is given below."
msgstr ""
"Кореневий реєстратор повинен вказати рівень і список обробників. Нижче "
"наведено приклад розділу кореневого реєстратора."

#: ../../library/logging.config.rst:691
msgid ""
"The ``level`` entry can be one of ``DEBUG, INFO, WARNING, ERROR, CRITICAL`` "
"or ``NOTSET``. For the root logger only, ``NOTSET`` means that all messages "
"will be logged. Level values are :func:`eval`\\ uated in the context of the "
"``logging`` package's namespace."
msgstr ""

#: ../../library/logging.config.rst:696
msgid ""
"The ``handlers`` entry is a comma-separated list of handler names, which "
"must appear in the ``[handlers]`` section. These names must appear in the "
"``[handlers]`` section and have corresponding sections in the configuration "
"file."
msgstr ""
"Запис ``обробники`` — це список імен обробників, розділених комами, які "
"повинні з’являтися в розділі ``[обробники]``. Ці назви мають відображатися в "
"розділі ``[обробники]`` і мати відповідні розділи у файлі конфігурації."

#: ../../library/logging.config.rst:701
msgid ""
"For loggers other than the root logger, some additional information is "
"required. This is illustrated by the following example."
msgstr ""
"Для реєстраторів, відмінних від кореневого реєстратора, потрібна додаткова "
"інформація. Це ілюструється наступним прикладом."

#: ../../library/logging.config.rst:712
msgid ""
"The ``level`` and ``handlers`` entries are interpreted as for the root "
"logger, except that if a non-root logger's level is specified as ``NOTSET``, "
"the system consults loggers higher up the hierarchy to determine the "
"effective level of the logger. The ``propagate`` entry is set to 1 to "
"indicate that messages must propagate to handlers higher up the logger "
"hierarchy from this logger, or 0 to indicate that messages are **not** "
"propagated to handlers up the hierarchy. The ``qualname`` entry is the "
"hierarchical channel name of the logger, that is to say the name used by the "
"application to get the logger."
msgstr ""
"Записи ``level`` і ``handlers`` інтерпретуються як для кореневого "
"реєстратора, за винятком того, що якщо рівень некореневого реєстратора "
"вказано як ``NOTSET``, система консультується з реєстраторами вищого рівня в "
"ієрархії, щоб визначити ефективний рівень логера. Запис ``пропагувати`` має "
"значення 1, щоб вказати, що повідомлення повинні поширюватися до обробників, "
"які знаходяться вище в ієрархії реєстратора, або 0, щоб вказати, що "
"повідомлення **не** поширюються до обробників, які знаходяться вище в "
"ієрархії. Запис ``qualname`` — це ієрархічна назва каналу реєстратора, тобто "
"ім’я, яке використовується програмою для отримання реєстратора."

#: ../../library/logging.config.rst:721
msgid ""
"Sections which specify handler configuration are exemplified by the "
"following."
msgstr "Розділи, які визначають конфігурацію обробника, представлені нижче."

#: ../../library/logging.config.rst:731
msgid ""
"The ``class`` entry indicates the handler's class (as determined by :func:"
"`eval` in the ``logging`` package's namespace). The ``level`` is interpreted "
"as for loggers, and ``NOTSET`` is taken to mean 'log everything'."
msgstr ""
"Запис ``class`` вказує на клас обробника (як визначено :func:`eval` у "
"просторі імен пакета ``logging``). ``level`` інтерпретується як для "
"реєстраторів, а ``NOTSET`` означає 'зареєструвати все'."

#: ../../library/logging.config.rst:735
msgid ""
"The ``formatter`` entry indicates the key name of the formatter for this "
"handler. If blank, a default formatter (``logging._defaultFormatter``) is "
"used. If a name is specified, it must appear in the ``[formatters]`` section "
"and have a corresponding section in the configuration file."
msgstr ""
"Запис ``formatter`` вказує назву ключа форматера для цього обробника. Якщо "
"пусте, використовується форматування за замовчуванням (``logging."
"_defaultFormatter``). Якщо вказано ім’я, воно повинно відображатися в "
"розділі ``[formatters]`` і мати відповідний розділ у файлі конфігурації."

#: ../../library/logging.config.rst:740
msgid ""
"The ``args`` entry, when :func:`eval`\\ uated in the context of the "
"``logging`` package's namespace, is the list of arguments to the constructor "
"for the handler class. Refer to the constructors for the relevant handlers, "
"or to the examples below, to see how typical entries are constructed. If not "
"provided, it defaults to ``()``."
msgstr ""

#: ../../library/logging.config.rst:746
msgid ""
"The optional ``kwargs`` entry, when :func:`eval`\\ uated in the context of "
"the ``logging`` package's namespace, is the keyword argument dict to the "
"constructor for the handler class. If not provided, it defaults to ``{}``."
msgstr ""

#: ../../library/logging.config.rst:803
msgid ""
"Sections which specify formatter configuration are typified by the following."
msgstr ""
"Розділи, які визначають конфігурацію форматера, представлені наступним чином."

#: ../../library/logging.config.rst:812
msgid ""
"The ``format`` entry is the overall format string, and the ``datefmt`` entry "
"is the :func:`strftime`\\ -compatible date/time format string.  If empty, "
"the package substitutes something which is almost equivalent to specifying "
"the date format string ``'%Y-%m-%d %H:%M:%S'``.  This format also specifies "
"milliseconds, which are appended to the result of using the above format "
"string, with a comma separator.  An example time in this format is "
"``2003-01-23 00:29:50,411``."
msgstr ""

#: ../../library/logging.config.rst:819
msgid ""
"The ``class`` entry is optional.  It indicates the name of the formatter's "
"class (as a dotted module and class name.)  This option is useful for "
"instantiating a :class:`~logging.Formatter` subclass.  Subclasses of :class:"
"`~logging.Formatter` can present exception tracebacks in an expanded or "
"condensed format."
msgstr ""

#: ../../library/logging.config.rst:827
msgid ""
"Due to the use of :func:`eval` as described above, there are potential "
"security risks which result from using the :func:`listen` to send and "
"receive configurations via sockets. The risks are limited to where multiple "
"users with no mutual trust run code on the same machine; see the :func:"
"`listen` documentation for more information."
msgstr ""
"Через використання :func:`eval`, як описано вище, існують потенційні ризики "
"для безпеки, які є результатом використання :func:`listen` для надсилання та "
"отримання конфігурацій через сокети. Ризики обмежені тим, що кілька "
"користувачів, які не мають взаємної довіри, запускають код на одній машині; "
"дивіться документацію :func:`listen` для отримання додаткової інформації."

#: ../../library/logging.config.rst:836
msgid "Module :mod:`logging`"
msgstr "Módulo :mod:`logging`"

#: ../../library/logging.config.rst:836
msgid "API reference for the logging module."
msgstr "Referência da API para o módulo de logging."

#: ../../library/logging.config.rst:838
msgid "Module :mod:`logging.handlers`"
msgstr "Módulo :mod:`logging.handlers`"

#: ../../library/logging.config.rst:839
msgid "Useful handlers included with the logging module."
msgstr "Tratadores úteis incluídos no módulo logging."

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# i17obot <i17obot@rougeth.com>, 2020
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 17:51+0000\n"
"PO-Revision-Date: 2017-02-16 23:08+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/email.message.rst:2
msgid ":mod:`email.message`: Representing an email message"
msgstr ":mod:`email.message`: представляє повідомлення електронної пошти"

#: ../../library/email.message.rst:10
msgid "**Source code:** :source:`Lib/email/message.py`"
msgstr "**Código-fonte:** :source:`Lib/email/message.py`"

#: ../../library/email.message.rst:14
msgid "[1]_"
msgstr "[1]_"

#: ../../library/email.message.rst:16
msgid ""
"The central class in the :mod:`email` package is the :class:`EmailMessage` "
"class, imported from the :mod:`email.message` module.  It is the base class "
"for the :mod:`email` object model.  :class:`EmailMessage` provides the core "
"functionality for setting and querying header fields, for accessing message "
"bodies, and for creating or modifying structured messages."
msgstr ""
"Центральним класом у пакеті :mod:`email` є клас :class:`EmailMessage`, "
"імпортований із модуля :mod:`email.message`. Це базовий клас для об’єктної "
"моделі :mod:`email`. :class:`EmailMessage` забезпечує основну "
"функціональність для налаштування та запиту полів заголовків, для доступу до "
"тіла повідомлень, а також для створення або зміни структурованих повідомлень."

#: ../../library/email.message.rst:22
msgid ""
"An email message consists of *headers* and a *payload* (which is also "
"referred to as the *content*).  Headers are :rfc:`5322` or :rfc:`6532` style "
"field names and values, where the field name and value are separated by a "
"colon.  The colon is not part of either the field name or the field value.  "
"The payload may be a simple text message, or a binary object, or a "
"structured sequence of sub-messages each with their own set of headers and "
"their own payload.  The latter type of payload is indicated by the message "
"having a MIME type such as :mimetype:`multipart/\\*` or :mimetype:`message/"
"rfc822`."
msgstr ""
"Повідомлення електронної пошти складається з *заголовків* і *корисного "
"навантаження* (яке також називають *контентом*). Заголовки — це імена та "
"значення полів у стилі :rfc:`5322` або :rfc:`6532`, де назва поля та "
"значення розділені двокрапкою. Двокрапка не є частиною ані імені поля, ані "
"значення поля. Корисне навантаження може бути простим текстовим "
"повідомленням, або двійковим об’єктом, або структурованою послідовністю "
"підповідомлень, кожне з яких має власний набір заголовків і власне корисне "
"навантаження. Останній тип корисного навантаження вказується повідомленням, "
"що має тип MIME, наприклад :mimetype:`multipart/\\*` або :mimetype:`message/"
"rfc822`."

#: ../../library/email.message.rst:31
msgid ""
"The conceptual model provided by an :class:`EmailMessage` object is that of "
"an ordered dictionary of headers coupled with a *payload* that represents "
"the :rfc:`5322` body of the message, which might be a list of sub-"
"``EmailMessage`` objects.  In addition to the normal dictionary methods for "
"accessing the header names and values, there are methods for accessing "
"specialized information from the headers (for example the MIME content "
"type), for operating on the payload, for generating a serialized version of "
"the message, and for recursively walking over the object tree."
msgstr ""
"Концептуальна модель, надана об’єктом :class:`EmailMessage`, — це "
"впорядкований словник заголовків у поєднанні з *корисним навантаженням*, "
"який представляє тіло :rfc:`5322` повідомлення, яке може бути списком під-` "
"Об’єкти ``EmailMessage``. На додаток до звичайних методів словника для "
"доступу до імен і значень заголовків, існують методи для доступу до "
"спеціальної інформації із заголовків (наприклад, типу вмісту MIME), для "
"роботи з корисним навантаженням, для генерації серіалізованої версії "
"повідомлення та для рекурсивного переходу по дереву об'єктів."

#: ../../library/email.message.rst:40
msgid ""
"The :class:`EmailMessage` dictionary-like interface is indexed by the header "
"names, which must be ASCII values.  The values of the dictionary are strings "
"with some extra methods.  Headers are stored and returned in case-preserving "
"form, but field names are matched case-insensitively.  Unlike a real dict, "
"there is an ordering to the keys, and there can be duplicate keys.  "
"Additional methods are provided for working with headers that have duplicate "
"keys."
msgstr ""
"Інтерфейс :class:`EmailMessage`, схожий на словник, індексується іменами "
"заголовків, які мають бути значеннями ASCII. Значення словника є рядками з "
"деякими додатковими методами. Заголовки зберігаються та повертаються у формі "
"зі збереженням регістру, але імена полів зіставляються без урахування "
"регістру. На відміну від справжнього dict, ключі впорядковані, і ключі "
"можуть дублюватися. Для роботи із заголовками, які мають повторювані ключі, "
"надаються додаткові методи."

#: ../../library/email.message.rst:47
msgid ""
"The *payload* is either a string or bytes object, in the case of simple "
"message objects, or a list of :class:`EmailMessage` objects, for MIME "
"container documents such as :mimetype:`multipart/\\*` and :mimetype:`message/"
"rfc822` message objects."
msgstr ""
"*Корисне навантаження* — це об’єкт рядка чи байтів у випадку простих "
"об’єктів повідомлення, або список об’єктів :class:`EmailMessage` для "
"документів-контейнерів MIME, таких як :mimetype:`multipart/\\*` і :mimetype:"
"`message/rfc822` об’єкти повідомлення."

#: ../../library/email.message.rst:55
msgid ""
"If *policy* is specified use the rules it specifies to update and serialize "
"the representation of the message.  If *policy* is not set, use the :class:"
"`~email.policy.default` policy, which follows the rules of the email RFCs "
"except for line endings (instead of the RFC mandated ``\\r\\n``, it uses the "
"Python standard ``\\n`` line endings).  For more information see the :mod:"
"`~email.policy` documentation."
msgstr ""
"Якщо вказано *політику*, використовуйте правила, які вона визначає, щоб "
"оновити та серіалізувати представлення повідомлення. Якщо *policy* не "
"встановлено, використовуйте політику :class:`~email.policy.default`, яка "
"відповідає правилам RFC електронної пошти, за винятком закінчення рядків "
"(замість RFC, передбаченого ``\\r\\n``, він використовує стандартні "
"закінчення рядків Python ``\\n``). Для отримання додаткової інформації "
"дивіться документацію :mod:`~email.policy`."

#: ../../library/email.message.rst:64
msgid ""
"Return the entire message flattened as a string.  When optional *unixfrom* "
"is true, the envelope header is included in the returned string.  *unixfrom* "
"defaults to ``False``.  For backward compatibility with the base :class:"
"`~email.message.Message` class *maxheaderlen* is accepted, but defaults to "
"``None``, which means that by default the line length is controlled by the :"
"attr:`~email.policy.EmailPolicy.max_line_length` of the policy.  The "
"*policy* argument may be used to override the default policy obtained from "
"the message instance.  This can be used to control some of the formatting "
"produced by the method, since the specified *policy* will be passed to the :"
"class:`~email.generator.Generator`."
msgstr ""
"Повернути все повідомлення зведеним у вигляді рядка. Якщо необов’язковий "
"параметр *unixfrom* має значення true, заголовок конверта включається до "
"поверненого рядка. *unixfrom* за умовчанням має значення ``False``. Для "
"зворотної сумісності з базовим :class:`~email.message.Message` класом "
"*maxheaderlen* прийнято, але за умовчанням встановлено ``None``, що означає, "
"що за замовчуванням довжина рядка контролюється :attr:`~email.policy."
"EmailPolicy.max_line_length` політики. Аргумент *policy* можна "
"використовувати для заміни політики за замовчуванням, отриманої з екземпляра "
"повідомлення. Це можна використовувати для керування частиною форматування, "
"створеного методом, оскільки вказану *політику* буде передано до :class:"
"`~email.generator.Generator`."

#: ../../library/email.message.rst:76 ../../library/email.message.rst:114
msgid ""
"Flattening the message may trigger changes to the :class:`EmailMessage` if "
"defaults need to be filled in to complete the transformation to a string "
"(for example, MIME boundaries may be generated or modified)."
msgstr ""
"Зведення повідомлення може викликати зміни в :class:`EmailMessage`, якщо для "
"завершення перетворення в рядок необхідно вказати значення за умовчанням "
"(наприклад, можуть бути згенеровані або змінені межі MIME)."

#: ../../library/email.message.rst:80
msgid ""
"Note that this method is provided as a convenience and may not be the most "
"useful way to serialize messages in your application, especially if you are "
"dealing with multiple messages.  See :class:`email.generator.Generator` for "
"a more flexible API for serializing messages.  Note also that this method is "
"restricted to producing messages serialized as \"7 bit clean\" when :attr:"
"`~email.policy.EmailPolicy.utf8` is ``False``, which is the default."
msgstr ""
"Зауважте, що цей метод надається для зручності та може бути не найкориснішим "
"способом серіалізації повідомлень у вашій програмі, особливо якщо ви маєте "
"справу з кількома повідомленнями. Перегляньте :class:`email.generator."
"Generator` для більш гнучкого API для серіалізації повідомлень. Зауважте "
"також, що цей метод обмежений створенням повідомлень, серіалізованих як \"7 "
"bit clean\", якщо :attr:`~email.policy.EmailPolicy.utf8` має значення "
"``False``, що є типовим."

#: ../../library/email.message.rst:88
msgid ""
"the default behavior when *maxheaderlen* is not specified was changed from "
"defaulting to 0 to defaulting to the value of *max_line_length* from the "
"policy."
msgstr ""
"поведінку за замовчуванням, коли *maxheaderlen* не вказано, було змінено з 0 "
"на значення *max_line_length* із політики."

#: ../../library/email.message.rst:95
msgid ""
"Equivalent to ``as_string(policy=self.policy.clone(utf8=True))``.  Allows "
"``str(msg)`` to produce a string containing the serialized message in a "
"readable format."
msgstr ""
"Еквівалент ``as_string(policy=self.policy.clone(utf8=True))``. Дозволяє "
"``str(msg)`` створювати рядок, що містить серіалізоване повідомлення в "
"читабельному форматі."

#: ../../library/email.message.rst:99
msgid ""
"the method was changed to use ``utf8=True``, thus producing an :rfc:`6531`-"
"like message representation, instead of being a direct alias for :meth:"
"`as_string`."
msgstr ""
"метод було змінено на використання ``utf8=True``, таким чином створюючи "
"представлення повідомлення, схоже на :rfc:`6531`, замість прямого псевдоніма "
"для :meth:`as_string`."

#: ../../library/email.message.rst:106
msgid ""
"Return the entire message flattened as a bytes object.  When optional "
"*unixfrom* is true, the envelope header is included in the returned string.  "
"*unixfrom* defaults to ``False``.  The *policy* argument may be used to "
"override the default policy obtained from the message instance. This can be "
"used to control some of the formatting produced by the method, since the "
"specified *policy* will be passed to the :class:`~email.generator."
"BytesGenerator`."
msgstr ""
"Повертає все повідомлення зведене як об’єкт bytes. Якщо необов’язковий "
"параметр *unixfrom* має значення true, заголовок конверта включається до "
"поверненого рядка. *unixfrom* за умовчанням має значення ``False``. Аргумент "
"*policy* можна використовувати для заміни політики за замовчуванням, "
"отриманої з екземпляра повідомлення. Це можна використовувати для керування "
"частиною форматування, створеного методом, оскільки вказану *політику* буде "
"передано до :class:`~email.generator.BytesGenerator`."

#: ../../library/email.message.rst:118
msgid ""
"Note that this method is provided as a convenience and may not be the most "
"useful way to serialize messages in your application, especially if you are "
"dealing with multiple messages.  See :class:`email.generator.BytesGenerator` "
"for a more flexible API for serializing messages."
msgstr ""
"Зауважте, що цей метод надається для зручності та може бути не найкориснішим "
"способом серіалізації повідомлень у вашій програмі, особливо якщо ви маєте "
"справу з кількома повідомленнями. Перегляньте :class:`email.generator."
"BytesGenerator` для більш гнучкого API для серіалізації повідомлень."

#: ../../library/email.message.rst:127
msgid ""
"Equivalent to :meth:`.as_bytes()`.  Allows ``bytes(msg)`` to produce a bytes "
"object containing the serialized message."
msgstr ""
"Еквівалент :meth:`.as_bytes()`. Дозволяє ``bytes(msg)`` створити об'єкт "
"bytes, що містить серіалізоване повідомлення."

#: ../../library/email.message.rst:133
msgid ""
"Return ``True`` if the message's payload is a list of sub-\\ :class:"
"`EmailMessage` objects, otherwise return ``False``.  When :meth:"
"`is_multipart` returns ``False``, the payload should be a string object "
"(which might be a CTE encoded binary payload).  Note that :meth:"
"`is_multipart` returning ``True`` does not necessarily mean that \"msg."
"get_content_maintype() == 'multipart'\" will return the ``True``. For "
"example, ``is_multipart`` will return ``True`` when the :class:"
"`EmailMessage` is of type ``message/rfc822``."
msgstr ""
"Повертає ``True``, якщо корисним навантаженням повідомлення є список sub-\\ :"
"class:`EmailMessage` об’єктів, інакше повертає ``False``. Коли :meth:"
"`is_multipart` повертає ``False``, корисним навантаженням має бути рядковий "
"об’єкт (який може бути двійковим навантаженням у кодуванні CTE). Зауважте, "
"що :meth:`is_multipart`, що повертає ``True``, не обов’язково означає, що "
"\"msg.get_content_maintype() == 'multipart'\" поверне ``True``. Наприклад, "
"``is_multipart`` поверне ``True``, якщо :class:`EmailMessage` має тип "
"``message/rfc822``."

#: ../../library/email.message.rst:145
msgid ""
"Set the message's envelope header to *unixfrom*, which should be a string.  "
"(See :class:`~mailbox.mboxMessage` for a brief description of this header.)"
msgstr ""
"Встановіть заголовок конверта повідомлення на *unixfrom*, який має бути "
"рядком. (Див. :class:`~mailbox.mboxMessage` для короткого опису цього "
"заголовка.)"

#: ../../library/email.message.rst:152
msgid ""
"Return the message's envelope header.  Defaults to ``None`` if the envelope "
"header was never set."
msgstr ""
"Повернути заголовок конверта повідомлення. За замовчуванням ``None``, якщо "
"заголовок конверта ніколи не встановлювався."

#: ../../library/email.message.rst:156
msgid ""
"The following methods implement the mapping-like interface for accessing the "
"message's headers.  Note that there are some semantic differences between "
"these methods and a normal mapping (i.e. dictionary) interface.  For "
"example, in a dictionary there are no duplicate keys, but here there may be "
"duplicate message headers.  Also, in dictionaries there is no guaranteed "
"order to the keys returned by :meth:`keys`, but in an :class:`EmailMessage` "
"object, headers are always returned in the order they appeared in the "
"original message, or in which they were added to the message later.  Any "
"header deleted and then re-added is always appended to the end of the header "
"list."
msgstr ""
"Наступні методи реалізують схожий на відображення інтерфейс для доступу до "
"заголовків повідомлення. Зверніть увагу, що існують деякі семантичні "
"відмінності між цими методами та інтерфейсом звичайного відображення (тобто "
"словника). Наприклад, у словнику немає дублікатів ключів, але тут можуть "
"бути дублікати заголовків повідомлень. Крім того, у словниках немає "
"гарантованого порядку ключів, які повертає :meth:`keys`, але в об’єкті :"
"class:`EmailMessage` заголовки завжди повертаються в тому порядку, в якому "
"вони з’явилися в оригінальному повідомленні або в якому вони були додані до "
"повідомлення пізніше. Будь-який заголовок, видалений і потім знову доданий, "
"завжди додається в кінець списку заголовків."

#: ../../library/email.message.rst:167
msgid ""
"These semantic differences are intentional and are biased toward convenience "
"in the most common use cases."
msgstr ""
"Ці семантичні відмінності є навмисними та спрямовані на зручність у "
"найпоширеніших випадках використання."

#: ../../library/email.message.rst:170
msgid ""
"Note that in all cases, any envelope header present in the message is not "
"included in the mapping interface."
msgstr ""
"Зауважте, що в усіх випадках будь-який заголовок конверта, присутній у "
"повідомленні, не включається в інтерфейс зіставлення."

#: ../../library/email.message.rst:176
msgid "Return the total number of headers, including duplicates."
msgstr "Повертає загальну кількість заголовків, включаючи дублікати."

#: ../../library/email.message.rst:181
msgid ""
"Return ``True`` if the message object has a field named *name*. Matching is "
"done without regard to case and *name* does not include the trailing colon.  "
"Used for the ``in`` operator.  For example::"
msgstr ""
"Повертає ``True``, якщо об’єкт повідомлення має поле з назвою *name*. "
"Зіставлення виконується без урахування регістру, а *ім’я* не містить "
"двокрапки в кінці. Використовується для оператора ``in``. Наприклад::"

#: ../../library/email.message.rst:191
msgid ""
"Return the value of the named header field.  *name* does not include the "
"colon field separator.  If the header is missing, ``None`` is returned; a :"
"exc:`KeyError` is never raised."
msgstr ""
"Повертає значення названого поля заголовка. *ім’я* не містить двокрапку-"
"роздільник полів. Якщо заголовок відсутній, повертається ``None``; a :exc:"
"`KeyError` ніколи не виникає."

#: ../../library/email.message.rst:195
msgid ""
"Note that if the named field appears more than once in the message's "
"headers, exactly which of those field values will be returned is undefined.  "
"Use the :meth:`get_all` method to get the values of all the extant headers "
"named *name*."
msgstr ""
"Зауважте, що якщо назване поле з’являється більше одного разу в заголовках "
"повідомлення, яке саме значення полів буде повернуто, не визначено. "
"Використовуйте метод :meth:`get_all`, щоб отримати значення всіх існуючих "
"заголовків з назвою *name*."

#: ../../library/email.message.rst:200
msgid ""
"Using the standard (non-``compat32``) policies, the returned value is an "
"instance of a subclass of :class:`email.headerregistry.BaseHeader`."
msgstr ""
"Використовуючи стандартні політики (не ``compat32``), повернуте значення є "
"екземпляром підкласу :class:`email.headerregistry.BaseHeader`."

#: ../../library/email.message.rst:206
msgid ""
"Add a header to the message with field name *name* and value *val*.  The "
"field is appended to the end of the message's existing headers."
msgstr ""
"Додайте до повідомлення заголовок із назвою поля *name* і значенням *val*. "
"Поле додається в кінці існуючих заголовків повідомлення."

#: ../../library/email.message.rst:209
msgid ""
"Note that this does *not* overwrite or delete any existing header with the "
"same name.  If you want to ensure that the new header is the only one "
"present in the message with field name *name*, delete the field first, e.g.::"
msgstr ""
"Зауважте, що це *не* перезаписує та не видаляє будь-який існуючий заголовок "
"із такою ж назвою. Якщо ви хочете переконатися, що новий заголовок є єдиним "
"у повідомленні з назвою поля *name*, спочатку видаліть це поле, наприклад::"

#: ../../library/email.message.rst:216
msgid ""
"If the :mod:`policy` defines certain headers to be unique (as the standard "
"policies do), this method may raise a :exc:`ValueError` when an attempt is "
"made to assign a value to such a header when one already exists.  This "
"behavior is intentional for consistency's sake, but do not depend on it as "
"we may choose to make such assignments do an automatic deletion of the "
"existing header in the future."
msgstr ""
"Якщо :mod:`policy` визначає певні заголовки як унікальні (як стандартні "
"політики), цей метод може викликати :exc:`ValueError`, коли робиться спроба "
"призначити значення такому заголовку, коли він уже існує . Така поведінка є "
"навмисною для забезпечення узгодженості, але не залежить від неї, оскільки "
"ми можемо зробити такі призначення автоматичним видаленням існуючого "
"заголовка в майбутньому."

#: ../../library/email.message.rst:226
msgid ""
"Delete all occurrences of the field with name *name* from the message's "
"headers.  No exception is raised if the named field isn't present in the "
"headers."
msgstr ""
"Видалити всі входження поля з назвою *ім’я* із заголовків повідомлення. "
"Жодного винятку не створюється, якщо назване поле відсутнє в заголовках."

#: ../../library/email.message.rst:233
msgid "Return a list of all the message's header field names."
msgstr "Повертає список імен усіх полів заголовка повідомлення."

#: ../../library/email.message.rst:238
msgid "Return a list of all the message's field values."
msgstr "Повертає список усіх значень полів повідомлення."

#: ../../library/email.message.rst:243
msgid ""
"Return a list of 2-tuples containing all the message's field headers and "
"values."
msgstr ""
"Повертає список із двох кортежів, що містить усі заголовки та значення полів "
"повідомлення."

#: ../../library/email.message.rst:249
msgid ""
"Return the value of the named header field.  This is identical to :meth:"
"`__getitem__` except that optional *failobj* is returned if the named header "
"is missing (*failobj* defaults to ``None``)."
msgstr ""
"Повертає значення названого поля заголовка. Це ідентично :meth:"
"`__getitem__`, за винятком того, що необов’язковий *failobj* повертається, "
"якщо іменований заголовок відсутній (*failobj* за замовчуванням має значення "
"``None``)."

#: ../../library/email.message.rst:254
msgid "Here are some additional useful header related methods:"
msgstr "Ось кілька додаткових корисних методів, пов’язаних із заголовками:"

#: ../../library/email.message.rst:259
msgid ""
"Return a list of all the values for the field named *name*. If there are no "
"such named headers in the message, *failobj* is returned (defaults to "
"``None``)."
msgstr ""
"Повертає список усіх значень для поля з назвою *name*. Якщо в повідомленні "
"немає таких іменованих заголовків, повертається *failobj* (за замовчуванням "
"``None``)."

#: ../../library/email.message.rst:266
msgid ""
"Extended header setting.  This method is similar to :meth:`__setitem__` "
"except that additional header parameters can be provided as keyword "
"arguments.  *_name* is the header field to add and *_value* is the *primary* "
"value for the header."
msgstr ""
"Розширене налаштування заголовка. Цей метод подібний до :meth:`__setitem__` "
"за винятком того, що додаткові параметри заголовка можуть бути надані як "
"аргументи ключового слова. *_name* — це поле заголовка, яке потрібно додати, "
"а *_value* — це *основне* значення для заголовка."

#: ../../library/email.message.rst:271
msgid ""
"For each item in the keyword argument dictionary *_params*, the key is taken "
"as the parameter name, with underscores converted to dashes (since dashes "
"are illegal in Python identifiers).  Normally, the parameter will be added "
"as ``key=\"value\"`` unless the value is ``None``, in which case only the "
"key will be added."
msgstr ""
"Для кожного елемента в словнику аргументів ключових слів *_params* ключ "
"береться як ім’я параметра, а символи підкреслення перетворюються на тире "
"(оскільки тире заборонені в ідентифікаторах Python). Зазвичай параметр буде "
"додано як ``key=\"value\"``, якщо значення не буде ``None``, у цьому випадку "
"буде додано лише ключ."

#: ../../library/email.message.rst:277
msgid ""
"If the value contains non-ASCII characters, the charset and language may be "
"explicitly controlled by specifying the value as a three tuple in the format "
"``(CHARSET, LANGUAGE, VALUE)``, where ``CHARSET`` is a string naming the "
"charset to be used to encode the value, ``LANGUAGE`` can usually be set to "
"``None`` or the empty string (see :rfc:`2231` for other possibilities), and "
"``VALUE`` is the string value containing non-ASCII code points.  If a three "
"tuple is not passed and the value contains non-ASCII characters, it is "
"automatically encoded in :rfc:`2231` format using a ``CHARSET`` of ``utf-8`` "
"and a ``LANGUAGE`` of ``None``."
msgstr ""
"Якщо значення містить символи, відмінні від ASCII, кодуванням і мовою можна "
"явно керувати, вказавши значення у вигляді трьох кортежів у форматі ``(НАБОР "
"СИГНАЛІВ, МОВА, ЗНАЧЕННЯ)``, де ``НАБІР СИГНАЛІВ`` — це назва рядка набір "
"символів, який буде використано для кодування значення, ``LANGUAGE`` "
"зазвичай може бути встановлено на ``None`` або порожній рядок (перегляньте :"
"rfc:`2231` для інших можливостей), а ``VALUE`` є значення рядка, що містить "
"кодові точки, відмінні від ASCII. Якщо три кортежу не передано і значення "
"містить символи, відмінні від ASCII, воно автоматично кодується у форматі :"
"rfc:`2231` з використанням ``CHARSET`` ``utf-8`` і ``LANGUAGE`` з "
"``Жодного``."

#: ../../library/email.message.rst:287
msgid "Here is an example::"
msgstr "Aqui está um exemplo::"

#: ../../library/email.message.rst:291
msgid "This will add a header that looks like ::"
msgstr "Це додасть заголовок, який виглядає так::"

#: ../../library/email.message.rst:295
msgid "An example of the extended interface with non-ASCII characters::"
msgstr "Приклад розширеного інтерфейсу з не-ASCII символами::"

#: ../../library/email.message.rst:303
msgid ""
"Replace a header.  Replace the first header found in the message that "
"matches *_name*, retaining header order and field name case of the original "
"header.  If no matching header is found, raise a :exc:`KeyError`."
msgstr ""
"Замінити заголовок. Замініть перший знайдений у повідомленні заголовок, який "
"відповідає *_name*, зберігаючи порядок заголовків і регістр імені поля "
"вихідного заголовка. Якщо відповідного заголовка не знайдено, викликайте :"
"exc:`KeyError`."

#: ../../library/email.message.rst:311
msgid ""
"Return the message's content type, coerced to lower case of the form :"
"mimetype:`maintype/subtype`.  If there is no :mailheader:`Content-Type` "
"header in the message return the value returned by :meth:"
"`get_default_type`.  If the :mailheader:`Content-Type` header is invalid, "
"return ``text/plain``."
msgstr ""
"Повертає тип вмісту повідомлення, переведений у нижній регістр у формі :"
"mimetype:`maintype/subtype`. Якщо в повідомленні немає заголовка :mailheader:"
"`Content-Type`, повертається значення, яке повертає :meth:"
"`get_default_type`. Якщо заголовок :mailheader:`Content-Type` недійсний, "
"поверніть ``text/plain``."

#: ../../library/email.message.rst:317
msgid ""
"(According to :rfc:`2045`, messages always have a default type, :meth:"
"`get_content_type` will always return a value.  :rfc:`2045` defines a "
"message's default type to be :mimetype:`text/plain` unless it appears inside "
"a :mimetype:`multipart/digest` container, in which case it would be :"
"mimetype:`message/rfc822`.  If the :mailheader:`Content-Type` header has an "
"invalid type specification, :rfc:`2045` mandates that the default type be :"
"mimetype:`text/plain`.)"
msgstr ""
"(Відповідно до :rfc:`2045`, повідомлення завжди мають тип за замовчуванням, :"
"meth:`get_content_type` завжди повертатиме значення. :rfc:`2045` визначає "
"тип повідомлення за замовчуванням як :mimetype:`text/plain` якщо він не "
"з’являється всередині контейнера :mimetype:`multipart/digest`, у такому "
"випадку це буде :mimetype:`message/rfc822`. Якщо заголовок :mailheader:"
"`Content-Type` має недійсну специфікацію типу, :rfc:`2045` вимагає, щоб тип "
"за замовчуванням був :mimetype:`text/plain`.)"

#: ../../library/email.message.rst:328
msgid ""
"Return the message's main content type.  This is the :mimetype:`maintype` "
"part of the string returned by :meth:`get_content_type`."
msgstr ""
"Повернути основний тип вмісту повідомлення. Це :mimetype:`maintype` частина "
"рядка, яку повертає :meth:`get_content_type`."

#: ../../library/email.message.rst:334
msgid ""
"Return the message's sub-content type.  This is the :mimetype:`subtype` part "
"of the string returned by :meth:`get_content_type`."
msgstr ""
"Повернути тип підвмісту повідомлення. Це :mimetype:`subtype` частина рядка, "
"яку повертає :meth:`get_content_type`."

#: ../../library/email.message.rst:340
msgid ""
"Return the default content type.  Most messages have a default content type "
"of :mimetype:`text/plain`, except for messages that are subparts of :"
"mimetype:`multipart/digest` containers.  Such subparts have a default "
"content type of :mimetype:`message/rfc822`."
msgstr ""
"Повернути типовий тип вмісту. Більшість повідомлень мають стандартний тип "
"вмісту :mimetype:`text/plain`, за винятком повідомлень, які є підчастинами "
"контейнерів :mimetype:`multipart/digest`. Такі підчастини мають типовий тип "
"вмісту :mimetype:`message/rfc822`."

#: ../../library/email.message.rst:348
msgid ""
"Set the default content type.  *ctype* should either be :mimetype:`text/"
"plain` or :mimetype:`message/rfc822`, although this is not enforced.  The "
"default content type is not stored in the :mailheader:`Content-Type` header, "
"so it only affects the return value of the ``get_content_type`` methods when "
"no :mailheader:`Content-Type` header is present in the message."
msgstr ""
"Встановіть тип вмісту за замовчуванням. *ctype* має бути :mimetype:`text/"
"plain` або :mimetype:`message/rfc822`, хоча це не обов’язково. Тип вмісту за "
"замовчуванням не зберігається в заголовку :mailheader:`Content-Type`, тому "
"він впливає лише на значення, що повертається методами ``get_content_type``, "
"якщо в повідомленні немає заголовка :mailheader:`Content-Type` ."

#: ../../library/email.message.rst:359
msgid ""
"Set a parameter in the :mailheader:`Content-Type` header.  If the parameter "
"already exists in the header, replace its value with *value*. When *header* "
"is ``Content-Type`` (the default) and the header does not yet exist in the "
"message, add it, set its value to :mimetype:`text/plain`, and append the new "
"parameter value.  Optional *header* specifies an alternative header to :"
"mailheader:`Content-Type`."
msgstr ""
"Установіть параметр у заголовку :mailheader:`Content-Type`. Якщо параметр "
"уже існує в заголовку, замініть його значення на *value*. Якщо *header* має "
"значення ``Content-Type`` (за замовчуванням), а заголовок ще не існує в "
"повідомленні, додайте його, установіть для нього значення :mimetype:`text/"
"plain` і додайте нове значення параметра. Необов’язковий *header* визначає "
"альтернативний заголовок :mailheader:`Content-Type`."

#: ../../library/email.message.rst:366
msgid ""
"If the value contains non-ASCII characters, the charset and language may be "
"explicitly specified using the optional *charset* and *language* "
"parameters.  Optional *language* specifies the :rfc:`2231` language, "
"defaulting to the empty string.  Both *charset* and *language* should be "
"strings.  The default is to use the ``utf8`` *charset* and ``None`` for the "
"*language*."
msgstr ""
"Якщо значення містить символи, відмінні від ASCII, кодування та мову можна "
"вказати явно за допомогою додаткових параметрів *charset* і *language*. "
"Необов’язковий *мова* вказує мову :rfc:`2231`, за умовчанням порожній рядок. "
"І *charset*, і *language* мають бути рядками. За замовчуванням для *мови* "
"використовується ``utf8`` *charset* і ``None``."

#: ../../library/email.message.rst:373
msgid ""
"If *replace* is ``False`` (the default) the header is moved to the end of "
"the list of headers.  If *replace* is ``True``, the header will be updated "
"in place."
msgstr ""
"Якщо *replace* має значення ``False`` (за замовчуванням), заголовок "
"переміщується в кінець списку заголовків. Якщо *replace* має значення "
"``True``, заголовок буде оновлено на місці."

#: ../../library/email.message.rst:377 ../../library/email.message.rst:394
msgid ""
"Use of the *requote* parameter with :class:`EmailMessage` objects is "
"deprecated."
msgstr ""
"Uso do parâmetro *requote* com objetos :class:`EmailMessage`  está "
"descontinuado."

#: ../../library/email.message.rst:380
msgid ""
"Note that existing parameter values of headers may be accessed through the :"
"attr:`~email.headerregistry.BaseHeader.params` attribute of the header value "
"(for example, ``msg['Content-Type'].params['charset']``)."
msgstr ""
"Зауважте, що наявні значення параметрів заголовків можна отримати через "
"атрибут :attr:`~email.headerregistry.BaseHeader.params` значення заголовка "
"(наприклад, ``msg['Content-Type'].params['charset' ]``)."

#: ../../library/email.message.rst:384
msgid "``replace`` keyword was added."
msgstr "Palavra-chave ``replace`` foi adicionada."

#: ../../library/email.message.rst:389
msgid ""
"Remove the given parameter completely from the :mailheader:`Content-Type` "
"header.  The header will be re-written in place without the parameter or its "
"value.  Optional *header* specifies an alternative to :mailheader:`Content-"
"Type`."
msgstr ""
"Повністю вилучіть вказаний параметр із заголовка :mailheader:`Content-Type`. "
"Заголовок буде перезаписано на місці без параметра чи його значення. "
"Необов’язковий *заголовок* визначає альтернативу :mailheader:`Content-Type`."

#: ../../library/email.message.rst:400
msgid ""
"Return the value of the ``filename`` parameter of the :mailheader:`Content-"
"Disposition` header of the message.  If the header does not have a "
"``filename`` parameter, this method falls back to looking for the ``name`` "
"parameter on the :mailheader:`Content-Type` header.  If neither is found, or "
"the header is missing, then *failobj* is returned. The returned string will "
"always be unquoted as per :func:`email.utils.unquote`."
msgstr ""
"Повертає значення параметра ``filename`` заголовка :mailheader:`Content-"
"Disposition` повідомлення. Якщо заголовок не має параметра ``filename``, цей "
"метод повертається до пошуку параметра ``name`` у заголовку :mailheader:"
"`Content-Type`. Якщо нічого не знайдено або відсутній заголовок, "
"повертається *failobj*. Повернений рядок завжди буде без лапок відповідно "
"до :func:`email.utils.unquote`."

#: ../../library/email.message.rst:411
msgid ""
"Return the value of the ``boundary`` parameter of the :mailheader:`Content-"
"Type` header of the message, or *failobj* if either the header is missing, "
"or has no ``boundary`` parameter.  The returned string will always be "
"unquoted as per :func:`email.utils.unquote`."
msgstr ""
"Повертає значення параметра ``boundary`` заголовка :mailheader:`Content-"
"Type` повідомлення або *failobj*, якщо заголовок відсутній або не має "
"параметра ``boundary``. Повернений рядок завжди буде без лапок відповідно "
"до :func:`email.utils.unquote`."

#: ../../library/email.message.rst:419
msgid ""
"Set the ``boundary`` parameter of the :mailheader:`Content-Type` header to "
"*boundary*.  :meth:`set_boundary` will always quote *boundary* if "
"necessary.  A :exc:`~email.errors.HeaderParseError` is raised if the message "
"object has no :mailheader:`Content-Type` header."
msgstr ""
"Установіть для параметра ``boundary`` заголовка :mailheader:`Content-Type` "
"значення *boundary*. :meth:`set_boundary` завжди братиме *boundary* у лапки, "
"якщо необхідно. Помилка :exc:`~email.errors.HeaderParseError` виникає, якщо "
"об’єкт повідомлення не має заголовка :mailheader:`Content-Type`."

#: ../../library/email.message.rst:424
msgid ""
"Note that using this method is subtly different from deleting the old :"
"mailheader:`Content-Type` header and adding a new one with the new boundary "
"via :meth:`add_header`, because :meth:`set_boundary` preserves the order of "
"the :mailheader:`Content-Type` header in the list of headers."
msgstr ""
"Зауважте, що використання цього методу дещо відрізняється від видалення "
"старого заголовка :mailheader:`Content-Type` і додавання нового з новою "
"межею за допомогою :meth:`add_header`, оскільки :meth:`set_boundary` "
"зберігає порядок заголовок :mailheader:`Content-Type` у списку заголовків."

#: ../../library/email.message.rst:433
msgid ""
"Return the ``charset`` parameter of the :mailheader:`Content-Type` header, "
"coerced to lower case.  If there is no :mailheader:`Content-Type` header, or "
"if that header has no ``charset`` parameter, *failobj* is returned."
msgstr ""
"Повертає параметр ``charset`` заголовка :mailheader:`Content-Type` у "
"нижньому регістрі. Якщо немає заголовка :mailheader:`Content-Type` або цей "
"заголовок не має параметра ``charset``, повертається *failobj*."

#: ../../library/email.message.rst:440
msgid ""
"Return a list containing the character set names in the message.  If the "
"message is a :mimetype:`multipart`, then the list will contain one element "
"for each subpart in the payload, otherwise, it will be a list of length 1."
msgstr ""
"Повернути список із назвами наборів символів у повідомленні. Якщо "
"повідомлення є :mimetype:`multipart`, тоді список міститиме один елемент для "
"кожної підчастини в корисному навантаженні, інакше це буде список довжиною 1."

#: ../../library/email.message.rst:444
msgid ""
"Each item in the list will be a string which is the value of the ``charset`` "
"parameter in the :mailheader:`Content-Type` header for the represented "
"subpart.  If the subpart has no :mailheader:`Content-Type` header, no "
"``charset`` parameter, or is not of the :mimetype:`text` main MIME type, "
"then that item in the returned list will be *failobj*."
msgstr ""
"Кожен елемент у списку буде рядком, який є значенням параметра ``charset`` у "
"заголовку :mailheader:`Content-Type` для представленої підчастини. Якщо "
"підчастина не має заголовка :mailheader:`Content-Type`, параметра "
"``charset`` або не належить до основного типу MIME :mimetype:`text`, тоді "
"цей елемент у списку буде *failobj* ."

#: ../../library/email.message.rst:453
msgid ""
"Return ``True`` if there is a :mailheader:`Content-Disposition` header and "
"its (case insensitive) value is ``attachment``, ``False`` otherwise."
msgstr ""
"Повертає ``True``, якщо є заголовок :mailheader:`Content-Disposition` і його "
"(незалежне від регістру) значення є ``attachment``, ``False`` інакше."

#: ../../library/email.message.rst:456
msgid ""
"is_attachment is now a method instead of a property, for consistency with :"
"meth:`~email.message.Message.is_multipart`."
msgstr ""
"is_attachment тепер є методом замість властивості, для узгодженості з :meth:"
"`~email.message.Message.is_multipart`."

#: ../../library/email.message.rst:463
msgid ""
"Return the lowercased value (without parameters) of the message's :"
"mailheader:`Content-Disposition` header if it has one, or ``None``.  The "
"possible values for this method are *inline*, *attachment* or ``None`` if "
"the message follows :rfc:`2183`."
msgstr ""
"Повертає значення в нижньому регістрі (без параметрів) заголовка "
"повідомлення :mailheader:`Content-Disposition`, якщо воно є, або ``None``. "
"Можливі значення для цього методу: *inline*, *attachment* або ``None``, якщо "
"повідомлення слідує за :rfc:`2183`."

#: ../../library/email.message.rst:471
msgid ""
"The following methods relate to interrogating and manipulating the content "
"(payload) of the message."
msgstr ""
"Наступні методи стосуються опитування та маніпулювання вмістом (корисним "
"навантаженням) повідомлення."

#: ../../library/email.message.rst:477
msgid ""
"The :meth:`walk` method is an all-purpose generator which can be used to "
"iterate over all the parts and subparts of a message object tree, in depth-"
"first traversal order.  You will typically use :meth:`walk` as the iterator "
"in a ``for`` loop; each iteration returns the next subpart."
msgstr ""
"Метод :meth:`walk` — це універсальний генератор, який можна використовувати "
"для перебору всіх частин і підчастин дерева об’єктів повідомлення в порядку "
"проходження спочатку в глибину. Ви зазвичай використовуєте :meth:`walk` як "
"ітератор у циклі ``for``; кожна ітерація повертає наступну підчастину."

#: ../../library/email.message.rst:482
msgid ""
"Here's an example that prints the MIME type of every part of a multipart "
"message structure:"
msgstr ""
"Ось приклад, який друкує тип MIME кожної частини структури повідомлення, що "
"складається з кількох частин:"

#: ../../library/email.message.rst:503
msgid ""
"``walk`` iterates over the subparts of any part where :meth:`is_multipart` "
"returns ``True``, even though ``msg.get_content_maintype() == 'multipart'`` "
"may return ``False``.  We can see this in our example by making use of the "
"``_structure`` debug helper function:"
msgstr ""
"``walk`` повторює підчастини будь-якої частини, де :meth:`is_multipart` "
"повертає ``True``, навіть якщо ``msg.get_content_maintype() == 'multipart'`` "
"може повернути ``False``. Ми можемо побачити це в нашому прикладі, "
"використовуючи допоміжну функцію налагодження ``_structure``:"

#: ../../library/email.message.rst:531
msgid ""
"Here the ``message`` parts are not ``multiparts``, but they do contain "
"subparts. ``is_multipart()`` returns ``True`` and ``walk`` descends into the "
"subparts."
msgstr ""
"Тут частини ``message`` не є ``multiparts``, але вони містять підчастини. "
"``is_multipart()`` повертає ``True`` і ``walk`` спускається до підчастин."

#: ../../library/email.message.rst:538
msgid ""
"Return the MIME part that is the best candidate to be the \"body\" of the "
"message."
msgstr ""
"Повертає частину MIME, яка є найкращим кандидатом на роль \"тіла\" "
"повідомлення."

#: ../../library/email.message.rst:541
msgid ""
"*preferencelist* must be a sequence of strings from the set ``related``, "
"``html``, and ``plain``, and indicates the order of preference for the "
"content type of the part returned."
msgstr ""
"*preferencelist* має бути послідовністю рядків із набору ``related``, "
"``html`` і ``plain`` і вказує на порядок пріоритету для типу вмісту "
"повернутої частини."

#: ../../library/email.message.rst:545
msgid ""
"Start looking for candidate matches with the object on which the "
"``get_body`` method is called."
msgstr ""
"Почніть шукати збіги кандидатів з об’єктом, для якого викликається метод "
"get_body."

#: ../../library/email.message.rst:548
msgid ""
"If ``related`` is not included in *preferencelist*, consider the root part "
"(or subpart of the root part) of any related encountered as a candidate if "
"the (sub-)part matches a preference."
msgstr ""
"Якщо ``related`` не включено до *preferencelist*, розгляньте кореневу "
"частину (або підчастину кореневої частини) будь-якої пов’язаної частини як "
"кандидата, якщо (під)частина відповідає налаштуванню."

#: ../../library/email.message.rst:552
msgid ""
"When encountering a ``multipart/related``, check the ``start`` parameter and "
"if a part with a matching :mailheader:`Content-ID` is found, consider only "
"it when looking for candidate matches.  Otherwise consider only the first "
"(default root) part of the ``multipart/related``."
msgstr ""
"Коли ви зустрічаєте ``multipart/related``, перевірте параметр ``start``, і "
"якщо знайдено частину з відповідним :mailheader:`Content-ID`, враховуйте "
"лише його під час пошуку збігів кандидатів. В іншому випадку враховуйте лише "
"першу (за замовчуванням кореневу) частину ``multipart/related``."

#: ../../library/email.message.rst:557
msgid ""
"If a part has a :mailheader:`Content-Disposition` header, only consider the "
"part a candidate match if the value of the header is ``inline``."
msgstr ""
"Якщо частина має заголовок :mailheader:`Content-Disposition`, розглядайте цю "
"частину як кандидат-збіг, лише якщо значення заголовка є ``inline``."

#: ../../library/email.message.rst:560
msgid ""
"If none of the candidates matches any of the preferences in "
"*preferencelist*, return ``None``."
msgstr ""
"Якщо жоден із кандидатів не відповідає жодному з параметрів у "
"*preferencelist*, поверніть ``None``."

#: ../../library/email.message.rst:563
msgid ""
"Notes: (1) For most applications the only *preferencelist* combinations that "
"really make sense are ``('plain',)``, ``('html', 'plain')``, and the default "
"``('related', 'html', 'plain')``.  (2) Because matching starts with the "
"object on which ``get_body`` is called, calling ``get_body`` on a "
"``multipart/related`` will return the object itself unless *preferencelist* "
"has a non-default value. (3) Messages (or message parts) that do not specify "
"a :mailheader:`Content-Type` or whose :mailheader:`Content-Type` header is "
"invalid will be treated as if they are of type ``text/plain``, which may "
"occasionally cause ``get_body`` to return unexpected results."
msgstr ""
"Примітки: (1) Для більшості програм єдиними комбінаціями *preferencelist*, "
"які справді мають сенс, є ``('plain',)``, ``('html', 'plain')`` і типове "
"``( 'related', 'html', 'plain')``. (2) Оскільки зіставлення починається з "
"об’єкта, для якого викликається ``get_body``, виклик ``get_body`` для "
"``multipart/related`` поверне сам об’єкт, якщо *preferencelist* не має "
"значення за замовчуванням. (3) Повідомлення (або частини повідомлення), у "
"яких не вказано :mailheader:`Content-Type` або чий :mailheader:`Content-"
"Type` заголовок недійсний, розглядатимуться так, ніби вони мають тип ``text/"
"plain``, через що іноді get_body може повертати несподівані результати."

#: ../../library/email.message.rst:577
msgid ""
"Return an iterator over all of the immediate sub-parts of the message that "
"are not candidate \"body\" parts.  That is, skip the first occurrence of "
"each of ``text/plain``, ``text/html``, ``multipart/related``, or ``multipart/"
"alternative`` (unless they are explicitly marked as attachments via :"
"mailheader:`Content-Disposition: attachment`), and return all remaining "
"parts.  When applied directly to a ``multipart/related``, return an iterator "
"over the all the related parts except the root part (ie: the part pointed to "
"by the ``start`` parameter, or the first part if there is no ``start`` "
"parameter or the ``start`` parameter doesn't match the :mailheader:`Content-"
"ID` of any of the parts).  When applied directly to a ``multipart/"
"alternative`` or a non-``multipart``, return an empty iterator."
msgstr ""
"Повертає ітератор над усіма безпосередніми підчастинами повідомлення, які не "
"є кандидатами на \"тіло\". Тобто пропустіть перше входження кожного з ``text/"
"plain``, ``text/html``, ``multipart/related`` або ``multipart/alternative`` "
"(якщо вони явно не позначені як вкладення через :mailheader:`Content-"
"Disposition: attachment`), і повернути всі інші частини. При безпосередньому "
"застосуванні до ``multipart/related`` повертає ітератор для всіх пов’язаних "
"частин, крім кореневої частини (тобто: частини, на яку вказує параметр "
"``start``, або першої частини, якщо її немає Параметр ``start`` або параметр "
"``start`` не відповідає :mailheader:`Content-ID` жодної з частин). При "
"застосуванні безпосередньо до ``multipart/alternative`` або не-``multipart`` "
"повертає порожній ітератор."

#: ../../library/email.message.rst:593
msgid ""
"Return an iterator over all of the immediate sub-parts of the message, which "
"will be empty for a non-``multipart``.  (See also :meth:`~email.message."
"EmailMessage.walk`.)"
msgstr ""
"Повертає ітератор для всіх безпосередніх підчастин повідомлення, який буде "
"порожнім для не-``multipart``. (Див. також :meth:`~email.message."
"EmailMessage.walk`.)"

#: ../../library/email.message.rst:600
msgid ""
"Call the :meth:`~email.contentmanager.ContentManager.get_content` method of "
"the *content_manager*, passing self as the message object, and passing along "
"any other arguments or keywords as additional arguments.  If "
"*content_manager* is not specified, use the ``content_manager`` specified by "
"the current :mod:`~email.policy`."
msgstr ""
"Викличте метод :meth:`~email.contentmanager.ContentManager.get_content` "
"*content_manager*, передаючи self як об’єкт повідомлення та передаючи будь-"
"які інші аргументи чи ключові слова як додаткові аргументи. Якщо "
"*content_manager* не вказано, використовуйте ``content_manager``, визначений "
"поточною :mod:`~email.policy`."

#: ../../library/email.message.rst:609
msgid ""
"Call the :meth:`~email.contentmanager.ContentManager.set_content` method of "
"the *content_manager*, passing self as the message object, and passing along "
"any other arguments or keywords as additional arguments.  If "
"*content_manager* is not specified, use the ``content_manager`` specified by "
"the current :mod:`~email.policy`."
msgstr ""
"Викличте метод :meth:`~email.contentmanager.ContentManager.set_content` "
"*content_manager*, передаючи self як об’єкт повідомлення та передаючи будь-"
"які інші аргументи чи ключові слова як додаткові аргументи. Якщо "
"*content_manager* не вказано, використовуйте ``content_manager``, визначений "
"поточною :mod:`~email.policy`."

#: ../../library/email.message.rst:618
msgid ""
"Convert a non-``multipart`` message into a ``multipart/related`` message, "
"moving any existing :mailheader:`Content-` headers and payload into a (new) "
"first part of the ``multipart``.  If *boundary* is specified, use it as the "
"boundary string in the multipart, otherwise leave the boundary to be "
"automatically created when it is needed (for example, when the message is "
"serialized)."
msgstr ""
"Перетворіть повідомлення, яке не є ``складним``, на ``багаточастинне/"
"пов’язане`` повідомлення, перемістивши будь-які існуючі заголовки :"
"mailheader:`Content-` і корисне навантаження в (нову) першу частину "
"``багаточастинного``. Якщо вказано *межу*, використовуйте її як "
"обмежувальний рядок у складеній частині, інакше залиште межу автоматично "
"створеною, коли це необхідно (наприклад, коли повідомлення серіалізовано)."

#: ../../library/email.message.rst:628
msgid ""
"Convert a non-``multipart`` or a ``multipart/related`` into a ``multipart/"
"alternative``, moving any existing :mailheader:`Content-` headers and "
"payload into a (new) first part of the ``multipart``.  If *boundary* is "
"specified, use it as the boundary string in the multipart, otherwise leave "
"the boundary to be automatically created when it is needed (for example, "
"when the message is serialized)."
msgstr ""
"Перетворіть не ``multipart`` або ``multipart/related`` на ``multipart/"
"alternative``, перемістивши всі наявні заголовки :mailheader:`Content-` і "
"корисне навантаження в (нову) першу частину ``багаточастинний``. Якщо "
"вказано *межу*, використовуйте її як обмежувальний рядок у складеній "
"частині, інакше залиште межу автоматично створеною, коли це необхідно "
"(наприклад, коли повідомлення серіалізовано)."

#: ../../library/email.message.rst:638
msgid ""
"Convert a non-``multipart``, a ``multipart/related``, or a ``multipart-"
"alternative`` into a ``multipart/mixed``, moving any existing :mailheader:"
"`Content-` headers and payload into a (new) first part of the "
"``multipart``.  If *boundary* is specified, use it as the boundary string in "
"the multipart, otherwise leave the boundary to be automatically created when "
"it is needed (for example, when the message is serialized)."
msgstr ""
"Перетворіть не ``multipart``, ``multipart/related`` або ``multipart-"
"alternative`` на ``multipart/mixed``, перемістивши будь-які існуючі "
"заголовки :mailheader:`Content-` та корисне навантаження в (нову) першу "
"частину ``multipart``. Якщо вказано *межу*, використовуйте її як "
"обмежувальний рядок у складеній частині, інакше залиште межу автоматично "
"створеною, коли це необхідно (наприклад, коли повідомлення серіалізовано)."

#: ../../library/email.message.rst:648
msgid ""
"If the message is a ``multipart/related``, create a new message object, pass "
"all of the arguments to its :meth:`set_content` method, and :meth:`~email."
"message.Message.attach` it to the ``multipart``.  If the message is a non-"
"``multipart``, call :meth:`make_related` and then proceed as above.  If the "
"message is any other type of ``multipart``, raise a :exc:`TypeError`. If "
"*content_manager* is not specified, use the ``content_manager`` specified by "
"the current :mod:`~email.policy`. If the added part has no :mailheader:"
"`Content-Disposition` header, add one with the value ``inline``."
msgstr ""
"Якщо повідомлення є ``multipart/related``, створіть новий об’єкт "
"повідомлення, передайте всі аргументи його методу :meth:`set_content` і :"
"meth:`~email.message.Message.attach` його до ``багаточастинний``. Якщо "
"повідомлення не є ``складним``, викличте :meth:`make_related`, а потім "
"виконайте описані вище дії. Якщо повідомлення має будь-який інший тип "
"``multipart``, викликайте :exc:`TypeError`. Якщо *content_manager* не "
"вказано, використовуйте ``content_manager``, визначений поточною :mod:"
"`~email.policy`. Якщо додана частина не має заголовка :mailheader:`Content-"
"Disposition`, додайте його зі значенням ``inline``."

#: ../../library/email.message.rst:661
msgid ""
"If the message is a ``multipart/alternative``, create a new message object, "
"pass all of the arguments to its :meth:`set_content` method, and :meth:"
"`~email.message.Message.attach` it to the ``multipart``.  If the message is "
"a non-``multipart`` or ``multipart/related``, call :meth:`make_alternative` "
"and then proceed as above.  If the message is any other type of "
"``multipart``, raise a :exc:`TypeError`. If *content_manager* is not "
"specified, use the ``content_manager`` specified by the current :mod:`~email."
"policy`."
msgstr ""
"Якщо повідомлення є ``multipart/alternative``, створіть новий об’єкт "
"повідомлення, передайте всі аргументи його методу :meth:`set_content` і :"
"meth:`~email.message.Message.attach` його до ``багаточастинний``. Якщо "
"повідомлення не є ``multipart`` або ``multipart/related``, викличте :meth:"
"`make_alternative`, а потім виконайте описані вище дії. Якщо повідомлення "
"має будь-який інший тип ``multipart``, викликайте :exc:`TypeError`. Якщо "
"*content_manager* не вказано, використовуйте ``content_manager``, визначений "
"поточною :mod:`~email.policy`."

#: ../../library/email.message.rst:673
msgid ""
"If the message is a ``multipart/mixed``, create a new message object, pass "
"all of the arguments to its :meth:`set_content` method, and :meth:`~email."
"message.Message.attach` it to the ``multipart``.  If the message is a non-"
"``multipart``, ``multipart/related``, or ``multipart/alternative``, call :"
"meth:`make_mixed` and then proceed as above. If *content_manager* is not "
"specified, use the ``content_manager`` specified by the current :mod:`~email."
"policy`.  If the added part has no :mailheader:`Content-Disposition` header, "
"add one with the value ``attachment``.  This method can be used both for "
"explicit attachments (:mailheader:`Content-Disposition: attachment`) and "
"``inline`` attachments (:mailheader:`Content-Disposition: inline`), by "
"passing appropriate options to the ``content_manager``."
msgstr ""
"Якщо повідомлення є ``multipart/mixed``, створіть новий об’єкт повідомлення, "
"передайте всі аргументи його методу :meth:`set_content` і :meth:`~email."
"message.Message.attach` його до ``багаточастинний``. Якщо повідомлення не є "
"``multipart``, ``multipart/related`` або ``multipart/alternative``, "
"викличте :meth:`make_mixed`, а потім виконайте описані вище дії. Якщо "
"*content_manager* не вказано, використовуйте ``content_manager``, визначений "
"поточною :mod:`~email.policy`. Якщо додана частина не має заголовка :"
"mailheader:`Content-Disposition`, додайте його зі значенням ``attachment``. "
"Цей метод можна використовувати як для явних вкладень (:mailheader:`Content-"
"Disposition: attachment`), так і для вкладень ``inline`` (:mailheader:"
"`Content-Disposition: inline`), передавши відповідні параметри "
"``content_manager``."

#: ../../library/email.message.rst:689
msgid "Remove the payload and all of the headers."
msgstr "Видаліть корисне навантаження та всі заголовки."

#: ../../library/email.message.rst:694
msgid ""
"Remove the payload and all of the :exc:`Content-` headers, leaving all other "
"headers intact and in their original order."
msgstr ""
"Видаліть корисне навантаження та всі заголовки :exc:`Content-`, залишивши "
"всі інші заголовки недоторканими та в їх початковому порядку."

#: ../../library/email.message.rst:698
msgid ":class:`EmailMessage` objects have the following instance attributes:"
msgstr "Об’єкти :class:`EmailMessage` мають такі атрибути екземпляра:"

#: ../../library/email.message.rst:703
msgid ""
"The format of a MIME document allows for some text between the blank line "
"following the headers, and the first multipart boundary string. Normally, "
"this text is never visible in a MIME-aware mail reader because it falls "
"outside the standard MIME armor.  However, when viewing the raw text of the "
"message, or when viewing the message in a non-MIME aware reader, this text "
"can become visible."
msgstr ""
"Формат документа MIME допускає деякий текст між порожнім рядком після "
"заголовків і першим обмежувальним рядком із складених частин. Зазвичай цей "
"текст ніколи не відображається в програмі читання пошти з підтримкою MIME, "
"оскільки він виходить за межі стандартної броні MIME. Однак під час "
"перегляду необробленого тексту повідомлення або під час перегляду "
"повідомлення в програмі читання, яка не підтримує MIME, цей текст може стати "
"видимим."

#: ../../library/email.message.rst:710
msgid ""
"The *preamble* attribute contains this leading extra-armor text for MIME "
"documents.  When the :class:`~email.parser.Parser` discovers some text after "
"the headers but before the first boundary string, it assigns this text to "
"the message's *preamble* attribute.  When the :class:`~email.generator."
"Generator` is writing out the plain text representation of a MIME message, "
"and it finds the message has a *preamble* attribute, it will write this text "
"in the area between the headers and the first boundary.  See :mod:`email."
"parser` and :mod:`email.generator` for details."
msgstr ""
"Атрибут *преамбула* містить цей провідний додатковий текст для документів "
"MIME. Коли :class:`~email.parser.Parser` виявляє текст після заголовків, але "
"перед першим обмежувальним рядком, він призначає цей текст атрибуту "
"*преамбула* повідомлення. Коли :class:`~email.generator.Generator` записує "
"звичайне текстове представлення повідомлення MIME і виявляє, що повідомлення "
"має атрибут *преамбула*, він записує цей текст у область між заголовками та "
"перша межа. Перегляньте :mod:`email.parser` і :mod:`email.generator` для "
"деталей."

#: ../../library/email.message.rst:720
msgid ""
"Note that if the message object has no preamble, the *preamble* attribute "
"will be ``None``."
msgstr ""
"Зауважте, що якщо об’єкт повідомлення не має преамбули, атрибут *preamble* "
"матиме значення ``None``."

#: ../../library/email.message.rst:726
msgid ""
"The *epilogue* attribute acts the same way as the *preamble* attribute, "
"except that it contains text that appears between the last boundary and the "
"end of the message.  As with the :attr:`~EmailMessage.preamble`, if there is "
"no epilog text this attribute will be ``None``."
msgstr ""
"Атрибут *epilogue* діє так само, як і атрибут *preamble*, за винятком того, "
"що він містить текст, який з’являється між останньою межею та кінцем "
"повідомлення. Як і у випадку з :attr:`~EmailMessage.preamble`, якщо немає "
"тексту епілога, цей атрибут буде ``None``."

#: ../../library/email.message.rst:734
msgid ""
"The *defects* attribute contains a list of all the problems found when "
"parsing this message.  See :mod:`email.errors` for a detailed description of "
"the possible parsing defects."
msgstr ""
"Атрибут *defects* містить список усіх проблем, виявлених під час аналізу "
"цього повідомлення. Перегляньте :mod:`email.errors` для детального опису "
"можливих дефектів аналізу."

#: ../../library/email.message.rst:741
msgid ""
"This class represents a subpart of a MIME message.  It is identical to :"
"class:`EmailMessage`, except that no :mailheader:`MIME-Version` headers are "
"added when :meth:`~EmailMessage.set_content` is called, since sub-parts do "
"not need their own :mailheader:`MIME-Version` headers."
msgstr ""
"Цей клас представляє підчастину повідомлення MIME. Він ідентичний :class:"
"`EmailMessage`, за винятком того, що під час виклику :meth:`~EmailMessage."
"set_content` не додаються заголовки :mailheader:`MIME-Version`, оскільки "
"підчастини не потребують власного Заголовки :mailheader:`MIME-Version`."

#: ../../library/email.message.rst:748
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../library/email.message.rst:749
msgid ""
"Originally added in 3.4 as a :term:`provisional module <provisional "
"package>`.  Docs for legacy message class moved to :ref:`compat32_message`."
msgstr ""
"Спочатку додано в 3.4 як :term:`проміжний модуль <provisional package>`. "
"Документи для застарілого класу повідомлень переміщено до :ref:"
"`compat32_message`."

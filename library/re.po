# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Raphael Mendonça, 2018
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2019
# Cauê Baasch de Souza <cauebaasch@gmail.com>, 2019
# Risaffi <erikrisaffi@gmail.com>, 2019
# Marco Rougeth <marco@rougeth.com>, 2020
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-09 18:48+0900\n"
"PO-Revision-Date: 2018-06-29 17:36+0000\n"
"Last-Translator: Marco Rougeth <marco@rougeth.com>, 2020\n"
"Language-Team: Portuguese (Brazil) (https://www.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../library/re.rst:2
msgid ":mod:`re` --- Regular expression operations"
msgstr ":mod:`re` --- Operações com expressões regulares"

#: ../../library/re.rst:10
msgid "**Source code:** :source:`Lib/re.py`"
msgstr "**Código Fonte:** :source:`Lib/re.py`"

#: ../../library/re.rst:14
msgid ""
"This module provides regular expression matching operations similar to those "
"found in Perl."
msgstr ""
"Este módulo fornece operações de correspondência de expressões regulares "
"semelhantes às encontradas em Perl. O nome do módulo vem da abreviação do "
"termo em inglês *regular expressions*, RE."

#: ../../library/re.rst:17
msgid ""
"Both patterns and strings to be searched can be Unicode strings (:class:"
"`str`) as well as 8-bit strings (:class:`bytes`). However, Unicode strings "
"and 8-bit strings cannot be mixed: that is, you cannot match a Unicode "
"string with a byte pattern or vice-versa; similarly, when asking for a "
"substitution, the replacement string must be of the same type as both the "
"pattern and the search string."
msgstr ""
"Ambos os padrões e strings a serem pesquisados podem ser strings Unicode (:"
"class:`str`) assim como strings de 8 bits (:class:`bytes`). No entanto, "
"strings Unicode e strings de 8 bits não podem ser misturadas: ou seja, você "
"não pode combinar uma string Unicode com um padrão de bytes ou vice-versa; "
"da mesma forma, ao solicitar uma substituição, a string de substituição deve "
"ser do mesmo tipo que o padrão e a string de pesquisa."

#: ../../library/re.rst:24
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal."
msgstr ""

#: ../../library/re.rst:33
msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal "
"prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string containing "
"``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string containing "
"a newline.  Usually patterns will be expressed in Python code using this raw "
"string notation."
msgstr ""
"A solução é usar a notação de string bruta do Python para padrões de "
"expressão regular; as contrabarras não são tratadas de nenhuma maneira "
"especial em uma string literal com o prefixo ``'r'``. Portanto, ``r\"\\n\"`` "
"é uma string de dois caracteres contendo ``'\\'`` e ``'n'``, enquanto ``\"\\n"
"\"`` é uma string de um caractere contendo um nova linha. Normalmente, os "
"padrões serão expressos em código Python usando esta notação de string bruta."

#: ../../library/re.rst:40
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular "
"expressions <re-objects>`.  The functions are shortcuts that don't require "
"you to compile a regex object first, but miss some fine-tuning parameters."
msgstr ""
"É importante notar que a maioria das operações de expressão regular estão "
"disponíveis como funções e métodos de nível de módulo em :ref:`expressões "
"regulares compiladas <re-objects>`. As funções são atalhos que não exigem "
"que você compile um objeto regex primeiro, mas perdem alguns parâmetros de "
"ajuste fino."

#: ../../library/re.rst:48
msgid ""
"The third-party `regex <https://pypi.org/project/regex/>`_ module, which has "
"an API compatible with the standard library :mod:`re` module, but offers "
"additional functionality and a more thorough Unicode support."
msgstr ""
"O módulo `regex <https://pypi.org/project/regex/>`_ de terceiros, que possui "
"uma API compatível com o módulo da biblioteca padrão :mod:`re`, mas oferece "
"funcionalidades adicionais e um suporte mais completo a Unicode."

#: ../../library/re.rst:56
msgid "Regular Expression Syntax"
msgstr "Sintaxe de expressão regular"

#: ../../library/re.rst:58
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the "
"functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""
"Uma expressão regular (ou ER) especifica um conjunto de strings que "
"corresponde a ela; as funções neste módulo permitem que você verifique se "
"uma determinada string corresponde a uma determinada expressão regular (ou "
"se uma determinada expressão regular corresponde a uma determinada string, o "
"que resulta na mesma coisa)."

#: ../../library/re.rst:63
msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described "
"here.  For details of the theory and implementation of regular expressions, "
"consult the Friedl book [Frie09]_, or almost any textbook about compiler "
"construction."
msgstr ""
"As expressões regulares podem ser concatenadas para formar novas expressões "
"regulares; se *A* e *B* forem expressões regulares, então *AB* também será "
"uma expressão regular. Em geral, se uma string *p* corresponder a *A* e "
"outra string *q* corresponder a *B*, a string *pq* corresponderá a AB. Isso "
"é válido, a menos que *A* ou *B* contenham operações de baixa precedência; "
"condições de contorno entre *A* e *B*; ou ter referências de grupo "
"numeradas. Assim, expressões complexas podem ser facilmente construídas a "
"partir de expressões primitivas mais simples, como as descritas aqui. Para "
"obter detalhes sobre a teoria e implementação de expressões regulares, "
"consulte o livro de Friedl [Frie09]_, ou quase qualquer livro sobre "
"construção de compiladores."

#: ../../library/re.rst:73
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr ""
"Segue uma breve explicação do formato das expressões regulares. Para mais "
"informações e uma apresentação mais suave, consulte o :ref:`regex-howto`."

#: ../../library/re.rst:76
msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""
"As expressões regulares podem conter caracteres especiais e comuns. A "
"maioria dos caracteres comuns, como ``'A'``, ``'a'`` ou ``'0'``, são as "
"expressões regulares mais simples; eles simplesmente se combinam. Você pode "
"concatenar caracteres comuns, de forma que ``último`` corresponda à string "
"``'último'``. (No restante desta seção, escreveremos ERs ``neste estilo "
"especial``, geralmente sem aspas, e strings para serem correspondidas "
"``'entre aspas simples'``.)"

#: ../../library/re.rst:83
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted."
msgstr ""
"Alguns caracteres, como ``'|'`` ou ``'('``, são especiais. Os caracteres "
"especiais representam classes de caracteres comuns ou afetam como as "
"expressões regulares em torno deles são interpretadas."

#: ../../library/re.rst:87
msgid ""
"Repetition qualifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) cannot be "
"directly nested. This avoids ambiguity with the non-greedy modifier suffix "
"``?``, and with other modifiers in other implementations. To apply a second "
"repetition to an inner repetition, parentheses may be used. For example, the "
"expression ``(?:a{6})*`` matches any multiple of six ``'a'`` characters."
msgstr ""
"Qualificadores de repetição (``*``, ``+``, ``?``, ``{m,n}`` etc) não podem "
"ser aninhados diretamente. Isso evita ambiguidade com o sufixo modificador "
"não guloso ``?``, E com outros modificadores em outras implementações. Para "
"aplicar uma segunda repetição a uma repetição interna, podem ser usados "
"parênteses. Por exemplo, a expressão ``(?:a{6})*`` corresponde a qualquer "
"múltiplo de seis caracteres ``'a'``."

#: ../../library/re.rst:94
msgid "The special characters are:"
msgstr "Os caracteres especiais são:"

#: ../../library/re.rst:101 ../../library/re.rst:1372
msgid "``.``"
msgstr "``.``"

#: ../../library/re.rst:99
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline."
msgstr ""
"(Ponto.) No modo padrão, corresponde a qualquer caractere, exceto uma nova "
"linha. Se o sinalizador :const:`DOTALL` foi especificado, ele corresponde a "
"qualquer caractere, incluindo uma nova linha."

#: ../../library/re.rst:107
msgid "``^``"
msgstr "``^``"

#: ../../library/re.rst:106
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr ""
"(Sinal de circunflexo.) Corresponde ao início da string, e no modo :const:"
"`MULTILINE` também corresponde imediatamente após cada nova linha."

#: ../../library/re.rst:118
msgid "``$``"
msgstr "``$``"

#: ../../library/re.rst:112
msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression ``foo"
"$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in "
"``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in :const:"
"`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will find two "
"(empty) matches: one just before the newline, and one at the end of the "
"string."
msgstr ""
"Corresponde ao final da string ou logo antes da nova linha no final da "
"string, e no modo :const:`MULTILINE` também corresponde antes de uma nova "
"linha. ``foo`` corresponde a 'foo' e 'foobar', enquanto a expressão regular "
"``foo$`` corresponde apenas a 'foo'. Mais interessante, pesquisar por ``foo."
"$`` em ``'foo1\\nfoo2\\n'`` corresponde a 'foo2' normalmente, mas 'foo1' no "
"modo :const:`MULTILINE`; procurando por um único ``$`` em ``'foo\\n'`` "
"encontrará duas correspondências (vazias): uma logo antes da nova linha e "
"uma no final da string."

#: ../../library/re.rst:125
msgid "``*``"
msgstr "``*``"

#: ../../library/re.rst:123
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""
"Faz com que a ER resultante corresponda a 0 ou mais repetições da ER "
"anterior, tantas repetições quantas forem possíveis. ``ab*`` corresponderá a "
"'a', 'ab' ou 'a' seguido por qualquer número de 'b's."

#: ../../library/re.rst:132
msgid "``+``"
msgstr "``+``"

#: ../../library/re.rst:130
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr ""
"Faz com que a ER resultante corresponda a 1 ou mais repetições da ER "
"anterior. ``ab+`` irá corresponder a 'a' seguido por qualquer número "
"diferente de zero de 'b's; não corresponderá apenas a 'a'."

#: ../../library/re.rst:138
msgid "``?``"
msgstr "``?``"

#: ../../library/re.rst:137
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr ""
"Faz com que a ER resultante corresponda a 0 ou 1 repetição da ER anterior. "
"``ab?`` irá corresponder a 'a' ou 'ab'."

#: ../../library/re.rst:152
msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

#: ../../library/re.rst:146
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` qualifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``'<a> b <c>'``, it will match the entire "
"string, and not just ``'<a>'``.  Adding ``?`` after the qualifier makes it "
"perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``'<a>'``."
msgstr ""
"Os qualificadores ``'*'``, ``'+'`` e ``'?'`` são todos :dfn:`gananciosos`; "
"eles correspondem ao máximo de texto possível. Às vezes, esse comportamento "
"não é desejado; se a ER ``<.*>`` for correspondida com ``'<a> b <c>'``, ele "
"irá corresponder a toda a string, e não apenas ``'<a>'``. Adicionar ``?`` "
"após o qualificador faz com que ele execute a correspondência da maneira :"
"dfn:`não gananciosa` ou :dfn:`minimalista`; tão *poucos* caracteres quanto "
"possível serão correspondidos. Usando a ``<.*?>`` irá corresponder apenas "
"``'<a>'``."

#: ../../library/re.rst:160
msgid "``{m}``"
msgstr "``{m}``"

#: ../../library/re.rst:158
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""
"Especifica que exatamente *m* cópias da ER anterior devem ser "
"correspondidas; menos correspondências fazem com que toda a ER não seja "
"correspondida. Por exemplo, ``a{6}`` irá corresponder exatamente a seis "
"caracteres ``'a'``, mas não a cinco."

#: ../../library/re.rst:169
msgid "``{m,n}``"
msgstr "``{m,n}``"

#: ../../library/re.rst:163
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m* "
"specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``'aaaab'`` or a thousand "
"``'a'`` characters followed by a ``'b'``, but not ``'aaab'``. The comma may "
"not be omitted or the modifier would be confused with the previously "
"described form."
msgstr ""
"Faz com que a ER resultante corresponda de *m* a *n* repetições da ER "
"precedente, tentando corresponder ao máximo de repetições possível. Por "
"exemplo, ``a{3,5}`` irá corresponder de 3 a 5 caracteres ``'a'``. A omissão "
"de *m* especifica um limite inferior de zero e a omissão de *n* especifica "
"um limite superior infinito. Como exemplo, ``a{4,}b`` irá corresponder a "
"``'aaaab'`` ou mil caracteres ``'a'`` seguidos por um ``'b'``, mas não "
"``'aaab'``. A vírgula não pode ser omitida ou o modificador será confundido "
"com a forma descrita anteriormente."

#: ../../library/re.rst:176
msgid "``{m,n}?``"
msgstr "``{m,n}?``"

#: ../../library/re.rst:172
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is "
"the non-greedy version of the previous qualifier.  For example, on the 6-"
"character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters, "
"while ``a{3,5}?`` will only match 3 characters."
msgstr ""
"Faz com que a ER resultante corresponda de *m* a *n* repetições da ER "
"precedente, tentando corresponder o mínimo de *poucas* repetições possível. "
"Esta é a versão não gananciosa do qualificador anterior. Por exemplo, na "
"string de 6 caracteres ``'aaaaaa'``, ``a{3,5}`` irá corresponder a 5 "
"caracteres ``'a'``, enquanto ``a{3,5}?`` corresponderá apenas a 3 caracteres."

#: ../../library/re.rst:191
msgid "``\\``"
msgstr "``\\``"

#: ../../library/re.rst:181
msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr ""
"Ou escapa caracteres especiais (permitindo que você corresponde a caracteres "
"como ``'*'``, ``'?'`` e assim por diante), ou sinaliza uma sequência "
"especial; sequências especiais são discutidas abaixo."

#: ../../library/re.rst:185
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""
"Se você não estiver usando uma string raw para expressar o padrão, lembre-se "
"de que o Python também usa a contrabarra como uma sequência de escape em "
"literais de string; se a sequência de escape não for reconhecida pelo "
"analisador sintático do Python, a contrabarra e o caractere subsequente "
"serão incluídos na string resultante. No entanto, se o Python reconhecer a "
"sequência resultante, a contrabarra deve ser repetida duas vezes. Isso é "
"complicado e difícil de entender, portanto, é altamente recomendável que "
"você use strings raw para todas as expressões, exceto as mais simples."

#: ../../library/re.rst:232
msgid "``[]``"
msgstr "``[]``"

#: ../../library/re.rst:197
msgid "Used to indicate a set of characters.  In a set:"
msgstr "Usado para indicar um conjunto de caracteres. Em um conjunto:"

#: ../../library/re.rst:199
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr ""
"Caracteres podem ser listados individualmente, por exemplo, ``[amk]`` vai "
"corresponder a ``'a'``, ``'m'`` ou ``'k'``."

#: ../../library/re.rst:204
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase "
"ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[-a]`` or ``[a-]``), it will match a literal ``'-'``."
msgstr ""
"Intervalos de caracteres podem ser indicados fornecendo dois caracteres e "
"separando-os por ``'-'``, por exemplo ``[a-z]`` irá corresponder a qualquer "
"letra ASCII minúscula, ``[0-5][0-9]`` irá corresponder a todos os números de "
"dois dígitos de ``00`` a ``59``, e ``[0-9A-Fa-f]`` irá corresponder a "
"qualquer dígito hexadecimal. Se ``-`` for escapado (por exemplo, ``[a\\-"
"z]``) ou se for colocado como o primeiro ou último caractere (por exemplo, "
"``[-a]`` ou ``[a-]``), ele corresponderá a um literal ``'-'``."

#: ../../library/re.rst:211
msgid ""
"Special characters lose their special meaning inside sets.  For example, "
"``[(+*)]`` will match any of the literal characters ``'('``, ``'+'``, "
"``'*'``, or ``')'``."
msgstr ""
"Os caracteres especiais perdem seu significado especial dentro dos "
"conjuntos. Por exemplo, ``[(+*)]`` corresponderá a qualquer um dos "
"caracteres literais ``'('``, ``'+'``, ``'*'`` ou ``')'``."

#: ../../library/re.rst:217
msgid ""
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"accepted inside a set, although the characters they match depends on "
"whether :const:`ASCII` or :const:`LOCALE` mode is in force."
msgstr ""
"Classes de caracteres como ``\\w`` ou ``\\S`` (definidas abaixo) também são "
"aceitas dentro de um conjunto, embora os caracteres que correspondem "
"dependam do modo :const:`ASCII` ou :const:`LOCALE` está em vigor."

#: ../../library/re.rst:223
msgid ""
"Characters that are not within a range can be matched by :dfn:"
"`complementing` the set.  If the first character of the set is ``'^'``, all "
"the characters that are *not* in the set will be matched.  For example, "
"``[^5]`` will match any character except ``'5'``, and ``[^^]`` will match "
"any character except ``'^'``.  ``^`` has no special meaning if it's not the "
"first character in the set."
msgstr ""
"Os caracteres que não estão dentro de um intervalo podem ser correspondidos :"
"dfn:`complementando` o conjunto. Se o primeiro caractere do conjunto for "
"``'^'``, todos os caracteres que *não* estiverem no conjunto serão "
"correspondidos. Por exemplo, ``[^5]`` irá corresponder a qualquer caractere "
"exceto ``'5'``, e ``[^^]`` irá corresponder a qualquer caractere exceto "
"``'^'``. ``^`` não tem nenhum significado especial se não for o primeiro "
"caractere do conjunto."

#: ../../library/re.rst:230
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will both match a parenthesis."
msgstr ""
"Para corresponder a um ``']'`` literal dentro de um conjunto, preceda-o com "
"uma contrabarra ou coloque-o no início do conjunto. Por exemplo, ``[()[\\]"
"{}]`` e ``[]()[{}]`` ambos corresponderão a um parêntese."

#: ../../library/re.rst:245
msgid "``|``"
msgstr "``|``"

#: ../../library/re.rst:237
msgid ""
"``A|B``, where *A* and *B* can be arbitrary REs, creates a regular "
"expression that will match either *A* or *B*.  An arbitrary number of REs "
"can be separated by the ``'|'`` in this way.  This can be used inside groups "
"(see below) as well.  As the target string is scanned, REs separated by "
"``'|'`` are tried from left to right. When one pattern completely matches, "
"that branch is accepted. This means that once *A* matches, *B* will not be "
"tested further, even if it would produce a longer overall match.  In other "
"words, the ``'|'`` operator is never greedy.  To match a literal ``'|'``, "
"use ``\\|``, or enclose it inside a character class, as in ``[|]``."
msgstr ""
"``A|B``, onde *A* e *B* podem ser ERs arbitrários, cria uma expressão "
"regular que corresponderá a *A* ou *B*. Um número arbitrário de ERs pode ser "
"separado por ``'|'`` desta forma. Isso também pode ser usado dentro de "
"grupos (veja abaixo). Conforme a string alvo é escaneada, ERs separados por "
"``'|'`` são tentados da esquerda para a direita. Quando um padrão "
"corresponde completamente, essa ramificação é aceita. Isso significa que, "
"assim que *A* corresponder, *B* não será testado posteriormente, mesmo que "
"produza uma correspondência geral mais longa. Em outras palavras, o operador "
"``'|'`` nunca é ganancioso. Para corresponder a um ``'|'`` literal, use ``\\|"
"``, ou coloque-o dentro de uma classe de caractere, como em ``[|]``."

#: ../../library/re.rst:255
msgid "``(...)``"
msgstr "``(...)``"

#: ../../library/re.rst:251
msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates "
"the start and end of a group; the contents of a group can be retrieved after "
"a match has been performed, and can be matched later in the string with the "
"``\\number`` special sequence, described below.  To match the literals "
"``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside a "
"character class: ``[(]``, ``[)]``."
msgstr ""
"Corresponde a qualquer expressão regular que esteja entre parênteses e "
"indica o início e o fim de um grupo; o conteúdo de um grupo pode ser "
"recuperado após uma correspondência ter sido realizada e pode ser "
"correspondido posteriormente na string com a sequência especial ``"
"\\number``, descrita abaixo. Para corresponder aos literais ``'('`` ou "
"``')'``, use ``\\(`` ou ``\\)``, ou coloque-os dentro de uma classe de "
"caracteres: ``[(]``, ``[)]``."

#: ../../library/re.rst:264
msgid "``(?...)``"
msgstr "``(?...)``"

#: ../../library/re.rst:260
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""
"Esta é uma notação de extensão (um ``'?'`` seguindo um ``'('`` não é "
"significativo de outra forma). O primeiro caractere após o ``'?'`` determina "
"qual o significado e sintaxe posterior do é. As extensões normalmente não "
"criam um novo grupo; ``(?P<name>...)`` é a única exceção a esta regra. A "
"seguir estão as extensões atualmente suportadas."

#: ../../library/re.rst:278
msgid "``(?aiLmsux)``"
msgstr "``(?aiLmsux)``"

#: ../../library/re.rst:267
msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.)  The group matches the empty string; the letters "
"set the corresponding flags: :const:`re.A` (ASCII-only matching), :const:`re."
"I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M` (multi-"
"line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode matching), "
"and :const:`re.X` (verbose), for the entire regular expression. (The flags "
"are described in :ref:`contents-of-module-re`.) This is useful if you wish "
"to include the flags as part of the regular expression, instead of passing a "
"*flag* argument to the :func:`re.compile` function.  Flags should be used "
"first in the expression string."
msgstr ""
"(Uma ou mais letras do conjunto ``'a'``, ``'i'``, ``'L'``, ``'m'``, ``'s'``, "
"``'u'``, ``'x'``.) O grupo corresponde à string vazia; as letras definem os "
"sinalizadores correspondentes: :const:`re.A` (correspondência somente "
"ASCII), :const:`re.I` (não diferenciar maiúsculas e minúsculas), :const:`re."
"L` (dependente do local), :const:`re.M` (multi-linha), :const:`re.S` (ponto "
"corresponde a todos), :const:`re.U` (correspondência Unicode) e :const:`re."
"X` (detalhado), para toda a expressão regular. (Os sinalizadores são "
"descritos em :ref:`contents-of-module-re`.) Isso é útil se você deseja "
"incluir os sinalizadores como parte da expressão regular, em vez de passar "
"um argumento *flag* para função :func:`re.compile`. Os sinalizadores devem "
"ser usados primeiro na string de expressão."

#: ../../library/re.rst:286
msgid "``(?:...)``"
msgstr "``(?:...)``"

#: ../../library/re.rst:283
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group "
"*cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr ""
"Uma versão sem captura de parênteses regulares. Corresponde a qualquer "
"expressão regular que esteja entre parênteses, mas a substring correspondida "
"pelo grupo *não pode* ser recuperada após realizar uma correspondência ou "
"referenciada posteriormente no padrão."

#: ../../library/re.rst:296
msgid "``(?imsx-imsx:...)``"
msgstr ""

#: ../../library/re.rst:289
msgid ""
"(Zero or more letters from the set ``'i'``, ``'m'``, ``'s'``, ``'x'``, "
"optionally followed by ``'-'`` followed by one or more letters from the same "
"set.)  The letters set or removes the corresponding flags: :const:`re.I` "
"(ignore case), :const:`re.M` (multi-line), :const:`re.S` (dot matches all), "
"and :const:`re.X` (verbose), for the part of the expression.  (The flags are "
"described in :ref:`contents-of-module-re`.)"
msgstr ""

#: ../../library/re.rst:323
msgid "``(?P<name>...)``"
msgstr "``(?P<name>...)``"

#: ../../library/re.rst:301
msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and each group name must be defined only once within a "
"regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr ""
"Semelhante aos parênteses regulares, mas a substring correspondida pelo "
"grupo é acessível por meio do nome de grupo simbólico *name*. Os nomes de "
"grupo devem ser identificadores Python válidos e cada nome de grupo deve ser "
"definido apenas uma vez em uma expressão regular. Um grupo simbólico também "
"é um grupo numerado, como se o grupo não tivesse um nome."

#: ../../library/re.rst:307
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is ``(?"
"P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either "
"single or double quotes):"
msgstr ""
"Grupos nomeados podem ser referenciados em três contextos. Se o padrão for "
"``(?P<quote>['\"]).*?(?P=quote)`` (ou seja, corresponder a uma string entre "
"aspas simples ou duplas):"

#: ../../library/re.rst:312
msgid "Context of reference to group \"quote\""
msgstr "Contexto de referência ao grupo \"quote\""

#: ../../library/re.rst:312
msgid "Ways to reference it"
msgstr "Formas de referenciá-lo"

#: ../../library/re.rst:314
msgid "in the same pattern itself"
msgstr "no mesmo padrão"

#: ../../library/re.rst:314
msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=quote)`` (como mostrado)"

#: ../../library/re.rst:315 ../../library/re.rst:322
msgid "``\\1``"
msgstr "``\\1``"

#: ../../library/re.rst:317
msgid "when processing match object *m*"
msgstr "ao processar a correspondência do objeto *m*"

#: ../../library/re.rst:317
msgid "``m.group('quote')``"
msgstr "``m.group('quote')``"

#: ../../library/re.rst:318
msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('quote')`` (etc.)"

#: ../../library/re.rst:320
msgid "in a string passed to the *repl* argument of ``re.sub()``"
msgstr "em uma string passada para o argumento *repl* de ``re.sub()``"

#: ../../library/re.rst:320
msgid "``\\g<quote>``"
msgstr "``\\g<quote>``"

#: ../../library/re.rst:321
msgid "``\\g<1>``"
msgstr "``\\g<1>``"

#: ../../library/re.rst:329
msgid "``(?P=name)``"
msgstr "``(?P=name)``"

#: ../../library/re.rst:328
msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr ""
"Uma referência anterior a um grupo nomeado; corresponde a qualquer texto que "
"corresponda ao grupo anterior denominado *name*."

#: ../../library/re.rst:334
msgid "``(?#...)``"
msgstr "``(?#...)``"

#: ../../library/re.rst:334
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "Um comentário; o conteúdo dos parênteses é simplesmente ignorado."

#: ../../library/re.rst:339
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../library/re.rst:337
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a :dfn:`lookahead assertion`.  For example, ``Isaac (?"
"=Asimov)`` will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""
"Corresponde se ``...`` corresponder a próxima, mas não consome nada da "
"string. Isso é chamado de :dfn:`asserção lookahead`. Por exemplo, ``Isaac (?"
"=Asimov)`` corresponderá a ``'Isaac '`` apenas se for seguido por "
"``'Asimov'``."

#: ../../library/re.rst:346
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../library/re.rst:344
msgid ""
"Matches if ``...`` doesn't match next.  This is a :dfn:`negative lookahead "
"assertion`. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only "
"if it's *not* followed by ``'Asimov'``."
msgstr ""
"Corresponde se ``...`` não corresponder a próxima. Isso é uma :dfn:`asserção "
"lookahead negativa`. Por exemplo, ``Isaac (?!Asimov)`` corresponderá a "
"``'Isaac '`` apenas se *não* for seguido por ``'Asimov'``."

#: ../../library/re.rst:373
msgid "``(?<=...)``"
msgstr "``(?<=...)``"

#: ../../library/re.rst:351
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``'abcdef'``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed "
"length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and ``a{3,4}"
"`` are not.  Note that patterns which start with positive lookbehind "
"assertions will not match at the beginning of the string being searched; you "
"will most likely want to use the :func:`search` function rather than the :"
"func:`match` function:"
msgstr ""
"Corresponde se a posição atual na string for precedida por uma "
"correspondência para ``...`` que termina na posição atual. Isso é chamado "
"de :dfn:`asserção retrovisora positiva`. ``(?<=abc)def`` irá encontrar uma "
"correspondência em ``'abcdef'``, uma vez que o retrovisor vai voltar 3 "
"caracteres e verificar se o padrão contido corresponde. O padrão contido "
"deve corresponder apenas a strings de algum comprimento fixo, o que "
"significa que ``abc`` ou ``a|b`` são permitidos, mas ``a*`` e ``a{3,4}`` não "
"são. Observe que os padrões que começam com asserções retrovisoras positivas "
"não corresponderão ao início da string que está sendo pesquisada; você "
"provavelmente desejará usar a função :func:`search` em vez da função :func:"
"`match`:"

#: ../../library/re.rst:366
msgid "This example looks for a word following a hyphen:"
msgstr "Este exemplo procura por uma palavra logo após um hífen:"

#: ../../library/re.rst:372
msgid "Added support for group references of fixed length."
msgstr "Adicionado suporte para referências de grupo de comprimento fixo."

#: ../../library/re.rst:382
msgid "``(?<!...)``"
msgstr "``(?<!...)``"

#: ../../library/re.rst:378
msgid ""
"Matches if the current position in the string is not preceded by a match for "
"``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar to "
"positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length.  Patterns which start with negative lookbehind "
"assertions may match at the beginning of the string being searched."
msgstr ""
"Corresponde se a posição atual na string não for precedida por uma "
"correspondência para ``...``. Isso é chamado de :dfn:`asserção retrovisora "
"negativa`. Semelhante às asserções retrovisoras positivas, o padrão contido "
"deve corresponder apenas a strings de algum comprimento fixo. Os padrões que "
"começam com asserções retroativas negativas podem corresponder ao início da "
"string que está sendo pesquisada."

#: ../../library/re.rst:391
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/name)yes-pattern|no-pattern)``"

#: ../../library/re.rst:385
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>|$)`` is a poor email matching pattern, which will match with "
"``'<user@host.com>'`` as well as ``'user@host.com'``, but not with "
"``'<user@host.com'`` nor ``'user@host.com>'``."
msgstr ""
"Tentará corresponder com ``padrão-sim`` se o grupo com determinado *id* ou "
"*nome* existir, e com ``padrão-não`` se não existir. ``padrão-não`` é "
"opcional e pode ser omitido. Por exemplo,  ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>|$)`` é um padrão ruim de correspondência de e-mail, que corresponderá "
"com ``'<usuario@host.com>'`` bem como ``'usuario@host.com'``, mas não com "
"``'<usuario@host.com>'`` nem ``'usuario@host.com>'``."

#: ../../library/re.rst:393
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII letter, "
"then the resulting RE will match the second character.  For example, ``\\$`` "
"matches the character ``'$'``."
msgstr ""
"As sequências especiais consistem em ``'\\'`` e um caractere da lista "
"abaixo. Se o caractere comum não for um dígito ASCII ou uma letra ASCII, a "
"ER resultante corresponderá ao segundo caractere. Por exemplo, ``\\$`` "
"corresponde ao caractere ``'$'``."

#: ../../library/re.rst:408
msgid "``\\number``"
msgstr "``\\number``"

#: ../../library/re.rst:401
msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first "
"digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""
"Corresponde ao conteúdo do grupo de mesmo número. Os grupos são numerados a "
"partir de 1. Por exemplo, ``(.+) \\1`` corresponde a ``'de de'`` ou ``'55 "
"55'``, mas não ``'dede'`` (note o espaço após o grupo). Esta sequência "
"especial só pode ser usada para corresponder a um dos primeiros 99 grupos. "
"Se o primeiro dígito de *número* for 0, ou *número* tiver 3 dígitos octais "
"de comprimento, ele não será interpretado como uma correspondência de grupo, "
"mas como o caractere com *número* de valor octal. Dentro de ``'['`` e "
"``']'`` de uma classe de caracteres, todos os escapes numéricos são tratados "
"como caracteres."

#: ../../library/re.rst:413
msgid "``\\A``"
msgstr "``\\A``"

#: ../../library/re.rst:413
msgid "Matches only at the start of the string."
msgstr "Corresponde apenas ao início da string."

#: ../../library/re.rst:429
msgid "``\\b``"
msgstr "``\\b``"

#: ../../library/re.rst:418
msgid ""
"Matches the empty string, but only at the beginning or end of a word. A word "
"is defined as a sequence of word characters.  Note that formally, ``\\b`` is "
"defined as the boundary between a ``\\w`` and a ``\\W`` character (or vice "
"versa), or between ``\\w`` and the beginning/end of the string. This means "
"that ``r'\\bfoo\\b'`` matches ``'foo'``, ``'foo.'``, ``'(foo)'``, ``'bar foo "
"baz'`` but not ``'foobar'`` or ``'foo3'``."
msgstr ""
"Corresponde à string vazia, mas apenas no início ou no final de uma palavra. "
"Uma palavra é definida como uma sequência de caracteres de palavras. Observe "
"que, formalmente, ``\\b`` é definido como a fronteira entre um caractere ``"
"\\w`` e um ``\\W`` (ou vice-versa), ou entre ``\\w`` e o início/fim da "
"string. Isso significa que ``r'\\bfoo\\b'`` corresponde a ``'foo'``, "
"``'foo.'``, ``'(foo)'``, ``'bar foo baz'``, mas não a ``'foobar'`` ou "
"``'foo3'``."

#: ../../library/re.rst:425
msgid ""
"By default Unicode alphanumerics are the ones used in Unicode patterns, but "
"this can be changed by using the :const:`ASCII` flag.  Word boundaries are "
"determined by the current locale if the :const:`LOCALE` flag is used. Inside "
"a character range, ``\\b`` represents the backspace character, for "
"compatibility with Python's string literals."
msgstr ""
"Por padrão, os alfanuméricos Unicode são aqueles usados nos padrões Unicode, "
"mas isso pode ser alterado usando o sinalizador :const:`ASCII`. Os limites "
"das palavras são determinados pela localidade atual se o sinalizador :const:"
"`LOCALE` for usado. Dentro de um intervalo de caracteres, ``\\b`` representa "
"o caractere de backspace, para compatibilidade com os literais de string do "
"Python."

#: ../../library/re.rst:440
msgid "``\\B``"
msgstr "``\\B``"

#: ../../library/re.rst:434
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word.  This means that ``r'py\\B'`` matches ``'python'``, ``'py3'``, "
"``'py2'``, but not ``'py'``, ``'py.'``, or ``'py!'``. ``\\B`` is just the "
"opposite of ``\\b``, so word characters in Unicode patterns are Unicode "
"alphanumerics or the underscore, although this can be changed by using the :"
"const:`ASCII` flag.  Word boundaries are determined by the current locale if "
"the :const:`LOCALE` flag is used."
msgstr ""
"Corresponde à string vazia, mas apenas quando *não* estiver no início ou no "
"final de uma palavra. Isso significa que ``r'py\\B'`` corresponde a "
"``'python'``, ``'py3'``, ``'py2'``, mas não ``'py'``, ``'py.'``, or "
"``'py!'``. ``\\B`` é exatamente o oposto de ``\\b``, então caracteres de "
"palavras em padrões Unicode são alfanuméricos Unicode ou o sublinhado, "
"embora isso possa ser alterado usando o sinalizador :const:`ASCII`. Os "
"limites das palavras são determinados pela localidade atual se o "
"sinalizador :const:`LOCALE` for usado."

#: ../../library/re.rst:454
msgid "``\\d``"
msgstr "``\\d``"

#: ../../library/re.rst:451 ../../library/re.rst:475 ../../library/re.rst:499
msgid "For Unicode (str) patterns:"
msgstr "Para padrões (str) Unicode:"

#: ../../library/re.rst:446
msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category [Nd]).  This includes ``[0-9]``, and also many other "
"digit characters.  If the :const:`ASCII` flag is used only ``[0-9]`` is "
"matched (but the flag affects the entire regular expression, so in such "
"cases using an explicit ``[0-9]`` may be a better choice)."
msgstr ""

#: ../../library/re.rst:454 ../../library/re.rst:479 ../../library/re.rst:505
msgid "For 8-bit (bytes) patterns:"
msgstr "Para padrões de 8 bits (isto é, bytes):"

#: ../../library/re.rst:454
msgid "Matches any decimal digit; this is equivalent to ``[0-9]``."
msgstr "Corresponde a qualquer dígito decimal; isso é equivalente a ``[0-9]``."

#: ../../library/re.rst:463
msgid "``\\D``"
msgstr "``\\D``"

#: ../../library/re.rst:459
msgid ""
"Matches any character which is not a decimal digit. This is the opposite of "
"``\\d``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^0-9]`` (but the flag affects the entire regular expression, so in such "
"cases using an explicit ``[^0-9]`` may be a better choice)."
msgstr ""

#: ../../library/re.rst:479
msgid "``\\s``"
msgstr "``\\s``"

#: ../../library/re.rst:469
msgid ""
"Matches Unicode whitespace characters (which includes ``[ \\t\\n\\r\\f"
"\\v]``, and also many other characters, for example the non-breaking spaces "
"mandated by typography rules in many languages). If the :const:`ASCII` flag "
"is used, only ``[ \\t\\n\\r\\f\\v]`` is matched (but the flag affects the "
"entire regular expression, so in such cases using an explicit ``[ \\t\\n\\r"
"\\f\\v]`` may be a better choice)."
msgstr ""

#: ../../library/re.rst:478
msgid ""
"Matches characters considered whitespace in the ASCII character set; this is "
"equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"Corresponde a caracteres considerados espaços em branco no conjunto de "
"caracteres ASCII; isso é equivalente a ``[ \\t\\n\\r\\f\\v]``."

#: ../../library/re.rst:488
msgid "``\\S``"
msgstr "``\\S``"

#: ../../library/re.rst:484
msgid ""
"Matches any character which is not a whitespace character. This is the "
"opposite of ``\\s``. If the :const:`ASCII` flag is used this becomes the "
"equivalent of ``[^ \\t\\n\\r\\f\\v]`` (but the flag affects the entire "
"regular expression, so in such cases using an explicit ``[^ \\t\\n\\r\\f"
"\\v]`` may be a better choice)."
msgstr ""

#: ../../library/re.rst:505
msgid "``\\w``"
msgstr "``\\w``"

#: ../../library/re.rst:494
msgid ""
"Matches Unicode word characters; this includes most characters that can be "
"part of a word in any language, as well as numbers and the underscore. If "
"the :const:`ASCII` flag is used, only ``[a-zA-Z0-9_]`` is matched (but the "
"flag affects the entire regular expression, so in such cases using an "
"explicit ``[a-zA-Z0-9_]`` may be a better choice)."
msgstr ""

#: ../../library/re.rst:502
msgid ""
"Matches characters considered alphanumeric in the ASCII character set; this "
"is equivalent to ``[a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, "
"matches characters considered alphanumeric in the current locale and the "
"underscore."
msgstr ""
"Corresponde a caracteres considerados alfanuméricos no conjunto de "
"caracteres ASCII; isso é equivalente a ``[a-zA-Z0-9_]``. Se o sinalizador :"
"const:`LOCALE` for usado, corresponde aos caracteres considerados "
"alfanuméricos na localidade atual e o sublinhado."

#: ../../library/re.rst:516
msgid "``\\W``"
msgstr "``\\W``"

#: ../../library/re.rst:510
msgid ""
"Matches any character which is not a word character. This is the opposite of "
"``\\w``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^a-zA-Z0-9_]`` (but the flag affects the entire regular expression, so in "
"such cases using an explicit ``[^a-zA-Z0-9_]`` may be a better choice).  If "
"the :const:`LOCALE` flag is used, matches characters considered alphanumeric "
"in the current locale and the underscore."
msgstr ""

#: ../../library/re.rst:521
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../library/re.rst:521
msgid "Matches only at the end of the string."
msgstr "Corresponde apenas ao final da string."

#: ../../library/re.rst:537
msgid ""
"Most of the standard escapes supported by Python string literals are also "
"accepted by the regular expression parser::"
msgstr ""
"A maioria dos escapes padrão suportados por literais de string Python também "
"são aceitos pelo analisador sintático de expressão regular:"

#: ../../library/re.rst:544
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr ""
"(Observe que ``\\b`` é usado para representar limites de palavras e "
"significa fazer \"backspace\" apenas dentro das classes de caracteres.)"

#: ../../library/re.rst:547
msgid ""
"``'\\u'`` and ``'\\U'`` escape sequences are only recognized in Unicode "
"patterns.  In bytes patterns they are errors."
msgstr ""

#: ../../library/re.rst:550
msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0, or "
"if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""
"Os escapes octais são incluídos em um formulário limitado. Se o primeiro "
"dígito for 0, ou se houver três dígitos octais, é considerado um escape "
"octal. Caso contrário, é uma referência de grupo. Quanto aos literais de "
"string, os escapes octais têm sempre no máximo três dígitos."

#: ../../library/re.rst:555
msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr "As sequências de escape ``'\\u'`` e ``'\\U'`` foram adicionadas."

#: ../../library/re.rst:558
msgid ""
"Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr ""
"Escapes desconhecidos consistindo em ``'\\'`` e uma letra ASCII agora são "
"erros."

#: ../../library/re.rst:566
msgid "Module Contents"
msgstr "Conteúdo do Módulo"

#: ../../library/re.rst:568
msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr ""
"O módulo define várias funções, constantes e uma exceção. Algumas das "
"funções são versões simplificadas dos métodos completos para expressões "
"regulares compiladas. A maioria dos aplicativos não triviais sempre usa a "
"forma compilada."

#: ../../library/re.rst:573
msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a subclass "
"of :class:`enum.IntFlag`."
msgstr ""
"Constantes de sinalizadores são agora instâncias de :class:`RegexFlag`, que "
"é uma subclasse de :class:`enum.IntFlag`."

#: ../../library/re.rst:579
msgid ""
"Compile a regular expression pattern into a :ref:`regular expression object "
"<re-objects>`, which can be used for matching using its :func:`~regex."
"match`, :func:`~regex.search` and other methods, described below."
msgstr ""

#: ../../library/re.rst:584
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the following variables, combined using bitwise OR (the "
"``|`` operator)."
msgstr ""
"O comportamento da expressão pode ser modificado especificando um valor "
"*flags*. Os valores podem ser qualquer uma das seguintes variáveis, "
"correspondidas usando OU bit a bit (o operador ``|``)."

#: ../../library/re.rst:588
msgid "The sequence ::"
msgstr "A sequência ::"

#: ../../library/re.rst:593
msgid "is equivalent to ::"
msgstr "é equivalente a::"

#: ../../library/re.rst:597
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr ""
"mas usar :func:`re.compile` e salvar o objeto de expressão regular "
"resultante para reutilização é mais eficiente quando a expressão será usada "
"várias vezes em um único programa."

#: ../../library/re.rst:603
msgid ""
"The compiled versions of the most recent patterns passed to :func:`re."
"compile` and the module-level matching functions are cached, so programs "
"that use only a few regular expressions at a time needn't worry about "
"compiling regular expressions."
msgstr ""
"As versões compiladas dos padrões mais recentes passados para :func:`re."
"compile` e as funções de correspondência em nível de módulo são armazenadas "
"em cache, de modo que programas que usam apenas algumas expressões regulares "
"por vez não precisam se preocupar em compilar expressões regulares."

#: ../../library/re.rst:612
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and ``"
"\\S`` perform ASCII-only matching instead of full Unicode matching.  This is "
"only meaningful for Unicode patterns, and is ignored for byte patterns. "
"Corresponds to the inline flag ``(?a)``."
msgstr ""
"Faz com que ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` e "
"``\\S`` executem a correspondência somente ASCII em vez da correspondência "
"Unicode completa. Isso é significativo apenas para padrões Unicode e é "
"ignorado para padrões de bytes. Corresponde ao sinalizador em linha ``(?a)``."

#: ../../library/re.rst:617
msgid ""
"Note that for backward compatibility, the :const:`re.U` flag still exists "
"(as well as its synonym :const:`re.UNICODE` and its embedded counterpart ``(?"
"u)``), but these are redundant in Python 3 since matches are Unicode by "
"default for strings (and Unicode matching isn't allowed for bytes)."
msgstr ""
"Observe que, para compatibilidade com versões anteriores, o sinalizador :"
"const:`re.U` ainda existe (bem como seu sinônimo :const:`re.UNICODE` e sua "
"contraparte incorporada ``(?u)``), mas estes são redundantes em Python 3, "
"pois as correspondências são Unicode por padrão para strings (e a "
"correspondência Unicode não é permitida para bytes)."

#: ../../library/re.rst:626
msgid ""
"Display debug information about compiled expression. No corresponding inline "
"flag."
msgstr ""
"Exibe informações de depuração sobre a expressão compilada. Nenhum "
"sinalizador em linha correspondente."

#: ../../library/re.rst:633
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also "
"match lowercase letters.  Full Unicode matching (such as ``Ü`` matching "
"``ü``) also works unless the :const:`re.ASCII` flag is used to disable non-"
"ASCII matches.  The current locale does not change the effect of this flag "
"unless the :const:`re.LOCALE` flag is also used. Corresponds to the inline "
"flag ``(?i)``."
msgstr ""
"Executa uma correspondência que não diferencia maiúsculas de minúsculas; "
"expressões como ``[A-Z]`` também corresponderão a letras minúsculas. A "
"correspondência Unicode completa (como ``Ü`` correspondendo a ``ü``) também "
"funciona, a menos que o sinalizador :const:`re.ASCII` seja usado para "
"desabilitar correspondências não ASCII. A localidade atual não muda o efeito "
"deste sinalizador a menos que o sinalizador :const:`re.LOCALE` também seja "
"usado. Corresponde ao sinalizador em linha ``(?i)``."

#: ../../library/re.rst:640
msgid ""
"Note that when the Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in "
"combination with the :const:`IGNORECASE` flag, they will match the 52 ASCII "
"letters and 4 additional non-ASCII letters: 'İ' (U+0130, Latin capital "
"letter I with dot above), 'ı' (U+0131, Latin small letter dotless i), 'ſ' (U"
"+017F, Latin small letter long s) and 'K' (U+212A, Kelvin sign). If the :"
"const:`ASCII` flag is used, only letters 'a' to 'z' and 'A' to 'Z' are "
"matched (but the flag affects the entire regular expression, so in such "
"cases using an explicit ``(?-i:[a-zA-Z])`` may be a better choice)."
msgstr ""

#: ../../library/re.rst:653
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale.  This flag can be used only with bytes "
"patterns.  The use of this flag is discouraged as the locale mechanism is "
"very unreliable, it only handles one \"culture\" at a time, and it only "
"works with 8-bit locales.  Unicode matching is already enabled by default in "
"Python 3 for Unicode (str) patterns, and it is able to handle different "
"locales/languages. Corresponds to the inline flag ``(?L)``."
msgstr ""
"Faz ``\\w``, ``\\W``, ``\\b``, ``\\B`` e a correspondência sem diferença "
"entre maiúsculas e minúsculas dependente do local atual. Este sinalizador "
"pode ser usado apenas com padrões de bytes. O uso desse sinalizador é "
"desencorajado porque o mecanismo de localidade não é confiável, ele só lida "
"com uma \"cultura\" por vez e só funciona com localidades de 8 bits. A "
"correspondência Unicode já está habilitada por padrão no Python 3 para "
"padrões Unicode (str) e é capaz de lidar com diferentes localidades/idiomas. "
"Corresponde ao sinalizador em linha ``(?L)``."

#: ../../library/re.rst:662
msgid ""
":const:`re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :const:`re.ASCII`."
msgstr ""
":const:`re.LOCALE` pode ser usado apenas com padrões de bytes e não é "
"compatível com :const:`re.ASCII`."

#: ../../library/re.rst:670
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string "
"and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string. Corresponds to the inline flag ``(?m)``."
msgstr ""
"Quando especificado, o caractere padrão ``'^'`` corresponde ao início da "
"string e ao início de cada linha (imediatamente após cada nova linha); e o "
"caractere padrão ``'$'`` corresponde ao final da string e ao final de cada "
"linha (imediatamente antes de cada nova linha). Por padrão, ``'^'`` "
"corresponde apenas no início da string, e ``'$'`` apenas no final da string "
"e imediatamente antes da nova linha (se houver) no final da string. "
"Corresponde ao sinalizador em linha ``(?m)``."

#: ../../library/re.rst:682
msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline. "
"Corresponds to the inline flag ``(?s)``."
msgstr ""
"Faz o caractere especial ``'.'`` corresponder a qualquer caractere, "
"incluindo uma nova linha; sem este sinalizador, ``'.'`` irá corresponder a "
"qualquer coisa *exceto* uma nova linha. Corresponde ao sinalizador em linha "
"``(?s)``."

#: ../../library/re.rst:692
msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class, or when preceded by an unescaped backslash, or "
"within tokens like ``*?``, ``(?:`` or ``(?P<...>``. When a line contains a "
"``#`` that is not in a character class and is not preceded by an unescaped "
"backslash, all characters from the leftmost such ``#`` through the end of "
"the line are ignored."
msgstr ""
"Este sinalizador permite que você escreva expressões regulares que parecem "
"mais agradáveis e são mais legíveis, permitindo que você separe visualmente "
"seções lógicas do padrão e adicione comentários. O espaço em branco dentro "
"do padrão é ignorado, exceto quando em uma classe de caractere, ou quando "
"precedido por uma contrabarra sem escape, ou dentro de tokens como ``*?``, "
"``(?:`` ou ``(?P<...>``. Quando uma linha contém um ``#`` que não está em "
"uma classe de caractere e não é precedido por uma contrabarra sem escape, "
"todos os caracteres da extremidade esquerda, como ``#`` até o final da linha "
"são ignorados."

#: ../../library/re.rst:701
msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr ""
"Isso significa que os dois seguintes objetos de expressão regular que "
"correspondem a um número decimal são funcionalmente iguais::"

#: ../../library/re.rst:709
msgid "Corresponds to the inline flag ``(?x)``."
msgstr "Corresponde ao sinalizador em linha ``(?x)``."

#: ../../library/re.rst:714
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding :ref:"
"`match object <match-objects>`.  Return ``None`` if no position in the "
"string matches the pattern; note that this is different from finding a zero-"
"length match at some point in the string."
msgstr ""
"Percorre a *string* procurando o primeiro local onde o padrão *pattern* de "
"expressão regular produz uma correspondência e retorna um :ref:`objeto de "
"correspondência <match-objects>` encontrado. Retorne ``None`` se nenhuma "
"posição na string corresponder ao padrão; observe que isso é diferente de "
"encontrar uma correspondência de comprimento zero em algum ponto da string."

#: ../../library/re.rst:723
msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :ref:`match object <match-"
"objects>`.  Return ``None`` if the string does not match the pattern; note "
"that this is different from a zero-length match."
msgstr ""
"Se zero ou mais caracteres no início da *string* corresponderem ao padrão "
"*pattern* da expressão regular, retorna um :ref:`objeto de correspondência "
"<match-objects>` encontrado. Retorna ``None`` se a string não corresponder "
"ao padrão; observe que isso é diferente de uma correspondência de "
"comprimento zero."

#: ../../library/re.rst:728
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr ""
"Observe que mesmo no modo :const:`MULTILINE`, :func:`re.match` irá "
"corresponder apenas no início da string e não no início de cada linha."

#: ../../library/re.rst:731
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""
"Se você quiser localizar uma correspondência em qualquer lugar em *string*, "
"use :func:`search` (veja também :ref:`search-vs-match`)."

#: ../../library/re.rst:737
msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"Se toda a *string* corresponder ao padrão *pattern* da expressão regular, "
"retorna um :ref:`objeto de correspondência <match-objects>` encontrado. "
"Retorna ``None`` se a string não corresponder ao padrão; observe que isso é "
"diferente de uma correspondência de comprimento zero."

#: ../../library/re.rst:747
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list. ::"
msgstr ""
"Divide a *string* pelas ocorrências do padrão *pattern*. Se parênteses de "
"captura forem usados em *pattern*, o texto de todos os grupos no padrão "
"também será retornado como parte da lista resultante. Se *maxsplit* for "
"diferente de zero, no máximo *maxsplit* divisões ocorrerão e o restante da "
"string será retornado como o elemento final da lista. ::"

#: ../../library/re.rst:762
msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string::"
msgstr ""
"Se houver grupos de captura no separador e ele corresponder ao início da "
"string, o resultado começará com uma string vazia. O mesmo vale para o final "
"da string::"

#: ../../library/re.rst:769
msgid ""
"That way, separator components are always found at the same relative indices "
"within the result list."
msgstr ""
"Dessa forma, os componentes do separador são sempre encontrados nos mesmos "
"índices relativos na lista de resultados."

#: ../../library/re.rst:774
msgid ""
":func:`split` doesn't currently split a string on an empty pattern match. "
"For example::"
msgstr ""

#: ../../library/re.rst:780
msgid ""
"Even though ``'x*'`` also matches 0 'x' before 'a', between 'b' and 'c', and "
"after 'c', currently these matches are ignored.  The correct behavior (i.e. "
"splitting on empty matches too and returning ``['', 'a', 'b', 'c', '']``) "
"will be implemented in future versions of Python, but since this is a "
"backward incompatible change, a :exc:`FutureWarning` will be raised in the "
"meanwhile."
msgstr ""

#: ../../library/re.rst:787
msgid ""
"Patterns that can only match empty strings currently never split the "
"string.  Since this doesn't match the expected behavior, a :exc:`ValueError` "
"will be raised starting from Python 3.5::"
msgstr ""

#: ../../library/re.rst:797 ../../library/re.rst:877 ../../library/re.rst:897
msgid "Added the optional flags argument."
msgstr "Adicionado o argumento de sinalizadores opcionais."

#: ../../library/re.rst:800
msgid ""
"Splitting on a pattern that could match an empty string now raises a "
"warning.  Patterns that can only match empty strings are now rejected."
msgstr ""

#: ../../library/re.rst:807
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings.  The *string* is scanned left-to-right, and matches are returned in "
"the order found.  If one or more groups are present in the pattern, return a "
"list of groups; this will be a list of tuples if the pattern has more than "
"one group.  Empty matches are included in the result."
msgstr ""
"Retorna todas as correspondências não sobrepostas de padrão *pattern* na "
"*string*, como uma lista de strings. A *string* é verificada da esquerda "
"para a direita e as correspondências são retornadas na ordem encontrada. Se "
"um ou mais grupos estiverem presentes no padrão, retorna uma lista de "
"grupos; esta será uma lista de tuplas se o padrão tiver mais de um grupo. "
"Correspondências vazias são incluídas no resultado."

#: ../../library/re.rst:815
msgid ""
"Due to the limitation of the current implementation the character following "
"an empty match is not included in a next match, so ``findall(r'^|\\w+', 'two "
"words')`` returns ``['', 'wo', 'words']`` (note missed \"t\").  This is "
"changed in Python 3.7."
msgstr ""

#: ../../library/re.rst:823
msgid ""
"Return an :term:`iterator` yielding :ref:`match objects <match-objects>` "
"over all non-overlapping matches for the RE *pattern* in *string*.  The "
"*string* is scanned left-to-right, and matches are returned in the order "
"found.  Empty matches are included in the result.  See also the note about :"
"func:`findall`."
msgstr ""

#: ../../library/re.rst:831
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string "
"or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, ``"
"\\r`` is converted to a carriage return, and so forth.  Unknown escapes such "
"as ``\\&`` are left alone.  Backreferences, such as ``\\6``, are replaced "
"with the substring matched by group 6 in the pattern. For example::"
msgstr ""

#: ../../library/re.rst:845
msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single :ref:`match object <match-"
"objects>` argument, and returns the replacement string.  For example::"
msgstr ""
"Se *repl* for uma função, ela será chamada para cada ocorrência não "
"sobreposta do padrão *pattern*. A função recebe um único argumento :ref:"
"`objeto de correspondência <match-objects>` e retorna a string de "
"substituição. Por exemplo::"

#: ../../library/re.rst:857
msgid "The pattern may be a string or a :ref:`pattern object <re-objects>`."
msgstr ""
"O padrão pode ser uma string ou um :ref:`objeto de padrão <re-objects>`."

#: ../../library/re.rst:859
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero, "
"all occurrences will be replaced. Empty matches for the pattern are replaced "
"only when not adjacent to a previous match, so ``sub('x*', '-', 'abc')`` "
"returns ``'-a-b-c-'``."
msgstr ""

#: ../../library/re.rst:867
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched "
"by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. ``"
"\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore "
"equivalent to ``\\2``, but isn't ambiguous in a replacement such as ``"
"\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not a "
"reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr ""
"Em argumentos *repl* do tipo string, além dos escapes de caractere e "
"retrovisores descritos acima, ``\\g<nome>`` usará a substring correspondida "
"pelo grupo denominado ``nome``, conforme definido pela sintaxe ``(?"
"P<nome>...)``. ``\\g<número>`` usa o número do grupo correspondente; ``"
"\\g<2>`` é portanto equivalente a ``\\2``, mas não é ambíguo em uma "
"substituição como ``\\g<2>0``. ``\\20`` seria interpretado como uma "
"referência ao grupo 20, não uma referência ao grupo 2 seguida pelo caractere "
"literal ``'0'``. O retrovisor ``\\g6`` substitui em toda a substring "
"correspondida pela ER."

#: ../../library/re.rst:880 ../../library/re.rst:900 ../../library/re.rst:1120
msgid "Unmatched groups are replaced with an empty string."
msgstr "Grupos sem correspondência são substituídos por uma string vazia."

#: ../../library/re.rst:883
msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter now "
"are errors."
msgstr ""
"Escapes desconhecidos no padrão *pattern* consistindo em ``'\\'`` e uma "
"letra ASCII agora são erros."

#: ../../library/re.rst:889
msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now "
"raise a deprecation warning and will be forbidden in Python 3.7."
msgstr ""

#: ../../library/re.rst:894
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string, "
"number_of_subs_made)``."
msgstr ""

#: ../../library/re.rst:906
msgid ""
"Escape all the characters in *pattern* except ASCII letters, numbers and "
"``'_'``. This is useful if you want to match an arbitrary literal string "
"that may have regular expression metacharacters in it.  For example::"
msgstr ""

#: ../../library/re.rst:921
msgid ""
"This functions must not be used for the replacement string in :func:`sub` "
"and :func:`subn`, only backslashes should be escaped.  For example::"
msgstr ""

#: ../../library/re.rst:929
msgid "The ``'_'`` character is no longer escaped."
msgstr ""

#: ../../library/re.rst:935
msgid "Clear the regular expression cache."
msgstr ""

#: ../../library/re.rst:940
msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or "
"matching.  It is never an error if a string contains no match for a "
"pattern.  The error instance has the following additional attributes:"
msgstr ""

#: ../../library/re.rst:948
msgid "The unformatted error message."
msgstr ""

#: ../../library/re.rst:952
msgid "The regular expression pattern."
msgstr ""

#: ../../library/re.rst:956
msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr ""

#: ../../library/re.rst:960
msgid "The line corresponding to *pos* (may be ``None``)."
msgstr ""

#: ../../library/re.rst:964
msgid "The column corresponding to *pos* (may be ``None``)."
msgstr ""

#: ../../library/re.rst:966
msgid "Added additional attributes."
msgstr ""

#: ../../library/re.rst:972
msgid "Regular Expression Objects"
msgstr ""

#: ../../library/re.rst:974
msgid ""
"Compiled regular expression objects support the following methods and "
"attributes:"
msgstr ""

#: ../../library/re.rst:979
msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding :ref:`match object "
"<match-objects>`.  Return ``None`` if no position in the string matches the "
"pattern; note that this is different from finding a zero-length match at "
"some point in the string."
msgstr ""

#: ../../library/re.rst:985
msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent "
"to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""

#: ../../library/re.rst:991
msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found; otherwise, if *rx* is a "
"compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``. ::"
msgstr ""

#: ../../library/re.rst:1006
msgid ""
"If zero or more characters at the *beginning* of *string* match this regular "
"expression, return a corresponding :ref:`match object <match-objects>`. "
"Return ``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""

#: ../../library/re.rst:1011 ../../library/re.rst:1029
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the :"
"meth:`~regex.search` method. ::"
msgstr ""

#: ../../library/re.rst:1019
msgid ""
"If you want to locate a match anywhere in *string*, use :meth:`~regex."
"search` instead (see also :ref:`search-vs-match`)."
msgstr ""

#: ../../library/re.rst:1025
msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""

#: ../../library/re.rst:1043
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr ""

#: ../../library/re.rst:1048
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""

#: ../../library/re.rst:1055
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""

#: ../../library/re.rst:1062
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr ""

#: ../../library/re.rst:1067
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr ""

#: ../../library/re.rst:1072
msgid ""
"The regex matching flags.  This is a combination of the flags given to :func:"
"`.compile`, any ``(?...)`` inline flags in the pattern, and implicit flags "
"such as :data:`UNICODE` if the pattern is a Unicode string."
msgstr ""

#: ../../library/re.rst:1079
msgid "The number of capturing groups in the pattern."
msgstr ""

#: ../../library/re.rst:1084
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr ""

#: ../../library/re.rst:1091
msgid "The pattern string from which the RE object was compiled."
msgstr ""

#: ../../library/re.rst:1097
msgid "Match Objects"
msgstr ""

#: ../../library/re.rst:1099
msgid ""
"Match objects always have a boolean value of ``True``. Since :meth:`~regex."
"match` and :meth:`~regex.search` return ``None`` when there is no match, you "
"can test whether there was a match with a simple ``if`` statement::"
msgstr ""

#: ../../library/re.rst:1108
msgid "Match objects support the following methods and attributes:"
msgstr ""

#: ../../library/re.rst:1113
msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~regex.sub` method. Escapes such as "
"``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, ``"
"\\g<name>``) are replaced by the contents of the corresponding group."
msgstr ""

#: ../../library/re.rst:1125
msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match, "
"the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned. ::"
msgstr ""

#: ../../library/re.rst:1147
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an :exc:"
"`IndexError` exception is raised."
msgstr ""

#: ../../library/re.rst:1152
msgid "A moderately complicated example::"
msgstr ""

#: ../../library/re.rst:1160
msgid "Named groups can also be referred to by their index::"
msgstr ""

#: ../../library/re.rst:1167
msgid "If a group matches multiple times, only the last match is accessible::"
msgstr ""

#: ../../library/re.rst:1176
msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match::"
msgstr ""

#: ../../library/re.rst:1192
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``."
msgstr ""

#: ../../library/re.rst:1196 ../../library/re.rst:1416
msgid "For example::"
msgstr "Por exemplo::"

#: ../../library/re.rst:1202
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given::"
msgstr ""

#: ../../library/re.rst:1215
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed "
"by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example::"
msgstr ""

#: ../../library/re.rst:1227
msgid ""
"Return the indices of the start and end of the substring matched by *group*; "
"*group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""

#: ../../library/re.rst:1235
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, ``m."
"start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are both "
"2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""

#: ../../library/re.rst:1240
msgid "An example that will remove *remove_this* from email addresses::"
msgstr ""

#: ../../library/re.rst:1250
msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. Note "
"that if *group* did not contribute to the match, this is ``(-1, -1)``. "
"*group* defaults to zero, the entire match."
msgstr ""

#: ../../library/re.rst:1257
msgid ""
"The value of *pos* which was passed to the :meth:`~regex.search` or :meth:"
"`~regex.match` method of a :ref:`regex object <re-objects>`.  This is the "
"index into the string at which the RE engine started looking for a match."
msgstr ""

#: ../../library/re.rst:1264
msgid ""
"The value of *endpos* which was passed to the :meth:`~regex.search` or :meth:"
"`~regex.match` method of a :ref:`regex object <re-objects>`.  This is the "
"index into the string beyond which the RE engine will not go."
msgstr ""

#: ../../library/re.rst:1271
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, ``((a)"
"(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the string "
"``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == 2``, if "
"applied to the same string."
msgstr ""

#: ../../library/re.rst:1280
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr ""

#: ../../library/re.rst:1286
msgid ""
"The :ref:`regular expression object <re-objects>` whose :meth:`~regex.match` "
"or :meth:`~regex.search` method produced this match instance."
msgstr ""

#: ../../library/re.rst:1292
msgid "The string passed to :meth:`~regex.match` or :meth:`~regex.search`."
msgstr ""

#: ../../library/re.rst:1298
msgid "Regular Expression Examples"
msgstr ""

#: ../../library/re.rst:1302
msgid "Checking for a Pair"
msgstr ""

#: ../../library/re.rst:1304
msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully:"
msgstr ""

#: ../../library/re.rst:1314
msgid ""
"Suppose you are writing a poker program where a player's hand is represented "
"as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr ""

#: ../../library/re.rst:1319
msgid "To see if a given string is a valid hand, one could do the following::"
msgstr ""

#: ../../library/re.rst:1329
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences "
"as such::"
msgstr ""

#: ../../library/re.rst:1339
msgid ""
"To find out what card the pair consists of, one could use the :meth:`~match."
"group` method of the match object in the following manner:"
msgstr ""

#: ../../library/re.rst:1359
msgid "Simulating scanf()"
msgstr ""

#: ../../library/re.rst:1363
msgid ""
"Python does not currently have an equivalent to :c:func:`scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than :c:"
"func:`scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :c:func:`scanf` format tokens and regular "
"expressions."
msgstr ""

#: ../../library/re.rst:1370
msgid ":c:func:`scanf` Token"
msgstr ""

#: ../../library/re.rst:1370
msgid "Regular Expression"
msgstr ""

#: ../../library/re.rst:1372
msgid "``%c``"
msgstr "``%c``"

#: ../../library/re.rst:1374
msgid "``%5c``"
msgstr "``%5c``"

#: ../../library/re.rst:1374
msgid "``.{5}``"
msgstr "``.{5}``"

#: ../../library/re.rst:1376
msgid "``%d``"
msgstr "``%d``"

#: ../../library/re.rst:1376
msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

#: ../../library/re.rst:1378
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr ""

#: ../../library/re.rst:1378
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

#: ../../library/re.rst:1380
msgid "``%i``"
msgstr "``%i``"

#: ../../library/re.rst:1380
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

#: ../../library/re.rst:1382
msgid "``%o``"
msgstr "``%o``"

#: ../../library/re.rst:1382
msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

#: ../../library/re.rst:1384
msgid "``%s``"
msgstr "``%s``"

#: ../../library/re.rst:1384
msgid "``\\S+``"
msgstr "``\\S+``"

#: ../../library/re.rst:1386
msgid "``%u``"
msgstr "``%u``"

#: ../../library/re.rst:1386
msgid "``\\d+``"
msgstr "``\\d+``"

#: ../../library/re.rst:1388
msgid "``%x``, ``%X``"
msgstr ""

#: ../../library/re.rst:1388
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

#: ../../library/re.rst:1391
msgid "To extract the filename and numbers from a string like ::"
msgstr ""

#: ../../library/re.rst:1395
msgid "you would use a :c:func:`scanf` format like ::"
msgstr ""

#: ../../library/re.rst:1399
msgid "The equivalent regular expression would be ::"
msgstr "A expressão regular equivalente seria ::"

#: ../../library/re.rst:1407
msgid "search() vs. match()"
msgstr ""

#: ../../library/re.rst:1411
msgid ""
"Python offers two different primitive operations based on regular "
"expressions: :func:`re.match` checks for a match only at the beginning of "
"the string, while :func:`re.search` checks for a match anywhere in the "
"string (this is what Perl does by default)."
msgstr ""

#: ../../library/re.rst:1422
msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr ""

#: ../../library/re.rst:1430
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each "
"line. ::"
msgstr ""

#: ../../library/re.rst:1440
msgid "Making a Phonebook"
msgstr ""

#: ../../library/re.rst:1442
msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""

#: ../../library/re.rst:1447
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax::"
msgstr ""

#: ../../library/re.rst:1458
msgid ""
"The entries are separated by one or more newlines. Now we convert the string "
"into a list with each nonempty line having its own entry:"
msgstr ""

#: ../../library/re.rst:1471
msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""

#: ../../library/re.rst:1484
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""

#: ../../library/re.rst:1499
msgid "Text Munging"
msgstr ""

#: ../../library/re.rst:1501
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""

#: ../../library/re.rst:1518
msgid "Finding all Adverbs"
msgstr ""

#: ../../library/re.rst:1520
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if a writer wanted to find all of "
"the adverbs in some text, they might use :func:`findall` in the following "
"manner::"
msgstr ""

#: ../../library/re.rst:1531
msgid "Finding all Adverbs and their Positions"
msgstr ""

#: ../../library/re.rst:1533
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides :ref:`match objects "
"<match-objects>` instead of strings.  Continuing with the previous example, "
"if a writer wanted to find all of the adverbs *and their positions* in some "
"text, they would use :func:`finditer` in the following manner::"
msgstr ""

#: ../../library/re.rst:1547
msgid "Raw String Notation"
msgstr ""

#: ../../library/re.rst:1549
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without "
"it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical::"
msgstr ""

#: ../../library/re.rst:1559
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical::"
msgstr ""

#: ../../library/re.rst:1571
msgid "Writing a Tokenizer"
msgstr ""

#: ../../library/re.rst:1573
msgid ""
"A `tokenizer or scanner <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"analyzes a string to categorize groups of characters.  This is a useful "
"first step in writing a compiler or interpreter."
msgstr ""

#: ../../library/re.rst:1577
msgid ""
"The text categories are specified with regular expressions.  The technique "
"is to combine those into a single master regular expression and to loop over "
"successive matches::"
msgstr ""

#: ../../library/re.rst:1629
msgid "The tokenizer produces the following output::"
msgstr ""

#: ../../library/re.rst:1652
msgid ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. The third edition of the book no longer covers Python at all, but the "
"first edition covered writing good regular expression patterns in great "
"detail."
msgstr ""

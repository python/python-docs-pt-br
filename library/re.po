# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Risaffi <erikrisaffi@gmail.com>, 2021
# i17obot <i17obot@rougeth.com>, 2021
# Marco Rougeth <marco@rougeth.com>, 2021
# Vinicius Gubiani Ferreira <vini.g.fer@gmail.com>, 2021
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2022
# Leticia Portella <leportella@gmail.com>, 2022
# Adorilson Bezerra <adorilson@gmail.com>, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-25 14:19+0000\n"
"PO-Revision-Date: 2021-06-28 01:12+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/re.rst:2
msgid ":mod:`!re` --- Regular expression operations"
msgstr ":mod:`!re` --- Operações com expressões regulares"

#: ../../library/re.rst:10
msgid "**Source code:** :source:`Lib/re/`"
msgstr "**Código-fonte:** :source:`Lib/re/`"

#: ../../library/re.rst:14
msgid ""
"This module provides regular expression matching operations similar to those "
"found in Perl."
msgstr ""
"Este módulo fornece operações para correspondência de expressões regulares "
"semelhantes às encontradas em Perl. O nome do módulo vem das iniciais do "
"termo em inglês *regular expressions*, também frequentemente chamadas de "
"*regex*."

#: ../../library/re.rst:17
msgid ""
"Both patterns and strings to be searched can be Unicode strings "
"(:class:`str`) as well as 8-bit strings (:class:`bytes`). However, Unicode "
"strings and 8-bit strings cannot be mixed: that is, you cannot match a "
"Unicode string with a bytes pattern or vice-versa; similarly, when asking "
"for a substitution, the replacement string must be of the same type as both "
"the pattern and the search string."
msgstr ""
"Tanto os padrões quanto as strings a serem pesquisados podem ser strings "
"Unicode (:class:`str`) assim como strings de 8 bits (:class:`bytes`). No "
"entanto, strings Unicode e strings de 8 bits não podem ser misturadas: ou "
"seja, você não pode corresponder uma string Unicode com um padrão de bytes "
"ou vice-versa; da mesma forma, ao solicitar uma substituição, a string de "
"substituição deve ser do mesmo tipo que o padrão e a string de pesquisa."

#: ../../library/re.rst:24
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal. Also, "
"please note that any invalid escape sequences in Python's usage of the "
"backslash in string literals now generate a :exc:`SyntaxWarning` and in the "
"future this will become a :exc:`SyntaxError`. This behaviour will happen "
"even if it is a valid escape sequence for a regular expression."
msgstr ""
"Expressões regulares usam o caractere de contrabarra (``'\\'``) para indicar "
"formas especiais ou para permitir que caracteres especiais sejam usados sem "
"invocar seu significado especial. Isso colide com o uso em Python do mesmo "
"caractere para o mesmo propósito em literais de string; por exemplo, para "
"corresponder a uma contrabarra literal, pode-se ter que escrever ``'\\\\\\"
"\\'`` como a string do padrão, porque a expressão regular deve ser ``\\\\``, "
"e cada contrabarra deve ser expressa como ``\\\\`` dentro de um literal de "
"string Python regular. Além disso, observe que quaisquer sequências de "
"escape inválidas no uso do Python da contrabarra em literais de string agora "
"levantam uma exceção :exc:`SyntaxWarning` e no futuro isso se tornará "
"um :exc:`SyntaxError`. Esse comportamento acontecerá mesmo se for uma "
"sequência de escape válida para uma expressão regular."

#: ../../library/re.rst:36
msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal "
"prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string containing "
"``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string containing "
"a newline.  Usually patterns will be expressed in Python code using this raw "
"string notation."
msgstr ""
"A solução é usar a notação de string bruta do Python para padrões de "
"expressão regular; as contrabarras não são tratadas de nenhuma maneira "
"especial em uma string literal com o prefixo ``'r'``. Portanto, ``r\"\\n\"`` "
"é uma string de dois caracteres contendo ``'\\'`` e ``'n'``, enquanto "
"``\"\\n\"`` é uma string de um caractere contendo uma nova linha. "
"Normalmente, os padrões serão expressos em código Python usando esta notação "
"de string bruta."

#: ../../library/re.rst:43
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular "
"expressions <re-objects>`.  The functions are shortcuts that don't require "
"you to compile a regex object first, but miss some fine-tuning parameters."
msgstr ""
"É importante notar que a maioria das operações de expressão regular estão "
"disponíveis como funções e métodos em nível de módulo em :ref:`expressões "
"regulares compiladas <re-objects>`. As funções são atalhos que não exigem "
"que você compile um objeto de expressão regular primeiro, mas perdem-se "
"alguns parâmetros de ajuste fino."

#: ../../library/re.rst:51
msgid ""
"The third-party :pypi:`regex` module, which has an API compatible with the "
"standard library :mod:`re` module, but offers additional functionality and a "
"more thorough Unicode support."
msgstr ""
"O módulo de terceiros :pypi:`regex` possui uma API compatível com o módulo "
"da biblioteca padrão :mod:`re`, mas oferece funcionalidades adicionais e um "
"suporte mais completo a Unicode."

#: ../../library/re.rst:59
msgid "Regular Expression Syntax"
msgstr "Sintaxe de expressão regular"

#: ../../library/re.rst:61
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the "
"functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""
"Uma expressão regular (ou ER) especifica um conjunto de strings que "
"corresponde a ela; as funções neste módulo permitem que você verifique se "
"uma determinada string corresponde a uma determinada expressão regular (ou "
"se uma determinada expressão regular corresponde a uma determinada string, o "
"que resulta na mesma coisa)."

#: ../../library/re.rst:66
msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described "
"here.  For details of the theory and implementation of regular expressions, "
"consult the Friedl book [Frie09]_, or almost any textbook about compiler "
"construction."
msgstr ""
"As expressões regulares podem ser concatenadas para formar novas expressões "
"regulares; se *A* e *B* forem expressões regulares, então *AB* também será "
"uma expressão regular. Em geral, se uma string *p* corresponder a *A* e "
"outra string *q* corresponder a *B*, a string *pq* corresponderá a AB. Isso "
"é válido, a menos que *A* ou *B* contenham operações de baixa precedência; "
"condições de contorno entre *A* e *B*; ou ter referências de grupo "
"numeradas. Assim, expressões complexas podem ser facilmente construídas a "
"partir de expressões primitivas mais simples, como as descritas aqui. Para "
"obter detalhes sobre a teoria e implementação de expressões regulares, "
"consulte o livro de Friedl [Frie09]_, ou quase qualquer livro sobre "
"construção de compiladores."

#: ../../library/re.rst:76
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr ""
"Segue uma breve explicação do formato das expressões regulares. Para mais "
"informações e uma apresentação mais suave, consulte o tutorial "
"de :ref:`regex-howto`."

#: ../../library/re.rst:79
msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""
"As expressões regulares podem conter caracteres especiais e comuns. A "
"maioria dos caracteres comuns, como ``'A'``, ``'a'`` ou ``'0'``, são as "
"expressões regulares mais simples; eles simplesmente se correspondem. Você "
"pode concatenar caracteres comuns, de forma que ``último`` corresponda à "
"string ``'último'``. (No restante desta seção, escreveremos ERs ``neste "
"estilo especial``, geralmente sem aspas, e strings para serem correspondidas "
"``'entre aspas simples'``.)"

#: ../../library/re.rst:86
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted."
msgstr ""
"Alguns caracteres, como ``'|'`` ou ``'('``, são especiais. Os caracteres "
"especiais representam classes de caracteres comuns ou afetam como as "
"expressões regulares em torno deles são interpretadas."

#: ../../library/re.rst:90
msgid ""
"Repetition operators or quantifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) "
"cannot be directly nested. This avoids ambiguity with the non-greedy "
"modifier suffix ``?``, and with other modifiers in other implementations. To "
"apply a second repetition to an inner repetition, parentheses may be used. "
"For example, the expression ``(?:a{6})*`` matches any multiple of six "
"``'a'`` characters."
msgstr ""
"Operadores de repetição ou quantificadores (``*``, ``+``, ``?``, ``{m,n}`` "
"etc) não podem ser aninhados diretamente. Isso evita ambiguidade com o "
"sufixo modificador não guloso ``?``, e com outros modificadores em outras "
"implementações. Para aplicar uma segunda repetição a uma repetição interna, "
"podem ser usados parênteses. Por exemplo, a expressão ``(?:a{6})*`` "
"corresponde a qualquer múltiplo de seis caracteres ``'a'``."

#: ../../library/re.rst:97
msgid "The special characters are:"
msgstr "Os caracteres especiais são:"

#: ../../library/re.rst:101 ../../library/re.rst:1658
msgid "``.``"
msgstr "``.``"

#: ../../library/re.rst:102
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline.  ``(?s:.)`` matches any character regardless of flags."
msgstr ""
"(Ponto.) No modo padrão, corresponde a qualquer caractere, exceto uma nova "
"linha. Se o sinalizador :const:`DOTALL` foi especificado, ele corresponde a "
"qualquer caractere, incluindo uma nova linha. ``(?s:.)`` corresponde a "
"qualquer caractere independente de sinalizadores."

#: ../../library/re.rst:108
msgid "``^``"
msgstr "``^``"

#: ../../library/re.rst:109
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr ""
"(Sinal de circunflexo.) Corresponde ao início da string, e no "
"modo :const:`MULTILINE` também corresponde imediatamente após cada nova "
"linha."

#: ../../library/re.rst:114
msgid "``$``"
msgstr "``$``"

#: ../../library/re.rst:115
msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in "
"``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' "
"in :const:`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` "
"will find two (empty) matches: one just before the newline, and one at the "
"end of the string."
msgstr ""
"Corresponde ao final da string ou logo antes da nova linha no final da "
"string, e no modo :const:`MULTILINE` também corresponde antes de uma nova "
"linha. ``foo`` corresponde a 'foo' e 'foobar', enquanto a expressão regular "
"``foo$`` corresponde apenas a 'foo'. Mais interessante, pesquisar por ``foo."
"$`` em ``'foo1\\nfoo2\\n'`` corresponde a 'foo2' normalmente, mas 'foo1' no "
"modo :const:`MULTILINE`; procurando por um único ``$`` em ``'foo\\n'`` "
"encontrará duas correspondências (vazias): uma logo antes da nova linha e "
"uma no final da string."

#: ../../library/re.rst:125
msgid "``*``"
msgstr "``*``"

#: ../../library/re.rst:126
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""
"Faz a ER resultante corresponder a 0 ou mais repetições da ER anterior, "
"tantas repetições quantas forem possíveis. ``ab*`` corresponderá a 'a', 'ab' "
"ou 'a' seguido por uma quantidade qualquer de 'b's."

#: ../../library/re.rst:132
msgid "``+``"
msgstr "``+``"

#: ../../library/re.rst:133
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr ""
"Faz com que a ER resultante corresponda a 1 ou mais repetições da ER "
"anterior. ``ab+`` irá corresponder a 'a' seguido por qualquer número "
"diferente de zero de 'b's; não corresponderá apenas a 'a'."

#: ../../library/re.rst:139
msgid "``?``"
msgstr "``?``"

#: ../../library/re.rst:140
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr ""
"Faz a ER resultante corresponder a 0 ou 1 repetição da ER anterior. ``ab?`` "
"irá corresponder a 'a' ou 'ab'."

#: ../../library/re.rst:148
msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

#: ../../library/re.rst:149
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` quantifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``'<a> b <c>'``, it will match the entire "
"string, and not just ``'<a>'``.  Adding ``?`` after the quantifier makes it "
"perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``'<a>'``."
msgstr ""
"Os quantificadores ``'*'``, ``'+'`` e ``'?'`` são todos :dfn:`gulosos`; eles "
"correspondem ao máximo de texto possível. Às vezes, esse comportamento não é "
"desejado; se a ER ``<.*>`` for correspondida com ``'<a> b <c>'``, ela irá "
"corresponder a toda a string, e não apenas ``'<a>'``. Adicionar ``?`` após o "
"quantificador faz com que ele execute a correspondência da maneira :dfn:`não "
"gulosa` ou :dfn:`minimalista`; tão *poucos* caracteres quanto possível serão "
"correspondidos. Usando a ER ``<.*?>`` irá corresponder apenas ``'<a>'``."

#: ../../library/re.rst:162
msgid "``*+``, ``++``, ``?+``"
msgstr "``*+``, ``++``, ``?+``"

#: ../../library/re.rst:163
msgid ""
"Like the ``'*'``, ``'+'``, and ``'?'`` quantifiers, those where ``'+'`` is "
"appended also match as many times as possible. However, unlike the true "
"greedy quantifiers, these do not allow back-tracking when the expression "
"following it fails to match. These are known as :dfn:`possessive` "
"quantifiers. For example, ``a*a`` will match ``'aaaa'`` because the ``a*`` "
"will match all 4 ``'a'``\\ s, but, when the final ``'a'`` is encountered, "
"the expression is backtracked so that in the end the ``a*`` ends up matching "
"3 ``'a'``\\ s total, and the fourth ``'a'`` is matched by the final ``'a'``. "
"However, when ``a*+a`` is used to match ``'aaaa'``, the ``a*+`` will match "
"all 4 ``'a'``, but when the final ``'a'`` fails to find any more characters "
"to match, the expression cannot be backtracked and will thus fail to match. "
"``x*+``, ``x++`` and ``x?+`` are equivalent to ``(?>x*)``, ``(?>x+)`` and "
"``(?>x?)`` correspondingly."
msgstr ""
"Como os quantificadores ``'*'``, ``'+'`` e ``'?'``, aqueles em que ``'+'`` é "
"anexado também correspondem tantas vezes quanto possível. No entanto, ao "
"contrário dos quantificadores realmente gulosos, eles não permitem "
"retrocesso quando a expressão que o segue não corresponde. Estes são "
"conhecidos como quantificadores :dfn:`possessivos`. Por exemplo, ``a*a`` "
"corresponderá a ``'aaaa'`` porque o ``a*`` corresponderá a todos os 4 "
"``'a'``\\s, mas, quando o final ``'a'`` for encontrado, a expressão é "
"retrocedida para que no final o ``a*`` acabe correspondendo a 3 ``'a'``\\ s "
"no total, e o quarto ``'a'`` seja correspondido por o final ``'a'``. No "
"entanto, quando ``a*+a`` é usado para corresponder a ``'aaaa'``, o ``a*+`` "
"corresponderá a todos os 4 ``'a'``, mas quando o ``'a'`` final não encontrar "
"mais caracteres para corresponder, a expressão não pode ser retrocedida e, "
"portanto, não corresponderá. ``x*+``, ``x++`` e ``x?+`` são equivalentes a "
"``(?>x*)``, ``(?>x+)`` e ``(?>x?)`` respectivamente."

#: ../../library/re.rst:184
msgid "``{m}``"
msgstr "``{m}``"

#: ../../library/re.rst:185
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""
"Especifica que exatamente *m* cópias da ER anterior devem ser "
"correspondidas; menos correspondências fazem com que toda a ER não seja "
"correspondida. Por exemplo, ``a{6}`` irá corresponder exatamente a seis "
"caracteres ``'a'``, mas não a cinco."

#: ../../library/re.rst:189
msgid "``{m,n}``"
msgstr "``{m,n}``"

#: ../../library/re.rst:190
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m* "
"specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``'aaaab'`` or a thousand "
"``'a'`` characters followed by a ``'b'``, but not ``'aaab'``. The comma may "
"not be omitted or the modifier would be confused with the previously "
"described form."
msgstr ""
"Faz a ER resultante corresponder de *m* a *n* repetições da ER anterior, "
"tentando corresponder ao máximo de repetições possível. Por exemplo, ``a{3,5}"
"`` irá corresponder de 3 a 5 caracteres ``'a'``. A omissão de *m* especifica "
"um limite inferior de zero e a omissão de *n* especifica um limite superior "
"infinito. Como exemplo, ``a{4,}b`` irá corresponder a ``'aaaab'`` ou mil "
"caracteres ``'a'`` seguidos por um ``'b'``, mas não ``'aaab'``. A vírgula "
"não pode ser omitida ou o modificador será confundido com a forma descrita "
"anteriormente."

#: ../../library/re.rst:198
msgid "``{m,n}?``"
msgstr "``{m,n}?``"

#: ../../library/re.rst:199
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is "
"the non-greedy version of the previous quantifier.  For example, on the 6-"
"character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters, "
"while ``a{3,5}?`` will only match 3 characters."
msgstr ""
"Faz a ER resultante corresponder de *m* a *n* repetições da ER anterior, "
"tentando corresponder o *mínimo* de repetições possível. Esta é a versão não "
"gulosa do quantificador anterior. Por exemplo, na string de 6 caracteres "
"``'aaaaaa'``, ``a{3,5}`` irá corresponder a 5 caracteres ``'a'``, enquanto "
"``a{3,5}?`` corresponderá apenas a 3 caracteres."

#: ../../library/re.rst:205
msgid "``{m,n}+``"
msgstr "``{m,n}+``"

#: ../../library/re.rst:206
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible *without* "
"establishing any backtracking points. This is the possessive version of the "
"quantifier above. For example, on the 6-character string ``'aaaaaa'``, "
"``a{3,5}+aa`` attempt to match 5 ``'a'`` characters, then, requiring 2 more "
"``'a'``\\ s, will need more characters than available and thus fail, while "
"``a{3,5}aa`` will match with ``a{3,5}`` capturing 5, then 4 ``'a'``\\ s by "
"backtracking and then the final 2 ``'a'``\\ s are matched by the final "
"``aa`` in the pattern. ``x{m,n}+`` is equivalent to ``(?>x{m,n})``."
msgstr ""
"Faz a ER resultante corresponder de *m* a *n* repetições da ER anterior, "
"tentando corresponder o maior número possível de repetições *sem* "
"estabelecer nenhum ponto de retrocesso. Esta é a versão possessiva do "
"quantificador acima. Por exemplo, na string de 6 caracteres ``'aaaaaa'``, "
"``a{3,5}+aa`` tenta corresponder 5 caracteres ``'a'``, então, requerer mais "
"2 ``'a'``\\s, precisará de mais caracteres do que os disponíveis e, "
"portanto, falhará, enquanto ``a{3,5}aa`` corresponderá a ``a{3,5}`` "
"capturando 5, depois 4 ``'a'``\\s por retrocesso e então os 2 ``'a'``\\s "
"finais são combinados com o ``aa`` final no padrão. ``x{m,n}+`` é "
"equivalente a ``(?>x{m,n})``."

#: ../../library/re.rst:222
msgid "``\\``"
msgstr "``\\``"

#: ../../library/re.rst:223
msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr ""
"Ou anula o efeito de caracteres especiais (permitindo a você corresponder "
"caracteres como ``'*'``, ``'?'`` e assim por diante), ou sinaliza uma "
"sequência especial; sequências especiais são discutidas abaixo."

#: ../../library/re.rst:227
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""
"Se você não estiver usando uma string bruta para expressar o padrão, lembre-"
"se de que o Python também usa a contrabarra como uma sequência de escape em "
"literais de string; se a sequência de escape não for reconhecida pelo "
"analisador sintático do Python, a contrabarra e o caractere subsequente "
"serão incluídos na string resultante. No entanto, se Python reconhecer a "
"sequência resultante, a contrabarra deve ser repetida duas vezes. Isso é "
"complicado e difícil de entender, portanto, é altamente recomendável que "
"você use strings brutas para todas as expressões, exceto as mais simples."

#: ../../library/re.rst:238
msgid "``[]``"
msgstr "``[]``"

#: ../../library/re.rst:239
msgid "Used to indicate a set of characters.  In a set:"
msgstr "Usado para indicar um conjunto de caracteres. Em um conjunto:"

#: ../../library/re.rst:241
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr ""
"Caracteres podem ser listados individualmente, por exemplo, ``[amk]`` vai "
"corresponder a ``'a'``, ``'m'`` ou ``'k'``."

#: ../../library/re.rst:246
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase "
"ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[-a]`` or ``[a-]``), it will match a literal ``'-'``."
msgstr ""
"Intervalos de caracteres podem ser indicados fornecendo dois caracteres e "
"separando-os por ``'-'``, por exemplo ``[a-z]`` irá corresponder a qualquer "
"letra ASCII minúscula, ``[0-5][0-9]`` irá corresponder a todos os números de "
"dois dígitos de ``00`` a ``59``, e ``[0-9A-Fa-f]`` irá corresponder a "
"qualquer dígito hexadecimal. Se ``-`` for precedido de uma contrabarra (por "
"exemplo, ``[a\\-z]``) ou se for colocado como o primeiro ou último caractere "
"(por exemplo, ``[-a]`` ou ``[a-]``), ele corresponderá a um literal ``'-'``."

#: ../../library/re.rst:253
msgid ""
"Special characters except backslash lose their special meaning inside sets. "
"For example, ``[(+*)]`` will match any of the literal characters ``'('``, "
"``'+'``, ``'*'``, or ``')'``."
msgstr ""
"Os caracteres especiais, exceto contrabarra, perdem seu significado especial "
"dentro dos conjuntos. Por exemplo, ``[(+*)]`` vai corresponder a qualquer um "
"dos caracteres literais ``'('``, ``'+'``, ``'*'`` ou ``')'``."

#: ../../library/re.rst:260
msgid ""
"Backslash either escapes characters which have special meaning in a set such "
"as ``'-'``, ``']'``, ``'^'`` and ``'\\\\'`` itself or signals a special "
"sequence which represents a single character such as ``\\xa0`` or ``\\n`` or "
"a character class such as ``\\w`` or ``\\S`` (defined below). Note that "
"``\\b`` represents a single \"backspace\" character, not a word boundary as "
"outside a set, and numeric escapes such as ``\\1`` are always octal escapes, "
"not group references. Special sequences which do not match a single "
"character such as ``\\A`` and ``\\Z`` are not allowed."
msgstr ""
"A contrabarra escapa caracteres que têm significado especial em um conjunto, "
"como ``'-'``, ``']'``, ``'^'`` e ``'\\\\'``, ou sinaliza uma sequência "
"especial que representa um único caractere, como ``\\xa0`` ou ``\\n``, ou "
"uma classe de caracteres como ``\\w`` ou ``\\S`` (definida abaixo). Observe "
"que ``\\b`` representa um único caractere de \"backspace\", não um limite de "
"palavra como fora de um conjunto, e escapes numéricos como ``\\1`` são "
"sempre escapes octais, não referências de grupo. Sequências especiais que "
"não correspondem a um único caractere, como ``\\A`` e ``\\Z``, não são "
"permitidas."

#: ../../library/re.rst:273
msgid ""
"Characters that are not within a range can be matched "
"by :dfn:`complementing` the set.  If the first character of the set is "
"``'^'``, all the characters that are *not* in the set will be matched.  For "
"example, ``[^5]`` will match any character except ``'5'``, and ``[^^]`` will "
"match any character except ``'^'``.  ``^`` has no special meaning if it's "
"not the first character in the set."
msgstr ""
"Os caracteres que não estão dentro de um intervalo podem ser "
"correspondidos :dfn:`complementando` o conjunto. Se o primeiro caractere do "
"conjunto for ``'^'``, todos os caracteres que *não* estiverem no conjunto "
"serão correspondidos. Por exemplo, ``[^5]`` irá corresponder a qualquer "
"caractere exceto ``'5'``, e ``[^^]`` irá corresponder a qualquer caractere "
"exceto ``'^'``. ``^`` não tem nenhum significado especial se não for o "
"primeiro caractere do conjunto."

#: ../../library/re.rst:280
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will match a right bracket, as well as left bracket, braces, "
"and parentheses."
msgstr ""
"Para corresponder a um ``']'`` literal dentro de um conjunto, preceda-o com "
"uma contrabarra ou coloque-o no início do conjunto. Por exemplo, ``[()[\\]"
"{}]`` e ``[]()[{}]`` vai corresponder ao colchete à direita, assim como o "
"colchete, chave ou parêntese à esquerda."

#: ../../library/re.rst:290
msgid ""
"Support of nested sets and set operations as in `Unicode Technical Standard "
"#18`_ might be added in the future.  This would change the syntax, so to "
"facilitate this change a :exc:`FutureWarning` will be raised in ambiguous "
"cases for the time being. That includes sets starting with a literal ``'['`` "
"or containing literal character sequences ``'--'``, ``'&&'``, ``'~~'``, and "
"``'||'``.  To avoid a warning escape them with a backslash."
msgstr ""
"Suporte para conjuntos aninhados e operações de conjunto como no `Padrão "
"Técnico do Unicode #18`_ podem ser adicionados no futuro. Isso mudaria a "
"sintaxe, então para facilitar essa mudança uma :exc:`FutureWarning` será "
"levantada em casos ambíguos por enquanto. Isso inclui conjuntos que começam "
"com um ``'['`` literal ou contendo sequências de caracteres literais "
"``'--'``, ``'&&'``, ``'~~'`` e ``'||'``. Para evitar um aviso, use uma "
"contrabarra antes deles."

#: ../../library/re.rst:300
msgid ""
":exc:`FutureWarning` is raised if a character set contains constructs that "
"will change semantically in the future."
msgstr ""
":exc:`FutureWarning` é levantada se um conjunto de caracteres contém "
"construções que mudarão semanticamente no futuro."

#: ../../library/re.rst:306
msgid "``|``"
msgstr "``|``"

#: ../../library/re.rst:307
msgid ""
"``A|B``, where *A* and *B* can be arbitrary REs, creates a regular "
"expression that will match either *A* or *B*.  An arbitrary number of REs "
"can be separated by the ``'|'`` in this way.  This can be used inside groups "
"(see below) as well.  As the target string is scanned, REs separated by "
"``'|'`` are tried from left to right. When one pattern completely matches, "
"that branch is accepted. This means that once *A* matches, *B* will not be "
"tested further, even if it would produce a longer overall match.  In other "
"words, the ``'|'`` operator is never greedy.  To match a literal ``'|'``, "
"use ``\\|``, or enclose it inside a character class, as in ``[|]``."
msgstr ""
"``A|B``, onde *A* e *B* podem ser ERs arbitrárias, cria uma expressão "
"regular que corresponderá a *A* ou *B*. Um número arbitrário de ERs pode ser "
"separado por ``'|'`` desta forma. Isso também pode ser usado dentro de "
"grupos (veja abaixo). Conforme a string alvo é percorrida, ERs separadas por "
"``'|'`` são avaliadas da esquerda para a direita. Quando um padrão "
"corresponde completamente, essa ramificação é aceita. Isso significa que, "
"assim que *A* corresponder, *B* não será avaliado posteriormente, mesmo que "
"produza uma correspondência geral mais longa. Em outras palavras, o operador "
"``'|'`` nunca é guloso. Para corresponder a um ``'|'`` literal, use ``\\|``, "
"ou coloque-o dentro de uma classe de caractere, como em ``[|]``."

#: ../../library/re.rst:320
msgid "``(...)``"
msgstr "``(...)``"

#: ../../library/re.rst:321
msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates "
"the start and end of a group; the contents of a group can be retrieved after "
"a match has been performed, and can be matched later in the string with the "
"``\\number`` special sequence, described below.  To match the literals "
"``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside a "
"character class: ``[(]``, ``[)]``."
msgstr ""
"Corresponde a qualquer expressão regular que esteja entre parênteses e "
"indica o início e o fim de um grupo; o conteúdo de um grupo pode ser "
"recuperado após uma correspondência ter sido realizada e pode ser "
"correspondido posteriormente na string com a sequência especial "
"``\\número``, descrita abaixo. Para corresponder aos literais ``'('`` ou "
"``')'``, use ``\\(`` ou ``\\)``, ou coloque-os dentro de uma classe de "
"caracteres: ``[(]``, ``[)]``."

#: ../../library/re.rst:329
msgid "``(?...)``"
msgstr "``(?...)``"

#: ../../library/re.rst:330
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""
"Esta é uma notação de extensão (um ``'?'`` após um ``'('`` não é "
"significativo de outra forma). O primeiro caractere após o ``'?'`` determina "
"qual o significado e sintaxe posterior da construção. As extensões "
"normalmente não criam um novo grupo; ``(?P<nome>...)`` é a única exceção a "
"esta regra. A seguir estão as extensões atualmente implementadas."

#: ../../library/re.rst:336
msgid "``(?aiLmsux)``"
msgstr "``(?aiLmsux)``"

#: ../../library/re.rst:337
msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.) The group matches the empty string; the letters "
"set the corresponding flags for the entire regular expression:"
msgstr ""
"(Uma ou mais letras do conjunto ``'a'``, ``'i'``, ``'L'``, ``'m'``, ``'s'``, "
"``'u'``, ``'x'``.) O grupo corresponde à string vazia; as letras definem os "
"sinalizadores correspondentes para toda a expressão regular:"

#: ../../library/re.rst:342 ../../library/re.rst:374
msgid ":const:`re.A` (ASCII-only matching)"
msgstr ":const:`re.A` (correspondência somente ASCII)"

#: ../../library/re.rst:343 ../../library/re.rst:375
msgid ":const:`re.I` (ignore case)"
msgstr ":const:`re.I` (ignorar maiúsculas/minúsculas)"

#: ../../library/re.rst:344 ../../library/re.rst:376
msgid ":const:`re.L` (locale dependent)"
msgstr ":const:`re.L` (dependente da localidade)"

#: ../../library/re.rst:345 ../../library/re.rst:377
msgid ":const:`re.M` (multi-line)"
msgstr ":const:`re.M` (multi-linha)"

#: ../../library/re.rst:346 ../../library/re.rst:378
msgid ":const:`re.S` (dot matches all)"
msgstr ":const:`re.S` (ponto corresponde a tudo)"

#: ../../library/re.rst:347 ../../library/re.rst:379
msgid ":const:`re.U` (Unicode matching)"
msgstr ":const:`re.U` (correspondência Unicode)"

#: ../../library/re.rst:348 ../../library/re.rst:380
msgid ":const:`re.X` (verbose)"
msgstr ":const:`re.X` (verboso)"

#: ../../library/re.rst:350
msgid ""
"(The flags are described in :ref:`contents-of-module-re`.) This is useful if "
"you wish to include the flags as part of the regular expression, instead of "
"passing a *flag* argument to the :func:`re.compile` function. Flags should "
"be used first in the expression string."
msgstr ""
"(Os sinalizadores são descritos em :ref:`contents-of-module-re`.) Isso é "
"útil se você deseja incluir os sinalizadores como parte da expressão "
"regular, em vez de passar um argumento *flag* para a "
"função :func:`re.compile`. Os sinalizadores devem ser usados primeiro na "
"string de expressão."

#: ../../library/re.rst:356
msgid "This construction can only be used at the start of the expression."
msgstr "Esta construção só pode ser usada no início da expressão."

#: ../../library/re.rst:361
msgid "``(?:...)``"
msgstr "``(?:...)``"

#: ../../library/re.rst:362
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group "
"*cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr ""
"Uma versão sem captura de parênteses regulares. Corresponde a qualquer "
"expressão regular que esteja entre parênteses, mas a substring correspondida "
"pelo grupo *não pode* ser recuperada após realizar uma correspondência ou "
"referenciada posteriormente no padrão."

#: ../../library/re.rst:367
msgid "``(?aiLmsux-imsx:...)``"
msgstr "``(?aiLmsux-imsx:...)``"

#: ../../library/re.rst:368
msgid ""
"(Zero or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``, optionally followed by ``'-'`` followed by one or "
"more letters from the ``'i'``, ``'m'``, ``'s'``, ``'x'``.) The letters set "
"or remove the corresponding flags for the part of the expression:"
msgstr ""
"(Zero ou mais letras do conjunto ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``, opcionalmente seguidas por ``'-'`` seguido por "
"uma ou mais letras do conjunto ``'i'``, ``'m'``, ``'s'``, ``'x'``.) O "
"conjunto de letras define ou remove os sinalizadores correspondentes para a "
"parte da expressão:"

#: ../../library/re.rst:382
msgid "(The flags are described in :ref:`contents-of-module-re`.)"
msgstr "(Os sinalizadores são descritos em :ref:`contents-of-module-re`.)"

#: ../../library/re.rst:384
msgid ""
"The letters ``'a'``, ``'L'`` and ``'u'`` are mutually exclusive when used as "
"inline flags, so they can't be combined or follow ``'-'``.  Instead, when "
"one of them appears in an inline group, it overrides the matching mode in "
"the enclosing group.  In Unicode patterns ``(?a:...)`` switches to ASCII-"
"only matching, and ``(?u:...)`` switches to Unicode matching (default).  In "
"bytes patterns ``(?L:...)`` switches to locale dependent matching, and ``(?"
"a:...)`` switches to ASCII-only matching (default). This override is only in "
"effect for the narrow inline group, and the original matching mode is "
"restored outside of the group."
msgstr ""
"As letras ``'a'``, ``'L'`` e ``'u'`` são mutuamente exclusivas quando usadas "
"como sinalizadores em linha, portanto, não podem ser combinadas ou seguir "
"``'-'``. Em vez disso, quando um deles aparece em um grupo embutido, ele "
"substitui o modo de correspondência no grupo anexo. Em padrões Unicode ``(?"
"a:...)`` muda para correspondência somente ASCII, e ``(?u:...)`` muda para "
"correspondência Unicode (padrão). Em padrões de bytes ``(?L:...)`` muda para "
"a correspondência dependente da localidade, e ``(?a:...)`` muda para "
"correspondência apenas ASCII (padrão). Esta substituição só tem efeito para "
"o grupo estreito em linha e o modo de correspondência original é restaurado "
"fora do grupo."

#: ../../library/re.rst:396
msgid "The letters ``'a'``, ``'L'`` and ``'u'`` also can be used in a group."
msgstr ""
"As letras ``'a'``, ``'L'`` e ``'u'`` também podem ser usadas em um grupo."

#: ../../library/re.rst:399
msgid "``(?>...)``"
msgstr "``(?>...)``"

#: ../../library/re.rst:400
msgid ""
"Attempts to match ``...`` as if it was a separate regular expression, and if "
"successful, continues to match the rest of the pattern following it. If the "
"subsequent pattern fails to match, the stack can only be unwound to a point "
"*before* the ``(?>...)`` because once exited, the expression, known as "
"an :dfn:`atomic group`, has thrown away all stack points within itself. "
"Thus, ``(?>.*).`` would never match anything because first the ``.*`` would "
"match all characters possible, then, having nothing left to match, the final "
"``.`` would fail to match. Since there are no stack points saved in the "
"Atomic Group, and there is no stack point before it, the entire expression "
"would thus fail to match."
msgstr ""
"Tenta corresponder ``...`` como se fosse uma expressão regular separada e, "
"se for bem-sucedida, continua correspondendo ao restante do padrão que a "
"segue. Se o padrão subsequente não corresponder, a pilha só pode ser "
"desenrolada até um ponto *antes* do ``(?>...)`` porque, uma vez encerrada, a "
"expressão, conhecida como :dfn:`grupo atômico`, jogou fora todos os pontos "
"de pilha dentro de si. Assim, ``(?>.*).`` nunca corresponderia a nada porque "
"primeiro o ``.*`` corresponderia a todos os caracteres possíveis, então, não "
"tendo mais nada para corresponder, o ``.`` final falharia em corresponder. "
"Como não há pontos de pilha salvos no Grupo Atômico e não há ponto de pilha "
"antes dele, a expressão inteira não corresponderia."

#: ../../library/re.rst:416
msgid "``(?P<name>...)``"
msgstr "``(?P<nome>...)``"

#: ../../library/re.rst:417
msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and in :class:`bytes` patterns they can only contain "
"bytes in the ASCII range.  Each group name must be defined only once within "
"a regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr ""
"Semelhante aos parênteses regulares, mas a substring correspondida pelo "
"grupo é acessível por meio do nome de grupo simbólico *nome*. Os nomes de "
"grupo devem ser identificadores Python válidos e em padrões :class:`bytes` "
"eles só podem conter bytes no intervalo ASCII. Cada nome de grupo deve ser "
"definido apenas uma vez em uma expressão regular. Um grupo simbólico também "
"é um grupo numerado, como se o grupo não tivesse um nome."

#: ../../library/re.rst:424
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is ``(?"
"P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either "
"single or double quotes):"
msgstr ""
"Grupos nomeados podem ser referenciados em três contextos. Se o padrão for "
"``(?P<citação>['\"]).*?(?P=citação)`` (ou seja, corresponder a uma string "
"entre aspas simples ou duplas):"

#: ../../library/re.rst:429
msgid "Context of reference to group \"quote\""
msgstr "Contexto de referência ao grupo \"citação\""

#: ../../library/re.rst:429
msgid "Ways to reference it"
msgstr "Formas de referenciá-lo"

#: ../../library/re.rst:431
msgid "in the same pattern itself"
msgstr "no mesmo padrão"

#: ../../library/re.rst:431
msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=citação)`` (como mostrado)"

#: ../../library/re.rst:432 ../../library/re.rst:439
msgid "``\\1``"
msgstr "``\\1``"

#: ../../library/re.rst:434
msgid "when processing match object *m*"
msgstr "ao processar a correspondência do objeto *m*"

#: ../../library/re.rst:434
msgid "``m.group('quote')``"
msgstr "``m.group('citação')``"

#: ../../library/re.rst:435
msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('citação')`` (etc.)"

#: ../../library/re.rst:437
msgid "in a string passed to the *repl* argument of ``re.sub()``"
msgstr "em uma string passada para o argumento *repl* de ``re.sub()``"

#: ../../library/re.rst:437
msgid "``\\g<quote>``"
msgstr "``\\g<citação>``"

#: ../../library/re.rst:438
msgid "``\\g<1>``"
msgstr "``\\g<1>``"

#: ../../library/re.rst:442
msgid ""
"In :class:`bytes` patterns, group *name* can only contain bytes in the ASCII "
"range (``b'\\x00'``-``b'\\x7f'``)."
msgstr ""
"Nos padrões :class:`bytes`, o grupo *nome* só pode conter bytes no intervalo "
"ASCII (``b'\\x00'``-``b'\\x7f'``)."

#: ../../library/re.rst:448
msgid "``(?P=name)``"
msgstr "``(?P=nome)``"

#: ../../library/re.rst:449
msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr ""
"Uma referência anterior a um grupo nomeado; corresponde a qualquer texto que "
"corresponda ao grupo anterior denominado *nome*."

#: ../../library/re.rst:454
msgid "``(?#...)``"
msgstr "``(?#...)``"

#: ../../library/re.rst:455
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "Um comentário; o conteúdo dos parênteses é simplesmente ignorado."

#: ../../library/re.rst:459
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../library/re.rst:460
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a :dfn:`lookahead assertion`.  For example, ``Isaac (?"
"=Asimov)`` will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""
"Corresponde se ``...`` corresponder a próxima, mas não consome nada da "
"string. Isso é chamado de :dfn:`asserção preditiva`. Por exemplo, ``Isaac (?"
"=Asimov)`` corresponderá a ``'Isaac '`` apenas se for seguido por "
"``'Asimov'``."

#: ../../library/re.rst:466
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../library/re.rst:467
msgid ""
"Matches if ``...`` doesn't match next.  This is a :dfn:`negative lookahead "
"assertion`. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only "
"if it's *not* followed by ``'Asimov'``."
msgstr ""
"Corresponde se ``...`` não corresponder a próxima. Isso é uma :dfn:`asserção "
"preditiva negativa`. Por exemplo, ``Isaac (?!Asimov)`` corresponderá a "
"``'Isaac '`` apenas se *não* for seguido por ``'Asimov'``."

#: ../../library/re.rst:473
msgid "``(?<=...)``"
msgstr "``(?<=...)``"

#: ../../library/re.rst:474
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``'abcdef'``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed "
"length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and ``a{3,4}"
"`` are not.  Note that patterns which start with positive lookbehind "
"assertions will not match at the beginning of the string being searched; you "
"will most likely want to use the :func:`search` function rather than "
"the :func:`match` function:"
msgstr ""
"Corresponde se a posição atual na string for precedida por uma "
"correspondência para ``...`` que termina na posição atual. Isso é chamado "
"de :dfn:`asserção retroativa positiva`. ``(?<=abc)def`` irá encontrar uma "
"correspondência em ``'abcdef'``, uma vez que a expressão regular vai voltar "
"3 caracteres e verificar se o padrão contido corresponde. O padrão contido "
"deve corresponder apenas a strings de algum comprimento fixo, o que "
"significa que ``abc`` ou ``a|b`` são permitidos, mas ``a*`` e ``a{3,4}`` não "
"são. Observe que os padrões que começam com asserções retroativas positivas "
"não corresponderão ao início da string que está sendo pesquisada; você "
"provavelmente desejará usar a função :func:`search` em vez da "
"função :func:`match`:"

#: ../../library/re.rst:489
msgid "This example looks for a word following a hyphen:"
msgstr "Este exemplo procura por uma palavra logo após um hífen:"

#: ../../library/re.rst:495
msgid "Added support for group references of fixed length."
msgstr "Adicionado suporte para referências de grupo de comprimento fixo."

#: ../../library/re.rst:500
msgid "``(?<!...)``"
msgstr "``(?<!...)``"

#: ../../library/re.rst:501
msgid ""
"Matches if the current position in the string is not preceded by a match for "
"``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar to "
"positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length.  Patterns which start with negative lookbehind "
"assertions may match at the beginning of the string being searched."
msgstr ""
"Corresponde se a posição atual na string não for precedida por uma "
"correspondência para ``...``. Isso é chamado de :dfn:`asserção retroativa "
"negativa`. Semelhante às asserções retroativas positivas, o padrão contido "
"deve corresponder apenas a strings de algum comprimento fixo. Os padrões que "
"começam com asserções retroativas negativas podem corresponder ao início da "
"string que está sendo pesquisada."

#: ../../library/re.rst:510
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/nome)padrão-sim|padrão-não)``"

#: ../../library/re.rst:511
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>|$)`` is a poor email matching pattern, which will match with "
"``'<user@host.com>'`` as well as ``'user@host.com'``, but not with "
"``'<user@host.com'`` nor ``'user@host.com>'``."
msgstr ""
"Tentará corresponder com ``padrão-sim`` se o grupo com determinado *id* ou "
"*nome* existir, e com ``padrão-não`` se não existir. ``padrão-não`` é "
"opcional e pode ser omitido. Por exemplo,  ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>|$)`` é um padrão ruim de correspondência de e-mail, que corresponderá "
"com ``'<usuario@host.com>'`` bem como ``'usuario@host.com'``, mas não com "
"``'<usuario@host.com>'`` nem ``'usuario@host.com>'``."

#: ../../library/re.rst:518
msgid ""
"Group *id* can only contain ASCII digits. In :class:`bytes` patterns, group "
"*name* can only contain bytes in the ASCII range (``b'\\x00'``-``b'\\x7f'``)."
msgstr ""
"O grupo *id* só podem conter dígitos ASCII. Nos padrões :class:`bytes`, o "
"grupo *nome* só pode conter bytes no intervalo ASCII (``b'\\x00'``-"
"``b'\\x7f'``)."

#: ../../library/re.rst:526
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII letter, "
"then the resulting RE will match the second character.  For example, ``\\$`` "
"matches the character ``'$'``."
msgstr ""
"As sequências especiais consistem em ``'\\'`` e um caractere da lista "
"abaixo. Se o caractere comum não for um dígito ASCII ou uma letra ASCII, a "
"ER resultante corresponderá ao segundo caractere. Por exemplo, ``\\$`` "
"corresponde ao caractere ``'$'``."

#: ../../library/re.rst:533
msgid "``\\number``"
msgstr "``\\número``"

#: ../../library/re.rst:534
msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first "
"digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""
"Corresponde ao conteúdo do grupo de mesmo número. Os grupos são numerados a "
"partir de 1. Por exemplo, ``(.+) \\1`` corresponde a ``'de de'`` ou ``'55 "
"55'``, mas não ``'dede'`` (note o espaço após o grupo). Esta sequência "
"especial só pode ser usada para corresponder a um dos primeiros 99 grupos. "
"Se o primeiro dígito de *número* for 0, ou *número* tiver 3 dígitos octais "
"de comprimento, ele não será interpretado como uma correspondência de grupo, "
"mas como o caractere com *número* de valor octal. Dentro de ``'['`` e "
"``']'`` de uma classe de caracteres, todos os escapes numéricos são tratados "
"como caracteres."

#: ../../library/re.rst:545
msgid "``\\A``"
msgstr "``\\A``"

#: ../../library/re.rst:546
msgid "Matches only at the start of the string."
msgstr "Corresponde apenas ao início da string."

#: ../../library/re.rst:550
msgid "``\\b``"
msgstr "``\\b``"

#: ../../library/re.rst:551
msgid ""
"Matches the empty string, but only at the beginning or end of a word. A word "
"is defined as a sequence of word characters. Note that formally, ``\\b`` is "
"defined as the boundary between a ``\\w`` and a ``\\W`` character (or vice "
"versa), or between ``\\w`` and the beginning or end of the string. This "
"means that ``r'\\bat\\b'`` matches ``'at'``, ``'at.'``, ``'(at)'``, and "
"``'as at ay'`` but not ``'attempt'`` or ``'atlas'``."
msgstr ""
"Corresponde à string vazia, mas apenas no início ou no final de uma palavra. "
"Uma palavra é definida como uma sequência de caracteres de palavras. Observe "
"que, formalmente, ``\\b`` é definido como a fronteira entre um caractere "
"``\\w`` e um ``\\W`` (ou vice-versa), ou entre ``\\w`` e o início/fim da "
"string. Isso significa que ``r'\\bat\\b'`` corresponde a ``'at'``, "
"``'at.'``, ``'(at)'``, ``'as at ay'``, mas não a ``'attempt'`` ou "
"``'atlas'``."

#: ../../library/re.rst:559
msgid ""
"The default word characters in Unicode (str) patterns are Unicode "
"alphanumerics and the underscore, but this can be changed by using "
"the :py:const:`~re.ASCII` flag. Word boundaries are determined by the "
"current locale if the :py:const:`~re.LOCALE` flag is used."
msgstr ""
"Os caracteres de palavras predefinidos em padrões Unicode (str) são "
"alfanuméricos Unicode e o sublinhado, mas isso pode ser alterado usando o "
"sinalizador :py:const:`~re.ASCII`. Os limites das palavras são determinados "
"pela localidade atual se o sinalizador :py:const:`~re.LOCALE` for usado."

#: ../../library/re.rst:567
msgid ""
"Inside a character range, ``\\b`` represents the backspace character, for "
"compatibility with Python's string literals."
msgstr ""
"Dentro de um intervalo de caracteres, ``\\b`` representa o caractere "
"backspace, para compatibilidade com strings literais do Python."

#: ../../library/re.rst:572
msgid "``\\B``"
msgstr "``\\B``"

#: ../../library/re.rst:573
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word. This means that ``r'at\\B'`` matches ``'athens'``, ``'atom'``, "
"``'attorney'``, but not ``'at'``, ``'at.'``, or ``'at!'``. ``\\B`` is the "
"opposite of ``\\b``, so word characters in Unicode (str) patterns are "
"Unicode alphanumerics or the underscore, although this can be changed by "
"using the :py:const:`~re.ASCII` flag. Word boundaries are determined by the "
"current locale if the :py:const:`~re.LOCALE` flag is used."
msgstr ""
"Corresponde à string vazia, mas apenas quando *não* estiver no início ou no "
"final de uma palavra. Isso significa que ``r'at\\B'`` corresponde a "
"``'athens'``, ``'atom'``, ``'attorney'``, mas não ``'at'``, ``'at.'`` ou "
"``'at!'``. ``\\B`` é exatamente o oposto de ``\\b``, então caracteres de "
"palavras em padrões Unicode são alfanuméricos Unicode ou o sublinhado, "
"embora isso possa ser alterado usando o sinalizador :const:`ASCII`. Os "
"limites das palavras são determinados pela localidade atual se o "
"sinalizador :const:`LOCALE` for usado."

#: ../../library/re.rst:586
msgid ""
"Note that ``\\B`` does not match an empty string, which differs from RE "
"implementations in other programming languages such as Perl. This behavior "
"is kept for compatibility reasons."
msgstr ""
"Note que ``\\B`` não corresponde uma string vazia, o que difere das "
"implementações de ER em outros linguagens de programação, como Perl. Este "
"comportamento é mantido por razões de compatibilidade."

#: ../../library/re.rst:592
msgid "``\\d``"
msgstr "``\\d``"

#: ../../library/re.rst:593 ../../library/re.rst:617 ../../library/re.rst:639
msgid "For Unicode (str) patterns:"
msgstr "Para padrões Unicode (str):"

#: ../../library/re.rst:594
msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category `[Nd]`__). This includes ``[0-9]``, and also many other "
"digit characters."
msgstr ""
"Corresponde a qualquer dígito decimal Unicode (ou seja, qualquer caractere "
"na categoria de caractere Unicode `[Nd]`__). Isso inclui ``[0-9]``, e também "
"muitos outros caracteres de dígitos."

#: ../../library/re.rst:598
msgid "Matches ``[0-9]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""
"Se o sinalizador :const:`ASCII` for usado, apenas ``[0-9]`` será "
"correspondido."

#: ../../library/re.rst:602 ../../library/re.rst:624 ../../library/re.rst:647
msgid "For 8-bit (bytes) patterns:"
msgstr "Para padrões de 8 bits (isto é, bytes):"

#: ../../library/re.rst:603
msgid ""
"Matches any decimal digit in the ASCII character set; this is equivalent to "
"``[0-9]``."
msgstr ""
"Corresponde a qualquer dígito decimal no conjunto de caracteres ASCII; isso "
"é equivalente a ``[0-9]``."

#: ../../library/re.rst:608
msgid "``\\D``"
msgstr "``\\D``"

#: ../../library/re.rst:609
msgid ""
"Matches any character which is not a decimal digit. This is the opposite of "
"``\\d``."
msgstr ""
"Corresponde a qualquer caractere que não seja um dígito decimal. Isso é o "
"oposto de ``\\d``."

#: ../../library/re.rst:612
msgid "Matches ``[^0-9]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""
"Se o sinalizador :const:`~re.ASCII` for usado, apenas ``[^0-9]`` será "
"correspondido."

#: ../../library/re.rst:616
msgid "``\\s``"
msgstr "``\\s``"

#: ../../library/re.rst:618
msgid ""
"Matches Unicode whitespace characters (as defined "
"by :py:meth:`str.isspace`). This includes ``[ \\t\\n\\r\\f\\v]``, and also "
"many other characters, for example the non-breaking spaces mandated by "
"typography rules in many languages."
msgstr ""
"Corresponde a caracteres de espaço em branco Unicode (como definido "
"por :py:meth:`str.isspace`) . Isso inclui ``[ \\t\\n\\r\\f\\v]``, e também "
"muitos outros caracteres, como, por exemplo, os espaços não separáveis "
"exigidos pelas regras de tipografia em muitos idiomas."

#: ../../library/re.rst:622
msgid ""
"Matches ``[ \\t\\n\\r\\f\\v]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""
"Se o sinalizador  :const:`~re.ASCII` for usado, apenas "
"``[ \\t\\n\\r\\f\\v]`` é correspondido."

#: ../../library/re.rst:625
msgid ""
"Matches characters considered whitespace in the ASCII character set; this is "
"equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"Corresponde a caracteres considerados espaços em branco no conjunto de "
"caracteres ASCII; isso é equivalente a ``[ \\t\\n\\r\\f\\v]``."

#: ../../library/re.rst:630
msgid "``\\S``"
msgstr "``\\S``"

#: ../../library/re.rst:631
msgid ""
"Matches any character which is not a whitespace character. This is the "
"opposite of ``\\s``."
msgstr ""
"Corresponde a qualquer caractere que não seja um espaço em branco. Isso é o "
"oposto de ``\\s``."

#: ../../library/re.rst:634
msgid ""
"Matches ``[^ \\t\\n\\r\\f\\v]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""
"Se o sinalizador  :const:`~re.ASCII` for usado, apenas ``[^ "
"\\t\\n\\r\\f\\v]`` é correspondido."

#: ../../library/re.rst:638
msgid "``\\w``"
msgstr "``\\w``"

#: ../../library/re.rst:640
msgid ""
"Matches Unicode word characters; this includes all Unicode alphanumeric "
"characters (as defined by :py:meth:`str.isalnum`), as well as the underscore "
"(``_``)."
msgstr ""
"Corresponde a caracteres de palavras Unicode; isso inclui todos os "
"caracteres alfanuméricos Unicode (conforme definido "
"por :py:meth:`str.isalnum`), bem como o sublinhado (``_``)."

#: ../../library/re.rst:645
msgid "Matches ``[a-zA-Z0-9_]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""
"Se o sinalizador :const:`~re.ASCII` for usado, apenas ``[a-zA-Z0-9_]`` será "
"correspondido."

#: ../../library/re.rst:648
msgid ""
"Matches characters considered alphanumeric in the ASCII character set; this "
"is equivalent to ``[a-zA-Z0-9_]``. If the :py:const:`~re.LOCALE` flag is "
"used, matches characters considered alphanumeric in the current locale and "
"the underscore."
msgstr ""
"Corresponde a caracteres considerados alfanuméricos no conjunto de "
"caracteres ASCII; isso é equivalente a ``[a-zA-Z0-9_]``. Se o "
"sinalizador :py:const:`~re.LOCALE` for usado, corresponde aos caracteres "
"considerados alfanuméricos na localidade atual e o sublinhado."

#: ../../library/re.rst:655
msgid "``\\W``"
msgstr "``\\W``"

#: ../../library/re.rst:656
msgid ""
"Matches any character which is not a word character. This is the opposite of "
"``\\w``. By default, matches non-underscore (``_``) characters for "
"which :py:meth:`str.isalnum` returns ``False``."
msgstr ""
"Corresponde a qualquer caractere que não seja um caractere de palavra. Isso "
"é o oposto de ``\\w``. Por padrão, corresponde a caracteres que não são "
"sublinhados (``_``) para os quais :py:meth:`str.isalnum` retorna ``False``."

#: ../../library/re.rst:661
msgid "Matches ``[^a-zA-Z0-9_]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""
"Se o sinalizador :const:`~re.ASCII` for usado, apenas ``[^a-zA-Z0-9_]`` será "
"correspondido."

#: ../../library/re.rst:663
msgid ""
"If the :py:const:`~re.LOCALE` flag is used, matches characters which are "
"neither alphanumeric in the current locale nor the underscore."
msgstr ""
"Se o sinalizador :py:const:`~re.LOCALE` for usado, corresponde a caracteres "
"que não são alfanuméricos na localidade atual nem ao sublinhado."

#: ../../library/re.rst:669
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../library/re.rst:670
msgid "Matches only at the end of the string."
msgstr "Corresponde apenas ao final da string."

#: ../../library/re.rst:686
msgid ""
"Most of the :ref:`escape sequences <escape-sequences>` supported by Python "
"string literals are also accepted by the regular expression parser::"
msgstr ""
"A maioria das :ref:`sequências de escape <escape-sequences>` com suporte das "
"literais de string Python também são aceitos pelo analisador sintático de "
"expressão regular:"

#: ../../library/re.rst:689
msgid ""
"\\a      \\b      \\f      \\n\n"
"\\N      \\r      \\t      \\u\n"
"\\U      \\v      \\x      \\\\"
msgstr ""
"\\a      \\b      \\f      \\n\n"
"\\N      \\r      \\t      \\u\n"
"\\U      \\v      \\x      \\\\"

#: ../../library/re.rst:693
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr ""
"(Observe que ``\\b`` é usado para representar limites de palavras e "
"significa fazer \"backspace\" apenas dentro das classes de caracteres.)"

#: ../../library/re.rst:696
msgid ""
"``'\\u'``, ``'\\U'``, and ``'\\N'`` escape sequences are only recognized in "
"Unicode (str) patterns. In bytes patterns they are errors. Unknown escapes "
"of ASCII letters are reserved for future use and treated as errors."
msgstr ""
"As sequências de escape ``'\\u'``, ``'\\U'`` e ``'\\N'`` são reconhecidas "
"apenas em padrões Unicode (str). Em padrões de bytes, eles são erros. "
"Escapes desconhecidos de letras ASCII são reservados para uso futuro e "
"tratados como erros."

#: ../../library/re.rst:702
msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0, or "
"if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""
"Os escapes octais são incluídos em um formulário limitado. Se o primeiro "
"dígito for 0, ou se houver três dígitos octais, é considerado um escape "
"octal. Caso contrário, é uma referência de grupo. Quanto aos literais de "
"string, os escapes octais têm sempre no máximo três dígitos."

#: ../../library/re.rst:707
msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr "As sequências de escape ``'\\u'`` e ``'\\U'`` foram adicionadas."

#: ../../library/re.rst:710
msgid ""
"Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr ""
"Escapes desconhecidos consistindo em ``'\\'`` e uma letra ASCII agora são "
"erros."

#: ../../library/re.rst:713
msgid ""
"The :samp:`'\\\\N\\\\{{name}\\\\}'` escape sequence has been added. As in "
"string literals, it expands to the named Unicode character (e.g. ``'\\N{EM "
"DASH}'``)."
msgstr ""
"A sequência de escape :samp:`'\\\\N\\\\{{name}\\\\}'` foi adicionada. Como "
"em literais de string, ela se expande para o caractere Unicode nomeado (por "
"exemplo, ``'\\N{EM DASH}'``)."

#: ../../library/re.rst:721
msgid "Module Contents"
msgstr "Conteúdo do módulo"

#: ../../library/re.rst:723
msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr ""
"O módulo define várias funções, constantes e uma exceção. Algumas das "
"funções são versões simplificadas dos métodos completos para expressões "
"regulares compiladas. A maioria das aplicações não triviais sempre usa a "
"forma compilada."

#: ../../library/re.rst:730
msgid "Flags"
msgstr "Sinalizadores"

#: ../../library/re.rst:732
msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a subclass "
"of :class:`enum.IntFlag`."
msgstr ""
"Constantes de sinalizadores agora são instâncias de :class:`RegexFlag`, que "
"é uma subclasse de :class:`enum.IntFlag`."

#: ../../library/re.rst:739
msgid ""
"An :class:`enum.IntFlag` class containing the regex options listed below."
msgstr ""
"Uma subclasse de :class:`enum.IntFlag` contendo as opções de expressão "
"regular listadas abaixo."

#: ../../library/re.rst:741
msgid "- added to ``__all__``"
msgstr "- adicionada a ``__all__``"

#: ../../library/re.rst:746
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` perform ASCII-only matching instead of full Unicode matching.  This "
"is only meaningful for Unicode (str) patterns, and is ignored for bytes "
"patterns."
msgstr ""
"Faz com que ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` e "
"``\\S`` executem a correspondência somente ASCII em vez da correspondência "
"Unicode completa. Isso é significativo apenas para padrões Unicode (str) e é "
"ignorado para padrões de bytes."

#: ../../library/re.rst:750
msgid "Corresponds to the inline flag ``(?a)``."
msgstr "Corresponde ao sinalizador em linha ``(?a)``."

#: ../../library/re.rst:754
msgid ""
"The :py:const:`~re.U` flag still exists for backward compatibility, but is "
"redundant in Python 3 since matches are Unicode by default for ``str`` "
"patterns, and Unicode matching isn't allowed for bytes "
"patterns. :py:const:`~re.UNICODE` and the inline flag ``(?u)`` are similarly "
"redundant."
msgstr ""
"O sinalizador :py:const:`~re.U` ainda existe para compatibilidade com "
"versões anteriores, mas é redundante no Python 3, pois as correspondências "
"são feitas em Unicode por padrão para padrões de ``str`` e correspondência "
"Unicode não é permitida para padrões de \"bytes\". :py:const:`~re.UNICODE` e "
"o sinalizador em linha ``(?u)`` são igualmente redundantes."

#: ../../library/re.rst:763
msgid "Display debug information about compiled expression."
msgstr "Exibe informações de depuração sobre a expressão compilada."

#: ../../library/re.rst:765
msgid "No corresponding inline flag."
msgstr "Nenhum sinalizador em linha correspondente."

#: ../../library/re.rst:771
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also  "
"match lowercase letters. Full Unicode matching (such as ``Ü`` matching "
"``ü``) also works unless the :py:const:`~re.ASCII` flag is used to disable "
"non-ASCII matches. The current locale does not change the effect of this "
"flag unless the :py:const:`~re.LOCALE` flag is also used."
msgstr ""
"Executa uma correspondência que não diferencia maiúsculas de minúsculas; "
"expressões como ``[A-Z]`` também corresponderão a letras minúsculas. A "
"correspondência Unicode completa (como ``Ü`` correspondendo a ``ü``) também "
"funciona, a menos que o sinalizador :py:const:`~re.ASCII` seja usado para "
"desabilitar correspondências não ASCII. A localidade atual não muda o efeito "
"deste sinalizador a menos que o sinalizador :py:const:`~re.LOCALE` também "
"seja usado."

#: ../../library/re.rst:779
msgid "Corresponds to the inline flag ``(?i)``."
msgstr "Corresponde ao sinalizador em linha ``(?i)``."

#: ../../library/re.rst:781
msgid ""
"Note that when the Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in "
"combination with the :const:`IGNORECASE` flag, they will match the 52 ASCII "
"letters and 4 additional non-ASCII letters: 'İ' (U+0130, Latin capital "
"letter I with dot above), 'ı' (U+0131, Latin small letter dotless i), 'ſ' "
"(U+017F, Latin small letter long s) and 'K' (U+212A, Kelvin sign). If "
"the :py:const:`~re.ASCII` flag is used, only letters 'a' to 'z' and 'A' to "
"'Z' are matched."
msgstr ""
"Observe que quando os padrões Unicode ``[a-z]`` ou ``[A-Z]`` são usados em "
"combinação com o sinalizador :const:`IGNORECASE`, eles corresponderão às 52 "
"letras ASCII e 4 letras não-ASCII adicionais: 'İ' (U+0130, letra latina I "
"maiúscula com ponto em cima), 'ı' (U+0131, letra latina i minúscula sem "
"ponto), 'ſ' (U+017F, letra latina s minúscula longa) e 'K' (U+212A, sinal de "
"Kelvin). Se o sinalizador :const:`ASCII` for usado, apenas as letras 'a' a "
"'z' e 'A' a 'Z' serão correspondidas."

#: ../../library/re.rst:792
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale. This flag can be used only with bytes "
"patterns."
msgstr ""
"Faz com que ``\\w``, ``\\W``, ``\\b``, ``\\B`` e a correspondência sem "
"diferenciação de maiúsculas e minúsculas dependam da localidade atual. Esse "
"sinalizador só pode ser usado com padrões de bytes."

#: ../../library/re.rst:796
msgid "Corresponds to the inline flag ``(?L)``."
msgstr "Corresponde ao sinalizador em linha ``(?L)``."

#: ../../library/re.rst:800
msgid ""
"This flag is discouraged; consider Unicode matching instead. The locale "
"mechanism is very unreliable as it only handles one \"culture\" at a time "
"and only works with 8-bit locales. Unicode matching is enabled by default "
"for Unicode (str) patterns and it is able to handle different locales and "
"languages."
msgstr ""
"Este sinalizador é desencorajado; considere usar correspondência Unicode em "
"vez disso. O mecanismo de localidade é muito pouco confiável, pois só "
"manipula uma \"cultura\" por vez e só funciona com localidades de 8 bits. A "
"correspondência Unicode é habilitada por padrão para padrões Unicode (str) e "
"é capaz de manipular diferentes localidades e idiomas."

#: ../../library/re.rst:807
msgid ""
":py:const:`~re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :py:const:`~re.ASCII`."
msgstr ""
":py:const:`~re.LOCALE` pode ser usado apenas com padrões de bytes e não é "
"compatível com :const:`~re.ASCII`."

#: ../../library/re.rst:811
msgid ""
"Compiled regular expression objects with the :py:const:`~re.LOCALE` flag no "
"longer depend on the locale at compile time. Only the locale at matching "
"time affects the result of matching."
msgstr ""
"Objetos de expressão regular compilados com o "
"sinalizador :py:const:`~re.LOCALE` não dependem mais da localidade em tempo "
"de compilação. Apenas a localidade no momento da correspondência afeta o "
"resultado da correspondência."

#: ../../library/re.rst:820
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string "
"and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string."
msgstr ""
"Quando especificado, o caractere padrão ``'^'`` corresponde ao início da "
"string e ao início de cada linha (imediatamente após cada nova linha); e o "
"caractere padrão ``'$'`` corresponde ao final da string e ao final de cada "
"linha (imediatamente antes de cada nova linha). Por padrão, ``'^'`` "
"corresponde apenas no início da string, e ``'$'`` apenas no final da string "
"e imediatamente antes da nova linha (se houver) no final da string."

#: ../../library/re.rst:827
msgid "Corresponds to the inline flag ``(?m)``."
msgstr "Corresponde ao sinalizador em linha ``(?m)``."

#: ../../library/re.rst:831
msgid ""
"Indicates no flag being applied, the value is ``0``.  This flag may be used "
"as a default value for a function keyword argument or as a base value that "
"will be conditionally ORed with other flags.  Example of use as a default "
"value::"
msgstr ""
"Indica que nenhum sinalizador está sendo aplicado, o valor é ``0``. Este "
"sinalizador pode ser usado como um valor padrão para um argumento nomeado de "
"função ou como um valor base que será condicionalmente OU com outros "
"sinalizadores. Exemplo de uso como valor padrão::"

#: ../../library/re.rst:836
msgid ""
"def myfunc(text, flag=re.NOFLAG):\n"
"    return re.match(text, flag)"
msgstr ""
"def minha_funcao(texto, sinalizador=re.NOFLAG):\n"
"    return re.match(texto, sinalizador)"

#: ../../library/re.rst:844
msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr ""
"Faz o caractere especial ``'.'`` corresponder com qualquer caractere que "
"seja, incluindo uma nova linha; sem este sinalizador, ``'.'`` irá "
"corresponder a qualquer coisa, *exceto* uma nova linha."

#: ../../library/re.rst:847
msgid "Corresponds to the inline flag ``(?s)``."
msgstr "Corresponde ao sinalizador em linha ``(?s)``."

#: ../../library/re.rst:853
msgid ""
"In Python 3, Unicode characters are matched by default for ``str`` patterns. "
"This flag is therefore redundant with **no effect** and is only kept for "
"backward compatibility."
msgstr ""
"Em Python 3, os caracteres Unicode são correspondidos por padrão para "
"padrões ``str``. Esse sinalizador é, portanto, redundante e **sem efeito**, "
"sendo mantido apenas para compatibilidade com versões anteriores."

#: ../../library/re.rst:858
msgid ""
"See :py:const:`~re.ASCII` to restrict matching to ASCII characters instead."
msgstr ""
"Veja :py:const:`~re.ASCII` para restringir a correspondência apenas a "
"caracteres ASCII."

#: ../../library/re.rst:865
msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class, or when preceded by an unescaped backslash, or "
"within tokens like ``*?``, ``(?:`` or ``(?P<...>``. For example, ``(? :`` "
"and ``* ?`` are not allowed. When a line contains a ``#`` that is not in a "
"character class and is not preceded by an unescaped backslash, all "
"characters from the leftmost such ``#`` through the end of the line are "
"ignored."
msgstr ""
"Este sinalizador permite que você escreva expressões regulares que parecem "
"mais agradáveis e são mais legíveis, permitindo que você separe visualmente "
"seções lógicas do padrão e adicione comentários. O espaço em branco dentro "
"do padrão é ignorado, exceto quando em uma classe de caractere, ou quando "
"precedido por uma contrabarra sem escape, ou dentro de tokens como ``*?``, "
"``(?:`` ou ``(?P<...>``. Por exemplo, ``(? :`` e ``* ?`` não são permitidos. "
"Quando uma linha contém um ``#`` que não está em uma classe de caractere e "
"não é precedido por uma contrabarra sem escape, todos os caracteres a partir "
"do ``#`` mais à esquerda até o final da linha são ignorados."

#: ../../library/re.rst:875
msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr ""
"Isso significa que os dois seguintes objetos expressão regular que "
"correspondem a um número decimal são funcionalmente iguais::"

#: ../../library/re.rst:878
msgid ""
"a = re.compile(r\"\"\"\\d +  # the integral part\n"
"                   \\.    # the decimal point\n"
"                   \\d *  # some fractional digits\"\"\", re.X)\n"
"b = re.compile(r\"\\d+\\.\\d*\")"
msgstr ""
"a = re.compile(r\"\"\"\\d +  # a parte inteira\n"
"                   \\.    # o ponto decimal\n"
"                   \\d *  # alguns digitos fracionários\"\"\", re.X)\n"
"b = re.compile(r\"\\d+\\.\\d*\")"

#: ../../library/re.rst:883
msgid "Corresponds to the inline flag ``(?x)``."
msgstr "Corresponde ao sinalizador em linha ``(?x)``."

#: ../../library/re.rst:887
msgid "Functions"
msgstr "Funções"

#: ../../library/re.rst:891
msgid ""
"Compile a regular expression pattern into a :ref:`regular expression object "
"<re-objects>`, which can be used for matching using "
"its :func:`~Pattern.match`, :func:`~Pattern.search` and other methods, "
"described below."
msgstr ""
"Compila um padrão de expressão regular em um :ref:`objeto expressão regular "
"<re-objects>`, que pode ser usado para correspondência usando "
"seu :func:`~Pattern.match`, :func:`~Pattern.search` e outros métodos, "
"descritos abaixo."

#: ../../library/re.rst:896 ../../library/re.rst:928 ../../library/re.rst:946
#: ../../library/re.rst:957 ../../library/re.rst:1003 ../../library/re.rst:1037
#: ../../library/re.rst:1052 ../../library/re.rst:1111
#: ../../library/re.rst:1147
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the `flags`_ variables, combined using bitwise OR (the "
"``|`` operator)."
msgstr ""
"O comportamento da expressão pode ser modificado especificando um valor para "
"o parâmetro *flags*. Os valores podem ser qualquer um dos `sinalizadores`_, "
"combinados usando OU bit a bit (o operador ``|``)."

#: ../../library/re.rst:900
msgid "The sequence ::"
msgstr "A sequência ::"

#: ../../library/re.rst:902
msgid ""
"prog = re.compile(pattern)\n"
"result = prog.match(string)"
msgstr ""
"prog = re.compile(pattern)\n"
"result = prog.match(string)"

#: ../../library/re.rst:905
msgid "is equivalent to ::"
msgstr "é equivalente a ::"

#: ../../library/re.rst:907
msgid "result = re.match(pattern, string)"
msgstr "result = re.match(pattern, string)"

#: ../../library/re.rst:909
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr ""
"mas usar :func:`re.compile` e salvar o objeto expressão regular resultante "
"para reutilização é mais eficiente quando a expressão será usada várias "
"vezes em um único programa."

#: ../../library/re.rst:915
msgid ""
"The compiled versions of the most recent patterns passed "
"to :func:`re.compile` and the module-level matching functions are cached, so "
"programs that use only a few regular expressions at a time needn't worry "
"about compiling regular expressions."
msgstr ""
"As versões compiladas dos padrões mais recentes passados "
"para :func:`re.compile` e as funções de correspondência em nível de módulo "
"são armazenadas em cache, de modo que programas que usam apenas algumas "
"expressões regulares por vez não precisam se preocupar em compilar "
"expressões regulares."

#: ../../library/re.rst:923
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a "
"corresponding :class:`~re.Match`. Return ``None`` if no position in the "
"string matches the pattern; note that this is different from finding a zero-"
"length match at some point in the string."
msgstr ""
"Percorre a *string* procurando o primeiro local onde o padrão *pattern* de "
"expressão regular produz uma correspondência e retorna um :class:`~re.Match` "
"correspondente. Retorna ``None`` se nenhuma posição na string corresponder "
"ao padrão; observe que isso é diferente de encontrar uma correspondência de "
"comprimento zero em algum ponto da string."

#: ../../library/re.rst:935
msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :class:`~re.Match`.  Return "
"``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""
"Se zero ou mais caracteres no início da *string* corresponderem ao padrão "
"*pattern* da expressão regular, retorna um :class:`~re.Match` "
"correspondente. Retorna ``None`` se a string não corresponder ao padrão; "
"observe que isso é diferente de uma correspondência de comprimento zero."

#: ../../library/re.rst:940
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr ""
"Observe que mesmo no modo :const:`MULTILINE`, :func:`re.match` irá "
"corresponder apenas no início da string e não no início de cada linha."

#: ../../library/re.rst:943
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""
"Se você quiser localizar uma correspondência em qualquer lugar em *string*, "
"use :func:`search` (veja também :ref:`search-vs-match`)."

#: ../../library/re.rst:953
msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :class:`~re.Match`.  Return ``None`` if the string does not "
"match the pattern; note that this is different from a zero-length match."
msgstr ""
"Se toda a *string* corresponder ao padrão *pattern* da expressão regular, "
"retorna um :class:`~re.Match` correspondente. Retorna ``None`` se a string "
"não corresponder ao padrão; observe que isso é diferente de uma "
"correspondência de comprimento zero."

#: ../../library/re.rst:966
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list. ::"
msgstr ""
"Divide a *string* pelas ocorrências do padrão *pattern*. Se parênteses de "
"captura forem usados em *pattern*, o texto de todos os grupos no padrão "
"também será retornado como parte da lista resultante. Se *maxsplit* for "
"diferente de zero, no máximo *maxsplit* divisões ocorrerão e o restante da "
"string será retornado como o elemento final da lista. ::"

#: ../../library/re.rst:972
msgid ""
">>> re.split(r'\\W+', 'Words, words, words.')\n"
"['Words', 'words', 'words', '']\n"
">>> re.split(r'(\\W+)', 'Words, words, words.')\n"
"['Words', ', ', 'words', ', ', 'words', '.', '']\n"
">>> re.split(r'\\W+', 'Words, words, words.', maxsplit=1)\n"
"['Words', 'words, words.']\n"
">>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE)\n"
"['0', '3', '9']"
msgstr ""
">>> re.split(r'\\W+', 'Palavras, palavras, palavras.')\n"
"['Palavras', 'palavras', 'palavras', '']\n"
">>> re.split(r'(\\W+)', 'Palavras, palavras, palavras.')\n"
"['Palavras', ', ', 'palavras', ', ', 'palavras', '.', '']\n"
">>> re.split(r'\\W+', 'Palavras, palavras, palavras.', maxsplit=1)\n"
"['Palavras', 'palavras, palavras.']\n"
">>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE)\n"
"['0', '3', '9']"

#: ../../library/re.rst:981
msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string::"
msgstr ""
"Se houver grupos de captura no separador e ele corresponder ao início da "
"string, o resultado começará com uma string vazia. O mesmo vale para o final "
"da string::"

#: ../../library/re.rst:985
msgid ""
">>> re.split(r'(\\W+)', '...words, words...')\n"
"['', '...', 'words', ', ', 'words', '...', '']"
msgstr ""
">>> re.split(r'(\\W+)', '...palavras, palavras...')\n"
"['', '...', 'palavras', ', ', 'palavras', '...', '']"

#: ../../library/re.rst:988
msgid ""
"That way, separator components are always found at the same relative indices "
"within the result list."
msgstr ""
"Dessa forma, os componentes do separador são sempre encontrados nos mesmos "
"índices relativos na lista de resultados."

#: ../../library/re.rst:991
msgid ""
"Empty matches for the pattern split the string only when not adjacent to a "
"previous empty match."
msgstr ""
"As correspondências vazias para o padrão dividem a string apenas quando não "
"adjacente a uma correspondência vazia anterior."

#: ../../library/re.rst:994
msgid ""
">>> re.split(r'\\b', 'Words, words, words.')\n"
"['', 'Words', ', ', 'words', ', ', 'words', '.']\n"
">>> re.split(r'\\W*', '...words...')\n"
"['', '', 'w', 'o', 'r', 'd', 's', '', '']\n"
">>> re.split(r'(\\W*)', '...words...')\n"
"['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', "
"'']"
msgstr ""
">>> re.split(r'\\b', 'Palavras, palavras, palavras.')\n"
"['', 'Palavras', ', ', 'palavras', ', ', 'palavras', '.']\n"
">>> re.split(r'\\W*', '...palavras...')\n"
"['', '', 'p', 'a', 'l', 'a', 'v', 'r', 'a', 's', '', '']\n"
">>> re.split(r'(\\W*)', '...palavras...')\n"
"['', '...', '', '', 'p', '', 'a', '', 'l', '', 'a', '', 'v', '', 'r', '', "
"'a', '', 's', '...', '', '', '']"

#: ../../library/re.rst:1007 ../../library/re.rst:1115
msgid "Added the optional flags argument."
msgstr "Adicionado o argumento de sinalizadores opcionais."

#: ../../library/re.rst:1010
msgid ""
"Added support of splitting on a pattern that could match an empty string."
msgstr ""
"Adicionado suporte de divisão em um padrão que pode corresponder a uma "
"string vazia."

#: ../../library/re.rst:1013
msgid ""
"Passing *maxsplit* and *flags* as positional arguments is deprecated. In "
"future Python versions they will be :ref:`keyword-only parameters <keyword-"
"only_parameter>`."
msgstr ""
"Passar *maxsplit* e *flags* como argumentos posicionais foi descontinuado. "
"Nas versões futuras do Python eles serão :ref:`parâmetros somente-nomeados "
"<keyword-only_parameter>`."

#: ../../library/re.rst:1021
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings or tuples.  The *string* is scanned left-to-right, and matches are "
"returned in the order found.  Empty matches are included in the result."
msgstr ""
"Retorna todas as correspondências não sobrepostas do padrão *pattern* em "
"*string*, como uma lista de strings ou tuplas. A *string* é verificada da "
"esquerda para a direita e as correspondências são retornadas na ordem "
"encontrada. Correspondências vazias são incluídas no resultado."

#: ../../library/re.rst:1025
msgid ""
"The result depends on the number of capturing groups in the pattern. If "
"there are no groups, return a list of strings matching the whole pattern.  "
"If there is exactly one group, return a list of strings matching that "
"group.  If multiple groups are present, return a list of tuples of strings "
"matching the groups.  Non-capturing groups do not affect the form of the "
"result."
msgstr ""
"O resultado depende do número de grupos de captura no padrão. Se não houver "
"grupos, retorna uma lista de strings que correspondem a todo o padrão. Se "
"houver exatamente um grupo, retorna uma lista de strings correspondentes a "
"esse grupo. Se vários grupos estiverem presentes, retorna uma lista de "
"tuplas de strings correspondentes aos grupos. Grupos sem captura não afetam "
"a forma do resultado."

#: ../../library/re.rst:1041 ../../library/re.rst:1056
msgid "Non-empty matches can now start just after a previous empty match."
msgstr ""
"Correspondências não vazias agora podem começar logo após uma "
"correspondência vazia anterior."

#: ../../library/re.rst:1047
msgid ""
"Return an :term:`iterator` yielding :class:`~re.Match` objects over all non-"
"overlapping matches for the RE *pattern* in *string*.  The *string* is "
"scanned left-to-right, and matches are returned in the order found.  Empty "
"matches are included in the result."
msgstr ""
"Retorna um :term:`iterador` produzindo objetos :class:`~re.Match` sobre "
"todas as correspondências não sobrepostas para o padrão *pattern* em "
"*string*. A *string* é percorrida da esquerda para a direita e as "
"correspondências são retornadas na ordem encontrada. Correspondências vazias "
"são incluídas no resultado."

#: ../../library/re.rst:1062
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string "
"or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a carriage return, and so forth.  Unknown escapes of "
"ASCII letters are reserved for future use and treated as errors.  Other "
"unknown escapes such as ``\\&`` are left alone. Backreferences, such as "
"``\\6``, are replaced with the substring matched by group 6 in the pattern. "
"For example::"
msgstr ""
"Retorna a string obtida substituindo as ocorrências não sobrepostas da "
"extremidade esquerda do padrão *pattern* na *string* pela substituição "
"*repl*. Se o padrão não for encontrado, *string* será retornado inalterado. "
"*repl* pode ser uma string ou uma função; se for uma string, qualquer escape "
"de contrabarra será processado. Ou seja, ``\\n`` é convertido em um único "
"caractere de nova linha, ``\\r`` é convertido em um retorno de carro e assim "
"por diante. Escapes desconhecidos de letras ASCII são reservados para uso "
"futuro e tratados como erros. Outros escapes desconhecidos como ``\\&`` são "
"deixados como estão. Referências anteriores, como ``\\6``, são substituídos "
"pela substring correspondida pelo grupo 6 no padrão. Por exemplo::"

#: ../../library/re.rst:1073
msgid ""
">>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):',\n"
"...        r'static PyObject*\\npy_\\1(void)\\n{',\n"
"...        'def myfunc():')\n"
"'static PyObject*\\npy_myfunc(void)\\n{'"
msgstr ""
">>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):',\n"
"...        r'static PyObject*\\npy_\\1(void)\\n{',\n"
"...        'def myfunc():')\n"
"'static PyObject*\\npy_myfunc(void)\\n{'"

#: ../../library/re.rst:1078
msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single :class:`~re.Match` argument, and "
"returns the replacement string.  For example::"
msgstr ""
"Se *repl* for uma função, ela será chamada para cada ocorrência não "
"sobreposta do padrão *pattern*. A função recebe um único "
"argumento :class:`~re.Match` e retorna a string de substituição. Por "
"exemplo::"

#: ../../library/re.rst:1082
msgid ""
">>> def dashrepl(matchobj):\n"
"...     if matchobj.group(0) == '-': return ' '\n"
"...     else: return '-'\n"
"...\n"
">>> re.sub('-{1,2}', dashrepl, 'pro----gram-files')\n"
"'pro--gram files'\n"
">>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', "
"flags=re.IGNORECASE)\n"
"'Baked Beans & Spam'"
msgstr ""
">>> def dashrepl(matchobj):\n"
"...     if matchobj.group(0) == '-': return ' '\n"
"...     else: return '-'\n"
"...\n"
">>> re.sub('-{1,2}', dashrepl, 'arquivos-de-pro----grama')\n"
"'arquivos de pro--grama'\n"
">>> re.sub(r'\\sE\\s', ' & ', 'Feijões queimados e spam', "
"flags=re.IGNORECASE)\n"
"'Feijões queimados & spam'"

#: ../../library/re.rst:1091
msgid "The pattern may be a string or a :class:`~re.Pattern`."
msgstr "O padrão pode ser uma string ou um :class:`~re.Pattern`."

#: ../../library/re.rst:1093
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero, "
"all occurrences will be replaced. Empty matches for the pattern are replaced "
"only when not adjacent to a previous empty match, so ``sub('x*', '-', "
"'abxd')`` returns ``'-a-b--d-'``."
msgstr ""
"O argumento opcional *count* é o número máximo de ocorrências de padrão a "
"serem substituídas; *count* deve ser um número inteiro não negativo. Se "
"omitido ou zero, todas as ocorrências serão substituídas. As "
"correspondências vazias para o padrão são substituídas apenas quando não "
"adjacentes a uma correspondência vazia anterior, então ``sub('x*', '-', "
"'abxd')`` retorna ``'-a-b--d-'``."

#: ../../library/re.rst:1101
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched "
"by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. "
"``\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore "
"equivalent to ``\\2``, but isn't ambiguous in a replacement such as "
"``\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not "
"a reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr ""
"Em argumentos *repl* do tipo string, além dos escapes de caractere e "
"referências anteriores descritas acima, ``\\g<nome>`` usará a substring "
"correspondida pelo grupo denominado ``nome``, conforme definido pela sintaxe "
"``(?P<nome>...)``. ``\\g<número>`` usa o número do grupo correspondente; "
"``\\g<2>`` é portanto equivalente a ``\\2``, mas não é ambíguo em uma "
"substituição como ``\\g<2>0``. ``\\20`` seria interpretado como uma "
"referência ao grupo 20, não uma referência ao grupo 2 seguida pelo caractere "
"literal ``'0'``. A referência anterior ``\\g6`` substitui em toda a "
"substring correspondida pela ER."

#: ../../library/re.rst:1118 ../../library/re.rst:1396
msgid "Unmatched groups are replaced with an empty string."
msgstr "Grupos sem correspondência são substituídos por uma string vazia."

#: ../../library/re.rst:1121
msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter now "
"are errors."
msgstr ""
"Escapes desconhecidos no padrão *pattern* consistindo em ``'\\'`` e uma "
"letra ASCII agora são erros."

#: ../../library/re.rst:1125
msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now are "
"errors. Empty matches for the pattern are replaced when adjacent to a "
"previous non-empty match."
msgstr ""
"Escapes desconhecidos em *repl* consistindo em ``'\\'`` e uma letra ASCII "
"agora são erros. As correspondências vazias do padrão são substituídas "
"quando adjacentes a uma correspondência não vazia anterior."

#: ../../library/re.rst:1131
msgid ""
"Group *id* can only contain ASCII digits. In :class:`bytes` replacement "
"strings, group *name* can only contain bytes in the ASCII range "
"(``b'\\x00'``-``b'\\x7f'``)."
msgstr ""
"O grupo *id* só pode conter dígitos ASCII. Nas strings de "
"substituição :class:`bytes`, o grupo *name* só pode conter bytes no "
"intervalo ASCII (``b'\\x00'``-``b'\\x7f'``)."

#: ../../library/re.rst:1136
msgid ""
"Passing *count* and *flags* as positional arguments is deprecated. In future "
"Python versions they will be :ref:`keyword-only parameters <keyword-"
"only_parameter>`."
msgstr ""
"Passar *count* e *flags* como argumentos posicionais foi descontinuado. Nas "
"versões futuras do Python eles serão :ref:`parâmetros somente-nomeados "
"<keyword-only_parameter>`."

#: ../../library/re.rst:1144
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string, "
"number_of_subs_made)``."
msgstr ""
"Executa a mesma operação que :func:`sub`, mas retorna uma tupla "
"``(nova_string, número_de_substituições_feitas)``."

#: ../../library/re.rst:1154
msgid ""
"Escape special characters in *pattern*. This is useful if you want to match "
"an arbitrary literal string that may have regular expression metacharacters "
"in it.  For example::"
msgstr ""
"Escapa caracteres especiais no padrão *pattern*. Isso é útil se você deseja "
"corresponder uma string literal arbitrária que pode conter metacaracteres de "
"expressão regular. Por exemplo::"

#: ../../library/re.rst:1158
msgid ""
">>> print(re.escape('https://www.python.org'))\n"
"https://www\\.python\\.org\n"
"\n"
">>> legal_chars = string.ascii_lowercase + string.digits + \"!#$%&'*+-.^_`|~:"
"\"\n"
">>> print('[%s]+' % re.escape(legal_chars))\n"
"[abcdefghijklmnopqrstuvwxyz0123456789!\\#\\$%\\&'\\*\\+\\-\\.\\^_`\\|\\~:]+\n"
"\n"
">>> operators = ['+', '-', '*', '/', '**']\n"
">>> print('|'.join(map(re.escape, sorted(operators, reverse=True))))\n"
"/|\\-|\\+|\\*\\*|\\*"
msgstr ""
">>> print(re.escape('https://www.python.org'))\n"
"https://www\\.python\\.org\n"
"\n"
">>> legal_chars = string.ascii_lowercase + string.digits + \"!#$%&'*+-.^_`|~:"
"\"\n"
">>> print('[%s]+' % re.escape(legal_chars))\n"
"[abcdefghijklmnopqrstuvwxyz0123456789!\\#\\$%\\&'\\*\\+\\-\\.\\^_`\\|\\~:]+\n"
"\n"
">>> operators = ['+', '-', '*', '/', '**']\n"
">>> print('|'.join(map(re.escape, sorted(operators, reverse=True))))\n"
"/|\\-|\\+|\\*\\*|\\*"

#: ../../library/re.rst:1169
msgid ""
"This function must not be used for the replacement string in :func:`sub` "
"and :func:`subn`, only backslashes should be escaped.  For example::"
msgstr ""
"Esta função não deve ser usada para a string de substituição em :func:`sub` "
"e :func:`subn`, apenas contrabarras devem ser escapadas. Por exemplo::"

#: ../../library/re.rst:1172
msgid ""
">>> digits_re = r'\\d+'\n"
">>> sample = '/usr/sbin/sendmail - 0 errors, 12 warnings'\n"
">>> print(re.sub(digits_re, digits_re.replace('\\\\', r'\\\\'), sample))\n"
"/usr/sbin/sendmail - \\d+ errors, \\d+ warnings"
msgstr ""
">>> digits_re = r'\\d+'\n"
">>> sample = '/usr/sbin/sendmail - 0 errors, 12 warnings'\n"
">>> print(re.sub(digits_re, digits_re.replace('\\\\', r'\\\\'), sample))\n"
"/usr/sbin/sendmail - \\d+ errors, \\d+ warnings"

#: ../../library/re.rst:1177
msgid "The ``'_'`` character is no longer escaped."
msgstr "O caractere ``'_'`` não é mais escapado."

#: ../../library/re.rst:1180
msgid ""
"Only characters that can have special meaning in a regular expression are "
"escaped. As a result, ``'!'``, ``'\"'``, ``'%'``, ``\"'\"``, ``','``, "
"``'/'``, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``, ``'@'``, and ``\"`\"`` "
"are no longer escaped."
msgstr ""
"Somente caracteres que podem ter um significado especial em uma expressão "
"regular são escapados. Como resultado, ``'!'``, ``'\"'``, ``'%'``, "
"``\"'\"``, ``','``, ``'/'``, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``, "
"``'@'``, e ``\"`\"`` não são mais escapados."

#: ../../library/re.rst:1189
msgid "Clear the regular expression cache."
msgstr "Limpa o cache da expressão regular."

#: ../../library/re.rst:1193
msgid "Exceptions"
msgstr "Exceções"

#: ../../library/re.rst:1197
msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or "
"matching.  It is never an error if a string contains no match for a "
"pattern.  The ``PatternError`` instance has the following additional "
"attributes:"
msgstr ""
"Exceção levantada quando uma string passada para uma das funções desde "
"módulo não é uma expressão regular válida (por exemplo, ela pode conter "
"parênteses não correspondentes) ou quando algum outro erro ocorre durante a "
"compilação ou correspondência. Nunca é um erro se uma string não contém "
"correspondência para um padrão. A instância de ``PatternError`` possui os "
"seguintes atributos adicionais:"

#: ../../library/re.rst:1205
msgid "The unformatted error message."
msgstr "A mensagem de erro não formatada."

#: ../../library/re.rst:1209
msgid "The regular expression pattern."
msgstr "O padrão da expressão regular."

#: ../../library/re.rst:1213
msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr ""
"O índice no padrão *pattern* no qual a compilação falhou (pode ser ``None``)."

#: ../../library/re.rst:1217
msgid "The line corresponding to *pos* (may be ``None``)."
msgstr "A linha correspondente a *pos* (pode ser ``None``)."

#: ../../library/re.rst:1221
msgid "The column corresponding to *pos* (may be ``None``)."
msgstr "A coluna correspondente a *pos* (pode ser ``None``)."

#: ../../library/re.rst:1223
msgid "Added additional attributes."
msgstr "Adicionados os atributos adicionais."

#: ../../library/re.rst:1226
msgid ""
"``PatternError`` was originally named ``error``; the latter is kept as an "
"alias for backward compatibility."
msgstr ""
"``PatternError`` era originalmente chamado de ``error``; o último é mantido "
"como um apelido para compatibilidade com versões anteriores."

#: ../../library/re.rst:1233
msgid "Regular Expression Objects"
msgstr "Objetos expressão regular"

#: ../../library/re.rst:1237
msgid "Compiled regular expression object returned by :func:`re.compile`."
msgstr "Objeto expressão regular compilado retornado por :func:`re.compile`."

#: ../../library/re.rst:1239
msgid ""
":py:class:`re.Pattern` supports ``[]`` to indicate a Unicode (str) or bytes "
"pattern. See :ref:`types-genericalias`."
msgstr ""
":py:class:`re.Pattern` tem suporte a ``[]`` para indicar um padrão Unicode "
"(str) ou bytes. Veja :ref:`types-genericalias`."

#: ../../library/re.rst:1245
msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding :class:`~re.Match`. "
"Return ``None`` if no position in the string matches the pattern; note that "
"this is different from finding a zero-length match at some point in the "
"string."
msgstr ""
"Percorre a *string* procurando o primeiro local onde esta expressão regular "
"produz uma correspondência e retorna um :class:`~re.Match` correspondente. "
"Retorna ``None`` se nenhuma posição na string corresponder ao padrão; "
"observe que isso é diferente de encontrar uma correspondência de comprimento "
"zero em algum ponto da string."

#: ../../library/re.rst:1250
msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent "
"to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""
"O segundo parâmetro opcional *pos* fornece um índice na string onde a "
"pesquisa deve começar; o padrão é ``0``. Isso não é totalmente equivalente a "
"fatiar a string; o caractere padrão ``'^'`` corresponde no início real da "
"string e nas posições logo após uma nova linha, mas não necessariamente no "
"índice onde a pesquisa deve começar."

#: ../../library/re.rst:1256
msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found; otherwise, if *rx* is a "
"compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``. ::"
msgstr ""
"O parâmetro opcional *endpos* limita o quão longe a string será pesquisada; "
"será como se a string tivesse *endpos* caracteres, então apenas os "
"caracteres de *pos* a ``endpos - 1`` serão procurados por uma "
"correspondência. Se *endpos* for menor que *pos*, nenhuma correspondência "
"será encontrada; caso contrário, se *rx* é um objeto de expressão regular "
"compilado, ``rx.search(string, 0, 50)`` é equivalente a "
"``rx.search(string[:50], 0)``. ::"

#: ../../library/re.rst:1263
msgid ""
">>> pattern = re.compile(\"d\")\n"
">>> pattern.search(\"dog\")     # Match at index 0\n"
"<re.Match object; span=(0, 1), match='d'>\n"
">>> pattern.search(\"dog\", 1)  # No match; search doesn't include the \"d\""
msgstr ""
">>> pattern = re.compile(\"d\")\n"
">>> pattern.search(\"dog\")     # Correspondeu no índice 0\n"
"<re.Match object; span=(0, 1), match='d'>\n"
">>> pattern.search(\"dog\", 1)  # Não correspondeu; a busca não inclui \"d\""

#: ../../library/re.rst:1271
msgid ""
"If zero or more characters at the *beginning* of *string* match this regular "
"expression, return a corresponding :class:`~re.Match`. Return ``None`` if "
"the string does not match the pattern; note that this is different from a "
"zero-length match."
msgstr ""
"Se zero ou mais caracteres no início da *string* corresponderem a esta "
"expressão regular, retorna um :class:`~re.Match` correspondente. Retorna "
"``None`` se a string não corresponder ao padrão; observe que isso é "
"diferente de uma correspondência de comprimento zero."

#: ../../library/re.rst:1276 ../../library/re.rst:1294
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for "
"the :meth:`~Pattern.search` method. ::"
msgstr ""
"Os parâmetros opcionais *pos* e *endpos* têm o mesmo significado que para o "
"método :meth:`~Pattern.search`. ::"

#: ../../library/re.rst:1279
msgid ""
">>> pattern = re.compile(\"o\")\n"
">>> pattern.match(\"dog\")      # No match as \"o\" is not at the start of "
"\"dog\".\n"
">>> pattern.match(\"dog\", 1)   # Match as \"o\" is the 2nd character of "
"\"dog\".\n"
"<re.Match object; span=(1, 2), match='o'>"
msgstr ""
">>> pattern = re.compile(\"o\")\n"
">>> pattern.match(\"dog\")      # Não correspondeu, pois \"o\" não é o "
"início de \"dog\".\n"
">>> pattern.match(\"dog\", 1)   # Correspondeu, pois \"o\" é o 2º caractere "
"de \"dog\".\n"
"<re.Match object; span=(1, 2), match='o'>"

#: ../../library/re.rst:1284
msgid ""
"If you want to locate a match anywhere in *string*, "
"use :meth:`~Pattern.search` instead (see also :ref:`search-vs-match`)."
msgstr ""
"Se você quiser localizar uma correspondência em qualquer lugar em *string*, "
"use :meth:`~Pattern.search` ao invés (veja também :ref:`search-vs-match`)."

#: ../../library/re.rst:1290
msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :class:`~re.Match`.  Return ``None`` if the string does not "
"match the pattern; note that this is different from a zero-length match."
msgstr ""
"Se toda a *string* corresponder a esta expressão regular, retorna "
"um :class:`~re.Match` correspondente. Retorna ``None`` se a string não "
"corresponder ao padrão; observe que isso é diferente de uma correspondência "
"de comprimento zero."

#: ../../library/re.rst:1297
msgid ""
">>> pattern = re.compile(\"o[gh]\")\n"
">>> pattern.fullmatch(\"dog\")      # No match as \"o\" is not at the start "
"of \"dog\".\n"
">>> pattern.fullmatch(\"ogre\")     # No match as not the full string "
"matches.\n"
">>> pattern.fullmatch(\"doggie\", 1, 3)   # Matches within given limits.\n"
"<re.Match object; span=(1, 3), match='og'>"
msgstr ""
">>> pattern = re.compile(\"o[gh]\")\n"
">>> pattern.fullmatch(\"dog\")      # Não correspondeu, pois \"o\" não é o "
"início de \"dog\".\n"
">>> pattern.fullmatch(\"ogre\")     # Não correspondeu, pois não é uma "
"correspondência da string inteira.\n"
">>> pattern.fullmatch(\"doggie\", 1, 3)   # Corresponde dentro dos limites "
"dados.\n"
"<re.Match object; span=(1, 3), match='og'>"

#: ../../library/re.rst:1308
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr "Idêntico à função :func:`split`, usando o padrão compilado."

#: ../../library/re.rst:1313
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
"Semelhante à função :func:`findall`, usando o padrão compilado, mas também "
"aceita os parâmetros *pos* e *endpos* opcionais que limitam a região de "
"pesquisa como para :meth:`search`."

#: ../../library/re.rst:1320
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
"Semelhante à função :func:`finditer`, usando o padrão compilado, mas também "
"aceita os parâmetros *pos* e *endpos* opcionais que limitam a região de "
"pesquisa como para :meth:`search`."

#: ../../library/re.rst:1327
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr "Idêntico à função :func:`sub`, usando o padrão compilado."

#: ../../library/re.rst:1332
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr "Idêntico à função :func:`subn`, usando o padrão compilado."

#: ../../library/re.rst:1337
msgid ""
"The regex matching flags.  This is a combination of the flags given "
"to :func:`.compile`, any ``(?...)`` inline flags in the pattern, and "
"implicit flags such as :py:const:`~re.UNICODE` if the pattern is a Unicode "
"string."
msgstr ""
"Os sinalizadores de correspondência de expressões regulares. Esta é uma "
"combinação dos sinalizadores fornecidos para :func:`.compile`, qualquer  "
"sinalizador em linha ``(?...)`` no padrão e sinalizadores implícitos "
"como :py:const:`~re.UNICODE` se o padrão for uma string Unicode."

#: ../../library/re.rst:1344
msgid "The number of capturing groups in the pattern."
msgstr "O número de grupos de captura no padrão."

#: ../../library/re.rst:1349
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr ""
"Um dicionário que mapeia qualquer nome de grupo simbólico definido por ``(?"
"P<id>)`` para números de grupo. O dicionário estará vazio se nenhum grupo "
"simbólico for usado no padrão."

#: ../../library/re.rst:1356
msgid "The pattern string from which the pattern object was compiled."
msgstr "A string de padrão da qual o objeto de padrão foi compilado."

#: ../../library/re.rst:1359
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Compiled "
"regular expression objects are considered atomic."
msgstr ""
"Adicionado suporte de :func:`copy.copy` e :func:`copy.deepcopy`. Os objetos "
"expressão regular compilados são considerados atômicos."

#: ../../library/re.rst:1367
msgid "Match Objects"
msgstr "Objetos correspondência"

#: ../../library/re.rst:1369
msgid ""
"Match objects always have a boolean value of ``True``. "
"Since :meth:`~Pattern.match` and :meth:`~Pattern.search` return ``None`` "
"when there is no match, you can test whether there was a match with a simple "
"``if`` statement::"
msgstr ""
"Objetos correspondência sempre têm um valor booleano de ``True``. "
"Como :meth:`~Pattern.match` e :meth:`~Pattern.search` retornam ``None`` "
"quando não há correspondência, você pode testar se houve uma correspondência "
"com uma simples instrução ``if``::"

#: ../../library/re.rst:1374
msgid ""
"match = re.search(pattern, string)\n"
"if match:\n"
"    process(match)"
msgstr ""
"match = re.search(pattern, string)\n"
"if match:\n"
"    process(match)"

#: ../../library/re.rst:1380
msgid "Match object returned by successful ``match``\\ es and ``search``\\ es."
msgstr ""
"Objeto correspondência retornado por ``match``\\ s e ``search``\\ s bem "
"sucedidos."

#: ../../library/re.rst:1382
msgid ""
":py:class:`re.Match` supports ``[]`` to indicate a Unicode (str) or bytes "
"match. See :ref:`types-genericalias`."
msgstr ""
":py:class:`re.Match` tem suporte a ``[]`` para indicar uma correspondência "
"Unicode (str) ou bytes. Veja :ref:`types-genericalias`."

#: ../../library/re.rst:1388
msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~Pattern.sub` method. Escapes such "
"as ``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, "
"``\\g<name>``) are replaced by the contents of the corresponding group. The "
"backreference ``\\g<0>`` will be replaced by the entire match."
msgstr ""
"Retorna a string obtida fazendo a substituição da contrabarra na string de "
"modelo *template*, como feito pelo método :meth:`~Pattern.sub`. Escapes como "
"``\\n`` são convertidos para os caracteres apropriados, e referências "
"anteriores numéricas (``\\1``, ``\\2``) e referências anteriores nomeadas "
"(``\\g<1>``, ``\\g<nome>``) são substituídas pelo conteúdo do grupo "
"correspondente. A referência anterior ``\\g<0>`` será substituída pela "
"correspondência completa."

#: ../../library/re.rst:1401
msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match, "
"the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned. ::"
msgstr ""
"Retorna um ou mais subgrupos da correspondência. Se houver um único "
"argumento, o resultado será uma única string; se houver vários argumentos, o "
"resultado é uma tupla com um item por argumento. Sem argumentos, *group1* "
"padroniza para zero (toda a correspondência é retornada). Se um argumento "
"*groupN* for zero, o valor de retorno correspondente será toda a string "
"correspondente; se estiver no intervalo inclusivo [1..99], é a string que "
"corresponde ao grupo entre parênteses correspondente. Se um número de grupo "
"for negativo ou maior do que o número de grupos definidos no padrão, uma "
"exceção :exc:`IndexError` é levantada. Se um grupo estiver contido em uma "
"parte do padrão que não correspondeu, o resultado correspondente será "
"``None``. Se um grupo estiver contido em uma parte do padrão que "
"correspondeu várias vezes, a última correspondência será retornada. ::"

#: ../../library/re.rst:1413
msgid ""
">>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\")\n"
">>> m.group(0)       # The entire match\n"
"'Isaac Newton'\n"
">>> m.group(1)       # The first parenthesized subgroup.\n"
"'Isaac'\n"
">>> m.group(2)       # The second parenthesized subgroup.\n"
"'Newton'\n"
">>> m.group(1, 2)    # Multiple arguments give us a tuple.\n"
"('Isaac', 'Newton')"
msgstr ""
">>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, físico\")\n"
">>> m.group(0)       # A correspondência inteira\n"
"'Isaac Newton'\n"
">>> m.group(1)       # O primeiro subgrupo entre parênteses.\n"
"'Isaac'\n"
">>> m.group(2)       # O segundo subgrupo entre parênteses.\n"
"'Newton'\n"
">>> m.group(1, 2)    # Múltiplos argumentos retornam uma tupla.\n"
"('Isaac', 'Newton')"

#: ../../library/re.rst:1423
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, "
"an :exc:`IndexError` exception is raised."
msgstr ""
"Se a expressão regular usa a sintaxe ``(?P<nome>...)``, os argumentos "
"*groupN* também podem ser strings que identificam grupos por seus nomes de "
"grupo. Se um argumento string não for usado como um nome de grupo no padrão, "
"uma exceção :exc:`IndexError` é levantada."

#: ../../library/re.rst:1428
msgid "A moderately complicated example::"
msgstr "Um exemplo moderadamente complicado::"

#: ../../library/re.rst:1430
msgid ""
">>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm "
"Reynolds\")\n"
">>> m.group('first_name')\n"
"'Malcolm'\n"
">>> m.group('last_name')\n"
"'Reynolds'"
msgstr ""
">>> m = re.match(r\"(?P<primeiro_nome>\\w+) (?P<sobrenome>\\w+)\", \"Malcolm "
"Reynolds\")\n"
">>> m.group('primeiro_nome')\n"
"'Malcolm'\n"
">>> m.group('sobrenome')\n"
"'Reynolds'"

#: ../../library/re.rst:1436
msgid "Named groups can also be referred to by their index::"
msgstr "Grupos nomeados também podem ser referidos por seu índice::"

#: ../../library/re.rst:1438
msgid ""
">>> m.group(1)\n"
"'Malcolm'\n"
">>> m.group(2)\n"
"'Reynolds'"
msgstr ""
">>> m.group(1)\n"
"'Malcolm'\n"
">>> m.group(2)\n"
"'Reynolds'"

#: ../../library/re.rst:1443
msgid "If a group matches multiple times, only the last match is accessible::"
msgstr ""
"Se um grupo corresponder várias vezes, apenas a última correspondência "
"estará acessível::"

#: ../../library/re.rst:1445
msgid ""
">>> m = re.match(r\"(..)+\", \"a1b2c3\")  # Matches 3 times.\n"
">>> m.group(1)                        # Returns only the last match.\n"
"'c3'"
msgstr ""
">>> m = re.match(r\"(..)+\", \"a1b2c3\")  # Corresponde 3 vezes.\n"
">>> m.group(1)                        # Retorna somente a última "
"correspondência.\n"
"'c3'"

#: ../../library/re.rst:1452
msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match::"
msgstr ""
"Isso é idêntico a ``m.group(g)``. Isso permite acesso mais fácil a um grupo "
"individual de uma correspondência::"

#: ../../library/re.rst:1455
msgid ""
">>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\")\n"
">>> m[0]       # The entire match\n"
"'Isaac Newton'\n"
">>> m[1]       # The first parenthesized subgroup.\n"
"'Isaac'\n"
">>> m[2]       # The second parenthesized subgroup.\n"
"'Newton'"
msgstr ""
">>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, físico\")\n"
">>> m[0]       # A correspondência inteira\n"
"'Isaac Newton'\n"
">>> m[1]       # O primeiro subgrupo entre parênteses.\n"
"'Isaac'\n"
">>> m[2]       # O segundo subgrupo entre parênteses.\n"
"'Newton'"

#: ../../library/re.rst:1463
msgid "Named groups are supported as well::"
msgstr "Também há suporte para grupos nomeados::"

#: ../../library/re.rst:1465
msgid ""
">>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Isaac "
"Newton\")\n"
">>> m['first_name']\n"
"'Isaac'\n"
">>> m['last_name']\n"
"'Newton'"
msgstr ""
">>> m = re.match(r\"(?P<primeiro_nome>\\w+) (?P<sobrenome>\\w+)\", \"Isaac "
"Newton\")\n"
">>> m['primeiro_nome']\n"
"'Isaac'\n"
">>> m['sobrenome']\n"
"'Newton'"

#: ../../library/re.rst:1476
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``."
msgstr ""
"Retorna uma tupla contendo todos os subgrupos da correspondência, de 1 até "
"quantos grupos estiverem no padrão. O argumento *default* é usado para "
"grupos que não participaram da correspondência; o padrão é ``None``."

#: ../../library/re.rst:1480 ../../library/re.rst:1705
msgid "For example::"
msgstr "Por exemplo::"

#: ../../library/re.rst:1482
msgid ""
">>> m = re.match(r\"(\\d+)\\.(\\d+)\", \"24.1632\")\n"
">>> m.groups()\n"
"('24', '1632')"
msgstr ""
">>> m = re.match(r\"(\\d+)\\.(\\d+)\", \"24.1632\")\n"
">>> m.groups()\n"
"('24', '1632')"

#: ../../library/re.rst:1486
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given::"
msgstr ""
"Se colocarmos a casa decimal e tudo depois dela opcional, nem todos os "
"grupos podem participar da correspondência. Esses grupos serão padronizados "
"como ``None``, a menos que o argumento *default* seja fornecido::"

#: ../../library/re.rst:1490
msgid ""
">>> m = re.match(r\"(\\d+)\\.?(\\d+)?\", \"24\")\n"
">>> m.groups()      # Second group defaults to None.\n"
"('24', None)\n"
">>> m.groups('0')   # Now, the second group defaults to '0'.\n"
"('24', '0')"
msgstr ""
">>> m = re.match(r\"(\\d+)\\.?(\\d+)?\", \"24\")\n"
">>> m.groups()      # Segundo grupo padronizado para None.\n"
"('24', None)\n"
">>> m.groups('0')   # Agora, o segundo grupo é padronizado para '0'.\n"
"('24', '0')"

#: ../../library/re.rst:1499
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed "
"by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example::"
msgstr ""
"Retorna um dicionário contendo todos os subgrupos *nomeados* da "
"correspondência, tendo como chave o nome do subgrupo. O argumento *default* "
"usado para grupos que não participaram da correspondência; o padrão é "
"``None``. Por exemplo::"

#: ../../library/re.rst:1503
msgid ""
">>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm "
"Reynolds\")\n"
">>> m.groupdict()\n"
"{'first_name': 'Malcolm', 'last_name': 'Reynolds'}"
msgstr ""
">>> m = re.match(r\"(?P<primeiro_nome>\\w+) (?P<sobrenome>\\w+)\", \"Malcolm "
"Reynolds\")\n"
">>> m.groupdict()\n"
"{'primeiro_nome': 'Malcolm', 'sobrenome': 'Reynolds'}"

#: ../../library/re.rst:1511
msgid ""
"Return the indices of the start and end of the substring matched by *group*; "
"*group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""
"Retorna os índices de início e fim da substring correspondida pelo grupo "
"*group*; *group* tem como padrão  zero (o que significa que toda a substring "
"é correspondida). Retorna ``-1`` se *group* existe, mas não contribuiu para "
"a correspondência. Para um objeto correspondência *m* e um grupo *g* que "
"contribuiu para a correspondência, a substring correspondida pelo grupo *g* "
"(equivalente a ``m.group(g)``) é ::"

#: ../../library/re.rst:1517
msgid "m.string[m.start(g):m.end(g)]"
msgstr "m.string[m.start(g):m.end(g)]"

#: ../../library/re.rst:1519
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, "
"``m.start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are "
"both 2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""
"Observe que ``m.start(group)`` será igual a ``m.end(group)`` se *group* "
"correspondeu a uma string nula. Por exemplo, após ``m = re.search('b(c?)', "
"'cba')``, ``m.start(0)`` é 1, ``m.end(0)`` é 2, ``m.start(1)`` e "
"``m.end(1)`` são 2, e ``m.start(2)`` levanta uma exceção :exc:`IndexError`."

#: ../../library/re.rst:1524
msgid "An example that will remove *remove_this* from email addresses::"
msgstr "Um exemplo que removerá *remova_isto* dos endereços de e-mail::"

#: ../../library/re.rst:1526
msgid ""
">>> email = \"tony@tiremove_thisger.net\"\n"
">>> m = re.search(\"remove_this\", email)\n"
">>> email[:m.start()] + email[m.end():]\n"
"'tony@tiger.net'"
msgstr ""
">>> email = \"tony@tiremova_istoger.net\"\n"
">>> m = re.search(\"remova_isto\", email)\n"
">>> email[:m.start()] + email[m.end():]\n"
"'tony@tiger.net'"

#: ../../library/re.rst:1534
msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. Note "
"that if *group* did not contribute to the match, this is ``(-1, -1)``. "
"*group* defaults to zero, the entire match."
msgstr ""
"Para uma correspondência *m*, retorna a tupla com dois elementos "
"``(m.start(group), m.end(group))``. Observe que se *group* não contribuiu "
"para a correspondência, isso é ``(-1, -1)``. *group* tem como padrão zero, a "
"correspondência inteira."

#: ../../library/re.rst:1541
msgid ""
"The value of *pos* which was passed to the :meth:`~Pattern.search` "
"or :meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  "
"This is the index into the string at which the RE engine started looking for "
"a match."
msgstr ""
"O valor de *pos* que foi passado para o método :meth:`~Pattern.search` "
"ou :meth:`~Pattern.match` de um :ref:`objeto expressão regular <re-"
"objects>`. Este é o índice da string na qual o mecanismo de ER começou a "
"procurar uma correspondência."

#: ../../library/re.rst:1548
msgid ""
"The value of *endpos* which was passed to the :meth:`~Pattern.search` "
"or :meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  "
"This is the index into the string beyond which the RE engine will not go."
msgstr ""
"O valor de *endpos* que foi passado para o método :meth:`~Pattern.search` "
"ou :meth:`~Pattern.match` de um :ref:`objeto expressão regular <re-"
"objects>`. Este é o índice da string após o qual o mecanismo de ER não vai "
"chegar."

#: ../../library/re.rst:1555
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, ``((a)"
"(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the string "
"``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == 2``, if "
"applied to the same string."
msgstr ""
"O índice em número inteiro do último grupo de captura correspondido, ou "
"``None`` se nenhum grupo foi correspondido. Por exemplo, as expressões "
"``(a)b``, ``((a)(b))`` e ``((ab))`` terão ``lastindex == 1`` se aplicadas à "
"string ``'ab'``, enquanto a expressão ``(a)(b)`` terá ``lastindex == 2``, se "
"aplicada à mesma string."

#: ../../library/re.rst:1564
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr ""
"O nome do último grupo de captura correspondido, ou ``None`` se o grupo não "
"tinha um nome, ou se nenhum grupo foi correspondido."

#: ../../library/re.rst:1570
msgid ""
"The :ref:`regular expression object <re-objects>` "
"whose :meth:`~Pattern.match` or :meth:`~Pattern.search` method produced this "
"match instance."
msgstr ""
"O :ref:`objeto expressão regular <re-objects>` cujo "
"método :meth:`~Pattern.match` ou :meth:`~Pattern.search` produziu esta "
"instância de correspondência."

#: ../../library/re.rst:1576
msgid "The string passed to :meth:`~Pattern.match` or :meth:`~Pattern.search`."
msgstr ""
"A string passada para :meth:`~Pattern.match` ou :meth:`~Pattern.search`."

#: ../../library/re.rst:1579
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Match objects "
"are considered atomic."
msgstr ""
"Adicionado suporte para :func:`copy.copy` e :func:`copy.deepcopy`. Objetos "
"correspondência são considerados atômicos."

#: ../../library/re.rst:1587
msgid "Regular Expression Examples"
msgstr "Exemplos de expressão regular"

#: ../../library/re.rst:1591
msgid "Checking for a Pair"
msgstr "Verificando por um par"

#: ../../library/re.rst:1593
msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully::"
msgstr ""
"Neste exemplo, usaremos a seguinte função auxiliar para exibir objetos "
"correspondência com um pouco mais de elegância::"

#: ../../library/re.rst:1596
msgid ""
"def displaymatch(match):\n"
"    if match is None:\n"
"        return None\n"
"    return '<Match: %r, groups=%r>' % (match.group(), match.groups())"
msgstr ""
"def displaymatch(match):\n"
"    if match is None:\n"
"        return None\n"
"    return '<Match: %r, groups=%r>' % (match.group(), match.groups())"

#: ../../library/re.rst:1601
msgid ""
"Suppose you are writing a poker program where a player's hand is represented "
"as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr ""
"Suponha que você esteja escrevendo um programa de pôquer onde a mão de um "
"jogador é representada como uma string de 5 caracteres com cada caractere "
"representando uma carta, \"a\" para ás, \"k\" para rei, \"q\" para dama, "
"\"j\" para valete, \"t\" para 10 e \"2\" a \"9\" representando a carta com "
"esse valor."

#: ../../library/re.rst:1606
msgid "To see if a given string is a valid hand, one could do the following::"
msgstr ""
"Para ver se uma determinada string é uma mão válida, pode-se fazer o "
"seguinte::"

#: ../../library/re.rst:1608
msgid ""
">>> valid = re.compile(r\"^[a2-9tjqk]{5}$\")\n"
">>> displaymatch(valid.match(\"akt5q\"))  # Valid.\n"
"\"<Match: 'akt5q', groups=()>\"\n"
">>> displaymatch(valid.match(\"akt5e\"))  # Invalid.\n"
">>> displaymatch(valid.match(\"akt\"))    # Invalid.\n"
">>> displaymatch(valid.match(\"727ak\"))  # Valid.\n"
"\"<Match: '727ak', groups=()>\""
msgstr ""
">>> valid = re.compile(r\"^[a2-9tjqk]{5}$\")\n"
">>> displaymatch(valid.match(\"akt5q\"))  # Válida.\n"
"\"<Match: 'akt5q', groups=()>\"\n"
">>> displaymatch(valid.match(\"akt5e\"))  # Inválida.\n"
">>> displaymatch(valid.match(\"akt\"))    # Inválida.\n"
">>> displaymatch(valid.match(\"727ak\"))  # Válida.\n"
"\"<Match: '727ak', groups=()>\""

#: ../../library/re.rst:1616
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences "
"as such::"
msgstr ""
"Essa última mão, ``\"727ak\"``, continha um par, ou duas cartas com o mesmo "
"valor. Para combinar isso com uma expressão regular, pode-se usar "
"referências anteriores como::"

#: ../../library/re.rst:1619
msgid ""
">>> pair = re.compile(r\".*(.).*\\1\")\n"
">>> displaymatch(pair.match(\"717ak\"))     # Pair of 7s.\n"
"\"<Match: '717', groups=('7',)>\"\n"
">>> displaymatch(pair.match(\"718ak\"))     # No pairs.\n"
">>> displaymatch(pair.match(\"354aa\"))     # Pair of aces.\n"
"\"<Match: '354aa', groups=('a',)>\""
msgstr ""
">>> pair = re.compile(r\".*(.).*\\1\")\n"
">>> displaymatch(pair.match(\"717ak\"))     # Par de 7s.\n"
"\"<Match: '717', groups=('7',)>\"\n"
">>> displaymatch(pair.match(\"718ak\"))     # Sem pares.\n"
">>> displaymatch(pair.match(\"354aa\"))     # Par de áses.\n"
"\"<Match: '354aa', groups=('a',)>\""

#: ../../library/re.rst:1626
msgid ""
"To find out what card the pair consists of, one could use "
"the :meth:`~Match.group` method of the match object in the following manner::"
msgstr ""
"Para descobrir em que carta o par consiste, pode-se usar o "
"método :meth:`~Match.group` do objeto correspondência da seguinte maneira::"

#: ../../library/re.rst:1629
msgid ""
">>> pair = re.compile(r\".*(.).*\\1\")\n"
">>> pair.match(\"717ak\").group(1)\n"
"'7'\n"
"\n"
"# Error because re.match() returns None, which doesn't have a group() "
"method:\n"
">>> pair.match(\"718ak\").group(1)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#23>\", line 1, in <module>\n"
"    re.match(r\".*(.).*\\1\", \"718ak\").group(1)\n"
"AttributeError: 'NoneType' object has no attribute 'group'\n"
"\n"
">>> pair.match(\"354aa\").group(1)\n"
"'a'"
msgstr ""
">>> pair = re.compile(r\".*(.).*\\1\")\n"
">>> pair.match(\"717ak\").group(1)\n"
"'7'\n"
"\n"
"# Erro porque re.match() retorna None, que não tem um método group()::\n"
">>> pair.match(\"718ak\").group(1)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#23>\", line 1, in <module>\n"
"    re.match(r\".*(.).*\\1\", \"718ak\").group(1)\n"
"AttributeError: 'NoneType' object has no attribute 'group'\n"
"\n"
">>> pair.match(\"354aa\").group(1)\n"
"'a'"

#: ../../library/re.rst:1645
msgid "Simulating scanf()"
msgstr "Simulando scanf()"

#: ../../library/re.rst:1649
msgid ""
"Python does not currently have an equivalent to :c:func:`!scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, "
"than :c:func:`!scanf` format strings.  The table below offers some more-or-"
"less equivalent mappings between :c:func:`!scanf` format tokens and regular "
"expressions."
msgstr ""
"Atualmente, Python não possui um equivalente a :c:func:`!scanf`. Expressões "
"regulares são geralmente mais poderosas, embora também mais prolixas, do que "
"strings de formato :c:func:`!scanf`. A tabela abaixo oferece alguns "
"mapeamentos mais ou menos equivalentes entre strings de formato :c:func:`!"
"scanf` e expressões regulares."

#: ../../library/re.rst:1656
msgid ":c:func:`!scanf` Token"
msgstr "Símbolo do :c:func:`!scanf`"

#: ../../library/re.rst:1656
msgid "Regular Expression"
msgstr "Expressão regular"

#: ../../library/re.rst:1658
msgid "``%c``"
msgstr "``%c``"

#: ../../library/re.rst:1660
msgid "``%5c``"
msgstr "``%5c``"

#: ../../library/re.rst:1660
msgid "``.{5}``"
msgstr "``.{5}``"

#: ../../library/re.rst:1662
msgid "``%d``"
msgstr "``%d``"

#: ../../library/re.rst:1662
msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

#: ../../library/re.rst:1664
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr "``%e``, ``%E``, ``%f``, ``%g``"

#: ../../library/re.rst:1664
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

#: ../../library/re.rst:1666
msgid "``%i``"
msgstr "``%i``"

#: ../../library/re.rst:1666
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

#: ../../library/re.rst:1668
msgid "``%o``"
msgstr "``%o``"

#: ../../library/re.rst:1668
msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

#: ../../library/re.rst:1670
msgid "``%s``"
msgstr "``%s``"

#: ../../library/re.rst:1670
msgid "``\\S+``"
msgstr "``\\S+``"

#: ../../library/re.rst:1672
msgid "``%u``"
msgstr "``%u``"

#: ../../library/re.rst:1672
msgid "``\\d+``"
msgstr "``\\d+``"

#: ../../library/re.rst:1674
msgid "``%x``, ``%X``"
msgstr "``%x``, ``%X``"

#: ../../library/re.rst:1674
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

#: ../../library/re.rst:1677
msgid "To extract the filename and numbers from a string like ::"
msgstr "Para extrair um nome de arquivo e números de uma string como ::"

#: ../../library/re.rst:1679
msgid "/usr/sbin/sendmail - 0 errors, 4 warnings"
msgstr "/usr/sbin/sendmail - 0 errors, 4 warnings"

#: ../../library/re.rst:1681
msgid "you would use a :c:func:`!scanf` format like ::"
msgstr "você usaria um formato :c:func:`!scanf` como ::"

#: ../../library/re.rst:1683
msgid "%s - %d errors, %d warnings"
msgstr "%s - %d errors, %d warnings"

#: ../../library/re.rst:1685
msgid "The equivalent regular expression would be ::"
msgstr "A expressão regular equivalente seria ::"

#: ../../library/re.rst:1687
msgid "(\\S+) - (\\d+) errors, (\\d+) warnings"
msgstr "(\\S+) - (\\d+) errors, (\\d+) warnings"

#: ../../library/re.rst:1693
msgid "search() vs. match()"
msgstr "search() vs. match()"

#: ../../library/re.rst:1697
msgid ""
"Python offers different primitive operations based on regular expressions:"
msgstr ""
"Python oferece diferentes operações primitivas baseadas em expressões "
"regulares:"

#: ../../library/re.rst:1699
msgid ":func:`re.match` checks for a match only at the beginning of the string"
msgstr ""
":func:`re.match` verifica uma correspondência apenas no início da string"

#: ../../library/re.rst:1700
msgid ""
":func:`re.search` checks for a match anywhere in the string (this is what "
"Perl does by default)"
msgstr ""
":func:`re.search` verifica uma correspondência em qualquer lugar na string "
"(isso é o que o Perl faz por padrão)"

#: ../../library/re.rst:1702
msgid ":func:`re.fullmatch` checks for entire string to be a match"
msgstr ""
":func:`re.fullmatch` verifica toda a string para ser uma correspondência"

#: ../../library/re.rst:1707
msgid ""
">>> re.match(\"c\", \"abcdef\")    # No match\n"
">>> re.search(\"c\", \"abcdef\")   # Match\n"
"<re.Match object; span=(2, 3), match='c'>\n"
">>> re.fullmatch(\"p.*n\", \"python\") # Match\n"
"<re.Match object; span=(0, 6), match='python'>\n"
">>> re.fullmatch(\"r.*n\", \"python\") # No match"
msgstr ""
">>> re.match(\"c\", \"abcdef\")    # Sem correspondência\n"
">>> re.search(\"c\", \"abcdef\")   # Correspondência\n"
"<re.Match object; span=(2, 3), match='c'>\n"
">>> re.fullmatch(\"p.*n\", \"python\") # Correspondência\n"
"<re.Match object; span=(0, 6), match='python'>\n"
">>> re.fullmatch(\"r.*n\", \"python\") # Sem correspondência"

#: ../../library/re.rst:1714
msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr ""
"Expressões regulares começando com ``'^'`` podem ser usadas "
"com :func:`search` para restringir a correspondência no início da string::"

#: ../../library/re.rst:1717
msgid ""
">>> re.match(\"c\", \"abcdef\")    # No match\n"
">>> re.search(\"^c\", \"abcdef\")  # No match\n"
">>> re.search(\"^a\", \"abcdef\")  # Match\n"
"<re.Match object; span=(0, 1), match='a'>"
msgstr ""
">>> re.match(\"c\", \"abcdef\")    # Sem correspondência\n"
">>> re.search(\"^c\", \"abcdef\")  # Sem correspondência\n"
">>> re.search(\"^a\", \"abcdef\")  # Correspondência\n"
"<re.Match object; span=(0, 1), match='a'>"

#: ../../library/re.rst:1722
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each "
"line. ::"
msgstr ""
"Observe, entretanto, que no modo :const:`MULTILINE` :func:`match` apenas "
"corresponde ao início da string, enquanto que usar :func:`search` com uma "
"expressão regular começando com ``'^'`` irá corresponder no início de cada "
"linha. ::"

#: ../../library/re.rst:1726
msgid ""
">>> re.match(\"X\", \"A\\nB\\nX\", re.MULTILINE)  # No match\n"
">>> re.search(\"^X\", \"A\\nB\\nX\", re.MULTILINE)  # Match\n"
"<re.Match object; span=(4, 5), match='X'>"
msgstr ""
">>> re.match(\"X\", \"A\\nB\\nX\", re.MULTILINE)  # Sem correspondência\n"
">>> re.search(\"^X\", \"A\\nB\\nX\", re.MULTILINE)  # Correspondência\n"
"<re.Match object; span=(4, 5), match='X'>"

#: ../../library/re.rst:1732
msgid "Making a Phonebook"
msgstr "Criando uma lista telefônica"

#: ../../library/re.rst:1734
msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""
":func:`split` divide uma string em uma lista delimitada pelo padrão passado. "
"O método é inestimável para converter dados textuais em estruturas de dados "
"que podem ser facilmente lidas e modificadas pelo Python, conforme "
"demonstrado no exemplo a seguir que cria uma lista telefônica."

#: ../../library/re.rst:1739
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax"
msgstr ""
"Primeiro, aqui está a entrada. Normalmente pode vir de um arquivo, aqui "
"estamos usando a sintaxe de string entre aspas triplas."

#: ../../library/re.rst:1742
msgid ""
">>> text = \"\"\"Ross McFluff: 834.345.1254 155 Elm Street\n"
"...\n"
"... Ronald Heathmore: 892.345.3428 436 Finley Avenue\n"
"... Frank Burger: 925.541.7625 662 South Dogwood Way\n"
"...\n"
"...\n"
"... Heather Albrecht: 548.326.4584 919 Park Place\"\"\""
msgstr ""
">>> texto = \"\"\"Ross McFluff: 834.345.1254 155 Elm Street\n"
"...\n"
"... Ronald Heathmore: 892.345.3428 436 Finley Avenue\n"
"... Frank Burger: 925.541.7625 662 South Dogwood Way\n"
"...\n"
"...\n"
"... Heather Albrecht: 548.326.4584 919 Park Place\"\"\""

#: ../../library/re.rst:1752
msgid ""
"The entries are separated by one or more newlines. Now we convert the string "
"into a list with each nonempty line having its own entry:"
msgstr ""
"Os registros são separados por uma ou mais novas linhas. Agora, convertemos "
"a string em uma lista com cada linha não vazia tendo seu próprio registro:"

#: ../../library/re.rst:1755
msgid ""
">>> entries = re.split(\"\\n+\", text)\n"
">>> entries\n"
"['Ross McFluff: 834.345.1254 155 Elm Street',\n"
"'Ronald Heathmore: 892.345.3428 436 Finley Avenue',\n"
"'Frank Burger: 925.541.7625 662 South Dogwood Way',\n"
"'Heather Albrecht: 548.326.4584 919 Park Place']"
msgstr ""
">>> registros = re.split(\"\\n+\", texto)\n"
">>> registros\n"
"['Ross McFluff: 834.345.1254 155 Elm Street',\n"
"'Ronald Heathmore: 892.345.3428 436 Finley Avenue',\n"
"'Frank Burger: 925.541.7625 662 South Dogwood Way',\n"
"'Heather Albrecht: 548.326.4584 919 Park Place']"

#: ../../library/re.rst:1765
msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""
"Finalmente, divida cada registro em uma lista com nome, sobrenome, número de "
"telefone e endereço. Usamos o parâmetro ``maxsplit`` de :func:`split` porque "
"o endereço contém espaços, nosso padrão de divisão:"

#: ../../library/re.rst:1769
msgid ""
">>> [re.split(\":? \", entry, maxsplit=3) for entry in entries]\n"
"[['Ross', 'McFluff', '834.345.1254', '155 Elm Street'],\n"
"['Ronald', 'Heathmore', '892.345.3428', '436 Finley Avenue'],\n"
"['Frank', 'Burger', '925.541.7625', '662 South Dogwood Way'],\n"
"['Heather', 'Albrecht', '548.326.4584', '919 Park Place']]"
msgstr ""
">>> [re.split(\":? \", registro, maxsplit=3) for registro in registros]\n"
"[['Ross', 'McFluff', '834.345.1254', '155 Elm Street'],\n"
"['Ronald', 'Heathmore', '892.345.3428', '436 Finley Avenue'],\n"
"['Frank', 'Burger', '925.541.7625', '662 South Dogwood Way'],\n"
"['Heather', 'Albrecht', '548.326.4584', '919 Park Place']]"

#: ../../library/re.rst:1778
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""
"O padrão ``:?`` corresponde ao caractere de dois pontos após o sobrenome, de "
"modo que não ocorre na lista de resultados. Com um ``maxsplit`` de ``4``, "
"podemos separar o número da casa do nome da rua:"

#: ../../library/re.rst:1782
msgid ""
">>> [re.split(\":? \", entry, maxsplit=4) for entry in entries]\n"
"[['Ross', 'McFluff', '834.345.1254', '155', 'Elm Street'],\n"
"['Ronald', 'Heathmore', '892.345.3428', '436', 'Finley Avenue'],\n"
"['Frank', 'Burger', '925.541.7625', '662', 'South Dogwood Way'],\n"
"['Heather', 'Albrecht', '548.326.4584', '919', 'Park Place']]"
msgstr ""
">>> [re.split(\":? \", registro, maxsplit=4) for registro in registros]\n"
"[['Ross', 'McFluff', '834.345.1254', '155', 'Elm Street'],\n"
"['Ronald', 'Heathmore', '892.345.3428', '436', 'Finley Avenue'],\n"
"['Frank', 'Burger', '925.541.7625', '662', 'South Dogwood Way'],\n"
"['Heather', 'Albrecht', '548.326.4584', '919', 'Park Place']]"

#: ../../library/re.rst:1793
msgid "Text Munging"
msgstr "Mastigando texto"

#: ../../library/re.rst:1795
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""
":func:`sub` substitui cada ocorrência de um padrão por uma string ou o "
"resultado de uma função. Este exemplo demonstra o uso de :func:`sub` com uma "
"função para \"mastigar\" o texto ou aleatorizar a ordem de todos os "
"caracteres em cada palavra de uma frase, exceto o primeiro e o último "
"caracteres::"

#: ../../library/re.rst:1800
msgid ""
">>> def repl(m):\n"
"...     inner_word = list(m.group(2))\n"
"...     random.shuffle(inner_word)\n"
"...     return m.group(1) + \"\".join(inner_word) + m.group(3)\n"
"...\n"
">>> text = \"Professor Abdolmalek, please report your absences promptly.\"\n"
">>> re.sub(r\"(\\w)(\\w+)(\\w)\", repl, text)\n"
"'Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.'\n"
">>> re.sub(r\"(\\w)(\\w+)(\\w)\", repl, text)\n"
"'Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.'"
msgstr ""
">>> def repl(m):\n"
"...     inner_word = list(m.group(2))\n"
"...     random.shuffle(inner_word)\n"
"...     return m.group(1) + \"\".join(inner_word) + m.group(3)\n"
"...\n"
">>> text = \"Professor Masanori, favor comunicar suas ausências "
"imediatamente.\"\n"
">>> re.sub(r\"(\\w)(\\w+)(\\w)\", repl, text)\n"
"'Psesforor Mranoasi, favor cmounacir suas acaêiusns idaaeemttnmie.'\n"
">>> re.sub(r\"(\\w)(\\w+)(\\w)\", repl, text)\n"
"'Prfseosor Monsaari, fovar camonucir saus acuêsains ientdaammetie.'"

#: ../../library/re.rst:1813
msgid "Finding all Adverbs"
msgstr "Encontrando todos os advérbios"

#: ../../library/re.rst:1815
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if a writer wanted to find all of "
"the adverbs in some text, they might use :func:`findall` in the following "
"manner::"
msgstr ""
":func:`findall` corresponde *todas* as ocorrências de um padrão, não apenas "
"a primeira como :func:`search` faz. Por exemplo, se uma pessoa deseja "
"encontrar todos os advérbios em algum texto, ela pode usar :func:`findall` "
"da seguinte maneira::"

#: ../../library/re.rst:1820
msgid ""
">>> text = \"He was carefully disguised but captured quickly by police.\"\n"
">>> re.findall(r\"\\w+ly\\b\", text)\n"
"['carefully', 'quickly']"
msgstr ""
">>> text = \"Ele estava cuidadosamente disfarçado, mas foi rapidamente "
"capturado pela polícia.\"\n"
">>> re.findall(r\"\\w+mente\\b\", text)\n"
"['cuidadosamente', 'rapidamente']"

#: ../../library/re.rst:1826
msgid "Finding all Adverbs and their Positions"
msgstr "Encontrando todos os advérbios e suas posições"

#: ../../library/re.rst:1828
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides :class:`~re.Match` "
"objects instead of strings.  Continuing with the previous example, if a "
"writer wanted to find all of the adverbs *and their positions* in some text, "
"they would use :func:`finditer` in the following manner::"
msgstr ""
"Se alguém deseja obter mais informações sobre todas as correspondências de "
"um padrão além do texto correspondido, :func:`finditer` é útil, pois fornece "
"objetos :class:`~re.Match` em vez de strings. Continuando com o exemplo "
"anterior, se um escritor quisesse encontrar todos os advérbios *e suas "
"posições* em algum texto, ele usaria :func:`finditer` da seguinte maneira::"

#: ../../library/re.rst:1834
msgid ""
">>> text = \"He was carefully disguised but captured quickly by police.\"\n"
">>> for m in re.finditer(r\"\\w+ly\\b\", text):\n"
"...     print('%02d-%02d: %s' % (m.start(), m.end(), m.group(0)))\n"
"07-16: carefully\n"
"40-47: quickly"
msgstr ""
">>> text = \"Ele estava cuidadosamente disfarçado, mas foi rapidamente "
"capturado pela polícia.\"\n"
">>> for m in re.finditer(r\"\\w+mente\\b\", text):\n"
"... print('%02d-%02d: %s' % (m.start(), m.end(), m.group(0)))\n"
"11-25: cuidadosamente\n"
"46-57: rapidamente"

#: ../../library/re.rst:1842
msgid "Raw String Notation"
msgstr "Notação de string bruta"

#: ../../library/re.rst:1844
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without "
"it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical::"
msgstr ""
"A notação de string bruta (``r\"texto\"``) mantém as expressões regulares "
"sãs. Sem ela, cada contrabarra (``'\\'``) em uma expressão regular teria que "
"ser prefixada com outra para ter seu efeito de caractere especial anulado. "
"Por exemplo, as duas linhas de código a seguir são funcionalmente idênticas::"

#: ../../library/re.rst:1849
msgid ""
">>> re.match(r\"\\W(.)\\1\\W\", \" ff \")\n"
"<re.Match object; span=(0, 4), match=' ff '>\n"
">>> re.match(\"\\\\W(.)\\\\1\\\\W\", \" ff \")\n"
"<re.Match object; span=(0, 4), match=' ff '>"
msgstr ""
">>> re.match(r\"\\W(.)\\1\\W\", \" ff \")\n"
"<re.Match object; span=(0, 4), match=' ff '>\n"
">>> re.match(\"\\\\W(.)\\\\1\\\\W\", \" ff \")\n"
"<re.Match object; span=(0, 4), match=' ff '>"

#: ../../library/re.rst:1854
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical::"
msgstr ""
"Quando se deseja corresponder a uma contrabarra literal, ela deve ser "
"prefixada com outra contrabarra na expressão regular. Com a notação de "
"string bruta, isso significa ``r\"\\\\\"``. Sem a notação de string bruta, "
"deve-se usar ``\"\\\\\\\\\"``, tornando as seguintes linhas de código "
"funcionalmente idênticas::"

#: ../../library/re.rst:1859
msgid ""
">>> re.match(r\"\\\\\", r\"\\\\\")\n"
"<re.Match object; span=(0, 1), match='\\\\'>\n"
">>> re.match(\"\\\\\\\\\", r\"\\\\\")\n"
"<re.Match object; span=(0, 1), match='\\\\'>"
msgstr ""
">>> re.match(r\"\\\\\", r\"\\\\\")\n"
"<re.Match object; span=(0, 1), match='\\\\'>\n"
">>> re.match(\"\\\\\\\\\", r\"\\\\\")\n"
"<re.Match object; span=(0, 1), match='\\\\'>"

#: ../../library/re.rst:1866
msgid "Writing a Tokenizer"
msgstr "Escrevendo um tokenizador"

#: ../../library/re.rst:1868
msgid ""
"A `tokenizer or scanner <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"analyzes a string to categorize groups of characters.  This is a useful "
"first step in writing a compiler or interpreter."
msgstr ""
"Um `tokenizador ou scanner <https://pt.wikipedia.org/wiki/Análise_léxica>`_ "
"analisa uma string para categorizar grupos de caracteres. Este é um primeiro "
"passo útil para escrever um compilador ou interpretador."

#: ../../library/re.rst:1872
msgid ""
"The text categories are specified with regular expressions.  The technique "
"is to combine those into a single master regular expression and to loop over "
"successive matches::"
msgstr ""
"As categorias de texto são especificadas com expressões regulares. A técnica "
"é combiná-las em uma única expressão regular mestre e fazer um laço em "
"correspondências sucessivas::"

#: ../../library/re.rst:1876
msgid ""
"from typing import NamedTuple\n"
"import re\n"
"\n"
"class Token(NamedTuple):\n"
"    type: str\n"
"    value: str\n"
"    line: int\n"
"    column: int\n"
"\n"
"def tokenize(code):\n"
"    keywords = {'IF', 'THEN', 'ENDIF', 'FOR', 'NEXT', 'GOSUB', 'RETURN'}\n"
"    token_specification = [\n"
"        ('NUMBER',   r'\\d+(\\.\\d*)?'),  # Integer or decimal number\n"
"        ('ASSIGN',   r':='),           # Assignment operator\n"
"        ('END',      r';'),            # Statement terminator\n"
"        ('ID',       r'[A-Za-z]+'),    # Identifiers\n"
"        ('OP',       r'[+\\-*/]'),      # Arithmetic operators\n"
"        ('NEWLINE',  r'\\n'),           # Line endings\n"
"        ('SKIP',     r'[ \\t]+'),       # Skip over spaces and tabs\n"
"        ('MISMATCH', r'.'),            # Any other character\n"
"    ]\n"
"    tok_regex = '|'.join('(?P<%s>%s)' % pair for pair in "
"token_specification)\n"
"    line_num = 1\n"
"    line_start = 0\n"
"    for mo in re.finditer(tok_regex, code):\n"
"        kind = mo.lastgroup\n"
"        value = mo.group()\n"
"        column = mo.start() - line_start\n"
"        if kind == 'NUMBER':\n"
"            value = float(value) if '.' in value else int(value)\n"
"        elif kind == 'ID' and value in keywords:\n"
"            kind = value\n"
"        elif kind == 'NEWLINE':\n"
"            line_start = mo.end()\n"
"            line_num += 1\n"
"            continue\n"
"        elif kind == 'SKIP':\n"
"            continue\n"
"        elif kind == 'MISMATCH':\n"
"            raise RuntimeError(f'{value!r} unexpected on line {line_num}')\n"
"        yield Token(kind, value, line_num, column)\n"
"\n"
"statements = '''\n"
"    IF quantity THEN\n"
"        total := total + price * quantity;\n"
"        tax := price * 0.05;\n"
"    ENDIF;\n"
"'''\n"
"\n"
"for token in tokenize(statements):\n"
"    print(token)"
msgstr ""
"from typing import NamedTuple\n"
"import re\n"
"\n"
"class Token(NamedTuple):\n"
"    type: str\n"
"    value: str\n"
"    line: int\n"
"    column: int\n"
"\n"
"def tokenize(code):\n"
"    keywords = {'IF', 'THEN', 'ENDIF', 'FOR', 'NEXT', 'GOSUB', 'RETURN'}\n"
"    token_specification = [\n"
"        ('NUMBER',   r'\\d+(\\.\\d*)?'),  # Número inteiro ou decimal\n"
"        ('ASSIGN',   r':='),           # Operador de atribuição\n"
"        ('END',      r';'),            # Fiinalizador de instrução\n"
"        ('ID',       r'[A-Za-z]+'),    # Identificadores\n"
"        ('OP',       r'[+\\-*/]'),      # Operadores aritméticos\n"
"        ('NEWLINE',  r'\\n'),           # Finais de linha\n"
"        ('SKIP',     r'[ \\t]+'),       # Pula espaços e tabulações\n"
"        ('MISMATCH', r'.'),            # Qualquer outro caracter\n"
"    ]\n"
"    tok_regex = '|'.join('(?P<%s>%s)' % pair for pair in "
"token_specification)\n"
"    line_num = 1\n"
"    line_start = 0\n"
"    for mo in re.finditer(tok_regex, code):\n"
"        kind = mo.lastgroup\n"
"        value = mo.group()\n"
"        column = mo.start() - line_start\n"
"        if kind == 'NUMBER':\n"
"            value = float(value) if '.' in value else int(value)\n"
"        elif kind == 'ID' and value in keywords:\n"
"            kind = value\n"
"        elif kind == 'NEWLINE':\n"
"            line_start = mo.end()\n"
"            line_num += 1\n"
"            continue\n"
"        elif kind == 'SKIP':\n"
"            continue\n"
"        elif kind == 'MISMATCH':\n"
"            raise RuntimeError(f'{value!r} unexpected on line {line_num}')\n"
"        yield Token(kind, value, line_num, column)\n"
"\n"
"statements = '''\n"
"    IF quantity THEN\n"
"        total := total + price * quantity;\n"
"        tax := price * 0.05;\n"
"    ENDIF;\n"
"'''\n"
"\n"
"for token in tokenize(statements):\n"
"    print(token)"

#: ../../library/re.rst:1928
msgid "The tokenizer produces the following output::"
msgstr "O tokenizador produz a seguinte saída::"

#: ../../library/re.rst:1930
msgid ""
"Token(type='IF', value='IF', line=2, column=4)\n"
"Token(type='ID', value='quantity', line=2, column=7)\n"
"Token(type='THEN', value='THEN', line=2, column=16)\n"
"Token(type='ID', value='total', line=3, column=8)\n"
"Token(type='ASSIGN', value=':=', line=3, column=14)\n"
"Token(type='ID', value='total', line=3, column=17)\n"
"Token(type='OP', value='+', line=3, column=23)\n"
"Token(type='ID', value='price', line=3, column=25)\n"
"Token(type='OP', value='*', line=3, column=31)\n"
"Token(type='ID', value='quantity', line=3, column=33)\n"
"Token(type='END', value=';', line=3, column=41)\n"
"Token(type='ID', value='tax', line=4, column=8)\n"
"Token(type='ASSIGN', value=':=', line=4, column=12)\n"
"Token(type='ID', value='price', line=4, column=15)\n"
"Token(type='OP', value='*', line=4, column=21)\n"
"Token(type='NUMBER', value=0.05, line=4, column=23)\n"
"Token(type='END', value=';', line=4, column=27)\n"
"Token(type='ENDIF', value='ENDIF', line=5, column=4)\n"
"Token(type='END', value=';', line=5, column=9)"
msgstr ""
"Token(type='IF', value='IF', line=2, column=4)\n"
"Token(type='ID', value='quantity', line=2, column=7)\n"
"Token(type='THEN', value='THEN', line=2, column=16)\n"
"Token(type='ID', value='total', line=3, column=8)\n"
"Token(type='ASSIGN', value=':=', line=3, column=14)\n"
"Token(type='ID', value='total', line=3, column=17)\n"
"Token(type='OP', value='+', line=3, column=23)\n"
"Token(type='ID', value='price', line=3, column=25)\n"
"Token(type='OP', value='*', line=3, column=31)\n"
"Token(type='ID', value='quantity', line=3, column=33)\n"
"Token(type='END', value=';', line=3, column=41)\n"
"Token(type='ID', value='tax', line=4, column=8)\n"
"Token(type='ASSIGN', value=':=', line=4, column=12)\n"
"Token(type='ID', value='price', line=4, column=15)\n"
"Token(type='OP', value='*', line=4, column=21)\n"
"Token(type='NUMBER', value=0.05, line=4, column=23)\n"
"Token(type='END', value=';', line=4, column=27)\n"
"Token(type='ENDIF', value='ENDIF', line=5, column=4)\n"
"Token(type='END', value=';', line=5, column=9)"

#: ../../library/re.rst:1951
msgid ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. The third edition of the book no longer covers Python at all, but the "
"first edition covered writing good regular expression patterns in great "
"detail."
msgstr ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3ª ed., O'Reilly Media, "
"2009. A terceira edição do livro não cobre mais o Python, mas a primeira "
"edição cobriu a escrita de bons padrões de expressão regular em grandes "
"detalhes."

#: ../../library/re.rst:99
msgid ". (dot)"
msgstr ". (ponto)"

#: ../../library/re.rst:99 ../../library/re.rst:106 ../../library/re.rst:112
#: ../../library/re.rst:123 ../../library/re.rst:130 ../../library/re.rst:137
#: ../../library/re.rst:143 ../../library/re.rst:157 ../../library/re.rst:181
#: ../../library/re.rst:220 ../../library/re.rst:235 ../../library/re.rst:244
#: ../../library/re.rst:258 ../../library/re.rst:271 ../../library/re.rst:304
#: ../../library/re.rst:317 ../../library/re.rst:327 ../../library/re.rst:359
#: ../../library/re.rst:414 ../../library/re.rst:446 ../../library/re.rst:452
#: ../../library/re.rst:457 ../../library/re.rst:464 ../../library/re.rst:471
#: ../../library/re.rst:498 ../../library/re.rst:508 ../../library/re.rst:531
#: ../../library/re.rst:543 ../../library/re.rst:548 ../../library/re.rst:570
#: ../../library/re.rst:590 ../../library/re.rst:606 ../../library/re.rst:614
#: ../../library/re.rst:628 ../../library/re.rst:636 ../../library/re.rst:653
#: ../../library/re.rst:667 ../../library/re.rst:672 ../../library/re.rst:863
#: ../../library/re.rst:1099
msgid "in regular expressions"
msgstr "em expressões regulares"

#: ../../library/re.rst:106 ../../library/re.rst:271
msgid "^ (caret)"
msgstr "^ (circunflexo)"

#: ../../library/re.rst:112
msgid "$ (dollar)"
msgstr "$ (cifrão)"

#: ../../library/re.rst:123
msgid "* (asterisk)"
msgstr "* (asterisco)"

#: ../../library/re.rst:130
msgid "+ (plus)"
msgstr "+ (mais)"

#: ../../library/re.rst:137
msgid "? (question mark)"
msgstr "? (interrogação)"

#: ../../library/re.rst:143
msgid "*?"
msgstr "*?"

#: ../../library/re.rst:143
msgid "+?"
msgstr "+?"

#: ../../library/re.rst:143
msgid "??"
msgstr "??"

#: ../../library/re.rst:157
msgid "*+"
msgstr "*+"

#: ../../library/re.rst:157
msgid "++"
msgstr "++"

#: ../../library/re.rst:157
msgid "?+"
msgstr "?+"

#: ../../library/re.rst:181
msgid "{} (curly brackets)"
msgstr "{} (chaves)"

#: ../../library/re.rst:220 ../../library/re.rst:258 ../../library/re.rst:531
msgid "\\ (backslash)"
msgstr "\\ (contrabarra)"

#: ../../library/re.rst:235
msgid "[] (square brackets)"
msgstr "[] (colchetes)"

#: ../../library/re.rst:244
msgid "- (minus)"
msgstr "- (menos)"

#: ../../library/re.rst:304
msgid "| (vertical bar)"
msgstr "| (barra vertical)"

#: ../../library/re.rst:317
msgid "() (parentheses)"
msgstr "() (parênteses)"

#: ../../library/re.rst:327
msgid "(?"
msgstr "(?"

#: ../../library/re.rst:359
msgid "(?:"
msgstr "(?:"

#: ../../library/re.rst:414
msgid "(?P<"
msgstr "(?P<"

#: ../../library/re.rst:446
msgid "(?P="
msgstr "(?P="

#: ../../library/re.rst:452
msgid "(?#"
msgstr "(?#"

#: ../../library/re.rst:457
msgid "(?="
msgstr "(?="

#: ../../library/re.rst:464
msgid "(?!"
msgstr "(?!"

#: ../../library/re.rst:471
msgid "(?<="
msgstr "(?<="

#: ../../library/re.rst:498
msgid "(?<!"
msgstr "(?<!"

#: ../../library/re.rst:508
msgid "(?("
msgstr "(?("

#: ../../library/re.rst:543
msgid "\\A"
msgstr "\\A"

#: ../../library/re.rst:548 ../../library/re.rst:672
msgid "\\b"
msgstr "\\b"

#: ../../library/re.rst:570
msgid "\\B"
msgstr "\\B"

#: ../../library/re.rst:590
msgid "\\d"
msgstr "\\d"

#: ../../library/re.rst:606
msgid "\\D"
msgstr "\\D"

#: ../../library/re.rst:614
msgid "\\s"
msgstr "\\s"

#: ../../library/re.rst:628
msgid "\\S"
msgstr "\\S"

#: ../../library/re.rst:636
msgid "\\w"
msgstr "\\w"

#: ../../library/re.rst:653
msgid "\\W"
msgstr "\\W"

#: ../../library/re.rst:667
msgid "\\Z"
msgstr "\\Z"

#: ../../library/re.rst:672
msgid "\\a"
msgstr "\\a"

#: ../../library/re.rst:672
msgid "\\f"
msgstr "\\f"

#: ../../library/re.rst:672
msgid "\\n"
msgstr "\\n"

#: ../../library/re.rst:672
msgid "\\r"
msgstr "\\r"

#: ../../library/re.rst:672
msgid "\\t"
msgstr "\\t"

#: ../../library/re.rst:672
msgid "\\u"
msgstr "\\u"

#: ../../library/re.rst:672
msgid "\\U"
msgstr "\\U"

#: ../../library/re.rst:672
msgid "\\v"
msgstr "\\v"

#: ../../library/re.rst:672
msgid "\\x"
msgstr "\\x"

#: ../../library/re.rst:672
msgid "\\\\"
msgstr "\\\\"

#: ../../library/re.rst:863
msgid "# (hash)"
msgstr "# (cerquilha)"

#: ../../library/re.rst:1099
msgid "\\g"
msgstr "\\g"

#: ../../library/re.rst:1647
msgid "scanf (C function)"
msgstr "scanf (função C)"

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2017
# Raphael Mendonça, 2018
# Marco Rougeth <marco@rougeth.com>, 2020
# Rafael Fontenelle <rffontenelle@gmail.com>, 2020
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-03-01 12:50+0000\n"
"PO-Revision-Date: 2017-02-16 23:06+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2020\n"
"Language-Team: Portuguese (Brazil) (https://www.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../library/decimal.rst:2
msgid ":mod:`decimal` --- Decimal fixed point and floating point arithmetic"
msgstr ":mod:`decimal` --- Aritmética de ponto fixo decimal e ponto flutuante"

#: ../../library/decimal.rst:15
msgid "**Source code:** :source:`Lib/decimal.py`"
msgstr "**Código-fonte:** :source:`Lib/decimal.py`"

#: ../../library/decimal.rst:33
msgid ""
"The :mod:`decimal` module provides support for fast correctly-rounded "
"decimal floating point arithmetic. It offers several advantages over the :"
"class:`float` datatype:"
msgstr ""
"O módulo :mod:`decimal` fornece suporte a aritmética rápida de ponto "
"flutuante decimal corretamente arredondado. Oferece várias vantagens sobre o "
"tipo de dados :class:`float`:"

#: ../../library/decimal.rst:37
msgid ""
"Decimal \"is based on a floating-point model which was designed with people "
"in mind, and necessarily has a paramount guiding principle -- computers must "
"provide an arithmetic that works in the same way as the arithmetic that "
"people learn at school.\" -- excerpt from the decimal arithmetic "
"specification."
msgstr ""
"Decimal \"é baseado em um modelo de ponto flutuante que foi projetado com as "
"pessoas em mente e necessariamente tem um princípio orientador primordial -- "
"os computadores devem fornecer uma aritmética que funcione da mesma maneira "
"que a aritmética que as pessoas aprendem na escola\". -- trecho da "
"especificação aritmética decimal."

#: ../../library/decimal.rst:42
msgid ""
"Decimal numbers can be represented exactly.  In contrast, numbers like :"
"const:`1.1` and :const:`2.2` do not have exact representations in binary "
"floating point. End users typically would not expect ``1.1 + 2.2`` to "
"display as :const:`3.3000000000000003` as it does with binary floating point."
msgstr ""
"Os números decimais podem ser representados exatamente. Por outro lado, "
"números como :const:`1.1` e :const:`2.2` não possuem representações exatas "
"em ponto flutuante binário. Os usuários finais normalmente não esperam que "
"``1.1 + 2.2`` sejam exibidos como :const:`3.3000000000000003`, como acontece "
"com o ponto flutuante binário."

#: ../../library/decimal.rst:47
msgid ""
"The exactness carries over into arithmetic.  In decimal floating point, "
"``0.1 + 0.1 + 0.1 - 0.3`` is exactly equal to zero.  In binary floating "
"point, the result is :const:`5.5511151231257827e-017`.  While near to zero, "
"the differences prevent reliable equality testing and differences can "
"accumulate. For this reason, decimal is preferred in accounting applications "
"which have strict equality invariants."
msgstr ""
"A exatidão transita para a aritmética. No ponto flutuante decimal, ``0.1 + "
"0.1 + 0.1 - 0.3`` é exatamente igual a zero. No ponto flutuante binário, o "
"resultado é :const:`5.5511151231257827e-017`. Embora próximas de zero, as "
"diferenças impedem o teste de igualdade confiável e as diferenças podem se "
"acumular. Por esse motivo, o decimal é preferido em aplicativos de "
"contabilidade que possuem invariáveis estritos de igualdade."

#: ../../library/decimal.rst:54
msgid ""
"The decimal module incorporates a notion of significant places so that "
"``1.30 + 1.20`` is :const:`2.50`.  The trailing zero is kept to indicate "
"significance. This is the customary presentation for monetary applications. "
"For multiplication, the \"schoolbook\" approach uses all the figures in the "
"multiplicands.  For instance, ``1.3 * 1.2`` gives :const:`1.56` while ``1.30 "
"* 1.20`` gives :const:`1.5600`."
msgstr ""
"O módulo decimal incorpora uma noção de casas significativas para que ``1.30 "
"+ 1.20`` seja :const:`2.50`. O zero à direita é mantido para indicar "
"significância. Esta é a apresentação habitual para aplicações monetárias. "
"Para multiplicação, a abordagem \"livro escolar\" usa todas as figuras nos "
"multiplicandos. Por exemplo, ``1.3 * 1.2`` é igual a :const:`1.56` enquanto "
"``1.30 * 1.20`` é igual a :const:`1.5600`."

#: ../../library/decimal.rst:61
msgid ""
"Unlike hardware based binary floating point, the decimal module has a user "
"alterable precision (defaulting to 28 places) which can be as large as "
"needed for a given problem:"
msgstr ""
"Diferentemente do ponto flutuante binário baseado em hardware, o módulo "
"decimal possui uma precisão alterável pelo usuário (padrão de 28 casas), que "
"pode ser tão grande quanto necessário para um determinado problema:"

#: ../../library/decimal.rst:73
msgid ""
"Both binary and decimal floating point are implemented in terms of published "
"standards.  While the built-in float type exposes only a modest portion of "
"its capabilities, the decimal module exposes all required parts of the "
"standard. When needed, the programmer has full control over rounding and "
"signal handling. This includes an option to enforce exact arithmetic by "
"using exceptions to block any inexact operations."
msgstr ""
"O ponto flutuante binário e decimal é implementado em termos de padrões "
"publicados. Enquanto o tipo ponto flutuante embutido expõe apenas uma parte "
"modesta de seus recursos, o módulo decimal expõe todas as partes necessárias "
"do padrão. Quando necessário, o programador tem controle total sobre o "
"arredondamento e o manuseio do sinal. Isso inclui uma opção para impor "
"aritmética exata usando exceções para bloquear quaisquer operações inexatas."

#: ../../library/decimal.rst:80
msgid ""
"The decimal module was designed to support \"without prejudice, both exact "
"unrounded decimal arithmetic (sometimes called fixed-point arithmetic) and "
"rounded floating-point arithmetic.\"  -- excerpt from the decimal arithmetic "
"specification."
msgstr ""
"O módulo decimal foi projetado para dar suporte, \"sem prejuízo, a "
"aritmética decimal não arredondada exata (às vezes chamada aritmética de "
"ponto fixo) e aritmética arredondada de ponto flutuante\". -- trecho da "
"especificação aritmética decimal."

#: ../../library/decimal.rst:85
msgid ""
"The module design is centered around three concepts:  the decimal number, "
"the context for arithmetic, and signals."
msgstr ""
"O design do módulo é centrado em torno de três conceitos: o número decimal, "
"o contexto da aritmética e os sinais."

#: ../../library/decimal.rst:88
msgid ""
"A decimal number is immutable.  It has a sign, coefficient digits, and an "
"exponent.  To preserve significance, the coefficient digits do not truncate "
"trailing zeros.  Decimals also include special values such as :const:"
"`Infinity`, :const:`-Infinity`, and :const:`NaN`.  The standard also "
"differentiates :const:`-0` from :const:`+0`."
msgstr ""
"Um número decimal é imutável. Possui um sinal, dígitos de coeficiente e um "
"expoente. Para preservar a significância, os dígitos do coeficiente não "
"truncam zeros à direita. Os decimais também incluem valores especiais, tais "
"como :const:`Infinity`, :const:`-Infinity` e :const:`NaN`. O padrão também "
"diferencia :const:`-0` de :const:`+0`."

#: ../../library/decimal.rst:94
msgid ""
"The context for arithmetic is an environment specifying precision, rounding "
"rules, limits on exponents, flags indicating the results of operations, and "
"trap enablers which determine whether signals are treated as exceptions.  "
"Rounding options include :const:`ROUND_CEILING`, :const:`ROUND_DOWN`, :const:"
"`ROUND_FLOOR`, :const:`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, :const:"
"`ROUND_HALF_UP`, :const:`ROUND_UP`, and :const:`ROUND_05UP`."
msgstr ""
"O contexto da aritmética é um ambiente que especifica precisão, regras de "
"arredondamento, limites de expoentes, sinalizadores indicando os resultados "
"das operações e ativadores de interceptação que determinam se os sinais são "
"tratados como exceções. As opções de arredondamento incluem :const:"
"`ROUND_CEILING`, :const:`ROUND_DOWN`, :const:`ROUND_FLOOR`, :const:"
"`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, :const:`ROUND_HALF_UP`, :const:"
"`ROUND_UP` e :const:`ROUND_05UP`."

#: ../../library/decimal.rst:101
msgid ""
"Signals are groups of exceptional conditions arising during the course of "
"computation.  Depending on the needs of the application, signals may be "
"ignored, considered as informational, or treated as exceptions. The signals "
"in the decimal module are: :const:`Clamped`, :const:`InvalidOperation`, :"
"const:`DivisionByZero`, :const:`Inexact`, :const:`Rounded`, :const:"
"`Subnormal`, :const:`Overflow`, :const:`Underflow` and :const:"
"`FloatOperation`."
msgstr ""
"Sinais são grupos de condições excepcionais que surgem durante o curso da "
"computação. Dependendo das necessidades do aplicativo, os sinais podem ser "
"ignorados, considerados informativos ou tratados como exceções. Os sinais no "
"módulo decimal são: :const:`Clamped`, :const:`InvalidOperation`, :const:"
"`DivisionByZero`, :const:`Inexact`, :const:`Rounded`, :const:`Subnormal`, :"
"const:`Overflow`, :const:`Underflow` e :const:`FloatOperation`."

#: ../../library/decimal.rst:108
msgid ""
"For each signal there is a flag and a trap enabler.  When a signal is "
"encountered, its flag is set to one, then, if the trap enabler is set to "
"one, an exception is raised.  Flags are sticky, so the user needs to reset "
"them before monitoring a calculation."
msgstr ""
"Para cada sinal, há um sinalizador e um ativador de interceptação. Quando um "
"sinal é encontrado, seu sinalizador é definido como um e, se o ativador de "
"interceptação estiver definido como um, uma exceção será gerada. Os "
"sinalizadores são fixos; portanto, o usuário precisa redefini-los antes de "
"monitorar um cálculo."

#: ../../library/decimal.rst:116
msgid ""
"IBM's General Decimal Arithmetic Specification, `The General Decimal "
"Arithmetic Specification <http://speleotrove.com/decimal/decarith.html>`_."
msgstr ""
"A especificação geral aritmética decimal da IBM, `The General Decimal "
"Arithmetic Specification <http://speleotrove.com/decimal/decarith.html>`_."

#: ../../library/decimal.rst:125
msgid "Quick-start Tutorial"
msgstr "Tutorial de início rápido"

#: ../../library/decimal.rst:127
msgid ""
"The usual start to using decimals is importing the module, viewing the "
"current context with :func:`getcontext` and, if necessary, setting new "
"values for precision, rounding, or enabled traps::"
msgstr ""
"O início usual do uso de decimais é importar o módulo, exibir o contexto "
"atual com :func:`getcontext` e, se necessário, definir novos valores para "
"precisão, arredondamento ou armadilhas ativados::"

#: ../../library/decimal.rst:139
msgid ""
"Decimal instances can be constructed from integers, strings, floats, or "
"tuples. Construction from an integer or a float performs an exact conversion "
"of the value of that integer or float.  Decimal numbers include special "
"values such as :const:`NaN` which stands for \"Not a number\", positive and "
"negative :const:`Infinity`, and :const:`-0`::"
msgstr ""
"Instâncias decimais podem ser construídas a partir de números inteiros, "
"strings, pontos flutuantes ou tuplas. A construção de um número inteiro ou "
"de um ponto flutuante realiza uma conversão exata do valor desse número "
"inteiro ou ponto flutuante. Os números decimais incluem valores especiais "
"como :const:`NaN`, que significa \"Não é um número\", :const:`Infinity` "
"positivo e negativo e :const:`-0`::"

#: ../../library/decimal.rst:163
msgid ""
"If the :exc:`FloatOperation` signal is trapped, accidental mixing of "
"decimals and floats in constructors or ordering comparisons raises an "
"exception::"
msgstr ""
"Se o sinal :exc:`FloatOperation` for capturado na armadilha, a mistura "
"acidental de decimais e pontos flutuantes em construtores ou comparações de "
"ordenação levanta uma exceção::"

#: ../../library/decimal.rst:182
msgid ""
"The significance of a new Decimal is determined solely by the number of "
"digits input.  Context precision and rounding only come into play during "
"arithmetic operations."
msgstr ""
"O significado de um novo decimal é determinado apenas pelo número de dígitos "
"inseridos. A precisão e o arredondamento do contexto só entram em jogo "
"durante operações aritméticas."

#: ../../library/decimal.rst:199
msgid ""
"If the internal limits of the C version are exceeded, constructing a decimal "
"raises :class:`InvalidOperation`::"
msgstr ""
"Se os limites internos da versão C forem excedidos, a construção de um "
"decimal levanta :class:`InvalidOperation`::"

#: ../../library/decimal.rst:209
msgid ""
"Decimals interact well with much of the rest of Python.  Here is a small "
"decimal floating point flying circus:"
msgstr ""
"Os decimais interagem bem com grande parte do resto do Python. Aqui está um "
"pequeno circo voador de ponto flutuante decimal:"

#: ../../library/decimal.rst:241
msgid "And some mathematical functions are also available to Decimal:"
msgstr "E algumas funções matemáticas também estão disponíveis no Decimal:"

#: ../../library/decimal.rst:253
msgid ""
"The :meth:`quantize` method rounds a number to a fixed exponent.  This "
"method is useful for monetary applications that often round results to a "
"fixed number of places:"
msgstr ""
"O método :meth:`quantize` arredonda um número para um expoente fixo. Esse "
"método é útil para aplicações monetárias que geralmente arredondam os "
"resultados para um número fixo de locais:"

#: ../../library/decimal.rst:262
msgid ""
"As shown above, the :func:`getcontext` function accesses the current context "
"and allows the settings to be changed.  This approach meets the needs of "
"most applications."
msgstr ""
"Como mostrado acima, a função :func:`getcontext` acessa o contexto atual e "
"permite que as configurações sejam alteradas. Essa abordagem atende às "
"necessidades da maioria das aplicações."

#: ../../library/decimal.rst:266
msgid ""
"For more advanced work, it may be useful to create alternate contexts using "
"the Context() constructor.  To make an alternate active, use the :func:"
"`setcontext` function."
msgstr ""
"Para trabalhos mais avançados, pode ser útil criar contextos alternativos "
"usando o construtor Context(). Para ativar uma alternativa, use a função :"
"func:`setcontext`."

#: ../../library/decimal.rst:270
msgid ""
"In accordance with the standard, the :mod:`decimal` module provides two "
"ready to use standard contexts, :const:`BasicContext` and :const:"
"`ExtendedContext`. The former is especially useful for debugging because "
"many of the traps are enabled:"
msgstr ""
"De acordo com o padrão, o módulo :mod:`decimal` fornece dois contextos "
"padrão prontos para uso, :const:`BasicContext` e :const:`ExtendedContext`. O "
"primeiro é especialmente útil para depuração porque muitas das armadilhas "
"estão ativadas:"

#: ../../library/decimal.rst:299
msgid ""
"Contexts also have signal flags for monitoring exceptional conditions "
"encountered during computations.  The flags remain set until explicitly "
"cleared, so it is best to clear the flags before each set of monitored "
"computations by using the :meth:`clear_flags` method. ::"
msgstr ""
"Os contextos também possuem sinalizadores para monitorar condições "
"excepcionais encontradas durante os cálculos. Os sinalizadores permanecem "
"definidos até que sejam explicitamente limpos, portanto, é melhor limpar os "
"sinalizadores antes de cada conjunto de cálculos monitorados usando o "
"método :meth:`clear_flags`. ::"

#: ../../library/decimal.rst:312
msgid ""
"The *flags* entry shows that the rational approximation to :const:`Pi` was "
"rounded (digits beyond the context precision were thrown away) and that the "
"result is inexact (some of the discarded digits were non-zero)."
msgstr ""
"A entrada *flags* mostra que a aproximação racional de :const:`Pi` foi "
"arredondada (dígitos além da precisão do contexto foram descartados) e que o "
"resultado é inexato (alguns dos dígitos descartados eram diferentes de zero)."

#: ../../library/decimal.rst:316
msgid ""
"Individual traps are set using the dictionary in the :attr:`traps` field of "
"a context:"
msgstr ""
"As armadilhas individuais são definidas usando o dicionário no campo :attr:"
"`traps` de um contexto:"

#: ../../library/decimal.rst:331
msgid ""
"Most programs adjust the current context only once, at the beginning of the "
"program.  And, in many applications, data is converted to :class:`Decimal` "
"with a single cast inside a loop.  With context set and decimals created, "
"the bulk of the program manipulates the data no differently than with other "
"Python numeric types."
msgstr ""
"A maioria dos programas ajusta o contexto atual apenas uma vez, no início do "
"programa. E, em muitas aplicações, os dados são convertidos para :class:"
"`Decimal` com uma única conversão dentro de um loop. Com o conjunto de "
"contextos e decimais criados, a maior parte do programa manipula os dados de "
"maneira diferente do que com outros tipos numéricos do Python."

#: ../../library/decimal.rst:343
msgid "Decimal objects"
msgstr "Objetos de Decimal"

#: ../../library/decimal.rst:348
msgid "Construct a new :class:`Decimal` object based from *value*."
msgstr "Constrói um novo objeto de :class:`Decimal` com base em *value*."

#: ../../library/decimal.rst:350
msgid ""
"*value* can be an integer, string, tuple, :class:`float`, or another :class:"
"`Decimal` object. If no *value* is given, returns ``Decimal('0')``.  If "
"*value* is a string, it should conform to the decimal numeric string syntax "
"after leading and trailing whitespace characters, as well as underscores "
"throughout, are removed::"
msgstr ""
"*value* pode ser um inteiro, string, tupla, :class:`float` ou outro objeto "
"de :class:`Decimal`. Se nenhum *value* for fornecido, retornará "
"``Decimal('0')``. Se *value* for uma string, ele deverá estar em "
"conformidade com a sintaxe da string numérica decimal após caracteres de "
"espaço em branco à esquerda e à direita, bem como sublinhados em toda parte, "
"serem removidos::"

#: ../../library/decimal.rst:366
msgid ""
"Other Unicode decimal digits are also permitted where ``digit`` appears "
"above.  These include decimal digits from various other alphabets (for "
"example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits "
"``'\\uff10'`` through ``'\\uff19'``."
msgstr ""
"Outros dígitos decimais Unicode também são permitidos onde ``digit`` aparece "
"acima. Isso inclui dígitos decimais de vários outros alfabetos (por exemplo, "
"dígitos em árabes-índicos e devanágaris), além dos dígitos de largura total "
"``'\\uff10'`` a ``'\\uff19'``."

#: ../../library/decimal.rst:371
msgid ""
"If *value* is a :class:`tuple`, it should have three components, a sign (:"
"const:`0` for positive or :const:`1` for negative), a :class:`tuple` of "
"digits, and an integer exponent. For example, ``Decimal((0, (1, 4, 1, 4), "
"-3))`` returns ``Decimal('1.414')``."
msgstr ""
"Se *value* for um :class:`tuple`, ele deverá ter três componentes, um sinal "
"(:const:`0` para positivo ou :const:`1` para negativo), um :class:`tuple` de "
"dígitos e um expoente inteiro. Por exemplo, ``Decimal((0, (1, 4, 1, 4), "
"-3))`` returna ``Decimal('1.414')``."

#: ../../library/decimal.rst:376
msgid ""
"If *value* is a :class:`float`, the binary floating point value is "
"losslessly converted to its exact decimal equivalent.  This conversion can "
"often require 53 or more digits of precision.  For example, "
"``Decimal(float('1.1'))`` converts to "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``."
msgstr ""
"Se *value* é um :class:`float`, o valor do ponto flutuante binário é "
"convertido sem perdas no seu equivalente decimal exato. Essa conversão "
"geralmente requer 53 ou mais dígitos de precisão. Por exemplo, "
"``Decimal(float('1.1'))`` converte para "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``."

#: ../../library/decimal.rst:382
msgid ""
"The *context* precision does not affect how many digits are stored. That is "
"determined exclusively by the number of digits in *value*. For example, "
"``Decimal('3.00000')`` records all five zeros even if the context precision "
"is only three."
msgstr ""
"A precisão *context* não afeta quantos dígitos estão armazenados. Isso é "
"determinado exclusivamente pelo número de dígitos em *value*. Por exemplo, "
"``Decimal('3.00000')`` registra todos os cinco zeros, mesmo que a precisão "
"do contexto seja apenas três."

#: ../../library/decimal.rst:387
msgid ""
"The purpose of the *context* argument is determining what to do if *value* "
"is a malformed string.  If the context traps :const:`InvalidOperation`, an "
"exception is raised; otherwise, the constructor returns a new Decimal with "
"the value of :const:`NaN`."
msgstr ""
"O objetivo do argumento *context* é determinar o que fazer se *value* for "
"uma string malformada. Se o contexto capturar :const:`InvalidOperation`, uma "
"exceção será levantada; caso contrário, o construtor retornará um novo "
"decimal com o valor de :const:`NaN`."

#: ../../library/decimal.rst:392
msgid "Once constructed, :class:`Decimal` objects are immutable."
msgstr "Uma vez construídos, objetos de :class:`Decimal` são imutáveis."

#: ../../library/decimal.rst:394
msgid ""
"The argument to the constructor is now permitted to be a :class:`float` "
"instance."
msgstr ""
"O argumento para o construtor agora pode ser uma instância de :class:`float`."

#: ../../library/decimal.rst:398
msgid ""
":class:`float` arguments raise an exception if the :exc:`FloatOperation` "
"trap is set. By default the trap is off."
msgstr ""
"Os argumentos de :class:`float` levantam uma exceção se a armadilha :exc:"
"`FloatOperation` estiver definida. Por padrão, a armadilha está desativada."

#: ../../library/decimal.rst:402
msgid ""
"Underscores are allowed for grouping, as with integral and floating-point "
"literals in code."
msgstr ""
"Sublinhados são permitidos para agrupamento, como nos literais de ponto "
"flutuante e integral no código."

#: ../../library/decimal.rst:406
msgid ""
"Decimal floating point objects share many properties with the other built-in "
"numeric types such as :class:`float` and :class:`int`.  All of the usual "
"math operations and special methods apply.  Likewise, decimal objects can be "
"copied, pickled, printed, used as dictionary keys, used as set elements, "
"compared, sorted, and coerced to another type (such as :class:`float` or :"
"class:`int`)."
msgstr ""
"Objetos decimais de ponto flutuante compartilham muitas propriedades com "
"outros tipos numéricos internos, como :class:`float` e :class:`int`. Todas "
"as operações matemáticas usuais e métodos especiais se aplicam. Da mesma "
"forma, objetos decimais podem ser copiados, separados, impressos, usados "
"como chaves de dicionário, usados como elementos de conjunto, comparados, "
"classificados e coagidos a outro tipo (como :class:`float` ou :class:`int`)."

#: ../../library/decimal.rst:413
msgid ""
"There are some small differences between arithmetic on Decimal objects and "
"arithmetic on integers and floats.  When the remainder operator ``%`` is "
"applied to Decimal objects, the sign of the result is the sign of the "
"*dividend* rather than the sign of the divisor::"
msgstr ""
"Existem algumas pequenas diferenças entre aritmética em objetos decimais e "
"aritmética em números inteiros e flutuantes. Quando o operador de resto ``"
"%`` é aplicado a objetos decimais, o sinal do resultado é o sinal do "
"*dividend* em vez do sinal do divisor::"

#: ../../library/decimal.rst:423
msgid ""
"The integer division operator ``//`` behaves analogously, returning the "
"integer part of the true quotient (truncating towards zero) rather than its "
"floor, so as to preserve the usual identity ``x == (x // y) * y + x % y``::"
msgstr ""
"O operador de divisão inteira ``//`` se comporta de maneira análoga, "
"retornando a parte inteira do quociente verdadeiro (truncando em direção a "
"zero) em vez de seu resto, de modo a preservar a identidade usual ``x == "
"(x // y) * y + x % y``::"

#: ../../library/decimal.rst:432
msgid ""
"The ``%`` and ``//`` operators implement the ``remainder`` and ``divide-"
"integer`` operations (respectively) as described in the specification."
msgstr ""
"Os operadores ``%`` e ``//`` implementam as operações ``módulo`` e ``divisão "
"inteira`` (respectivamente) como descrito na especificação."

#: ../../library/decimal.rst:436
msgid ""
"Decimal objects cannot generally be combined with floats or instances of :"
"class:`fractions.Fraction` in arithmetic operations: an attempt to add a :"
"class:`Decimal` to a :class:`float`, for example, will raise a :exc:"
"`TypeError`.  However, it is possible to use Python's comparison operators "
"to compare a :class:`Decimal` instance ``x`` with another number ``y``.  "
"This avoids confusing results when doing equality comparisons between "
"numbers of different types."
msgstr ""
"Objetos decimais geralmente não podem ser combinados com pontos flutuantes "
"ou instâncias de :class:`fractions.Fraction` em operações aritméticas: uma "
"tentativa de adicionar um :class:`Decimal` a um :class:`float`, por exemplo, "
"vai levantar um :exc:`TypeError`. No entanto, é possível usar os operadores "
"de comparação do Python para comparar uma instância de :class:`Decimal` "
"``x`` com outro número ``y``. Isso evita resultados confusos ao fazer "
"comparações de igualdade entre números de tipos diferentes."

#: ../../library/decimal.rst:444
msgid ""
"Mixed-type comparisons between :class:`Decimal` instances and other numeric "
"types are now fully supported."
msgstr ""
"As comparações de tipos mistos entre instâncias de :class:`Decimal` e outros "
"tipos numéricos agora são totalmente suportadas."

#: ../../library/decimal.rst:448
msgid ""
"In addition to the standard numeric properties, decimal floating point "
"objects also have a number of specialized methods:"
msgstr ""
"Além das propriedades numéricas padrão, os objetos de ponto flutuante "
"decimal também possuem vários métodos especializados:"

#: ../../library/decimal.rst:454
msgid ""
"Return the adjusted exponent after shifting out the coefficient's rightmost "
"digits until only the lead digit remains: ``Decimal('321e+5').adjusted()`` "
"returns seven.  Used for determining the position of the most significant "
"digit with respect to the decimal point."
msgstr ""
"Retorna o expoente ajustado depois de deslocar os dígitos mais à direita do "
"coeficiente até restar apenas o dígito principal: ``Decimal('321e+5')."
"adjusted()`` retorna sete. Usado para determinar a posição do dígito mais "
"significativo em relação ao ponto decimal."

#: ../../library/decimal.rst:461
msgid ""
"Return a pair ``(n, d)`` of integers that represent the given :class:"
"`Decimal` instance as a fraction, in lowest terms and with a positive "
"denominator::"
msgstr ""
"Retorna um par ``(n, d)`` de números inteiros que representam a instância "
"dada :class:`Decimal` como uma fração, nos termos mais baixos e com um "
"denominador positivo::"

#: ../../library/decimal.rst:468
msgid ""
"The conversion is exact.  Raise OverflowError on infinities and ValueError "
"on NaNs."
msgstr ""
"A conversão é exata. Levanta OverflowError em infinitos e ValueError em NaNs."

#: ../../library/decimal.rst:475
msgid ""
"Return a :term:`named tuple` representation of the number: "
"``DecimalTuple(sign, digits, exponent)``."
msgstr ""
"Retorna uma representação de :term:`tupla nomeada <named tuple>` do número: "
"``DecimalTuple(sign, digits, exponent)``."

#: ../../library/decimal.rst:481
msgid ""
"Return the canonical encoding of the argument.  Currently, the encoding of "
"a :class:`Decimal` instance is always canonical, so this operation returns "
"its argument unchanged."
msgstr ""
"Retorna a codificação canônica do argumento. Atualmente, a codificação de "
"uma instância de :class:`Decimal` é sempre canônica, portanto, esta operação "
"retorna seu argumento inalterado."

#: ../../library/decimal.rst:487
msgid ""
"Compare the values of two Decimal instances.  :meth:`compare` returns a "
"Decimal instance, and if either operand is a NaN then the result is a NaN::"
msgstr ""
"Compara os valores de duas instâncias decimais. :meth:`compare` retorna uma "
"instância decimal, e se qualquer operando for um NaN, o resultado será um "
"NaN::"

#: ../../library/decimal.rst:498
msgid ""
"This operation is identical to the :meth:`compare` method, except that all "
"NaNs signal.  That is, if neither operand is a signaling NaN then any quiet "
"NaN operand is treated as though it were a signaling NaN."
msgstr ""
"Esta operação é idêntica ao método :meth:`compare`, exceto que todos os NaNs "
"sinalizam. Ou seja, se nenhum operando for um NaN sinalizador, qualquer "
"operando NaN silencioso será tratado como se fosse um NaN sinalizador."

#: ../../library/decimal.rst:504
msgid ""
"Compare two operands using their abstract representation rather than their "
"numerical value.  Similar to the :meth:`compare` method, but the result "
"gives a total ordering on :class:`Decimal` instances.  Two :class:`Decimal` "
"instances with the same numeric value but different representations compare "
"unequal in this ordering:"
msgstr ""
"Compara dois operandos usando sua representação abstrata em vez de seu valor "
"numérico. Semelhante ao método :meth:`compare`, mas o resultado fornece uma "
"ordem total nas instâncias de :class:`Decimal`. Duas instâncias de :class:"
"`Decimal` com o mesmo valor numérico, mas diferentes representações, se "
"comparam desiguais nesta ordem:"

#: ../../library/decimal.rst:513
msgid ""
"Quiet and signaling NaNs are also included in the total ordering.  The "
"result of this function is ``Decimal('0')`` if both operands have the same "
"representation, ``Decimal('-1')`` if the first operand is lower in the total "
"order than the second, and ``Decimal('1')`` if the first operand is higher "
"in the total order than the second operand.  See the specification for "
"details of the total order."
msgstr ""
"Os NaNs silenciosos e sinalizadores também estão incluídos no pedido total. "
"O resultado dessa função é ``Decimal('0')`` se os dois operandos tiverem a "
"mesma representação, ``Decimal('-1')`` se o primeiro operando for menor na "
"ordem total que o segundo e ``Decimal('1')`` se o primeiro operando for "
"maior na ordem total que o segundo operando. Veja a especificação para "
"detalhes da ordem total."

#: ../../library/decimal.rst:520 ../../library/decimal.rst:531
#: ../../library/decimal.rst:559 ../../library/decimal.rst:834
msgid ""
"This operation is unaffected by context and is quiet: no flags are changed "
"and no rounding is performed.  As an exception, the C version may raise "
"InvalidOperation if the second operand cannot be converted exactly."
msgstr ""
"Esta operação não é afetada pelo contexto e é silenciosa: nenhum sinalizador "
"é alterado e nenhum arredondamento é executado. Como uma exceção, a versão C "
"pode levantar InvalidOperation se o segundo operando não puder ser "
"convertido exatamente."

#: ../../library/decimal.rst:526
msgid ""
"Compare two operands using their abstract representation rather than their "
"value as in :meth:`compare_total`, but ignoring the sign of each operand. "
"``x.compare_total_mag(y)`` is equivalent to ``x.copy_abs().compare_total(y."
"copy_abs())``."
msgstr ""
"Compara dois operandos usando sua representação abstrata em vez de seu "
"valor, como em :meth:`compare_total`, mas ignorando o sinal de cada "
"operando. ``x.compare_total_mag(y)`` é equivalente a ``x.copy_abs()."
"compare_total(y.copy_abs())``."

#: ../../library/decimal.rst:537
msgid ""
"Just returns self, this method is only to comply with the Decimal "
"Specification."
msgstr ""
"Apenas retorna a si próprio, sendo esse método apenas para atender à "
"Especificação de Decimal."

#: ../../library/decimal.rst:542
msgid ""
"Return the absolute value of the argument.  This operation is unaffected by "
"the context and is quiet: no flags are changed and no rounding is performed."
msgstr ""
"Retorna o valor absoluto do argumento. Esta operação não é afetada pelo "
"contexto e é silenciosa: nenhum sinalizador é alterado e nenhum "
"arredondamento é executado."

#: ../../library/decimal.rst:548
msgid ""
"Return the negation of the argument.  This operation is unaffected by the "
"context and is quiet: no flags are changed and no rounding is performed."
msgstr ""
"Retorna a negação do argumento. Esta operação não é afetada pelo contexto e "
"é silenciosa: nenhum sinalizador é alterado e nenhum arredondamento é "
"executado."

#: ../../library/decimal.rst:553
msgid ""
"Return a copy of the first operand with the sign set to be the same as the "
"sign of the second operand.  For example:"
msgstr ""
"Retorna uma cópia do primeiro operando com o sinal definido para ser o mesmo "
"que o sinal do segundo operando. Por exemplo:"

#: ../../library/decimal.rst:565
msgid ""
"Return the value of the (natural) exponential function ``e**x`` at the given "
"number.  The result is correctly rounded using the :const:`ROUND_HALF_EVEN` "
"rounding mode."
msgstr ""
"Retorna o valor da função exponencial (natural) ``e**x`` no número "
"especificado. O resultado é arredondado corretamente usando o modo de "
"arredondamento :const:`ROUND_HALF_EVEN`."

#: ../../library/decimal.rst:576
msgid "Classmethod that converts a float to a decimal number, exactly."
msgstr ""
"Método de classe que converte um ponto flutuante em um número decimal, "
"exatamente."

#: ../../library/decimal.rst:578
msgid ""
"Note `Decimal.from_float(0.1)` is not the same as `Decimal('0.1')`. Since "
"0.1 is not exactly representable in binary floating point, the value is "
"stored as the nearest representable value which is `0x1.999999999999ap-4`.  "
"That equivalent value in decimal is "
"`0.1000000000000000055511151231257827021181583404541015625`."
msgstr ""
"Observe que `Decimal.from_float(0.1)` não é o mesmo que `Decimal('0.1')`. "
"Como 0.1 não é exatamente representável no ponto flutuante binário, o valor "
"é armazenado como o valor representável mais próximo que é "
"`0x1.999999999999ap-4`. Esse valor equivalente em decimal é "
"`0.1000000000000000055511151231257827021181583404541015625`."

#: ../../library/decimal.rst:584
msgid ""
"From Python 3.2 onwards, a :class:`Decimal` instance can also be constructed "
"directly from a :class:`float`."
msgstr ""
"A partir do Python 3.2 em diante, uma instância de :class:`Decimal` também "
"pode ser construída diretamente a partir de um :class:`float`."

#: ../../library/decimal.rst:602
msgid ""
"Fused multiply-add.  Return self*other+third with no rounding of the "
"intermediate product self*other."
msgstr ""
"Multiplicação e adição fundidos. Retorna self*other+third sem arredondamento "
"do produto intermediário self*other."

#: ../../library/decimal.rst:610
msgid ""
"Return :const:`True` if the argument is canonical and :const:`False` "
"otherwise.  Currently, a :class:`Decimal` instance is always canonical, so "
"this operation always returns :const:`True`."
msgstr ""
"Retorna :const:`True` se o argumento for canônico e :const:`False` caso "
"contrário. Atualmente, uma instância de :class:`Decimal` é sempre canônica, "
"portanto, esta operação sempre retorna :const:`True`."

#: ../../library/decimal.rst:616
msgid ""
"Return :const:`True` if the argument is a finite number, and :const:`False` "
"if the argument is an infinity or a NaN."
msgstr ""
"Retorna :const:`True` se o argumento for um número finito e :const:`False` "
"se o argumento for um infinito ou um NaN."

#: ../../library/decimal.rst:621
msgid ""
"Return :const:`True` if the argument is either positive or negative infinity "
"and :const:`False` otherwise."
msgstr ""
"Retorna :const:`True` se o argumento for infinito positivo ou negativo e :"
"const:`False` caso contrário."

#: ../../library/decimal.rst:626
msgid ""
"Return :const:`True` if the argument is a (quiet or signaling) NaN and :"
"const:`False` otherwise."
msgstr ""
"Retorna :const:`True` se o argumento for NaN (silencioso ou sinalizador) e :"
"const:`False` caso contrário."

#: ../../library/decimal.rst:631
msgid ""
"Return :const:`True` if the argument is a *normal* finite number.  Return :"
"const:`False` if the argument is zero, subnormal, infinite or a NaN."
msgstr ""
"Retorna :const:`True` se o argumento for um número finito *normal*. Retorna :"
"const:`False` se o argumento for zero, subnormal, infinito ou NaN."

#: ../../library/decimal.rst:636
msgid ""
"Return :const:`True` if the argument is a quiet NaN, and :const:`False` "
"otherwise."
msgstr ""
"Retorna :const:`True` se o argumento for um NaN silencioso, e :const:`False` "
"caso contrário."

#: ../../library/decimal.rst:641
msgid ""
"Return :const:`True` if the argument has a negative sign and :const:`False` "
"otherwise.  Note that zeros and NaNs can both carry signs."
msgstr ""
"Retorna :const:`True` se o argumento tiver um sinal negativo e :const:"
"`False` caso contrário. Observe que zeros e NaNs podem carregar sinais."

#: ../../library/decimal.rst:646
msgid ""
"Return :const:`True` if the argument is a signaling NaN and :const:`False` "
"otherwise."
msgstr ""
"Retorna :const:`True` se o argumento for um sinal NaN e :const:`False` caso "
"contrário."

#: ../../library/decimal.rst:651
msgid ""
"Return :const:`True` if the argument is subnormal, and :const:`False` "
"otherwise."
msgstr ""
"Retorna :const:`True` se o argumento for subnormal e :const:`False` caso "
"contrário."

#: ../../library/decimal.rst:656
msgid ""
"Return :const:`True` if the argument is a (positive or negative) zero and :"
"const:`False` otherwise."
msgstr ""
"Retorna :const:`True` se o argumento for um zero (positivo ou negativo) e :"
"const:`False` caso contrário."

#: ../../library/decimal.rst:661
msgid ""
"Return the natural (base e) logarithm of the operand.  The result is "
"correctly rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""
"Retorna o logaritmo (base e) natural do operando. O resultado é arredondado "
"corretamente usando o modo de arredondamento :const:`ROUND_HALF_EVEN`."

#: ../../library/decimal.rst:666
msgid ""
"Return the base ten logarithm of the operand.  The result is correctly "
"rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""
"Retorna o logaritmo da base dez do operando. O resultado é arredondado "
"corretamente usando o modo de arredondamento :const:`ROUND_HALF_EVEN`."

#: ../../library/decimal.rst:671
msgid ""
"For a nonzero number, return the adjusted exponent of its operand as a :"
"class:`Decimal` instance.  If the operand is a zero then ``Decimal('-"
"Infinity')`` is returned and the :const:`DivisionByZero` flag is raised.  If "
"the operand is an infinity then ``Decimal('Infinity')`` is returned."
msgstr ""
"Para um número diferente de zero, retorna o expoente ajustado de seu "
"operando como uma instância de :class:`Decimal`. Se o operando é zero, "
"``Decimal('-Infinity')`` é retornado e o sinalizador :const:`DivisionByZero` "
"é levantado. Se o operando for um infinito, ``Decimal('Infinity')`` será "
"retornado."

#: ../../library/decimal.rst:679
msgid ""
":meth:`logical_and` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"``and`` of the two operands."
msgstr ""
":meth:`logical_and` é uma operação lógica que leva dois *operandos lógicos* "
"(consulte :ref:`logical_operands_label`). O resultado é o ``and`` dígito a "
"dígito dos dois operandos."

#: ../../library/decimal.rst:685
msgid ""
":meth:`logical_invert` is a logical operation.  The result is the digit-wise "
"inversion of the operand."
msgstr ""
":meth:`logical_invert` é uma operação lógica. O resultado é a inversão "
"dígito a dígito do operando."

#: ../../library/decimal.rst:690
msgid ""
":meth:`logical_or` is a logical operation which takes two *logical operands* "
"(see :ref:`logical_operands_label`).  The result is the digit-wise ``or`` of "
"the two operands."
msgstr ""
":meth:`logical_or` é uma operação lógica que leva dois *operandos lógicos* "
"(consulte :ref:`logical_operands_label`). O resultado é o ``or`` dígito a "
"dígito dos dois operandos."

#: ../../library/decimal.rst:696
msgid ""
":meth:`logical_xor` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"exclusive or of the two operands."
msgstr ""
":meth:`logical_xor` é uma operação lógica que leva dois *operandos lógicos* "
"(consulte :ref:`logical_operands_label`). O resultado é o \"ou exclusivo\" "
"dígito a dígito ou dos dois operandos."

#: ../../library/decimal.rst:702
msgid ""
"Like ``max(self, other)`` except that the context rounding rule is applied "
"before returning and that :const:`NaN` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"Como ``max(self, other)``, exceto que a regra de arredondamento de contexto "
"é aplicada antes de retornar e que os valores :const:`NaN` são sinalizados "
"ou ignorados (dependendo do contexto e se estão sinalizando ou silenciosos)."

#: ../../library/decimal.rst:709
msgid ""
"Similar to the :meth:`.max` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ""
"Semelhante ao método :meth:`.max`, mas a comparação é feita usando os "
"valores absolutos dos operandos."

#: ../../library/decimal.rst:714
msgid ""
"Like ``min(self, other)`` except that the context rounding rule is applied "
"before returning and that :const:`NaN` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"Como ``min(self, other)``, exceto que a regra de arredondamento de contexto "
"é aplicada antes de retornar e que os valores :const:`NaN` são sinalizados "
"ou ignorados (dependendo do contexto e se estão sinalizando ou silenciosos)."

#: ../../library/decimal.rst:721
msgid ""
"Similar to the :meth:`.min` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ""
"Semelhante ao método :meth:`.min`, mas a comparação é feita usando os "
"valores absolutos dos operandos."

#: ../../library/decimal.rst:726
msgid ""
"Return the largest number representable in the given context (or in the "
"current thread's context if no context is given) that is smaller than the "
"given operand."
msgstr ""
"Retorna o maior número representável no contexto fornecido (ou no contexto "
"atual da thread, se nenhum contexto for fornecido) que seja menor que o "
"operando especificado."

#: ../../library/decimal.rst:732
msgid ""
"Return the smallest number representable in the given context (or in the "
"current thread's context if no context is given) that is larger than the "
"given operand."
msgstr ""
"Retorna o menor número representável no contexto fornecido (ou no contexto "
"atual da thread, se nenhum contexto for fornecido) que seja maior que o "
"operando fornecido."

#: ../../library/decimal.rst:738
msgid ""
"If the two operands are unequal, return the number closest to the first "
"operand in the direction of the second operand.  If both operands are "
"numerically equal, return a copy of the first operand with the sign set to "
"be the same as the sign of the second operand."
msgstr ""
"Se os dois operandos forem desiguais, retorna o número mais próximo ao "
"primeiro operando na direção do segundo operando. Se os dois operandos forem "
"numericamente iguais, retorna uma cópia do primeiro operando com o sinal "
"configurado para ser o mesmo que o sinal do segundo operando."

#: ../../library/decimal.rst:745
msgid ""
"Normalize the number by stripping the rightmost trailing zeros and "
"converting any result equal to :const:`Decimal('0')` to :const:"
"`Decimal('0e0')`. Used for producing canonical values for attributes of an "
"equivalence class. For example, ``Decimal('32.100')`` and "
"``Decimal('0.321000e+2')`` both normalize to the equivalent value "
"``Decimal('32.1')``."
msgstr ""
"Normaliza o número eliminando os zeros à direita e convertendo qualquer "
"resultado igual a :const:`Decimal('0')` para :const:`Decimal('0e0')`. Usado "
"para produzir valores canônicos para atributos de uma classe de "
"equivalência. Por exemplo, ``Decimal('32.100')`` e ``Decimal('0.321000e"
"+2')`` normalizam com o valor equivalente ``Decimal('32.1')``."

#: ../../library/decimal.rst:754
msgid ""
"Return a string describing the *class* of the operand.  The returned value "
"is one of the following ten strings."
msgstr ""
"Retorna uma string descrevendo a *classe* do operando. O valor retornado é "
"uma das dez sequências a seguir."

#: ../../library/decimal.rst:757
msgid "``\"-Infinity\"``, indicating that the operand is negative infinity."
msgstr "``\"-Infinity\"``, indicando que o operando é infinito negativo."

#: ../../library/decimal.rst:758
msgid ""
"``\"-Normal\"``, indicating that the operand is a negative normal number."
msgstr "``\"-Normal\"``, indicando que o operando é um número normal negativo."

#: ../../library/decimal.rst:759
msgid ""
"``\"-Subnormal\"``, indicating that the operand is negative and subnormal."
msgstr "``\"-Subnormal\"``, indicando que o operando é negativo e subnormal."

#: ../../library/decimal.rst:760
msgid "``\"-Zero\"``, indicating that the operand is a negative zero."
msgstr "``\"-Zero\"``, indicando que o operando é um zero negativo."

#: ../../library/decimal.rst:761
msgid "``\"+Zero\"``, indicating that the operand is a positive zero."
msgstr "``\"+Zero\"``, indicando que o operando é um zero positivo."

#: ../../library/decimal.rst:762
msgid ""
"``\"+Subnormal\"``, indicating that the operand is positive and subnormal."
msgstr "``\"+Subnormal\"``, indicando que o operando é positivo e subnormal."

#: ../../library/decimal.rst:763
msgid ""
"``\"+Normal\"``, indicating that the operand is a positive normal number."
msgstr "``\"+Normal\"``, indicando que o operando é um número normal positivo."

#: ../../library/decimal.rst:764
msgid "``\"+Infinity\"``, indicating that the operand is positive infinity."
msgstr "``\"+Infinity\"``, indicando que o operando é infinito positivo."

#: ../../library/decimal.rst:765
msgid "``\"NaN\"``, indicating that the operand is a quiet NaN (Not a Number)."
msgstr ""
"``\"NaN\"``, indicando que o operando é um NaN (\"Not a Number\") silencioso."

#: ../../library/decimal.rst:766
msgid "``\"sNaN\"``, indicating that the operand is a signaling NaN."
msgstr "``\"sNaN\"``, indicando que o operando é um NaN sinalizador."

#: ../../library/decimal.rst:770
msgid ""
"Return a value equal to the first operand after rounding and having the "
"exponent of the second operand."
msgstr ""
"Retorna um valor igual ao primeiro operando após o arredondamento e com o "
"expoente do segundo operando."

#: ../../library/decimal.rst:776
msgid ""
"Unlike other operations, if the length of the coefficient after the quantize "
"operation would be greater than precision, then an :const:`InvalidOperation` "
"is signaled. This guarantees that, unless there is an error condition, the "
"quantized exponent is always equal to that of the right-hand operand."
msgstr ""
"Diferentemente de outras operações, se o comprimento do coeficiente após a "
"operação de quantização for maior que a precisão, então :const:"
"`InvalidOperation` é sinalizado. Isso garante que, a menos que haja uma "
"condição de erro, o expoente quantizado é sempre igual ao do operando do "
"lado direito."

#: ../../library/decimal.rst:782
msgid ""
"Also unlike other operations, quantize never signals Underflow, even if the "
"result is subnormal and inexact."
msgstr ""
"Também, diferentemente de outras operações, a quantização nunca sinaliza "
"Underflow, mesmo que o resultado seja subnormal e inexato."

#: ../../library/decimal.rst:785
msgid ""
"If the exponent of the second operand is larger than that of the first then "
"rounding may be necessary.  In this case, the rounding mode is determined by "
"the ``rounding`` argument if given, else by the given ``context`` argument; "
"if neither argument is given the rounding mode of the current thread's "
"context is used."
msgstr ""
"Se o expoente do segundo operando for maior que o do primeiro, o "
"arredondamento poderá ser necessário. Nesse caso, o modo de arredondamento é "
"determinado pelo argumento ``rounding``, se fornecido, ou pelo argumento "
"``context`` fornecido; se nenhum argumento for fornecido, o modo de "
"arredondamento do contexto da thread atual será usado."

#: ../../library/decimal.rst:791
msgid ""
"An error is returned whenever the resulting exponent is greater than :attr:"
"`Emax` or less than :attr:`Etiny`."
msgstr ""
"Um erro é retornado sempre que o expoente resultante for maior que :attr:"
"`Emax` ou menor que :attr:`Etiny`."

#: ../../library/decimal.rst:796
msgid ""
"Return ``Decimal(10)``, the radix (base) in which the :class:`Decimal` class "
"does all its arithmetic.  Included for compatibility with the specification."
msgstr ""
"Retorna ``Decimal(10)``, a raiz (base) na qual a classe :class:`Decimal` faz "
"toda a sua aritmética. Incluído para compatibilidade com a especificação."

#: ../../library/decimal.rst:802
msgid ""
"Return the remainder from dividing *self* by *other*.  This differs from "
"``self % other`` in that the sign of the remainder is chosen so as to "
"minimize its absolute value.  More precisely, the return value is ``self - n "
"* other`` where ``n`` is the integer nearest to the exact value of ``self / "
"other``, and if two integers are equally near then the even one is chosen."
msgstr ""
"Retorna o resto da divisão de *self* por *other*. Isso é diferente de ``self "
"% other``, pois o sinal do resto é escolhido para minimizar seu valor "
"absoluto. Mais precisamente, o valor de retorno é ``self - n * other``, onde "
"``n`` é o número inteiro mais próximo do valor exato de ``self / other``, e "
"se dois números inteiros estiverem igualmente próximos, o par será é "
"escolhido."

#: ../../library/decimal.rst:809
msgid "If the result is zero then its sign will be the sign of *self*."
msgstr "Se o resultado for zero, seu sinal será o sinal de *self*."

#: ../../library/decimal.rst:820
msgid ""
"Return the result of rotating the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to rotate.  If the second operand is "
"positive then rotation is to the left; otherwise rotation is to the right. "
"The coefficient of the first operand is padded on the left with zeros to "
"length precision if necessary.  The sign and exponent of the first operand "
"are unchanged."
msgstr ""
"Retorna o resultado da rotação dos dígitos do primeiro operando em uma "
"quantidade especificada pelo segundo operando. O segundo operando deve ser "
"um número inteiro no intervalo - precisão através da precisão. O valor "
"absoluto do segundo operando fornece o número de locais a serem "
"rotacionados. Se o segundo operando for positivo, a rotação será para a "
"esquerda; caso contrário, a rotação será para a direita. O coeficiente do "
"primeiro operando é preenchido à esquerda com zeros na precisão do "
"comprimento, se necessário. O sinal e o expoente do primeiro operando não "
"são alterados."

#: ../../library/decimal.rst:831
msgid ""
"Test whether self and other have the same exponent or whether both are :"
"const:`NaN`."
msgstr ""
"Testa se \"self\" e \"other\" têm o mesmo expoente ou se ambos são :const:"
"`NaN`."

#: ../../library/decimal.rst:840
msgid ""
"Return the first operand with exponent adjusted by the second. Equivalently, "
"return the first operand multiplied by ``10**other``.  The second operand "
"must be an integer."
msgstr ""
"Retorna o primeiro operando com o expoente ajustado pelo segundo. Da mesma "
"forma, retorna o primeiro operando multiplicado por ``10**other``. O segundo "
"operando deve ser um número inteiro."

#: ../../library/decimal.rst:846
msgid ""
"Return the result of shifting the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to shift.  If the second operand is "
"positive then the shift is to the left; otherwise the shift is to the "
"right.  Digits shifted into the coefficient are zeros.  The sign and "
"exponent of the first operand are unchanged."
msgstr ""
"Retorna o resultado da troca dos dígitos do primeiro operando em uma "
"quantidade especificada pelo segundo operando. O segundo operando deve ser "
"um número inteiro no intervalo - precisão através da precisão. O valor "
"absoluto do segundo operando fornece o número de locais a serem deslocados. "
"Se o segundo operando for positivo, o deslocamento será para a esquerda; "
"caso contrário, a mudança é para a direita. Os dígitos deslocados para o "
"coeficiente são zeros. O sinal e o expoente do primeiro operando não são "
"alterados."

#: ../../library/decimal.rst:856
msgid "Return the square root of the argument to full precision."
msgstr "Retorna a raiz quadrada do argumento para a precisão total."

#: ../../library/decimal.rst:861 ../../library/decimal.rst:1437
msgid ""
"Convert to a string, using engineering notation if an exponent is needed."
msgstr ""
"Converte em uma string, usando notação de engenharia, se for necessário um "
"expoente."

#: ../../library/decimal.rst:863 ../../library/decimal.rst:1439
msgid ""
"Engineering notation has an exponent which is a multiple of 3.  This can "
"leave up to 3 digits to the left of the decimal place and may require the "
"addition of either one or two trailing zeros."
msgstr ""
"A notação de engenharia possui um expoente que é múltiplo de 3. Isso pode "
"deixar até 3 dígitos à esquerda da casa decimal e pode exigir a adição de um "
"ou dois zeros à direita."

#: ../../library/decimal.rst:867
msgid ""
"For example, this converts ``Decimal('123E+1')`` to ``Decimal('1.23E+3')``."
msgstr ""
"Por exemplo, isso converte ``Decimal('123E+1')`` para ``Decimal('1.23E+3')``."

#: ../../library/decimal.rst:871
msgid ""
"Identical to the :meth:`to_integral_value` method.  The ``to_integral`` name "
"has been kept for compatibility with older versions."
msgstr ""
"Idêntico ao método :meth:`to_integral_value`. O nome ``to_integral`` foi "
"mantido para compatibilidade com versões mais antigas."

#: ../../library/decimal.rst:876
msgid ""
"Round to the nearest integer, signaling :const:`Inexact` or :const:`Rounded` "
"as appropriate if rounding occurs.  The rounding mode is determined by the "
"``rounding`` parameter if given, else by the given ``context``.  If neither "
"parameter is given then the rounding mode of the current context is used."
msgstr ""
"Arredonda para o número inteiro mais próximo, sinalizando :const:`Inexact` "
"ou :const:`Rounded`, conforme apropriado, se o arredondamento ocorrer. O "
"modo de arredondamento é determinado pelo parâmetro ``rouding``, se "
"fornecido, ou pelo ``context`` especificado. Se nenhum parâmetro for "
"fornecido, o modo de arredondamento do contexto atual será usado."

#: ../../library/decimal.rst:884
msgid ""
"Round to the nearest integer without signaling :const:`Inexact` or :const:"
"`Rounded`.  If given, applies *rounding*; otherwise, uses the rounding "
"method in either the supplied *context* or the current context."
msgstr ""
"Arredonda para o número inteiro mais próximo sem sinalizar :const:`Inexact` "
"ou :const:`Rounding`. Se fornecido, aplica *rounding*; caso contrário, usa o "
"método de arredondamento no *context* especificado ou no contexto atual."

#: ../../library/decimal.rst:892
msgid "Logical operands"
msgstr "Operandos lógicos"

#: ../../library/decimal.rst:894
msgid ""
"The :meth:`logical_and`, :meth:`logical_invert`, :meth:`logical_or`, and :"
"meth:`logical_xor` methods expect their arguments to be *logical operands*.  "
"A *logical operand* is a :class:`Decimal` instance whose exponent and sign "
"are both zero, and whose digits are all either :const:`0` or :const:`1`."
msgstr ""
"Os métodos :meth:`logical_and`, :meth:`logical_invert`, :meth:`logical_or` "
"e :meth:`logical_xor` esperam que seus argumentos sejam *operandos lógicos*. "
"Um *operando lógico* é uma instância de :class:`Decimal` cujo expoente e "
"sinal são zero e cujos dígitos são todos :const:`0` ou :const:`1`."

#: ../../library/decimal.rst:906
msgid "Context objects"
msgstr "Objetos de contexto"

#: ../../library/decimal.rst:908
msgid ""
"Contexts are environments for arithmetic operations.  They govern precision, "
"set rules for rounding, determine which signals are treated as exceptions, "
"and limit the range for exponents."
msgstr ""
"Contextos são ambientes para operações aritméticas. Eles governam a "
"precisão, estabelecem regras para arredondamento, determinam quais sinais "
"são tratados como exceções e limitam o intervalo dos expoentes."

#: ../../library/decimal.rst:912
msgid ""
"Each thread has its own current context which is accessed or changed using "
"the :func:`getcontext` and :func:`setcontext` functions:"
msgstr ""
"Cada thread possui seu próprio contexto atual que é acessado ou alterado "
"usando as funções :func:`getcontext` e :func:`setcontext`:"

#: ../../library/decimal.rst:918
msgid "Return the current context for the active thread."
msgstr "Retorna o contexto atual para a thread ativa."

#: ../../library/decimal.rst:923
msgid "Set the current context for the active thread to *c*."
msgstr "Define o contexto atual para a thread ativa como *C*."

#: ../../library/decimal.rst:925
msgid ""
"You can also use the :keyword:`with` statement and the :func:`localcontext` "
"function to temporarily change the active context."
msgstr ""
"Você também pode usar a instrução :keyword:`with` e a função :func:"
"`localcontext` para alterar temporariamente o contexto ativo."

#: ../../library/decimal.rst:930
msgid ""
"Return a context manager that will set the current context for the active "
"thread to a copy of *ctx* on entry to the with-statement and restore the "
"previous context when exiting the with-statement. If no context is "
"specified, a copy of the current context is used."
msgstr ""
"Retorna um gerenciador de contexto que vai definir o contexto atual da "
"thread ativa para uma cópia de *ctx* na entrada da instrução \"with\" e "
"restaurar o contexto anterior ao sair da instrução \"with\". Se nenhum "
"contexto for especificado, uma cópia do contexto atual será usada."

#: ../../library/decimal.rst:935
msgid ""
"For example, the following code sets the current decimal precision to 42 "
"places, performs a calculation, and then automatically restores the previous "
"context::"
msgstr ""
"Por exemplo, o código a seguir define a precisão decimal atual para 42 "
"casas, executa um cálculo e restaura automaticamente o contexto anterior::"

#: ../../library/decimal.rst:945
msgid ""
"New contexts can also be created using the :class:`Context` constructor "
"described below. In addition, the module provides three pre-made contexts:"
msgstr ""
"Novos contextos também podem ser criados usando o construtor :class:"
"`Context` descrito abaixo. Além disso, o módulo fornece três contextos pré-"
"criados::"

#: ../../library/decimal.rst:951
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_UP`.  All flags are cleared.  All traps are enabled (treated as "
"exceptions) except :const:`Inexact`, :const:`Rounded`, and :const:"
"`Subnormal`."
msgstr ""
"Este é um contexto padrão definido pela Especificação Aritmética Decimal "
"Geral. A precisão está definida como nove. O arredondamento está definido "
"como :const:`ROUND_HALF_UP`. Todos os sinalizadores estão limpos. Todos as "
"armadilhas estão ativadas (tratadas como exceções), exceto por :const:"
"`Inexact`, :const:`Rounded` e :const:`Subnormal`."

#: ../../library/decimal.rst:957
msgid ""
"Because many of the traps are enabled, this context is useful for debugging."
msgstr ""
"Como muitas das armadilhas estão ativadas, esse contexto é útil para "
"depuração."

#: ../../library/decimal.rst:962
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_EVEN`.  All flags are cleared.  No traps are enabled (so that "
"exceptions are not raised during computations)."
msgstr ""
"Este é um contexto padrão definido pela Especificação Aritmética Decimal "
"Geral. A precisão está definida como nove. O arredondamento está definido "
"como :const:`ROUND_HALF_EVEN`. Todos os sinalizadores estão limpos. Nenhuma "
"armadilha está ativada (de forma que exceções não são levantadas durante os "
"cálculos)."

#: ../../library/decimal.rst:967
msgid ""
"Because the traps are disabled, this context is useful for applications that "
"prefer to have result value of :const:`NaN` or :const:`Infinity` instead of "
"raising exceptions.  This allows an application to complete a run in the "
"presence of conditions that would otherwise halt the program."
msgstr ""
"Como as armadilhas estão desativadas, esse contexto é útil para aplicativos "
"que preferem ter o valor de resultado de :const:`NaN` ou :const:`Infinity` "
"em vez de levantar exceções. Isso permite que uma aplicação conclua uma "
"execução na presença de condições que interromperiam o programa."

#: ../../library/decimal.rst:975
msgid ""
"This context is used by the :class:`Context` constructor as a prototype for "
"new contexts.  Changing a field (such a precision) has the effect of "
"changing the default for new contexts created by the :class:`Context` "
"constructor."
msgstr ""
"Este contexto é usado pelo construtor :class:`Context` como um protótipo "
"para novos contextos. Alterar um campo (tal como precisão) tem o efeito de "
"alterar o padrão para novos contextos criados pelo construtor :class:"
"`Context`."

#: ../../library/decimal.rst:979
msgid ""
"This context is most useful in multi-threaded environments.  Changing one of "
"the fields before threads are started has the effect of setting system-wide "
"defaults.  Changing the fields after threads have started is not recommended "
"as it would require thread synchronization to prevent race conditions."
msgstr ""
"Esse contexto é mais útil em ambientes multithread. A alteração de um dos "
"campos antes do início das threads tem o efeito de definir os padrões para "
"todo o sistema. Não é recomendável alterar os campos após o início das "
"threads, pois exigiria sincronização de threads para evitar condições de "
"corrida."

#: ../../library/decimal.rst:984
msgid ""
"In single threaded environments, it is preferable to not use this context at "
"all.  Instead, simply create contexts explicitly as described below."
msgstr ""
"Em ambientes de thread única, é preferível não usar esse contexto. Em vez "
"disso, basta criar contextos explicitamente, conforme descrito abaixo."

#: ../../library/decimal.rst:987
msgid ""
"The default values are :attr:`prec`\\ =\\ :const:`28`, :attr:`rounding`\\ ="
"\\ :const:`ROUND_HALF_EVEN`, and enabled traps for :class:`Overflow`, :class:"
"`InvalidOperation`, and :class:`DivisionByZero`."
msgstr ""
"Os valores padrão são :attr:`prec`\\ =\\ :const:`28`, :attr:`rounding`\\ ="
"\\ :const:`ROUND_HALF_EVEN` e armadilhas ativadas para :class:`Overflow`, :"
"class:`InvalidOperation` e :class:`DivisionByZero`."

#: ../../library/decimal.rst:992
msgid ""
"In addition to the three supplied contexts, new contexts can be created with "
"the :class:`Context` constructor."
msgstr ""
"Além dos três contextos fornecidos, novos contextos podem ser criados com o "
"construtor :class:`Context`."

#: ../../library/decimal.rst:998
msgid ""
"Creates a new context.  If a field is not specified or is :const:`None`, the "
"default values are copied from the :const:`DefaultContext`.  If the *flags* "
"field is not specified or is :const:`None`, all flags are cleared."
msgstr ""
"Cria um novo contexto. Se um campo não for especificado ou for :const:"
"`None`, os valores padrão serão copiados de :const:`DefaultContext`. Se o "
"campo *flags* não for especificado ou for :const:`None`, todos os "
"sinalizadores serão limpados."

#: ../../library/decimal.rst:1002
msgid ""
"*prec* is an integer in the range [:const:`1`, :const:`MAX_PREC`] that sets "
"the precision for arithmetic operations in the context."
msgstr ""
"*prec* é um número inteiro no intervalo [:const:`1`, :const:`MAX_PREC`] que "
"define a precisão das operações aritméticas no contexto."

#: ../../library/decimal.rst:1005
msgid ""
"The *rounding* option is one of the constants listed in the section "
"`Rounding Modes`_."
msgstr ""
"A opção *rounding* é uma das constantes listadas na seção `Modos de "
"arredondamento`_."

#: ../../library/decimal.rst:1008
msgid ""
"The *traps* and *flags* fields list any signals to be set. Generally, new "
"contexts should only set traps and leave the flags clear."
msgstr ""
"Os campos *traps* e *flags* listam todos os sinais a serem configurados. "
"Geralmente, novos contextos devem apenas definir armadilhas e deixar os "
"sinalizadores limpos."

#: ../../library/decimal.rst:1011
msgid ""
"The *Emin* and *Emax* fields are integers specifying the outer limits "
"allowable for exponents. *Emin* must be in the range [:const:`MIN_EMIN`, :"
"const:`0`], *Emax* in the range [:const:`0`, :const:`MAX_EMAX`]."
msgstr ""
"Os campos *Emin* e *Emax* são números inteiros que especificam os limites "
"externos permitidos para expoentes. *Emin* deve estar no intervalo [:const:"
"`MIN_EMIN`, :const:`0`], *Emax* no intervalo [:const:`0`, :const:`MAX_EMAX`]."

#: ../../library/decimal.rst:1015
msgid ""
"The *capitals* field is either :const:`0` or :const:`1` (the default). If "
"set to :const:`1`, exponents are printed with a capital :const:`E`; "
"otherwise, a lowercase :const:`e` is used: :const:`Decimal('6.02e+23')`."
msgstr ""
"O campo *capitals* é :const:`0` ou :const:`1` (o padrão). Se definido como :"
"const:`1`, os expoentes serão impressos com um :const:`E` maiúsculo; caso "
"contrário, um :const:`e` minúscula é usado: :const:`Decimal('6.02e+23')`."

#: ../../library/decimal.rst:1019
msgid ""
"The *clamp* field is either :const:`0` (the default) or :const:`1`. If set "
"to :const:`1`, the exponent ``e`` of a :class:`Decimal` instance "
"representable in this context is strictly limited to the range ``Emin - prec "
"+ 1 <= e <= Emax - prec + 1``.  If *clamp* is :const:`0` then a weaker "
"condition holds: the adjusted exponent of the :class:`Decimal` instance is "
"at most ``Emax``.  When *clamp* is :const:`1`, a large normal number will, "
"where possible, have its exponent reduced and a corresponding number of "
"zeros added to its coefficient, in order to fit the exponent constraints; "
"this preserves the value of the number but loses information about "
"significant trailing zeros.  For example::"
msgstr ""
"O campo *clamp* é :const:`0` (o padrão) ou :const:`1`. Se definido como :"
"const:`1`, o expoente ``e`` de uma instância de :class:`Decimal` "
"representável nesse contexto é estritamente limitado ao intervalo ``Emin - "
"prec + 1 <= e <= Emax - prec + 1``. Se *clamp* for :const:`0`, uma condição "
"mais fraca será mantida: o expoente ajustado da instância de :class:"
"`Decimal` é no máximo ``Emax``. Quando *clamp* é :const:`1`, um grande "
"número normal terá, sempre que possível, seu expoente reduzido e um número "
"correspondente de zeros adicionado ao seu coeficiente, para ajustar as "
"restrições do expoente; isso preserva o valor do número, mas perde "
"informações sobre zeros à direita significativos. Por exemplo::"

#: ../../library/decimal.rst:1034
msgid ""
"A *clamp* value of :const:`1` allows compatibility with the fixed-width "
"decimal interchange formats specified in IEEE 754."
msgstr ""
"Um valor de *clamp* de :const:`1` permite compatibilidade com os formatos de "
"intercâmbio decimal de largura fixa especificados na IEEE 754."

#: ../../library/decimal.rst:1037
msgid ""
"The :class:`Context` class defines several general purpose methods as well "
"as a large number of methods for doing arithmetic directly in a given "
"context. In addition, for each of the :class:`Decimal` methods described "
"above (with the exception of the :meth:`adjusted` and :meth:`as_tuple` "
"methods) there is a corresponding :class:`Context` method.  For example, for "
"a :class:`Context` instance ``C`` and :class:`Decimal` instance ``x``, ``C."
"exp(x)`` is equivalent to ``x.exp(context=C)``.  Each :class:`Context` "
"method accepts a Python integer (an instance of :class:`int`) anywhere that "
"a Decimal instance is accepted."
msgstr ""
"A classe :class:`Context` define vários métodos de uso geral, bem como um "
"grande número de métodos para fazer aritmética diretamente em um determinado "
"contexto. Além disso, para cada um dos métodos de :class:`Decimal` descritos "
"acima (com exceção dos métodos :meth:`adjusted` e :meth:`as_tuple`) existe "
"um método correspondente em :class:`Context`. Por exemplo, para uma "
"instância ``C`` de :class:`Context` e uma instância ``x`` de :class:"
"`Decimal`, ``C.exp(x)`` é equivalente a ``x.exp(context=C)``. Cada método "
"de :class:`Context` aceita um número inteiro do Python (uma instância de :"
"class:`int`) em qualquer lugar em que uma instância de Decimal seja aceita."

#: ../../library/decimal.rst:1050
msgid "Resets all of the flags to :const:`0`."
msgstr "Redefine todos os sinalizadores para :const:`0`."

#: ../../library/decimal.rst:1054
msgid "Resets all of the traps to :const:`0`."
msgstr "Redefine todas as armadilhas para :const:`0`."

#: ../../library/decimal.rst:1060
msgid "Return a duplicate of the context."
msgstr "Retorna uma duplicata do contexto."

#: ../../library/decimal.rst:1064
msgid "Return a copy of the Decimal instance num."
msgstr "Retorna uma cópia da instância de Decimal *num*."

#: ../../library/decimal.rst:1068
msgid ""
"Creates a new Decimal instance from *num* but using *self* as context. "
"Unlike the :class:`Decimal` constructor, the context precision, rounding "
"method, flags, and traps are applied to the conversion."
msgstr ""
"Cria uma nova instância decimal a partir de *num*, mas usando *self* como "
"contexto. Diferentemente do construtor de :class:`Decimal`, a precisão do "
"contexto, o método de arredondamento, os sinalizadores e as armadilhas são "
"aplicadas à conversão."

#: ../../library/decimal.rst:1072
msgid ""
"This is useful because constants are often given to a greater precision than "
"is needed by the application.  Another benefit is that rounding immediately "
"eliminates unintended effects from digits beyond the current precision. In "
"the following example, using unrounded inputs means that adding zero to a "
"sum can change the result:"
msgstr ""
"Isso é útil porque as constantes geralmente são fornecidas com uma precisão "
"maior do que a necessária pela aplicação. Outro benefício é que o "
"arredondamento elimina imediatamente os efeitos indesejados dos dígitos além "
"da precisão atual. No exemplo a seguir, o uso de entradas não arredondadas "
"significa que adicionar zero a uma soma pode alterar o resultado:"

#: ../../library/decimal.rst:1086
msgid ""
"This method implements the to-number operation of the IBM specification. If "
"the argument is a string, no leading or trailing whitespace or underscores "
"are permitted."
msgstr ""
"Este método implementa a operação \"to-number\" da especificação IBM. Se o "
"argumento for uma string, nenhum espaço em branco à esquerda ou à direita ou "
"sublinhado serão permitidos."

#: ../../library/decimal.rst:1092
msgid ""
"Creates a new Decimal instance from a float *f* but rounding using *self* as "
"the context.  Unlike the :meth:`Decimal.from_float` class method, the "
"context precision, rounding method, flags, and traps are applied to the "
"conversion."
msgstr ""
"Cria uma nova instância de Decimal a partir de um ponto flutuante *f*, mas "
"arredondando usando *self* como contexto. Diferentemente do método da "
"classe :meth:`Decimal.from_float`, a precisão do contexto, o método de "
"arredondamento, os sinalizadores e as armadilhas são aplicados à conversão."

#: ../../library/decimal.rst:1112
msgid ""
"Returns a value equal to ``Emin - prec + 1`` which is the minimum exponent "
"value for subnormal results.  When underflow occurs, the exponent is set to :"
"const:`Etiny`."
msgstr ""
"Retorna um valor igual a ``Emin - prec + 1``, que é o valor mínimo do "
"expoente para resultados subnormais. Quando ocorre o estouro negativo, o "
"expoente é definido como :const:`Etiny`."

#: ../../library/decimal.rst:1118
msgid "Returns a value equal to ``Emax - prec + 1``."
msgstr "Retorna um valor igual a ``Emax - prec + 1``."

#: ../../library/decimal.rst:1120
msgid ""
"The usual approach to working with decimals is to create :class:`Decimal` "
"instances and then apply arithmetic operations which take place within the "
"current context for the active thread.  An alternative approach is to use "
"context methods for calculating within a specific context.  The methods are "
"similar to those for the :class:`Decimal` class and are only briefly "
"recounted here."
msgstr ""
"A abordagem usual para trabalhar com decimais é criar instâncias de :class:"
"`Decimal` e depois aplicar operações aritméticas que ocorrem no contexto "
"atual da thread ativa. Uma abordagem alternativa é usar métodos de contexto "
"para calcular dentro de um contexto específico. Os métodos são semelhantes "
"aos da classe :class:`Decimal` e são contados apenas brevemente aqui."

#: ../../library/decimal.rst:1130
msgid "Returns the absolute value of *x*."
msgstr "Retorna o valor absoluto de *x*."

#: ../../library/decimal.rst:1135
msgid "Return the sum of *x* and *y*."
msgstr "Retorna a soma de *x* e *y*."

#: ../../library/decimal.rst:1140
msgid "Returns the same Decimal object *x*."
msgstr "Retorna o mesmo objeto de Decimal *x*."

#: ../../library/decimal.rst:1145
msgid "Compares *x* and *y* numerically."
msgstr "Compara *x* e *y* numericamente."

#: ../../library/decimal.rst:1150
msgid "Compares the values of the two operands numerically."
msgstr "Compara os valores dos dois operandos numericamente."

#: ../../library/decimal.rst:1155
msgid "Compares two operands using their abstract representation."
msgstr "Compara dois operandos usando sua representação abstrata."

#: ../../library/decimal.rst:1160
msgid ""
"Compares two operands using their abstract representation, ignoring sign."
msgstr ""
"Compara dois operandos usando sua representação abstrata, ignorando o sinal."

#: ../../library/decimal.rst:1165
msgid "Returns a copy of *x* with the sign set to 0."
msgstr "Retorna uma cópia de *x* com o sinal definido para 0."

#: ../../library/decimal.rst:1170
msgid "Returns a copy of *x* with the sign inverted."
msgstr "Retorna uma cópia de *x* com o sinal invertido."

#: ../../library/decimal.rst:1175
msgid "Copies the sign from *y* to *x*."
msgstr "Copia o sinal de *y* para *x*."

#: ../../library/decimal.rst:1180
msgid "Return *x* divided by *y*."
msgstr "Retorna *x* dividido por *y*."

#: ../../library/decimal.rst:1185
msgid "Return *x* divided by *y*, truncated to an integer."
msgstr "Retorna *x* dividido por *y*, truncado para um inteiro."

#: ../../library/decimal.rst:1190
msgid "Divides two numbers and returns the integer part of the result."
msgstr "Divide dois números e retorna a parte inteira do resultado."

#: ../../library/decimal.rst:1195
msgid "Returns `e ** x`."
msgstr "Retorna `e ** x`."

#: ../../library/decimal.rst:1200
msgid "Returns *x* multiplied by *y*, plus *z*."
msgstr "Retorna *x* multiplicado por *y*, mais *z*."

#: ../../library/decimal.rst:1205
msgid "Returns ``True`` if *x* is canonical; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` se *x* for canonical; caso contrário, retorna ``False``."

#: ../../library/decimal.rst:1210
msgid "Returns ``True`` if *x* is finite; otherwise returns ``False``."
msgstr "Retorna ``True`` se *x* for finito; caso contrário, retorna ``False``."

#: ../../library/decimal.rst:1215
msgid "Returns ``True`` if *x* is infinite; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` se *x* for infinito; caso contrário, retorna ``False``."

#: ../../library/decimal.rst:1220
msgid "Returns ``True`` if *x* is a qNaN or sNaN; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` se *x* for qNaN ou sNaN; caso contrário, retorna ``False``."

#: ../../library/decimal.rst:1225
msgid ""
"Returns ``True`` if *x* is a normal number; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` se *x* for um número normal; caso contrário, retorna "
"``False``."

#: ../../library/decimal.rst:1230
msgid "Returns ``True`` if *x* is a quiet NaN; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` se *x* for um NaN silencioso; caso contrário, retorna "
"``False``."

#: ../../library/decimal.rst:1235
msgid "Returns ``True`` if *x* is negative; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` se *x* for negativo; caso contrário, retorna ``False``."

#: ../../library/decimal.rst:1240
msgid ""
"Returns ``True`` if *x* is a signaling NaN; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` se *x* for um NaN sinalizador; caso contrário, retorna "
"``False``."

#: ../../library/decimal.rst:1245
msgid "Returns ``True`` if *x* is subnormal; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` se *x* for subnormal; caso contrário, retorna ``False``."

#: ../../library/decimal.rst:1250
msgid "Returns ``True`` if *x* is a zero; otherwise returns ``False``."
msgstr "Retorna ``True`` se *x* for zero; caso contrário, retorna ``False``."

#: ../../library/decimal.rst:1255
msgid "Returns the natural (base e) logarithm of *x*."
msgstr "Retorna o logaritmo natural (base e) de *x*."

#: ../../library/decimal.rst:1260
msgid "Returns the base 10 logarithm of *x*."
msgstr "Retorna o logaritmo de base 10 de *x*."

#: ../../library/decimal.rst:1265
msgid "Returns the exponent of the magnitude of the operand's MSD."
msgstr "Retorna o expoente da magnitude do MSD do operando."

#: ../../library/decimal.rst:1270
msgid "Applies the logical operation *and* between each operand's digits."
msgstr "Aplica a operação lógica *e* entre cada dígito do operando."

#: ../../library/decimal.rst:1275
msgid "Invert all the digits in *x*."
msgstr "Inverte todos os dígitos em *x*."

#: ../../library/decimal.rst:1280
msgid "Applies the logical operation *or* between each operand's digits."
msgstr "Aplica a operação lógica *ou* entre cada dígito do operando."

#: ../../library/decimal.rst:1285
msgid "Applies the logical operation *xor* between each operand's digits."
msgstr "Aplica a operação lógica *ou exclusivo* entre cada dígito do operando."

#: ../../library/decimal.rst:1290
msgid "Compares two values numerically and returns the maximum."
msgstr "Compara dois valores numericamente e retorna o máximo."

#: ../../library/decimal.rst:1295 ../../library/decimal.rst:1305
msgid "Compares the values numerically with their sign ignored."
msgstr "Compara dois valores numericamente com seu sinal ignorado."

#: ../../library/decimal.rst:1300
msgid "Compares two values numerically and returns the minimum."
msgstr "Compara dois valores numericamente e retorna o mínimo."

#: ../../library/decimal.rst:1310
msgid "Minus corresponds to the unary prefix minus operator in Python."
msgstr ""
"Minus corresponde ao operador de subtração de prefixo unário no Python."

#: ../../library/decimal.rst:1315
msgid "Return the product of *x* and *y*."
msgstr "Retorna o produto de *x* e *y*."

#: ../../library/decimal.rst:1320
msgid "Returns the largest representable number smaller than *x*."
msgstr "Retorna o maior número representável menor que *x*."

#: ../../library/decimal.rst:1325
msgid "Returns the smallest representable number larger than *x*."
msgstr "Retorna o menor número representável maior que *x*."

#: ../../library/decimal.rst:1330
msgid "Returns the number closest to *x*, in direction towards *y*."
msgstr "Retorna o número mais próximo a *x*, em direção a *y*."

#: ../../library/decimal.rst:1335
msgid "Reduces *x* to its simplest form."
msgstr "Reduz *x* para sua forma mais simples."

#: ../../library/decimal.rst:1340
msgid "Returns an indication of the class of *x*."
msgstr "Retorna uma indicação da classe de *x*."

#: ../../library/decimal.rst:1345
msgid ""
"Plus corresponds to the unary prefix plus operator in Python.  This "
"operation applies the context precision and rounding, so it is *not* an "
"identity operation."
msgstr ""
"Plus corresponde ao operador de soma de prefixo unário no Python. Esta "
"operação aplica a precisão e o arredondamento do contexto, portanto *não* é "
"uma operação de identidade."

#: ../../library/decimal.rst:1352
msgid "Return ``x`` to the power of ``y``, reduced modulo ``modulo`` if given."
msgstr ""
"Retorna ``x`` à potência de ``y``, com a redução de módulo ``modulo`` se "
"fornecido."

#: ../../library/decimal.rst:1354
msgid ""
"With two arguments, compute ``x**y``.  If ``x`` is negative then ``y`` must "
"be integral.  The result will be inexact unless ``y`` is integral and the "
"result is finite and can be expressed exactly in 'precision' digits. The "
"rounding mode of the context is used. Results are always correctly-rounded "
"in the Python version."
msgstr ""
"Com dois argumentos, calcula ``x**y``. Se ``x`` for negativo, ``y`` deve ser "
"inteiro. O resultado será inexato, a menos que ``y`` seja inteiro e o "
"resultado seja finito e possa ser expresso exatamente em \"precisão\" "
"dígitos. O modo de arredondamento do contexto é usado. Os resultados são "
"sempre arredondados corretamente na versão Python."

#: ../../library/decimal.rst:1360
msgid ""
"The C module computes :meth:`power` in terms of the correctly-rounded :meth:"
"`exp` and :meth:`ln` functions. The result is well-defined but only \"almost "
"always correctly-rounded\"."
msgstr ""
"O módulo C calcula :meth:`power` em termos das funções corretamente "
"arredondadas :meth:`exp` e :meth:`ln`. O resultado é bem definido, mas "
"apenas \"quase sempre corretamente arredondado\"."

#: ../../library/decimal.rst:1365
msgid ""
"With three arguments, compute ``(x**y) % modulo``.  For the three argument "
"form, the following restrictions on the arguments hold:"
msgstr ""
"Com três argumentos, calcula ``(x**y) % modulo``. Para o formulário de três "
"argumentos, as seguintes restrições nos argumentos são válidas:"

#: ../../library/decimal.rst:1368
msgid "all three arguments must be integral"
msgstr "todos os três argumentos devem ser inteiros"

#: ../../library/decimal.rst:1369
msgid "``y`` must be nonnegative"
msgstr "``y`` não pode ser negativo"

#: ../../library/decimal.rst:1370
msgid "at least one of ``x`` or ``y`` must be nonzero"
msgstr "pelo menos um de ``x`` ou ``y`` não pode ser negativo"

#: ../../library/decimal.rst:1371
msgid "``modulo`` must be nonzero and have at most 'precision' digits"
msgstr ""
"``modulo`` não pode ser zero e deve ter pelo menos \"precisão\" dígitos"

#: ../../library/decimal.rst:1373
msgid ""
"The value resulting from ``Context.power(x, y, modulo)`` is equal to the "
"value that would be obtained by computing ``(x**y) % modulo`` with unbounded "
"precision, but is computed more efficiently.  The exponent of the result is "
"zero, regardless of the exponents of ``x``, ``y`` and ``modulo``.  The "
"result is always exact."
msgstr ""
"O valor resultante de ``Context.power(x, y, modulo)`` é igual ao valor que "
"seria obtido ao computar ``(x**y) % modulo`` com precisão ilimitada, mas é "
"calculado com mais eficiência . O expoente do resultado é zero, "
"independentemente dos expoentes de ``x``, ``y`` e ``modulo``. O resultado é "
"sempre exato."

#: ../../library/decimal.rst:1383
msgid "Returns a value equal to *x* (rounded), having the exponent of *y*."
msgstr "Retorna um valor igual a *x* (arredondado), com o expoente de *y*."

#: ../../library/decimal.rst:1388
msgid "Just returns 10, as this is Decimal, :)"
msgstr "Só retorna 10, já que isso é Decimal, :)"

#: ../../library/decimal.rst:1393
msgid "Returns the remainder from integer division."
msgstr "Retorna o resto da divisão inteira."

#: ../../library/decimal.rst:1395
msgid ""
"The sign of the result, if non-zero, is the same as that of the original "
"dividend."
msgstr ""
"O sinal do resultado, se diferente de zero, é o mesmo que o do dividendo "
"original."

#: ../../library/decimal.rst:1401
msgid ""
"Returns ``x - y * n``, where *n* is the integer nearest the exact value of "
"``x / y`` (if the result is 0 then its sign will be the sign of *x*)."
msgstr ""
"Retorna ``x - y * n``, onde *n* é o número inteiro mais próximo do valor "
"exato de ``x / y`` (se o resultado for 0, seu sinal será o sinal de *x*)."

#: ../../library/decimal.rst:1407
msgid "Returns a rotated copy of *x*, *y* times."
msgstr "Retorna uma cópia re de *x*, *y* vezes."

#: ../../library/decimal.rst:1412
msgid "Returns ``True`` if the two operands have the same exponent."
msgstr "Retorna ``True`` se os dois operandos tiverem o mesmo expoente."

#: ../../library/decimal.rst:1417
msgid "Returns the first operand after adding the second value its exp."
msgstr "Retorna o primeiro operando após adicionar o segundo valor seu exp."

#: ../../library/decimal.rst:1422
msgid "Returns a shifted copy of *x*, *y* times."
msgstr "Retorna uma cópia deslocada de *x*, *y* vezes."

#: ../../library/decimal.rst:1427
msgid "Square root of a non-negative number to context precision."
msgstr "Raiz quadrada de um número não negativo para precisão do contexto."

#: ../../library/decimal.rst:1432
msgid "Return the difference between *x* and *y*."
msgstr "Retorna a diferença entre *x* e *y*."

#: ../../library/decimal.rst:1446
msgid "Rounds to an integer."
msgstr "Arredonda para um número inteiro."

#: ../../library/decimal.rst:1451
msgid "Converts a number to a string using scientific notation."
msgstr "Converte um número em uma string usando notação científica."

#: ../../library/decimal.rst:1458
msgid "Constants"
msgstr "Constantes"

#: ../../library/decimal.rst:1460
msgid ""
"The constants in this section are only relevant for the C module. They are "
"also included in the pure Python version for compatibility."
msgstr ""
"As constantes nesta seção são relevantes apenas para o módulo C. Eles também "
"estão incluídos na versão pura do Python para compatibilidade."

#: ../../library/decimal.rst:1464
msgid "32-bit"
msgstr "32 bits"

#: ../../library/decimal.rst:1464
msgid "64-bit"
msgstr "64 bits"

#: ../../library/decimal.rst:1466 ../../library/decimal.rst:1468
msgid ":const:`425000000`"
msgstr ":const:`425000000`"

#: ../../library/decimal.rst:1466 ../../library/decimal.rst:1468
msgid ":const:`999999999999999999`"
msgstr ":const:`999999999999999999`"

#: ../../library/decimal.rst:1470
msgid ":const:`-425000000`"
msgstr ":const:`-425000000`"

#: ../../library/decimal.rst:1470
msgid ":const:`-999999999999999999`"
msgstr ":const:`-999999999999999999`"

#: ../../library/decimal.rst:1472
msgid ":const:`-849999999`"
msgstr ":const:`-849999999`"

#: ../../library/decimal.rst:1472
msgid ":const:`-1999999999999999997`"
msgstr ":const:`-1999999999999999997`"

#: ../../library/decimal.rst:1478
msgid ""
"The value is ``True``.  Deprecated, because Python now always has threads."
msgstr ""
"O valor é ``True``. Descontinuado porque o Python agora sempre tem threads."

#: ../../library/decimal.rst:1484
msgid ""
"The default value is ``True``. If Python is compiled ``--without-decimal-"
"contextvar``, the C version uses a thread-local rather than a coroutine-"
"local context and the value is ``False``.  This is slightly faster in some "
"nested context scenarios."
msgstr ""
"O valor padrão é ``True``. Se o Python for compilado usando ``--without-"
"decimal-contextvar``, a versão C usará um contexto local de thread em vez de "
"local de corrotina e o valor será ``False``. Isso é um pouco mais rápido em "
"alguns cenários de contexto aninhados."

#: ../../library/decimal.rst:1488
msgid "backported to 3.7 and 3.8"
msgstr "backport realizado para 3.7 e 3.8"

#: ../../library/decimal.rst:1492
msgid "Rounding modes"
msgstr "Modos de arredondamento"

#: ../../library/decimal.rst:1496
msgid "Round towards :const:`Infinity`."
msgstr "Arredonda para :const:`Infinity`."

#: ../../library/decimal.rst:1500
msgid "Round towards zero."
msgstr "Arredonda para zero."

#: ../../library/decimal.rst:1504
msgid "Round towards :const:`-Infinity`."
msgstr "Arredonda para :const:`-Infinity`."

#: ../../library/decimal.rst:1508
msgid "Round to nearest with ties going towards zero."
msgstr "Arrendonda para o mais próximo com empates tendendo a zero."

#: ../../library/decimal.rst:1512
msgid "Round to nearest with ties going to nearest even integer."
msgstr ""
"Arredonda para o mais próximo com empates indo para o mais próximo inteiro "
"par."

#: ../../library/decimal.rst:1516
msgid "Round to nearest with ties going away from zero."
msgstr "Arrendonda para o mais próximo com empates se afastando de zero."

#: ../../library/decimal.rst:1520
msgid "Round away from zero."
msgstr "Arredonda se afastando de zero."

#: ../../library/decimal.rst:1524
msgid ""
"Round away from zero if last digit after rounding towards zero would have "
"been 0 or 5; otherwise round towards zero."
msgstr ""
"Arredonda se afastando de zero se o último dígito após o arredondamento para "
"zero fosse 0 ou 5; caso contrário, arredonda para zero."

#: ../../library/decimal.rst:1531
msgid "Signals"
msgstr "Sinais"

#: ../../library/decimal.rst:1533
msgid ""
"Signals represent conditions that arise during computation. Each corresponds "
"to one context flag and one context trap enabler."
msgstr ""
"Sinais representam condições que surgem durante o cálculo. Cada um "
"corresponde a um sinalizador de contexto e um ativador de armadilha de "
"contexto."

#: ../../library/decimal.rst:1536
msgid ""
"The context flag is set whenever the condition is encountered. After the "
"computation, flags may be checked for informational purposes (for instance, "
"to determine whether a computation was exact). After checking the flags, be "
"sure to clear all flags before starting the next computation."
msgstr ""
"O sinalizador de contexto é definido sempre que a condição é encontrada. "
"Após o cálculo, os sinalizadores podem ser verificados para fins "
"informativos (por exemplo, para determinar se um cálculo era exato). Depois "
"de verificar os sinalizadores, certifique-se de limpar todos os "
"sinalizadores antes de iniciar o próximo cálculo."

#: ../../library/decimal.rst:1541
msgid ""
"If the context's trap enabler is set for the signal, then the condition "
"causes a Python exception to be raised.  For example, if the :class:"
"`DivisionByZero` trap is set, then a :exc:`DivisionByZero` exception is "
"raised upon encountering the condition."
msgstr ""
"Se o ativador de armadilha de contexto estiver definido para o sinal, a "
"condição fará com que uma exceção Python seja levantada. Por exemplo, se a "
"armadilha :class:`DivisionByZero` for configurada, uma exceção :exc:"
"`DivisionByZero` será levantada ao encontrar a condição."

#: ../../library/decimal.rst:1549
msgid "Altered an exponent to fit representation constraints."
msgstr "Altera um expoente para ajustar as restrições de representação."

#: ../../library/decimal.rst:1551
msgid ""
"Typically, clamping occurs when an exponent falls outside the context's :"
"attr:`Emin` and :attr:`Emax` limits.  If possible, the exponent is reduced "
"to fit by adding zeros to the coefficient."
msgstr ""
"Normalmente, *clamping* ocorre quando um expoente fica fora dos limites do "
"contexto :attr:`Emin` e :attr:`Emax`. Se possível, o expoente é reduzido "
"para caber adicionando zeros ao coeficiente."

#: ../../library/decimal.rst:1558
msgid "Base class for other signals and a subclass of :exc:`ArithmeticError`."
msgstr ""
"Classe base para outros sinais e uma subclasse de :exc:`ArithmeticError`."

#: ../../library/decimal.rst:1563
msgid "Signals the division of a non-infinite number by zero."
msgstr "Sinaliza a divisão de um número não infinito por zero."

#: ../../library/decimal.rst:1565
msgid ""
"Can occur with division, modulo division, or when raising a number to a "
"negative power.  If this signal is not trapped, returns :const:`Infinity` "
"or :const:`-Infinity` with the sign determined by the inputs to the "
"calculation."
msgstr ""
"Pode ocorrer com divisão, divisão de módulo ou ao elevar um número a uma "
"potência negativa. Se este sinal não for capturado, retornará :const:"
"`Infinity` ou :const:`-Infinity` com o sinal determinado pelas entradas do "
"cálculo."

#: ../../library/decimal.rst:1572
msgid "Indicates that rounding occurred and the result is not exact."
msgstr "Indica que o arredondamento ocorreu e o resultado não é exato."

#: ../../library/decimal.rst:1574
msgid ""
"Signals when non-zero digits were discarded during rounding. The rounded "
"result is returned.  The signal flag or trap is used to detect when results "
"are inexact."
msgstr ""
"Sinaliza quando dígitos diferentes de zero foram descartados durante o "
"arredondamento. O resultado arredondado é retornado. O sinalizador ou "
"armadilha de sinal é usado para detectar quando os resultados são inexatos."

#: ../../library/decimal.rst:1581
msgid "An invalid operation was performed."
msgstr "Uma operação inválida foi realizada."

#: ../../library/decimal.rst:1583
msgid ""
"Indicates that an operation was requested that does not make sense. If not "
"trapped, returns :const:`NaN`.  Possible causes include::"
msgstr ""
"Indica que uma operação foi solicitada que não faz sentido. Se não for "
"capturado, retorna :const:`NaN`. As possíveis causas incluem::"

#: ../../library/decimal.rst:1599
msgid "Numerical overflow."
msgstr "Estouro numérico."

#: ../../library/decimal.rst:1601
msgid ""
"Indicates the exponent is larger than :attr:`Emax` after rounding has "
"occurred.  If not trapped, the result depends on the rounding mode, either "
"pulling inward to the largest representable finite number or rounding "
"outward to :const:`Infinity`.  In either case, :class:`Inexact` and :class:"
"`Rounded` are also signaled."
msgstr ""
"Indica que o expoente é maior que :attr:`Emax` após o arredondamento "
"ocorrer. Se não for capturado, o resultado depende do modo de "
"arredondamento, puxando para dentro para o maior número finito representável "
"ou arredondando para fora para :const:`Infinity`. Nos dois casos, :class:"
"`Inexact` e :class:`Rounded` também são sinalizados."

#: ../../library/decimal.rst:1610
msgid "Rounding occurred though possibly no information was lost."
msgstr ""
"O arredondamento ocorreu, embora possivelmente nenhuma informação tenha sido "
"perdida."

#: ../../library/decimal.rst:1612
msgid ""
"Signaled whenever rounding discards digits; even if those digits are zero "
"(such as rounding :const:`5.00` to :const:`5.0`).  If not trapped, returns "
"the result unchanged.  This signal is used to detect loss of significant "
"digits."
msgstr ""
"Sinalizado sempre que o arredondamento descarta dígitos; mesmo que esses "
"dígitos sejam zero (como arredondamento :const:`5.00` a :const:`5.0`). Se "
"não for capturado, retorna o resultado inalterado. Este sinal é usado para "
"detectar a perda de dígitos significativos."

#: ../../library/decimal.rst:1620
msgid "Exponent was lower than :attr:`Emin` prior to rounding."
msgstr "O expoente foi menor que :attr:`Emin` antes do arredondamento."

#: ../../library/decimal.rst:1622
msgid ""
"Occurs when an operation result is subnormal (the exponent is too small). If "
"not trapped, returns the result unchanged."
msgstr ""
"Ocorre quando um resultado da operação é subnormal (o expoente é muito "
"pequeno). Se não for capturado, retorna o resultado inalterado."

#: ../../library/decimal.rst:1628
msgid "Numerical underflow with result rounded to zero."
msgstr "Estouro negativo numérico com resultado arredondado para zero."

#: ../../library/decimal.rst:1630
msgid ""
"Occurs when a subnormal result is pushed to zero by rounding. :class:"
"`Inexact` and :class:`Subnormal` are also signaled."
msgstr ""
"Ocorre quando um resultado subnormal é empurrado para zero arredondando. :"
"class:`Inexact` e :class:`Subnormal` também são sinalizados."

#: ../../library/decimal.rst:1636
msgid "Enable stricter semantics for mixing floats and Decimals."
msgstr ""
"Ativa semânticas mais rigorosas para misturar objetos de float com de "
"Decimal."

#: ../../library/decimal.rst:1638
msgid ""
"If the signal is not trapped (default), mixing floats and Decimals is "
"permitted in the :class:`~decimal.Decimal` constructor, :meth:`~decimal."
"Context.create_decimal` and all comparison operators. Both conversion and "
"comparisons are exact. Any occurrence of a mixed operation is silently "
"recorded by setting :exc:`FloatOperation` in the context flags. Explicit "
"conversions with :meth:`~decimal.Decimal.from_float` or :meth:`~decimal."
"Context.create_decimal_from_float` do not set the flag."
msgstr ""

#: ../../library/decimal.rst:1646
msgid ""
"Otherwise (the signal is trapped), only equality comparisons and explicit "
"conversions are silent. All other mixed operations raise :exc:"
"`FloatOperation`."
msgstr ""

#: ../../library/decimal.rst:1650
msgid "The following table summarizes the hierarchy of signals::"
msgstr ""

#: ../../library/decimal.rst:1671
msgid "Floating Point Notes"
msgstr ""

#: ../../library/decimal.rst:1675
msgid "Mitigating round-off error with increased precision"
msgstr ""

#: ../../library/decimal.rst:1677
msgid ""
"The use of decimal floating point eliminates decimal representation error "
"(making it possible to represent :const:`0.1` exactly); however, some "
"operations can still incur round-off error when non-zero digits exceed the "
"fixed precision."
msgstr ""

#: ../../library/decimal.rst:1681
msgid ""
"The effects of round-off error can be amplified by the addition or "
"subtraction of nearly offsetting quantities resulting in loss of "
"significance.  Knuth provides two instructive examples where rounded "
"floating point arithmetic with insufficient precision causes the breakdown "
"of the associative and distributive properties of addition:"
msgstr ""

#: ../../library/decimal.rst:1705
msgid ""
"The :mod:`decimal` module makes it possible to restore the identities by "
"expanding the precision sufficiently to avoid loss of significance:"
msgstr ""

#: ../../library/decimal.rst:1725
msgid "Special values"
msgstr ""

#: ../../library/decimal.rst:1727
msgid ""
"The number system for the :mod:`decimal` module provides special values "
"including :const:`NaN`, :const:`sNaN`, :const:`-Infinity`, :const:"
"`Infinity`, and two zeros, :const:`+0` and :const:`-0`."
msgstr ""

#: ../../library/decimal.rst:1731
msgid ""
"Infinities can be constructed directly with:  ``Decimal('Infinity')``. Also, "
"they can arise from dividing by zero when the :exc:`DivisionByZero` signal "
"is not trapped.  Likewise, when the :exc:`Overflow` signal is not trapped, "
"infinity can result from rounding beyond the limits of the largest "
"representable number."
msgstr ""

#: ../../library/decimal.rst:1736
msgid ""
"The infinities are signed (affine) and can be used in arithmetic operations "
"where they get treated as very large, indeterminate numbers.  For instance, "
"adding a constant to infinity gives another infinite result."
msgstr ""

#: ../../library/decimal.rst:1740
msgid ""
"Some operations are indeterminate and return :const:`NaN`, or if the :exc:"
"`InvalidOperation` signal is trapped, raise an exception.  For example, "
"``0/0`` returns :const:`NaN` which means \"not a number\".  This variety of :"
"const:`NaN` is quiet and, once created, will flow through other computations "
"always resulting in another :const:`NaN`.  This behavior can be useful for a "
"series of computations that occasionally have missing inputs --- it allows "
"the calculation to proceed while flagging specific results as invalid."
msgstr ""

#: ../../library/decimal.rst:1748
msgid ""
"A variant is :const:`sNaN` which signals rather than remaining quiet after "
"every operation.  This is a useful return value when an invalid result needs "
"to interrupt a calculation for special handling."
msgstr ""

#: ../../library/decimal.rst:1752
msgid ""
"The behavior of Python's comparison operators can be a little surprising "
"where a :const:`NaN` is involved.  A test for equality where one of the "
"operands is a quiet or signaling :const:`NaN` always returns :const:`False` "
"(even when doing ``Decimal('NaN')==Decimal('NaN')``), while a test for "
"inequality always returns :const:`True`.  An attempt to compare two Decimals "
"using any of the ``<``, ``<=``, ``>`` or ``>=`` operators will raise the :"
"exc:`InvalidOperation` signal if either operand is a :const:`NaN`, and "
"return :const:`False` if this signal is not trapped.  Note that the General "
"Decimal Arithmetic specification does not specify the behavior of direct "
"comparisons; these rules for comparisons involving a :const:`NaN` were taken "
"from the IEEE 854 standard (see Table 3 in section 5.7).  To ensure strict "
"standards-compliance, use the :meth:`compare` and :meth:`compare-signal` "
"methods instead."
msgstr ""

#: ../../library/decimal.rst:1765
msgid ""
"The signed zeros can result from calculations that underflow. They keep the "
"sign that would have resulted if the calculation had been carried out to "
"greater precision.  Since their magnitude is zero, both positive and "
"negative zeros are treated as equal and their sign is informational."
msgstr ""

#: ../../library/decimal.rst:1770
msgid ""
"In addition to the two signed zeros which are distinct yet equal, there are "
"various representations of zero with differing precisions yet equivalent in "
"value.  This takes a bit of getting used to.  For an eye accustomed to "
"normalized floating point representations, it is not immediately obvious "
"that the following calculation returns a value equal to zero:"
msgstr ""

#: ../../library/decimal.rst:1785
msgid "Working with threads"
msgstr ""

#: ../../library/decimal.rst:1787
msgid ""
"The :func:`getcontext` function accesses a different :class:`Context` object "
"for each thread.  Having separate thread contexts means that threads may "
"make changes (such as ``getcontext().prec=10``) without interfering with "
"other threads."
msgstr ""

#: ../../library/decimal.rst:1791
msgid ""
"Likewise, the :func:`setcontext` function automatically assigns its target "
"to the current thread."
msgstr ""

#: ../../library/decimal.rst:1794
msgid ""
"If :func:`setcontext` has not been called before :func:`getcontext`, then :"
"func:`getcontext` will automatically create a new context for use in the "
"current thread."
msgstr ""

#: ../../library/decimal.rst:1798
msgid ""
"The new context is copied from a prototype context called *DefaultContext*. "
"To control the defaults so that each thread will use the same values "
"throughout the application, directly modify the *DefaultContext* object. "
"This should be done *before* any threads are started so that there won't be "
"a race condition between threads calling :func:`getcontext`. For example::"
msgstr ""

#: ../../library/decimal.rst:1823
msgid "Recipes"
msgstr ""

#: ../../library/decimal.rst:1825
msgid ""
"Here are a few recipes that serve as utility functions and that demonstrate "
"ways to work with the :class:`Decimal` class::"
msgstr ""

#: ../../library/decimal.rst:1980
msgid "Decimal FAQ"
msgstr ""

#: ../../library/decimal.rst:1982
msgid ""
"Q. It is cumbersome to type ``decimal.Decimal('1234.5')``.  Is there a way "
"to minimize typing when using the interactive interpreter?"
msgstr ""

#: ../../library/decimal.rst:1985
msgid "A. Some users abbreviate the constructor to just a single letter:"
msgstr ""

#: ../../library/decimal.rst:1991
msgid ""
"Q. In a fixed-point application with two decimal places, some inputs have "
"many places and need to be rounded.  Others are not supposed to have excess "
"digits and need to be validated.  What methods should be used?"
msgstr ""

#: ../../library/decimal.rst:1995
msgid ""
"A. The :meth:`quantize` method rounds to a fixed number of decimal places. "
"If the :const:`Inexact` trap is set, it is also useful for validation:"
msgstr ""

#: ../../library/decimal.rst:2013
msgid ""
"Q. Once I have valid two place inputs, how do I maintain that invariant "
"throughout an application?"
msgstr ""

#: ../../library/decimal.rst:2016
msgid ""
"A. Some operations like addition, subtraction, and multiplication by an "
"integer will automatically preserve fixed point.  Others operations, like "
"division and non-integer multiplication, will change the number of decimal "
"places and need to be followed-up with a :meth:`quantize` step:"
msgstr ""

#: ../../library/decimal.rst:2034
msgid ""
"In developing fixed-point applications, it is convenient to define functions "
"to handle the :meth:`quantize` step:"
msgstr ""

#: ../../library/decimal.rst:2047
msgid ""
"Q. There are many ways to express the same value.  The numbers :const:"
"`200`, :const:`200.000`, :const:`2E2`, and :const:`.02E+4` all have the same "
"value at various precisions. Is there a way to transform them to a single "
"recognizable canonical value?"
msgstr ""

#: ../../library/decimal.rst:2052
msgid ""
"A. The :meth:`normalize` method maps all equivalent values to a single "
"representative:"
msgstr ""

#: ../../library/decimal.rst:2059
msgid ""
"Q. Some decimal values always print with exponential notation.  Is there a "
"way to get a non-exponential representation?"
msgstr ""

#: ../../library/decimal.rst:2062
msgid ""
"A. For some values, exponential notation is the only way to express the "
"number of significant places in the coefficient.  For example, expressing :"
"const:`5.0E+3` as :const:`5000` keeps the value constant but cannot show the "
"original's two-place significance."
msgstr ""

#: ../../library/decimal.rst:2067
msgid ""
"If an application does not care about tracking significance, it is easy to "
"remove the exponent and trailing zeroes, losing significance, but keeping "
"the value unchanged:"
msgstr ""

#: ../../library/decimal.rst:2077
msgid "Q. Is there a way to convert a regular float to a :class:`Decimal`?"
msgstr ""

#: ../../library/decimal.rst:2079
msgid ""
"A. Yes, any binary floating point number can be exactly expressed as a "
"Decimal though an exact conversion may take more precision than intuition "
"would suggest:"
msgstr ""

#: ../../library/decimal.rst:2088
msgid ""
"Q. Within a complex calculation, how can I make sure that I haven't gotten a "
"spurious result because of insufficient precision or rounding anomalies."
msgstr ""

#: ../../library/decimal.rst:2091
msgid ""
"A. The decimal module makes it easy to test results.  A best practice is to "
"re-run calculations using greater precision and with various rounding modes. "
"Widely differing results indicate insufficient precision, rounding mode "
"issues, ill-conditioned inputs, or a numerically unstable algorithm."
msgstr ""

#: ../../library/decimal.rst:2096
msgid ""
"Q. I noticed that context precision is applied to the results of operations "
"but not to the inputs.  Is there anything to watch out for when mixing "
"values of different precisions?"
msgstr ""

#: ../../library/decimal.rst:2100
msgid ""
"A. Yes.  The principle is that all values are considered to be exact and so "
"is the arithmetic on those values.  Only the results are rounded.  The "
"advantage for inputs is that \"what you type is what you get\".  A "
"disadvantage is that the results can look odd if you forget that the inputs "
"haven't been rounded:"
msgstr ""

#: ../../library/decimal.rst:2113
msgid ""
"The solution is either to increase precision or to force rounding of inputs "
"using the unary plus operation:"
msgstr ""

#: ../../library/decimal.rst:2122
msgid ""
"Alternatively, inputs can be rounded upon creation using the :meth:`Context."
"create_decimal` method:"
msgstr ""

#: ../../library/decimal.rst:2128
msgid "Q. Is the CPython implementation fast for large numbers?"
msgstr ""

#: ../../library/decimal.rst:2130
msgid ""
"A. Yes.  In the CPython and PyPy3 implementations, the C/CFFI versions of "
"the decimal module integrate the high speed `libmpdec <https://www.bytereef."
"org/mpdecimal/doc/libmpdec/index.html>`_ library for arbitrary precision "
"correctly-rounded decimal floating point arithmetic [#]_. ``libmpdec`` uses "
"`Karatsuba multiplication <https://en.wikipedia.org/wiki/"
"Karatsuba_algorithm>`_ for medium-sized numbers and the `Number Theoretic "
"Transform <https://en.wikipedia.org/wiki/"
"Discrete_Fourier_transform_(general)#Number-theoretic_transform>`_ for very "
"large numbers."
msgstr ""

#: ../../library/decimal.rst:2140
msgid ""
"The context must be adapted for exact arbitrary precision arithmetic. :attr:"
"`Emin` and :attr:`Emax` should always be set to the maximum values, :attr:"
"`clamp` should always be 0 (the default).  Setting :attr:`prec` requires "
"some care."
msgstr ""

#: ../../library/decimal.rst:2144
msgid ""
"The easiest approach for trying out bignum arithmetic is to use the maximum "
"value for :attr:`prec` as well [#]_::"
msgstr ""

#: ../../library/decimal.rst:2153
msgid ""
"For inexact results, :attr:`MAX_PREC` is far too large on 64-bit platforms "
"and the available memory will be insufficient::"
msgstr ""

#: ../../library/decimal.rst:2161
msgid ""
"On systems with overallocation (e.g. Linux), a more sophisticated approach "
"is to adjust :attr:`prec` to the amount of available RAM.  Suppose that you "
"have 8GB of RAM and expect 10 simultaneous operands using a maximum of 500MB "
"each::"
msgstr ""

#: ../../library/decimal.rst:2185
msgid ""
"In general (and especially on systems without overallocation), it is "
"recommended to estimate even tighter bounds and set the :attr:`Inexact` trap "
"if all calculations are expected to be exact."
msgstr ""

#: ../../library/decimal.rst:2194
msgid ""
"This approach now works for all exact results except for non-integer powers. "
"Also backported to 3.7 and 3.8."
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# i17obot <i17obot@rougeth.com>, 2020
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 17:51+0000\n"
"PO-Revision-Date: 2017-02-16 23:07+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/email.contentmanager.rst:2
msgid ":mod:`email.contentmanager`: Managing MIME Content"
msgstr ":mod:`email.contentmanager`: Керування вмістом MIME"

#: ../../library/email.contentmanager.rst:10
msgid "**Source code:** :source:`Lib/email/contentmanager.py`"
msgstr "**Código-fonte:** :source:`Lib/email/contentmanager.py`"

#: ../../library/email.contentmanager.rst:14
msgid "[1]_"
msgstr "[1]_"

#: ../../library/email.contentmanager.rst:19
msgid ""
"Base class for content managers.  Provides the standard registry mechanisms "
"to register converters between MIME content and other representations, as "
"well as the ``get_content`` and ``set_content`` dispatch methods."
msgstr ""
"Classe base para gerenciadores de conteúdo. Fornece os mecanismos de "
"registro padrão para registrar conversores entre conteúdo MIME e outras "
"representações, bem como os métodos de despacho ``get_content`` e "
"``set_content``."

#: ../../library/email.contentmanager.rst:26
msgid ""
"Look up a handler function based on the ``mimetype`` of *msg* (see next "
"paragraph), call it, passing through all arguments, and return the result of "
"the call.  The expectation is that the handler will extract the payload from "
"*msg* and return an object that encodes information about the extracted data."
msgstr ""
"Procura uma função manipuladora baseada no ``mimetype`` de *msg* (veja o "
"próximo parágrafo), chama-a, passando por todos os argumentos, e retorna o "
"resultado da chamada. A expectativa é que a função manipuladora extraia o "
"payload de *msg* e retorne um objeto que codifique informações sobre os "
"dados extraídos."

#: ../../library/email.contentmanager.rst:32
msgid ""
"To find the handler, look for the following keys in the registry, stopping "
"with the first one found:"
msgstr ""
"Para encontrar o manipulador, procura as seguintes chaves no registro, "
"parando na primeira encontrada:"

#: ../../library/email.contentmanager.rst:35
msgid "the string representing the full MIME type (``maintype/subtype``)"
msgstr "a string que representa o tipo MIME completo (``maintype/subtype``)"

#: ../../library/email.contentmanager.rst:36
msgid "the string representing the ``maintype``"
msgstr "рядок, що представляє ``maintype``"

#: ../../library/email.contentmanager.rst:37
msgid "the empty string"
msgstr "порожній рядок"

#: ../../library/email.contentmanager.rst:39
msgid ""
"If none of these keys produce a handler, raise a :exc:`KeyError` for the "
"full MIME type."
msgstr ""
"Якщо жоден із цих ключів не створює обробник, викличте :exc:`KeyError` для "
"повного типу MIME."

#: ../../library/email.contentmanager.rst:45
msgid ""
"If the ``maintype`` is ``multipart``, raise a :exc:`TypeError`; otherwise "
"look up a handler function based on the type of *obj* (see next paragraph), "
"call :meth:`~email.message.EmailMessage.clear_content` on the *msg*, and "
"call the handler function, passing through all arguments.  The expectation "
"is that the handler will transform and store *obj* into *msg*, possibly "
"making other changes to *msg* as well, such as adding various MIME headers "
"to encode information needed to interpret the stored data."
msgstr ""
"Якщо ``maintype`` є ``multipart``, викликати :exc:`TypeError`; інакше "
"знайдіть функцію обробки на основі типу *obj* (див. наступний абзац), "
"викличте :meth:`~email.message.EmailMessage.clear_content` у *msg* та "
"викликайте функцію обробки, передаючи всі аргументи . Очікується, що "
"обробник перетворить і збереже *obj* в *msg*, можливо також вносячи інші "
"зміни в *msg*, наприклад додаючи різні заголовки MIME для кодування "
"інформації, необхідної для інтерпретації збережених даних."

#: ../../library/email.contentmanager.rst:54
msgid ""
"To find the handler, obtain the type of *obj* (``typ = type(obj)``), and "
"look for the following keys in the registry, stopping with the first one "
"found:"
msgstr ""
"Щоб знайти обробник, отримайте тип *obj* (``typ = type(obj)``) і знайдіть "
"наступні ключі в реєстрі, зупиняючись на першому знайденому:"

#: ../../library/email.contentmanager.rst:58
msgid "the type itself (``typ``)"
msgstr "сам тип (``typ``)"

#: ../../library/email.contentmanager.rst:59
msgid ""
"the type's fully qualified name (``typ.__module__ + '.' + typ."
"__qualname__``)."
msgstr "повне ім’я типу (``typ.__module__ + '.' + typ.__qualname__``)."

#: ../../library/email.contentmanager.rst:61
msgid "the type's qualname (``typ.__qualname__``)"
msgstr "qualname типу (``typ.__qualname__``)"

#: ../../library/email.contentmanager.rst:62
msgid "the type's name (``typ.__name__``)."
msgstr "назва типу (``typ.__name__``)."

#: ../../library/email.contentmanager.rst:64
msgid ""
"If none of the above match, repeat all of the checks above for each of the "
"types in the :term:`MRO` (``typ.__mro__``).  Finally, if no other key yields "
"a handler, check for a handler for the key ``None``.  If there is no handler "
"for ``None``, raise a :exc:`KeyError` for the fully qualified name of the "
"type."
msgstr ""
"Якщо нічого з наведеного вище не відповідає, повторіть усі перевірки, "
"наведені вище, для кожного типу в :term:`MRO` (``typ.__mro__``). Нарешті, "
"якщо жоден інший ключ не дає обробника, перевірте наявність обробника для "
"ключа ``None``. Якщо немає обробника для ``None``, підніміть :exc:`KeyError` "
"для повної назви типу."

#: ../../library/email.contentmanager.rst:70
msgid ""
"Also add a :mailheader:`MIME-Version` header if one is not present (see "
"also :class:`.MIMEPart`)."
msgstr ""
"Також додайте заголовок :mailheader:`MIME-Version`, якщо його немає (див. "
"також :class:`.MIMEPart`)."

#: ../../library/email.contentmanager.rst:76
msgid ""
"Record the function *handler* as the handler for *key*.  For the possible "
"values of *key*, see :meth:`get_content`."
msgstr ""
"Запишіть функцію *обробник* як обробник для *ключа*. Можливі значення *key* "
"див. у :meth:`get_content`."

#: ../../library/email.contentmanager.rst:82
msgid ""
"Record *handler* as the function to call when an object of a type matching "
"*typekey* is passed to :meth:`set_content`.  For the possible values of "
"*typekey*, see :meth:`set_content`."
msgstr ""
"Запишіть *обробник* як функцію для виклику, коли об’єкт типу, який "
"відповідає *typekey*, передається до :meth:`set_content`. Можливі значення "
"*typekey* див. у :meth:`set_content`."

#: ../../library/email.contentmanager.rst:88
msgid "Content Manager Instances"
msgstr "Примірники Content Manager"

#: ../../library/email.contentmanager.rst:90
msgid ""
"Currently the email package provides only one concrete content manager, :"
"data:`raw_data_manager`, although more may be added in the future. :data:"
"`raw_data_manager` is the :attr:`~email.policy.EmailPolicy.content_manager` "
"provided by :attr:`~email.policy.EmailPolicy` and its derivatives."
msgstr ""
"Наразі пакет електронної пошти містить лише один конкретний менеджер "
"вмісту, :data:`raw_data_manager`, хоча в майбутньому може бути додано "
"більше. :data:`raw_data_manager` — це :attr:`~email.policy.EmailPolicy."
"content_manager`, наданий :attr:`~email.policy.EmailPolicy` та його "
"похідними."

#: ../../library/email.contentmanager.rst:99
msgid ""
"This content manager provides only a minimum interface beyond that provided "
"by :class:`~email.message.Message` itself:  it deals only with text, raw "
"byte strings, and :class:`~email.message.Message` objects.  Nevertheless, it "
"provides significant advantages compared to the base API: ``get_content`` on "
"a text part will return a unicode string without the application needing to "
"manually decode it, ``set_content`` provides a rich set of options for "
"controlling the headers added to a part and controlling the content transfer "
"encoding, and it enables the use of the various ``add_`` methods, thereby "
"simplifying the creation of multipart messages."
msgstr ""
"Цей менеджер вмісту надає лише мінімальний інтерфейс, окрім того, який надає "
"сам :class:`~email.message.Message`: він має справу лише з текстом, "
"необробленими рядками байтів та об’єктами :class:`~email.message.Message`. "
"Тим не менш, він надає значні переваги порівняно з базовим API: "
"``get_content`` у текстовій частині поверне рядок Unicode без необхідності "
"програми вручну декодувати його, ``set_content`` надає багатий набір "
"параметрів для керування заголовками додається до частини та контролює "
"кодування передачі вмісту, а також дозволяє використовувати різні методи "
"``add_``, тим самим спрощуючи створення багатокомпонентних повідомлень."

#: ../../library/email.contentmanager.rst:111
msgid ""
"Return the payload of the part as either a string (for ``text`` parts), an :"
"class:`~email.message.EmailMessage` object (for ``message/rfc822`` parts), "
"or a ``bytes`` object (for all other non-multipart types).  Raise a :exc:"
"`KeyError` if called on a ``multipart``.  If the part is a ``text`` part and "
"*errors* is specified, use it as the error handler when decoding the payload "
"to unicode.  The default error handler is ``replace``."
msgstr ""
"Повертає корисне навантаження частини як рядок (для частин ``text``), "
"об’єкт :class:`~email.message.EmailMessage` (для частин ``message/rfc822``) "
"або ``bytes`` об'єкт (для всіх інших нескладних типів). Викликає :exc:"
"`KeyError`, якщо викликається на ``multipart``. Якщо частина є частиною "
"``text`` і вказано *errors*, використовуйте її як обробник помилок під час "
"декодування корисного навантаження в Юнікод. Обробником помилок за "
"замовчуванням є ``replace``."

#: ../../library/email.contentmanager.rst:130
msgid "Add headers and payload to *msg*:"
msgstr "Adicione headers e payload à *msg*:"

#: ../../library/email.contentmanager.rst:132
msgid ""
"Add a :mailheader:`Content-Type` header with a ``maintype/subtype`` value."
msgstr ""
"Додайте заголовок :mailheader:`Content-Type` зі значенням ``maintype/"
"subtype``."

#: ../../library/email.contentmanager.rst:135
msgid ""
"For ``str``, set the MIME ``maintype`` to ``text``, and set the subtype to "
"*subtype* if it is specified, or ``plain`` if it is not."
msgstr ""
"Для ``str`` встановіть ``maintype`` MIME на ``text`` і встановіть підтип на "
"*subtype*, якщо він указаний, або ``plain``, якщо він не вказано."

#: ../../library/email.contentmanager.rst:137
msgid ""
"For ``bytes``, use the specified *maintype* and *subtype*, or raise a :exc:"
"`TypeError` if they are not specified."
msgstr ""
"Для ``bytes`` використовуйте вказані *maintype* і *subtype* або викликайте :"
"exc:`TypeError`, якщо вони не вказані."

#: ../../library/email.contentmanager.rst:139
msgid ""
"For :class:`~email.message.EmailMessage` objects, set the maintype to "
"``message``, and set the subtype to *subtype* if it is specified or "
"``rfc822`` if it is not.  If *subtype* is ``partial``, raise an error "
"(``bytes`` objects must be used to construct ``message/partial`` parts)."
msgstr ""
"Для об’єктів :class:`~email.message.EmailMessage` встановіть основний тип як "
"``message``, а для підтипу встановіть *subtype*, якщо він указаний, або "
"``rfc822``, якщо його немає. Якщо *subtype* має значення ``partial``, "
"виникає помилка (об’єкти ``bytes`` повинні використовуватися для створення "
"частин ``message/partial``)."

#: ../../library/email.contentmanager.rst:145
msgid ""
"If *charset* is provided (which is valid only for ``str``), encode the "
"string to bytes using the specified character set.  The default is "
"``utf-8``.  If the specified *charset* is a known alias for a standard MIME "
"charset name, use the standard charset instead."
msgstr ""
"Якщо надано *charset* (який дійсний лише для ``str``), закодуйте рядок у "
"байти за допомогою вказаного набору символів. Типовим є ``utf-8``. Якщо "
"вказаний *набір символів* є відомим псевдонімом для назви стандартного "
"набору кодів MIME, замість цього використовуйте стандартний набір символів."

#: ../../library/email.contentmanager.rst:150
msgid ""
"If *cte* is set, encode the payload using the specified content transfer "
"encoding, and set the :mailheader:`Content-Transfer-Encoding` header to that "
"value.  Possible values for *cte* are ``quoted-printable``, ``base64``, "
"``7bit``, ``8bit``, and ``binary``.  If the input cannot be encoded in the "
"specified encoding (for example, specifying a *cte* of ``7bit`` for an input "
"that contains non-ASCII values), raise a :exc:`ValueError`."
msgstr ""
"Якщо встановлено *cte*, закодуйте корисне навантаження, використовуючи "
"вказане кодування передачі вмісту, і встановіть це значення для заголовка :"
"mailheader:`Content-Transfer-Encoding`. Можливі значення для *cte*: ``quoted-"
"printable``, ``base64``, ``7bit``, ``8bit`` і ``binary``. Якщо вхідні дані "
"не можна закодувати у вказаному кодуванні (наприклад, вказавши *cte* "
"``7bit`` для вхідних даних, які містять значення, відмінні від ASCII), "
"викликайте :exc:`ValueError`."

#: ../../library/email.contentmanager.rst:158
msgid ""
"For ``str`` objects, if *cte* is not set use heuristics to determine the "
"most compact encoding."
msgstr ""
"Для об’єктів ``str``, якщо *cte* не встановлено, використовуйте евристику "
"для визначення найбільш компактного кодування."

#: ../../library/email.contentmanager.rst:160
msgid ""
"For :class:`~email.message.EmailMessage`, per :rfc:`2046`, raise an error if "
"a *cte* of ``quoted-printable`` or ``base64`` is requested for *subtype* "
"``rfc822``, and for any *cte* other than ``7bit`` for *subtype* ``external-"
"body``.  For ``message/rfc822``, use ``8bit`` if *cte* is not specified.  "
"For all other values of *subtype*, use ``7bit``."
msgstr ""
"Для :class:`~email.message.EmailMessage`, відповідно до :rfc:`2046`, "
"викликати помилку, якщо *cte* ``quoted-printable`` або ``base64`` "
"запитується для *підтипу* ``rfc822`` і для будь-якого *cte*, крім ``7bit`` "
"для *підтипу* ``external-body``. Для ``message/rfc822`` використовуйте "
"``8bit``, якщо *cte* не вказано. Для всіх інших значень *subtype* "
"використовуйте ``7bit``."

#: ../../library/email.contentmanager.rst:167
msgid ""
"A *cte* of ``binary`` does not actually work correctly yet. The "
"``EmailMessage`` object as modified by ``set_content`` is correct, but :"
"class:`~email.generator.BytesGenerator` does not serialize it correctly."
msgstr ""
"*cte* ``binary`` насправді ще не працює належним чином. Об’єкт "
"``EmailMessage``, змінений ``set_content`` є правильним, але :class:`~email."
"generator.BytesGenerator` не серіалізує його правильно."

#: ../../library/email.contentmanager.rst:172
msgid ""
"If *disposition* is set, use it as the value of the :mailheader:`Content-"
"Disposition` header.  If not specified, and *filename* is specified, add the "
"header with the value ``attachment``. If *disposition* is not specified and "
"*filename* is also not specified, do not add the header.  The only valid "
"values for *disposition* are ``attachment`` and ``inline``."
msgstr ""
"Якщо встановлено *disposition*, використовуйте його як значення заголовка :"
"mailheader:`Content-Disposition`. Якщо не вказано, але вказано *filename*, "
"додайте заголовок зі значенням ``attachment``. Якщо *disposition* не вказано "
"і *filename* також не вказано, не додавайте заголовок. Єдиними дійсними "
"значеннями для *disposition* є ``attachment`` і ``inline``."

#: ../../library/email.contentmanager.rst:179
msgid ""
"If *filename* is specified, use it as the value of the ``filename`` "
"parameter of the :mailheader:`Content-Disposition` header."
msgstr ""
"Якщо вказано *filename*, використовуйте його як значення параметра "
"``filename`` заголовка :mailheader:`Content-Disposition`."

#: ../../library/email.contentmanager.rst:182
msgid ""
"If *cid* is specified, add a :mailheader:`Content-ID` header with *cid* as "
"its value."
msgstr ""
"Якщо вказано *cid*, додайте заголовок :mailheader:`Content-ID` зі значенням "
"*cid*."

#: ../../library/email.contentmanager.rst:185
msgid ""
"If *params* is specified, iterate its ``items`` method and use the resulting "
"``(key, value)`` pairs to set additional parameters on the :mailheader:"
"`Content-Type` header."
msgstr ""
"Якщо вказано *params*, повторіть його метод ``items`` і використовуйте "
"отримані пари ``(key, value)``, щоб установити додаткові параметри в "
"заголовку :mailheader:`Content-Type`."

#: ../../library/email.contentmanager.rst:189
msgid ""
"If *headers* is specified and is a list of strings of the form ``headername: "
"headervalue`` or a list of ``header`` objects (distinguished from strings by "
"having a ``name`` attribute), add the headers to *msg*."
msgstr ""
"Якщо вказано *headers* і це список рядків у формі ``назва заголовка: "
"значення заголовка`` або список об’єктів ``заголовка`` (відрізняються від "
"рядків наявністю атрибута ``назва``), додайте заголовки на *повідомлення*."

#: ../../library/email.contentmanager.rst:196
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../library/email.contentmanager.rst:197
msgid ""
"Originally added in 3.4 as a :term:`provisional module <provisional package>`"
msgstr ""
"Спочатку додано в 3.4 як :term:`проміжний модуль <provisional package>`"

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 16:41+0000\n"
"PO-Revision-Date: 2023-05-24 03:55+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/codecs.rst:2
msgid ":mod:`codecs` --- Codec registry and base classes"
msgstr ""

#: ../../library/codecs.rst:11
msgid "**Source code:** :source:`Lib/codecs.py`"
msgstr "**Código-fonte:** :source:`Lib/codecs.py`"

#: ../../library/codecs.rst:23
msgid ""
"This module defines base classes for standard Python codecs (encoders and "
"decoders) and provides access to the internal Python codec registry, which "
"manages the codec and error handling lookup process. Most standard codecs "
"are :term:`text encodings <text encoding>`, which encode text to bytes (and "
"decode bytes to text), but there are also codecs provided that encode text "
"to text, and bytes to bytes. Custom codecs may encode and decode between "
"arbitrary types, but some module features are restricted to be used "
"specifically with :term:`text encodings <text encoding>` or with codecs that "
"encode to :class:`bytes`."
msgstr ""
"Цей модуль визначає базові класи для стандартних кодеків Python (кодери та "
"декодери) і надає доступ до внутрішнього реєстру кодеків Python, який керує "
"процесом пошуку кодека та обробки помилок. Більшість стандартних кодеків — "
"це :term:`кодування тексту <text encoding>`, які кодують текст у байти (і "
"декодують байти в текст), але є також кодеки, які кодують текст у текст і "
"байти в байти. Спеціальні кодеки можуть кодувати та декодувати між "
"довільними типами, але деякі функції модулів обмежено для використання "
"спеціально з :term:`текстовими кодуваннями <text encoding>` або з кодеками, "
"які кодують у :class:`bytes`."

#: ../../library/codecs.rst:33
msgid ""
"The module defines the following functions for encoding and decoding with "
"any codec:"
msgstr ""
"Модуль визначає такі функції для кодування та декодування будь-яким кодеком:"

#: ../../library/codecs.rst:38
msgid "Encodes *obj* using the codec registered for *encoding*."
msgstr "Кодує *obj* за допомогою кодека, зареєстрованого для *кодування*."

#: ../../library/codecs.rst:40
msgid ""
"*Errors* may be given to set the desired error handling scheme. The default "
"error handler is ``'strict'`` meaning that encoding errors raise :exc:"
"`ValueError` (or a more codec specific subclass, such as :exc:"
"`UnicodeEncodeError`). Refer to :ref:`codec-base-classes` for more "
"information on codec error handling."
msgstr ""
"*Помилки* можуть бути надані для встановлення потрібної схеми обробки "
"помилок. Обробником помилок за замовчуванням є ``'strict'``, що означає, що "
"помилки кодування викликають :exc:`ValueError` (або більш специфічний "
"підклас кодека, наприклад :exc:`UnicodeEncodeError`). Зверніться до :ref:"
"`codec-base-classes` для отримання додаткової інформації щодо обробки "
"помилок кодека."

#: ../../library/codecs.rst:48
msgid "Decodes *obj* using the codec registered for *encoding*."
msgstr "Декодує *obj* за допомогою кодека, зареєстрованого для *кодування*."

#: ../../library/codecs.rst:50
msgid ""
"*Errors* may be given to set the desired error handling scheme. The default "
"error handler is ``'strict'`` meaning that decoding errors raise :exc:"
"`ValueError` (or a more codec specific subclass, such as :exc:"
"`UnicodeDecodeError`). Refer to :ref:`codec-base-classes` for more "
"information on codec error handling."
msgstr ""
"*Помилки* можуть бути надані для встановлення потрібної схеми обробки "
"помилок. Обробником помилок за замовчуванням є ``'strict'``, що означає, що "
"помилки декодування викликають :exc:`ValueError` (або більш специфічний "
"підклас кодека, такий як :exc:`UnicodeDecodeError`). Зверніться до :ref:"
"`codec-base-classes` для отримання додаткової інформації про обробку помилок "
"кодека."

#: ../../library/codecs.rst:56
msgid "The full details for each codec can also be looked up directly:"
msgstr ""
"Повну інформацію про кожен кодек також можна переглянути безпосередньо:"

#: ../../library/codecs.rst:60
msgid ""
"Looks up the codec info in the Python codec registry and returns a :class:"
"`CodecInfo` object as defined below."
msgstr ""
"Шукає інформацію про кодек у реєстрі кодеків Python і повертає об’єкт :class:"
"`CodecInfo`, як визначено нижче."

#: ../../library/codecs.rst:63
msgid ""
"Encodings are first looked up in the registry's cache. If not found, the "
"list of registered search functions is scanned. If no :class:`CodecInfo` "
"object is found, a :exc:`LookupError` is raised. Otherwise, the :class:"
"`CodecInfo` object is stored in the cache and returned to the caller."
msgstr ""
"Кодування спочатку шукаються в кеші реєстру. Якщо не знайдено, сканується "
"список зареєстрованих функцій пошуку. Якщо об’єкт :class:`CodecInfo` не "
"знайдено, виникає :exc:`LookupError`. В іншому випадку об’єкт :class:"
"`CodecInfo` зберігається в кеші та повертається абоненту."

#: ../../library/codecs.rst:70
msgid ""
"Codec details when looking up the codec registry. The constructor arguments "
"are stored in attributes of the same name:"
msgstr ""
"Відомості про кодек під час пошуку реєстру кодеків. Аргументи конструктора "
"зберігаються в однойменних атрибутах:"

#: ../../library/codecs.rst:76
msgid "The name of the encoding."
msgstr "Назва кодування."

#: ../../library/codecs.rst:82
msgid ""
"The stateless encoding and decoding functions. These must be functions or "
"methods which have the same interface as the :meth:`~Codec.encode` and :meth:"
"`~Codec.decode` methods of Codec instances (see :ref:`Codec Interface <codec-"
"objects>`). The functions or methods are expected to work in a stateless "
"mode."
msgstr ""
"Функції кодування та декодування без збереження стану. Це мають бути функції "
"чи методи, які мають той самий інтерфейс, що й методи :meth:`~Codec.encode` "
"і :meth:`~Codec.decode` екземплярів кодека (див. :ref:`Інтерфейс кодека "
"<codec-objects>`). Очікується, що функції або методи працюватимуть у режимі "
"без збереження стану."

#: ../../library/codecs.rst:92
msgid ""
"Incremental encoder and decoder classes or factory functions. These have to "
"provide the interface defined by the base classes :class:"
"`IncrementalEncoder` and :class:`IncrementalDecoder`, respectively. "
"Incremental codecs can maintain state."
msgstr ""
"Класи інкрементального кодера та декодера або заводські функції. Вони мають "
"забезпечувати інтерфейс, визначений базовими класами :class:"
"`IncrementalEncoder` та :class:`IncrementalDecoder` відповідно. Інкрементні "
"кодеки можуть підтримувати стан."

#: ../../library/codecs.rst:101
msgid ""
"Stream writer and reader classes or factory functions. These have to provide "
"the interface defined by the base classes :class:`StreamWriter` and :class:"
"`StreamReader`, respectively. Stream codecs can maintain state."
msgstr ""
"Класи потокового запису та читання або фабричні функції. Вони мають "
"забезпечувати інтерфейс, визначений базовими класами :class:`StreamWriter` "
"і :class:`StreamReader` відповідно. Потокові кодеки можуть підтримувати стан."

#: ../../library/codecs.rst:106
msgid ""
"To simplify access to the various codec components, the module provides "
"these additional functions which use :func:`lookup` for the codec lookup:"
msgstr ""
"Щоб спростити доступ до різних компонентів кодека, модуль надає такі "
"додаткові функції, які використовують :func:`lookup` для пошуку кодека:"

#: ../../library/codecs.rst:111
msgid ""
"Look up the codec for the given encoding and return its encoder function."
msgstr ""
"Знайдіть кодек для даного кодування та поверніть його функцію кодувальника."

#: ../../library/codecs.rst:113 ../../library/codecs.rst:120
#: ../../library/codecs.rst:146 ../../library/codecs.rst:154
msgid "Raises a :exc:`LookupError` in case the encoding cannot be found."
msgstr "Викликає :exc:`LookupError`, якщо кодування не знайдено."

#: ../../library/codecs.rst:118
msgid ""
"Look up the codec for the given encoding and return its decoder function."
msgstr ""
"Знайдіть кодек для даного кодування та поверніть його функцію декодера."

#: ../../library/codecs.rst:125
msgid ""
"Look up the codec for the given encoding and return its incremental encoder "
"class or factory function."
msgstr ""
"Знайдіть кодек для даного кодування та поверніть його інкрементний клас "
"кодера або заводську функцію."

#: ../../library/codecs.rst:128
msgid ""
"Raises a :exc:`LookupError` in case the encoding cannot be found or the "
"codec doesn't support an incremental encoder."
msgstr ""
"Викликає :exc:`LookupError`, якщо кодування не знайдено або кодек не "
"підтримує інкрементний кодер."

#: ../../library/codecs.rst:134
msgid ""
"Look up the codec for the given encoding and return its incremental decoder "
"class or factory function."
msgstr ""
"Знайдіть кодек для даного кодування та поверніть його інкрементний клас "
"декодера або заводську функцію."

#: ../../library/codecs.rst:137
msgid ""
"Raises a :exc:`LookupError` in case the encoding cannot be found or the "
"codec doesn't support an incremental decoder."
msgstr ""
"Викликає :exc:`LookupError`, якщо кодування не знайдено або кодек не "
"підтримує інкрементний декодер."

#: ../../library/codecs.rst:143
msgid ""
"Look up the codec for the given encoding and return its :class:"
"`StreamReader` class or factory function."
msgstr ""
"Знайдіть кодек для вказаного кодування та поверніть його клас :class:"
"`StreamReader` або фабричну функцію."

#: ../../library/codecs.rst:151
msgid ""
"Look up the codec for the given encoding and return its :class:"
"`StreamWriter` class or factory function."
msgstr ""
"Знайдіть кодек для вказаного кодування та поверніть його клас :class:"
"`StreamWriter` або фабричну функцію."

#: ../../library/codecs.rst:156
msgid ""
"Custom codecs are made available by registering a suitable codec search "
"function:"
msgstr ""
"Спеціальні кодеки стають доступними, якщо зареєструвати відповідну функцію "
"пошуку кодеків:"

#: ../../library/codecs.rst:161
msgid ""
"Register a codec search function. Search functions are expected to take one "
"argument, being the encoding name in all lower case letters with hyphens and "
"spaces converted to underscores, and return a :class:`CodecInfo` object. In "
"case a search function cannot find a given encoding, it should return "
"``None``."
msgstr ""
"Зареєструйте функцію пошуку кодеків. Очікується, що функції пошуку "
"прийматимуть один аргумент, тобто ім’я кодування, яке складається з малих "
"літер із дефісами та пробілами, перетворене на підкреслення, і повертатиме "
"об’єкт :class:`CodecInfo`. Якщо функція пошуку не може знайти задане "
"кодування, вона має повернути ``None``."

#: ../../library/codecs.rst:167
msgid "Hyphens and spaces are converted to underscore."
msgstr "Дефіси та пробіли перетворюються на підкреслення."

#: ../../library/codecs.rst:173
msgid ""
"Unregister a codec search function and clear the registry's cache. If the "
"search function is not registered, do nothing."
msgstr ""
"Скасуйте реєстрацію функції пошуку кодеків і очистіть кеш реєстру. Якщо "
"функція пошуку не зареєстрована, нічого не робіть."

#: ../../library/codecs.rst:179
msgid ""
"While the builtin :func:`open` and the associated :mod:`io` module are the "
"recommended approach for working with encoded text files, this module "
"provides additional utility functions and classes that allow the use of a "
"wider range of codecs when working with binary files:"
msgstr ""
"Хоча вбудований :func:`open` і пов’язаний модуль :mod:`io` є рекомендованим "
"підходом для роботи з кодованими текстовими файлами, цей модуль надає "
"додаткові службові функції та класи, які дозволяють використовувати ширший "
"діапазон кодеків під час роботи з бінарними файлами:"

#: ../../library/codecs.rst:186
msgid ""
"Open an encoded file using the given *mode* and return an instance of :class:"
"`StreamReaderWriter`, providing transparent encoding/decoding. The default "
"file mode is ``'r'``, meaning to open the file in read mode."
msgstr ""
"Відкрийте закодований файл у заданому *режимі* та поверніть екземпляр :class:"
"`StreamReaderWriter`, забезпечуючи прозоре кодування/декодування. Типовим "
"режимом файлу є ``'r''``, що означає відкриття файлу в режимі читання."

#: ../../library/codecs.rst:192
msgid ""
"If *encoding* is not ``None``, then the underlying encoded files are always "
"opened in binary mode. No automatic conversion of ``'\\n'`` is done on "
"reading and writing. The *mode* argument may be any binary mode acceptable "
"to the built-in :func:`open` function; the ``'b'`` is automatically added."
msgstr ""
"Если *encoding* не равно ``None``, то базовые закодированные файлы всегда "
"открываются в двоичном режиме. Никакое автоматическое преобразование "
"``'\\n'`` при чтении и записи не выполняется. Аргументом *mode* может быть "
"любой двоичный режим, приемлемый для встроенной функции :func:`open`; "
"``'b'`` добавляется автоматически."

#: ../../library/codecs.rst:198
msgid ""
"*encoding* specifies the encoding which is to be used for the file. Any "
"encoding that encodes to and decodes from bytes is allowed, and the data "
"types supported by the file methods depend on the codec used."
msgstr ""
"*encoding* визначає кодування, яке буде використано для файлу. Дозволяється "
"будь-яке кодування, яке кодує та декодує з байтів, а типи даних, які "
"підтримуються методами файлів, залежать від використовуваного кодека."

#: ../../library/codecs.rst:202
msgid ""
"*errors* may be given to define the error handling. It defaults to "
"``'strict'`` which causes a :exc:`ValueError` to be raised in case an "
"encoding error occurs."
msgstr ""
"*errors* можуть бути надані для визначення обробки помилок. За замовчуванням "
"встановлено значення ``'strict''``, що спричиняє виникнення :exc:"
"`ValueError` у разі виникнення помилки кодування."

#: ../../library/codecs.rst:205
msgid ""
"*buffering* has the same meaning as for the built-in :func:`open` function. "
"It defaults to -1 which means that the default buffer size will be used."
msgstr ""
"*buffering* має те саме значення, що й вбудована функція :func:`open`. За "
"замовчуванням він дорівнює -1, що означає, що буде використано стандартний "
"розмір буфера."

#: ../../library/codecs.rst:208
msgid "The ``'U'`` mode has been removed."
msgstr "O modo ``'U'`` foi removido."

#: ../../library/codecs.rst:214
msgid ""
"Return a :class:`StreamRecoder` instance, a wrapped version of *file* which "
"provides transparent transcoding. The original file is closed when the "
"wrapped version is closed."
msgstr ""
"Повертає екземпляр :class:`StreamRecoder`, загорнуту версію *файлу*, яка "
"забезпечує прозоре перекодування. Вихідний файл закривається, коли "
"закривається упакована версія."

#: ../../library/codecs.rst:218
msgid ""
"Data written to the wrapped file is decoded according to the given "
"*data_encoding* and then written to the original file as bytes using "
"*file_encoding*. Bytes read from the original file are decoded according to "
"*file_encoding*, and the result is encoded using *data_encoding*."
msgstr ""
"Дані, записані в обгорнутий файл, декодуються відповідно до заданого "
"*data_encoding*, а потім записуються в вихідний файл у вигляді байтів за "
"допомогою *file_encoding*. Байти, зчитані з вихідного файлу, декодуються "
"відповідно до *file_encoding*, а результат кодується за допомогою "
"*data_encoding*."

#: ../../library/codecs.rst:224
msgid "If *file_encoding* is not given, it defaults to *data_encoding*."
msgstr "Якщо *file_encoding* не вказано, за умовчанням буде *data_encoding*."

#: ../../library/codecs.rst:226
msgid ""
"*errors* may be given to define the error handling. It defaults to "
"``'strict'``, which causes :exc:`ValueError` to be raised in case an "
"encoding error occurs."
msgstr ""
"*errors* можуть бути надані для визначення обробки помилок. За замовчуванням "
"встановлено ``'strict'``, що спричиняє :exc:`ValueError`, що виникає у "
"випадку помилки кодування."

#: ../../library/codecs.rst:233
msgid ""
"Uses an incremental encoder to iteratively encode the input provided by "
"*iterator*. This function is a :term:`generator`. The *errors* argument (as "
"well as any other keyword argument) is passed through to the incremental "
"encoder."
msgstr ""
"Використовує інкрементальний кодувальник для ітеративного кодування вхідних "
"даних, наданих *iterator*. Ця функція є :term:`generator`. Аргумент *errors* "
"(як і будь-який інший аргумент ключового слова) передається до "
"інкрементального кодувальника."

#: ../../library/codecs.rst:238
msgid ""
"This function requires that the codec accept text :class:`str` objects to "
"encode. Therefore it does not support bytes-to-bytes encoders such as "
"``base64_codec``."
msgstr ""
"Ця функція вимагає, щоб кодек приймав текстові об’єкти :class:`str` для "
"кодування. Тому він не підтримує кодувальники байт-у-байт, такі як "
"``base64_codec``."

#: ../../library/codecs.rst:245
msgid ""
"Uses an incremental decoder to iteratively decode the input provided by "
"*iterator*. This function is a :term:`generator`. The *errors* argument (as "
"well as any other keyword argument) is passed through to the incremental "
"decoder."
msgstr ""
"Використовує інкрементальний декодер для ітеративного декодування вхідних "
"даних, наданих *iterator*. Ця функція є :term:`generator`. Аргумент *errors* "
"(як і будь-який інший аргумент ключового слова) передається до "
"інкрементального декодера."

#: ../../library/codecs.rst:250
msgid ""
"This function requires that the codec accept :class:`bytes` objects to "
"decode. Therefore it does not support text-to-text encoders such as "
"``rot_13``, although ``rot_13`` may be used equivalently with :func:"
"`iterencode`."
msgstr ""
"Ця функція вимагає, щоб кодек приймав об’єкти :class:`bytes` для "
"декодування. Тому він не підтримує кодувальники тексту в текст, такі як "
"``rot_13``, хоча ``rot_13`` можна використовувати еквівалентно з :func:"
"`iterencode`."

#: ../../library/codecs.rst:256
msgid ""
"The module also provides the following constants which are useful for "
"reading and writing to platform dependent files:"
msgstr ""
"Модуль також надає наступні константи, які корисні для читання та запису в "
"залежні від платформи файли:"

#: ../../library/codecs.rst:271
msgid ""
"These constants define various byte sequences, being Unicode byte order "
"marks (BOMs) for several encodings. They are used in UTF-16 and UTF-32 data "
"streams to indicate the byte order used, and in UTF-8 as a Unicode "
"signature. :const:`BOM_UTF16` is either :const:`BOM_UTF16_BE` or :const:"
"`BOM_UTF16_LE` depending on the platform's native byte order, :const:`BOM` "
"is an alias for :const:`BOM_UTF16`, :const:`BOM_LE` for :const:"
"`BOM_UTF16_LE` and :const:`BOM_BE` for :const:`BOM_UTF16_BE`. The others "
"represent the BOM in UTF-8 and UTF-32 encodings."
msgstr ""
"Ці константи визначають різні послідовності байтів, будучи мітками порядку "
"байтів Unicode (BOM) для кількох кодувань. Вони використовуються в потоках "
"даних UTF-16 і UTF-32 для позначення використовуваного порядку байтів, а в "
"UTF-8 як підпис Юнікод. :const:`BOM_UTF16` є або :const:`BOM_UTF16_BE`, або :"
"const:`BOM_UTF16_LE` залежно від рідного порядку байтів платформи, :const:"
"`BOM` є псевдонімом для :const:`BOM_UTF16`, :const:`BOM_LE` для :const:"
"`BOM_UTF16_LE` і :const:`BOM_BE` для :const:`BOM_UTF16_BE`. Інші "
"представляють специфікацію в кодуваннях UTF-8 і UTF-32."

#: ../../library/codecs.rst:285
msgid "Codec Base Classes"
msgstr "Базові класи кодеків"

#: ../../library/codecs.rst:287
msgid ""
"The :mod:`codecs` module defines a set of base classes which define the "
"interfaces for working with codec objects, and can also be used as the basis "
"for custom codec implementations."
msgstr ""
"Модуль :mod:`codecs` визначає набір базових класів, які визначають "
"інтерфейси для роботи з об’єктами кодеків, а також може бути використаний як "
"основа для користувацьких реалізацій кодеків."

#: ../../library/codecs.rst:291
msgid ""
"Each codec has to define four interfaces to make it usable as codec in "
"Python: stateless encoder, stateless decoder, stream reader and stream "
"writer. The stream reader and writers typically reuse the stateless encoder/"
"decoder to implement the file protocols. Codec authors also need to define "
"how the codec will handle encoding and decoding errors."
msgstr ""
"Кожен кодек має визначати чотири інтерфейси, щоб зробити його придатним для "
"використання як кодек у Python: кодер без стану, декодер без стану, читач "
"потоку та запис потоку. Зчитувач і записувач потоків зазвичай повторно "
"використовують кодер/декодер без збереження стану для реалізації протоколів "
"файлів. Автори кодеків також повинні визначити, як кодек оброблятиме помилки "
"кодування та декодування."

#: ../../library/codecs.rst:302
msgid "Error Handlers"
msgstr "Penangan Kesalahan"

#: ../../library/codecs.rst:304
msgid ""
"To simplify and standardize error handling, codecs may implement different "
"error handling schemes by accepting the *errors* string argument:"
msgstr ""
"Щоб спростити та стандартизувати обробку помилок, кодеки можуть "
"реалізовувати різні схеми обробки помилок, приймаючи рядковий аргумент "
"*errors*:"

#: ../../library/codecs.rst:324
msgid ""
"The following error handlers can be used with all Python :ref:`standard-"
"encodings` codecs:"
msgstr ""
"Наступні обробники помилок можна використовувати з усіма кодеками Python :"
"ref:`standard-encodings`:"

#: ../../library/codecs.rst:330 ../../library/codecs.rst:373
#: ../../library/codecs.rst:393
msgid "Value"
msgstr "Valor"

#: ../../library/codecs.rst:330 ../../library/codecs.rst:373
#: ../../library/codecs.rst:393 ../../library/codecs.rst:1330
#: ../../library/codecs.rst:1398 ../../library/codecs.rst:1455
msgid "Meaning"
msgstr "Significado"

#: ../../library/codecs.rst:332
msgid "``'strict'``"
msgstr "``'strict'``"

#: ../../library/codecs.rst:332
msgid ""
"Raise :exc:`UnicodeError` (or a subclass), this is the default. Implemented "
"in :func:`strict_errors`."
msgstr ""
"Викликати :exc:`UnicodeError` (або підклас), це типово. Реалізовано в :func:"
"`strict_errors`."

#: ../../library/codecs.rst:336
msgid "``'ignore'``"
msgstr "``'ignore'``"

#: ../../library/codecs.rst:336
msgid ""
"Ignore the malformed data and continue without further notice. Implemented "
"in :func:`ignore_errors`."
msgstr ""
"Ігноруйте неправильні дані та продовжуйте без додаткового повідомлення. "
"Реалізовано в :func:`ignore_errors`."

#: ../../library/codecs.rst:340
msgid "``'replace'``"
msgstr "``'replace'``"

#: ../../library/codecs.rst:340
msgid ""
"Replace with a replacement marker. On encoding, use ``?`` (ASCII character). "
"On decoding, use ``�`` (U+FFFD, the official REPLACEMENT CHARACTER). "
"Implemented in :func:`replace_errors`."
msgstr ""
"Замініть маркером заміни. У кодуванні використовуйте ``?`` (символ ASCII). "
"Під час декодування використовуйте ``�`` (U+FFFD, офіційний СИМВОЛ ЗАМІНИ). "
"Реалізовано в :func:`replace_errors`."

#: ../../library/codecs.rst:346
msgid "``'backslashreplace'``"
msgstr "``'backslashreplace'``"

#: ../../library/codecs.rst:346
msgid ""
"Replace with backslashed escape sequences. On encoding, use hexadecimal form "
"of Unicode code point with formats :samp:`\\\\x{hh}` :samp:`\\\\u{xxxx}` :"
"samp:`\\\\U{xxxxxxxx}`. On decoding, use hexadecimal form of byte value with "
"format :samp:`\\\\x{hh}`. Implemented in :func:`backslashreplace_errors`."
msgstr ""
"Замените escape-последовательностями с обратной косой чертой. При "
"кодировании используйте шестнадцатеричную форму кодовой точки Юникода в "
"форматах :samp:`\\\\x{hh}` :samp:`\\\\u{xxxx}` :samp:`\\\\U{xxxxxxxx}`. При "
"декодировании используйте шестнадцатеричную форму значения байта в формате :"
"samp:`\\\\x{hh}`. Реализовано в :func:`backslashreplace_errors`."

#: ../../library/codecs.rst:355
msgid "``'surrogateescape'``"
msgstr "``'surrogateescape'``"

#: ../../library/codecs.rst:355
msgid ""
"On decoding, replace byte with individual surrogate code ranging from "
"``U+DC80`` to ``U+DCFF``. This code will then be turned back into the same "
"byte when the ``'surrogateescape'`` error handler is used when encoding the "
"data. (See :pep:`383` for more.)"
msgstr ""
"Під час декодування замініть байт окремим сурогатним кодом у діапазоні від "
"``U+DC80`` до ``U+DCFF``. Потім цей код буде перетворено назад у той самий "
"байт, коли під час кодування даних використовується обробник помилок "
"``'surrogateescape'``. (Докладніше див. :pep:`383`.)"

#: ../../library/codecs.rst:369
msgid ""
"The following error handlers are only applicable to encoding (within :term:"
"`text encodings <text encoding>`):"
msgstr ""
"Наступні обробники помилок застосовуються лише до кодування (в межах :term:"
"`кодування тексту <text encoding>`):"

#: ../../library/codecs.rst:375
msgid "``'xmlcharrefreplace'``"
msgstr "``'xmlcharrefreplace'``"

#: ../../library/codecs.rst:375
msgid ""
"Replace with XML/HTML numeric character reference, which is a decimal form "
"of Unicode code point with format :samp:`&#{num};`. Implemented in :func:"
"`xmlcharrefreplace_errors`."
msgstr ""
"Замените ссылкой на числовые символы XML/HTML, которая представляет собой "
"десятичную форму кодовой точки Юникода в формате :samp:`&#{num};`. "
"Реализовано в :func:`xmlcharrefreplace_errors`."

#: ../../library/codecs.rst:381
msgid "``'namereplace'``"
msgstr "``'namereplace'``"

#: ../../library/codecs.rst:381
msgid ""
"Replace with ``\\N{...}`` escape sequences, what appears in the braces is "
"the Name property from Unicode Character Database. Implemented in :func:"
"`namereplace_errors`."
msgstr ""
"Замініть керуючу послідовність ``\\N{...}``, що відображається в фігурних "
"дужках — це властивість Name із бази даних символів Unicode. Реалізовано в :"
"func:`namereplace_errors`."

#: ../../library/codecs.rst:390
msgid ""
"In addition, the following error handler is specific to the given codecs:"
msgstr "Крім того, наступний обробник помилок є специфічним для даних кодеків:"

#: ../../library/codecs.rst:13 ../../library/codecs.rst:393
msgid "Codecs"
msgstr "Codecs"

#: ../../library/codecs.rst:395
msgid "``'surrogatepass'``"
msgstr "``'surrogatepass'``"

#: ../../library/codecs.rst:395
msgid "utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le"
msgstr "utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le"

#: ../../library/codecs.rst:395
msgid ""
"Allow encoding and decoding surrogate code point (``U+D800`` - ``U+DFFF``) "
"as normal code point. Otherwise these codecs treat the presence of surrogate "
"code point in :class:`str` as an error."
msgstr ""
"Дозволити кодування та декодування сурогатної кодової точки (``U+D800`` - "
"``U+DFFF``) як звичайну кодову точку. Інакше ці кодеки розглядають наявність "
"сурогатної кодової точки в :class:`str` як помилку."

#: ../../library/codecs.rst:402
msgid "The ``'surrogateescape'`` and ``'surrogatepass'`` error handlers."
msgstr "Обробники помилок ``'surrogateescape'`` і ``'surrogatepass'``."

#: ../../library/codecs.rst:405
msgid ""
"The ``'surrogatepass'`` error handler now works with utf-16\\* and utf-32\\* "
"codecs."
msgstr ""
"Обробник помилок ``'surrogatepass'`` тепер працює з кодеками utf-16\\* і "
"utf-32\\*."

#: ../../library/codecs.rst:409
msgid "The ``'namereplace'`` error handler."
msgstr "Обробник помилок ``'namereplace``."

#: ../../library/codecs.rst:412
msgid ""
"The ``'backslashreplace'`` error handler now works with decoding and "
"translating."
msgstr ""
"Обробник помилок ``'backslashreplace'`` тепер працює з декодуванням і "
"перекладом."

#: ../../library/codecs.rst:416
msgid ""
"The set of allowed values can be extended by registering a new named error "
"handler:"
msgstr ""
"Набір дозволених значень можна розширити, зареєструвавши новий іменований "
"обробник помилок:"

#: ../../library/codecs.rst:421
msgid ""
"Register the error handling function *error_handler* under the name *name*. "
"The *error_handler* argument will be called during encoding and decoding in "
"case of an error, when *name* is specified as the errors parameter."
msgstr ""
"Зареєструйте функцію обробки помилок *error_handler* під назвою *name*. "
"Аргумент *error_handler* буде викликаний під час кодування та декодування у "
"разі помилки, якщо *name* вказано як параметр errors."

#: ../../library/codecs.rst:425
msgid ""
"For encoding, *error_handler* will be called with a :exc:"
"`UnicodeEncodeError` instance, which contains information about the location "
"of the error. The error handler must either raise this or a different "
"exception, or return a tuple with a replacement for the unencodable part of "
"the input and a position where encoding should continue. The replacement may "
"be either :class:`str` or :class:`bytes`. If the replacement is bytes, the "
"encoder will simply copy them into the output buffer. If the replacement is "
"a string, the encoder will encode the replacement. Encoding continues on "
"original input at the specified position. Negative position values will be "
"treated as being relative to the end of the input string. If the resulting "
"position is out of bound an :exc:`IndexError` will be raised."
msgstr ""
"Для кодування *error_handler* буде викликано з екземпляром :exc:"
"`UnicodeEncodeError`, який містить інформацію про розташування помилки. "
"Обробник помилок повинен або викликати це чи інше виключення, або повернути "
"кортеж із заміною некодованої частини вхідних даних і позиції, де кодування "
"повинно продовжуватися. Заміна може бути :class:`str` або :class:`bytes`. "
"Якщо заміною є байти, кодер просто скопіює їх у вихідний буфер. Якщо заміна "
"є рядком, кодер закодує заміну. Кодування продовжується на початковому "
"введенні у вказаній позиції. Від’ємні значення позиції розглядатимуться як "
"такі, що відносяться до кінця вхідного рядка. Якщо результуюча позиція "
"виходить за межі, буде викликано :exc:`IndexError`."

#: ../../library/codecs.rst:437
msgid ""
"Decoding and translating works similarly, except :exc:`UnicodeDecodeError` "
"or :exc:`UnicodeTranslateError` will be passed to the handler and that the "
"replacement from the error handler will be put into the output directly."
msgstr ""
"Декодування та переклад працює аналогічно, за винятком того, що :exc:"
"`UnicodeDecodeError` або :exc:`UnicodeTranslateError` буде передано "
"обробнику, а заміна з обробника помилок буде введена безпосередньо у вивід."

#: ../../library/codecs.rst:442
msgid ""
"Previously registered error handlers (including the standard error handlers) "
"can be looked up by name:"
msgstr ""
"Раніше зареєстровані обробники помилок (включаючи стандартні обробники "
"помилок) можна шукати за назвою:"

#: ../../library/codecs.rst:447
msgid "Return the error handler previously registered under the name *name*."
msgstr ""
"Повернути обробник помилок, попередньо зареєстрований під іменем *name*."

#: ../../library/codecs.rst:449
msgid "Raises a :exc:`LookupError` in case the handler cannot be found."
msgstr "Викликає :exc:`LookupError`, якщо обробник не знайдено."

#: ../../library/codecs.rst:451
msgid ""
"The following standard error handlers are also made available as module "
"level functions:"
msgstr ""
"Наступні стандартні обробники помилок також доступні як функції рівня модуля:"

#: ../../library/codecs.rst:456
msgid "Implements the ``'strict'`` error handling."
msgstr "Implementa a tratativa de erro ``'strict'``."

#: ../../library/codecs.rst:458
msgid "Each encoding or decoding error raises a :exc:`UnicodeError`."
msgstr "Кожна помилка кодування або декодування викликає :exc:`UnicodeError`."

#: ../../library/codecs.rst:463
msgid "Implements the ``'ignore'`` error handling."
msgstr "Implementa a tratativa de erro ``'ignore'``."

#: ../../library/codecs.rst:465
msgid ""
"Malformed data is ignored; encoding or decoding is continued without further "
"notice."
msgstr ""
"Некоректні дані ігноруються; кодування або декодування продовжується без "
"додаткового повідомлення."

#: ../../library/codecs.rst:471
msgid "Implements the ``'replace'`` error handling."
msgstr "Implementa a tratativa de erro ``'replace'``."

#: ../../library/codecs.rst:473
msgid ""
"Substitutes ``?`` (ASCII character) for encoding errors or ``�`` (U+FFFD, "
"the official REPLACEMENT CHARACTER) for decoding errors."
msgstr ""
"Замінює ``?`` (символ ASCII) для помилок кодування або ``�`` (U+FFFD, "
"офіційний СИМВОЛ ЗАМІНИ) для помилок декодування."

#: ../../library/codecs.rst:479
msgid "Implements the ``'backslashreplace'`` error handling."
msgstr "Implementa a tratativa de erro ``'backslashreplace'``."

#: ../../library/codecs.rst:481
msgid ""
"Malformed data is replaced by a backslashed escape sequence. On encoding, "
"use the hexadecimal form of Unicode code point with formats :samp:`\\\\x{hh}"
"` :samp:`\\\\u{xxxx}` :samp:`\\\\U{xxxxxxxx}`. On decoding, use the "
"hexadecimal form of byte value with format :samp:`\\\\x{hh}`."
msgstr ""
"Неверно сформированные данные заменяются escape-последовательностью с "
"обратной косой чертой. При кодировании используйте шестнадцатеричную форму "
"кодовой точки Юникода в форматах :samp:`\\\\x{hh}` :samp:`\\\\u{xxxx}` :samp:"
"`\\\\U{xxxxxxxx}`. При декодировании используйте шестнадцатеричную форму "
"значения байта в формате :samp:`\\\\x{hh}`."

#: ../../library/codecs.rst:487
msgid "Works with decoding and translating."
msgstr "Працює з декодуванням і перекладом."

#: ../../library/codecs.rst:493
msgid ""
"Implements the ``'xmlcharrefreplace'`` error handling (for encoding within :"
"term:`text encoding` only)."
msgstr ""
"Реалізує обробку помилок ``'xmlcharrefreplace'`` (лише для кодування в "
"межах :term:`text encoding`)."

#: ../../library/codecs.rst:496
msgid ""
"The unencodable character is replaced by an appropriate XML/HTML numeric "
"character reference, which is a decimal form of Unicode code point with "
"format :samp:`&#{num};` ."
msgstr ""
"Некодируемый символ заменяется соответствующей ссылкой на числовой символ "
"XML/HTML, которая представляет собой десятичную форму кодовой точки Юникода "
"в формате :samp:`&#{num};` ."

#: ../../library/codecs.rst:503
msgid ""
"Implements the ``'namereplace'`` error handling (for encoding within :term:"
"`text encoding` only)."
msgstr ""
"Реалізує обробку помилок ``'namereplace'`` (лише для кодування в межах :term:"
"`text encoding`)."

#: ../../library/codecs.rst:506
msgid ""
"The unencodable character is replaced by a ``\\N{...}`` escape sequence. The "
"set of characters that appear in the braces is the Name property from "
"Unicode Character Database. For example, the German lowercase letter ``'ß'`` "
"will be converted to byte sequence ``\\N{LATIN SMALL LETTER SHARP S}`` ."
msgstr ""
"Некодований символ замінюється керуючою послідовністю ``\\N{...}``. Набір "
"символів, що з’являються в фігурних дужках, є властивістю Name з бази даних "
"символів Unicode. Наприклад, німецьку малу літеру ``'ß'`` буде перетворено "
"на послідовність байтів ``\\N{LATIN SMALL LETTER SHARP S}`` ."

#: ../../library/codecs.rst:517
msgid "Stateless Encoding and Decoding"
msgstr "Кодування та декодування без збереження стану"

#: ../../library/codecs.rst:519
msgid ""
"The base :class:`Codec` class defines these methods which also define the "
"function interfaces of the stateless encoder and decoder:"
msgstr ""
"Базовий клас :class:`Codec` визначає ці методи, які також визначають "
"функціональні інтерфейси кодера та декодера без збереження стану:"

#: ../../library/codecs.rst:527
msgid ""
"Encodes the object *input* and returns a tuple (output object, length "
"consumed). For instance, :term:`text encoding` converts a string object to a "
"bytes object using a particular character set encoding (e.g., ``cp1252`` or "
"``iso-8859-1``)."
msgstr ""
"Кодує об’єкт *input* і повертає кортеж (вихідний об’єкт, споживана довжина). "
"Наприклад, :term:`text encoding` перетворює рядковий об’єкт на об’єкт bytes, "
"використовуючи певне кодування набору символів (наприклад, ``cp1252`` або "
"``iso-8859-1``)."

#: ../../library/codecs.rst:532 ../../library/codecs.rst:554
msgid ""
"The *errors* argument defines the error handling to apply. It defaults to "
"``'strict'`` handling."
msgstr ""
"Аргумент *errors* визначає застосовувану обробку помилок. За замовчуванням "
"``'сувора''`` обробка."

#: ../../library/codecs.rst:535
msgid ""
"The method may not store state in the :class:`Codec` instance. Use :class:"
"`StreamWriter` for codecs which have to keep state in order to make encoding "
"efficient."
msgstr ""
"Метод може не зберігати стан в екземплярі :class:`Codec`. Використовуйте :"
"class:`StreamWriter` для кодеків, які мають зберігати стан, щоб зробити "
"кодування ефективним."

#: ../../library/codecs.rst:539
msgid ""
"The encoder must be able to handle zero length input and return an empty "
"object of the output object type in this situation."
msgstr ""
"У цій ситуації кодер повинен мати можливість обробляти вхідні дані нульової "
"довжини та повертати порожній об’єкт типу вихідного об’єкта."

#: ../../library/codecs.rst:545
msgid ""
"Decodes the object *input* and returns a tuple (output object, length "
"consumed). For instance, for a :term:`text encoding`, decoding converts a "
"bytes object encoded using a particular character set encoding to a string "
"object."
msgstr ""
"Декодує об’єкт *input* і повертає кортеж (вихідний об’єкт, споживана "
"довжина). Наприклад, для :term:`text encoding` декодування перетворює об’єкт "
"bytes, закодований за допомогою кодування певного набору символів, на "
"рядковий об’єкт."

#: ../../library/codecs.rst:550
msgid ""
"For text encodings and bytes-to-bytes codecs, *input* must be a bytes object "
"or one which provides the read-only buffer interface -- for example, buffer "
"objects and memory mapped files."
msgstr ""
"Для текстових кодувань і кодеків від байтів до байтів *input* має бути "
"об’єктом bytes або таким, який забезпечує інтерфейс буфера лише для читання "
"– наприклад, об’єкти буфера та файли, відображені в пам’яті."

#: ../../library/codecs.rst:557
msgid ""
"The method may not store state in the :class:`Codec` instance. Use :class:"
"`StreamReader` for codecs which have to keep state in order to make decoding "
"efficient."
msgstr ""
"Метод може не зберігати стан в екземплярі :class:`Codec`. Використовуйте :"
"class:`StreamReader` для кодеків, які мають зберігати стан, щоб зробити "
"декодування ефективним."

#: ../../library/codecs.rst:561
msgid ""
"The decoder must be able to handle zero length input and return an empty "
"object of the output object type in this situation."
msgstr ""
"У цій ситуації декодер повинен мати можливість обробляти вхідні дані "
"нульової довжини та повертати порожній об’єкт типу вихідного об’єкта."

#: ../../library/codecs.rst:566
msgid "Incremental Encoding and Decoding"
msgstr "Інкрементне кодування та декодування"

#: ../../library/codecs.rst:568
msgid ""
"The :class:`IncrementalEncoder` and :class:`IncrementalDecoder` classes "
"provide the basic interface for incremental encoding and decoding. Encoding/"
"decoding the input isn't done with one call to the stateless encoder/decoder "
"function, but with multiple calls to the :meth:`~IncrementalEncoder.encode`/:"
"meth:`~IncrementalDecoder.decode` method of the incremental encoder/decoder. "
"The incremental encoder/decoder keeps track of the encoding/decoding process "
"during method calls."
msgstr ""
"Класи :class:`IncrementalEncoder` і :class:`IncrementalDecoder` забезпечують "
"базовий інтерфейс для інкрементного кодування та декодування. Кодування/"
"декодування вхідних даних виконується не одним викликом функції кодувальника/"
"декодера без збереження стану, а кількома викликами методу :meth:"
"`~IncrementalEncoder.encode`/:meth:`~IncrementalDecoder.decode` "
"інкрементального кодувальника /декодер. Інкрементний кодер/декодер відстежує "
"процес кодування/декодування під час викликів методів."

#: ../../library/codecs.rst:576
msgid ""
"The joined output of calls to the :meth:`~IncrementalEncoder.encode`/:meth:"
"`~IncrementalDecoder.decode` method is the same as if all the single inputs "
"were joined into one, and this input was encoded/decoded with the stateless "
"encoder/decoder."
msgstr ""
"Об’єднаний вихід викликів методу :meth:`~IncrementalEncoder.encode`/:meth:"
"`~IncrementalDecoder.decode` такий самий, як якби всі окремі входи були "
"об’єднані в один, і цей вхід було закодовано/декодовано за допомогою кодер/"
"декодер без стану."

#: ../../library/codecs.rst:585
msgid "IncrementalEncoder Objects"
msgstr "Об’єкти IncrementalEncoder"

#: ../../library/codecs.rst:587
msgid ""
"The :class:`IncrementalEncoder` class is used for encoding an input in "
"multiple steps. It defines the following methods which every incremental "
"encoder must define in order to be compatible with the Python codec registry."
msgstr ""
"Клас :class:`IncrementalEncoder` використовується для кодування вхідних "
"даних у кілька кроків. Він визначає наступні методи, які повинен визначити "
"кожен інкрементальний кодер, щоб бути сумісним із реєстром кодеків Python."

#: ../../library/codecs.rst:594
msgid "Constructor for an :class:`IncrementalEncoder` instance."
msgstr "Конструктор для екземпляра :class:`IncrementalEncoder`."

#: ../../library/codecs.rst:596
msgid ""
"All incremental encoders must provide this constructor interface. They are "
"free to add additional keyword arguments, but only the ones defined here are "
"used by the Python codec registry."
msgstr ""
"Усі інкрементні кодери повинні забезпечувати цей інтерфейс конструктора. "
"Вони можуть вільно додавати додаткові аргументи ключових слів, але лише ті, "
"що визначені тут, використовуються реєстром кодеків Python."

#: ../../library/codecs.rst:600
msgid ""
"The :class:`IncrementalEncoder` may implement different error handling "
"schemes by providing the *errors* keyword argument. See :ref:`error-"
"handlers` for possible values."
msgstr ""
":class:`IncrementalEncoder` може реалізовувати різні схеми обробки помилок, "
"надаючи аргумент ключового слова *errors*. Перегляньте :ref:`error-handlers` "
"можливі значення."

#: ../../library/codecs.rst:604
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:"
"`IncrementalEncoder` object."
msgstr ""
"Аргумент *errors* буде призначено однойменному атрибуту. Призначення цьому "
"атрибуту дає змогу перемикатися між різними стратегіями обробки помилок "
"протягом життя об’єкта :class:`IncrementalEncoder`."

#: ../../library/codecs.rst:612
msgid ""
"Encodes *object* (taking the current state of the encoder into account) and "
"returns the resulting encoded object. If this is the last call to :meth:"
"`encode` *final* must be true (the default is false)."
msgstr ""
"Кодує *об’єкт* (з урахуванням поточного стану кодувальника) і повертає "
"отриманий закодований об’єкт. Якщо це останній виклик :meth:`encode`, "
"*final* має бути true (за умовчанням — false)."

#: ../../library/codecs.rst:619
msgid ""
"Reset the encoder to the initial state. The output is discarded: call ``."
"encode(object, final=True)``, passing an empty byte or text string if "
"necessary, to reset the encoder and to get the output."
msgstr ""
"Скиньте кодер до початкового стану. Вихідні дані відхиляються: викличте ``."
"encode(object, final=True)``, передаючи порожній байт або текстовий рядок, "
"якщо необхідно, щоб скинути кодер і отримати вихідні дані."

#: ../../library/codecs.rst:626
msgid ""
"Return the current state of the encoder which must be an integer. The "
"implementation should make sure that ``0`` is the most common state. (States "
"that are more complicated than integers can be converted into an integer by "
"marshaling/pickling the state and encoding the bytes of the resulting string "
"into an integer.)"
msgstr ""
"Повертає поточний стан кодувальника, який має бути цілим числом. Реалізація "
"має гарантувати, що ``0`` є найпоширенішим станом. (Стани, які є "
"складнішими, ніж цілі числа, можна перетворити на ціле число шляхом "
"маршалінгу/вибору стану та кодування байтів результуючого рядка в ціле "
"число.)"

#: ../../library/codecs.rst:635
msgid ""
"Set the state of the encoder to *state*. *state* must be an encoder state "
"returned by :meth:`getstate`."
msgstr ""
"Встановіть стан кодера на *state*. *state* має бути станом кодувальника, "
"який повертає :meth:`getstate`."

#: ../../library/codecs.rst:642
msgid "IncrementalDecoder Objects"
msgstr "Об’єкти IncrementalDecoder"

#: ../../library/codecs.rst:644
msgid ""
"The :class:`IncrementalDecoder` class is used for decoding an input in "
"multiple steps. It defines the following methods which every incremental "
"decoder must define in order to be compatible with the Python codec registry."
msgstr ""
"Клас :class:`IncrementalDecoder` використовується для декодування вхідних "
"даних у кілька кроків. Він визначає наступні методи, які повинен визначити "
"кожен інкрементний декодер, щоб бути сумісним із реєстром кодеків Python."

#: ../../library/codecs.rst:651
msgid "Constructor for an :class:`IncrementalDecoder` instance."
msgstr "Конструктор для екземпляра :class:`IncrementalDecoder`."

#: ../../library/codecs.rst:653
msgid ""
"All incremental decoders must provide this constructor interface. They are "
"free to add additional keyword arguments, but only the ones defined here are "
"used by the Python codec registry."
msgstr ""
"Усі інкрементні декодери повинні забезпечувати цей інтерфейс конструктора. "
"Вони можуть вільно додавати додаткові аргументи ключових слів, але лише ті, "
"що визначені тут, використовуються реєстром кодеків Python."

#: ../../library/codecs.rst:657
msgid ""
"The :class:`IncrementalDecoder` may implement different error handling "
"schemes by providing the *errors* keyword argument. See :ref:`error-"
"handlers` for possible values."
msgstr ""
":class:`IncrementalDecoder` може реалізовувати різні схеми обробки помилок, "
"надаючи аргумент ключового слова *errors*. Перегляньте :ref:`error-handlers` "
"можливі значення."

#: ../../library/codecs.rst:661
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:"
"`IncrementalDecoder` object."
msgstr ""
"Аргумент *errors* буде призначено однойменному атрибуту. Призначення цьому "
"атрибуту дає змогу перемикатися між різними стратегіями обробки помилок "
"протягом життя об’єкта :class:`IncrementalDecoder`."

#: ../../library/codecs.rst:669
msgid ""
"Decodes *object* (taking the current state of the decoder into account) and "
"returns the resulting decoded object. If this is the last call to :meth:"
"`decode` *final* must be true (the default is false). If *final* is true the "
"decoder must decode the input completely and must flush all buffers. If this "
"isn't possible (e.g. because of incomplete byte sequences at the end of the "
"input) it must initiate error handling just like in the stateless case "
"(which might raise an exception)."
msgstr ""
"Декодує *об’єкт* (з урахуванням поточного стану декодера) і повертає "
"отриманий декодований об’єкт. Якщо це останній виклик :meth:`decode`, "
"*final* має бути true (за умовчанням — false). Якщо *final* має значення "
"true, декодер повинен повністю декодувати вхідні дані та скинути всі буфери. "
"Якщо це неможливо (наприклад, через неповну послідовність байтів у кінці "
"введення), він повинен ініціювати обробку помилок, як у випадку без стану "
"(що може спричинити виняток)."

#: ../../library/codecs.rst:680
msgid "Reset the decoder to the initial state."
msgstr "Скиньте декодер до початкового стану."

#: ../../library/codecs.rst:685
msgid ""
"Return the current state of the decoder. This must be a tuple with two "
"items, the first must be the buffer containing the still undecoded input. "
"The second must be an integer and can be additional state info. (The "
"implementation should make sure that ``0`` is the most common additional "
"state info.) If this additional state info is ``0`` it must be possible to "
"set the decoder to the state which has no input buffered and ``0`` as the "
"additional state info, so that feeding the previously buffered input to the "
"decoder returns it to the previous state without producing any output. "
"(Additional state info that is more complicated than integers can be "
"converted into an integer by marshaling/pickling the info and encoding the "
"bytes of the resulting string into an integer.)"
msgstr ""
"Повернути поточний стан декодера. Це має бути кортеж із двома елементами, "
"перший має бути буфером, що містить ще недекодований вхід. Друге має бути "
"цілим числом і може бути додатковою інформацією про стан. (Реалізація має "
"переконатися, що ``0`` є найпоширенішою додатковою інформацією про стан.) "
"Якщо ця додаткова інформація про стан ``0``, має бути можливим встановити "
"декодер у стан, який не має буферизації вхідних даних і ``0`` як додаткову "
"інформацію про стан, так що подача попередньо буферизованого вхідного "
"сигналу в декодер повертає його до попереднього стану без виведення. "
"(Додаткову інформацію про стан, яка є складнішою, ніж цілі числа, можна "
"перетворити на ціле число шляхом маршалінгу/вибору інформації та кодування "
"байтів отриманого рядка в ціле число.)"

#: ../../library/codecs.rst:700
msgid ""
"Set the state of the decoder to *state*. *state* must be a decoder state "
"returned by :meth:`getstate`."
msgstr ""
"Встановіть стан декодера на *state*. *state* має бути станом декодера, який "
"повертає :meth:`getstate`."

#: ../../library/codecs.rst:705
msgid "Stream Encoding and Decoding"
msgstr "Кодування та декодування потоку"

#: ../../library/codecs.rst:708
msgid ""
"The :class:`StreamWriter` and :class:`StreamReader` classes provide generic "
"working interfaces which can be used to implement new encoding submodules "
"very easily. See :mod:`!encodings.utf_8` for an example of how this is done."
msgstr ""
"Классы :class:`StreamWriter` и :class:`StreamReader` предоставляют общие "
"рабочие интерфейсы, которые можно использовать для очень простой реализации "
"новых подмодулей кодирования. См. :mod:`!encodings.utf_8` для примера того, "
"как это делается."

#: ../../library/codecs.rst:716
msgid "StreamWriter Objects"
msgstr "Objek StreamWriter"

#: ../../library/codecs.rst:718
msgid ""
"The :class:`StreamWriter` class is a subclass of :class:`Codec` and defines "
"the following methods which every stream writer must define in order to be "
"compatible with the Python codec registry."
msgstr ""
"Клас :class:`StreamWriter` є підкласом :class:`Codec` і визначає наступні "
"методи, які повинен визначити кожен записувач потоків, щоб бути сумісним із "
"реєстром кодеків Python."

#: ../../library/codecs.rst:725
msgid "Constructor for a :class:`StreamWriter` instance."
msgstr "Конструктор для екземпляра :class:`StreamWriter`."

#: ../../library/codecs.rst:727
msgid ""
"All stream writers must provide this constructor interface. They are free to "
"add additional keyword arguments, but only the ones defined here are used by "
"the Python codec registry."
msgstr ""
"Цей інтерфейс конструктора мають надавати всі автори потоків. Вони можуть "
"вільно додавати додаткові аргументи ключових слів, але лише ті, що визначені "
"тут, використовуються реєстром кодеків Python."

#: ../../library/codecs.rst:731
msgid ""
"The *stream* argument must be a file-like object open for writing text or "
"binary data, as appropriate for the specific codec."
msgstr ""
"Аргумент *потік* має бути файлоподібним об’єктом, відкритим для запису "
"тексту або двійкових даних, відповідно до конкретного кодека."

#: ../../library/codecs.rst:734
msgid ""
"The :class:`StreamWriter` may implement different error handling schemes by "
"providing the *errors* keyword argument. See :ref:`error-handlers` for the "
"standard error handlers the underlying stream codec may support."
msgstr ""
":class:`StreamWriter` може реалізовувати різні схеми обробки помилок, "
"надаючи аргумент ключового слова *errors*. Перегляньте :ref:`error-handlers` "
"для стандартних обробників помилок, які може підтримувати основний потоковий "
"кодек."

#: ../../library/codecs.rst:738
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:`StreamWriter` "
"object."
msgstr ""
"Аргумент *errors* буде призначено однойменному атрибуту. Призначення цьому "
"атрибуту дає змогу перемикатися між різними стратегіями обробки помилок "
"протягом життя об’єкта :class:`StreamWriter`."

#: ../../library/codecs.rst:744
msgid "Writes the object's contents encoded to the stream."
msgstr "Записує закодований вміст об’єкта в потік."

#: ../../library/codecs.rst:749
msgid ""
"Writes the concatenated iterable of strings to the stream (possibly by "
"reusing the :meth:`write` method). Infinite or very large iterables are not "
"supported. The standard bytes-to-bytes codecs do not support this method."
msgstr ""
"Записує конкатенований ітерований рядок у потік (можливо, повторно "
"використовуючи метод :meth:`write`). Нескінченні або дуже великі ітерації не "
"підтримуються. Стандартні кодеки від байтів до байтів не підтримують цей "
"метод."

#: ../../library/codecs.rst:757 ../../library/codecs.rst:852
msgid "Resets the codec buffers used for keeping internal state."
msgstr ""
"Скидає буфери кодеків, які використовуються для збереження внутрішнього "
"стану."

#: ../../library/codecs.rst:759
msgid ""
"Calling this method should ensure that the data on the output is put into a "
"clean state that allows appending of new fresh data without having to rescan "
"the whole stream to recover state."
msgstr ""
"Chamar este método deve garantir que os dados na saída estejam num estado "
"limpo, que permite anexar novos dados sem ter que verificar novamente todo o "
"fluxo para recuperar o estado."

#: ../../library/codecs.rst:764
msgid ""
"In addition to the above methods, the :class:`StreamWriter` must also "
"inherit all other methods and attributes from the underlying stream."
msgstr ""
"Окрім вищезазначених методів, :class:`StreamWriter` також має успадкувати "
"всі інші методи та атрибути базового потоку."

#: ../../library/codecs.rst:771
msgid "StreamReader Objects"
msgstr "Objek StreamReader"

#: ../../library/codecs.rst:773
msgid ""
"The :class:`StreamReader` class is a subclass of :class:`Codec` and defines "
"the following methods which every stream reader must define in order to be "
"compatible with the Python codec registry."
msgstr ""
"Клас :class:`StreamReader` є підкласом :class:`Codec` і визначає наступні "
"методи, які повинен визначити кожен зчитувач потоку, щоб бути сумісним із "
"реєстром кодеків Python."

#: ../../library/codecs.rst:780
msgid "Constructor for a :class:`StreamReader` instance."
msgstr "Конструктор для екземпляра :class:`StreamReader`."

#: ../../library/codecs.rst:782
msgid ""
"All stream readers must provide this constructor interface. They are free to "
"add additional keyword arguments, but only the ones defined here are used by "
"the Python codec registry."
msgstr ""
"Усі зчитувачі потоків повинні надавати цей інтерфейс конструктора. Вони "
"можуть вільно додавати додаткові аргументи ключових слів, але лише ті, що "
"визначені тут, використовуються реєстром кодеків Python."

#: ../../library/codecs.rst:786
msgid ""
"The *stream* argument must be a file-like object open for reading text or "
"binary data, as appropriate for the specific codec."
msgstr ""
"Аргумент *потік* має бути файлоподібним об’єктом, відкритим для читання "
"тексту або двійкових даних, відповідно до конкретного кодека."

#: ../../library/codecs.rst:789
msgid ""
"The :class:`StreamReader` may implement different error handling schemes by "
"providing the *errors* keyword argument. See :ref:`error-handlers` for the "
"standard error handlers the underlying stream codec may support."
msgstr ""
":class:`StreamReader` може реалізовувати різні схеми обробки помилок, "
"надаючи аргумент ключового слова *errors*. Перегляньте :ref:`error-handlers` "
"для стандартних обробників помилок, які може підтримувати основний потоковий "
"кодек."

#: ../../library/codecs.rst:793
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:`StreamReader` "
"object."
msgstr ""
"Аргумент *errors* буде призначено однойменному атрибуту. Призначення цьому "
"атрибуту дає змогу перемикатися між різними стратегіями обробки помилок "
"протягом життя об’єкта :class:`StreamReader`."

#: ../../library/codecs.rst:797
msgid ""
"The set of allowed values for the *errors* argument can be extended with :"
"func:`register_error`."
msgstr ""
"Набір дозволених значень для аргументу *errors* можна розширити за "
"допомогою :func:`register_error`."

#: ../../library/codecs.rst:803
msgid "Decodes data from the stream and returns the resulting object."
msgstr "Декодує дані з потоку та повертає отриманий об’єкт."

#: ../../library/codecs.rst:805
msgid ""
"The *chars* argument indicates the number of decoded code points or bytes to "
"return. The :func:`read` method will never return more data than requested, "
"but it might return less, if there is not enough available."
msgstr ""
"Аргумент *chars* вказує кількість декодованих кодових точок або байтів, які "
"потрібно повернути. Метод :func:`read` ніколи не поверне більше даних, ніж "
"вимагається, але може повернути менше, якщо їх буде недостатньо."

#: ../../library/codecs.rst:810
msgid ""
"The *size* argument indicates the approximate maximum number of encoded "
"bytes or code points to read for decoding. The decoder can modify this "
"setting as appropriate. The default value -1 indicates to read and decode as "
"much as possible. This parameter is intended to prevent having to decode "
"huge files in one step."
msgstr ""
"Аргумент *size* вказує на приблизну максимальну кількість закодованих байтів "
"або кодових точок для читання для декодування. Декодер може змінювати цей "
"параметр за потреби. Значення за замовчуванням -1 вказує на читання та "
"декодування якомога більшої кількості. Цей параметр призначений для "
"запобігання необхідності декодувати великі файли за один крок."

#: ../../library/codecs.rst:817
msgid ""
"The *firstline* flag indicates that it would be sufficient to only return "
"the first line, if there are decoding errors on later lines."
msgstr ""
"Прапорець *firstline* вказує на те, що було б достатньо повернути лише "
"перший рядок, якщо в наступних рядках є помилки декодування."

#: ../../library/codecs.rst:821
msgid ""
"The method should use a greedy read strategy meaning that it should read as "
"much data as is allowed within the definition of the encoding and the given "
"size, e.g.  if optional encoding endings or state markers are available on "
"the stream, these should be read too."
msgstr ""
"Метод повинен використовувати стратегію жадібного читання, тобто він повинен "
"зчитувати стільки даних, скільки дозволено у визначенні кодування та "
"заданого розміру, наприклад. якщо в потоці доступні додаткові закінчення "
"кодування або маркери стану, їх також слід прочитати."

#: ../../library/codecs.rst:829
msgid "Read one line from the input stream and return the decoded data."
msgstr "Прочитати один рядок із вхідного потоку та повернути декодовані дані."

#: ../../library/codecs.rst:831
msgid ""
"*size*, if given, is passed as size argument to the stream's :meth:`read` "
"method."
msgstr ""
"*size*, якщо задано, передається як аргумент розміру в метод :meth:`read` "
"потоку."

#: ../../library/codecs.rst:834
msgid ""
"If *keepends* is false line-endings will be stripped from the lines returned."
msgstr ""
"Якщо *keepends* має значення false, закінчення рядків буде видалено з "
"повернутих рядків."

#: ../../library/codecs.rst:840
msgid ""
"Read all lines available on the input stream and return them as a list of "
"lines."
msgstr ""
"Прочитати всі рядки, доступні у вхідному потоці, і повернути їх як список "
"рядків."

#: ../../library/codecs.rst:843
msgid ""
"Line-endings are implemented using the codec's :meth:`decode` method and are "
"included in the list entries if *keepends* is true."
msgstr ""
"Закінчення рядків реалізуються за допомогою методу кодека :meth:`decode` і "
"включаються до записів списку, якщо *keepends* має значення true."

#: ../../library/codecs.rst:846
msgid ""
"*sizehint*, if given, is passed as the *size* argument to the stream's :meth:"
"`read` method."
msgstr ""
"*sizehint*, якщо його задано, передається як аргумент *size* у метод потоку :"
"meth:`read`."

#: ../../library/codecs.rst:854
msgid ""
"Note that no stream repositioning should take place. This method is "
"primarily intended to be able to recover from decoding errors."
msgstr ""
"Зауважте, що переміщення потоку не повинно відбуватися. Цей метод насамперед "
"призначений для відновлення після помилок декодування."

#: ../../library/codecs.rst:858
msgid ""
"In addition to the above methods, the :class:`StreamReader` must also "
"inherit all other methods and attributes from the underlying stream."
msgstr ""
"Окрім вищезазначених методів, :class:`StreamReader` також має успадкувати "
"всі інші методи та атрибути базового потоку."

#: ../../library/codecs.rst:864
msgid "StreamReaderWriter Objects"
msgstr "Objek StreamReaderWriter"

#: ../../library/codecs.rst:866
msgid ""
"The :class:`StreamReaderWriter` is a convenience class that allows wrapping "
"streams which work in both read and write modes."
msgstr ""
":class:`StreamReaderWriter` — це зручний клас, який дозволяє обгортати "
"потоки, які працюють як у режимі читання, так і в режимі запису."

#: ../../library/codecs.rst:869 ../../library/codecs.rst:893
msgid ""
"The design is such that one can use the factory functions returned by the :"
"func:`lookup` function to construct the instance."
msgstr ""
"Конструкція така, що можна використовувати фабричні функції, які повертає "
"функція :func:`lookup` для створення екземпляра."

#: ../../library/codecs.rst:875
msgid ""
"Creates a :class:`StreamReaderWriter` instance. *stream* must be a file-like "
"object. *Reader* and *Writer* must be factory functions or classes providing "
"the :class:`StreamReader` and :class:`StreamWriter` interface resp. Error "
"handling is done in the same way as defined for the stream readers and "
"writers."
msgstr ""
"Створює екземпляр :class:`StreamReaderWriter`. *потік* має бути "
"файлоподібним об’єктом. *Reader* і *Writer* повинні бути фабричними "
"функціями або класами, що забезпечують інтерфейс :class:`StreamReader` і :"
"class:`StreamWriter` відповідно. Обробка помилок виконується так само, як "
"визначено для читачів і записів потоку."

#: ../../library/codecs.rst:880
msgid ""
":class:`StreamReaderWriter` instances define the combined interfaces of :"
"class:`StreamReader` and :class:`StreamWriter` classes. They inherit all "
"other methods and attributes from the underlying stream."
msgstr ""
"Екземпляри :class:`StreamReaderWriter` визначають комбіновані інтерфейси "
"класів :class:`StreamReader` і :class:`StreamWriter`. Вони успадковують усі "
"інші методи та атрибути від основного потоку."

#: ../../library/codecs.rst:888
msgid "StreamRecoder Objects"
msgstr "Objek StreamRecoder"

#: ../../library/codecs.rst:890
msgid ""
"The :class:`StreamRecoder` translates data from one encoding to another, "
"which is sometimes useful when dealing with different encoding environments."
msgstr ""
":class:`StreamRecoder` переводить дані з одного кодування в інше, що іноді "
"корисно, коли ви маєте справу з різними середовищами кодування."

#: ../../library/codecs.rst:899
msgid ""
"Creates a :class:`StreamRecoder` instance which implements a two-way "
"conversion: *encode* and *decode* work on the frontend — the data visible to "
"code calling :meth:`~StreamReader.read` and :meth:`~StreamWriter.write`, "
"while *Reader* and *Writer* work on the backend — the data in *stream*."
msgstr ""
"Создает экземпляр :class:`StreamRecoder`, который реализует двустороннее "
"преобразование: *encode* и *decode* работают во внешнем интерфейсе — данные "
"видны коду, вызывающему :meth:`~StreamReader.read` и :meth:`~ StreamWriter."
"write`, а *Reader* и *Writer* работают на бэкэнде — данные в *stream*."

#: ../../library/codecs.rst:905
msgid ""
"You can use these objects to do transparent transcodings, e.g., from Latin-1 "
"to UTF-8 and back."
msgstr ""
"Ви можете використовувати ці об’єкти для прозорого перекодування, наприклад, "
"з Latin-1 на UTF-8 і назад."

#: ../../library/codecs.rst:908
msgid "The *stream* argument must be a file-like object."
msgstr "Аргумент *потік* має бути файлоподібним об’єктом."

#: ../../library/codecs.rst:910
msgid ""
"The *encode* and *decode* arguments must adhere to the :class:`Codec` "
"interface. *Reader* and *Writer* must be factory functions or classes "
"providing objects of the :class:`StreamReader` and :class:`StreamWriter` "
"interface respectively."
msgstr ""
"Аргументи *encode* і *decode* мають відповідати інтерфейсу :class:`Codec`. "
"*Reader* і *Writer* повинні бути фабричними функціями або класами, що "
"забезпечують об’єкти інтерфейсу :class:`StreamReader` і :class:"
"`StreamWriter` відповідно."

#: ../../library/codecs.rst:915
msgid ""
"Error handling is done in the same way as defined for the stream readers and "
"writers."
msgstr ""
"Обробка помилок виконується так само, як визначено для читачів і записів "
"потоку."

#: ../../library/codecs.rst:919
msgid ""
":class:`StreamRecoder` instances define the combined interfaces of :class:"
"`StreamReader` and :class:`StreamWriter` classes. They inherit all other "
"methods and attributes from the underlying stream."
msgstr ""
"Екземпляри :class:`StreamRecoder` визначають комбіновані інтерфейси класів :"
"class:`StreamReader` і :class:`StreamWriter`. Вони успадковують усі інші "
"методи та атрибути основного потоку."

#: ../../library/codecs.rst:927
msgid "Encodings and Unicode"
msgstr "Кодування та Unicode"

#: ../../library/codecs.rst:929
msgid ""
"Strings are stored internally as sequences of code points in range "
"``U+0000``--``U+10FFFF``. (See :pep:`393` for more details about the "
"implementation.) Once a string object is used outside of CPU and memory, "
"endianness and how these arrays are stored as bytes become an issue. As with "
"other codecs, serialising a string into a sequence of bytes is known as "
"*encoding*, and recreating the string from the sequence of bytes is known as "
"*decoding*. There are a variety of different text serialisation codecs, "
"which are collectivity referred to as :term:`text encodings <text encoding>`."
msgstr ""
"Рядки зберігаються внутрішньо як послідовності кодових точок у діапазоні "
"``U+0000``--``U+10FFFF``. (Див. :pep:`393` для отримання додаткової "
"інформації про реалізацію.) Коли рядковий об’єкт використовується поза "
"центральним процесором і пам’яттю, стає проблемою порядок байтів і те, як ці "
"масиви зберігаються як байти. Як і в інших кодеках, серіалізація рядка в "
"послідовність байтів відома як *кодування*, а відтворення рядка з "
"послідовності байтів відоме як *декодування*. Існує безліч різних кодеків "
"серіалізації тексту, які в сукупності називаються :term:`текстовими "
"кодуваннями <text encoding>`."

#: ../../library/codecs.rst:939
msgid ""
"The simplest text encoding (called ``'latin-1'`` or ``'iso-8859-1'``) maps "
"the code points 0--255 to the bytes ``0x0``--``0xff``, which means that a "
"string object that contains code points above ``U+00FF`` can't be encoded "
"with this codec. Doing so will raise a :exc:`UnicodeEncodeError` that looks "
"like the following (although the details of the error message may differ): "
"``UnicodeEncodeError: 'latin-1' codec can't encode character '\\u1234' in "
"position 3: ordinal not in range(256)``."
msgstr ""
"Найпростіше кодування тексту (називається ``'latin-1'`` або "
"``'iso-8859-1'``) відображає кодові точки 0--255 на байти ``0x0``--``0xff``, "
"що означає, що рядковий об’єкт, який містить кодові точки вище ``U+00FF``, "
"не може бути закодований цим кодеком. Це призведе до появи :exc:"
"`UnicodeEncodeError`, яка виглядає так (хоча деталі повідомлення про помилку "
"можуть відрізнятися): ``UnicodeEncodeError: кодек 'latin-1' не може "
"закодувати символ '\\u1234' у позиції 3 : порядковий номер не в діапазоні "
"(256)``."

#: ../../library/codecs.rst:947
msgid ""
"There's another group of encodings (the so called charmap encodings) that "
"choose a different subset of all Unicode code points and how these code "
"points are mapped to the bytes ``0x0``--``0xff``. To see how this is done "
"simply open e.g. :file:`encodings/cp1252.py` (which is an encoding that is "
"used primarily on Windows). There's a string constant with 256 characters "
"that shows you which character is mapped to which byte value."
msgstr ""
"Існує ще одна група кодувань (так звані кодування charmap), які вибирають "
"іншу підмножину всіх кодових точок Unicode і те, як ці кодові точки "
"відображаються на байти ``0x0``--``0xff``. Щоб побачити, як це робиться, "
"просто відкрийте, наприклад. :file:`encodings/cp1252.py` (це кодування, яке "
"використовується в основному в Windows). Існує рядкова константа з 256 "
"символами, яка показує, який символ зіставляється з яким значенням байта."

#: ../../library/codecs.rst:954
msgid ""
"All of these encodings can only encode 256 of the 1114112 code points "
"defined in Unicode. A simple and straightforward way that can store each "
"Unicode code point, is to store each code point as four consecutive bytes. "
"There are two possibilities: store the bytes in big endian or in little "
"endian order. These two encodings are called ``UTF-32-BE`` and ``UTF-32-LE`` "
"respectively. Their disadvantage is that if e.g. you use ``UTF-32-BE`` on a "
"little endian machine you will always have to swap bytes on encoding and "
"decoding. ``UTF-32`` avoids this problem: bytes will always be in natural "
"endianness. When these bytes are read by a CPU with a different endianness, "
"then bytes have to be swapped though. To be able to detect the endianness of "
"a ``UTF-16`` or ``UTF-32`` byte sequence, there's the so called BOM (\"Byte "
"Order Mark\"). This is the Unicode character ``U+FEFF``. This character can "
"be prepended to every ``UTF-16`` or ``UTF-32`` byte sequence. The byte "
"swapped version of this character (``0xFFFE``) is an illegal character that "
"may not appear in a Unicode text. So when the first character in a "
"``UTF-16`` or ``UTF-32`` byte sequence appears to be a ``U+FFFE`` the bytes "
"have to be swapped on decoding. Unfortunately the character ``U+FEFF`` had a "
"second purpose as a ``ZERO WIDTH NO-BREAK SPACE``: a character that has no "
"width and doesn't allow a word to be split. It can e.g. be used to give "
"hints to a ligature algorithm. With Unicode 4.0 using ``U+FEFF`` as a ``ZERO "
"WIDTH NO-BREAK SPACE`` has been deprecated (with ``U+2060`` (``WORD "
"JOINER``) assuming this role). Nevertheless Unicode software still must be "
"able to handle ``U+FEFF`` in both roles: as a BOM it's a device to determine "
"the storage layout of the encoded bytes, and vanishes once the byte sequence "
"has been decoded into a string; as a ``ZERO WIDTH NO-BREAK SPACE`` it's a "
"normal character that will be decoded like any other."
msgstr ""
"Усі ці кодування можуть кодувати лише 256 із 1114112 кодових точок, "
"визначених у Unicode. Простий і зрозумілий спосіб збереження кожної кодової "
"точки Unicode полягає в тому, щоб зберегти кожну кодову точку у вигляді "
"чотирьох послідовних байтів. Є дві можливості: зберігати байти в порядку "
"старшого або малого порядку. Ці два кодування називаються ``UTF-32-BE`` і "
"``UTF-32-LE`` відповідно. Їх недолік полягає в тому, що якщо напр. якщо ви "
"використовуєте ``UTF-32-BE`` на машині з порядковим порядком байтів, вам "
"завжди доведеться міняти місцями байти під час кодування та декодування. "
"``UTF-32`` уникає цієї проблеми: байти завжди будуть у природному порядку "
"байтів. Коли ці байти зчитуються процесором з іншим порядком байтів, тоді "
"байти потрібно поміняти місцями. Щоб мати можливість виявити порядок байтів "
"послідовності байтів ``UTF-16`` або ``UTF-32``, існує так звана BOM "
"(\"Позначка порядку байтів\"). Це символ Unicode ``U+FEFF``. Цей символ "
"можна додавати до кожної послідовності байтів ``UTF-16`` або ``UTF-32``. "
"Версія цього символу з заміною байтів (``0xFFFE``) є неприпустимим символом, "
"який може не з’являтися в тексті Unicode. Отже, коли перший символ у "
"послідовності байтів ``UTF-16`` або ``UTF-32`` виглядає як ``U+FFFE``, байти "
"потрібно поміняти місцями під час декодування. На жаль, символ ``U+FEFF`` "
"мав другу мету як ``НУЛЬОВА ШИРИНА БЕЗ РОЗБИВУ``: символ, який не має ширини "
"і не дозволяє розділити слово. Це може напр. використовувати для надання "
"підказок алгоритму лігатури. З Юнікодом 4.0 використання ``U+FEFF`` як "
"``НУЛЬОВА ШИРИНА НЕРОЗБИВНОГО ПРОБІЛУ`` застаріло (з ``U+2060`` (``WORD "
"JOINER``) виконує цю роль). Незважаючи на це, програмне забезпечення Unicode "
"все ще має бути в змозі обробляти ``U+FEFF`` в обох ролях: як BOM, це "
"пристрій для визначення макета зберігання закодованих байтів і зникає, коли "
"послідовність байтів була декодована в рядок; як ``НУЛЬОВА ШИРИНА БЕЗ "
"РОЗБИВУ`` це звичайний символ, який буде декодовано, як і будь-який інший."

#: ../../library/codecs.rst:980
msgid ""
"There's another encoding that is able to encode the full range of Unicode "
"characters: UTF-8. UTF-8 is an 8-bit encoding, which means there are no "
"issues with byte order in UTF-8. Each byte in a UTF-8 byte sequence consists "
"of two parts: marker bits (the most significant bits) and payload bits. The "
"marker bits are a sequence of zero to four ``1`` bits followed by a ``0`` "
"bit. Unicode characters are encoded like this (with x being payload bits, "
"which when concatenated give the Unicode character):"
msgstr ""
"Є інше кодування, яке може кодувати повний діапазон символів Unicode: UTF-8. "
"UTF-8 — це 8-бітне кодування, що означає, що в UTF-8 немає проблем із "
"порядком байтів. Кожен байт у послідовності байтів UTF-8 складається з двох "
"частин: бітів маркера (старших бітів) і бітів корисного навантаження. Біти "
"маркера являють собою послідовність із нуля до чотирьох бітів ``1``, за "
"якими йде ``0`` біт. Символи Unicode кодуються таким чином (де x є бітами "
"корисного навантаження, які при з’єднанні дають символ Unicode):"

#: ../../library/codecs.rst:989
msgid "Range"
msgstr "Rentang"

#: ../../library/codecs.rst:989
msgid "Encoding"
msgstr "Penyandian *Encoding*"

#: ../../library/codecs.rst:991
msgid "``U-00000000`` ... ``U-0000007F``"
msgstr "``U-00000000`` ... ``U-0000007F``"

#: ../../library/codecs.rst:991
msgid "0xxxxxxx"
msgstr "0xxxxxxx"

#: ../../library/codecs.rst:993
msgid "``U-00000080`` ... ``U-000007FF``"
msgstr "``U-00000080`` ... ``U-000007FF``"

#: ../../library/codecs.rst:993
msgid "110xxxxx 10xxxxxx"
msgstr "110xxxxx 10xxxxxx"

#: ../../library/codecs.rst:995
msgid "``U-00000800`` ... ``U-0000FFFF``"
msgstr "``U-00000800`` ... ``U-0000FFFF``"

#: ../../library/codecs.rst:995
msgid "1110xxxx 10xxxxxx 10xxxxxx"
msgstr "1110xxxx 10xxxxxx 10xxxxxx"

#: ../../library/codecs.rst:997
msgid "``U-00010000`` ... ``U-0010FFFF``"
msgstr "``U-00010000`` ... ``U-0010FFFF``"

#: ../../library/codecs.rst:997
msgid "11110xxx 10xxxxxx 10xxxxxx 10xxxxxx"
msgstr "11110xxx 10xxxxxx 10xxxxxx 10xxxxxx"

#: ../../library/codecs.rst:1000
msgid ""
"The least significant bit of the Unicode character is the rightmost x bit."
msgstr "Наймолодшим бітом символу Юнікод є крайній правий біт x."

#: ../../library/codecs.rst:1002
msgid ""
"As UTF-8 is an 8-bit encoding no BOM is required and any ``U+FEFF`` "
"character in the decoded string (even if it's the first character) is "
"treated as a ``ZERO WIDTH NO-BREAK SPACE``."
msgstr ""
"Оскільки UTF-8 є 8-бітним кодуванням, специфікація матеріалів не потрібна, і "
"будь-який символ ``U+FEFF`` у декодованому рядку (навіть якщо це перший "
"символ) розглядається як ``НУЛЬОВА ШИРИНА БЕЗ РОЗБИВУ`` ."

#: ../../library/codecs.rst:1006
msgid ""
"Without external information it's impossible to reliably determine which "
"encoding was used for encoding a string. Each charmap encoding can decode "
"any random byte sequence. However that's not possible with UTF-8, as UTF-8 "
"byte sequences have a structure that doesn't allow arbitrary byte sequences. "
"To increase the reliability with which a UTF-8 encoding can be detected, "
"Microsoft invented a variant of UTF-8 (that Python calls ``\"utf-8-sig\"``) "
"for its Notepad program: Before any of the Unicode characters is written to "
"the file, a UTF-8 encoded BOM (which looks like this as a byte sequence: "
"``0xef``, ``0xbb``, ``0xbf``) is written. As it's rather improbable that any "
"charmap encoded file starts with these byte values (which would e.g. map to"
msgstr ""
"Без зовнішньої інформації неможливо достовірно визначити, яке кодування було "
"використано для кодування рядка. Кожне кодування charmap може декодувати "
"будь-яку випадкову послідовність байтів. Однак це неможливо з UTF-8, "
"оскільки послідовності байтів UTF-8 мають структуру, яка не допускає "
"довільних послідовностей байтів. Щоб підвищити надійність виявлення "
"кодування UTF-8, Microsoft винайшла варіант UTF-8 (який Python називає "
"``\"utf-8-sig\"``) для своєї програми Notepad: перед будь-яким із символів "
"Unicode записується у файл, записується BOM у кодуванні UTF-8 (який виглядає "
"так як послідовність байтів: ``0xef``, ``0xbb``, ``0xbf``). Оскільки "
"малоймовірно, щоб будь-який файл, закодований charmap, починався з цих "
"значень байтів (що, наприклад, відображатиметься на"

#: ../../library/codecs.rst:0
msgid "LATIN SMALL LETTER I WITH DIAERESIS"
msgstr "LATIN SMALL LETTER I WITH DIAERESIS"

#: ../../library/codecs.rst:0
msgid "RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK"
msgstr "RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK"

#: ../../library/codecs.rst:0
msgid "INVERTED QUESTION MARK"
msgstr "INVERTED QUESTION MARK"

#: ../../library/codecs.rst:1022
msgid ""
"in iso-8859-1), this increases the probability that a ``utf-8-sig`` encoding "
"can be correctly guessed from the byte sequence. So here the BOM is not used "
"to be able to determine the byte order used for generating the byte "
"sequence, but as a signature that helps in guessing the encoding. On "
"encoding the utf-8-sig codec will write ``0xef``, ``0xbb``, ``0xbf`` as the "
"first three bytes to the file. On decoding ``utf-8-sig`` will skip those "
"three bytes if they appear as the first three bytes in the file. In UTF-8, "
"the use of the BOM is discouraged and should generally be avoided."
msgstr ""
"в iso-8859-1), це збільшує ймовірність того, що кодування ``utf-8-sig`` "
"можна правильно вгадати з послідовності байтів. Отже, тут BOM "
"використовується не для визначення порядку байтів, який використовується для "
"створення послідовності байтів, а як підпис, який допомагає вгадати "
"кодування. Під час кодування кодек utf-8-sig записуватиме ``0xef``, "
"``0xbb``, ``0xbf`` як перші три байти до файлу. Під час декодування ``utf-8-"
"sig`` пропустить ці три байти, якщо вони відображаються як перші три байти у "
"файлі. В UTF-8 використання BOM не рекомендується, і його слід уникати."

#: ../../library/codecs.rst:1035
msgid "Standard Encodings"
msgstr "Стандартні кодування"

#: ../../library/codecs.rst:1037
msgid ""
"Python comes with a number of codecs built-in, either implemented as C "
"functions or with dictionaries as mapping tables. The following table lists "
"the codecs by name, together with a few common aliases, and the languages "
"for which the encoding is likely used. Neither the list of aliases nor the "
"list of languages is meant to be exhaustive. Notice that spelling "
"alternatives that only differ in case or use a hyphen instead of an "
"underscore are also valid aliases; therefore, e.g. ``'utf-8'`` is a valid "
"alias for the ``'utf_8'`` codec."
msgstr ""
"Python поставляється з низкою вбудованих кодеків, реалізованих як функції C "
"або зі словниками як таблиці відображення. У наведеній нижче таблиці "
"наведено кодеки за назвами разом із кількома поширеними псевдонімами та "
"мовами, для яких, ймовірно, використовується кодування. Ні список "
"псевдонімів, ні список мов не є вичерпними. Зауважте, що варіанти написання, "
"які відрізняються лише регістром або використовують дефіс замість "
"підкреслення, також є дійсними псевдонімами; отже, напр. ``'utf-8''`` є "
"дійсним псевдонімом для ``'utf_8''`` кодека."

#: ../../library/codecs.rst:1047
msgid ""
"Some common encodings can bypass the codecs lookup machinery to improve "
"performance. These optimization opportunities are only recognized by CPython "
"for a limited set of (case insensitive) aliases: utf-8, utf8, latin-1, "
"latin1, iso-8859-1, iso8859-1, mbcs (Windows only), ascii, us-ascii, utf-16, "
"utf16, utf-32, utf32, and the same using underscores instead of dashes. "
"Using alternative aliases for these encodings may result in slower execution."
msgstr ""
"Деякі поширені кодування можуть обійти механізм пошуку кодеків для "
"підвищення продуктивності. Ці можливості оптимізації розпізнаються CPython "
"лише для обмеженого набору (незалежних від регістру) псевдонімів: utf-8, "
"utf8, latin-1, latin1, iso-8859-1, iso8859-1, mbcs (лише Windows), ascii, us "
"-ascii, utf-16, utf16, utf-32, utf32 і те саме, використовуючи підкреслення "
"замість тире. Використання альтернативних псевдонімів для цих кодувань може "
"призвести до сповільнення виконання."

#: ../../library/codecs.rst:1055
msgid "Optimization opportunity recognized for us-ascii."
msgstr "Можливість оптимізації визнана для us-ascii."

#: ../../library/codecs.rst:1058
msgid ""
"Many of the character sets support the same languages. They vary in "
"individual characters (e.g. whether the EURO SIGN is supported or not), and "
"in the assignment of characters to code positions. For the European "
"languages in particular, the following variants typically exist:"
msgstr ""
"Багато наборів символів підтримують однакові мови. Вони відрізняються за "
"окремими символами (наприклад, чи підтримується ЗНАК ЄВРО чи ні), а також за "
"призначенням символів позиціям коду. Зокрема, для європейських мов зазвичай "
"існують такі варіанти:"

#: ../../library/codecs.rst:1063
msgid "an ISO 8859 codeset"
msgstr "кодовий набір ISO 8859"

#: ../../library/codecs.rst:1065
msgid ""
"a Microsoft Windows code page, which is typically derived from an 8859 "
"codeset, but replaces control characters with additional graphic characters"
msgstr ""
"кодова сторінка Microsoft Windows, яка зазвичай походить від коду 8859, але "
"замінює контрольні символи додатковими графічними символами"

#: ../../library/codecs.rst:1068
msgid "an IBM EBCDIC code page"
msgstr "кодову сторінку IBM EBCDIC"

#: ../../library/codecs.rst:1070
msgid "an IBM PC code page, which is ASCII compatible"
msgstr "кодова сторінка IBM PC, сумісна з ASCII"

#: ../../library/codecs.rst:1075 ../../library/codecs.rst:1330
#: ../../library/codecs.rst:1398 ../../library/codecs.rst:1455
msgid "Codec"
msgstr "*Codec*"

#: ../../library/codecs.rst:1075 ../../library/codecs.rst:1330
#: ../../library/codecs.rst:1398 ../../library/codecs.rst:1455
msgid "Aliases"
msgstr "Псевдоніми"

#: ../../library/codecs.rst:1075
msgid "Languages"
msgstr "Idiomas"

#: ../../library/codecs.rst:1077
msgid "ascii"
msgstr "ascii"

#: ../../library/codecs.rst:1077
msgid "646, us-ascii"
msgstr "646, us-ascii"

#: ../../library/codecs.rst:1077 ../../library/codecs.rst:1083
#: ../../library/codecs.rst:1091
msgid "English"
msgstr "Inglês"

#: ../../library/codecs.rst:1079
msgid "big5"
msgstr "big5"

#: ../../library/codecs.rst:1079
msgid "big5-tw, csbig5"
msgstr "big5-tw, csbig5"

#: ../../library/codecs.rst:1079 ../../library/codecs.rst:1081
#: ../../library/codecs.rst:1139
msgid "Traditional Chinese"
msgstr "Cina Tradisional"

#: ../../library/codecs.rst:1081
msgid "big5hkscs"
msgstr "big5hkscs"

#: ../../library/codecs.rst:1081
msgid "big5-hkscs, hkscs"
msgstr "big5-hkscs, hkscs"

#: ../../library/codecs.rst:1083
msgid "cp037"
msgstr "cp037"

#: ../../library/codecs.rst:1083
msgid "IBM037, IBM039"
msgstr "IBM037, IBM039"

#: ../../library/codecs.rst:1085
msgid "cp273"
msgstr "cp273"

#: ../../library/codecs.rst:1085
msgid "273, IBM273, csIBM273"
msgstr "273, IBM273, csIBM273"

#: ../../library/codecs.rst:1085
msgid "German"
msgstr "Alemão"

#: ../../library/codecs.rst:1089
msgid "cp424"
msgstr "cp424"

#: ../../library/codecs.rst:1089
msgid "EBCDIC-CP-HE, IBM424"
msgstr "EBCDIC-CP-HE, IBM424"

#: ../../library/codecs.rst:1089 ../../library/codecs.rst:1109
#: ../../library/codecs.rst:1119 ../../library/codecs.rst:1162
#: ../../library/codecs.rst:1225
msgid "Hebrew"
msgstr "Hebraico"

#: ../../library/codecs.rst:1091
msgid "cp437"
msgstr "cp437"

#: ../../library/codecs.rst:1091
msgid "437, IBM437"
msgstr "437, IBM437"

#: ../../library/codecs.rst:1093
msgid "cp500"
msgstr "cp500"

#: ../../library/codecs.rst:1093
msgid "EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500"
msgstr "EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500"

#: ../../library/codecs.rst:1093 ../../library/codecs.rst:1102
#: ../../library/codecs.rst:1113 ../../library/codecs.rst:1149
#: ../../library/codecs.rst:1156 ../../library/codecs.rst:1209
#: ../../library/codecs.rst:1237 ../../library/codecs.rst:1265
msgid "Western Europe"
msgstr "Eropa Barat"

#: ../../library/codecs.rst:1096
msgid "cp720"
msgstr "cp720"

#: ../../library/codecs.rst:1096 ../../library/codecs.rst:1123
#: ../../library/codecs.rst:1164 ../../library/codecs.rst:1221
msgid "Arabic"
msgstr "Árabe"

#: ../../library/codecs.rst:1098
msgid "cp737"
msgstr "cp737"

#: ../../library/codecs.rst:1098 ../../library/codecs.rst:1129
#: ../../library/codecs.rst:1133 ../../library/codecs.rst:1158
#: ../../library/codecs.rst:1223 ../../library/codecs.rst:1258
msgid "Greek"
msgstr "Grego"

#: ../../library/codecs.rst:1100
msgid "cp775"
msgstr "cp775"

#: ../../library/codecs.rst:1100
msgid "IBM775"
msgstr "IBM775"

#: ../../library/codecs.rst:1100 ../../library/codecs.rst:1166
#: ../../library/codecs.rst:1216 ../../library/codecs.rst:1233
msgid "Baltic languages"
msgstr "Bahasa Baltik"

#: ../../library/codecs.rst:1102
msgid "cp850"
msgstr "cp850"

#: ../../library/codecs.rst:1102
msgid "850, IBM850"
msgstr "850, IBM850"

#: ../../library/codecs.rst:1104
msgid "cp852"
msgstr "cp852"

#: ../../library/codecs.rst:1104
msgid "852, IBM852"
msgstr "852, IBM852"

#: ../../library/codecs.rst:1104 ../../library/codecs.rst:1151
#: ../../library/codecs.rst:1212 ../../library/codecs.rst:1262
msgid "Central and Eastern Europe"
msgstr "Eropa Tengah dan Timur"

#: ../../library/codecs.rst:1106
msgid "cp855"
msgstr "cp855"

#: ../../library/codecs.rst:1106
msgid "855, IBM855"
msgstr "855, IBM855"

#: ../../library/codecs.rst:1106 ../../library/codecs.rst:1153
#: ../../library/codecs.rst:1218 ../../library/codecs.rst:1255
msgid "Bulgarian, Byelorussian, Macedonian, Russian, Serbian"
msgstr "Bahasa Bulgaria, Byelorusia, Makedonia, Rusia, Serbia"

#: ../../library/codecs.rst:1109
msgid "cp856"
msgstr "cp856"

#: ../../library/codecs.rst:1111
msgid "cp857"
msgstr "cp857"

#: ../../library/codecs.rst:1111
msgid "857, IBM857"
msgstr "857, IBM857"

#: ../../library/codecs.rst:1111 ../../library/codecs.rst:1143
#: ../../library/codecs.rst:1160 ../../library/codecs.rst:1227
#: ../../library/codecs.rst:1267
msgid "Turkish"
msgstr "Turco"

#: ../../library/codecs.rst:1113
msgid "cp858"
msgstr "cp858"

#: ../../library/codecs.rst:1113
msgid "858, IBM858"
msgstr "858, IBM858"

#: ../../library/codecs.rst:1115
msgid "cp860"
msgstr "cp860"

#: ../../library/codecs.rst:1115
msgid "860, IBM860"
msgstr "860, IBM860"

#: ../../library/codecs.rst:1115
msgid "Portuguese"
msgstr "Português"

#: ../../library/codecs.rst:1117
msgid "cp861"
msgstr "cp861"

#: ../../library/codecs.rst:1117
msgid "861, CP-IS, IBM861"
msgstr "861, CP-IS, IBM861"

#: ../../library/codecs.rst:1117 ../../library/codecs.rst:1260
msgid "Icelandic"
msgstr "Islandês"

#: ../../library/codecs.rst:1119
msgid "cp862"
msgstr "cp862"

#: ../../library/codecs.rst:1119
msgid "862, IBM862"
msgstr "862, IBM862"

#: ../../library/codecs.rst:1121
msgid "cp863"
msgstr "cp863"

#: ../../library/codecs.rst:1121
msgid "863, IBM863"
msgstr "863, IBM863"

#: ../../library/codecs.rst:1121
msgid "Canadian"
msgstr "Canadense"

#: ../../library/codecs.rst:1123
msgid "cp864"
msgstr "cp864"

#: ../../library/codecs.rst:1123
msgid "IBM864"
msgstr "IBM864"

#: ../../library/codecs.rst:1125
msgid "cp865"
msgstr "cp865"

#: ../../library/codecs.rst:1125
msgid "865, IBM865"
msgstr "865, IBM865"

#: ../../library/codecs.rst:1125
msgid "Danish, Norwegian"
msgstr "Bahasa Denmark, Norwegia"

#: ../../library/codecs.rst:1127
msgid "cp866"
msgstr "cp866"

#: ../../library/codecs.rst:1127
msgid "866, IBM866"
msgstr "866, IBM866"

#: ../../library/codecs.rst:1127 ../../library/codecs.rst:1243
msgid "Russian"
msgstr "Russo"

#: ../../library/codecs.rst:1129
msgid "cp869"
msgstr "cp869"

#: ../../library/codecs.rst:1129
msgid "869, CP-GR, IBM869"
msgstr "869, CP-GR, IBM869"

#: ../../library/codecs.rst:1131
msgid "cp874"
msgstr "cp874"

#: ../../library/codecs.rst:1131
msgid "Thai"
msgstr "Tailandês"

#: ../../library/codecs.rst:1133
msgid "cp875"
msgstr "cp875"

#: ../../library/codecs.rst:1135
msgid "cp932"
msgstr "cp932"

#: ../../library/codecs.rst:1135
msgid "932, ms932, mskanji, ms-kanji"
msgstr "932, ms932, mskanji, ms-kanji"

#: ../../library/codecs.rst:1135 ../../library/codecs.rst:1170
#: ../../library/codecs.rst:1172 ../../library/codecs.rst:1174
#: ../../library/codecs.rst:1191 ../../library/codecs.rst:1194
#: ../../library/codecs.rst:1199 ../../library/codecs.rst:1202
#: ../../library/codecs.rst:1204 ../../library/codecs.rst:1272
#: ../../library/codecs.rst:1275 ../../library/codecs.rst:1278
msgid "Japanese"
msgstr "Japonês"

#: ../../library/codecs.rst:1137
msgid "cp949"
msgstr "cp949"

#: ../../library/codecs.rst:1137
msgid "949, ms949, uhc"
msgstr "949, ms949, uhc"

#: ../../library/codecs.rst:1137 ../../library/codecs.rst:1176
#: ../../library/codecs.rst:1206 ../../library/codecs.rst:1241
msgid "Korean"
msgstr "Coreano"

#: ../../library/codecs.rst:1139
msgid "cp950"
msgstr "cp950"

#: ../../library/codecs.rst:1139
msgid "950, ms950"
msgstr "950, ms950"

#: ../../library/codecs.rst:1141
msgid "cp1006"
msgstr "cp1006"

#: ../../library/codecs.rst:1141
msgid "Urdu"
msgstr "Bahasa Urdu"

#: ../../library/codecs.rst:1143
msgid "cp1026"
msgstr "cp1026"

#: ../../library/codecs.rst:1143
msgid "ibm1026"
msgstr "ibm1026"

#: ../../library/codecs.rst:1145
msgid "cp1125"
msgstr "cp1125"

#: ../../library/codecs.rst:1145
msgid "1125, ibm1125, cp866u, ruscii"
msgstr "1125, ibm1125, cp866u, ruscii"

#: ../../library/codecs.rst:1145 ../../library/codecs.rst:1249
msgid "Ukrainian"
msgstr "Ucraniano"

#: ../../library/codecs.rst:1149
msgid "cp1140"
msgstr "cp1140"

#: ../../library/codecs.rst:1149
msgid "ibm1140"
msgstr "ibm1140"

#: ../../library/codecs.rst:1151
msgid "cp1250"
msgstr "cp1250"

#: ../../library/codecs.rst:1151
msgid "windows-1250"
msgstr "windows-1250"

#: ../../library/codecs.rst:1153
msgid "cp1251"
msgstr "cp1251"

#: ../../library/codecs.rst:1153
msgid "windows-1251"
msgstr "windows-1251"

#: ../../library/codecs.rst:1156
msgid "cp1252"
msgstr "cp1252"

#: ../../library/codecs.rst:1156
msgid "windows-1252"
msgstr "windows-1252"

#: ../../library/codecs.rst:1158
msgid "cp1253"
msgstr "cp1253"

#: ../../library/codecs.rst:1158
msgid "windows-1253"
msgstr "windows-1253"

#: ../../library/codecs.rst:1160
msgid "cp1254"
msgstr "cp1254"

#: ../../library/codecs.rst:1160
msgid "windows-1254"
msgstr "windows-1254"

#: ../../library/codecs.rst:1162
msgid "cp1255"
msgstr "cp1255"

#: ../../library/codecs.rst:1162
msgid "windows-1255"
msgstr "windows-1255"

#: ../../library/codecs.rst:1164
msgid "cp1256"
msgstr "cp1256"

#: ../../library/codecs.rst:1164
msgid "windows-1256"
msgstr "windows-1256"

#: ../../library/codecs.rst:1166
msgid "cp1257"
msgstr "cp1257"

#: ../../library/codecs.rst:1166
msgid "windows-1257"
msgstr "windows-1257"

#: ../../library/codecs.rst:1168
msgid "cp1258"
msgstr "cp1258"

#: ../../library/codecs.rst:1168
msgid "windows-1258"
msgstr "windows-1258"

#: ../../library/codecs.rst:1168
msgid "Vietnamese"
msgstr "Vietnamita"

#: ../../library/codecs.rst:1170
msgid "euc_jp"
msgstr "euc_jp"

#: ../../library/codecs.rst:1170
msgid "eucjp, ujis, u-jis"
msgstr "eucjp, ujis, u-jis"

#: ../../library/codecs.rst:1172
msgid "euc_jis_2004"
msgstr "euc_jis_2004"

#: ../../library/codecs.rst:1172
msgid "jisx0213, eucjis2004"
msgstr "jisx0213, eucjis2004"

#: ../../library/codecs.rst:1174
msgid "euc_jisx0213"
msgstr "euc_jisx0213"

#: ../../library/codecs.rst:1174
msgid "eucjisx0213"
msgstr "eucjisx0213"

#: ../../library/codecs.rst:1176
msgid "euc_kr"
msgstr "euc_kr"

#: ../../library/codecs.rst:1176
msgid "euckr, korean, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001"
msgstr "euckr, korean, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001"

#: ../../library/codecs.rst:1180
msgid "gb2312"
msgstr "gb2312"

#: ../../library/codecs.rst:1180
msgid ""
"chinese, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, "
"gb2312-80, iso-ir-58"
msgstr ""
"chinese, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, "
"gb2312-80, iso-ir-58"

#: ../../library/codecs.rst:1180 ../../library/codecs.rst:1189
msgid "Simplified Chinese"
msgstr "Bahasa Cina Disederhanakan *Simplified*"

#: ../../library/codecs.rst:1185
msgid "gbk"
msgstr "gbk"

#: ../../library/codecs.rst:1185
msgid "936, cp936, ms936"
msgstr "936, cp936, ms936"

#: ../../library/codecs.rst:1185 ../../library/codecs.rst:1187
msgid "Unified Chinese"
msgstr "Bahasa Cina Terpadu"

#: ../../library/codecs.rst:1187
msgid "gb18030"
msgstr "gb18030"

#: ../../library/codecs.rst:1187
msgid "gb18030-2000"
msgstr "gb18030-2000"

#: ../../library/codecs.rst:1189
msgid "hz"
msgstr "hz"

#: ../../library/codecs.rst:1189
msgid "hzgb, hz-gb, hz-gb-2312"
msgstr "hzgb, hz-gb, hz-gb-2312"

#: ../../library/codecs.rst:1191
msgid "iso2022_jp"
msgstr "iso2022_jp"

#: ../../library/codecs.rst:1191
msgid "csiso2022jp, iso2022jp, iso-2022-jp"
msgstr "csiso2022jp, iso2022jp, iso-2022-jp"

#: ../../library/codecs.rst:1194
msgid "iso2022_jp_1"
msgstr "iso2022_jp_1"

#: ../../library/codecs.rst:1194
msgid "iso2022jp-1, iso-2022-jp-1"
msgstr "iso2022jp-1, iso-2022-jp-1"

#: ../../library/codecs.rst:1196
msgid "iso2022_jp_2"
msgstr "iso2022_jp_2"

#: ../../library/codecs.rst:1196
msgid "iso2022jp-2, iso-2022-jp-2"
msgstr "iso2022jp-2, iso-2022-jp-2"

#: ../../library/codecs.rst:1196
msgid "Japanese, Korean, Simplified Chinese, Western Europe, Greek"
msgstr ""
"Bahasa Jepang, Korea, Cina Disederhanakan *Simplified*, Eropa Barat, Yunani"

#: ../../library/codecs.rst:1199
msgid "iso2022_jp_2004"
msgstr "iso2022_jp_2004"

#: ../../library/codecs.rst:1199
msgid "iso2022jp-2004, iso-2022-jp-2004"
msgstr "iso2022jp-2004, iso-2022-jp-2004"

#: ../../library/codecs.rst:1202
msgid "iso2022_jp_3"
msgstr "iso2022_jp_3"

#: ../../library/codecs.rst:1202
msgid "iso2022jp-3, iso-2022-jp-3"
msgstr "iso2022jp-3, iso-2022-jp-3"

#: ../../library/codecs.rst:1204
msgid "iso2022_jp_ext"
msgstr "iso2022_jp_ext"

#: ../../library/codecs.rst:1204
msgid "iso2022jp-ext, iso-2022-jp-ext"
msgstr "iso2022jp-ext, iso-2022-jp-ext"

#: ../../library/codecs.rst:1206
msgid "iso2022_kr"
msgstr "iso2022_kr"

#: ../../library/codecs.rst:1206
msgid "csiso2022kr, iso2022kr, iso-2022-kr"
msgstr "csiso2022kr, iso2022kr, iso-2022-kr"

#: ../../library/codecs.rst:1209
msgid "latin_1"
msgstr "latin_1"

#: ../../library/codecs.rst:1209
msgid "iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1"
msgstr "iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1"

#: ../../library/codecs.rst:1212
msgid "iso8859_2"
msgstr "iso8859_2"

#: ../../library/codecs.rst:1212
msgid "iso-8859-2, latin2, L2"
msgstr "iso-8859-2, latin2, L2"

#: ../../library/codecs.rst:1214
msgid "iso8859_3"
msgstr "iso8859_3"

#: ../../library/codecs.rst:1214
msgid "iso-8859-3, latin3, L3"
msgstr "iso-8859-3, latin3, L3"

#: ../../library/codecs.rst:1214
msgid "Esperanto, Maltese"
msgstr "Esperanto, Maltese"

#: ../../library/codecs.rst:1216
msgid "iso8859_4"
msgstr "iso8859_4"

#: ../../library/codecs.rst:1216
msgid "iso-8859-4, latin4, L4"
msgstr "iso-8859-4, latin4, L4"

#: ../../library/codecs.rst:1218
msgid "iso8859_5"
msgstr "iso8859_5"

#: ../../library/codecs.rst:1218
msgid "iso-8859-5, cyrillic"
msgstr "iso-8859-5, cyrillic"

#: ../../library/codecs.rst:1221
msgid "iso8859_6"
msgstr "iso8859_6"

#: ../../library/codecs.rst:1221
msgid "iso-8859-6, arabic"
msgstr "iso-8859-6, arabic"

#: ../../library/codecs.rst:1223
msgid "iso8859_7"
msgstr "iso8859_7"

#: ../../library/codecs.rst:1223
msgid "iso-8859-7, greek, greek8"
msgstr "iso-8859-7, greek, greek8"

#: ../../library/codecs.rst:1225
msgid "iso8859_8"
msgstr "iso8859_8"

#: ../../library/codecs.rst:1225
msgid "iso-8859-8, hebrew"
msgstr "iso-8859-8, hebrew"

#: ../../library/codecs.rst:1227
msgid "iso8859_9"
msgstr "iso8859_9"

#: ../../library/codecs.rst:1227
msgid "iso-8859-9, latin5, L5"
msgstr "iso-8859-9, latin5, L5"

#: ../../library/codecs.rst:1229
msgid "iso8859_10"
msgstr "iso8859_10"

#: ../../library/codecs.rst:1229
msgid "iso-8859-10, latin6, L6"
msgstr "iso-8859-10, latin6, L6"

#: ../../library/codecs.rst:1229
msgid "Nordic languages"
msgstr "Bahasa Nordik"

#: ../../library/codecs.rst:1231
msgid "iso8859_11"
msgstr "iso8859_11"

#: ../../library/codecs.rst:1231
msgid "iso-8859-11, thai"
msgstr "iso-8859-11, thai"

#: ../../library/codecs.rst:1231
msgid "Thai languages"
msgstr "Bahasa Thai"

#: ../../library/codecs.rst:1233
msgid "iso8859_13"
msgstr "iso8859_13"

#: ../../library/codecs.rst:1233
msgid "iso-8859-13, latin7, L7"
msgstr "iso-8859-13, latin7, L7"

#: ../../library/codecs.rst:1235
msgid "iso8859_14"
msgstr "iso8859_14"

#: ../../library/codecs.rst:1235
msgid "iso-8859-14, latin8, L8"
msgstr "iso-8859-14, latin8, L8"

#: ../../library/codecs.rst:1235
msgid "Celtic languages"
msgstr "Bahasa Celtic"

#: ../../library/codecs.rst:1237
msgid "iso8859_15"
msgstr "iso8859_15"

#: ../../library/codecs.rst:1237
msgid "iso-8859-15, latin9, L9"
msgstr "iso-8859-15, latin9, L9"

#: ../../library/codecs.rst:1239
msgid "iso8859_16"
msgstr "iso8859_16"

#: ../../library/codecs.rst:1239
msgid "iso-8859-16, latin10, L10"
msgstr "iso-8859-16, latin10, L10"

#: ../../library/codecs.rst:1239
msgid "South-Eastern Europe"
msgstr "South-Eastern Europe"

#: ../../library/codecs.rst:1241
msgid "johab"
msgstr "johab"

#: ../../library/codecs.rst:1241
msgid "cp1361, ms1361"
msgstr "cp1361, ms1361"

#: ../../library/codecs.rst:1243
msgid "koi8_r"
msgstr "koi8_r"

#: ../../library/codecs.rst:1245
msgid "koi8_t"
msgstr "koi8_t"

#: ../../library/codecs.rst:1245
msgid "Tajik"
msgstr "Tajik"

#: ../../library/codecs.rst:1249
msgid "koi8_u"
msgstr "koi8_u"

#: ../../library/codecs.rst:1251
msgid "kz1048"
msgstr "kz1048"

#: ../../library/codecs.rst:1251
msgid "kz_1048, strk1048_2002, rk1048"
msgstr "kz_1048, strk1048_2002, rk1048"

#: ../../library/codecs.rst:1251 ../../library/codecs.rst:1269
msgid "Kazakh"
msgstr "Cazaque"

#: ../../library/codecs.rst:1255
msgid "mac_cyrillic"
msgstr "mac_cyrillic"

#: ../../library/codecs.rst:1255
msgid "maccyrillic"
msgstr "maccyrillic"

#: ../../library/codecs.rst:1258
msgid "mac_greek"
msgstr "mac_greek"

#: ../../library/codecs.rst:1258
msgid "macgreek"
msgstr "macgreek"

#: ../../library/codecs.rst:1260
msgid "mac_iceland"
msgstr "mac_iceland"

#: ../../library/codecs.rst:1260
msgid "maciceland"
msgstr "maciceland"

#: ../../library/codecs.rst:1262
msgid "mac_latin2"
msgstr "mac_latin2"

#: ../../library/codecs.rst:1262
msgid "maclatin2, maccentraleurope, mac_centeuro"
msgstr "maclatin2, maccentraleurope, mac_centeuro"

#: ../../library/codecs.rst:1265
msgid "mac_roman"
msgstr "mac_roman"

#: ../../library/codecs.rst:1265
msgid "macroman, macintosh"
msgstr "macroman, macintosh"

#: ../../library/codecs.rst:1267
msgid "mac_turkish"
msgstr "mac_turkish"

#: ../../library/codecs.rst:1267
msgid "macturkish"
msgstr "macturkish"

#: ../../library/codecs.rst:1269
msgid "ptcp154"
msgstr "ptcp154"

#: ../../library/codecs.rst:1269
msgid "csptcp154, pt154, cp154, cyrillic-asian"
msgstr "csptcp154, pt154, cp154, cyrillic-asian"

#: ../../library/codecs.rst:1272
msgid "shift_jis"
msgstr "shift_jis"

#: ../../library/codecs.rst:1272
msgid "csshiftjis, shiftjis, sjis, s_jis"
msgstr "csshiftjis, shiftjis, sjis, s_jis"

#: ../../library/codecs.rst:1275
msgid "shift_jis_2004"
msgstr "shift_jis_2004"

#: ../../library/codecs.rst:1275
msgid "shiftjis2004, sjis_2004, sjis2004"
msgstr "shiftjis2004, sjis_2004, sjis2004"

#: ../../library/codecs.rst:1278
msgid "shift_jisx0213"
msgstr "shift_jisx0213"

#: ../../library/codecs.rst:1278
msgid "shiftjisx0213, sjisx0213, s_jisx0213"
msgstr "shiftjisx0213, sjisx0213, s_jisx0213"

#: ../../library/codecs.rst:1281
msgid "utf_32"
msgstr "utf_32"

#: ../../library/codecs.rst:1281
msgid "U32, utf32"
msgstr "U32, utf32"

#: ../../library/codecs.rst:1281 ../../library/codecs.rst:1283
#: ../../library/codecs.rst:1285 ../../library/codecs.rst:1287
#: ../../library/codecs.rst:1289 ../../library/codecs.rst:1291
#: ../../library/codecs.rst:1293 ../../library/codecs.rst:1295
#: ../../library/codecs.rst:1297
msgid "all languages"
msgstr "todas linguagens"

#: ../../library/codecs.rst:1283
msgid "utf_32_be"
msgstr "utf_32_be"

#: ../../library/codecs.rst:1283
msgid "UTF-32BE"
msgstr "UTF-32BE"

#: ../../library/codecs.rst:1285
msgid "utf_32_le"
msgstr "utf_32_le"

#: ../../library/codecs.rst:1285
msgid "UTF-32LE"
msgstr "UTF-32LE"

#: ../../library/codecs.rst:1287
msgid "utf_16"
msgstr "utf_16"

#: ../../library/codecs.rst:1287
msgid "U16, utf16"
msgstr "U16, utf16"

#: ../../library/codecs.rst:1289
msgid "utf_16_be"
msgstr "utf_16_be"

#: ../../library/codecs.rst:1289
msgid "UTF-16BE"
msgstr "UTF-16BE"

#: ../../library/codecs.rst:1291
msgid "utf_16_le"
msgstr "utf_16_le"

#: ../../library/codecs.rst:1291
msgid "UTF-16LE"
msgstr "UTF-16LE"

#: ../../library/codecs.rst:1293
msgid "utf_7"
msgstr "utf_7"

#: ../../library/codecs.rst:1293
msgid "U7, unicode-1-1-utf-7"
msgstr "U7, unicode-1-1-utf-7"

#: ../../library/codecs.rst:1295
msgid "utf_8"
msgstr "utf_8"

#: ../../library/codecs.rst:1295
msgid "U8, UTF, utf8, cp65001"
msgstr "U8, UTF, utf8, cp65001"

#: ../../library/codecs.rst:1297
msgid "utf_8_sig"
msgstr "utf_8_sig"

#: ../../library/codecs.rst:1300
msgid ""
"The utf-16\\* and utf-32\\* encoders no longer allow surrogate code points "
"(``U+D800``--``U+DFFF``) to be encoded. The utf-32\\* decoders no longer "
"decode byte sequences that correspond to surrogate code points."
msgstr ""
"Кодери utf-16\\* і utf-32\\* більше не дозволяють кодувати сурогатні кодові "
"точки (``U+D800``--``U+DFFF``). Декодери utf-32\\* більше не декодують "
"послідовності байтів, які відповідають сурогатним кодовим точкам."

#: ../../library/codecs.rst:1306
msgid "``cp65001`` is now an alias to ``utf_8``."
msgstr "``cp65001`` тепер є псевдонімом ``utf_8``."

#: ../../library/codecs.rst:1311
msgid "Python Specific Encodings"
msgstr "Спеціальні кодування Python"

#: ../../library/codecs.rst:1313
msgid ""
"A number of predefined codecs are specific to Python, so their codec names "
"have no meaning outside Python. These are listed in the tables below based "
"on the expected input and output types (note that while text encodings are "
"the most common use case for codecs, the underlying codec infrastructure "
"supports arbitrary data transforms rather than just text encodings). For "
"asymmetric codecs, the stated meaning describes the encoding direction."
msgstr ""
"Деякі попередньо визначені кодеки є специфічними для Python, тому їхні назви "
"кодеків не мають значення поза Python. Вони перераховані в таблицях нижче на "
"основі очікуваних типів введення та виведення (зауважте, що хоча кодування "
"тексту є найпоширенішим випадком використання кодеків, базова інфраструктура "
"кодеків підтримує довільні перетворення даних, а не лише кодування тексту). "
"Для асиметричних кодеків вказане значення описує напрямок кодування."

#: ../../library/codecs.rst:1321
msgid "Text Encodings"
msgstr "Кодування тексту"

#: ../../library/codecs.rst:1323
msgid ""
"The following codecs provide :class:`str` to :class:`bytes` encoding and :"
"term:`bytes-like object` to :class:`str` decoding, similar to the Unicode "
"text encodings."
msgstr ""
"Наступні кодеки забезпечують кодування :class:`str` до :class:`bytes` і "
"декодування :term:`bytes-like object` до :class:`str`, подібне до кодування "
"тексту Unicode."

#: ../../library/codecs.rst:1332
msgid "idna"
msgstr "idna"

#: ../../library/codecs.rst:1332
msgid ""
"Implement :rfc:`3490`, see also :mod:`encodings.idna`. Only "
"``errors='strict'`` is supported."
msgstr ""
"Реалізація :rfc:`3490`, див. також :mod:`encodings.idna`. Підтримується лише "
"``errors='strict'``."

#: ../../library/codecs.rst:1338
msgid "mbcs"
msgstr "mbcs"

#: ../../library/codecs.rst:1338
msgid "ansi, dbcs"
msgstr "ansi, dbcs"

#: ../../library/codecs.rst:1338
msgid ""
"Windows only: Encode the operand according to the ANSI codepage (CP_ACP)."
msgstr ""
"Лише для Windows: кодуйте операнд відповідно до кодової сторінки ANSI "
"(CP_ACP)."

#: ../../library/codecs.rst:1342
msgid "oem"
msgstr "oem"

#: ../../library/codecs.rst:1342
msgid ""
"Windows only: Encode the operand according to the OEM codepage (CP_OEMCP)."
msgstr ""
"Лише для Windows: кодуйте операнд відповідно до кодової сторінки OEM "
"(CP_OEMCP)."

#: ../../library/codecs.rst:1348
msgid "palmos"
msgstr "palmos"

#: ../../library/codecs.rst:1348
msgid "Encoding of PalmOS 3.5."
msgstr "Кодування PalmOS 3.5."

#: ../../library/codecs.rst:1350
msgid "punycode"
msgstr "punycode"

#: ../../library/codecs.rst:1350
msgid "Implement :rfc:`3492`. Stateful codecs are not supported."
msgstr "Впровадити :rfc:`3492`. Кодеки з підтримкою стану не підтримуються."

#: ../../library/codecs.rst:1354
msgid "raw_unicode_escape"
msgstr "raw_unicode_escape"

#: ../../library/codecs.rst:1354
msgid ""
"Latin-1 encoding with :samp:`\\\\u{XXXX}` and :samp:`\\\\U{XXXXXXXX}` for "
"other code points. Existing backslashes are not escaped in any way. It is "
"used in the Python pickle protocol."
msgstr ""
"Кодировка Latin-1 с :samp:`\\\\u{XXXX}` и :samp:`\\\\U{XXXXXXXX}` для других "
"кодовых точек. Существующие обратные косые черты никак не экранируются. Он "
"используется в протоколе Pickle Python."

#: ../../library/codecs.rst:1364
msgid "undefined"
msgstr "tidak terdefinisi"

#: ../../library/codecs.rst:1364
msgid ""
"Raise an exception for all conversions, even empty strings. The error "
"handler is ignored."
msgstr ""
"Викликати виняток для всіх перетворень, навіть для порожніх рядків. Обробник "
"помилок ігнорується."

#: ../../library/codecs.rst:1369
msgid "unicode_escape"
msgstr "unicode_escape"

#: ../../library/codecs.rst:1369
msgid ""
"Encoding suitable as the contents of a Unicode literal in ASCII-encoded "
"Python source code, except that quotes are not escaped. Decode from Latin-1 "
"source code. Beware that Python source code actually uses UTF-8 by default."
msgstr ""
"Кодування, придатне як вміст літералу Юнікод у вихідному коді Python із "
"кодуванням ASCII, за винятком того, що лапки не екрануються. Декодувати з "
"вихідного коду Latin-1. Майте на увазі, що вихідний код Python насправді "
"використовує UTF-8 за замовчуванням."

#: ../../library/codecs.rst:1381
msgid "\"unicode_internal\" codec is removed."
msgstr "Кодек \"unicode_internal\" видалено."

#: ../../library/codecs.rst:1388
msgid "Binary Transforms"
msgstr "Двійкові перетворення"

#: ../../library/codecs.rst:1390
msgid ""
"The following codecs provide binary transforms: :term:`bytes-like object` "
"to :class:`bytes` mappings. They are not supported by :meth:`bytes.decode` "
"(which only produces :class:`str` output)."
msgstr ""
"Наступні кодеки забезпечують двійкові перетворення: :term:`bytes-like "
"object` у :class:`bytes` зіставлення. Вони не підтримуються :meth:`bytes."
"decode` (який виводить лише :class:`str`)."

#: ../../library/codecs.rst:1398
msgid "Encoder / decoder"
msgstr "Кодер / декодер"

#: ../../library/codecs.rst:1400
msgid "base64_codec [#b64]_"
msgstr "base64_codec [#b64]_"

#: ../../library/codecs.rst:1400
msgid "base64, base_64"
msgstr "base64, base_64"

#: ../../library/codecs.rst:1400
msgid ""
"Convert the operand to multiline MIME base64 (the result always includes a "
"trailing ``'\\n'``)."
msgstr ""
"Перетворіть операнд на багаторядковий MIME base64 (результат завжди включає "
"``'\\n'``)."

#: ../../library/codecs.rst:1405
msgid ""
"accepts any :term:`bytes-like object` as input for encoding and decoding"
msgstr ""
"приймає будь-який :term:`bytes-like object` як вхідні дані для кодування та "
"декодування"

#: ../../library/codecs.rst:1400
msgid ":meth:`base64.encodebytes` / :meth:`base64.decodebytes`"
msgstr ":meth:`base64.encodebytes` / :meth:`base64.decodebytes`"

#: ../../library/codecs.rst:1411
msgid "bz2_codec"
msgstr "bz2_codec"

#: ../../library/codecs.rst:1411
msgid "bz2"
msgstr "bz2"

#: ../../library/codecs.rst:1411
msgid "Compress the operand using bz2."
msgstr "Стисніть операнд за допомогою bz2."

#: ../../library/codecs.rst:1411
msgid ":meth:`bz2.compress` / :meth:`bz2.decompress`"
msgstr ":meth:`bz2.compress` / :meth:`bz2.decompress`"

#: ../../library/codecs.rst:1414
msgid "hex_codec"
msgstr "hex_codec"

#: ../../library/codecs.rst:1414
msgid "hex"
msgstr "hex"

#: ../../library/codecs.rst:1414
msgid ""
"Convert the operand to hexadecimal representation, with two digits per byte."
msgstr "Перетворіть операнд у шістнадцяткове подання з двома цифрами на байт."

#: ../../library/codecs.rst:1414
msgid ":meth:`binascii.b2a_hex` / :meth:`binascii.a2b_hex`"
msgstr ":meth:`binascii.b2a_hex` / :meth:`binascii.a2b_hex`"

#: ../../library/codecs.rst:1419
msgid "quopri_codec"
msgstr "quopri_codec"

#: ../../library/codecs.rst:1419
msgid "quopri, quotedprintable, quoted_printable"
msgstr "quopri, quotedprintable, quoted_printable"

#: ../../library/codecs.rst:1419
msgid "Convert the operand to MIME quoted printable."
msgstr "Перетворіть операнд на MIME-цитований для друку."

#: ../../library/codecs.rst:1419
msgid ":meth:`quopri.encode` with ``quotetabs=True`` / :meth:`quopri.decode`"
msgstr ":meth:`quopri.encode` with ``quotetabs=True`` / :meth:`quopri.decode`"

#: ../../library/codecs.rst:1423
msgid "uu_codec"
msgstr "uu_codec"

#: ../../library/codecs.rst:1423
msgid "uu"
msgstr "uu"

#: ../../library/codecs.rst:1423
msgid "Convert the operand using uuencode."
msgstr "Перетворіть операнд за допомогою uuencode."

#: ../../library/codecs.rst:1423
msgid ""
":meth:`!uu.encode` / :meth:`!uu.decode` (Note: :mod:`uu` is deprecated.)"
msgstr ""
":meth:`!uu.encode` / :meth:`!uu.decode` (Примечание: :mod:`uu` устарел.)"

#: ../../library/codecs.rst:1428
msgid "zlib_codec"
msgstr "zlib_codec"

#: ../../library/codecs.rst:1428
msgid "zip, zlib"
msgstr "zip, zlib"

#: ../../library/codecs.rst:1428
msgid "Compress the operand using gzip."
msgstr "Стисніть операнд за допомогою gzip."

#: ../../library/codecs.rst:1428
msgid ":meth:`zlib.compress` / :meth:`zlib.decompress`"
msgstr ":meth:`zlib.compress` / :meth:`zlib.decompress`"

#: ../../library/codecs.rst:1432
msgid ""
"In addition to :term:`bytes-like objects <bytes-like object>`, "
"``'base64_codec'`` also accepts ASCII-only instances of :class:`str` for "
"decoding"
msgstr ""
"На додаток до :term:`байт-подібних об’єктів <bytes-like object>`, "
"``'base64_codec''`` також приймає лише ASCII-примірники :class:`str` для "
"декодування"

#: ../../library/codecs.rst:1436
msgid "Restoration of the binary transforms."
msgstr "Відновлення двійкових перетворень."

#: ../../library/codecs.rst:1439
msgid "Restoration of the aliases for the binary transforms."
msgstr "Відновлення псевдонімів для бінарних перетворень."

#: ../../library/codecs.rst:1446
msgid "Text Transforms"
msgstr "Перетворення тексту"

#: ../../library/codecs.rst:1448
msgid ""
"The following codec provides a text transform: a :class:`str` to :class:"
"`str` mapping. It is not supported by :meth:`str.encode` (which only "
"produces :class:`bytes` output)."
msgstr ""
"Наступний кодек забезпечує перетворення тексту: відображення :class:`str` у :"
"class:`str`. Він не підтримується :meth:`str.encode` (який виводить лише :"
"class:`bytes`)."

#: ../../library/codecs.rst:1457
msgid "rot_13"
msgstr "rot_13"

#: ../../library/codecs.rst:1457
msgid "rot13"
msgstr "rot13"

#: ../../library/codecs.rst:1457
msgid "Return the Caesar-cypher encryption of the operand."
msgstr "Повернути шифрування операнда за допомогою шифру Цезаря."

#: ../../library/codecs.rst:1462
msgid "Restoration of the ``rot_13`` text transform."
msgstr "Відновлення текстового перетворення ``rot_13``."

#: ../../library/codecs.rst:1465
msgid "Restoration of the ``rot13`` alias."
msgstr "Відновлення псевдоніма ``rot13``."

#: ../../library/codecs.rst:1470
msgid ""
":mod:`encodings.idna` --- Internationalized Domain Names in Applications"
msgstr ""
":mod:`encodings.idna` --- Інтернаціоналізовані доменні імена в програмах"

#: ../../library/codecs.rst:1476
msgid ""
"This module implements :rfc:`3490` (Internationalized Domain Names in "
"Applications) and :rfc:`3492` (Nameprep: A Stringprep Profile for "
"Internationalized Domain Names (IDN)). It builds upon the ``punycode`` "
"encoding and :mod:`stringprep`."
msgstr ""
"Цей модуль реалізує :rfc:`3490` (інтернаціоналізовані доменні імена в "
"програмах) і :rfc:`3492` (nameprep: профіль Stringprep для "
"інтернаціоналізованих доменних імен (IDN)). Він побудований на основі "
"кодування ``punycode`` і :mod:`stringprep`."

#: ../../library/codecs.rst:1481
msgid ""
"If you need the IDNA 2008 standard from :rfc:`5891` and :rfc:`5895`, use the "
"third-party `idna module <https://pypi.org/project/idna/>`_."
msgstr ""

#: ../../library/codecs.rst:1484
msgid ""
"These RFCs together define a protocol to support non-ASCII characters in "
"domain names. A domain name containing non-ASCII characters (such as ``www."
"Alliancefrançaise.nu``) is converted into an ASCII-compatible encoding (ACE, "
"such as ``www.xn--alliancefranaise-npb.nu``). The ACE form of the domain "
"name is then used in all places where arbitrary characters are not allowed "
"by the protocol, such as DNS queries, HTTP :mailheader:`Host` fields, and so "
"on. This conversion is carried out in the application; if possible invisible "
"to the user: The application should transparently convert Unicode domain "
"labels to IDNA on the wire, and convert back ACE labels to Unicode before "
"presenting them to the user."
msgstr ""
"Ці RFC разом визначають протокол для підтримки символів, відмінних від "
"ASCII, у доменних іменах. Доменне ім’я, що містить символи, відмінні від "
"ASCII (наприклад, ``www.Alliancefrançaise.nu``), перетворюється на ASCII-"
"сумісне кодування (ACE, наприклад ``www.xn--alliancefranaise-npb.nu``). "
"Форма ACE імені домену потім використовується в усіх місцях, де довільні "
"символи не дозволені протоколом, наприклад у запитах DNS, HTTP :mailheader:"
"`Host` тощо. Це перетворення здійснюється в додатку; якщо можливо, невидимі "
"для користувача: програма повинна прозоро перетворювати мітки домену Unicode "
"на IDNA на дроті та перетворювати мітки ACE назад у Unicode перед тим, як "
"представляти їх користувачеві."

#: ../../library/codecs.rst:1495
msgid ""
"Python supports this conversion in several ways:  the ``idna`` codec "
"performs conversion between Unicode and ACE, separating an input string into "
"labels based on the separator characters defined in :rfc:`section 3.1 of RFC "
"3490 <3490#section-3.1>` and converting each label to ACE as required, and "
"conversely separating an input byte string into labels based on the ``.`` "
"separator and converting any ACE labels found into unicode. Furthermore, "
"the :mod:`socket` module transparently converts Unicode host names to ACE, "
"so that applications need not be concerned about converting host names "
"themselves when they pass them to the socket module. On top of that, modules "
"that have host names as function parameters, such as :mod:`http.client` and :"
"mod:`ftplib`, accept Unicode host names (:mod:`http.client` then also "
"transparently sends an IDNA hostname in the :mailheader:`Host` field if it "
"sends that field at all)."
msgstr ""
"Python підтримує це перетворення декількома способами: кодек ``idna`` "
"виконує перетворення між Юнікодом і ACE, розділяючи вхідний рядок на мітки "
"на основі символів-роздільників, визначених у :rfc:`розділі 3.1 RFC 3490 "
"<3490#section-3.1>`, і перетворюючи кожну мітку до ACE за потреби, і "
"навпаки, розділяючи вхідний байтовий рядок на мітки на основі роздільника ``."
"`` і перетворюючи будь-які знайдені мітки ACE в Юнікод. Крім того, модуль :"
"mod:`socket` прозоро перетворює імена хостів Unicode на ACE, тому програмам "
"не потрібно турбуватися про перетворення самих імен хостів, коли вони "
"передають їх модулю сокетів. Крім того, модулі, які мають імена хостів як "
"параметри функцій, наприклад :mod:`http.client` і :mod:`ftplib`, приймають "
"імена хостів Unicode (:mod:`http.client` потім також прозоро надсилає IDNA "
"ім’я хоста в полі :mailheader:`Host`, якщо воно взагалі надсилає це поле)."

#: ../../library/codecs.rst:1508
msgid ""
"When receiving host names from the wire (such as in reverse name lookup), no "
"automatic conversion to Unicode is performed: applications wishing to "
"present such host names to the user should decode them to Unicode."
msgstr ""
"Під час отримання імен хостів із проводу (наприклад, під час зворотного "
"пошуку імен) автоматичне перетворення в Unicode не виконується: програми, "
"які бажають надати такі імена хостів користувачеві, повинні декодувати їх у "
"Unicode."

#: ../../library/codecs.rst:1512
msgid ""
"The module :mod:`encodings.idna` also implements the nameprep procedure, "
"which performs certain normalizations on host names, to achieve case-"
"insensitivity of international domain names, and to unify similar "
"characters. The nameprep functions can be used directly if desired."
msgstr ""
"Модуль :mod:`encodings.idna` також реалізує процедуру nameprep, яка виконує "
"певні нормалізації імен хостів, щоб досягти нечутливості до регістру "
"міжнародних доменних імен і уніфікувати схожі символи. За бажанням можна "
"безпосередньо використовувати функції nameprep."

#: ../../library/codecs.rst:1520
msgid ""
"Return the nameprepped version of *label*. The implementation currently "
"assumes query strings, so ``AllowUnassigned`` is true."
msgstr ""
"Повертає запрограмовану версію *мітки*. Реалізація наразі передбачає рядки "
"запиту, тому ``AllowUnassigned`` є істинним."

#: ../../library/codecs.rst:1526
msgid ""
"Convert a label to ASCII, as specified in :rfc:`3490`. ``UseSTD3ASCIIRules`` "
"is assumed to be false."
msgstr ""
"Перетворіть мітку на ASCII, як зазначено в :rfc:`3490`. "
"``UseSTD3ASCIIRules`` вважається false."

#: ../../library/codecs.rst:1532
msgid "Convert a label to Unicode, as specified in :rfc:`3490`."
msgstr "Перетворіть мітку в Unicode, як зазначено в :rfc:`3490`."

#: ../../library/codecs.rst:1536
msgid ":mod:`encodings.mbcs` --- Windows ANSI codepage"
msgstr ":mod:`encodings.mbcs` --- кодова сторінка Windows ANSI"

#: ../../library/codecs.rst:1541
msgid "This module implements the ANSI codepage (CP_ACP)."
msgstr "Цей модуль реалізує кодову сторінку ANSI (CP_ACP)."

#: ../../library/codecs.rst:1543
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Availability <availability>`: Windows."

#: ../../library/codecs.rst:1545
msgid ""
"Before 3.2, the *errors* argument was ignored; ``'replace'`` was always used "
"to encode, and ``'ignore'`` to decode."
msgstr ""
"До версії 3.2 аргумент *errors* ігнорувався; ``'replace'`` завжди "
"використовувався для кодування, а ``'ignore''`` для декодування."

#: ../../library/codecs.rst:1549
msgid "Support any error handler."
msgstr "Підтримка будь-якого засобу обробки помилок."

#: ../../library/codecs.rst:1554
msgid ":mod:`encodings.utf_8_sig` --- UTF-8 codec with BOM signature"
msgstr ":mod:`encodings.utf_8_sig` --- кодек UTF-8 із підписом BOM"

#: ../../library/codecs.rst:1560
msgid ""
"This module implements a variant of the UTF-8 codec. On encoding, a UTF-8 "
"encoded BOM will be prepended to the UTF-8 encoded bytes. For the stateful "
"encoder this is only done once (on the first write to the byte stream). On "
"decoding, an optional UTF-8 encoded BOM at the start of the data will be "
"skipped."
msgstr ""
"Цей модуль реалізує варіант кодека UTF-8. Під час кодування BOM у кодуванні "
"UTF-8 буде додано до байтів у кодуванні UTF-8. Для кодувальника зі "
"збереженням стану це робиться лише один раз (під час першого запису в потік "
"байтів). Під час декодування додаткова специфікація даних у кодуванні UTF-8 "
"на початку даних буде пропущена."

#: ../../library/codecs.rst:13
msgid "Unicode"
msgstr "Unicode"

#: ../../library/codecs.rst:13
msgid "encode"
msgstr "кодувати"

#: ../../library/codecs.rst:13
msgid "decode"
msgstr "декодувати"

#: ../../library/codecs.rst:13
msgid "streams"
msgstr "streams"

#: ../../library/codecs.rst:13
msgid "stackable"
msgstr "stackable"

#: ../../library/codecs.rst:312
msgid "strict"
msgstr "strict"

#: ../../library/codecs.rst:312 ../../library/codecs.rst:364
#: ../../library/codecs.rst:387
msgid "error handler's name"
msgstr "имя обработчика ошибок"

#: ../../library/codecs.rst:312
msgid "ignore"
msgstr "ignore"

#: ../../library/codecs.rst:312
msgid "replace"
msgstr "replace"

#: ../../library/codecs.rst:312
msgid "backslashreplace"
msgstr "backslashreplace"

#: ../../library/codecs.rst:312
msgid "surrogateescape"
msgstr "surrogateescape"

#: ../../library/codecs.rst:312
msgid "? (question mark)"
msgstr "? (interrogação)"

#: ../../library/codecs.rst:312
msgid "replacement character"
msgstr "заменяющий символ"

#: ../../library/codecs.rst:312
msgid "\\ (backslash)"
msgstr "\\ (contrabarra)"

#: ../../library/codecs.rst:312 ../../library/codecs.rst:364
msgid "escape sequence"
msgstr "sequência de escape"

#: ../../library/codecs.rst:312
msgid "\\x"
msgstr "\\x"

#: ../../library/codecs.rst:312
msgid "\\u"
msgstr "\\u"

#: ../../library/codecs.rst:312
msgid "\\U"
msgstr "\\U"

#: ../../library/codecs.rst:364
msgid "xmlcharrefreplace"
msgstr "xmlcharrefreplace"

#: ../../library/codecs.rst:364
msgid "namereplace"
msgstr "namereplace"

#: ../../library/codecs.rst:387
msgid "surrogatepass"
msgstr "surrogatepass"

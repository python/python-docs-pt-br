# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-09 14:13+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/json.rst:2
msgid ":mod:`!json` --- JSON encoder and decoder"
msgstr ":mod:`!json` --- Codificador e decodificador JSON"

#: ../../library/json.rst:10
msgid "**Source code:** :source:`Lib/json/__init__.py`"
msgstr "**Código-fonte:** :source:`Lib/json/__init__.py`"

#: ../../library/json.rst:14
msgid ""
"`JSON (JavaScript Object Notation) <https://json.org>`_, specified by :rfc:"
"`7159` (which obsoletes :rfc:`4627`) and by `ECMA-404 <https://ecma-"
"international.org/publications-and-standards/standards/ecma-404/>`_, is a "
"lightweight data interchange format inspired by `JavaScript <https://en."
"wikipedia.org/wiki/JavaScript>`_ object literal syntax (although it is not a "
"strict subset of JavaScript [#rfc-errata]_ )."
msgstr ""
"`JSON (JavaScript Object Notation) <https://json.org>`_, especificado pelo :"
"rfc:`7159` (que tornou o :rfc:`4627` obsoleta) e pelo `ECMA-404 <https://"
"ecma-international.org/publications-and-standards/standards/ecma-404/>`_, é "
"um formato leve de troca de dados inspirado pela sintaxe de objeto "
"`JavaScript <https://en.wikipedia.org/wiki/JavaScript>`_ (embora não seja um "
"subconjunto estrito de JavaScript [#rfc-errata]_)."

#: ../../library/json.rst:22
msgid ""
"The term \"object\" in the context of JSON processing in Python can be "
"ambiguous. All values in Python are objects. In JSON, an object refers to "
"any data wrapped in curly braces, similar to a Python dictionary."
msgstr ""
"O termo \"objeto\" no contexto do processamento JSON em Python pode ser "
"ambíguo. Todos os valores em Python são objetos. Em JSON, um objeto se "
"refere a qualquer dado entre chaves, semelhante a um dicionário Python."

#: ../../library/json.rst:27
msgid ""
"Be cautious when parsing JSON data from untrusted sources. A malicious JSON "
"string may cause the decoder to consume considerable CPU and memory "
"resources. Limiting the size of data to be parsed is recommended."
msgstr ""
"Tenha cuidado quando estiver analisando dados JSON de fontes não-confiáveis. "
"Uma string JSON maliciosa pode fazer o decodificador consumir recursos "
"consideráveis de CPU e memória. É recomendado limitar o tamanho do dado a "
"ser analisado."

#: ../../library/json.rst:31
msgid ""
"This module exposes an API familiar to users of the standard library :mod:"
"`marshal` and :mod:`pickle` modules."
msgstr ""
"Este módulo expõe uma API familiar para pessoas usuárias dos módulos :mod:"
"`marshal` e :mod:`pickle` da biblioteca padrão."

#: ../../library/json.rst:34
msgid "Encoding basic Python object hierarchies::"
msgstr "Codificação de hierarquias básicas de objetos Python::"

#: ../../library/json.rst:36
msgid ""
">>> import json\n"
">>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])\n"
"'[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n"
">>> print(json.dumps(\"\\\"foo\\bar\"))\n"
"\"\\\"foo\\bar\"\n"
">>> print(json.dumps('\\u1234'))\n"
"\"\\u1234\"\n"
">>> print(json.dumps('\\\\'))\n"
"\"\\\\\"\n"
">>> print(json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True))\n"
"{\"a\": 0, \"b\": 0, \"c\": 0}\n"
">>> from io import StringIO\n"
">>> io = StringIO()\n"
">>> json.dump(['streaming API'], io)\n"
">>> io.getvalue()\n"
"'[\"streaming API\"]'"
msgstr ""
">>> import json\n"
">>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])\n"
"'[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n"
">>> print(json.dumps(\"\\\"foo\\bar\"))\n"
"\"\\\"foo\\bar\"\n"
">>> print(json.dumps('\\u1234'))\n"
"\"\\u1234\"\n"
">>> print(json.dumps('\\\\'))\n"
"\"\\\\\"\n"
">>> print(json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True))\n"
"{\"a\": 0, \"b\": 0, \"c\": 0}\n"
">>> from io import StringIO\n"
">>> io = StringIO()\n"
">>> json.dump(['streaming API'], io)\n"
">>> io.getvalue()\n"
"'[\"streaming API\"]'"

#: ../../library/json.rst:53
msgid "Compact encoding::"
msgstr "Codificação compacta::"

#: ../../library/json.rst:55
msgid ""
">>> import json\n"
">>> json.dumps([1, 2, 3, {'4': 5, '6': 7}], separators=(',', ':'))\n"
"'[1,2,3,{\"4\":5,\"6\":7}]'"
msgstr ""
">>> import json\n"
">>> json.dumps([1, 2, 3, {'4': 5, '6': 7}], separators=(',', ':'))\n"
"'[1,2,3,{\"4\":5,\"6\":7}]'"

#: ../../library/json.rst:59
msgid "Pretty printing::"
msgstr "Saída bonita::"

#: ../../library/json.rst:61
msgid ""
">>> import json\n"
">>> print(json.dumps({'6': 7, '4': 5}, sort_keys=True, indent=4))\n"
"{\n"
"    \"4\": 5,\n"
"    \"6\": 7\n"
"}"
msgstr ""
">>> import json\n"
">>> print(json.dumps({'6': 7, '4': 5}, sort_keys=True, indent=4))\n"
"{\n"
"    \"4\": 5,\n"
"    \"6\": 7\n"
"}"

#: ../../library/json.rst:68
msgid "Customizing JSON object encoding::"
msgstr "Personalizando em codificação de objeto JSON::"

#: ../../library/json.rst:70
msgid ""
">>> import json\n"
">>> def custom_json(obj):\n"
"...     if isinstance(obj, complex):\n"
"...         return {'__complex__': True, 'real': obj.real, 'imag': obj."
"imag}\n"
"...     raise TypeError(f'Cannot serialize object of {type(obj)}')\n"
"...\n"
">>> json.dumps(1 + 2j, default=custom_json)\n"
"'{\"__complex__\": true, \"real\": 1.0, \"imag\": 2.0}'"
msgstr ""
">>> import json\n"
">>> def custom_json(obj):\n"
"...     if isinstance(obj, complex):\n"
"...         return {'__complex__': True, 'real': obj.real, 'imag': obj."
"imag}\n"
"...     raise TypeError(f'Cannot serialize object of {type(obj)}')\n"
"...\n"
">>> json.dumps(1 + 2j, default=custom_json)\n"
"'{\"__complex__\": true, \"real\": 1.0, \"imag\": 2.0}'"

#: ../../library/json.rst:79
msgid "Decoding JSON::"
msgstr "Decodificando JSON::"

#: ../../library/json.rst:81
msgid ""
">>> import json\n"
">>> json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]')\n"
"['foo', {'bar': ['baz', None, 1.0, 2]}]\n"
">>> json.loads('\"\\\\\"foo\\\\bar\"')\n"
"'\"foo\\x08ar'\n"
">>> from io import StringIO\n"
">>> io = StringIO('[\"streaming API\"]')\n"
">>> json.load(io)\n"
"['streaming API']"
msgstr ""
">>> import json\n"
">>> json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]')\n"
"['foo', {'bar': ['baz', None, 1.0, 2]}]\n"
">>> json.loads('\"\\\\\"foo\\\\bar\"')\n"
"'\"foo\\x08ar'\n"
">>> from io import StringIO\n"
">>> io = StringIO('[\"streaming API\"]')\n"
">>> json.load(io)\n"
"['streaming API']"

#: ../../library/json.rst:91
msgid "Customizing JSON object decoding::"
msgstr "Personalizando em decodificação de objeto JSON::"

#: ../../library/json.rst:93
msgid ""
">>> import json\n"
">>> def as_complex(dct):\n"
"...     if '__complex__' in dct:\n"
"...         return complex(dct['real'], dct['imag'])\n"
"...     return dct\n"
"...\n"
">>> json.loads('{\"__complex__\": true, \"real\": 1, \"imag\": 2}',\n"
"...     object_hook=as_complex)\n"
"(1+2j)\n"
">>> import decimal\n"
">>> json.loads('1.1', parse_float=decimal.Decimal)\n"
"Decimal('1.1')"
msgstr ""
">>> import json\n"
">>> def as_complex(dct):\n"
"...     if '__complex__' in dct:\n"
"...         return complex(dct['real'], dct['imag'])\n"
"...     return dct\n"
"...\n"
">>> json.loads('{\"__complex__\": true, \"real\": 1, \"imag\": 2}',\n"
"...     object_hook=as_complex)\n"
"(1+2j)\n"
">>> import decimal\n"
">>> json.loads('1.1', parse_float=decimal.Decimal)\n"
"Decimal('1.1')"

#: ../../library/json.rst:106
msgid "Extending :class:`JSONEncoder`::"
msgstr "Estendendo :class:`JSONEncoder`::"

#: ../../library/json.rst:108
msgid ""
">>> import json\n"
">>> class ComplexEncoder(json.JSONEncoder):\n"
"...     def default(self, obj):\n"
"...         if isinstance(obj, complex):\n"
"...             return [obj.real, obj.imag]\n"
"...         # Let the base class default method raise the TypeError\n"
"...         return super().default(obj)\n"
"...\n"
">>> json.dumps(2 + 1j, cls=ComplexEncoder)\n"
"'[2.0, 1.0]'\n"
">>> ComplexEncoder().encode(2 + 1j)\n"
"'[2.0, 1.0]'\n"
">>> list(ComplexEncoder().iterencode(2 + 1j))\n"
"['[2.0', ', 1.0', ']']"
msgstr ""
">>> import json\n"
">>> class ComplexEncoder(json.JSONEncoder):\n"
"...     def default(self, obj):\n"
"...         if isinstance(obj, complex):\n"
"...             return [obj.real, obj.imag]\n"
"...         # Let the base class default method raise the TypeError\n"
"...         return super().default(obj)\n"
"...\n"
">>> json.dumps(2 + 1j, cls=ComplexEncoder)\n"
"'[2.0, 1.0]'\n"
">>> ComplexEncoder().encode(2 + 1j)\n"
"'[2.0, 1.0]'\n"
">>> list(ComplexEncoder().iterencode(2 + 1j))\n"
"['[2.0', ', 1.0', ']']"

#: ../../library/json.rst:124
msgid "Using :mod:`json` from the shell to validate and pretty-print:"
msgstr ""
"Usando :mod:`json` para validar a partir do console e exibir formatado:"

#: ../../library/json.rst:126
msgid ""
"$ echo '{\"json\":\"obj\"}' | python -m json\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"
msgstr ""
"$ echo '{\"json\":\"obj\"}' | python -m json\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"

#: ../../library/json.rst:135
msgid "See :ref:`json-commandline` for detailed documentation."
msgstr "Veja :ref:`json-commandline` para a documentação detalhada."

#: ../../library/json.rst:139
msgid ""
"JSON is a subset of `YAML <https://yaml.org/>`_ 1.2.  The JSON produced by "
"this module's default settings (in particular, the default *separators* "
"value) is also a subset of YAML 1.0 and 1.1.  This module can thus also be "
"used as a YAML serializer."
msgstr ""
"JSON é um subconjunto do `YAML <https://yaml.org/>`_ 1.2. O JSON gerado "
"pelas definições padrões desse módulo (particularmente, o valor padrão dos "
"*separadores*) é também um subconjunto do YAML 1.0 e 1.1. Esse módulo pode, "
"portanto, também ser usado como serializador YAML."

#: ../../library/json.rst:146
msgid ""
"This module's encoders and decoders preserve input and output order by "
"default.  Order is only lost if the underlying containers are unordered."
msgstr ""
"O codificador e o decodificador do módulo preservam a ordem de entrada e "
"saída por padrão. A ordem só é perdida se os contêineres subjacentes estão "
"desordenados."

#: ../../library/json.rst:151
msgid "Basic Usage"
msgstr "Uso básico"

#: ../../library/json.rst:158
msgid ""
"Serialize *obj* as a JSON formatted stream to *fp* (a ``.write()``-"
"supporting :term:`file-like object`) using this :ref:`Python-to-JSON "
"conversion table <py-to-json-table>`."
msgstr ""
"Serializa um *obj* como um stream JSON formatado para *fp* (um :term:`objeto "
"arquivo ou similar` com suporte a ``.write()``) usando essa :ref:`tabela de "
"conversão de Python para JSON <py-to-json-table>`."

#: ../../library/json.rst:164
msgid ""
"Unlike :mod:`pickle` and :mod:`marshal`, JSON is not a framed protocol, so "
"trying to serialize multiple objects with repeated calls to :func:`dump` "
"using the same *fp* will result in an invalid JSON file."
msgstr ""
"Diferente de :mod:`pickle` e :mod:`marshal`, JSON não é um protocolo com "
"datagrama, assim tentar serializar múltiplos objetos com chamadas repetidas "
"para :func:`dump` usando o mesmo *fp* resultará em um arquivo JSON inválido."

#: ../../library/json.rst:0
msgid "Parameters"
msgstr "Parâmetros"

#: ../../library/json.rst:168
msgid "The Python object to be serialized."
msgstr "O objeto Python a ser serializado."

#: ../../library/json.rst:171
msgid ""
"The file-like object *obj* will be serialized to. The :mod:`!json` module "
"always produces :class:`str` objects, not :class:`bytes` objects, therefore "
"``fp.write()`` must support :class:`str` input."
msgstr ""
"O objeto arquivo ou similar *obj* para o qual será serializado. O módulo :"
"mod:`!json` sempre produz objetos :class:`str`, e não objetos :class:"
"`bytes`. Dessa forma, ``fp.write()`` precisa ter suporte para entradas :"
"class:`str`."

#: ../../library/json.rst:178
msgid ""
"If ``True``, keys that are not of a basic type (:class:`str`, :class:`int`, :"
"class:`float`, :class:`bool`, ``None``) will be skipped instead of raising "
"a :exc:`TypeError`. Default ``False``."
msgstr ""
"Se ``True``, as chaves que não forem de um tipo básico (:class:`str`, :class:"
"`int`, :class:`float`, :class:`bool`, ``None``) serão ignoradas ao invés de "
"levantar uma exceção :exc:`TypeError`. Padrão ``False``."

#: ../../library/json.rst:184
msgid ""
"If ``True`` (the default), the output is guaranteed to have all incoming non-"
"ASCII and non-printable characters escaped. If ``False``, all characters "
"will be outputted as-is, except for the characters that must be escaped: "
"quotation mark, reverse solidus, and the control characters U+0000 through "
"U+001F."
msgstr ""

#: ../../library/json.rst:191
msgid ""
"If ``False``, the circular reference check for container types is skipped "
"and a circular reference will result in a :exc:`RecursionError` (or worse). "
"Default ``True``."
msgstr ""
"Se ``False``, a verificação de referência circular for de tipos contêineres "
"é ignorada e uma referência circular resultará em uma exceção :exc:"
"`RecursionError` (ou pior). Padrão ``True``."

#: ../../library/json.rst:196
msgid ""
"If ``False``, serialization of out-of-range :class:`float` values (``nan``, "
"``inf``, ``-inf``) will result in a :exc:`ValueError`, in strict compliance "
"with the JSON specification. If ``True`` (the default), their JavaScript "
"equivalents (``NaN``, ``Infinity``, ``-Infinity``) are used."
msgstr ""
"Se ``False``, serialização de valores :class:`float` fora de intervalo "
"(``nan``, ``inf``, ``-inf``) vai resultar em um :exc:`ValueError` em estrita "
"conformidade com a especificação. Se ``True`` (o padrão), seus equivalentes "
"JavaScript (``NaN``, ``Infinity``, ``-Infinity``) serão usados."

#: ../../library/json.rst:203
msgid ""
"If set, a custom JSON encoder with the :meth:`~JSONEncoder.default` method "
"overridden, for serializing into custom datatypes. If ``None`` (the "
"default), :class:`!JSONEncoder` is used."
msgstr ""
"Se definido, um codificador JSON personalizado com o método :meth:"
"`~JSONEncoder.default` substituído, para serializar em tipos de dados "
"personalizados. Se ``None`` (o padrão), :class:`!JSONEncoder` é usado."

#: ../../library/json.rst:210
msgid ""
"If a positive integer or string, JSON array elements and object members will "
"be pretty-printed with that indent level. A positive integer indents that "
"many spaces per level; a string (such as ``\"\\t\"``) is used to indent each "
"level. If zero, negative, or ``\"\"`` (the empty string), only newlines are "
"inserted. If ``None`` (the default), the most compact representation is used."
msgstr ""
"Se for um inteiro positivo ou uma string, os elementos da vetores JSON e os "
"membros do objeto serão impressos de forma bonita com esse nível de "
"indentação. Um inteiro positivo recua essa quantidade de espaços por nível; "
"uma string (como ``\"\\t\"``) é usada para indentar cada nível. Se for zero, "
"negativo ou ``\"\"`` (a string vazia), somente novas linhas serão inseridas. "
"Se for ``None`` (o padrão), a representação mais compacta será usada."

#: ../../library/json.rst:220
msgid ""
"A two-tuple: ``(item_separator, key_separator)``. If ``None`` (the default), "
"*separators* defaults to ``(', ', ': ')`` if *indent* is ``None``, and "
"``(',', ': ')`` otherwise. For the most compact JSON, specify ``(',', ':')`` "
"to eliminate whitespace."
msgstr ""
"Uma tupla dupla: ``(item_separator, key_separator)``. Se ``None`` (o "
"padrão), *separators* assume como padrão ``(', ', ': ')`` se *indent* for "
"``None``, e ``(',', ': ')`` caso contrário. Para o JSON mais compacto, "
"especifique ``(',', ':')`` para eliminar espaços em branco."

#: ../../library/json.rst:229
msgid ""
"A function that is called for objects that can't otherwise be serialized. It "
"should return a JSON encodable version of the object or raise a :exc:"
"`TypeError`. If ``None`` (the default), :exc:`!TypeError` is raised."
msgstr ""
"Uma função que é chamada para objetos que não podem ser serializados de "
"outra forma. Ela deve retornar uma versão JSON codificável do objeto ou "
"gerar um :exc:`TypeError`. Se ``None`` (o padrão), :exc:`!TypeError` é "
"levantada."

#: ../../library/json.rst:236
msgid ""
"If ``True``, dictionaries will be outputted sorted by key. Default ``False``."
msgstr ""
"Se ``True``, os dicionários serão emitidos classificados por chave. Padrão "
"``False``."

#: ../../library/json.rst:240 ../../library/json.rst:527
msgid "Allow strings for *indent* in addition to integers."
msgstr "Permite strings para *indent*, além de inteiros."

#: ../../library/json.rst:243 ../../library/json.rst:535
msgid "Use ``(',', ': ')`` as default if *indent* is not ``None``."
msgstr "Usa ``(',', ': ')`` como padrão se *indent* não for ``None``."

#: ../../library/json.rst:246 ../../library/json.rst:345
msgid ""
"All optional parameters are now :ref:`keyword-only <keyword-only_parameter>`."
msgstr ""
"Todos os parâmetros opcionais agora são :ref:`somente-nomeados <keyword-"
"only_parameter>`."

#: ../../library/json.rst:255
msgid ""
"Serialize *obj* to a JSON formatted :class:`str` using this :ref:`conversion "
"table <py-to-json-table>`.  The arguments have the same meaning as in :func:"
"`dump`."
msgstr ""
"Serializa *obj* para uma :class:`str` com formato JSON usando essa :ref:"
"`tabela de conversão <py-to-json-table>`. Os argumentos têm o mesmo "
"significado que na função :func:`dump`."

#: ../../library/json.rst:261
msgid ""
"Keys in key/value pairs of JSON are always of the type :class:`str`. When a "
"dictionary is converted into JSON, all the keys of the dictionary are "
"coerced to strings. As a result of this, if a dictionary is converted into "
"JSON and then back into a dictionary, the dictionary may not equal the "
"original one. That is, ``loads(dumps(x)) != x`` if x has non-string keys."
msgstr ""
"Chaves nos pares chave/valor de JSON são sempre do tipo :class:`str`. Quando "
"um dicionário é convertido para JSON, todas as chaves são convertidas para "
"strings. Como resultado disso, se um dicionário é convertido para JSON e "
"depois de volta para um dicionário, o dicionário pode não ser igual ao "
"original. Isto é, ``loads(dumps(x)) != x`` se x tem chaves não strings."

#: ../../library/json.rst:272
msgid ""
"Deserialize *fp* to a Python object using the :ref:`JSON-to-Python "
"conversion table <json-to-py-table>`."
msgstr ""
"Desserializa *fp* para um objeto Python usando a :ref:`tabela de conversão "
"JSON para Python <json-to-py-table>`."

#: ../../library/json.rst:275
msgid ""
"A ``.read()``-supporting :term:`text file` or :term:`binary file` containing "
"the JSON document to be deserialized."
msgstr ""
"Um :term:`arquivo texto` ou :term:`arquivo binário` com suporte a ``."
"read()`` contendo o documento JSON a ser desserializado."

#: ../../library/json.rst:280
msgid ""
"If set, a custom JSON decoder. Additional keyword arguments to :func:`!load` "
"will be passed to the constructor of *cls*. If ``None`` (the default), :"
"class:`!JSONDecoder` is used."
msgstr ""
"Se definido, um decodificador JSON personalizado. Argumentos nomeados "
"adicionais para :func:`!load` serão passados para o construtor de *cls*. Se "
"``None`` (o padrão), :class:`!JSONDecoder` é usado."

#: ../../library/json.rst:287
msgid ""
"If set, a function that is called with the result of any JSON object literal "
"decoded (a :class:`dict`). The return value of this function will be used "
"instead of the :class:`dict`. This feature can be used to implement custom "
"decoders, for example `JSON-RPC <https://www.jsonrpc.org>`_ class hinting. "
"Default ``None``."
msgstr ""
"Se definido, uma função que é chamada com o resultado de qualquer literal de "
"objeto JSON decodificado (um :class:`dict`). O valor de retorno desta função "
"será usado em vez do :class:`dict`. Este recurso pode ser usado para "
"implementar decodificadores personalizados, por exemplo dica de classes "
"`JSON-RPC <https://www.jsonrpc.org>`_. O padrão é ``None``."

#: ../../library/json.rst:297
msgid ""
"If set, a function that is called with the result of any JSON object literal "
"decoded with an ordered list of pairs. The return value of this function "
"will be used instead of the :class:`dict`. This feature can be used to "
"implement custom decoders. If *object_hook* is also set, *object_pairs_hook* "
"takes priority. Default ``None``."
msgstr ""
"Se definido, uma função que é chamada com o resultado de qualquer literal de "
"objeto JSON decodificado com uma lista ordenada de pares. O valor de retorno "
"desta função será usado em vez de :class:`dict`. Este recurso pode ser usado "
"para implementar decodificadores personalizados. Se *object_hook* também for "
"definido, *object_pairs_hook* terá prioridade. O padrão é ``None``."

#: ../../library/json.rst:307
msgid ""
"If set, a function that is called with the string of every JSON float to be "
"decoded. If ``None`` (the default), it is equivalent to ``float(num_str)``. "
"This can be used to parse JSON floats into custom datatypes, for example :"
"class:`decimal.Decimal`."
msgstr ""
"Se definido, uma função que é chamada com a string de cada ponto flutuante "
"JSON a ser decodificada. Se ``None`` (o padrão), é equivalente a "
"``float(num_str)``. Isso pode ser usado para analisar pontos flutuantes JSON "
"em tipos de dados personalizados, por exemplo :class:`decimal.Decimal`."

#: ../../library/json.rst:315
msgid ""
"If set, a function that is called with the string of every JSON int to be "
"decoded. If ``None`` (the default), it is equivalent to ``int(num_str)``. "
"This can be used to parse JSON integers into custom datatypes, for example :"
"class:`float`."
msgstr ""
"Se definido, uma função que é chamada com a string de cada int JSON a ser "
"decodificado. Se ``None`` (o padrão), é equivalente a ``int(num_str)``. Isso "
"pode ser usado para analisar inteiros JSON em tipos de dados personalizados, "
"por exemplo :class:`float`."

#: ../../library/json.rst:323
msgid ""
"If set, a function that is called with one of the following strings: ``'-"
"Infinity'``, ``'Infinity'``, or ``'NaN'``. This can be used to raise an "
"exception if invalid JSON numbers are encountered. Default ``None``."
msgstr ""
"Se definido, uma função que é chamada com uma das seguintes strings: ``'-"
"Infinity'``, ``'Infinity'`` ou ``'NaN'``. Isso pode ser usado para levantar "
"uma exceção se números JSON inválidos forem encontrados. Padrão ``None``."

#: ../../library/json.rst:0
msgid "Raises"
msgstr "Levanta"

#: ../../library/json.rst:331
msgid "When the data being deserialized is not a valid JSON document."
msgstr ""
"Quando os dados a serem desserializados não forem um documento JSON válido."

#: ../../library/json.rst:334
msgid ""
"When the data being deserialized does not contain UTF-8, UTF-16 or UTF-32 "
"encoded data."
msgstr ""
"Quando os dados que estão sendo desserializados não contêm dados codificados "
"em UTF-8, UTF-16 ou UTF-32."

#: ../../library/json.rst:340
msgid "Added the optional *object_pairs_hook* parameter."
msgstr "Adicionado o parâmetro opcional *object_pairs_hook*."

#: ../../library/json.rst:341
msgid "*parse_constant* doesn't get called on 'null', 'true', 'false' anymore."
msgstr "*parse_constant* não é mais chamada para 'null', 'true', 'false'."

#: ../../library/json.rst:346
msgid ""
"*fp* can now be a :term:`binary file`. The input encoding should be UTF-8, "
"UTF-16 or UTF-32."
msgstr ""
"*fp* agora pode ser um :term:`arquivo binário <binary file>`. A entrada deve "
"estar codificada como UTF-8, UTF-16 ou UTF-32."

#: ../../library/json.rst:349
msgid ""
"The default *parse_int* of :func:`int` now limits the maximum length of the "
"integer string via the interpreter's :ref:`integer string conversion length "
"limitation <int_max_str_digits>` to help avoid denial of service attacks."
msgstr ""
"O *parse_int* padrão para  :func:`int` agora limita o tamanho máximo da "
"string de inteiro via :ref:`limitação de comprimento de string na conversão "
"para inteiro <int_max_str_digits>` do interpretador para ajudar a evitar "
"ataques por negação de serviço."

#: ../../library/json.rst:357
msgid ""
"Identical to :func:`load`, but instead of a file-like object, deserialize "
"*s* (a :class:`str`, :class:`bytes` or :class:`bytearray` instance "
"containing a JSON document) to a Python object using this :ref:`conversion "
"table <json-to-py-table>`."
msgstr ""
"Idêntico a :func:`load`, mas em vez de um objeto arquivo ou similar, "
"desserializa *s* (uma instância de :class:`str`, :class:`bytes` ou :class:"
"`bytearray` contendo um documento JSON) para um objeto Python usando essa :"
"ref:`tabela de conversão <json-to-py-table>`."

#: ../../library/json.rst:362
msgid ""
"*s* can now be of type :class:`bytes` or :class:`bytearray`. The input "
"encoding should be UTF-8, UTF-16 or UTF-32."
msgstr ""
"*s* agora pode ser um do tipo :class:`bytes` ou :class:`bytearray`. A "
"entrada deve estar codificado como UTF-8, UTF-16 ou UTF-32."

#: ../../library/json.rst:366
msgid "The keyword argument *encoding* has been removed."
msgstr "O argumento nomeado *encoding* foi removido."

#: ../../library/json.rst:371
msgid "Encoders and Decoders"
msgstr "Codificadores e decodificadores"

#: ../../library/json.rst:375
msgid "Simple JSON decoder."
msgstr "Decodificador JSON simples."

#: ../../library/json.rst:377
msgid "Performs the following translations in decoding by default:"
msgstr "Executa as seguintes traduções na decodificação por padrão:"

#: ../../library/json.rst:382 ../../library/json.rst:470
msgid "JSON"
msgstr "JSON"

#: ../../library/json.rst:382 ../../library/json.rst:470
msgid "Python"
msgstr "Python"

#: ../../library/json.rst:384 ../../library/json.rst:472
msgid "object"
msgstr "objeto"

#: ../../library/json.rst:384 ../../library/json.rst:472
msgid "dict"
msgstr "dicionário"

#: ../../library/json.rst:386 ../../library/json.rst:474
msgid "array"
msgstr "array"

#: ../../library/json.rst:386
msgid "list"
msgstr "lista"

#: ../../library/json.rst:388 ../../library/json.rst:476
msgid "string"
msgstr "string"

#: ../../library/json.rst:388 ../../library/json.rst:476
msgid "str"
msgstr "str"

#: ../../library/json.rst:390
msgid "number (int)"
msgstr "número (inteiro)"

#: ../../library/json.rst:390
msgid "int"
msgstr "int"

#: ../../library/json.rst:392
msgid "number (real)"
msgstr "número (real)"

#: ../../library/json.rst:392
msgid "float"
msgstr "float"

#: ../../library/json.rst:394 ../../library/json.rst:480
msgid "true"
msgstr "verdadeiro"

#: ../../library/json.rst:394 ../../library/json.rst:480
msgid "True"
msgstr "True"

#: ../../library/json.rst:396 ../../library/json.rst:482
msgid "false"
msgstr "falso"

#: ../../library/json.rst:396 ../../library/json.rst:482
msgid "False"
msgstr "False"

#: ../../library/json.rst:398 ../../library/json.rst:484
msgid "null"
msgstr "nulo"

#: ../../library/json.rst:398 ../../library/json.rst:484
msgid "None"
msgstr "None"

#: ../../library/json.rst:401
msgid ""
"It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as their "
"corresponding ``float`` values, which is outside the JSON spec."
msgstr ""
"Ele também entende ``NaN``, ``Infinity`` e ``-Infinity`` como seus valores "
"``float`` correspondentes, que estão fora da especificação JSON."

#: ../../library/json.rst:404
msgid ""
"*object_hook* is an optional function that will be called with the result of "
"every JSON object decoded and its return value will be used in place of the "
"given :class:`dict`.  This can be used to provide custom deserializations (e."
"g. to support `JSON-RPC <https://www.jsonrpc.org>`_ class hinting)."
msgstr ""
"*object_hook* é uma função opcional que será chamada com o resultado de cada "
"objeto JSON decodificado e seu valor de retorno será usado no lugar do dado :"
"class:`dict`. Isso pode ser usado para fornecer desserializações "
"personalizadas (por exemplo, para oferecer suporte a dicas de classe `JSON-"
"RPC <https://www.jsonrpc.org>`_)"

#: ../../library/json.rst:409
msgid ""
"*object_pairs_hook* is an optional function that will be called with the "
"result of every JSON object decoded with an ordered list of pairs.  The "
"return value of *object_pairs_hook* will be used instead of the :class:"
"`dict`.  This feature can be used to implement custom decoders.  If "
"*object_hook* is also defined, the *object_pairs_hook* takes priority."
msgstr ""
"*object_pairs_hook* é uma função opcional que será chamada com o resultado "
"de todo objeto JSON decodificado com uma lista ordenada de pares. O valor de "
"retorno de *object_pairs_hook* será usado no lugar do :class:`dict`. Este "
"recurso pode ser usado para implementar decodificadores personalizados. Se "
"*object_pairs_hook* também for definido, o *object_pairs_hook* terá "
"prioridade."

#: ../../library/json.rst:415
msgid "Added support for *object_pairs_hook*."
msgstr "Adicionado suporte para *object_pairs_hook*."

#: ../../library/json.rst:418
msgid ""
"*parse_float* is an optional function that will be called with the string of "
"every JSON float to be decoded.  By default, this is equivalent to "
"``float(num_str)``.  This can be used to use another datatype or parser for "
"JSON floats (e.g. :class:`decimal.Decimal`)."
msgstr ""
"*parse_float* é uma função opcional que será chamada com a string de cada "
"ponto flutuante JSON para ser decodificado. Por padrão, equivale a "
"``float(num_str)``. Pode ser usado para qualquer outro tipo de dado ou "
"analisador de pontos flutuante JSON (por exemplo, :class:`decimal.Decimal`)."

#: ../../library/json.rst:423
msgid ""
"*parse_int* is an optional function that will be called with the string of "
"every JSON int to be decoded.  By default, this is equivalent to "
"``int(num_str)``.  This can be used to use another datatype or parser for "
"JSON integers (e.g. :class:`float`)."
msgstr ""
"*parse_int* é uma função opcional que será chamada com a string de cada "
"inteiro JSON para ser decodificado. Por padrão, equivale a ``int(num_str)``. "
"Pode ser usado para qualquer outro tipo de dado ou analisador de inteiros "
"JSON (por exemplo, :class:`float`)."

#: ../../library/json.rst:428
msgid ""
"*parse_constant* is an optional function that will be called with one of the "
"following strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  This can be "
"used to raise an exception if invalid JSON numbers are encountered."
msgstr ""
"*parse_constant* é uma função opcional que será chamada para cada um das "
"seguintes strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``. Isso pode ser "
"usado para levantar uma exceção se forem encontrados números JSON inválidos."

#: ../../library/json.rst:432
msgid ""
"If *strict* is false (``True`` is the default), then control characters will "
"be allowed inside strings.  Control characters in this context are those "
"with character codes in the 0--31 range, including ``'\\t'`` (tab), "
"``'\\n'``, ``'\\r'`` and ``'\\0'``."
msgstr ""
"Se *strict* for falso (``True`` é o padrão), os caracteres de controle serão "
"permitidos dentro das strings. Os caracteres de controle neste contexto são "
"aqueles com códigos de caracteres no intervalo 0--31, incluindo ``'\\t'`` "
"(tab), ``'\\n'``, ``'\\r'`` e ``'\\0'``."

#: ../../library/json.rst:437
msgid ""
"If the data being deserialized is not a valid JSON document, a :exc:"
"`JSONDecodeError` will be raised."
msgstr ""
"Se os dados a serem desserializados não forem um documento JSON válido, será "
"levantada uma exceção :exc:`JSONDecodeError`."

#: ../../library/json.rst:440 ../../library/json.rst:543
msgid "All parameters are now :ref:`keyword-only <keyword-only_parameter>`."
msgstr ""
"Todos os parâmetros agora são :ref:`somente-nomeado <keyword-"
"only_parameter>`."

#: ../../library/json.rst:445
msgid ""
"Return the Python representation of *s* (a :class:`str` instance containing "
"a JSON document)."
msgstr ""
"Retorna a representação Python de *s* (uma instância :class:`str` contendo "
"um documento JSON)."

#: ../../library/json.rst:448
msgid ""
":exc:`JSONDecodeError` will be raised if the given JSON document is not "
"valid."
msgstr ""
"Uma exceção :exc:`JSONDecodeError` será levantada se o documento JSON "
"fornecido não for válido."

#: ../../library/json.rst:453
msgid ""
"Decode a JSON document from *s* (a :class:`str` beginning with a JSON "
"document) and return a 2-tuple of the Python representation and the index in "
"*s* where the document ended."
msgstr ""
"Decodifica um documento JSON a partir de *s* (uma :class:`str` iniciando com "
"um documento JSON) e retornando uma tupla de 2 elementos, a representação "
"Python e o índice em *s* onde o documento finaliza."

#: ../../library/json.rst:457
msgid ""
"This can be used to decode a JSON document from a string that may have "
"extraneous data at the end."
msgstr ""
"Isso pode ser usado para decodificar um documento JSON a partir de uma "
"string que possa ter dados extras ao final."

#: ../../library/json.rst:463
msgid "Extensible JSON encoder for Python data structures."
msgstr "Codificador JSON extensível para estruturas de dados Python."

#: ../../library/json.rst:465
msgid "Supports the following objects and types by default:"
msgstr "Por padrão, possui suporte para os seguintes objetos e tipos:"

#: ../../library/json.rst:474
msgid "list, tuple"
msgstr "list, tuple"

#: ../../library/json.rst:478
msgid "int, float, int- & float-derived Enums"
msgstr "int, float e Enums derivados de int e float"

#: ../../library/json.rst:478
msgid "number"
msgstr "number"

#: ../../library/json.rst:487
msgid "Added support for int- and float-derived Enum classes."
msgstr "Adicionado suporte para classes Enum derivadas de int e float."

#: ../../library/json.rst:490
msgid ""
"To extend this to recognize other objects, subclass and implement a :meth:"
"`~JSONEncoder.default` method with another method that returns a "
"serializable object for ``o`` if possible, otherwise it should call the "
"superclass implementation (to raise :exc:`TypeError`)."
msgstr ""
"Para estender isso para reconhecer outros objetos, crie uma subclasse e "
"implemente o método :meth:`~JSONEncoder.default` com outro método que "
"retorne um objeto serializável para ``o`` se possível, caso contrário "
"deveria chamar a implementação da superclasse (para levantar :exc:"
"`TypeError`)."

#: ../../library/json.rst:495
msgid ""
"If *skipkeys* is false (the default), a :exc:`TypeError` will be raised when "
"trying to encode keys that are not :class:`str`, :class:`int`, :class:"
"`float`, :class:`bool` or ``None``.  If *skipkeys* is true, such items are "
"simply skipped."
msgstr ""
"Se *skipkeys* é falso (o padrão), então sluma :exc:`TypeError` será "
"levantada ao tentar codificar as chaves que não são :class:`str`, :class:"
"`int`, :class:`float`, :class:`bool` ou ``None``.  Se *skipkeys* é "
"verdadeiro, esses itens são simplesmente pulados."

#: ../../library/json.rst:499
msgid ""
"If *ensure_ascii* is true (the default), the output is guaranteed to have "
"all incoming non-ASCII and non-printable characters escaped. If "
"*ensure_ascii* is false, all characters will be output as-is, except for the "
"characters that must be escaped: quotation mark, reverse solidus, and the "
"control characters U+0000 through U+001F."
msgstr ""

#: ../../library/json.rst:505
msgid ""
"If *check_circular* is true (the default), then lists, dicts, and custom "
"encoded objects will be checked for circular references during encoding to "
"prevent an infinite recursion (which would cause a :exc:`RecursionError`). "
"Otherwise, no such check takes place."
msgstr ""
"Se *check_circular* é verdadeiro (o padrão), então listas, dicionários e "
"objetos codificados personalizados serão verificados por referências "
"circulares durante a codificação para prevenir uma recursão infinita (que "
"iria causar uma :exc:`RecursionError`). Caso contrário, nenhuma verificação "
"será feita."

#: ../../library/json.rst:510
msgid ""
"If *allow_nan* is true (the default), then ``NaN``, ``Infinity``, and ``-"
"Infinity`` will be encoded as such.  This behavior is not JSON specification "
"compliant, but is consistent with most JavaScript based encoders and "
"decoders.  Otherwise, it will be a :exc:`ValueError` to encode such floats."
msgstr ""
"Se *allow_nan* for verdadeiro (o padrão), então ``NaN``, ``Infinity``, e ``-"
"Infinity`` serão codificados como tal. Esse comportamento não é compatível "
"com a especificação do JSON, mas é consistente com a maioria dos "
"codificadores e decodificadores baseados em JavaScript. Caso contrário, será "
"levantada uma :exc:`ValueError` para tais pontos flutuantes."

#: ../../library/json.rst:516
msgid ""
"If *sort_keys* is true (default: ``False``), then the output of dictionaries "
"will be sorted by key; this is useful for regression tests to ensure that "
"JSON serializations can be compared on a day-to-day basis."
msgstr ""
"Se *sort_keys* for verdadeiro (padrão: ``False``), então a saída dos "
"dicionários serão ordenados pela chave; isto é útil para testes de regressão "
"para certificar-se que as serializações de JSON possam ser comparadas com "
"uma base no dia a dia."

#: ../../library/json.rst:520
msgid ""
"If *indent* is a non-negative integer or string, then JSON array elements "
"and object members will be pretty-printed with that indent level.  An indent "
"level of 0, negative, or ``\"\"`` will only insert newlines.  ``None`` (the "
"default) selects the most compact representation. Using a positive integer "
"indent indents that many spaces per level.  If *indent* is a string (such as "
"``\"\\t\"``), that string is used to indent each level."
msgstr ""
"Se *indent* for um inteiro não negativo ou uma string, então elementos de um "
"vetor JSON e membros de objetos terão uma saída formatada com este nível de "
"indentação. Um nível de indentação 0, negativo ou ``\"\"`` apenas colocará "
"novas linhas. ``None`` (o padrão) seleciona a representação mais compacta. "
"Usando um inteiro positivo a indentação terá alguns espaços por nível. Se "
"*indent* for uma string (como ``\"\\t\"``), essa string será usada para "
"indentar cada nível."

#: ../../library/json.rst:530
msgid ""
"If specified, *separators* should be an ``(item_separator, key_separator)`` "
"tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and ``(',', "
"': ')`` otherwise.  To get the most compact JSON representation, you should "
"specify ``(',', ':')`` to eliminate whitespace."
msgstr ""
"Se especificado, *separators* deve ser uma tupla ``(item_separator, "
"key_separator)``. O padrão é ``(', ', ': ')`` se *indent* for ``None`` e "
"``(',', ': ')`` caso contrário. Para pegar representação JSON mais compacta, "
"você deve especificar ``(',', ':')`` para eliminar espaços em branco."

#: ../../library/json.rst:538
msgid ""
"If specified, *default* should be a function that gets called for objects "
"that can't otherwise be serialized.  It should return a JSON encodable "
"version of the object or raise a :exc:`TypeError`.  If not specified, :exc:"
"`TypeError` is raised."
msgstr ""
"Se especificado, *default* deve ser uma função para ser chamada para objetos "
"que não podem ser serializados de outra forma. Deve retornar uma versão "
"codificável JSON do objeto ou levantar uma exceção :exc:`TypeError`. Se não "
"for especificada, :exc:`TypeError` é levantada."

#: ../../library/json.rst:549
msgid ""
"Implement this method in a subclass such that it returns a serializable "
"object for *o*, or calls the base implementation (to raise a :exc:"
"`TypeError`)."
msgstr ""
"Implemente este método em uma subclasse que retorna um objeto serializável "
"para *o* ou que chame a implementação base (para levantar uma :exc:"
"`TypeError`)."

#: ../../library/json.rst:553
msgid ""
"For example, to support arbitrary iterators, you could implement :meth:"
"`~JSONEncoder.default` like this::"
msgstr ""
"Por exemplo, para suporte a iteradores arbitrários, você poderia "
"implementar :meth:`~JSONEncoder.default` dessa forma::"

#: ../../library/json.rst:556
msgid ""
"def default(self, o):\n"
"   try:\n"
"       iterable = iter(o)\n"
"   except TypeError:\n"
"       pass\n"
"   else:\n"
"       return list(iterable)\n"
"   # Let the base class default method raise the TypeError\n"
"   return super().default(o)"
msgstr ""
"def default(self, o):\n"
"   try:\n"
"       iterable = iter(o)\n"
"   except TypeError:\n"
"       pass\n"
"   else:\n"
"       return list(iterable)\n"
"   # Faz o método padrão de classe base levantar a TypeError\n"
"   return super().default(o)"

#: ../../library/json.rst:569
msgid ""
"Return a JSON string representation of a Python data structure, *o*.  For "
"example::"
msgstr ""
"Retorna uma string representando um JSON a partir da estrutura de dados "
"Python, *o*. Por exemplo::"

#: ../../library/json.rst:572
msgid ""
">>> json.JSONEncoder().encode({\"foo\": [\"bar\", \"baz\"]})\n"
"'{\"foo\": [\"bar\", \"baz\"]}'"
msgstr ""
">>> json.JSONEncoder().encode({\"foo\": [\"bar\", \"baz\"]})\n"
"'{\"foo\": [\"bar\", \"baz\"]}'"

#: ../../library/json.rst:578
msgid ""
"Encode the given object, *o*, and yield each string representation as "
"available.  For example::"
msgstr ""
"Codifica o objeto dado, *o*, e produz cada representação em string assim que "
"disponível.  Por exemplo::"

#: ../../library/json.rst:581
msgid ""
"for chunk in json.JSONEncoder().iterencode(bigobject):\n"
"    mysocket.write(chunk)"
msgstr ""
"for chunk in json.JSONEncoder().iterencode(bigobject):\n"
"    mysocket.write(chunk)"

#: ../../library/json.rst:586
msgid "Exceptions"
msgstr "Exceções"

#: ../../library/json.rst:590
msgid "Subclass of :exc:`ValueError` with the following additional attributes:"
msgstr "Subclasse de :exc:`ValueError` com os seguintes atributos adicionais:"

#: ../../library/json.rst:594
msgid "The unformatted error message."
msgstr "A mensagem de erro não formatada."

#: ../../library/json.rst:598
msgid "The JSON document being parsed."
msgstr "O documento JSON sendo analisado."

#: ../../library/json.rst:602
msgid "The start index of *doc* where parsing failed."
msgstr "O índice inicial de *doc* em que a análise falhou."

#: ../../library/json.rst:606
msgid "The line corresponding to *pos*."
msgstr "A linha correspondente a *pos*."

#: ../../library/json.rst:610
msgid "The column corresponding to *pos*."
msgstr "A coluna correspondente a *pos*."

#: ../../library/json.rst:616
msgid "Standard Compliance and Interoperability"
msgstr "Conformidade e interoperabilidade entre padrões"

#: ../../library/json.rst:618
msgid ""
"The JSON format is specified by :rfc:`7159` and by `ECMA-404 <https://ecma-"
"international.org/publications-and-standards/standards/ecma-404/>`_. This "
"section details this module's level of compliance with the RFC. For "
"simplicity, :class:`JSONEncoder` and :class:`JSONDecoder` subclasses, and "
"parameters other than those explicitly mentioned, are not considered."
msgstr ""
"O formato JSON é especificado pela :rfc:`7159` e por `ECMA-404 <https://ecma-"
"international.org/publications-and-standards/standards/ecma-404/>`_. Esta "
"seção detalha o nível de conformidade deste módulo com a RFC. Para "
"simplificar, as subclasses :class:`JSONEncoder` e :class:`JSONDecoder`, e "
"outros parâmetros além daqueles explicitamente mencionados, não são "
"considerados."

#: ../../library/json.rst:624
msgid ""
"This module does not comply with the RFC in a strict fashion, implementing "
"some extensions that are valid JavaScript but not valid JSON.  In particular:"
msgstr ""
"Este módulo não está em conformidade com a RFC de forma estrita, "
"implementando algumas extensões que são JavaScript válidas, mas não JSON "
"válido. Em particular:"

#: ../../library/json.rst:627
msgid "Infinite and NaN number values are accepted and output;"
msgstr "Os valores de números infinitos e NaN são aceitos e produzidos;"

#: ../../library/json.rst:628
msgid ""
"Repeated names within an object are accepted, and only the value of the last "
"name-value pair is used."
msgstr ""
"Nomes repetidos em um objeto são aceitos e apenas o valor do último par nome-"
"valor é usado."

#: ../../library/json.rst:631
msgid ""
"Since the RFC permits RFC-compliant parsers to accept input texts that are "
"not RFC-compliant, this module's deserializer is technically RFC-compliant "
"under default settings."
msgstr ""
"Uma vez que a RFC permite que os analisadores compatíveis com a RFC aceitem "
"textos de entrada que não sejam compatíveis com a RFC, o desserializador "
"deste módulo é tecnicamente compatível com a RFC nas configurações padrão."

#: ../../library/json.rst:636
msgid "Character Encodings"
msgstr "Codificações de caracteres"

#: ../../library/json.rst:638
msgid ""
"The RFC requires that JSON be represented using either UTF-8, UTF-16, or "
"UTF-32, with UTF-8 being the recommended default for maximum "
"interoperability."
msgstr ""
"A RFC requer que JSON seja representado usando UTF-8, UTF-16 ou UTF-32, com "
"UTF-8 sendo o padrão recomendado para interoperabilidade máxima."

#: ../../library/json.rst:641
msgid ""
"As permitted, though not required, by the RFC, this module's serializer sets "
"*ensure_ascii=True* by default, thus escaping the output so that the "
"resulting strings only contain printable ASCII characters."
msgstr ""

#: ../../library/json.rst:645
msgid ""
"Other than the *ensure_ascii* parameter, this module is defined strictly in "
"terms of conversion between Python objects and :class:`Unicode strings "
"<str>`, and thus does not otherwise directly address the issue of character "
"encodings."
msgstr ""
"Além do parâmetro *ensure_ascii*, este módulo é definido estritamente em "
"termos de conversão entre objetos Python e :class:`strings Unicode <str>` e, "
"portanto, não aborda diretamente o problema de codificação de caracteres."

#: ../../library/json.rst:650
msgid ""
"The RFC prohibits adding a byte order mark (BOM) to the start of a JSON "
"text, and this module's serializer does not add a BOM to its output. The RFC "
"permits, but does not require, JSON deserializers to ignore an initial BOM "
"in their input.  This module's deserializer raises a :exc:`ValueError` when "
"an initial BOM is present."
msgstr ""
"A RFC proíbe adicionar uma marca de ordem de byte (do inglês *byte order "
"mark* - BOM) ao início de um texto JSON, e o serializador deste módulo não "
"adiciona um BOM à sua saída. A RFC permite, mas não exige, que os "
"desserializadores JSON ignorem um BOM inicial em sua entrada. O "
"desserializador deste módulo levanta uma :exc:`ValueError` quando um BOM "
"inicial está presente."

#: ../../library/json.rst:656
msgid ""
"The RFC does not explicitly forbid JSON strings which contain byte sequences "
"that don't correspond to valid Unicode characters (e.g. unpaired UTF-16 "
"surrogates), but it does note that they may cause interoperability problems. "
"By default, this module accepts and outputs (when present in the original :"
"class:`str`) code points for such sequences."
msgstr ""
"A RFC não proíbe explicitamente as strings JSON que contêm sequências de "
"bytes que não correspondem a caracteres Unicode válidos (por exemplo, "
"substitutos UTF-16 não emparelhados), mas observa que podem causar problemas "
"de interoperabilidade. Por padrão, este módulo aceita e produz (quando "
"presente no original :class:`str`) pontos de código para tais sequências."

#: ../../library/json.rst:664
msgid "Infinite and NaN Number Values"
msgstr "Valores numéricos infinitos e NaN"

#: ../../library/json.rst:666
msgid ""
"The RFC does not permit the representation of infinite or NaN number values. "
"Despite that, by default, this module accepts and outputs ``Infinity``, ``-"
"Infinity``, and ``NaN`` as if they were valid JSON number literal values::"
msgstr ""
"A RFC não permite a representação de valores infinitos ou numéricos NaN. "
"Apesar disso, por padrão, este módulo aceita e produz ``Infinity``, ``-"
"Infinity`` e ``NaN`` como se fossem valores literais de número JSON válidos::"

#: ../../library/json.rst:670
msgid ""
">>> # Neither of these calls raises an exception, but the results are not "
"valid JSON\n"
">>> json.dumps(float('-inf'))\n"
"'-Infinity'\n"
">>> json.dumps(float('nan'))\n"
"'NaN'\n"
">>> # Same when deserializing\n"
">>> json.loads('-Infinity')\n"
"-inf\n"
">>> json.loads('NaN')\n"
"nan"
msgstr ""
">>> # Nenhuma dessas chamadas levanta uma exceção, mas os resultados não são "
"JSON válidos\n"
">>> json.dumps(float('-inf'))\n"
"'-Infinity'\n"
">>> json.dumps(float('nan'))\n"
"'NaN'\n"
">>> # Same when deserializing\n"
">>> json.loads('-Infinity')\n"
"-inf\n"
">>> json.loads('NaN')\n"
"nan"

#: ../../library/json.rst:681
msgid ""
"In the serializer, the *allow_nan* parameter can be used to alter this "
"behavior.  In the deserializer, the *parse_constant* parameter can be used "
"to alter this behavior."
msgstr ""
"No serializador, o parâmetro *allow_nan* pode ser usado para alterar esse "
"comportamento. No desserializador, o parâmetro *parse_constant* pode ser "
"usado para alterar esse comportamento."

#: ../../library/json.rst:687
msgid "Repeated Names Within an Object"
msgstr "Nomes repetidos dentro de um objeto"

#: ../../library/json.rst:689
msgid ""
"The RFC specifies that the names within a JSON object should be unique, but "
"does not mandate how repeated names in JSON objects should be handled.  By "
"default, this module does not raise an exception; instead, it ignores all "
"but the last name-value pair for a given name::"
msgstr ""
"A RFC especifica que os nomes em um objeto JSON devem ser exclusivos, mas "
"não determina como os nomes repetidos em objetos JSON devem ser tratados. "
"Por padrão, este módulo não levanta uma exceção; em vez disso, ele ignora "
"tudo, exceto o último par nome-valor para um determinado nome::"

#: ../../library/json.rst:694
msgid ""
">>> weird_json = '{\"x\": 1, \"x\": 2, \"x\": 3}'\n"
">>> json.loads(weird_json)\n"
"{'x': 3}"
msgstr ""
">>> weird_json = '{\"x\": 1, \"x\": 2, \"x\": 3}'\n"
">>> json.loads(weird_json)\n"
"{'x': 3}"

#: ../../library/json.rst:698
msgid "The *object_pairs_hook* parameter can be used to alter this behavior."
msgstr ""
"O parâmetro *object_pairs_hook* pode ser usado para alterar este "
"comportamento."

#: ../../library/json.rst:702
msgid "Top-level Non-Object, Non-Array Values"
msgstr "Valores não objeto e não vetor de nível superior"

#: ../../library/json.rst:704
msgid ""
"The old version of JSON specified by the obsolete :rfc:`4627` required that "
"the top-level value of a JSON text must be either a JSON object or array "
"(Python :class:`dict` or :class:`list`), and could not be a JSON null, "
"boolean, number, or string value.  :rfc:`7159` removed that restriction, and "
"this module does not and has never implemented that restriction in either "
"its serializer or its deserializer."
msgstr ""
"A versão antiga de JSON especificada pela obsoleta :rfc:`4627` exige que o "
"valor de nível superior do texto JSON deve ser do tipo object ou array (:"
"class:`dict` ou :class:`list` Python), e não poderia ser dos tipos null, "
"boolean, number ou string. :rfc:`7159` removeu essa restrição, e esse módulo "
"não tem nenhuma implementação que faça essa restrição, seja em seus "
"serializadores, sejam nos desserializadores."

#: ../../library/json.rst:711
msgid ""
"Regardless, for maximum interoperability, you may wish to voluntarily adhere "
"to the restriction yourself."
msgstr ""
"Independentemente, para máxima interoperabilidade, você pode querer aderir "
"voluntariamente à restrição."

#: ../../library/json.rst:716
msgid "Implementation Limitations"
msgstr "Limitações de implementação"

#: ../../library/json.rst:718
msgid "Some JSON deserializer implementations may set limits on:"
msgstr ""
"Algumas implementações de desserializadores JSON podem definir limites em:"

#: ../../library/json.rst:720
msgid "the size of accepted JSON texts"
msgstr "o tamanho de textos JSON aceitos"

#: ../../library/json.rst:721
msgid "the maximum level of nesting of JSON objects and arrays"
msgstr "o nível máximo de aninhamento de objetos e vetores JSON"

#: ../../library/json.rst:722
msgid "the range and precision of JSON numbers"
msgstr "o intervalo e a precisão de números JSON"

#: ../../library/json.rst:723
msgid "the content and maximum length of JSON strings"
msgstr "o conteúdo e o tamanho máximo de strings JSON"

#: ../../library/json.rst:725
msgid ""
"This module does not impose any such limits beyond those of the relevant "
"Python datatypes themselves or the Python interpreter itself."
msgstr ""
"Esse módulo não impõe nenhum limite além daqueles já colocados pelas "
"estruturas de dados Python ou pelo interpretador Python em si."

#: ../../library/json.rst:728
msgid ""
"When serializing to JSON, beware any such limitations in applications that "
"may consume your JSON.  In particular, it is common for JSON numbers to be "
"deserialized into IEEE 754 double precision numbers and thus subject to that "
"representation's range and precision limitations.  This is especially "
"relevant when serializing Python :class:`int` values of extremely large "
"magnitude, or when serializing instances of \"exotic\" numerical types such "
"as :class:`decimal.Decimal`."
msgstr ""
"Quando serializando para JSON, tenha cuidado com qualquer limitação nas "
"aplicações que irão consumir seu JSON. Em particular, é comum para números "
"JSON serem desserializados com números de precisão dupla definida em IEEE "
"754 e, portanto, sujeito a limitações de precisão e de intervalo da "
"representação. Isso é especialmente relevante quando serializando valores "
"Python :class:`int` de magnitude extremamente grande, ou quando  "
"serializando instâncias de tipos numéricos \"exóticos\" como :class:`decimal."
"Decimal`."

#: ../../library/json.rst:741
msgid "Command-line interface"
msgstr "Interface de linha de comando"

#: ../../library/json.rst:746
msgid "**Source code:** :source:`Lib/json/tool.py`"
msgstr "**Código-fonte:** :source:`Lib/json/tool.py`"

#: ../../library/json.rst:750
msgid ""
"The :mod:`json` module can be invoked as a script via ``python -m json`` to "
"validate and pretty-print JSON objects. The :mod:`json.tool` submodule "
"implements this interface."
msgstr ""
"O módulo :mod:`json` pode ser invocado como um script via ``python -m json`` "
"para validar e fazer uma impressão bem formatada de objetos JSON. O "
"submódulo :mod:`json.tool` implementa essa interface."

#: ../../library/json.rst:754
msgid ""
"If the optional ``infile`` and ``outfile`` arguments are not specified, :"
"data:`sys.stdin` and :data:`sys.stdout` will be used respectively:"
msgstr ""
"Se os argumentos opcionais ``infile`` e ``outfile`` não forem "
"especificados, :data:`sys.stdin` e :data:`sys.stdout` serão usados "
"respectivamente:"

#: ../../library/json.rst:757
msgid ""
"$ echo '{\"json\": \"obj\"}' | python -m json\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"
msgstr ""
"$ echo '{\"json\": \"obj\"}' | python -m json\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"

#: ../../library/json.rst:766
msgid ""
"The output is now in the same order as the input. Use the :option:`--sort-"
"keys` option to sort the output of dictionaries alphabetically by key."
msgstr ""
"A saída agora está na mesma ordem da entrada. Use a opção :option:`--sort-"
"keys` para ordenar a saída de dicionários alfabeticamente pela chave."

#: ../../library/json.rst:771
msgid ""
"The :mod:`json` module may now be directly executed as ``python -m json``. "
"For backwards compatibility, invoking the CLI as ``python -m json.tool`` "
"remains supported."
msgstr ""
"O módulo :mod:`json` agora pode ser executado diretamente como ``python -m "
"json``. Para retrocompatibilidade, a invocação da CLI como ``python -m json."
"tool`` continua sendo aceita."

#: ../../library/json.rst:778
msgid "Command-line options"
msgstr "Opções de linha de comando"

#: ../../library/json.rst:782
msgid "The JSON file to be validated or pretty-printed:"
msgstr "O arquivo JSON para ser validado ou saída embelezada:"

#: ../../library/json.rst:784
msgid ""
"$ python -m json mp_films.json\n"
"[\n"
"    {\n"
"        \"title\": \"And Now for Something Completely Different\",\n"
"        \"year\": 1971\n"
"    },\n"
"    {\n"
"        \"title\": \"Monty Python and the Holy Grail\",\n"
"        \"year\": 1975\n"
"    }\n"
"]"
msgstr ""
"$ python -m json mp_films.json\n"
"[\n"
"    {\n"
"        \"title\": \"And Now for Something Completely Different\",\n"
"        \"year\": 1971\n"
"    },\n"
"    {\n"
"        \"title\": \"Monty Python and the Holy Grail\",\n"
"        \"year\": 1975\n"
"    }\n"
"]"

#: ../../library/json.rst:798
msgid "If *infile* is not specified, read from :data:`sys.stdin`."
msgstr "Se *infile* não é especificado, lê de :data:`sys.stdin`."

#: ../../library/json.rst:802
msgid ""
"Write the output of the *infile* to the given *outfile*. Otherwise, write it "
"to :data:`sys.stdout`."
msgstr ""
"Escreve a saída de *infile* para o *outfile* dado. Caso contrário, escreve "
"em :data:`sys.stdout`."

#: ../../library/json.rst:807
msgid "Sort the output of dictionaries alphabetically by key."
msgstr "Ordena a saída de dicionários alfabeticamente pela chave."

#: ../../library/json.rst:813
msgid ""
"Disable escaping of non-ascii characters, see :func:`json.dumps` for more "
"information."
msgstr ""
"Desabilita escape de caracteres não-ascii, veja :func:`json.dumps` para mais "
"informações."

#: ../../library/json.rst:819
msgid "Parse every input line as separate JSON object."
msgstr "Analisa cada linha da entrada como um objeto JSON separado."

#: ../../library/json.rst:825
msgid "Mutually exclusive options for whitespace control."
msgstr "Opções mutualmente exclusivas para controle de espaços em branco."

#: ../../library/json.rst:831
msgid "Show the help message."
msgstr "Exibe a mensagem de ajuda."

#: ../../library/json.rst:835
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../library/json.rst:836
msgid ""
"As noted in `the errata for RFC 7159 <https://www.rfc-editor.org/"
"errata_search.php?rfc=7159>`_, JSON permits literal U+2028 (LINE SEPARATOR) "
"and U+2029 (PARAGRAPH SEPARATOR) characters in strings, whereas JavaScript "
"(as of ECMAScript Edition 5.1) does not."
msgstr ""
"Como apresentado `na errata para RFC 7159 <https://www.rfc-editor.org/"
"errata_search.php?rfc=7159>`_, JSON permite os caracteres literais U+2028 "
"(SEPARADOR DE LINHA) e U+2029 (SEPARADOR DE PARÁGRAFO) em strings, enquanto "
"que JavaScript (ECMAScript Edition 5.1) não."

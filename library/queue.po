# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 15:45+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/queue.rst:2
msgid ":mod:`!queue` --- A synchronized queue class"
msgstr ":mod:`!queue` --- Класс синхронизированной очереди"

#: ../../library/queue.rst:7
msgid "**Source code:** :source:`Lib/queue.py`"
msgstr "**Código-fonte:** :source:`Lib/queue.py`"

#: ../../library/queue.rst:11
msgid ""
"The :mod:`queue` module implements multi-producer, multi-consumer queues. It "
"is especially useful in threaded programming when information must be "
"exchanged safely between multiple threads.  The :class:`Queue` class in this "
"module implements all the required locking semantics."
msgstr ""
"Модуль :mod:`queue` реалізує черги з кількома виробниками та кількома "
"споживачами. Це особливо корисно в потоковому програмуванні, коли необхідно "
"безпечно обмінюватися інформацією між декількома потоками. Клас :class:"
"`Queue` у цьому модулі реалізує всю необхідну семантику блокування."

#: ../../library/queue.rst:16
msgid ""
"The module implements three types of queue, which differ only in the order "
"in which the entries are retrieved.  In a :abbr:`FIFO (first-in, first-out)` "
"queue, the first tasks added are the first retrieved.  In a :abbr:`LIFO "
"(last-in, first-out)` queue, the most recently added entry is the first "
"retrieved (operating like a stack).  With a priority queue, the entries are "
"kept sorted (using the :mod:`heapq` module) and the lowest valued entry is "
"retrieved first."
msgstr ""
"Модуль реализует три типа очередей, которые отличаются только порядком "
"получения записей. В очереди :abbr:`FIFO (первым вошел, первым обслужен)` "
"задачи, добавленные первыми, извлекаются первыми. В очереди :abbr:`LIFO "
"(последним вошел, первым обслужен)` самая последняя добавленная запись "
"является первой полученной (работает как стек). В очереди с приоритетом "
"записи сортируются (с использованием модуля :mod:`heapq`), и первой "
"извлекается запись с наименьшим значением."

#: ../../library/queue.rst:24
msgid ""
"Internally, those three types of queues use locks to temporarily block "
"competing threads; however, they are not designed to handle reentrancy "
"within a thread."
msgstr ""
"Внутрішньо ці три типи черг використовують блокування для тимчасового "
"блокування конкуруючих потоків; однак вони не призначені для обробки "
"повторного входу в потік."

#: ../../library/queue.rst:28
msgid ""
"In addition, the module implements a \"simple\" :abbr:`FIFO (first-in, first-"
"out)` queue type, :class:`SimpleQueue`, whose specific implementation "
"provides additional guarantees in exchange for the smaller functionality."
msgstr ""
"Крім того, модуль реалізує \"простий\" тип черги :abbr:`FIFO (перший "
"увійшов, перший вийшов)`, :class:`SimpleQueue`, конкретна реалізація якого "
"забезпечує додаткові гарантії в обмін на меншу функціональність."

#: ../../library/queue.rst:33
msgid "The :mod:`queue` module defines the following classes and exceptions:"
msgstr "Модуль :mod:`queue` визначає такі класи та винятки:"

#: ../../library/queue.rst:37
msgid ""
"Constructor for a :abbr:`FIFO (first-in, first-out)` queue.  *maxsize* is an "
"integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero, "
"the queue size is infinite."
msgstr ""
"Конструктор для черги :abbr:`FIFO (першим увійшов, першим вийшов)`. "
"*maxsize* — це ціле число, яке встановлює верхню межу кількості елементів, "
"які можна розмістити в черзі. Вставлення буде заблоковано, коли буде "
"досягнуто цього розміру, доки елементи черги не будуть використані. Якщо "
"*maxsize* менше або дорівнює нулю, розмір черги є нескінченним."

#: ../../library/queue.rst:45
msgid ""
"Constructor for a :abbr:`LIFO (last-in, first-out)` queue.  *maxsize* is an "
"integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero, "
"the queue size is infinite."
msgstr ""
"Конструктор для :abbr:`LIFO (останній увійшов, перший вийшов)` черги. "
"*maxsize* — це ціле число, яке встановлює верхню межу кількості елементів, "
"які можна розмістити в черзі. Вставлення буде заблоковано після досягнення "
"цього розміру, доки елементи черги не будуть використані. Якщо *maxsize* "
"менше або дорівнює нулю, розмір черги є нескінченним."

#: ../../library/queue.rst:54
msgid ""
"Constructor for a priority queue.  *maxsize* is an integer that sets the "
"upperbound limit on the number of items that can be placed in the queue.  "
"Insertion will block once this size has been reached, until queue items are "
"consumed.  If *maxsize* is less than or equal to zero, the queue size is "
"infinite."
msgstr ""
"Конструктор для пріоритетної черги. *maxsize* — це ціле число, яке "
"встановлює верхню межу кількості елементів, які можна розмістити в черзі. "
"Вставлення буде заблоковано після досягнення цього розміру, доки елементи "
"черги не будуть використані. Якщо *maxsize* менше або дорівнює нулю, розмір "
"черги є нескінченним."

#: ../../library/queue.rst:59
msgid ""
"The lowest valued entries are retrieved first (the lowest valued entry is "
"the one that would be returned by ``min(entries)``).  A typical pattern for "
"entries is a tuple in the form: ``(priority_number, data)``."
msgstr ""
"Сначала извлекаются записи с наименьшим значением (запись с наименьшим "
"значением - это та, которая будет возвращена ``min(entries)``). Типичным "
"шаблоном записей является кортеж в форме: ``(priority_number, data)``."

#: ../../library/queue.rst:63
msgid ""
"If the *data* elements are not comparable, the data can be wrapped in a "
"class that ignores the data item and only compares the priority number::"
msgstr ""
"Якщо елементи *data* не можна порівняти, дані можна загорнути в клас, який "
"ігнорує елемент даних і порівнює лише номер пріоритету::"

#: ../../library/queue.rst:66
msgid ""
"from dataclasses import dataclass, field\n"
"from typing import Any\n"
"\n"
"@dataclass(order=True)\n"
"class PrioritizedItem:\n"
"    priority: int\n"
"    item: Any=field(compare=False)"
msgstr ""
"from dataclasses import dataclass, field\n"
"from typing import Any\n"
"\n"
"@dataclass(order=True)\n"
"class PrioritizedItem:\n"
"    priority: int\n"
"    item: Any=field(compare=False)"

#: ../../library/queue.rst:76
msgid ""
"Constructor for an unbounded :abbr:`FIFO (first-in, first-out)` queue. "
"Simple queues lack advanced functionality such as task tracking."
msgstr ""
"Конструктор для необмеженої черги :abbr:`FIFO (першим увійшов, першим "
"вийшов)`. Прості черги не мають розширених функцій, таких як відстеження "
"завдань."

#: ../../library/queue.rst:84
msgid ""
"Exception raised when non-blocking :meth:`~Queue.get` (or :meth:`~Queue."
"get_nowait`) is called on a :class:`Queue` object which is empty."
msgstr ""
"Виняток виникає, коли неблокуючий :meth:`~Queue.get` (або :meth:`~Queue."
"get_nowait`) викликається для порожнього об’єкта :class:`Queue`."

#: ../../library/queue.rst:91
msgid ""
"Exception raised when non-blocking :meth:`~Queue.put` (or :meth:`~Queue."
"put_nowait`) is called on a :class:`Queue` object which is full."
msgstr ""
"Виняток виникає, коли неблокуючий :meth:`~Queue.put` (або :meth:`~Queue."
"put_nowait`) викликається для заповненого об’єкта :class:`Queue`."

#: ../../library/queue.rst:99
msgid "Queue Objects"
msgstr "Objetos Queue"

#: ../../library/queue.rst:101
msgid ""
"Queue objects (:class:`Queue`, :class:`LifoQueue`, or :class:"
"`PriorityQueue`) provide the public methods described below."
msgstr ""
"Об’єкти черги (:class:`Queue`, :class:`LifoQueue` або :class:"
"`PriorityQueue`) надають публічні методи, описані нижче."

#: ../../library/queue.rst:107
msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block, nor will qsize() < maxsize "
"guarantee that put() will not block."
msgstr ""
"Повертає приблизний розмір черги. Зауважте, що qsize() > 0 не гарантує, що "
"наступний get() не заблокує, а також qsize() < maxsize не гарантує, що put() "
"не заблокує."

#: ../../library/queue.rst:114
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``True`` it doesn't guarantee that a subsequent call to put() will "
"not block.  Similarly, if empty() returns ``False`` it doesn't guarantee "
"that a subsequent call to get() will not block."
msgstr ""
"Повертає ``True``, якщо черга порожня, ``False`` інакше. Якщо empty() "
"повертає ``True``, це не гарантує, що наступний виклик put() не "
"заблокується. Подібним чином, якщо empty() повертає ``False``, це не "
"гарантує, що наступний виклик get() не заблокується."

#: ../../library/queue.rst:122
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  If full() "
"returns ``True`` it doesn't guarantee that a subsequent call to get() will "
"not block.  Similarly, if full() returns ``False`` it doesn't guarantee that "
"a subsequent call to put() will not block."
msgstr ""
"Повертає ``True``, якщо черга заповнена, ``False`` інакше. Якщо full() "
"повертає ``True``, це не гарантує, що наступний виклик get() не "
"заблокується. Так само, якщо full() повертає ``False``, це не гарантує, що "
"наступний виклик put() не буде заблоковано."

#: ../../library/queue.rst:130
msgid ""
"Put *item* into the queue.  If optional args *block* is true and *timeout* "
"is ``None`` (the default), block if necessary until a free slot is "
"available.  If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Full` exception if no free slot was available "
"within that time. Otherwise (*block* is false), put an item on the queue if "
"a free slot is immediately available, else raise the :exc:`Full` exception "
"(*timeout* is ignored in that case)."
msgstr ""
"Поместите *элемент* в очередь. Если необязательные аргументы *block* имеют "
"значение true, а *timeout* имеет значение None (по умолчанию), блокируйте "
"при необходимости до тех пор, пока не станет доступен свободный слот. Если "
"*timeout* является положительным числом, он блокирует не более *timeout* "
"секунд и вызывает исключение :exc:`Full`, если в течение этого времени не "
"было свободного слота. В противном случае (*block* имеет значение false) "
"поместите элемент в очередь, если свободный слот доступен немедленно, иначе "
"вызовите исключение :exc:`Full` (в этом случае *timeout* игнорируется)."

#: ../../library/queue.rst:141
msgid "Equivalent to ``put(item, block=False)``."
msgstr "Еквівалент ``put(item, block=False)``."

#: ../../library/queue.rst:146 ../../library/queue.rst:258
msgid ""
"Remove and return an item from the queue.  If optional args *block* is true "
"and *timeout* is ``None`` (the default), block if necessary until an item is "
"available. If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Empty` exception if no item was available "
"within that time. Otherwise (*block* is false), return an item if one is "
"immediately available, else raise the :exc:`Empty` exception (*timeout* is "
"ignored in that case)."
msgstr ""
"Видалити та повернути елемент із черги. Якщо необов’язкові аргументи *block* "
"мають значення true, а *timeout* має значення ``None`` (за замовчуванням), "
"за потреби блокуйте, доки елемент не стане доступним. Якщо *timeout* є "
"позитивним числом, він блокує щонайбільше *timeout* секунд і викликає "
"виключення :exc:`Empty`, якщо жоден елемент не був доступний протягом цього "
"часу. В іншому випадку (*block* — false), повертає елемент, якщо він одразу "
"доступний, інакше викликає виняток :exc:`Empty` (у цьому випадку *timeout* "
"ігнорується)."

#: ../../library/queue.rst:153
msgid ""
"Prior to 3.0 on POSIX systems, and for all versions on Windows, if *block* "
"is true and *timeout* is ``None``, this operation goes into an "
"uninterruptible wait on an underlying lock.  This means that no exceptions "
"can occur, and in particular a SIGINT will not trigger a :exc:"
"`KeyboardInterrupt`."
msgstr ""
"До версии 3.0 в системах POSIX и для всех версий в Windows, если *block* "
"имеет значение true, а *timeout* имеет значение ``None``, эта операция "
"переходит в режим непрерывного ожидания базовой блокировки. Это означает, "
"что никаких исключений возникнуть не может, и, в частности, SIGINT не "
"вызовет :exc:`KeyboardInterrupt`."

#: ../../library/queue.rst:161 ../../library/queue.rst:268
msgid "Equivalent to ``get(False)``."
msgstr "Equivalente a ``get(False)``."

#: ../../library/queue.rst:163
msgid ""
"Two methods are offered to support tracking whether enqueued tasks have been "
"fully processed by daemon consumer threads."
msgstr ""
"Пропонуються два методи підтримки відстеження того, чи завдання, поставлені "
"в чергу, були повністю оброблені потоками споживачів демона."

#: ../../library/queue.rst:169
msgid ""
"Indicate that a formerly enqueued task is complete.  Used by queue consumer "
"threads.  For each :meth:`get` used to fetch a task, a subsequent call to :"
"meth:`task_done` tells the queue that the processing on the task is complete."
msgstr ""
"Вказує на те, що завдання, яке раніше було в черзі, виконано. "
"Використовується потоками споживачів черги. Для кожного :meth:`get`, який "
"використовується для отримання завдання, наступний виклик :meth:`task_done` "
"повідомляє черзі, що обробку завдання завершено."

#: ../../library/queue.rst:173
msgid ""
"If a :meth:`join` is currently blocking, it will resume when all items have "
"been processed (meaning that a :meth:`task_done` call was received for every "
"item that had been :meth:`put` into the queue)."
msgstr ""
"Якщо :meth:`join` зараз блокується, воно відновиться, коли всі елементи буде "
"оброблено (це означає, що виклик :meth:`task_done` отримано для кожного "
"елемента, який був :meth:`put` у чергу) ."

#: ../../library/queue.rst:177
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Levanta :exc:`ValueError` se for chamado mais vezes do que o número de itens "
"colocados na fila."

#: ../../library/queue.rst:183
msgid "Blocks until all items in the queue have been gotten and processed."
msgstr "Блокує, доки всі елементи в черзі не будуть отримані та оброблені."

#: ../../library/queue.rst:185
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue. The count goes down whenever a consumer thread calls :meth:"
"`task_done` to indicate that the item was retrieved and all work on it is "
"complete.  When the count of unfinished tasks drops to zero, :meth:`join` "
"unblocks."
msgstr ""
"Количество незавершенных задач увеличивается каждый раз, когда элемент "
"добавляется в очередь. Счетчик уменьшается всякий раз, когда потребительский "
"поток вызывает :meth:`task_done`, чтобы указать, что элемент был получен и "
"вся работа над ним завершена. Когда количество незавершенных задач падает до "
"нуля, :meth:`join` разблокируется."

#: ../../library/queue.rst:191
msgid "Example of how to wait for enqueued tasks to be completed::"
msgstr "Приклад очікування виконання завдань, поставлених у чергу::"

#: ../../library/queue.rst:193
msgid ""
"import threading\n"
"import queue\n"
"\n"
"q = queue.Queue()\n"
"\n"
"def worker():\n"
"    while True:\n"
"        item = q.get()\n"
"        print(f'Working on {item}')\n"
"        print(f'Finished {item}')\n"
"        q.task_done()\n"
"\n"
"# Turn-on the worker thread.\n"
"threading.Thread(target=worker, daemon=True).start()\n"
"\n"
"# Send thirty task requests to the worker.\n"
"for item in range(30):\n"
"    q.put(item)\n"
"\n"
"# Block until all tasks are done.\n"
"q.join()\n"
"print('All work completed')"
msgstr ""
"import threading\n"
"import queue\n"
"\n"
"q = queue.Queue()\n"
"\n"
"def worker():\n"
"    while True:\n"
"        item = q.get()\n"
"        print(f'Working on {item}')\n"
"        print(f'Finished {item}')\n"
"        q.task_done()\n"
"\n"
"# Turn-on the worker thread.\n"
"threading.Thread(target=worker, daemon=True).start()\n"
"\n"
"# Send thirty task requests to the worker.\n"
"for item in range(30):\n"
"    q.put(item)\n"
"\n"
"# Block until all tasks are done.\n"
"q.join()\n"
"print('All work completed')"

#: ../../library/queue.rst:218
msgid "SimpleQueue Objects"
msgstr "Objetos SimpleQueue"

#: ../../library/queue.rst:220
msgid ""
":class:`SimpleQueue` objects provide the public methods described below."
msgstr ""
"Об’єкти :class:`SimpleQueue` забезпечують публічні методи, описані нижче."

#: ../../library/queue.rst:224
msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block."
msgstr ""
"Повертає приблизний розмір черги. Зауважте, що qsize() > 0 не гарантує, що "
"наступний get() не заблокує."

#: ../../library/queue.rst:230
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``False`` it doesn't guarantee that a subsequent call to get() will "
"not block."
msgstr ""
"Верните True, если очередь пуста, и False в противном случае. Если пустой() "
"возвращает «False», это не гарантирует, что последующий вызов get() не будет "
"заблокирован."

#: ../../library/queue.rst:237
msgid ""
"Put *item* into the queue.  The method never blocks and always succeeds "
"(except for potential low-level errors such as failure to allocate memory). "
"The optional args *block* and *timeout* are ignored and only provided for "
"compatibility with :meth:`Queue.put`."
msgstr ""
"Поставте *товар* в чергу. Метод ніколи не блокується і завжди виконується "
"успішно (за винятком потенційних низькорівневих помилок, таких як помилка "
"виділення пам’яті). Необов’язкові аргументи *block* і *timeout* ігноруються "
"та надаються лише для сумісності з :meth:`Queue.put`."

#: ../../library/queue.rst:243
msgid ""
"This method has a C implementation which is reentrant.  That is, a ``put()`` "
"or ``get()`` call can be interrupted by another ``put()`` call in the same "
"thread without deadlocking or corrupting internal state inside the queue.  "
"This makes it appropriate for use in destructors such as ``__del__`` methods "
"or :mod:`weakref` callbacks."
msgstr ""
"Этот метод имеет реентерабельную реализацию на языке C. То есть вызов put() "
"или get() может быть прерван другим вызовом put() в том же потоке без "
"взаимоблокировки или повреждения внутреннего состояния внутри очереди. Это "
"делает его подходящим для использования в деструкторах, таких как методы "
"``__del__`` или обратные вызовы :mod:`weakref`."

#: ../../library/queue.rst:252
msgid ""
"Equivalent to ``put(item, block=False)``, provided for compatibility with :"
"meth:`Queue.put_nowait`."
msgstr ""
"Еквівалент ``put(item, block=False)``, передбачений для сумісності з :meth:"
"`Queue.put_nowait`."

#: ../../library/queue.rst:273
msgid "Class :class:`multiprocessing.Queue`"
msgstr "Клас :class:`multiprocessing.Queue`"

#: ../../library/queue.rst:274
msgid ""
"A queue class for use in a multi-processing (rather than multi-threading) "
"context."
msgstr ""
"Клас черги для використання в багатопроцесорному (а не багатопоточному) "
"контексті."

#: ../../library/queue.rst:277
msgid ""
":class:`collections.deque` is an alternative implementation of unbounded "
"queues with fast atomic :meth:`~collections.deque.append` and :meth:"
"`~collections.deque.popleft` operations that do not require locking and also "
"support indexing."
msgstr ""
":class:`collections.deque` — це альтернативна реалізація необмежених черг із "
"швидкими атомарними операціями :meth:`~collections.deque.append` і :meth:"
"`~collections.deque.popleft`, які не потребують блокування, а також "
"підтримують індексація."

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 17:51+0000\n"
"PO-Revision-Date: 2017-02-16 23:24+0000\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/queue.rst:2
msgid ":mod:`queue` --- A synchronized queue class"
msgstr ":mod:`queue` --- Синхронізований клас черги"

#: ../../library/queue.rst:7
msgid "**Source code:** :source:`Lib/queue.py`"
msgstr "**Código-fonte:** :source:`Lib/queue.py`"

#: ../../library/queue.rst:11
msgid ""
"The :mod:`queue` module implements multi-producer, multi-consumer queues. It "
"is especially useful in threaded programming when information must be "
"exchanged safely between multiple threads.  The :class:`Queue` class in this "
"module implements all the required locking semantics."
msgstr ""
"Модуль :mod:`queue` реалізує черги з кількома виробниками та кількома "
"споживачами. Це особливо корисно в потоковому програмуванні, коли необхідно "
"безпечно обмінюватися інформацією між декількома потоками. Клас :class:"
"`Queue` у цьому модулі реалізує всю необхідну семантику блокування."

#: ../../library/queue.rst:16
msgid ""
"The module implements three types of queue, which differ only in the order "
"in which the entries are retrieved.  In a :abbr:`FIFO (first-in, first-out)` "
"queue, the first tasks added are the first retrieved. In a :abbr:`LIFO (last-"
"in, first-out)` queue, the most recently added entry is the first retrieved "
"(operating like a stack).  With a priority queue, the entries are kept "
"sorted (using the :mod:`heapq` module) and the lowest valued entry is "
"retrieved first."
msgstr ""

#: ../../library/queue.rst:24
msgid ""
"Internally, those three types of queues use locks to temporarily block "
"competing threads; however, they are not designed to handle reentrancy "
"within a thread."
msgstr ""
"Внутрішньо ці три типи черг використовують блокування для тимчасового "
"блокування конкуруючих потоків; однак вони не призначені для обробки "
"повторного входу в потік."

#: ../../library/queue.rst:28
msgid ""
"In addition, the module implements a \"simple\" :abbr:`FIFO (first-in, first-"
"out)` queue type, :class:`SimpleQueue`, whose specific implementation "
"provides additional guarantees in exchange for the smaller functionality."
msgstr ""
"Крім того, модуль реалізує \"простий\" тип черги :abbr:`FIFO (перший "
"увійшов, перший вийшов)`, :class:`SimpleQueue`, конкретна реалізація якого "
"забезпечує додаткові гарантії в обмін на меншу функціональність."

#: ../../library/queue.rst:33
msgid "The :mod:`queue` module defines the following classes and exceptions:"
msgstr "Модуль :mod:`queue` визначає такі класи та винятки:"

#: ../../library/queue.rst:37
msgid ""
"Constructor for a :abbr:`FIFO (first-in, first-out)` queue.  *maxsize* is an "
"integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero, "
"the queue size is infinite."
msgstr ""
"Конструктор для черги :abbr:`FIFO (першим увійшов, першим вийшов)`. "
"*maxsize* — це ціле число, яке встановлює верхню межу кількості елементів, "
"які можна розмістити в черзі. Вставлення буде заблоковано, коли буде "
"досягнуто цього розміру, доки елементи черги не будуть використані. Якщо "
"*maxsize* менше або дорівнює нулю, розмір черги є нескінченним."

#: ../../library/queue.rst:45
msgid ""
"Constructor for a :abbr:`LIFO (last-in, first-out)` queue.  *maxsize* is an "
"integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero, "
"the queue size is infinite."
msgstr ""
"Конструктор для :abbr:`LIFO (останній увійшов, перший вийшов)` черги. "
"*maxsize* — це ціле число, яке встановлює верхню межу кількості елементів, "
"які можна розмістити в черзі. Вставлення буде заблоковано після досягнення "
"цього розміру, доки елементи черги не будуть використані. Якщо *maxsize* "
"менше або дорівнює нулю, розмір черги є нескінченним."

#: ../../library/queue.rst:54
msgid ""
"Constructor for a priority queue.  *maxsize* is an integer that sets the "
"upperbound limit on the number of items that can be placed in the queue.  "
"Insertion will block once this size has been reached, until queue items are "
"consumed.  If *maxsize* is less than or equal to zero, the queue size is "
"infinite."
msgstr ""
"Конструктор для пріоритетної черги. *maxsize* — це ціле число, яке "
"встановлює верхню межу кількості елементів, які можна розмістити в черзі. "
"Вставлення буде заблоковано після досягнення цього розміру, доки елементи "
"черги не будуть використані. Якщо *maxsize* менше або дорівнює нулю, розмір "
"черги є нескінченним."

#: ../../library/queue.rst:59
msgid ""
"The lowest valued entries are retrieved first (the lowest valued entry is "
"the one returned by ``sorted(list(entries))[0]``).  A typical pattern for "
"entries is a tuple in the form: ``(priority_number, data)``."
msgstr ""

#: ../../library/queue.rst:63
msgid ""
"If the *data* elements are not comparable, the data can be wrapped in a "
"class that ignores the data item and only compares the priority number::"
msgstr ""
"Якщо елементи *data* не можна порівняти, дані можна загорнути в клас, який "
"ігнорує елемент даних і порівнює лише номер пріоритету::"

#: ../../library/queue.rst:76
msgid ""
"Constructor for an unbounded :abbr:`FIFO (first-in, first-out)` queue. "
"Simple queues lack advanced functionality such as task tracking."
msgstr ""
"Конструктор для необмеженої черги :abbr:`FIFO (першим увійшов, першим "
"вийшов)`. Прості черги не мають розширених функцій, таких як відстеження "
"завдань."

#: ../../library/queue.rst:84
msgid ""
"Exception raised when non-blocking :meth:`~Queue.get` (or :meth:`~Queue."
"get_nowait`) is called on a :class:`Queue` object which is empty."
msgstr ""
"Виняток виникає, коли неблокуючий :meth:`~Queue.get` (або :meth:`~Queue."
"get_nowait`) викликається для порожнього об’єкта :class:`Queue`."

#: ../../library/queue.rst:91
msgid ""
"Exception raised when non-blocking :meth:`~Queue.put` (or :meth:`~Queue."
"put_nowait`) is called on a :class:`Queue` object which is full."
msgstr ""
"Виняток виникає, коли неблокуючий :meth:`~Queue.put` (або :meth:`~Queue."
"put_nowait`) викликається для заповненого об’єкта :class:`Queue`."

#: ../../library/queue.rst:99
msgid "Queue Objects"
msgstr "Objetos Queue"

#: ../../library/queue.rst:101
msgid ""
"Queue objects (:class:`Queue`, :class:`LifoQueue`, or :class:"
"`PriorityQueue`) provide the public methods described below."
msgstr ""
"Об’єкти черги (:class:`Queue`, :class:`LifoQueue` або :class:"
"`PriorityQueue`) надають публічні методи, описані нижче."

#: ../../library/queue.rst:107
msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block, nor will qsize() < maxsize "
"guarantee that put() will not block."
msgstr ""
"Повертає приблизний розмір черги. Зауважте, що qsize() > 0 не гарантує, що "
"наступний get() не заблокує, а також qsize() < maxsize не гарантує, що put() "
"не заблокує."

#: ../../library/queue.rst:114
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``True`` it doesn't guarantee that a subsequent call to put() will "
"not block.  Similarly, if empty() returns ``False`` it doesn't guarantee "
"that a subsequent call to get() will not block."
msgstr ""
"Повертає ``True``, якщо черга порожня, ``False`` інакше. Якщо empty() "
"повертає ``True``, це не гарантує, що наступний виклик put() не "
"заблокується. Подібним чином, якщо empty() повертає ``False``, це не "
"гарантує, що наступний виклик get() не заблокується."

#: ../../library/queue.rst:122
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  If full() "
"returns ``True`` it doesn't guarantee that a subsequent call to get() will "
"not block.  Similarly, if full() returns ``False`` it doesn't guarantee that "
"a subsequent call to put() will not block."
msgstr ""
"Повертає ``True``, якщо черга заповнена, ``False`` інакше. Якщо full() "
"повертає ``True``, це не гарантує, що наступний виклик get() не "
"заблокується. Так само, якщо full() повертає ``False``, це не гарантує, що "
"наступний виклик put() не буде заблоковано."

#: ../../library/queue.rst:130
msgid ""
"Put *item* into the queue. If optional args *block* is true and *timeout* is "
"``None`` (the default), block if necessary until a free slot is available. "
"If *timeout* is a positive number, it blocks at most *timeout* seconds and "
"raises the :exc:`Full` exception if no free slot was available within that "
"time. Otherwise (*block* is false), put an item on the queue if a free slot "
"is immediately available, else raise the :exc:`Full` exception (*timeout* is "
"ignored in that case)."
msgstr ""

#: ../../library/queue.rst:141
msgid "Equivalent to ``put(item, block=False)``."
msgstr "Еквівалент ``put(item, block=False)``."

#: ../../library/queue.rst:146
msgid ""
"Remove and return an item from the queue. If optional args *block* is true "
"and *timeout* is ``None`` (the default), block if necessary until an item is "
"available. If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Empty` exception if no item was available "
"within that time. Otherwise (*block* is false), return an item if one is "
"immediately available, else raise the :exc:`Empty` exception (*timeout* is "
"ignored in that case)."
msgstr ""

#: ../../library/queue.rst:153
msgid ""
"Prior to 3.0 on POSIX systems, and for all versions on Windows, if *block* "
"is true and *timeout* is ``None``, this operation goes into an "
"uninterruptible wait on an underlying lock. This means that no exceptions "
"can occur, and in particular a SIGINT will not trigger a :exc:"
"`KeyboardInterrupt`."
msgstr ""

#: ../../library/queue.rst:161 ../../library/queue.rst:268
msgid "Equivalent to ``get(False)``."
msgstr "Equivalente a ``get(False)``."

#: ../../library/queue.rst:163
msgid ""
"Two methods are offered to support tracking whether enqueued tasks have been "
"fully processed by daemon consumer threads."
msgstr ""
"Пропонуються два методи підтримки відстеження того, чи завдання, поставлені "
"в чергу, були повністю оброблені потоками споживачів демона."

#: ../../library/queue.rst:169
msgid ""
"Indicate that a formerly enqueued task is complete.  Used by queue consumer "
"threads.  For each :meth:`get` used to fetch a task, a subsequent call to :"
"meth:`task_done` tells the queue that the processing on the task is complete."
msgstr ""
"Вказує на те, що завдання, яке раніше було в черзі, виконано. "
"Використовується потоками споживачів черги. Для кожного :meth:`get`, який "
"використовується для отримання завдання, наступний виклик :meth:`task_done` "
"повідомляє черзі, що обробку завдання завершено."

#: ../../library/queue.rst:173
msgid ""
"If a :meth:`join` is currently blocking, it will resume when all items have "
"been processed (meaning that a :meth:`task_done` call was received for every "
"item that had been :meth:`put` into the queue)."
msgstr ""
"Якщо :meth:`join` зараз блокується, воно відновиться, коли всі елементи буде "
"оброблено (це означає, що виклик :meth:`task_done` отримано для кожного "
"елемента, який був :meth:`put` у чергу) ."

#: ../../library/queue.rst:177
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Levanta :exc:`ValueError` se for chamado mais vezes do que o número de itens "
"colocados na fila."

#: ../../library/queue.rst:183
msgid "Blocks until all items in the queue have been gotten and processed."
msgstr "Блокує, доки всі елементи в черзі не будуть отримані та оброблені."

#: ../../library/queue.rst:185
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue. The count goes down whenever a consumer thread calls :meth:"
"`task_done` to indicate that the item was retrieved and all work on it is "
"complete. When the count of unfinished tasks drops to zero, :meth:`join` "
"unblocks."
msgstr ""

#: ../../library/queue.rst:191
msgid "Example of how to wait for enqueued tasks to be completed::"
msgstr "Приклад очікування виконання завдань, поставлених у чергу::"

#: ../../library/queue.rst:218
msgid "SimpleQueue Objects"
msgstr "Objetos SimpleQueue"

#: ../../library/queue.rst:220
msgid ""
":class:`SimpleQueue` objects provide the public methods described below."
msgstr ""
"Об’єкти :class:`SimpleQueue` забезпечують публічні методи, описані нижче."

#: ../../library/queue.rst:224
msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block."
msgstr ""
"Повертає приблизний розмір черги. Зауважте, що qsize() > 0 не гарантує, що "
"наступний get() не заблокує."

#: ../../library/queue.rst:230
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise. If empty() "
"returns ``False`` it doesn't guarantee that a subsequent call to get() will "
"not block."
msgstr ""

#: ../../library/queue.rst:237
msgid ""
"Put *item* into the queue.  The method never blocks and always succeeds "
"(except for potential low-level errors such as failure to allocate memory). "
"The optional args *block* and *timeout* are ignored and only provided for "
"compatibility with :meth:`Queue.put`."
msgstr ""
"Поставте *товар* в чергу. Метод ніколи не блокується і завжди виконується "
"успішно (за винятком потенційних низькорівневих помилок, таких як помилка "
"виділення пам’яті). Необов’язкові аргументи *block* і *timeout* ігноруються "
"та надаються лише для сумісності з :meth:`Queue.put`."

#: ../../library/queue.rst:252
msgid ""
"Equivalent to ``put(item, block=False)``, provided for compatibility with :"
"meth:`Queue.put_nowait`."
msgstr ""
"Еквівалент ``put(item, block=False)``, передбачений для сумісності з :meth:"
"`Queue.put_nowait`."

#: ../../library/queue.rst:258
msgid ""
"Remove and return an item from the queue.  If optional args *block* is true "
"and *timeout* is ``None`` (the default), block if necessary until an item is "
"available. If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Empty` exception if no item was available "
"within that time. Otherwise (*block* is false), return an item if one is "
"immediately available, else raise the :exc:`Empty` exception (*timeout* is "
"ignored in that case)."
msgstr ""
"Видалити та повернути елемент із черги. Якщо необов’язкові аргументи *block* "
"мають значення true, а *timeout* має значення ``None`` (за замовчуванням), "
"за потреби блокуйте, доки елемент не стане доступним. Якщо *timeout* є "
"позитивним числом, він блокує щонайбільше *timeout* секунд і викликає "
"виключення :exc:`Empty`, якщо жоден елемент не був доступний протягом цього "
"часу. В іншому випадку (*block* — false), повертає елемент, якщо він одразу "
"доступний, інакше викликає виняток :exc:`Empty` (у цьому випадку *timeout* "
"ігнорується)."

#: ../../library/queue.rst:275
msgid "Class :class:`multiprocessing.Queue`"
msgstr "Клас :class:`multiprocessing.Queue`"

#: ../../library/queue.rst:274
msgid ""
"A queue class for use in a multi-processing (rather than multi-threading) "
"context."
msgstr ""
"Клас черги для використання в багатопроцесорному (а не багатопоточному) "
"контексті."

#: ../../library/queue.rst:277
msgid ""
":class:`collections.deque` is an alternative implementation of unbounded "
"queues with fast atomic :meth:`~collections.deque.append` and :meth:"
"`~collections.deque.popleft` operations that do not require locking and also "
"support indexing."
msgstr ""
":class:`collections.deque` — це альтернативна реалізація необмежених черг із "
"швидкими атомарними операціями :meth:`~collections.deque.append` і :meth:"
"`~collections.deque.popleft`, які не потребують блокування, а також "
"підтримують індексація."

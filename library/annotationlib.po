# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/annotationlib.rst:2
msgid ":mod:`!annotationlib` --- Functionality for introspecting annotations"
msgstr ""
":mod:`!annotationlib` --- Funcionalidade para introspecção de anotações"

#: ../../library/annotationlib.rst:8
msgid "**Source code:** :source:`Lib/annotationlib.py`"
msgstr "**Código-fonte:** :source:`Lib/annotationlib.py`"

#: ../../library/annotationlib.rst:17
msgid ""
"The :mod:`!annotationlib` module provides tools for introspecting :term:"
"`annotations <annotation>` on modules, classes, and functions."
msgstr ""
"O módulo :mod:`!annotationlib` fornece ferramentas para introspecção de :"
"term:`anotações <annotation>` em módulos, classes e funções."

#: ../../library/annotationlib.rst:20
msgid ""
"Annotations are :ref:`lazily evaluated <lazy-evaluation>` and often contain "
"forward references to objects that are not yet defined when the annotation "
"is created. This module provides a set of low-level tools that can be used "
"to retrieve annotations in a reliable way, even in the presence of forward "
"references and other edge cases."
msgstr ""
"As anotações são :ref:`avaliadas preguiçosamente <lazy-evaluation>` e "
"frequentemente contêm referências futuras a objetos que ainda não foram "
"definidos quando a anotação é criada. Este módulo fornece um conjunto de "
"ferramentas de baixo nível que podem ser usadas para recuperar anotações de "
"forma confiável, mesmo na presença de referências futuras e outros casos "
"extremos."

#: ../../library/annotationlib.rst:25
msgid ""
"This module supports retrieving annotations in three main formats (see :"
"class:`Format`), each of which works best for different use cases:"
msgstr ""
"Este módulo oferece suporte a recuperação de anotações em três formatos "
"principais (veja :class:`Format`), cada um dos quais funciona melhor para "
"diferentes casos de uso:"

#: ../../library/annotationlib.rst:28
msgid ""
":attr:`~Format.VALUE` evaluates the annotations and returns their value. "
"This is most straightforward to work with, but it may raise errors, for "
"example if the annotations contain references to undefined names."
msgstr ""
":attr:`~Format.VALUE` avalia as anotações e retorna seus valores. Isso é "
"mais simples de usar, mas pode levantar erros, por exemplo, se as anotações "
"contiverem referências a nomes indefinidos."

#: ../../library/annotationlib.rst:31
msgid ""
":attr:`~Format.FORWARDREF` returns :class:`ForwardRef` objects for "
"annotations that cannot be resolved, allowing you to inspect the annotations "
"without evaluating them. This is useful when you need to work with "
"annotations that may contain unresolved forward references."
msgstr ""
":attr:`~Format.FORWARDREF` retorna objetos :class:`ForwardRef` para "
"anotações que não podem ser resolvidas, permitindo que você inspecione as "
"anotações sem avaliá-las. Isso é útil quando você precisa trabalhar com "
"anotações que podem conter referências de encaminhamento não resolvidas."

#: ../../library/annotationlib.rst:35
msgid ""
":attr:`~Format.STRING` returns the annotations as a string, similar to how "
"it would appear in the source file. This is useful for documentation "
"generators that want to display annotations in a readable way."
msgstr ""
":attr:`~Format.STRING` retorna as anotações como uma string, semelhante a "
"como apareceria no arquivo fonte. Isso é útil para geradores de documentação "
"que desejam exibir anotações de forma legível."

#: ../../library/annotationlib.rst:39
msgid ""
"The :func:`get_annotations` function is the main entry point for retrieving "
"annotations. Given a function, class, or module, it returns an annotations "
"dictionary in the requested format. This module also provides functionality "
"for working directly with the :term:`annotate function` that is used to "
"evaluate annotations, such as :func:`get_annotate_from_class_namespace` and :"
"func:`call_annotate_function`, as well as the :func:`call_evaluate_function` "
"function for working with :term:`evaluate functions <evaluate function>`."
msgstr ""
"A função :func:`get_annotations` é o principal ponto de entrada para "
"recuperar anotações. Dada uma função, classe ou módulo, ela retorna um "
"dicionário de anotações no formato solicitado. Este módulo também fornece "
"funcionalidade para trabalhar diretamente com a :term:`função de anotação`, "
"usada para avaliar anotações, como :func:`get_annotate_from_class_namespace` "
"e :func:`call_annotate_function`, bem como a função :func:"
"`call_evaluate_function` para trabalhar com :term:`funções de avaliação "
"<evaluate function>`."

#: ../../library/annotationlib.rst:51
msgid ""
":pep:`649` proposed the current model for how annotations work in Python."
msgstr ""
":pep:`649` propôs o modelo atual de como as anotações funcionam em Python."

#: ../../library/annotationlib.rst:53
msgid ""
":pep:`749` expanded on various aspects of :pep:`649` and introduced the :mod:"
"`!annotationlib` module."
msgstr ""
":pep:`749` expandiu vários aspectos de :pep:`649` e introduziu o módulo :mod:"
"`!annotationlib`."

#: ../../library/annotationlib.rst:56
msgid ""
":ref:`annotations-howto` provides best practices for working with "
"annotations."
msgstr ""
":ref:`annotations-howto` fornece práticas recomendadas para trabalhar com "
"anotações."

#: ../../library/annotationlib.rst:59
msgid ""
":pypi:`typing-extensions` provides a backport of :func:`get_annotations` "
"that works on earlier versions of Python."
msgstr ""
":pypi:`typing-extensions` fornece um backport de :func:`get_annotations` que "
"funciona em versões anteriores do Python."

#: ../../library/annotationlib.rst:63
msgid "Annotation semantics"
msgstr "Semânticas de anotação"

#: ../../library/annotationlib.rst:65
msgid ""
"The way annotations are evaluated has changed over the history of Python 3, "
"and currently still depends on a :ref:`future import <future>`. There have "
"been execution models for annotations:"
msgstr ""
"A forma como as anotações são avaliadas mudou ao longo da história do Python "
"3 e atualmente ainda depende de uma :ref:`importação futura <future>`. Houve "
"modelos de execução para anotações:"

#: ../../library/annotationlib.rst:69
msgid ""
"*Stock semantics* (default in Python 3.0 through 3.13; see :pep:`3107` and :"
"pep:`526`): Annotations are evaluated eagerly, as they are encountered in "
"the source code."
msgstr ""
"*Semântica de estoque* (padrão no Python 3.0 a 3.13; veja :pep:`3107` e :pep:"
"`526`): As anotações são avaliadas avidamente, à medida que são encontradas "
"no código-fonte."

#: ../../library/annotationlib.rst:72
msgid ""
"*Stringified annotations* (used with ``from __future__ import annotations`` "
"in Python 3.7 and newer; see :pep:`563`): Annotations are stored as strings "
"only."
msgstr ""
"*Anotações em string* (usadas com ``from __future__ import annotations`` no "
"Python 3.7 e versões mais recentes; veja :pep:`563`): As anotações são "
"armazenadas apenas como strings."

#: ../../library/annotationlib.rst:75
msgid ""
"*Deferred evaluation* (default in Python 3.14 and newer; see :pep:`649` and :"
"pep:`749`): Annotations are evaluated lazily, only when they are accessed."
msgstr ""
"*Avaliação adiada* (padrão no Python 3.14 e versões mais recentes; veja :pep:"
"`649` e :pep:`749`): As anotações são avaliadas preguiçosamente, somente "
"quando são acessadas."

#: ../../library/annotationlib.rst:78
msgid "As an example, consider the following program::"
msgstr "Como exemplo, considere o seguinte programa::"

#: ../../library/annotationlib.rst:80
msgid ""
"def func(a: Cls) -> None:\n"
"    print(a)\n"
"\n"
"class Cls: pass\n"
"\n"
"print(func.__annotations__)"
msgstr ""
"def func(a: Cls) -> None:\n"
"    print(a)\n"
"\n"
"class Cls: pass\n"
"\n"
"print(func.__annotations__)"

#: ../../library/annotationlib.rst:87
msgid "This will behave as follows:"
msgstr "Isso se comportará da seguinte maneira:"

#: ../../library/annotationlib.rst:89
msgid ""
"Under stock semantics (Python 3.13 and earlier), it will throw a :exc:"
"`NameError` at the line where ``func`` is defined, because ``Cls`` is an "
"undefined name at that point."
msgstr ""
"De acordo com a semântica de estoque (Python 3.13 e versões anteriores), ele "
"levantará uma :exc:`NameError` na linha onde ``func`` está definido, porque "
"``Cls`` é um nome indefinido naquele ponto."

#: ../../library/annotationlib.rst:92
msgid ""
"Under stringified annotations (if ``from __future__ import annotations`` is "
"used), it will print ``{'a': 'Cls', 'return': 'None'}``."
msgstr ""
"Em anotações stringificadas (se ``from __future__ import annotations`` for "
"usado), exibirá ``{'a': 'Cls', 'return': 'None'}``."

#: ../../library/annotationlib.rst:94
msgid ""
"Under deferred evaluation (Python 3.14 and later), it will print ``{'a': "
"<class 'Cls'>, 'return': None}``."
msgstr ""
"Em avaliação adiada (Python 3.14 e posterior), exibiirá ``{'a': <class "
"'Cls'>, 'return': None}``."

#: ../../library/annotationlib.rst:97
msgid ""
"Stock semantics were used when function annotations were first introduced in "
"Python 3.0 (by :pep:`3107`) because this was the simplest, most obvious way "
"to implement annotations. The same execution model was used when variable "
"annotations were introduced in Python 3.6 (by :pep:`526`). However, stock "
"semantics caused problems when using annotations as type hints, such as a "
"need to refer to names that are not yet defined when the annotation is "
"encountered. In addition, there were performance problems with executing "
"annotations at module import time. Therefore, in Python 3.7, :pep:`563` "
"introduced the ability to store annotations as strings using the ``from "
"__future__ import annotations`` syntax. The plan at the time was to "
"eventually make this behavior the default, but a problem appeared: "
"stringified annotations are more difficult to process for those who "
"introspect annotations at runtime. An alternative proposal, :pep:`649`, "
"introduced the third execution model, deferred evaluation, and was "
"implemented in Python 3.14. Stringified annotations are still used if ``from "
"__future__ import annotations`` is present, but this behavior will "
"eventually be removed."
msgstr ""
"A semântica de estoque foi usada quando as anotações de função foram "
"introduzidas pela primeira vez no Python 3.0 (por :pep:`3107`) porque esta "
"era a maneira mais simples e óbvia de implementar anotações. O mesmo modelo "
"de execução foi usado quando as anotações de variáveis foram introduzidas no "
"Python 3.6 (por :pep:`526`). No entanto, a semântica de estoque causou "
"problemas ao usar anotações como dicas de tipo, como a necessidade de se "
"referir a nomes que ainda não estavam definidos quando a anotação era "
"encontrada. Além disso, havia problemas de desempenho com a execução de "
"anotações no momento da importação do módulo. Portanto, no Python 3.7, :pep:"
"`563` introduziu a capacidade de armazenar anotações como strings usando a "
"sintaxe ``from __future__ import annotations``. O plano na época era "
"eventualmente tornar esse comportamento o padrão, mas um problema surgiu: "
"anotações em string são mais difíceis de processar para aqueles que "
"inspecionam anotações em tempo de execução. Uma proposta alternativa, :pep:"
"`649`, introduziu o terceiro modelo de execução, avaliação adiada, e foi "
"implementada no Python 3.14. Anotações em string ainda são usadas se ``from "
"__future__ import annotations`` estiver presente, mas esse comportamento "
"será eventualmente removido."

#: ../../library/annotationlib.rst:116
msgid "Classes"
msgstr "Classes"

#: ../../library/annotationlib.rst:120
msgid ""
"An :class:`~enum.IntEnum` describing the formats in which annotations can be "
"returned. Members of the enum, or their equivalent integer values, can be "
"passed to :func:`get_annotations` and other functions in this module, as "
"well as to :attr:`~object.__annotate__` functions."
msgstr ""
"Uma :class:`~enum.IntEnum` que descreve os formatos nos quais as anotações "
"podem ser retornadas. Membros da enumeração, ou seus valores inteiros "
"equivalentes, podem ser passados para :func:`get_annotations` e outras "
"funções neste módulo, bem como para funções :attr:`~object.__annotate__`."

#: ../../library/annotationlib.rst:128
msgid "Values are the result of evaluating the annotation expressions."
msgstr "Os valores são o resultado da avaliação das expressões de anotação."

#: ../../library/annotationlib.rst:133
msgid ""
"Special value used to signal that an annotate function is being evaluated in "
"a special environment with fake globals. When passed this value, annotate "
"functions should either return the same value as for the :attr:`Format."
"VALUE` format, or raise :exc:`NotImplementedError` to signal that they do "
"not support execution in this environment. This format is only used "
"internally and should not be passed to the functions in this module."
msgstr ""
"Valor especial usado para sinalizar que uma função de anotação está sendo "
"avaliada em um ambiente especial com variáveis globais falsas. Ao receber "
"este valor, as funções de anotação devem retornar o mesmo valor do formato :"
"attr:`Format.VALUE` ou levantar :exc:`NotImplementedError` para sinalizar "
"que não suportam execução neste ambiente. Este formato é usado apenas "
"internamente e não deve ser passado para as funções deste módulo."

#: ../../library/annotationlib.rst:144
msgid ""
"Values are real annotation values (as per :attr:`Format.VALUE` format) for "
"defined values, and :class:`ForwardRef` proxies for undefined values. Real "
"objects may contain references to :class:`ForwardRef` proxy objects."
msgstr ""
"Valores são valores de anotação reais (conforme o formato :attr:`Format."
"VALUE`) para valores definidos e proxies :class:`ForwardRef` para valores "
"indefinidos. Objetos reais podem conter referências a objetos proxy :class:"
"`ForwardRef`."

#: ../../library/annotationlib.rst:152
msgid ""
"Values are the text string of the annotation as it appears in the source "
"code, up to modifications including, but not restricted to, whitespace "
"normalizations and constant values optimizations."
msgstr ""
"Valores são a string de texto da anotação como ela aparece no código-fonte, "
"até modificações, incluindo, mas não se limitando a, normalizações de "
"espaços em branco e otimizações de valores constantes."

#: ../../library/annotationlib.rst:156
msgid ""
"The exact values of these strings may change in future versions of Python."
msgstr ""
"Os valores exatos dessas strings podem mudar em versões futuras do Python."

#: ../../library/annotationlib.rst:162
msgid "A proxy object for forward references in annotations."
msgstr "Um objeto proxy para referências futuras em anotações."

#: ../../library/annotationlib.rst:164
msgid ""
"Instances of this class are returned when the :attr:`~Format.FORWARDREF` "
"format is used and annotations contain a name that cannot be resolved. This "
"can happen when a forward reference is used in an annotation, such as when a "
"class is referenced before it is defined."
msgstr ""
"Instâncias desta classe são retornadas quando o formato :attr:`~Format."
"FORWARDREF` é usado e as anotações contêm um nome que não pode ser "
"resolvido. Isso pode acontecer quando uma referência de avanço é usada em "
"uma anotação, como quando uma classe é referenciada antes de ser definida."

#: ../../library/annotationlib.rst:171
msgid ""
"A string containing the code that was evaluated to produce the :class:"
"`~ForwardRef`. The string may not be exactly equivalent to the original "
"source."
msgstr ""
"Uma string contendo o código que foi avaliado para produzir :class:"
"`~ForwardRef`. A string pode não ser exatamente equivalente à fonte original."

#: ../../library/annotationlib.rst:177
msgid "Evaluate the forward reference, returning its value."
msgstr "Avalia a referência futura, retornando seu valor."

#: ../../library/annotationlib.rst:179
msgid ""
"If the *format* argument is :attr:`~Format.VALUE` (the default), this method "
"may throw an exception, such as :exc:`NameError`, if the forward reference "
"refers to a name that cannot be resolved. The arguments to this method can "
"be used to provide bindings for names that would otherwise be undefined. If "
"the *format* argument is :attr:`~Format.FORWARDREF`, the method will never "
"throw an exception, but may return a :class:`~ForwardRef` instance. For "
"example, if the forward reference object contains the code "
"``list[undefined]``, where ``undefined`` is a name that is not defined, "
"evaluating it with the :attr:`~Format.FORWARDREF` format will return "
"``list[ForwardRef('undefined')]``. If the *format* argument is :attr:"
"`~Format.STRING`, the method will return :attr:`~ForwardRef.__forward_arg__`."
msgstr ""
"Se o argumento *format* for :attr:`~Format.VALUE` (o padrão), este método "
"poderá levantar uma exceção, como :exc:`NameError`, caso a referência futura "
"se refira a um nome que não pode ser resolvido. Os argumentos deste método "
"podem ser usados para fornecer ligações para nomes que, de outra forma, "
"seriam indefinidos. Se o argumento *format* for :attr:`~Format.FORWARDREF`, "
"o método nunca levantará uma exceção, mas poderá retornar uma instância de :"
"class:`~ForwardRef`. Por exemplo, se o objeto de referência futura contiver "
"o código ``list[undefined]``, onde ``undefined`` é um nome que não está "
"definido, avaliá-lo com o formato :attr:`~Format.FORWARDREF` retornará "
"``list[ForwardRef('undefined')]``. Se o argumento *format* for :attr:"
"`~Format.STRING`, o método retornará :attr:`~ForwardRef.__forward_arg__`."

#: ../../library/annotationlib.rst:191
msgid ""
"The *owner* parameter provides the preferred mechanism for passing scope "
"information to this method. The owner of a :class:`~ForwardRef` is the "
"object that contains the annotation from which the :class:`~ForwardRef` "
"derives, such as a module object, type object, or function object."
msgstr ""
"O parâmetro *owner* fornece o mecanismo preferencial para passar informações "
"de escopo para este método. O proprietário de uma :class:`~ForwardRef` é o "
"objeto que contém a anotação da qual a :class:`~ForwardRef` deriva, como um "
"objeto módulo, objeto tipo ou objeto função."

#: ../../library/annotationlib.rst:196
msgid ""
"The *globals*, *locals*, and *type_params* parameters provide a more precise "
"mechanism for influencing the names that are available when the :class:"
"`~ForwardRef` is evaluated. *globals* and *locals* are passed to :func:"
"`eval`, representing the global and local namespaces in which the name is "
"evaluated. The *type_params* parameter is relevant for objects created using "
"the native syntax for :ref:`generic classes <generic-classes>` and :ref:"
"`functions <generic-functions>`. It is a tuple of :ref:`type parameters "
"<type-params>` that are in scope while the forward reference is being "
"evaluated. For example, if evaluating a :class:`~ForwardRef` retrieved from "
"an annotation found in the class namespace of a generic class ``C``, "
"*type_params* should be set to ``C.__type_params__``."
msgstr ""
"Os parâmetros *globals*, *locals* e *type_params* fornecem um mecanismo mais "
"preciso para influenciar os nomes disponíveis quando :class:`~ForwardRef` é "
"avaliado. *globals* e *locals* são passados para :func:`eval`, representando "
"os espaços de nomes global e local nos quais o nome é avaliado. O parâmetro "
"*type_params* é relevante para objetos criados usando a sintaxe nativa para :"
"ref:`classes genéricas <generic-classes>` e :ref:`funções <generic-"
"functions>`. É uma tupla de :ref:`parâmetros de tipo <type-params>` que "
"estão no escopo enquanto a referência futura está sendo avaliada. Por "
"exemplo, ao avaliar um :class:`~ForwardRef` recuperado de uma anotação "
"encontrada no espaço de nomes de classe de uma classe genérica ``C``, "
"*type_params* deve ser definido como ``C.__type_params__``."

#: ../../library/annotationlib.rst:207
msgid ""
":class:`~ForwardRef` instances returned by :func:`get_annotations` retain "
"references to information about the scope they originated from, so calling "
"this method with no further arguments may be sufficient to evaluate such "
"objects. :class:`~ForwardRef` instances created by other means may not have "
"any information about their scope, so passing arguments to this method may "
"be necessary to evaluate them successfully."
msgstr ""
"Instâncias de :class:`~ForwardRef` retornadas por :func:`get_annotations` "
"retêm referências a informações sobre o escopo de onde se originaram, "
"portanto, chamar esse método sem argumentos adicionais pode ser suficiente "
"para avaliar tais objetos. Instâncias de :class:`~ForwardRef` criadas por "
"outros meios podem não ter nenhuma informação sobre seu escopo, portanto, "
"passar argumentos para esse método pode ser necessário para avaliá-las com "
"sucesso."

#: ../../library/annotationlib.rst:214
msgid ""
"If no *owner*, *globals*, *locals*, or *type_params* are provided and the :"
"class:`~ForwardRef` does not contain information about its origin, empty "
"globals and locals dictionaries are used."
msgstr ""
"Se nenhum entre *owner*, *globals*, *locals* ou *type_params* for fornecido "
"e :class:`~ForwardRef` não contiver informações sobre sua origem, "
"dicionários globals e locals vazios serão usados."

#: ../../library/annotationlib.rst:222
msgid "Functions"
msgstr "Funções"

#: ../../library/annotationlib.rst:226
msgid ""
"Convert an annotations dict containing runtime values to a dict containing "
"only strings. If the values are not already strings, they are converted "
"using :func:`type_repr`. This is meant as a helper for user-provided "
"annotate functions that support the :attr:`~Format.STRING` format but do not "
"have access to the code creating the annotations."
msgstr ""
"Converte um dicionário de anotações contendo valores de tempo de execução em "
"um dicionário contendo apenas strings. Se os valores ainda não forem "
"strings, eles serão convertidos usando :func:`type_repr`. Isso serve como um "
"auxiliar para funções de anotação fornecidas pelo usuário que oferecem "
"suporte ao formato :attr:`~Format.STRING`, mas não têm acesso ao código que "
"cria as anotações."

#: ../../library/annotationlib.rst:233
msgid ""
"For example, this is used to implement the :attr:`~Format.STRING` for :class:"
"`typing.TypedDict` classes created through the functional syntax:"
msgstr ""
"Por exemplo, isso é usado para implementar o :attr:`~Format.STRING` para "
"classes :class:`typing.TypedDict` criadas por meio da sintaxe funcional:"

#: ../../library/annotationlib.rst:236
msgid ""
">>> from typing import TypedDict\n"
">>> Movie = TypedDict(\"movie\", {\"name\": str, \"year\": int})\n"
">>> get_annotations(Movie, format=Format.STRING)\n"
"{'name': 'str', 'year': 'int'}"
msgstr ""
">>> from typing import TypedDict\n"
">>> Movie = TypedDict(\"movie\", {\"name\": str, \"year\": int})\n"
">>> get_annotations(Movie, format=Format.STRING)\n"
"{'name': 'str', 'year': 'int'}"

#: ../../library/annotationlib.rst:247
msgid ""
"Call the :term:`annotate function` *annotate* with the given *format*, a "
"member of the :class:`Format` enum, and return the annotations dictionary "
"produced by the function."
msgstr ""
"Chama a :term:`função de anotação` *annotate* com o *format* fornecido, um "
"membro da enumeração :class:`Format` e retorne o dicionário de anotações "
"produzido pela função."

#: ../../library/annotationlib.rst:251
msgid ""
"This helper function is required because annotate functions generated by the "
"compiler for functions, classes, and modules only support the :attr:`~Format."
"VALUE` format when called directly. To support other formats, this function "
"calls the annotate function in a special environment that allows it to "
"produce annotations in the other formats. This is a useful building block "
"when implementing functionality that needs to partially evaluate annotations "
"while a class is being constructed."
msgstr ""
"Esta função auxiliar é necessária porque as funções de anotação geradas pelo "
"compilador para funções, classes e módulos oferecem suporte a apenas o "
"formato :attr:`~Format.VALUE` quando chamadas diretamente. Para oferecer "
"suporte a outros formatos, esta função chama a função de anotação em um "
"ambiente especial que permite a produção de anotações nos outros formatos. "
"Este é um bloco de construção útil ao implementar funcionalidades que "
"precisam avaliar anotações parcialmente enquanto uma classe está sendo "
"construída."

#: ../../library/annotationlib.rst:260
msgid ""
"*owner* is the object that owns the annotation function, usually a function, "
"class, or module. If provided, it is used in the :attr:`~Format.FORWARDREF` "
"format to produce a :class:`ForwardRef` object that carries more information."
msgstr ""
"*owner* é o objeto que possui a função de anotação, geralmente uma função, "
"classe ou módulo. Se fornecido, é usado no formato :attr:`~Format."
"FORWARDREF` para produzir um objeto :class:`ForwardRef` que contém mais "
"informações."

#: ../../library/annotationlib.rst:267
msgid ""
":PEP:`PEP 649 <649#the-stringizer-and-the-fake-globals-environment>` "
"contains an explanation of the implementation technique used by this "
"function."
msgstr ""
":PEP:`PEP 649 <649#the-stringizer-and-the-fake-globals-environment>` contém "
"uma explicação da técnica de implementação usada por esta função."

#: ../../library/annotationlib.rst:275
msgid ""
"Call the :term:`evaluate function` *evaluate* with the given *format*, a "
"member of the :class:`Format` enum, and return the value produced by the "
"function. This is similar to :func:`call_annotate_function`, but the latter "
"always returns a dictionary mapping strings to annotations, while this "
"function returns a single value."
msgstr ""
"Chama a :term:`função de avaliação` *evaluate* com o *format* fornecido, um "
"membro da enumeração :class:`Format` e retorna o valor produzido pela "
"função. Isso é semelhante a :func:`call_annotate_function`, mas esta última "
"sempre retorna um dicionário que mapeia strings para anotações, enquanto "
"esta função retorna um único valor."

#: ../../library/annotationlib.rst:281
msgid ""
"This is intended for use with the evaluate functions generated for lazily "
"evaluated elements related to type aliases and type parameters:"
msgstr ""
"Isso se destina ao uso com as funções de avaliação geradas para elementos "
"avaliados preguiçosamente relacionados a apelidos de tipo e parâmetros de "
"tipo:"

#: ../../library/annotationlib.rst:284
msgid ":meth:`typing.TypeAliasType.evaluate_value`, the value of type aliases"
msgstr ""
":meth:`typing.TypeAliasType.evaluate_value`, o valor dos apelidos de tipo"

#: ../../library/annotationlib.rst:285
msgid ":meth:`typing.TypeVar.evaluate_bound`, the bound of type variables"
msgstr ""
":meth:`typing.TypeVar.evaluate_bound`, a delimitação das variáveis de tipo"

#: ../../library/annotationlib.rst:286
msgid ""
":meth:`typing.TypeVar.evaluate_constraints`, the constraints of type "
"variables"
msgstr ""
":meth:`typing.TypeVar.evaluate_constraints`, as restrições de tipos variáveis"

#: ../../library/annotationlib.rst:288
msgid ""
":meth:`typing.TypeVar.evaluate_default`, the default value of type variables"
msgstr ""
":meth:`typing.TypeVar.evaluate_default`, o valor padrão de tipos variáveis"

#: ../../library/annotationlib.rst:290
msgid ""
":meth:`typing.ParamSpec.evaluate_default`, the default value of parameter "
"specifications"
msgstr ""
":meth:`typing.ParamSpec.evaluate_default`, o valor padrão de especificações "
"de parâmetros"

#: ../../library/annotationlib.rst:292
msgid ""
":meth:`typing.TypeVarTuple.evaluate_default`, the default value of type "
"variable tuples"
msgstr ""
":meth:`typing.TypeVarTuple.evaluate_default`, o valor padrão de tuplas de "
"tipos variáveis"

#: ../../library/annotationlib.rst:295
msgid ""
"*owner* is the object that owns the evaluate function, such as the type "
"alias or type variable object."
msgstr ""
"*owner* é o objeto que possui a função de avaliação, como o apelido de tipo "
"ou o objeto de tipo variável."

#: ../../library/annotationlib.rst:298
msgid ""
"*format* can be used to control the format in which the value is returned:"
msgstr ""
"*format* pode ser usado para controlar o formato no qual o valor é retornado:"

#: ../../library/annotationlib.rst:300
msgid ""
">>> type Alias = undefined\n"
">>> call_evaluate_function(Alias.evaluate_value, Format.VALUE)\n"
"Traceback (most recent call last):\n"
"...\n"
"NameError: name 'undefined' is not defined\n"
">>> call_evaluate_function(Alias.evaluate_value, Format.FORWARDREF)\n"
"ForwardRef('undefined')\n"
">>> call_evaluate_function(Alias.evaluate_value, Format.STRING)\n"
"'undefined'"
msgstr ""
">>> type Alias = undefined\n"
">>> call_evaluate_function(Alias.evaluate_value, Format.VALUE)\n"
"Traceback (most recent call last):\n"
"...\n"
"NameError: name 'undefined' is not defined\n"
">>> call_evaluate_function(Alias.evaluate_value, Format.FORWARDREF)\n"
"ForwardRef('undefined')\n"
">>> call_evaluate_function(Alias.evaluate_value, Format.STRING)\n"
"'undefined'"

#: ../../library/annotationlib.rst:316
msgid ""
"Retrieve the :term:`annotate function` from a class namespace dictionary "
"*namespace*. Return :const:`!None` if the namespace does not contain an "
"annotate function. This is primarily useful before the class has been fully "
"created (e.g., in a metaclass); after the class exists, the annotate "
"function can be retrieved with ``cls.__annotate__``. See :ref:`below "
"<annotationlib-metaclass>` for an example using this function in a metaclass."
msgstr ""
"Recupera a :term:`função de anotação` de um dicionário de espaço de nomes de "
"classe *namespace*. Retorna :const:`!None` se o espaço de nomes não contiver "
"uma função de anotação. Isso é útil principalmente antes da classe ser "
"totalmente criada (por exemplo, em uma metaclasse); após a classe existir, a "
"função de anotação pode ser recuperada com ``cls.__annotate__``. Veja :ref:"
"`abaixo <annotationlib-metaclass>` para um exemplo usando esta função em uma "
"metaclasse."

#: ../../library/annotationlib.rst:326
msgid "Compute the annotations dict for an object."
msgstr "Calcula o dicionário de anotações para um objeto."

#: ../../library/annotationlib.rst:328
msgid ""
"*obj* may be a callable, class, module, or other object with :attr:`~object."
"__annotate__` or :attr:`~object.__annotations__` attributes. Passing any "
"other object raises :exc:`TypeError`."
msgstr ""
"*obj* pode ser um objeto chamável, classe, módulo ou outro objeto com os "
"atributos :attr:`~object.__annotate__` ou :attr:`~object.__annotations__`. "
"Passar qualquer outro objeto levanta :exc:`TypeError`."

#: ../../library/annotationlib.rst:332
msgid ""
"The *format* parameter controls the format in which annotations are "
"returned, and must be a member of the :class:`Format` enum or its integer "
"equivalent. The different formats work as follows:"
msgstr ""
"O parâmetro *format* controla o formato em que as anotações são retornadas e "
"deve ser um membro da enumeração :class:`Format` ou seu equivalente inteiro. "
"Os diferentes formatos funcionam da seguinte forma:"

#: ../../library/annotationlib.rst:336
msgid ""
"VALUE: :attr:`!object.__annotations__` is tried first; if that does not "
"exist, the :attr:`!object.__annotate__` function is called if it exists."
msgstr ""
"VALUE: :attr:`!object.__annotations__` é tentado primeiro; se não existir, a "
"função :attr:`!object.__annotate__` é chamada, se existir."

#: ../../library/annotationlib.rst:338
msgid ""
"FORWARDREF: If :attr:`!object.__annotations__` exists and can be evaluated "
"successfully, it is used; otherwise, the :attr:`!object.__annotate__` "
"function is called. If it does not exist either, :attr:`!object."
"__annotations__` is tried again and any error from accessing it is re-raised."
msgstr ""
"FORWARDREF: Se :attr:`!object.__annotations__` existir e puder ser avaliado "
"com sucesso, ele será usado; caso contrário, a função :attr:`!object."
"__annotate__` será chamada. Se também não existir, :attr:`!object."
"__annotations__` será tentado novamente e qualquer erro ao acessá-lo será "
"levantado novamente."

#: ../../library/annotationlib.rst:342
msgid ""
"STRING: If :attr:`!object.__annotate__` exists, it is called first; "
"otherwise, :attr:`!object.__annotations__` is used and stringified using :"
"func:`annotations_to_string`."
msgstr ""
"STRING: Se :attr:`!object.__annotate__` existir, ele será chamado primeiro; "
"caso contrário, :attr:`!object.__annotations__` será usado e transformado em "
"string usando :func:`annotations_to_string`."

#: ../../library/annotationlib.rst:346
msgid ""
"Returns a dict. :func:`!get_annotations` returns a new dict every time it's "
"called; calling it twice on the same object will return two different but "
"equivalent dicts."
msgstr ""
"Retorna um dict. :func:`!get_annotations` retorna um novo dict toda vez que "
"é chamado; chamá-lo duas vezes no mesmo objeto retornará dois dicts "
"diferentes, mas equivalentes."

#: ../../library/annotationlib.rst:350
msgid "This function handles several details for you:"
msgstr "Esta função cuida de vários detalhes para você:"

#: ../../library/annotationlib.rst:352
msgid ""
"If *eval_str* is true, values of type :class:`!str` will be un-stringized "
"using :func:`eval`. This is intended for use with stringized annotations "
"(``from __future__ import annotations``). It is an error to set *eval_str* "
"to true with formats other than :attr:`Format.VALUE`."
msgstr ""
"Se *eval_str* for verdadeiro, valores do tipo :class:`!str` serão "
"descodificados usando :func:`eval`. Isso se destina ao uso com anotações "
"transformadas em string (``from __future__ import annotations``). É um erro "
"definir *eval_str* como true com formatos diferentes de :attr:`Format.VALUE`."

#: ../../library/annotationlib.rst:357
msgid ""
"If *obj* doesn't have an annotations dict, returns an empty dict. (Functions "
"and methods always have an annotations dict; classes, modules, and other "
"types of callables may not.)"
msgstr ""
"Se *obj* não tiver um dicionário de anotações, retorna um dicionário vazio. "
"(Funções e métodos sempre têm um dicionário de anotações; classes, módulos e "
"outros tipos de chamáveis podem não ter.)"

#: ../../library/annotationlib.rst:361
msgid ""
"Ignores inherited annotations on classes, as well as annotations on "
"metaclasses. If a class doesn't have its own annotations dict, returns an "
"empty dict."
msgstr ""
"Ignora anotações herdadas em classes, bem como anotações em metaclasses. Se "
"uma classe não tiver seu próprio dicionário de anotações, retorna um "
"dicionário vazio."

#: ../../library/annotationlib.rst:364
msgid ""
"All accesses to object members and dict values are done using ``getattr()`` "
"and ``dict.get()`` for safety."
msgstr ""
"Todos os acessos aos membros do objeto e valores do dicionário são feitos "
"usando ``getattr()`` e ``dict.get()`` por segurança."

#: ../../library/annotationlib.rst:367
msgid ""
"*eval_str* controls whether or not values of type :class:`!str` are replaced "
"with the result of calling :func:`eval` on those values:"
msgstr ""
"*eval_str* controla se valores do tipo :class:`!str` são substituídos ou não "
"pelo resultado da chamada de :func:`eval` nesses valores:"

#: ../../library/annotationlib.rst:370
msgid ""
"If eval_str is true, :func:`eval` is called on values of type :class:`!str`. "
"(Note that :func:`!get_annotations` doesn't catch exceptions; if :func:"
"`eval` raises an exception, it will unwind the stack past the :func:`!"
"get_annotations` call.)"
msgstr ""
"Se eval_str for verdadeiro, :func:`eval` será chamado em valores do tipo :"
"class:`!str`. (Observe que :func:`!get_annotations` não captura exceções; "
"se :func:`eval` levanta uma exceção, ele desenrolará a pilha após a chamada "
"de :func:`!get_annotations`.)"

#: ../../library/annotationlib.rst:374
msgid ""
"If *eval_str* is false (the default), values of type :class:`!str` are "
"unchanged."
msgstr ""
"Se *eval_str* for falso (o padrão), os valores do tipo :class:`!str` não "
"serão alterados."

#: ../../library/annotationlib.rst:377
msgid ""
"*globals* and *locals* are passed in to :func:`eval`; see the documentation "
"for :func:`eval` for more information. If *globals* or *locals* is :const:`!"
"None`, this function may replace that value with a context-specific default, "
"contingent on ``type(obj)``:"
msgstr ""
"*globals* e *locals* são passados para :func:`eval`; consulte a documentação "
"de :func:`eval` para mais informações. Se *globals* ou *locals* for :const:`!"
"None`, esta função pode substituir esse valor por um padrão específico do "
"contexto, dependendo de ``type(obj)``:"

#: ../../library/annotationlib.rst:382
msgid "If *obj* is a module, *globals* defaults to ``obj.__dict__``."
msgstr "Se *obj* for um módulo, *globals* assume como padrão ``obj.__dict__``."

#: ../../library/annotationlib.rst:383
msgid ""
"If *obj* is a class, *globals* defaults to ``sys.modules[obj.__module__]."
"__dict__`` and *locals* defaults to the *obj* class namespace."
msgstr ""
"Se *obj* for uma classe, *globals* assume como padrão ``sys.modules[obj."
"__module__].__dict__`` e *locals* assume como padrão o espaço de nomes da "
"classe *obj*."

#: ../../library/annotationlib.rst:386
msgid ""
"If *obj* is a callable, *globals* defaults to :attr:`obj.__globals__ "
"<function.__globals__>`, although if *obj* is a wrapped function (using :"
"func:`functools.update_wrapper`) or a :class:`functools.partial` object, it "
"is unwrapped until a non-wrapped function is found."
msgstr ""
"Se *obj* for um chamável, *globals* assume como padrão :attr:`obj."
"__globals__ <function.__globals__>`, embora se *obj* for uma função "
"encapsulada (usando :func:`functools.update_wrapper`) ou um objeto :class:"
"`functools.partial`, ela será desencapsulada até que uma função não "
"encapsulada seja encontrada."

#: ../../library/annotationlib.rst:392
msgid ""
"Calling :func:`!get_annotations` is best practice for accessing the "
"annotations dict of any object. See :ref:`annotations-howto` for more "
"information on annotations best practices."
msgstr ""
"Chamar :func:`!get_annotations` é uma boa prática para acessar o dicionário "
"de anotações de qualquer objeto. Consulte :ref:`annotations-howto` para "
"obter mais informações sobre as práticas recomendadas para anotações."

#: ../../library/annotationlib.rst:396
msgid ""
">>> def f(a: int, b: str) -> float:\n"
"...     pass\n"
">>> get_annotations(f)\n"
"{'a': <class 'int'>, 'b': <class 'str'>, 'return': <class 'float'>}"
msgstr ""
">>> def f(a: int, b: str) -> float:\n"
"...     pass\n"
">>> get_annotations(f)\n"
"{'a': <class 'int'>, 'b': <class 'str'>, 'return': <class 'float'>}"

#: ../../library/annotationlib.rst:407
msgid ""
"Convert an arbitrary Python value to a format suitable for use by the :attr:"
"`~Format.STRING` format. This calls :func:`repr` for most objects, but has "
"special handling for some objects, such as type objects."
msgstr ""
"Converte um valor Python arbitrário para um formato adequado para uso pelo "
"formato :attr:`~Format.STRING`. Isso chama :func:`repr` para a maioria dos "
"objetos, mas tem um tratamento especial para alguns objetos, como objetos "
"tipo."

#: ../../library/annotationlib.rst:411
msgid ""
"This is meant as a helper for user-provided annotate functions that support "
"the :attr:`~Format.STRING` format but do not have access to the code "
"creating the annotations. It can also be used to provide a user-friendly "
"string representation for other objects that contain values that are "
"commonly encountered in annotations."
msgstr ""
"Isto serve como um auxiliar para funções de anotação fornecidas pelo usuário "
"que oferecem suporte ao formato :attr:`~Format.STRING`, mas não têm acesso "
"ao código que cria as anotações. Também pode ser usado para fornecer uma "
"representação de string amigável para outros objetos que contêm valores "
"comumente encontrados em anotações."

#: ../../library/annotationlib.rst:421
msgid "Recipes"
msgstr "Receitas"

#: ../../library/annotationlib.rst:426
msgid "Using annotations in a metaclass"
msgstr "Usando anotações em uma metaclasse"

#: ../../library/annotationlib.rst:428
msgid ""
"A :ref:`metaclass <metaclasses>` may want to inspect or even modify the "
"annotations in a class body during class creation. Doing so requires "
"retrieving annotations from the class namespace dictionary. For classes "
"created with ``from __future__ import annotations``, the annotations will be "
"in the ``__annotations__`` key of the dictionary. For other classes with "
"annotations, :func:`get_annotate_from_class_namespace` can be used to get "
"the annotate function, and :func:`call_annotate_function` can be used to "
"call it and retrieve the annotations. Using the :attr:`~Format.FORWARDREF` "
"format will usually be best, because this allows the annotations to refer to "
"names that cannot yet be resolved when the class is created."
msgstr ""
"Uma :ref:`metaclasse <metaclasses>` pode querer inspecionar ou até mesmo "
"modificar as anotações no corpo de uma classe durante a criação da classe. "
"Isso requer a recuperação das anotações do dicionário de espaços de nomes da "
"classe. Para classes criadas com ``from __future__ import annotations``, as "
"anotações estarão na chave ``__annotations__`` do dicionário. Para outras "
"classes com anotações, :func:`get_annotate_from_class_namespace` pode ser "
"usado para obter a função annotate, e :func:`call_annotate_function` pode "
"ser usado para chamá-la e recuperar as anotações. Usar o formato :attr:"
"`~Format.FORWARDREF` geralmente é a melhor opção, pois permite que as "
"anotações se refiram a nomes que ainda não podem ser resolvidos quando a "
"classe é criada."

#: ../../library/annotationlib.rst:439
msgid ""
"To modify the annotations, it is best to create a wrapper annotate function "
"that calls the original annotate function, makes any necessary adjustments, "
"and returns the result."
msgstr ""
"Para modificar as anotações, é melhor criar uma função de anotação que chame "
"a função de anotação original, faça os ajustes necessários e retorne o "
"resultado."

#: ../../library/annotationlib.rst:443
msgid ""
"Below is an example of a metaclass that filters out all :class:`typing."
"ClassVar` annotations from the class and puts them in a separate attribute:"
msgstr ""
"Abaixo está um exemplo de uma metaclasse que filtra todas as anotações :"
"class:`typing.ClassVar` da classe e as coloca em um atributo separado:"

#: ../../library/annotationlib.rst:446
msgid ""
"import annotationlib\n"
"import typing\n"
"\n"
"class ClassVarSeparator(type):\n"
"   def __new__(mcls, name, bases, ns):\n"
"      if \"__annotations__\" in ns:  # from __future__ import annotations\n"
"         annotations = ns[\"__annotations__\"]\n"
"         classvar_keys = {\n"
"            key for key, value in annotations.items()\n"
"            # Use string comparison for simplicity; a more robust solution\n"
"            # could use annotationlib.ForwardRef.evaluate\n"
"            if value.startswith(\"ClassVar\")\n"
"         }\n"
"         classvars = {key: annotations[key] for key in classvar_keys}\n"
"         ns[\"__annotations__\"] = {\n"
"            key: value for key, value in annotations.items()\n"
"            if key not in classvar_keys\n"
"         }\n"
"         wrapped_annotate = None\n"
"      elif annotate := annotationlib.get_annotate_from_class_namespace(ns):\n"
"         annotations = annotationlib.call_annotate_function(\n"
"            annotate, format=annotationlib.Format.FORWARDREF\n"
"         )\n"
"         classvar_keys = {\n"
"            key for key, value in annotations.items()\n"
"            if typing.get_origin(value) is typing.ClassVar\n"
"         }\n"
"         classvars = {key: annotations[key] for key in classvar_keys}\n"
"\n"
"         def wrapped_annotate(format):\n"
"            annos = annotationlib.call_annotate_function(annotate, format, "
"owner=typ)\n"
"            return {key: value for key, value in annos.items() if key not in "
"classvar_keys}\n"
"\n"
"      else:  # no annotations\n"
"         classvars = {}\n"
"         wrapped_annotate = None\n"
"      typ = super().__new__(mcls, name, bases, ns)\n"
"\n"
"      if wrapped_annotate is not None:\n"
"         # Wrap the original __annotate__ with a wrapper that removes "
"ClassVars\n"
"         typ.__annotate__ = wrapped_annotate\n"
"      typ.classvars = classvars  # Store the ClassVars in a separate "
"attribute\n"
"      return typ"
msgstr ""
"import annotationlib\n"
"import typing\n"
"\n"
"class ClassVarSeparator(type):\n"
"   def __new__(mcls, name, bases, ns):\n"
"      if \"__annotations__\" in ns:  # from __future__ import annotations\n"
"         annotations = ns[\"__annotations__\"]\n"
"         classvar_keys = {\n"
"            key for key, value in annotations.items()\n"
"            # Use comparação de strings para simplificar; uma solução\n"
"            # mais robusta poderia usar annotationlib.ForwardRef.evaluate\n"
"            if value.startswith(\"ClassVar\")\n"
"         }\n"
"         classvars = {key: annotations[key] for key in classvar_keys}\n"
"         ns[\"__annotations__\"] = {\n"
"            key: value for key, value in annotations.items()\n"
"            if key not in classvar_keys\n"
"         }\n"
"         wrapped_annotate = None\n"
"      elif annotate := annotationlib.get_annotate_from_class_namespace(ns):\n"
"         annotations = annotationlib.call_annotate_function(\n"
"            annotate, format=annotationlib.Format.FORWARDREF\n"
"         )\n"
"         classvar_keys = {\n"
"            key for key, value in annotations.items()\n"
"            if typing.get_origin(value) is typing.ClassVar\n"
"         }\n"
"         classvars = {key: annotations[key] for key in classvar_keys}\n"
"\n"
"         def wrapped_annotate(format):\n"
"            annos = annotationlib.call_annotate_function(annotate, format, "
"owner=typ)\n"
"            return {key: value for key, value in annos.items() if key not in "
"classvar_keys}\n"
"\n"
"      else:  # nenhuma anotação\n"
"         classvars = {}\n"
"         wrapped_annotate = None\n"
"      typ = super().__new__(mcls, name, bases, ns)\n"
"\n"
"      if wrapped_annotate is not None:\n"
"         # Encapsula o __annotate__ original com um invólucro que remove "
"ClassVars\n"
"         typ.__annotate__ = wrapped_annotate\n"
"      typ.classvars = classvars  # Armazena as ClassVars em um atributo "
"separado\n"
"      return typ"

#: ../../library/annotationlib.rst:494
msgid "Limitations of the ``STRING`` format"
msgstr "Limitações do formato ``STRING``"

#: ../../library/annotationlib.rst:496
msgid ""
"The :attr:`~Format.STRING` format is meant to approximate the source code of "
"the annotation, but the implementation strategy used means that it is not "
"always possible to recover the exact source code."
msgstr ""
"O formato :attr:`~Format.STRING` tem como objetivo aproximar o código-fonte "
"da anotação, mas a estratégia de implementação usada significa que nem "
"sempre é possível recuperar o código-fonte exato."

#: ../../library/annotationlib.rst:500
msgid ""
"First, the stringifier of course cannot recover any information that is not "
"present in the compiled code, including comments, whitespace, "
"parenthesization, and operations that get simplified by the compiler."
msgstr ""
"Primeiro, a transformação em string, é claro, não pode recuperar nenhuma "
"informação que não esteja presente no código compilado, incluindo "
"comentários, espaços em branco, parênteses e operações que são simplificadas "
"pelo compilador."

#: ../../library/annotationlib.rst:504
msgid ""
"Second, the stringifier can intercept almost all operations that involve "
"names looked up in some scope, but it cannot intercept operations that "
"operate fully on constants. As a corollary, this also means it is not safe "
"to request the ``STRING`` format on untrusted code: Python is powerful "
"enough that it is possible to achieve arbitrary code execution even with no "
"access to any globals or builtins. For example:"
msgstr ""
"Em segundo lugar, a transformação em string pode interceptar quase todas as "
"operações que envolvem nomes pesquisados em algum escopo, mas não pode "
"interceptar operações que operem totalmente em constantes. Como corolário, "
"isso também significa que não é seguro solicitar o formato ``STRING`` em "
"código não confiável: Python é poderoso o suficiente para permitir a "
"execução arbitrária de código mesmo sem acesso a nenhuma variável global ou "
"embutida. Por exemplo:"

#: ../../library/annotationlib.rst:510
msgid ""
">>> def f(x: (1).__class__.__base__.__subclasses__()[-1].__init__."
"__builtins__[\"print\"](\"Hello world\")): pass\n"
"...\n"
">>> annotationlib.get_annotations(f, format=annotationlib.Format.STRING)\n"
"Hello world\n"
"{'x': 'None'}"
msgstr ""

#: ../../library/annotationlib.rst:519
msgid ""
"This particular example works as of the time of writing, but it relies on "
"implementation details and is not guaranteed to work in the future."
msgstr ""
"Este exemplo específico funciona no momento em que este artigo foi escrito, "
"mas depende de detalhes de implementação e não há garantia de que funcionará "
"no futuro."

#: ../../library/annotationlib.rst:522
msgid ""
"Among the different kinds of expressions that exist in Python, as "
"represented by the :mod:`ast` module, some expressions are supported, "
"meaning that the ``STRING`` format can generally recover the original source "
"code; others are unsupported, meaning that they may result in incorrect "
"output or an error."
msgstr ""
"Entre os diferentes tipos de expressões que existem em Python, conforme "
"representado pelo módulo :mod:`ast`, algumas expressões são suportadas, o "
"que significa que o formato ``STRING`` geralmente pode recuperar o código-"
"fonte original; outras não são suportadas, o que significa que podem "
"resultar em saída incorreta ou erro."

#: ../../library/annotationlib.rst:527
msgid "The following are supported (sometimes with caveats):"
msgstr "Os seguintes são aceitos (às vezes com ressalvas):"

#: ../../library/annotationlib.rst:529
msgid ":class:`ast.BinOp`"
msgstr ":class:`ast.BinOp`"

#: ../../library/annotationlib.rst:530
msgid ":class:`ast.UnaryOp`"
msgstr ":class:`ast.UnaryOp`"

#: ../../library/annotationlib.rst:532
msgid ""
":class:`ast.Invert` (``~``), :class:`ast.UAdd` (``+``), and :class:`ast."
"USub` (``-``) are supported"
msgstr ""
":class:`ast.Invert` (``~``), :class:`ast.UAdd` (``+``) e :class:`ast.USub` "
"(``-``) são suportadas"

#: ../../library/annotationlib.rst:533
msgid ":class:`ast.Not` (``not``) is not supported"
msgstr ":class:`ast.Not` (``not``) não é suportada"

#: ../../library/annotationlib.rst:535
msgid ":class:`ast.Dict` (except when using ``**`` unpacking)"
msgstr ":class:`ast.Dict` (exceto ao usar desempacotamento ``**``)"

#: ../../library/annotationlib.rst:536
msgid ":class:`ast.Set`"
msgstr ":class:`ast.Set`"

#: ../../library/annotationlib.rst:537
msgid ":class:`ast.Compare`"
msgstr ":class:`ast.Compare`"

#: ../../library/annotationlib.rst:539
msgid ":class:`ast.Eq` and :class:`ast.NotEq` are supported"
msgstr ":class:`ast.Eq` e :class:`ast.NotEq` são suportadas"

#: ../../library/annotationlib.rst:540
msgid ""
":class:`ast.Lt`, :class:`ast.LtE`, :class:`ast.Gt`, and :class:`ast.GtE` are "
"supported, but the operand may be flipped"
msgstr ""
":class:`ast.Lt`, :class:`ast.LtE`, :class:`ast.Gt` e :class:`ast.GtE` são "
"suportadas, mas o operando pode ser invertido"

#: ../../library/annotationlib.rst:541
msgid ""
":class:`ast.Is`, :class:`ast.IsNot`, :class:`ast.In`, and :class:`ast.NotIn` "
"are not supported"
msgstr ""
":class:`ast.Is`, :class:`ast.IsNot`, :class:`ast.In` e :class:`ast.NotIn` "
"não são suportadas"

#: ../../library/annotationlib.rst:543
msgid ":class:`ast.Call` (except when using ``**`` unpacking)"
msgstr ":class:`ast.Call` (exceto ao usar desempacotamento ``**``)"

#: ../../library/annotationlib.rst:544
msgid ""
":class:`ast.Constant` (though not the exact representation of the constant; "
"for example, escape sequences in strings are lost; hexadecimal numbers are "
"converted to decimal)"
msgstr ""
":class:`ast.Constant` (embora não seja a representação exata da constante; "
"por exemplo, sequências de escape em strings são perdidas; números "
"hexadecimais são convertidos em decimais)"

#: ../../library/annotationlib.rst:546
msgid ":class:`ast.Attribute` (assuming the value is not a constant)"
msgstr ":class:`ast.Attribute` (presumindo que o valor não é uma constante)"

#: ../../library/annotationlib.rst:547
msgid ":class:`ast.Subscript` (assuming the value is not a constant)"
msgstr ":class:`ast.Subscript` (presumindo que o valor não é uma constante)"

#: ../../library/annotationlib.rst:548
msgid ":class:`ast.Starred` (``*`` unpacking)"
msgstr ":class:`ast.Starred` (desempacotamento ``*``)"

#: ../../library/annotationlib.rst:549
msgid ":class:`ast.Name`"
msgstr ":class:`ast.Name`"

#: ../../library/annotationlib.rst:550
msgid ":class:`ast.List`"
msgstr ":class:`ast.List`"

#: ../../library/annotationlib.rst:551
msgid ":class:`ast.Tuple`"
msgstr ":class:`ast.Tuple`"

#: ../../library/annotationlib.rst:552
msgid ":class:`ast.Slice`"
msgstr ":class:`ast.Slice`"

#: ../../library/annotationlib.rst:554
msgid ""
"The following are unsupported, but throw an informative error when "
"encountered by the stringifier:"
msgstr ""
"Os seguintes não são suportados, mas geram um erro informativo quando "
"encontrados pela transformação em string:"

#: ../../library/annotationlib.rst:557
msgid ""
":class:`ast.FormattedValue` (f-strings; error is not detected if conversion "
"specifiers like ``!r`` are used)"
msgstr ""
":class:`ast.FormattedValue` (f-strings; o erro não é detectado se "
"especificadores de conversões como ``!r`` forem usados)"

#: ../../library/annotationlib.rst:559
msgid ":class:`ast.JoinedStr` (f-strings)"
msgstr ":class:`ast.JoinedStr` (f-strings)"

#: ../../library/annotationlib.rst:561
msgid "The following are unsupported and result in incorrect output:"
msgstr "Os seguintes itens não são suportados e resultam em saída incorreta:"

#: ../../library/annotationlib.rst:563
msgid ":class:`ast.BoolOp` (``and`` and ``or``)"
msgstr ":class:`ast.BoolOp` (``and`` e ``or``)"

#: ../../library/annotationlib.rst:564
msgid ":class:`ast.IfExp`"
msgstr ":class:`ast.IfExp`"

#: ../../library/annotationlib.rst:565
msgid ":class:`ast.Lambda`"
msgstr ":class:`ast.Lambda`"

#: ../../library/annotationlib.rst:566
msgid ":class:`ast.ListComp`"
msgstr ":class:`ast.ListComp`"

#: ../../library/annotationlib.rst:567
msgid ":class:`ast.SetComp`"
msgstr ":class:`ast.SetComp`"

#: ../../library/annotationlib.rst:568
msgid ":class:`ast.DictComp`"
msgstr ":class:`ast.DictComp`"

#: ../../library/annotationlib.rst:569
msgid ":class:`ast.GeneratorExp`"
msgstr ":class:`ast.GeneratorExp`"

#: ../../library/annotationlib.rst:571
msgid ""
"The following are disallowed in annotation scopes and therefore not relevant:"
msgstr ""
"Os seguintes itens não são permitidos em escopos de anotação e, portanto, "
"não são relevantes:"

#: ../../library/annotationlib.rst:573
msgid ":class:`ast.NamedExpr` (``:=``)"
msgstr ":class:`ast.NamedExpr` (``:=``)"

#: ../../library/annotationlib.rst:574
msgid ":class:`ast.Await`"
msgstr ":class:`ast.Await`"

#: ../../library/annotationlib.rst:575
msgid ":class:`ast.Yield`"
msgstr ":class:`ast.Yield`"

#: ../../library/annotationlib.rst:576
msgid ":class:`ast.YieldFrom`"
msgstr ":class:`ast.YieldFrom`"

#: ../../library/annotationlib.rst:580
msgid "Limitations of the ``FORWARDREF`` format"
msgstr "Limitações do formato ``FORWARDREF``"

#: ../../library/annotationlib.rst:582
msgid ""
"The :attr:`~Format.FORWARDREF` format aims to produce real values as much as "
"possible, with anything that cannot be resolved replaced with :class:"
"`ForwardRef` objects. It is affected by broadly the same Limitations as the :"
"attr:`~Format.STRING` format: annotations that perform operations on "
"literals or that use unsupported expression types may raise exceptions when "
"evaluated using the :attr:`~Format.FORWARDREF` format."
msgstr ""
"O formato :attr:`~Format.FORWARDREF` visa produzir valores reais o máximo "
"possível, com tudo o que não puder ser resolvido sendo substituído por "
"objetos :class:`ForwardRef`. Ele é afetado, em linhas gerais, pelas mesmas "
"limitações do formato :attr:`~Format.STRING`: anotações que realizam "
"operações em literais ou que usam tipos de expressão não suportados podem "
"levantar exceções quando avaliadas usando o formato :attr:`~Format."
"FORWARDREF`."

#: ../../library/annotationlib.rst:589
msgid "Below are a few examples of the behavior with unsupported expressions:"
msgstr ""
"Abaixo estão alguns exemplos do comportamento com expressões não suportadas:"

#: ../../library/annotationlib.rst:591
msgid ""
">>> from annotationlib import get_annotations, Format\n"
">>> def zerodiv(x: 1 / 0): ...\n"
">>> get_annotations(zerodiv, format=Format.STRING)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero\n"
">>> get_annotations(zerodiv, format=Format.FORWARDREF)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero\n"
">>> def ifexp(x: 1 if y else 0): ...\n"
">>> get_annotations(ifexp, format=Format.STRING)\n"
"{'x': '1'}"
msgstr ""
">>> from annotationlib import get_annotations, Format\n"
">>> def zerodiv(x: 1 / 0): ...\n"
">>> get_annotations(zerodiv, format=Format.STRING)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero\n"
">>> get_annotations(zerodiv, format=Format.FORWARDREF)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero\n"
">>> def ifexp(x: 1 if y else 0): ...\n"
">>> get_annotations(ifexp, format=Format.STRING)\n"
"{'x': '1'}"

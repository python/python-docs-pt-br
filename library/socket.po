# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# felipe caridade fernandes <caridade500@gmail.com>, 2019
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 17:51+0000\n"
"PO-Revision-Date: 2017-02-16 23:26+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/socket.rst:2
msgid ":mod:`socket` --- Low-level networking interface"
msgstr ":mod:`socket` --- Interface de rede de baixo nível"

#: ../../library/socket.rst:7
msgid "**Source code:** :source:`Lib/socket.py`"
msgstr "**Código-fonte:** :source:`Lib/socket.py`"

#: ../../library/socket.rst:11
msgid ""
"This module provides access to the BSD *socket* interface. It is available "
"on all modern Unix systems, Windows, MacOS, and probably additional "
"platforms."
msgstr ""
"Este módulo provê acesso à interface de *soquete* do BSD. Está disponível em "
"todos os sistemas modernos Unix, Windows, MacOS e provavelmente outras "
"plataformas."

#: ../../library/socket.rst:16
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs."
msgstr ""
"Algum comportamento pode depender da plataforma, pois as chamadas são feitas "
"para as APIs de soquete do sistema operacional."

#: ../../library/socket.rst:21
msgid ""
"The Python interface is a straightforward transliteration of the Unix system "
"call and library interface for sockets to Python's object-oriented style: "
"the :func:`.socket` function returns a :dfn:`socket object` whose methods "
"implement the various socket system calls.  Parameter types are somewhat "
"higher-level than in the C interface: as with :meth:`read` and :meth:`write` "
"operations on Python files, buffer allocation on receive operations is "
"automatic, and buffer length is implicit on send operations."
msgstr ""
"A interface Python é uma transliteração direta da chamada de sistema e "
"interface de biblioteca de soquetes do Unix para o estilo orientado a "
"objetos do Python: a função :func:`.socket` retorna um :dfn:`objeto socket` "
"cujos métodos implementam as diversas chamadas de sistema de soquetes. Os "
"tipos de parâmetro são consideravelmente de nível mais alto que os da "
"interface em C: assim como as operações :meth:`read` e :meth:`write`  em "
"arquivos Python, a alocação de buffer em operações de recebimento é "
"automática, e o comprimento do buffer é implícito em operações de envio."

#: ../../library/socket.rst:33
msgid "Module :mod:`socketserver`"
msgstr "Módulo :mod:`socketserver`"

#: ../../library/socket.rst:33
msgid "Classes that simplify writing network servers."
msgstr "Classes que simplificam a escrita de servidores de rede."

#: ../../library/socket.rst:35
msgid "Module :mod:`ssl`"
msgstr "Módulo :mod:`ssl`"

#: ../../library/socket.rst:36
msgid "A TLS/SSL wrapper for socket objects."
msgstr "Um invólucro de TLS/SSL para objetos socket."

#: ../../library/socket.rst:40
msgid "Socket families"
msgstr "Famílias de soquete"

#: ../../library/socket.rst:42
msgid ""
"Depending on the system and the build options, various socket families are "
"supported by this module."
msgstr ""
"Dependendo do sistema e das opções de construção, várias famílias de "
"soquetes são suportadas por este módulo."

#: ../../library/socket.rst:45
msgid ""
"The address format required by a particular socket object is automatically "
"selected based on the address family specified when the socket object was "
"created.  Socket addresses are represented as follows:"
msgstr ""
"O formato de endereço requerido por um objeto socket em particular é "
"selecionado automaticamente com base na família de endereços especificada "
"quando o objeto socket foi criado. Endereços de socket são representados da "
"seguinte forma:"

#: ../../library/socket.rst:49
msgid ""
"The address of an :const:`AF_UNIX` socket bound to a file system node is "
"represented as a string, using the file system encoding and the "
"``'surrogateescape'`` error handler (see :pep:`383`).  An address in Linux's "
"abstract namespace is returned as a :term:`bytes-like object` with an "
"initial null byte; note that sockets in this namespace can communicate with "
"normal file system sockets, so programs intended to run on Linux may need to "
"deal with both types of address.  A string or bytes-like object can be used "
"for either type of address when passing it as an argument."
msgstr ""
"O endereço de um socket :const:`AF_UNIX` vinculado a um nó do sistema de "
"arquivos é representado como uma string, usando a codificação do sistema de "
"arquivos e o tratador de erros ``'surrogateescape'`` (veja :pep:`383`). Um "
"endereço no espaço de nomes abstrato do Linux é retornado como um :term:"
"`objeto bytes ou similar` com um byte nulo inicial; observe que os sockets "
"neste espaço de nomes podem se comunicar com sockets normais do sistema de "
"arquivos, então programas destinados a rodar no Linux podem precisar lidar "
"com ambos os tipos de endereço. Uma string ou um objeto bytes ou similar "
"pode ser usado para qualquer tipo de endereço ao passá-lo como um argumento."

#: ../../library/socket.rst:59
msgid ""
"Previously, :const:`AF_UNIX` socket paths were assumed to use UTF-8 encoding."
msgstr ""
"Раніше вважалося, що шляхи сокетів :const:`AF_UNIX` використовували "
"кодування UTF-8."

#: ../../library/socket.rst:63 ../../library/socket.rst:970
#: ../../library/socket.rst:1012 ../../library/socket.rst:1742
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "Записуваний :term:`bytes-like object` тепер приймається."

#: ../../library/socket.rst:68
msgid ""
"A pair ``(host, port)`` is used for the :const:`AF_INET` address family, "
"where *host* is a string representing either a hostname in Internet domain "
"notation like ``'daring.cwi.nl'`` or an IPv4 address like "
"``'100.50.200.5'``, and *port* is an integer."
msgstr ""

#: ../../library/socket.rst:73
msgid ""
"For IPv4 addresses, two special forms are accepted instead of a host "
"address: ``''`` represents :const:`INADDR_ANY`, which is used to bind to all "
"interfaces, and the string ``'<broadcast>'`` represents :const:"
"`INADDR_BROADCAST`.  This behavior is not compatible with IPv6, therefore, "
"you may want to avoid these if you intend to support IPv6 with your Python "
"programs."
msgstr ""
"Для адрес IPv4 приймаються дві спеціальні форми замість адреси хоста: ``''`` "
"представляє :const:`INADDR_ANY`, який використовується для прив’язки до всіх "
"інтерфейсів, а рядок ``' <broadcast> ''`` представляє  :const:"
"`INADDR_BROADCAST`. Така поведінка несумісна з IPv6, тому ви можете уникнути "
"цього, якщо ви маєте намір підтримувати IPv6 у своїх програмах на Python."

#: ../../library/socket.rst:80
msgid ""
"For :const:`AF_INET6` address family, a four-tuple ``(host, port, flowinfo, "
"scope_id)`` is used, where *flowinfo* and *scope_id* represent the "
"``sin6_flowinfo`` and ``sin6_scope_id`` members in :const:`struct "
"sockaddr_in6` in C.  For :mod:`socket` module methods, *flowinfo* and "
"*scope_id* can be omitted just for backward compatibility.  Note, however, "
"omission of *scope_id* can cause problems in manipulating scoped IPv6 "
"addresses."
msgstr ""
"Для родини адрес :const:`AF_INET6` використовується чотирикортеж ``(host, "
"port, flowinfo, scope_id)``, де *flowinfo* та *scope_id* представляють "
"``sin6_flowinfo`` та ``sin6_scope_id`` члени в :const:`struct sockaddr_in6` "
"в C. Для методів модуля :mod:`socket` *flowinfo* та *scope_id* можна "
"опустити тільки для зворотної сумісності. Однак зауважте, що пропуск "
"*scope_id* може спричинити проблеми під час маніпулювання адресами IPv6 із "
"областю дії."

#: ../../library/socket.rst:87
msgid ""
"For multicast addresses (with *scope_id* meaningful) *address* may not "
"contain ``%scope_id`` (or ``zone id``) part. This information is superfluous "
"and may be safely omitted (recommended)."
msgstr ""
"Для багатоадресних адрес (зі значенням *scope_id*) *address* не може містити "
"частину ``%scope_id`` (або ``zone id``). Ця інформація є зайвою, і її можна "
"сміливо опустити (рекомендовано)."

#: ../../library/socket.rst:92
msgid ":const:`AF_NETLINK` sockets are represented as pairs ``(pid, groups)``."
msgstr ":const:`AF_NETLINK` сокети представлені як пари ``(pid, groups)``."

#: ../../library/socket.rst:94
msgid ""
"Linux-only support for TIPC is available using the :const:`AF_TIPC` address "
"family.  TIPC is an open, non-IP based networked protocol designed for use "
"in clustered computer environments.  Addresses are represented by a tuple, "
"and the fields depend on the address type. The general tuple form is "
"``(addr_type, v1, v2, v3 [, scope])``, where:"
msgstr ""
"Підтримка TIPC лише для Linux доступна за допомогою родини адрес :const:"
"`AF_TIPC`. TIPC — це відкритий мережевий протокол не на основі IP, "
"призначений для використання в кластерних комп’ютерних середовищах. Адреси "
"представлені кортежем, а поля залежать від типу адреси. Загальна форма "
"кортежу ``(addr_type, v1, v2, v3 [, scope])``, де:"

#: ../../library/socket.rst:100
msgid ""
"*addr_type* is one of :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, "
"or :const:`TIPC_ADDR_ID`."
msgstr ""
"*addr_type* є одним із :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME` "
"або :const:`TIPC_ADDR_ID`."

#: ../../library/socket.rst:102
msgid ""
"*scope* is one of :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, "
"and :const:`TIPC_NODE_SCOPE`."
msgstr ""
"*scope* є одним із :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE` та :"
"const:`TIPC_NODE_SCOPE`."

#: ../../library/socket.rst:104
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAME`, then *v1* is the server type, "
"*v2* is the port identifier, and *v3* should be 0."
msgstr ""
"Якщо *addr_type* дорівнює :const:`TIPC_ADDR_NAME`, тоді *v1* — це тип "
"сервера, *v2* — ідентифікатор порту, а *v3* має бути 0."

#: ../../library/socket.rst:107
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAMESEQ`, then *v1* is the server type, "
"*v2* is the lower port number, and *v3* is the upper port number."
msgstr ""
"Якщо *addr_type* дорівнює :const:`TIPC_ADDR_NAMESEQ`, то *v1* — це тип "
"сервера, *v2* — нижній номер порту, а *v3* — верхній номер порту."

#: ../../library/socket.rst:110
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_ID`, then *v1* is the node, *v2* is the "
"reference, and *v3* should be set to 0."
msgstr ""
"Якщо *addr_type* дорівнює :const:`TIPC_ADDR_ID`, тоді *v1* є вузлом, *v2* є "
"посиланням, а *v3* має бути встановлено на 0."

#: ../../library/socket.rst:113
msgid ""
"A tuple ``(interface, )`` is used for the :const:`AF_CAN` address family, "
"where *interface* is a string representing a network interface name like "
"``'can0'``. The network interface name ``''`` can be used to receive packets "
"from all network interfaces of this family."
msgstr ""
"Кортеж ``(інтерфейс, )`` використовується для сімейства адрес :const:"
"`AF_CAN`, де *інтерфейс* — це рядок, що представляє назву мережевого "
"інтерфейсу, наприклад ``'can0'``. Ім'я мережевого інтерфейсу ``''`` можна "
"використовувати для отримання пакетів від усіх мережевих інтерфейсів цього "
"сімейства."

#: ../../library/socket.rst:118
msgid ""
":const:`CAN_ISOTP` protocol require a tuple ``(interface, rx_addr, "
"tx_addr)`` where both additional parameters are unsigned long integer that "
"represent a CAN identifier (standard or extended)."
msgstr ""
"Протокол :const:`CAN_ISOTP` вимагає кортеж ``(interface, rx_addr, "
"tx_addr)``, де обидва додаткові параметри є довгим цілим числом без знаку, "
"що представляє ідентифікатор CAN (стандартний або розширений)."

#: ../../library/socket.rst:121
msgid ""
":const:`CAN_J1939` protocol require a tuple ``(interface, name, pgn, addr)`` "
"where additional parameters are 64-bit unsigned integer representing the ECU "
"name, a 32-bit unsigned integer representing the Parameter Group Number "
"(PGN), and an 8-bit integer representing the address."
msgstr ""
"Протокол :const:`CAN_J1939` вимагає кортеж ``(interface, name, pgn, addr)``, "
"де додаткові параметри є 64-розрядним цілим числом без знака, що представляє "
"назву ECU, 32-розрядним цілим числом без знака, що представляє номер групи "
"параметрів (PGN ) і 8-бітове ціле число, що представляє адресу."

#: ../../library/socket.rst:126
msgid ""
"A string or a tuple ``(id, unit)`` is used for the :const:`SYSPROTO_CONTROL` "
"protocol of the :const:`PF_SYSTEM` family. The string is the name of a "
"kernel control using a dynamically-assigned ID. The tuple can be used if ID "
"and unit number of the kernel control are known or if a registered ID is "
"used."
msgstr ""

#: ../../library/socket.rst:134
msgid ""
":const:`AF_BLUETOOTH` supports the following protocols and address formats:"
msgstr ":const:`AF_BLUETOOTH` підтримує наступні протоколи та формати адрес:"

#: ../../library/socket.rst:137
msgid ""
":const:`BTPROTO_L2CAP` accepts ``(bdaddr, psm)`` where ``bdaddr`` is the "
"Bluetooth address as a string and ``psm`` is an integer."
msgstr ""
":const:`BTPROTO_L2CAP` приймає ``(bdaddr, psm)``, де ``bdaddr`` — адреса "
"Bluetooth у вигляді рядка, а ``psm`` — ціле число."

#: ../../library/socket.rst:140
msgid ""
":const:`BTPROTO_RFCOMM` accepts ``(bdaddr, channel)`` where ``bdaddr`` is "
"the Bluetooth address as a string and ``channel`` is an integer."
msgstr ""
":const:`BTPROTO_RFCOMM` приймає ``(bdaddr, канал)``, де ``bdaddr`` — це "
"адреса Bluetooth у вигляді рядка, а ``channel`` — ціле число."

#: ../../library/socket.rst:143
msgid ""
":const:`BTPROTO_HCI` accepts ``(device_id,)`` where ``device_id`` is either "
"an integer or a string with the Bluetooth address of the interface. (This "
"depends on your OS; NetBSD and DragonFlyBSD expect a Bluetooth address while "
"everything else expects an integer.)"
msgstr ""
":const:`BTPROTO_HCI` приймає ``(device_id,)``, де ``device_id`` є або цілим "
"числом, або рядком з адресою Bluetooth інтерфейсу. (Це залежить від вашої "
"ОС; NetBSD і DragonFlyBSD очікують адресу Bluetooth, а всі інші очікують "
"ціле число.)"

#: ../../library/socket.rst:148
msgid "NetBSD and DragonFlyBSD support added."
msgstr "Додано підтримку NetBSD і DragonFlyBSD."

#: ../../library/socket.rst:151
msgid ""
":const:`BTPROTO_SCO` accepts ``bdaddr`` where ``bdaddr`` is a :class:`bytes` "
"object containing the Bluetooth address in a string format. (ex. "
"``b'12:23:34:45:56:67'``) This protocol is not supported under FreeBSD."
msgstr ""
":const:`BTPROTO_SCO` приймає ``bdaddr``, де ``bdaddr`` є об'єктом :class:"
"`bytes`, що містить адресу Bluetooth у форматі рядка. (наприклад, "
"``b'12:23:34:45:56:67''``) Цей протокол не підтримується FreeBSD."

#: ../../library/socket.rst:156
msgid ""
":const:`AF_ALG` is a Linux-only socket based interface to Kernel "
"cryptography. An algorithm socket is configured with a tuple of two to four "
"elements ``(type, name [, feat [, mask]])``, where:"
msgstr ""
":const:`AF_ALG` — це інтерфейс для криптографії ядра на основі сокетів лише "
"для Linux. Сокет алгоритму налаштований за допомогою кортежу з двох-чотирьох "
"елементів ``(type, name [, feat [, mask]])``, де:"

#: ../../library/socket.rst:160
msgid ""
"*type* is the algorithm type as string, e.g. ``aead``, ``hash``, "
"``skcipher`` or ``rng``."
msgstr ""
"*type* — це тип алгоритму як рядок, напр. ``aead``, ``hash``, ``skcipher`` "
"або ``rng``."

#: ../../library/socket.rst:163
msgid ""
"*name* is the algorithm name and operation mode as string, e.g. ``sha256``, "
"``hmac(sha256)``, ``cbc(aes)`` or ``drbg_nopr_ctr_aes256``."
msgstr ""
"*ім’я* — це назва алгоритму та режим роботи у вигляді рядка, напр. "
"``sha256``, ``hmac(sha256)``, ``cbc(aes)`` або ``drbg_nopr_ctr_aes256``."

#: ../../library/socket.rst:166
msgid "*feat* and *mask* are unsigned 32bit integers."
msgstr "*feat* і *mask* — це 32-розрядні цілі числа без знаку."

#: ../../library/socket.rst:172
msgid ""
":const:`AF_VSOCK` allows communication between virtual machines and their "
"hosts. The sockets are represented as a ``(CID, port)`` tuple where the "
"context ID or CID and port are integers."
msgstr ""
":const:`AF_VSOCK` дозволяє спілкуватися між віртуальними машинами та їх "
"хостами. Сокети представлені як кортеж ``(CID, порт)``, де ідентифікатор "
"контексту або CID і порт є цілими числами."

#: ../../library/socket.rst:180
msgid ""
":const:`AF_PACKET` is a low-level interface directly to network devices. The "
"packets are represented by the tuple ``(ifname, proto[, pkttype[, hatype[, "
"addr]]])`` where:"
msgstr ""
":const:`AF_PACKET` — це низькорівневий інтерфейс безпосередньо до мережевих "
"пристроїв. Пакети представлені кортежем ``(ifname, proto[, pkttype[, "
"hatype[, addr]]])``, де:"

#: ../../library/socket.rst:184
msgid "*ifname* - String specifying the device name."
msgstr "*ifname* - Рядок, що визначає назву пристрою."

#: ../../library/socket.rst:185
msgid ""
"*proto* - An in network-byte-order integer specifying the Ethernet protocol "
"number."
msgstr ""
"*proto* – ціле число в мережевому порядку байтів, що визначає номер "
"протоколу Ethernet."

#: ../../library/socket.rst:187
msgid "*pkttype* - Optional integer specifying the packet type:"
msgstr "*pkttype* - додаткове ціле число, що вказує тип пакета:"

#: ../../library/socket.rst:189
msgid "``PACKET_HOST`` (the default) - Packet addressed to the local host."
msgstr ""
"``PACKET_HOST`` (за замовчуванням) - пакет, адресований локальному хосту."

#: ../../library/socket.rst:190
msgid "``PACKET_BROADCAST`` - Physical-layer broadcast packet."
msgstr "``PACKET_BROADCAST`` - широкомовний пакет фізичного рівня."

#: ../../library/socket.rst:191
msgid ""
"``PACKET_MULTIHOST`` - Packet sent to a physical-layer multicast address."
msgstr ""
"``PACKET_MULTIHOST`` - Пакет надіслано на багатоадресну адресу фізичного "
"рівня."

#: ../../library/socket.rst:192
msgid ""
"``PACKET_OTHERHOST`` - Packet to some other host that has been caught by a "
"device driver in promiscuous mode."
msgstr ""
"``PACKET_OTHERHOST`` - Пакет до іншого хосту, який був перехоплений "
"драйвером пристрою в безладному режимі."

#: ../../library/socket.rst:194
msgid ""
"``PACKET_OUTGOING`` - Packet originating from the local host that is looped "
"back to a packet socket."
msgstr ""
"``PACKET_OUTGOING`` – Пакет, що надходить від локального хосту і "
"повертається до сокета пакета."

#: ../../library/socket.rst:196
msgid "*hatype* - Optional integer specifying the ARP hardware address type."
msgstr "*hatype* – додаткове ціле число, що визначає тип апаратної адреси ARP."

#: ../../library/socket.rst:197
msgid ""
"*addr* - Optional bytes-like object specifying the hardware physical "
"address, whose interpretation depends on the device."
msgstr ""
"*addr* – необов’язковий байтовий об’єкт, що вказує апаратну фізичну адресу, "
"інтерпретація якої залежить від пристрою."

#: ../../library/socket.rst:202
msgid ""
":const:`AF_QIPCRTR` is a Linux-only socket based interface for communicating "
"with services running on co-processors in Qualcomm platforms. The address "
"family is represented as a ``(node, port)`` tuple where the *node* and "
"*port* are non-negative integers."
msgstr ""
":const:`AF_QIPCRTR` — це інтерфейс на основі сокетів лише для Linux для "
"зв’язку зі службами, що працюють на співпроцесорах на платформах Qualcomm. "
"Сімейство адрес представлено як кортеж ``(вузол, порт)``, де *вузол* і "
"*порт* є невід’ємними цілими числами."

#: ../../library/socket.rst:211
msgid ""
":const:`IPPROTO_UDPLITE` is a variant of UDP which allows you to specify "
"what portion of a packet is covered with the checksum. It adds two socket "
"options that you can change. ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_SEND_CSCOV, length)`` will change what portion of outgoing packets "
"are covered by the checksum and ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_RECV_CSCOV, length)`` will filter out packets which cover too little "
"of their data. In both cases ``length`` should be in ``range(8, 2**16, 8)``."
msgstr ""
":const:`IPPROTO_UDPLITE` — це варіант UDP, який дозволяє вказати, яку "
"частину пакету охоплює контрольна сума. Він додає два варіанти розеток, які "
"ви можете змінити. ``self.setsockopt(IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV, "
"length)`` змінить частину вихідних пакетів, охоплених контрольною сумою, а "
"``self.setsockopt(IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV, length)`` "
"відфільтровує пакети, які покривають занадто мало їхні дані. В обох випадках "
"``довжина`` має бути в ``діапазоні (8, 2**16, 8)``."

#: ../../library/socket.rst:220
msgid ""
"Such a socket should be constructed with ``socket(AF_INET, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv4 or ``socket(AF_INET6, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv6."
msgstr ""
"Такий сокет має бути створений за допомогою ``socket(AF_INET, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` для IPv4 або ``socket(AF_INET6, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` для IPv6."

#: ../../library/socket.rst:228
msgid ""
"If you use a hostname in the *host* portion of IPv4/v6 socket address, the "
"program may show a nondeterministic behavior, as Python uses the first "
"address returned from the DNS resolution.  The socket address will be "
"resolved differently into an actual IPv4/v6 address, depending on the "
"results from DNS resolution and/or the host configuration.  For "
"deterministic behavior use a numeric address in *host* portion."
msgstr ""
"Якщо ви використовуєте ім’я хоста в частині *host* адреси сокета IPv4/v6, "
"програма може продемонструвати недетерміновану поведінку, оскільки Python "
"використовує першу адресу, повернуту з вирішення DNS. Адреса сокета буде "
"перетворена по-іншому в фактичну адресу IPv4/v6, залежно від результатів "
"розв’язання DNS та/або конфігурації хоста. Для детермінованої поведінки "
"використовуйте числову адресу в частині *host*."

#: ../../library/socket.rst:235
msgid ""
"All errors raise exceptions.  The normal exceptions for invalid argument "
"types and out-of-memory conditions can be raised; starting from Python 3.3, "
"errors related to socket or address semantics raise :exc:`OSError` or one of "
"its subclasses (they used to raise :exc:`socket.error`)."
msgstr ""

#: ../../library/socket.rst:240
msgid ""
"Non-blocking mode is supported through :meth:`~socket.setblocking`.  A "
"generalization of this based on timeouts is supported through :meth:`~socket."
"settimeout`."
msgstr ""
"Неблокуючий режим підтримується через :meth:`~socket.setblocking`. "
"Узагальнення цього на основі тайм-аутів підтримується через :meth:`~socket."
"settimeout`."

#: ../../library/socket.rst:246
msgid "Module contents"
msgstr "Conteúdo do módulo"

#: ../../library/socket.rst:248
msgid "The module :mod:`socket` exports the following elements."
msgstr "Модуль :mod:`socket` експортує такі елементи."

#: ../../library/socket.rst:252
msgid "Exceptions"
msgstr "Exceções"

#: ../../library/socket.rst:256
msgid "A deprecated alias of :exc:`OSError`."
msgstr "Um apelido descontinuado de :exc:`OSError`."

#: ../../library/socket.rst:258
msgid "Following :pep:`3151`, this class was made an alias of :exc:`OSError`."
msgstr ""
"Seguindo a :pep:`3151`, esta classe foi transformada em um apelido de :exc:"
"`OSError`."

#: ../../library/socket.rst:264
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors, i.e. for functions that use *h_errno* in the POSIX C API, including :"
"func:`gethostbyname_ex` and :func:`gethostbyaddr`. The accompanying value is "
"a pair ``(h_errno, string)`` representing an error returned by a library "
"call.  *h_errno* is a numeric value, while *string* represents the "
"description of *h_errno*, as returned by the :c:func:`hstrerror` C function."
msgstr ""
"Підклас :exc:`OSError`, цей виняток виникає для помилок, пов’язаних з "
"адресою, тобто для функцій, які використовують *h_errno* в POSIX C API, "
"включаючи :func:`gethostbyname_ex` і :func:`gethostbyaddr`. Супровідним "
"значенням є пара ``(h_errno, string)``, яка представляє помилку, яку "
"повертає виклик бібліотеки. *h_errno* — це числове значення, тоді як "
"*string* представляє опис *h_errno*, який повертає функція :c:func:"
"`hstrerror` C."

#: ../../library/socket.rst:272 ../../library/socket.rst:285
#: ../../library/socket.rst:296
msgid "This class was made a subclass of :exc:`OSError`."
msgstr "Цей клас було створено підкласом :exc:`OSError`."

#: ../../library/socket.rst:277
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors by :func:`getaddrinfo` and :func:`getnameinfo`. The accompanying "
"value is a pair ``(error, string)`` representing an error returned by a "
"library call.  *string* represents the description of *error*, as returned "
"by the :c:func:`gai_strerror` C function.  The numeric *error* value will "
"match one of the :const:`EAI_\\*` constants defined in this module."
msgstr ""
"Підклас :exc:`OSError`, цей виняток створюється для помилок, пов’язаних з "
"адресою, :func:`getaddrinfo` і :func:`getnameinfo`. Супровідним значенням є "
"пара ``(помилка, рядок)``, яка представляє помилку, яку повертає виклик "
"бібліотеки. *рядок* представляє опис *помилки*, яку повертає функція C :c:"
"func:`gai_strerror`. Числове значення *помилки* відповідатиме одній із "
"констант :const:`EAI_\\*`, визначених у цьому модулі."

#: ../../library/socket.rst:290
msgid ""
"A subclass of :exc:`OSError`, this exception is raised when a timeout occurs "
"on a socket which has had timeouts enabled via a prior call to :meth:"
"`~socket.settimeout` (or implicitly through :func:`~socket."
"setdefaulttimeout`).  The accompanying value is a string whose value is "
"currently always \"timed out\"."
msgstr ""
"Підклас :exc:`OSError`, цей виняток виникає, коли тайм-аут виникає в сокеті, "
"для якого було ввімкнено тайм-аути через попередній виклик :meth:`~socket."
"settimeout` (або неявно через :func:`~socket .setdefaulttimeout`). "
"Супровідне значення - це рядок, значення якого наразі завжди \"закінчено\"."

#: ../../library/socket.rst:301
msgid "Constants"
msgstr "Constantes"

#: ../../library/socket.rst:303
msgid ""
"The AF_* and SOCK_* constants are now :class:`AddressFamily` and :class:"
"`SocketKind` :class:`.IntEnum` collections."
msgstr ""
"Константи AF_* і SOCK_* тепер є колекціями :class:`AddressFamily` і :class:"
"`SocketKind` :class:`.IntEnum`."

#: ../../library/socket.rst:312
msgid ""
"These constants represent the address (and protocol) families, used for the "
"first argument to :func:`.socket`.  If the :const:`AF_UNIX` constant is not "
"defined then this protocol is unsupported.  More constants may be available "
"depending on the system."
msgstr ""
"Ці константи представляють родини адрес (і протоколів), які використовуються "
"для першого аргументу :func:`.socket`. Якщо константа :const:`AF_UNIX` не "
"визначена, цей протокол не підтримується. Залежно від системи можуть бути "
"доступні інші константи."

#: ../../library/socket.rst:324
msgid ""
"These constants represent the socket types, used for the second argument to :"
"func:`.socket`.  More constants may be available depending on the system. "
"(Only :const:`SOCK_STREAM` and :const:`SOCK_DGRAM` appear to be generally "
"useful.)"
msgstr ""
"Ці константи представляють типи сокетів, які використовуються для другого "
"аргументу :func:`.socket`. Залежно від системи можуть бути доступні інші "
"константи. (Лише :const:`SOCK_STREAM` і :const:`SOCK_DGRAM` здаються загалом "
"корисними.)"

#: ../../library/socket.rst:332
msgid ""
"These two constants, if defined, can be combined with the socket types and "
"allow you to set some flags atomically (thus avoiding possible race "
"conditions and the need for separate calls)."
msgstr ""
"Ці дві константи, якщо їх визначено, можна комбінувати з типами сокетів і "
"дозволити вам встановлювати деякі прапори атомарно (таким чином уникаючи "
"можливих умов змагання та потреби в окремих викликах)."

#: ../../library/socket.rst:338
msgid ""
"`Secure File Descriptor Handling <http://udrepper.livejournal.com/20407."
"html>`_ for a more thorough explanation."
msgstr ""

#: ../../library/socket.rst:342
msgid ":ref:`Availability <availability>`: Linux >= 2.6.27."
msgstr ":ref:`Disponibilidade <availability>`: Linux >= 2.6.27."

#: ../../library/socket.rst:360
msgid ""
"Many constants of these forms, documented in the Unix documentation on "
"sockets and/or the IP protocol, are also defined in the socket module. They "
"are generally used in arguments to the :meth:`setsockopt` and :meth:"
"`getsockopt` methods of socket objects.  In most cases, only those symbols "
"that are defined in the Unix header files are defined; for a few symbols, "
"default values are provided."
msgstr ""
"Багато констант цих форм, задокументованих у документації Unix щодо сокетів "
"та/або протоколу IP, також визначені в модулі сокета. Зазвичай вони "
"використовуються в аргументах методів :meth:`setsockopt` і :meth:"
"`getsockopt` об'єктів сокета. У більшості випадків визначаються лише ті "
"символи, які визначені у файлах заголовків Unix; для кількох символів "
"надаються значення за замовчуванням."

#: ../../library/socket.rst:367
msgid ""
"``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION`` were added."
msgstr ""
"Додано ``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION``."

#: ../../library/socket.rst:371
msgid ""
"On Windows, ``TCP_FASTOPEN``, ``TCP_KEEPCNT`` appear if run-time Windows "
"supports."
msgstr ""
"У Windows відображаються ``TCP_FASTOPEN``, ``TCP_KEEPCNT``, якщо Windows "
"підтримує режим виконання."

#: ../../library/socket.rst:375
msgid "``TCP_NOTSENT_LOWAT`` was added."
msgstr "``TCP_NOTSENT_LOWAT`` було додано."

#: ../../library/socket.rst:378
msgid ""
"On Windows, ``TCP_KEEPIDLE``, ``TCP_KEEPINTVL`` appear if run-time Windows "
"supports."
msgstr ""
"У Windows відображаються ``TCP_KEEPIDLE``, ``TCP_KEEPINTVL``, якщо Windows "
"підтримує режим виконання."

#: ../../library/socket.rst:386 ../../library/socket.rst:453
#: ../../library/socket.rst:464
msgid ""
"Many constants of these forms, documented in the Linux documentation, are "
"also defined in the socket module."
msgstr ""
"Багато констант цих форм, задокументованих у документації Linux, також "
"визначені в модулі сокета."

#: ../../library/socket.rst:390 ../../library/socket.rst:401
#: ../../library/socket.rst:436
msgid ":ref:`Availability <availability>`: Linux >= 2.6.25."
msgstr ":ref:`Disponibilidade <availability>`: Linux >= 2.6.25."

#: ../../library/socket.rst:396
msgid ""
"CAN_BCM, in the CAN protocol family, is the broadcast manager (BCM) "
"protocol. Broadcast manager constants, documented in the Linux "
"documentation, are also defined in the socket module."
msgstr ""
"CAN_BCM, у сімействі протоколів CAN, є протоколом менеджера трансляції "
"(BCM). Константи менеджера трансляції, задокументовані в документації Linux, "
"також визначені в модулі сокета."

#: ../../library/socket.rst:403
msgid ""
"The :data:`CAN_BCM_CAN_FD_FRAME` flag is only available on Linux >= 4.8."
msgstr "Прапор :data:`CAN_BCM_CAN_FD_FRAME` доступний лише в Linux >= 4.8."

#: ../../library/socket.rst:409
msgid ""
"Enables CAN FD support in a CAN_RAW socket. This is disabled by default. "
"This allows your application to send both CAN and CAN FD frames; however, "
"you must accept both CAN and CAN FD frames when reading from the socket."
msgstr ""
"Вмикає підтримку CAN FD у гнізді CAN_RAW. За замовчуванням це вимкнено. Це "
"дозволяє вашій програмі надсилати кадри CAN і CAN FD; однак під час читання "
"з роз’єму ви повинні приймати як CAN, так і CAN FD кадри."

#: ../../library/socket.rst:413 ../../library/socket.rst:424
msgid "This constant is documented in the Linux documentation."
msgstr "Ця константа задокументована в документації Linux."

#: ../../library/socket.rst:416
msgid ":ref:`Availability <availability>`: Linux >= 3.6."
msgstr ":ref:`Disponibilidade <availability>`: Linux >= 3.6."

#: ../../library/socket.rst:421
msgid ""
"Joins the applied CAN filters such that only CAN frames that match all given "
"CAN filters are passed to user space."
msgstr ""
"Об’єднує застосовані фільтри CAN, щоб у простір користувача передавалися "
"лише кадри CAN, які відповідають усім наданим фільтрам CAN."

#: ../../library/socket.rst:427
msgid ":ref:`Availability <availability>`: Linux >= 4.1."
msgstr ":ref:`Disponibilidade <availability>`: Linux >= 4.1."

#: ../../library/socket.rst:432
msgid ""
"CAN_ISOTP, in the CAN protocol family, is the ISO-TP (ISO 15765-2) protocol. "
"ISO-TP constants, documented in the Linux documentation."
msgstr ""
"CAN_ISOTP у сімействі протоколів CAN є протоколом ISO-TP (ISO 15765-2). "
"Константи ISO-TP, задокументовані в документації Linux."

#: ../../library/socket.rst:441
msgid ""
"CAN_J1939, in the CAN protocol family, is the SAE J1939 protocol. J1939 "
"constants, documented in the Linux documentation."
msgstr ""
"CAN_J1939 у сімействі протоколів CAN є протоколом SAE J1939. Константи "
"J1939, задокументовані в документації Linux."

#: ../../library/socket.rst:445
msgid ":ref:`Availability <availability>`: Linux >= 5.4."
msgstr ":ref:`Disponibilidade <availability>`: Linux >= 5.4."

#: ../../library/socket.rst:456
msgid ":ref:`Availability <availability>`: Linux >= 2.2."
msgstr ":ref:`Disponibilidade <availability>`: Linux >= 2.2."

#: ../../library/socket.rst:468
msgid ":ref:`Availability <availability>`: Linux >= 2.6.30."
msgstr ":ref:`Disponibilidade <availability>`: Linux >= 2.6.30."

#: ../../library/socket.rst:477
msgid ""
"Constants for Windows' WSAIoctl(). The constants are used as arguments to "
"the :meth:`~socket.socket.ioctl` method of socket objects."
msgstr ""
"Константи для Windows WSAIoctl(). Константи використовуються як аргументи "
"методу :meth:`~socket.socket.ioctl` об’єктів сокета."

#: ../../library/socket.rst:480 ../../library/socket.rst:1364
msgid "``SIO_LOOPBACK_FAST_PATH`` was added."
msgstr "``SIO_LOOPBACK_FAST_PATH`` було додано."

#: ../../library/socket.rst:486
msgid ""
"TIPC related constants, matching the ones exported by the C socket API. See "
"the TIPC documentation for more information."
msgstr ""
"Константи, пов’язані з TIPC, що збігаються з тими, які експортує API сокета "
"C. Додаткову інформацію див. у документації TIPC."

#: ../../library/socket.rst:493
msgid "Constants for Linux Kernel cryptography."
msgstr "Константи для криптографії ядра Linux."

#: ../../library/socket.rst:496 ../../library/socket.rst:1664
msgid ":ref:`Availability <availability>`: Linux >= 2.6.38."
msgstr ":ref:`Disponibilidade <availability>`: Linux >= 2.6.38."

#: ../../library/socket.rst:505
msgid "Constants for Linux host/guest communication."
msgstr "Константи для зв’язку хост/гость Linux."

#: ../../library/socket.rst:508
msgid ":ref:`Availability <availability>`: Linux >= 4.8."
msgstr ":ref:`Disponibilidade <availability>`: Linux >= 4.8."

#: ../../library/socket.rst:514
msgid ":ref:`Availability <availability>`: BSD, macOS."
msgstr ":ref:`Disponibilidade <availability>`: BSD, macOS."

#: ../../library/socket.rst:519
msgid ""
"This constant contains a boolean value which indicates if IPv6 is supported "
"on this platform."
msgstr ""
"Ця константа містить логічне значення, яке вказує, чи підтримується IPv6 на "
"цій платформі."

#: ../../library/socket.rst:525
msgid ""
"These are string constants containing Bluetooth addresses with special "
"meanings. For example, :const:`BDADDR_ANY` can be used to indicate any "
"address when specifying the binding socket with :const:`BTPROTO_RFCOMM`."
msgstr ""
"Це рядкові константи, що містять адреси Bluetooth зі спеціальними "
"значеннями. Наприклад, :const:`BDADDR_ANY` можна використовувати для "
"вказівки будь-якої адреси, коли вказується сокет прив’язки за допомогою :"
"const:`BTPROTO_RFCOMM`."

#: ../../library/socket.rst:534
msgid ""
"For use with :const:`BTPROTO_HCI`. :const:`HCI_FILTER` is not available for "
"NetBSD or DragonFlyBSD. :const:`HCI_TIME_STAMP` and :const:`HCI_DATA_DIR` "
"are not available for FreeBSD, NetBSD, or DragonFlyBSD."
msgstr ""
"Для використання з :const:`BTPROTO_HCI`. :const:`HCI_FILTER` недоступний для "
"NetBSD або DragonFlyBSD. :const:`HCI_TIME_STAMP` і :const:`HCI_DATA_DIR` "
"недоступні для FreeBSD, NetBSD або DragonFlyBSD."

#: ../../library/socket.rst:541
msgid ""
"Constant for Qualcomm's IPC router protocol, used to communicate with "
"service providing remote processors."
msgstr ""
"Константа для протоколу маршрутизатора IPC Qualcomm, який використовується "
"для зв’язку з віддаленими процесорами, що надають послуги."

#: ../../library/socket.rst:544
msgid ":ref:`Availability <availability>`: Linux >= 4.7."
msgstr ":ref:`Disponibilidade <availability>`: Linux >= 4.7."

#: ../../library/socket.rst:547
msgid "Functions"
msgstr "Funções"

#: ../../library/socket.rst:550
msgid "Creating sockets"
msgstr "Criação de sockets"

#: ../../library/socket.rst:552
msgid ""
"The following functions all create :ref:`socket objects <socket-objects>`."
msgstr "Усі наступні функції створюють :ref:`об’єкти socket <socket-objects>`."

#: ../../library/socket.rst:557
msgid ""
"Create a new socket using the given address family, socket type and protocol "
"number.  The address family should be :const:`AF_INET` (the default), :const:"
"`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, :const:`AF_PACKET`, or :const:"
"`AF_RDS`. The socket type should be :const:`SOCK_STREAM` (the default), :"
"const:`SOCK_DGRAM`, :const:`SOCK_RAW` or perhaps one of the other ``SOCK_`` "
"constants. The protocol number is usually zero and may be omitted or in the "
"case where the address family is :const:`AF_CAN` the protocol should be one "
"of :const:`CAN_RAW`, :const:`CAN_BCM`, :const:`CAN_ISOTP` or :const:"
"`CAN_J1939`."
msgstr ""
"Створіть новий сокет, використовуючи вказане сімейство адрес, тип сокета та "
"номер протоколу. Сімейство адрес має бути :const:`AF_INET` (за "
"замовчуванням), :const:`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, :const:"
"`AF_PACKET` або :const:`AF_RDS`. Тип сокета має бути :const:`SOCK_STREAM` "
"(за замовчуванням), :const:`SOCK_DGRAM`, :const:`SOCK_RAW` або, можливо, "
"одна з інших констант ``SOCK_``. Номер протоколу зазвичай дорівнює нулю і "
"може бути пропущений або у випадку, коли сімейство адрес :const:`AF_CAN`, "
"протокол має бути одним із :const:`CAN_RAW`, :const:`CAN_BCM`, :const:"
"`CAN_ISOTP` або :const:`CAN_J1939`."

#: ../../library/socket.rst:567
msgid ""
"If *fileno* is specified, the values for *family*, *type*, and *proto* are "
"auto-detected from the specified file descriptor.  Auto-detection can be "
"overruled by calling the function with explicit *family*, *type*, or *proto* "
"arguments.  This only affects how Python represents e.g. the return value "
"of :meth:`socket.getpeername` but not the actual OS resource.  Unlike :func:"
"`socket.fromfd`, *fileno* will return the same socket and not a duplicate. "
"This may help close a detached socket using :meth:`socket.close()`."
msgstr ""
"Якщо вказано *fileno*, значення для *family*, *type* і *proto* автоматично "
"визначаються з указаного дескриптора файлу. Автоматичне визначення можна "
"скасувати, викликавши функцію з явними аргументами *family*, *type* або "
"*proto*. Це впливає лише на те, як Python представляє, наприклад. "
"повертається значення :meth:`socket.getpeername`, але не фактичний ресурс "
"ОС. На відміну від :func:`socket.fromfd`, *fileno* поверне той самий сокет, "
"а не дублікат. Це може допомогти закрити відокремлений сокет за допомогою :"
"meth:`socket.close()`."

#: ../../library/socket.rst:576 ../../library/socket.rst:710
#: ../../library/socket.rst:1194 ../../library/socket.rst:1281
msgid "The newly created socket is :ref:`non-inheritable <fd_inheritance>`."
msgstr "Новостворений сокет :ref:`не успадковується <fd_inheritance>`."

#: ../../library/socket.rst:578
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.__new__`` with arguments "
"``self``, ``family``, ``type``, ``protocol``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``socket.__new__`` com os "
"argumentos ``self``, ``family``, ``type``, ``protocol``."

#: ../../library/socket.rst:580
msgid "The AF_CAN family was added. The AF_RDS family was added."
msgstr "Додано сімейство AF_CAN. Додано сімейство AF_RDS."

#: ../../library/socket.rst:584
msgid "The CAN_BCM protocol was added."
msgstr "Додано протокол CAN_BCM."

#: ../../library/socket.rst:587 ../../library/socket.rst:712
msgid "The returned socket is now non-inheritable."
msgstr "Повернений сокет тепер не успадковується."

#: ../../library/socket.rst:590
msgid "The CAN_ISOTP protocol was added."
msgstr "Додано протокол CAN_ISOTP."

#: ../../library/socket.rst:593
msgid ""
"When :const:`SOCK_NONBLOCK` or :const:`SOCK_CLOEXEC` bit flags are applied "
"to *type* they are cleared, and :attr:`socket.type` will not reflect them.  "
"They are still passed to the underlying system `socket()` call.  Therefore,"
msgstr ""

#: ../../library/socket.rst:605
msgid ""
"will still create a non-blocking socket on OSes that support "
"``SOCK_NONBLOCK``, but ``sock.type`` will be set to ``socket.SOCK_STREAM``."
msgstr ""
"усе одно створить неблокуючий сокет в ОС, які підтримують ``SOCK_NONBLOCK``, "
"але ``sock.type`` буде встановлено на ``socket.SOCK_STREAM``."

#: ../../library/socket.rst:609
msgid "The CAN_J1939 protocol was added."
msgstr "Додано протокол CAN_J1939."

#: ../../library/socket.rst:614
msgid ""
"Build a pair of connected socket objects using the given address family, "
"socket type, and protocol number.  Address family, socket type, and protocol "
"number are as for the :func:`.socket` function above. The default family is :"
"const:`AF_UNIX` if defined on the platform; otherwise, the default is :const:"
"`AF_INET`."
msgstr ""
"Створіть пару з’єднаних об’єктів сокета, використовуючи вказане сімейство "
"адрес, тип сокета та номер протоколу. Родина адрес, тип сокета та номер "
"протоколу такі ж, як для функції :func:`.socket` вище. Сімейство за "
"замовчуванням :const:`AF_UNIX`, якщо визначено на платформі; інакше за "
"замовчуванням :const:`AF_INET`."

#: ../../library/socket.rst:619
msgid "The newly created sockets are :ref:`non-inheritable <fd_inheritance>`."
msgstr "Новостворені сокети :ref:`не успадковуються <fd_inheritance>`."

#: ../../library/socket.rst:621
msgid ""
"The returned socket objects now support the whole socket API, rather than a "
"subset."
msgstr ""
"Повернені об’єкти сокета тепер підтримують весь API сокета, а не його "
"підмножину."

#: ../../library/socket.rst:625
msgid "The returned sockets are now non-inheritable."
msgstr "Повернені сокети тепер не успадковуються."

#: ../../library/socket.rst:628
msgid "Windows support added."
msgstr "Додано підтримку Windows."

#: ../../library/socket.rst:634
msgid ""
"Connect to a TCP service listening on the Internet *address* (a 2-tuple "
"``(host, port)``), and return the socket object.  This is a higher-level "
"function than :meth:`socket.connect`: if *host* is a non-numeric hostname, "
"it will try to resolve it for both :data:`AF_INET` and :data:`AF_INET6`, and "
"then try to connect to all possible addresses in turn until a connection "
"succeeds.  This makes it easy to write clients that are compatible to both "
"IPv4 and IPv6."
msgstr ""

#: ../../library/socket.rst:642
msgid ""
"Passing the optional *timeout* parameter will set the timeout on the socket "
"instance before attempting to connect.  If no *timeout* is supplied, the "
"global default timeout setting returned by :func:`getdefaulttimeout` is used."
msgstr ""
"Передача додаткового параметра *timeout* встановить час очікування для "
"екземпляра сокета перед спробою підключення. Якщо *тайм-аут* не вказано, "
"використовується глобальне налаштування тайм-ауту за умовчанням, яке "
"повертає :func:`getdefaulttimeout`."

#: ../../library/socket.rst:647
msgid ""
"If supplied, *source_address* must be a 2-tuple ``(host, port)`` for the "
"socket to bind to as its source address before connecting.  If host or port "
"are '' or 0 respectively the OS default behavior will be used."
msgstr ""
"Якщо надано, *source_address* має бути 2-кортежем ``(хост, порт)``, щоб "
"сокет прив’язувався до своєї адреси джерела перед підключенням. Якщо хост "
"або порт мають значення '' або 0 відповідно, буде використано типову "
"поведінку ОС."

#: ../../library/socket.rst:651
msgid "*source_address* was added."
msgstr "*source_address* foi adicionado."

#: ../../library/socket.rst:656
msgid ""
"Convenience function which creates a TCP socket bound to *address* (a 2-"
"tuple ``(host, port)``) and return the socket object."
msgstr ""
"Зручна функція, яка створює TCP-сокет, прив’язаний до *адреси* (2-кортеж "
"``(хост, порт)``) і повертає об’єкт сокета."

#: ../../library/socket.rst:659
msgid ""
"*family* should be either :data:`AF_INET` or :data:`AF_INET6`. *backlog* is "
"the queue size passed to :meth:`socket.listen`; when ``0`` a default "
"reasonable value is chosen. *reuse_port* dictates whether to set the :data:"
"`SO_REUSEPORT` socket option."
msgstr ""

#: ../../library/socket.rst:664
msgid ""
"If *dualstack_ipv6* is true and the platform supports it the socket will be "
"able to accept both IPv4 and IPv6 connections, else it will raise :exc:"
"`ValueError`. Most POSIX platforms and Windows are supposed to support this "
"functionality. When this functionality is enabled the address returned by :"
"meth:`socket.getpeername` when an IPv4 connection occurs will be an IPv6 "
"address represented as an IPv4-mapped IPv6 address. If *dualstack_ipv6* is "
"false it will explicitly disable this functionality on platforms that enable "
"it by default (e.g. Linux). This parameter can be used in conjunction with :"
"func:`has_dualstack_ipv6`:"
msgstr ""
"Якщо *dualstack_ipv6* має значення true і платформа підтримує його, сокет "
"зможе приймати як з’єднання IPv4, так і IPv6, інакше виникне :exc:"
"`ValueError`. Більшість платформ POSIX і Windows повинні підтримувати цю "
"функцію. Якщо цю функцію ввімкнено, адреса, яку повертає :meth:`socket."
"getpeername` під час встановлення з’єднання IPv4, буде адресою IPv6, "
"представленою як адреса IPv6, відображена в IPv4. Якщо *dualstack_ipv6* має "
"значення false, це явно вимикає цю функцію на платформах, які ввімкнули її "
"за замовчуванням (наприклад, Linux). Цей параметр можна використовувати в "
"поєднанні з :func:`has_dualstack_ipv6`:"

#: ../../library/socket.rst:686
msgid ""
"On POSIX platforms the :data:`SO_REUSEADDR` socket option is set in order to "
"immediately reuse previous sockets which were bound on the same *address* "
"and remained in TIME_WAIT state."
msgstr ""
"На платформах POSIX параметр сокета :data:`SO_REUSEADDR` встановлено для "
"негайного повторного використання попередніх сокетів, які були прив’язані до "
"тієї самої *адреси* та залишалися в стані TIME_WAIT."

#: ../../library/socket.rst:694
msgid ""
"Return ``True`` if the platform supports creating a TCP socket which can "
"handle both IPv4 and IPv6 connections."
msgstr ""
"Повертає ``True``, якщо платформа підтримує створення TCP-сокета, який може "
"обробляти з’єднання IPv4 і IPv6."

#: ../../library/socket.rst:701
msgid ""
"Duplicate the file descriptor *fd* (an integer as returned by a file "
"object's :meth:`fileno` method) and build a socket object from the result.  "
"Address family, socket type and protocol number are as for the :func:`."
"socket` function above. The file descriptor should refer to a socket, but "
"this is not checked --- subsequent operations on the object may fail if the "
"file descriptor is invalid. This function is rarely needed, but can be used "
"to get or set socket options on a socket passed to a program as standard "
"input or output (such as a server started by the Unix inet daemon).  The "
"socket is assumed to be in blocking mode."
msgstr ""
"Скопіюйте файловий дескриптор *fd* (ціле число, яке повертає метод :meth:"
"`fileno` файлового об’єкта) і створіть об’єкт сокета з результату. Родина "
"адрес, тип сокета та номер протоколу такі ж, як для функції :func:`.socket` "
"вище. Дескриптор файлу має посилатися на сокет, але це не перевірено --- "
"подальші операції з об’єктом можуть завершитися помилкою, якщо дескриптор "
"файлу недійсний. Ця функція рідко потрібна, але її можна використовувати для "
"отримання або встановлення параметрів сокета для сокета, який передається "
"програмі як стандартний ввід або вихід (наприклад, сервер, запущений демоном "
"Unix inet). Передбачається, що розетка знаходиться в режимі блокування."

#: ../../library/socket.rst:718
msgid ""
"Instantiate a socket from data obtained from the :meth:`socket.share` "
"method.  The socket is assumed to be in blocking mode."
msgstr ""
"Створіть екземпляр сокета з даних, отриманих з методу :meth:`socket.share`. "
"Передбачається, що розетка знаходиться в режимі блокування."

#: ../../library/socket.rst:722 ../../library/socket.rst:1767
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Availability <availability>`: Windows."

#: ../../library/socket.rst:728
msgid ""
"This is a Python type object that represents the socket object type. It is "
"the same as ``type(socket(...))``."
msgstr ""
"Це об’єкт типу Python, який представляє тип об’єкта сокета. Це те саме, що "
"``type(socket(...))``."

#: ../../library/socket.rst:733
msgid "Other functions"
msgstr "Outras funções"

#: ../../library/socket.rst:735
msgid "The :mod:`socket` module also offers various network-related services:"
msgstr "Модуль :mod:`socket` також пропонує різноманітні мережеві служби:"

#: ../../library/socket.rst:740
msgid ""
"Close a socket file descriptor. This is like :func:`os.close`, but for "
"sockets. On some platforms (most noticeable Windows) :func:`os.close` does "
"not work for socket file descriptors."
msgstr ""
"Закрийте дескриптор файлу сокета. Це як :func:`os.close`, але для сокетів. "
"На деяких платформах (найбільш помітна Windows) :func:`os.close` не працює "
"для дескрипторів файлів сокетів."

#: ../../library/socket.rst:748
msgid ""
"Translate the *host*/*port* argument into a sequence of 5-tuples that "
"contain all the necessary arguments for creating a socket connected to that "
"service. *host* is a domain name, a string representation of an IPv4/v6 "
"address or ``None``. *port* is a string service name such as ``'http'``, a "
"numeric port number or ``None``.  By passing ``None`` as the value of *host* "
"and *port*, you can pass ``NULL`` to the underlying C API."
msgstr ""
"Переведіть аргумент *host*/*port* у послідовність із 5 кортежів, які містять "
"усі необхідні аргументи для створення сокета, підключеного до цієї служби. "
"*host* – це доменне ім’я, рядкове представлення адреси IPv4/v6 або ``None``. "
"*порт* — це рядкова назва служби, наприклад ``'http'``, числовий номер порту "
"або ``None``. Передаючи ``None`` як значення *host* і *port*, ви можете "
"передати ``NULL`` базовому C API."

#: ../../library/socket.rst:755
msgid ""
"The *family*, *type* and *proto* arguments can be optionally specified in "
"order to narrow the list of addresses returned.  Passing zero as a value for "
"each of these arguments selects the full range of results. The *flags* "
"argument can be one or several of the ``AI_*`` constants, and will influence "
"how results are computed and returned. For example, :const:`AI_NUMERICHOST` "
"will disable domain name resolution and will raise an error if *host* is a "
"domain name."
msgstr ""
"Аргументи *сімейство*, *тип* і *прото* можна додатково вказати, щоб звузити "
"список адрес, що повертаються. Передача нуля як значення для кожного з цих "
"аргументів вибирає повний діапазон результатів. Аргумент *flags* може бути "
"однією або декількома константами ``AI_*`` і впливатиме на спосіб обчислення "
"та повернення результатів. Наприклад, :const:`AI_NUMERICHOST` вимкне "
"розпізнавання доменного імені та викличе помилку, якщо *host* є доменним "
"іменем."

#: ../../library/socket.rst:763
msgid "The function returns a list of 5-tuples with the following structure:"
msgstr "Функція повертає список із 5-ти кортежів із такою структурою:"

#: ../../library/socket.rst:765
msgid "``(family, type, proto, canonname, sockaddr)``"
msgstr "``(family, type, proto, canonname, sockaddr)``"

#: ../../library/socket.rst:767
msgid ""
"In these tuples, *family*, *type*, *proto* are all integers and are meant to "
"be passed to the :func:`.socket` function.  *canonname* will be a string "
"representing the canonical name of the *host* if :const:`AI_CANONNAME` is "
"part of the *flags* argument; else *canonname* will be empty.  *sockaddr* is "
"a tuple describing a socket address, whose format depends on the returned "
"*family* (a ``(address, port)`` 2-tuple for :const:`AF_INET`, a ``(address, "
"port, flowinfo, scope_id)`` 4-tuple for :const:`AF_INET6`), and is meant to "
"be passed to the :meth:`socket.connect` method."
msgstr ""
"У цих кортежах усі *family*, *type*, *proto* є цілими числами, і вони "
"призначені для передачі у функцію :func:`.socket`. *canonname* буде рядком, "
"що представлятиме канонічне ім’я *хосту*, якщо :const:`AI_CANONNAME` є "
"частиною аргументу *flags*; інакше *canonname* буде порожнім. *sockaddr* — "
"це кортеж, що описує адресу сокета, формат якого залежить від повернутого "
"*сімейства* (2-кортеж ``(адреса, порт)`` для :const:`AF_INET`, ``(адреса, "
"порт, flowinfo, scope_id)`` 4-кортеж для :const:`AF_INET6`), і призначений "
"для передачі в метод :meth:`socket.connect`."

#: ../../library/socket.rst:777
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getaddrinfo`` with "
"arguments ``host``, ``port``, ``family``, ``type``, ``protocol``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``socket.getaddrinfo`` com "
"os argumentos ``host``, ``port``, ``family``, ``type``, ``protocol``."

#: ../../library/socket.rst:779
msgid ""
"The following example fetches address information for a hypothetical TCP "
"connection to ``example.org`` on port 80 (results may differ on your system "
"if IPv6 isn't enabled)::"
msgstr ""
"У наступному прикладі отримується інформація про адресу для гіпотетичного "
"TCP-з’єднання з ``example.org`` на порту 80 (результати можуть відрізнятися "
"у вашій системі, якщо IPv6 не ввімкнено):"

#: ../../library/socket.rst:789
msgid "parameters can now be passed using keyword arguments."
msgstr ""
"параметри тепер можна передавати за допомогою аргументів ключових слів."

#: ../../library/socket.rst:792
msgid ""
"for IPv6 multicast addresses, string representing an address will not "
"contain ``%scope_id`` part."
msgstr ""
"для багатоадресних адрес IPv6 рядок, що представляє адресу, не міститиме "
"частину ``%scope_id``."

#: ../../library/socket.rst:798
msgid ""
"Return a fully qualified domain name for *name*. If *name* is omitted or "
"empty, it is interpreted as the local host.  To find the fully qualified "
"name, the hostname returned by :func:`gethostbyaddr` is checked, followed by "
"aliases for the host, if available.  The first name which includes a period "
"is selected.  In case no fully qualified domain name is available and *name* "
"was provided, it is returned unchanged.  If *name* was empty or equal to "
"``'0.0.0.0'``, the hostname from :func:`gethostname` is returned."
msgstr ""
"Повернути повне доменне ім’я для *name*. Якщо *ім’я* опущене або порожнє, "
"воно інтерпретується як локальний хост. Щоб знайти повне ім’я, перевіряється "
"ім’я хоста, яке повертає :func:`gethostbyaddr`, а потім ідуть псевдоніми "
"хоста, якщо вони доступні. Вибрано перше ім’я, яке містить крапку. Якщо "
"повне доменне ім’я недоступне, а було вказано *ім’я*, воно повертається без "
"змін. Якщо *name* було порожнім або дорівнює ``'0.0.0.0'``, повертається "
"ім'я хоста з :func:`gethostname`."

#: ../../library/socket.rst:809
msgid ""
"Translate a host name to IPv4 address format.  The IPv4 address is returned "
"as a string, such as  ``'100.50.200.5'``.  If the host name is an IPv4 "
"address itself it is returned unchanged.  See :func:`gethostbyname_ex` for a "
"more complete interface. :func:`gethostbyname` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"Перекладіть ім’я хоста у формат адреси IPv4. Адреса IPv4 повертається у "
"вигляді рядка, наприклад ``'100.50.200.5``. Якщо ім’я хоста є адресою IPv4, "
"воно повертається без змін. Дивіться :func:`gethostbyname_ex` для більш "
"повного інтерфейсу. :func:`gethostbyname` не підтримує розпізнавання імен "
"IPv6, а :func:`getaddrinfo` слід використовувати замість цього для підтримки "
"подвійного стеку IPv4/v6."

#: ../../library/socket.rst:815 ../../library/socket.rst:829
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyname`` with "
"argument ``hostname``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``socket.gethostbyname`` "
"com o argumento ``hostname``."

#: ../../library/socket.rst:820
msgid ""
"Translate a host name to IPv4 address format, extended interface. Return a "
"triple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is the host's "
"primary host name, *aliaslist* is a (possibly empty) list of alternative "
"host names for the same address, and *ipaddrlist* is a list of IPv4 "
"addresses for the same interface on the same host (often but not always a "
"single address). :func:`gethostbyname_ex` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"Переклад імені хоста у формат адреси IPv4, розширений інтерфейс. Повертає "
"потрійний ``(hostname, aliaslist, ipaddrlist)``, де *hostname* — основне "
"ім’я хоста, *aliaslist* — (можливо, порожній) список альтернативних імен "
"хостів для тієї самої адреси, а *ipaddrlist* — список IPv4-адрес для одного "
"інтерфейсу на одному хості (часто, але не завжди одна адреса). :func:"
"`gethostbyname_ex` не підтримує розпізнавання імен IPv6, а :func:"
"`getaddrinfo` слід використовувати замість цього для підтримки подвійного "
"стеку IPv4/v6."

#: ../../library/socket.rst:834
msgid ""
"Return a string containing the hostname of the machine where  the Python "
"interpreter is currently executing."
msgstr ""
"Повертає рядок, що містить ім’я хоста машини, на якій зараз виконується "
"інтерпретатор Python."

#: ../../library/socket.rst:837
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostname`` with no "
"arguments."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``socket.gethostname`` sem "
"argumentos."

#: ../../library/socket.rst:839
msgid ""
"Note: :func:`gethostname` doesn't always return the fully qualified domain "
"name; use :func:`getfqdn` for that."
msgstr ""
"Примітка: :func:`gethostname` не завжди повертає повне доменне ім’я; "
"використовуйте для цього :func:`getfqdn`."

#: ../../library/socket.rst:845
msgid ""
"Return a triple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is "
"the primary host name responding to the given *ip_address*, *aliaslist* is a "
"(possibly empty) list of alternative host names for the same address, and "
"*ipaddrlist* is a list of IPv4/v6 addresses for the same interface on the "
"same host (most likely containing only a single address). To find the fully "
"qualified domain name, use the function :func:`getfqdn`. :func:"
"`gethostbyaddr` supports both IPv4 and IPv6."
msgstr ""
"Повертає потрійний ``(hostname, aliaslist, ipaddrlist)``, де *hostname* — "
"основне ім’я хоста, що відповідає заданій *ip_address*, *aliaslist* — "
"(можливо, порожній) список альтернативних імен хостів для тієї самої адреси, "
"а *ipaddrlist* — це список адрес IPv4/v6 для того самого інтерфейсу на тому "
"самому хості (швидше за все, містить лише одну адресу). Щоб знайти повне "
"доменне ім’я, скористайтеся функцією :func:`getfqdn`. :func:`gethostbyaddr` "
"підтримує як IPv4, так і IPv6."

#: ../../library/socket.rst:853
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyaddr`` with "
"argument ``ip_address``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``socket.gethostbyaddr`` "
"com o argumento ``ip_address``."

#: ../../library/socket.rst:858
msgid ""
"Translate a socket address *sockaddr* into a 2-tuple ``(host, port)``. "
"Depending on the settings of *flags*, the result can contain a fully-"
"qualified domain name or numeric address representation in *host*.  "
"Similarly, *port* can contain a string port name or a numeric port number."
msgstr ""

#: ../../library/socket.rst:863
msgid ""
"For IPv6 addresses, ``%scope_id`` is appended to the host part if *sockaddr* "
"contains meaningful *scope_id*. Usually this happens for multicast addresses."
msgstr ""
"Для адрес IPv6 ``%scope_id`` додається до частини хоста, якщо *sockaddr* "
"містить значимий *scope_id*. Зазвичай це відбувається для багатоадресних "
"адрес."

#: ../../library/socket.rst:866
msgid ""
"For more information about *flags* you can consult :manpage:`getnameinfo(3)`."
msgstr ""
"Для отримання додаткової інформації про *прапори* ви можете звернутися до :"
"manpage:`getnameinfo(3)`."

#: ../../library/socket.rst:868
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getnameinfo`` with "
"argument ``sockaddr``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``socket.getnameinfo`` com "
"o argumento ``sockaddr``."

#: ../../library/socket.rst:872
msgid ""
"Translate an Internet protocol name (for example, ``'icmp'``) to a constant "
"suitable for passing as the (optional) third argument to the :func:`.socket` "
"function.  This is usually only needed for sockets opened in \"raw\" mode (:"
"const:`SOCK_RAW`); for the normal socket modes, the correct protocol is "
"chosen automatically if the protocol is omitted or zero."
msgstr ""

#: ../../library/socket.rst:881
msgid ""
"Translate an Internet service name and protocol name to a port number for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""

#: ../../library/socket.rst:885
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyname`` with "
"arguments ``servicename``, ``protocolname``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``socket.getservbyname`` "
"com os argumentos ``servicename``, ``protocolname``."

#: ../../library/socket.rst:890
msgid ""
"Translate an Internet port number and protocol name to a service name for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""

#: ../../library/socket.rst:894
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyport`` with "
"arguments ``port``, ``protocolname``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``socket.getservbyport`` "
"com os argumentos ``port`` e ``protocolname``."

#: ../../library/socket.rst:899
msgid ""
"Convert 32-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"Перетворення 32-розрядних додатних чисел із мережевого порядку байтів на "
"хост. На машинах, де порядок байтів хоста збігається з порядком байтів у "
"мережі, це заборонено; інакше він виконує 4-байтову операцію обміну."

#: ../../library/socket.rst:906
msgid ""
"Convert 16-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"Перетворення 16-розрядних додатних чисел із мережевого порядку байтів на "
"хост. На машинах, де порядок байтів хоста збігається з порядком байтів у "
"мережі, це заборонено; інакше він виконує 2-байтову операцію обміну."

#: ../../library/socket.rst:910 ../../library/socket.rst:930
msgid ""
"In case *x* does not fit in 16-bit unsigned integer, but does fit in a "
"positive C int, it is silently truncated to 16-bit unsigned integer. This "
"silent truncation feature is deprecated, and will raise an exception in "
"future versions of Python."
msgstr ""

#: ../../library/socket.rst:919
msgid ""
"Convert 32-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"Перетворюйте 32-розрядні додатні цілі числа з хоста на мережевий порядок "
"байтів. На машинах, де порядок байтів хоста збігається з порядком байтів у "
"мережі, це заборонено; інакше він виконує 4-байтову операцію обміну."

#: ../../library/socket.rst:926
msgid ""
"Convert 16-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"Перетворення 16-розрядних додатних чисел із хоста в мережевий порядок "
"байтів. На машинах, де порядок байтів хоста збігається з порядком байтів у "
"мережі, це заборонено; інакше він виконує 2-байтову операцію обміну."

#: ../../library/socket.rst:939
msgid ""
"Convert an IPv4 address from dotted-quad string format (for example, "
"'123.45.67.89') to 32-bit packed binary format, as a bytes object four "
"characters in length.  This is useful when conversing with a program that "
"uses the standard C library and needs objects of type :c:type:`struct "
"in_addr`, which is the C type for the 32-bit packed binary this function "
"returns."
msgstr ""

#: ../../library/socket.rst:945
msgid ""
":func:`inet_aton` also accepts strings with less than three dots; see the "
"Unix manual page :manpage:`inet(3)` for details."
msgstr ""
":func:`inet_aton` також приймає рядки з менш ніж трьома крапками; подробиці "
"див. на сторінці посібника Unix :manpage:`inet(3)`."

#: ../../library/socket.rst:948
msgid ""
"If the IPv4 address string passed to this function is invalid, :exc:"
"`OSError` will be raised. Note that exactly what is valid depends on the "
"underlying C implementation of :c:func:`inet_aton`."
msgstr ""
"Якщо рядок адреси IPv4, переданий цій функції, недійсний, буде викликано :"
"exc:`OSError`. Зауважте, що саме те, що є дійсним, залежить від базової "
"реалізації C :c:func:`inet_aton`."

#: ../../library/socket.rst:952
msgid ""
":func:`inet_aton` does not support IPv6, and :func:`inet_pton` should be "
"used instead for IPv4/v6 dual stack support."
msgstr ""
":func:`inet_aton` не підтримує IPv6, а :func:`inet_pton` слід "
"використовувати замість цього для підтримки подвійного стеку IPv4/v6."

#: ../../library/socket.rst:958
msgid ""
"Convert a 32-bit packed IPv4 address (a :term:`bytes-like object` four bytes "
"in length) to its standard dotted-quad string representation (for example, "
"'123.45.67.89').  This is useful when conversing with a program that uses "
"the standard C library and needs objects of type :c:type:`struct in_addr`, "
"which is the C type for the 32-bit packed binary data this function takes as "
"an argument."
msgstr ""

#: ../../library/socket.rst:965
msgid ""
"If the byte sequence passed to this function is not exactly 4 bytes in "
"length, :exc:`OSError` will be raised. :func:`inet_ntoa` does not support "
"IPv6, and :func:`inet_ntop` should be used instead for IPv4/v6 dual stack "
"support."
msgstr ""
"Якщо послідовність байтів, передана цій функції, не має довжини точно 4 "
"байти, виникне :exc:`OSError`. :func:`inet_ntoa` не підтримує IPv6, а :func:"
"`inet_ntop` слід використовувати замість цього для підтримки подвійного "
"стеку IPv4/v6."

#: ../../library/socket.rst:976
msgid ""
"Convert an IP address from its family-specific string format to a packed, "
"binary format. :func:`inet_pton` is useful when a library or network "
"protocol calls for an object of type :c:type:`struct in_addr` (similar to :"
"func:`inet_aton`) or :c:type:`struct in6_addr`."
msgstr ""

#: ../../library/socket.rst:981
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and :"
"const:`AF_INET6`. If the IP address string *ip_string* is invalid, :exc:"
"`OSError` will be raised. Note that exactly what is valid depends on both "
"the value of *address_family* and the underlying implementation of :c:func:"
"`inet_pton`."
msgstr ""
"Підтримувані значення для *address_family* наразі: :const:`AF_INET` і :const:"
"`AF_INET6`. Якщо рядок IP-адреси *ip_string* недійсний, виникне :exc:"
"`OSError`. Зауважте, що саме те, що є дійсним, залежить як від значення "
"*address_family*, так і від базової реалізації :c:func:`inet_pton`."

#: ../../library/socket.rst:988 ../../library/socket.rst:1008
msgid ""
":ref:`Availability <availability>`: Unix (maybe not all platforms), Windows."
msgstr ""
":ref:`Наявність <availability>`: Unix (можливо не всі платформи), Windows."

#: ../../library/socket.rst:989 ../../library/socket.rst:1009
msgid "Windows support added"
msgstr "Suporte para Windows adicionado."

#: ../../library/socket.rst:995
msgid ""
"Convert a packed IP address (a :term:`bytes-like object` of some number of "
"bytes) to its standard, family-specific string representation (for example, "
"``'7.10.0.5'`` or ``'5aef:2b::8'``). :func:`inet_ntop` is useful when a "
"library or network protocol returns an object of type :c:type:`struct "
"in_addr` (similar to :func:`inet_ntoa`) or :c:type:`struct in6_addr`."
msgstr ""

#: ../../library/socket.rst:1002
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and :"
"const:`AF_INET6`. If the bytes object *packed_ip* is not the correct length "
"for the specified address family, :exc:`ValueError` will be raised. :exc:"
"`OSError` is raised for errors from the call to :func:`inet_ntop`."
msgstr ""
"Підтримувані значення для *address_family* наразі: :const:`AF_INET` і :const:"
"`AF_INET6`. Якщо об’єкт bytes *packed_ip* не має правильної довжини для "
"вказаного сімейства адрес, буде викликано :exc:`ValueError`. :exc:`OSError` "
"викликається для помилок виклику :func:`inet_ntop`."

#: ../../library/socket.rst:1024
msgid ""
"Return the total length, without trailing padding, of an ancillary data item "
"with associated data of the given *length*.  This value can often be used as "
"the buffer size for :meth:`~socket.recvmsg` to receive a single item of "
"ancillary data, but :rfc:`3542` requires portable applications to use :func:"
"`CMSG_SPACE` and thus include space for padding, even when the item will be "
"the last in the buffer.  Raises :exc:`OverflowError` if *length* is outside "
"the permissible range of values."
msgstr ""
"Повертає загальну довжину, без заповнення в кінці, елемента допоміжних даних "
"із пов’язаними даними заданої *довжини*. Це значення часто можна "
"використовувати як розмір буфера для :meth:`~socket.recvmsg` для отримання "
"окремого елемента допоміжних даних, але :rfc:`3542` вимагає, щоб портативні "
"програми використовували :func:`CMSG_SPACE` і таким чином включали простір "
"для заповнення, навіть якщо елемент буде останнім у буфері. Викликає :exc:"
"`OverflowError`, якщо *length* виходить за межі допустимого діапазону "
"значень."

#: ../../library/socket.rst:1034 ../../library/socket.rst:1055
#: ../../library/socket.rst:1500 ../../library/socket.rst:1542
#: ../../library/socket.rst:1648
msgid ""
":ref:`Availability <availability>`: most Unix platforms, possibly others."
msgstr ""
":ref:`Доступність <availability>`: більшість платформ Unix, можливо, інші."

#: ../../library/socket.rst:1040
msgid ""
"Return the buffer size needed for :meth:`~socket.recvmsg` to receive an "
"ancillary data item with associated data of the given *length*, along with "
"any trailing padding.  The buffer space needed to receive multiple items is "
"the sum of the :func:`CMSG_SPACE` values for their associated data lengths.  "
"Raises :exc:`OverflowError` if *length* is outside the permissible range of "
"values."
msgstr ""
"Повертає розмір буфера, необхідний для :meth:`~socket.recvmsg` для отримання "
"елемента допоміжних даних із пов’язаними даними заданої *довжини* разом із "
"будь-яким доповненням у кінці. Буферний простір, необхідний для отримання "
"кількох елементів, є сумою значень :func:`CMSG_SPACE` для відповідної "
"довжини даних. Викликає :exc:`OverflowError`, якщо *length* виходить за межі "
"допустимого діапазону значень."

#: ../../library/socket.rst:1048
msgid ""
"Note that some systems might support ancillary data without providing this "
"function.  Also note that setting the buffer size using the results of this "
"function may not precisely limit the amount of ancillary data that can be "
"received, since additional data may be able to fit into the padding area."
msgstr ""
"Зауважте, що деякі системи можуть підтримувати допоміжні дані без надання "
"цієї функції. Також зауважте, що встановлення розміру буфера за допомогою "
"результатів цієї функції може не обмежувати точно кількість допоміжних "
"даних, які можна отримати, оскільки додаткові дані можуть поміститися в "
"область заповнення."

#: ../../library/socket.rst:1061
msgid ""
"Return the default timeout in seconds (float) for new socket objects. A "
"value of ``None`` indicates that new socket objects have no timeout. When "
"the socket module is first imported, the default is ``None``."
msgstr ""
"Повертає стандартний час очікування в секундах (float) для нових об’єктів "
"сокета. Значення ``None`` вказує на те, що нові об’єкти сокета не мають часу "
"очікування. Коли модуль сокета імпортовано вперше, за замовчуванням буде "
"``None``."

#: ../../library/socket.rst:1068
msgid ""
"Set the default timeout in seconds (float) for new socket objects.  When the "
"socket module is first imported, the default is ``None``.  See :meth:"
"`~socket.settimeout` for possible values and their respective meanings."
msgstr ""
"Встановіть стандартний час очікування в секундах (float) для нових об’єктів "
"сокета. Коли модуль сокета імпортовано вперше, за замовчуванням буде "
"``None``. Перегляньте :meth:`~socket.settimeout` можливі значення та їх "
"відповідні значення."

#: ../../library/socket.rst:1076
msgid ""
"Set the machine's hostname to *name*.  This will raise an :exc:`OSError` if "
"you don't have enough rights."
msgstr ""
"Встановіть ім’я хоста машини на *name*. Це викличе :exc:`OSError`, якщо у "
"вас недостатньо прав."

#: ../../library/socket.rst:1079
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sethostname`` with "
"argument ``name``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``socket.sethostname`` com "
"o argumento ``name``."

#: ../../library/socket.rst:1082
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`Availability <availability>`: Unix."

#: ../../library/socket.rst:1088
msgid ""
"Return a list of network interface information (index int, name string) "
"tuples. :exc:`OSError` if the system call fails."
msgstr ""
"Повертає список кортежів інформації про мережевий інтерфейс (index int, name "
"string). :exc:`OSError`, якщо системний виклик не вдається."

#: ../../library/socket.rst:1093 ../../library/socket.rst:1120
#: ../../library/socket.rst:1137
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`Availability <availability>`: Unix, Windows."

#: ../../library/socket.rst:1096 ../../library/socket.rst:1123
#: ../../library/socket.rst:1140
msgid "Windows support was added."
msgstr "Suporte ao Windows foi adicionado."

#: ../../library/socket.rst:1101
msgid ""
"On Windows network interfaces have different names in different contexts "
"(all names are examples):"
msgstr ""
"У Windows мережеві інтерфейси мають різні імена в різних контекстах (усі "
"імена є прикладами):"

#: ../../library/socket.rst:1104
msgid "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"
msgstr "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"

#: ../../library/socket.rst:1105
msgid "name: ``ethernet_32770``"
msgstr "name: ``ethernet_32770``"

#: ../../library/socket.rst:1106
msgid "friendly name: ``vEthernet (nat)``"
msgstr "зрозуміла назва: ``vEthernet (nat)``"

#: ../../library/socket.rst:1107
msgid "description: ``Hyper-V Virtual Ethernet Adapter``"
msgstr "опис: ``Hyper-V Virtual Ethernet Adapter``"

#: ../../library/socket.rst:1109
msgid ""
"This function returns names of the second form from the list, "
"``ethernet_32770`` in this example case."
msgstr ""
"Ця функція повертає імена другої форми зі списку, ``ethernet_32770`` у цьому "
"прикладі."

#: ../../library/socket.rst:1115
msgid ""
"Return a network interface index number corresponding to an interface name. :"
"exc:`OSError` if no interface with the given name exists."
msgstr ""
"Повертає номер індексу мережевого інтерфейсу, який відповідає імені "
"інтерфейсу. :exc:`OSError`, якщо не існує інтерфейсу з вказаною назвою."

#: ../../library/socket.rst:1127 ../../library/socket.rst:1144
msgid "\"Interface name\" is a name as documented in :func:`if_nameindex`."
msgstr ""
"\"Назва інтерфейсу\" — це назва, задокументована в :func:`if_nameindex`."

#: ../../library/socket.rst:1132
msgid ""
"Return a network interface name corresponding to an interface index number. :"
"exc:`OSError` if no interface with the given index exists."
msgstr ""
"Повертає назву мережевого інтерфейсу, що відповідає номеру індексу "
"інтерфейсу. :exc:`OSError`, якщо не існує інтерфейсу з даним індексом."

#: ../../library/socket.rst:1149
msgid ""
"Send the list of file descriptors *fds* over an :const:`AF_UNIX` socket "
"*sock*. The *fds* parameter is a sequence of file descriptors. Consult :meth:"
"`sendmsg` for the documentation of these parameters."
msgstr ""
"Надішліть список дескрипторів файлів *fds* через сокет :const:`AF_UNIX` "
"*sock*. Параметр *fds* — це послідовність дескрипторів файлів. Зверніться "
"до :meth:`sendmsg` для документації щодо цих параметрів."

#: ../../library/socket.rst:1154
msgid ""
":ref:`Availability <availability>`: Unix supporting :meth:`~socket.sendmsg` "
"and :const:`SCM_RIGHTS` mechanism."
msgstr ""
":ref:`Доступність <availability>`: Unix підтримує механізм :meth:`~socket."
"sendmsg` і :const:`SCM_RIGHTS`."

#: ../../library/socket.rst:1160
msgid ""
"Receive up to *maxfds* file descriptors from an :const:`AF_UNIX` socket "
"*sock*. Return ``(msg, list(fds), flags, addr)``. Consult :meth:`recvmsg` "
"for the documentation of these parameters."
msgstr ""
"Отримайте до *maxfds* файлових дескрипторів із :const:`AF_UNIX` сокета "
"*sock*. Повернути ``(msg, list(fds), flags, addr)``. Зверніться до :meth:"
"`recvmsg` для документації цих параметрів."

#: ../../library/socket.rst:1165
msgid ""
":ref:`Availability <availability>`: Unix supporting :meth:`~socket.recvmsg` "
"and :const:`SCM_RIGHTS` mechanism."
msgstr ""
":ref:`Доступність <availability>`: Unix підтримує механізм :meth:`~socket."
"recvmsg` і :const:`SCM_RIGHTS`."

#: ../../library/socket.rst:1170
msgid "Any truncated integers at the end of the list of file descriptors."
msgstr "Будь-які скорочені цілі числа в кінці списку дескрипторів файлів."

#: ../../library/socket.rst:1176
msgid "Socket Objects"
msgstr "Об'єкти Socket"

#: ../../library/socket.rst:1178
msgid ""
"Socket objects have the following methods.  Except for :meth:`~socket."
"makefile`, these correspond to Unix system calls applicable to sockets."
msgstr ""
"Об’єкти Socket мають такі методи. За винятком :meth:`~socket.makefile`, вони "
"відповідають системним викликам Unix, застосовним до сокетів."

#: ../../library/socket.rst:1182
msgid ""
"Support for the :term:`context manager` protocol was added.  Exiting the "
"context manager is equivalent to calling :meth:`~socket.close`."
msgstr ""
"Додано підтримку протоколу :term:`context manager`. Вихід із контекстного "
"менеджера еквівалентний виклику :meth:`~socket.close`."

#: ../../library/socket.rst:1189
msgid ""
"Accept a connection. The socket must be bound to an address and listening "
"for connections. The return value is a pair ``(conn, address)`` where *conn* "
"is a *new* socket object usable to send and receive data on the connection, "
"and *address* is the address bound to the socket on the other end of the "
"connection."
msgstr ""
"Прийняти підключення. Сокет має бути прив’язаний до адреси та прослуховувати "
"підключення. Поверненим значенням є пара ``(conn, address)``, де *conn* — це "
"*новий* об’єкт сокета, який можна використовувати для надсилання та "
"отримання даних під час з’єднання, а *address* — це адреса, прив’язана до "
"сокета на іншому кінець з'єднання."

#: ../../library/socket.rst:1196 ../../library/socket.rst:1283
msgid "The socket is now non-inheritable."
msgstr "Тепер сокет не успадковується."

#: ../../library/socket.rst:1199 ../../library/socket.rst:1414
#: ../../library/socket.rst:1428 ../../library/socket.rst:1503
#: ../../library/socket.rst:1574 ../../library/socket.rst:1593
#: ../../library/socket.rst:1610 ../../library/socket.rst:1653
msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the method now retries the system call instead of raising an :exc:"
"`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"Якщо системний виклик перервано, а обробник сигналу не викликає виключення, "
"метод тепер повторює системний виклик замість того, щоб викликати виняток :"
"exc:`InterruptedError` (перегляньте :pep:`475` для обґрунтування)."

#: ../../library/socket.rst:1207
msgid ""
"Bind the socket to *address*.  The socket must not already be bound. (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"Прив’яжіть сокет до *адреси*. Розетка ще не повинна бути прив’язаною. "
"(Формат *адреси* залежить від групи адрес --- див. вище.)"

#: ../../library/socket.rst:1210
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.bind`` with arguments "
"``self``, ``address``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``socket.bind`` com os "
"argumentos ``self``, ``address``."

#: ../../library/socket.rst:1214
msgid ""
"Mark the socket closed.  The underlying system resource (e.g. a file "
"descriptor) is also closed when all file objects from :meth:`makefile()` are "
"closed.  Once that happens, all future operations on the socket object will "
"fail. The remote end will receive no more data (after queued data is "
"flushed)."
msgstr ""
"Позначте розетку закритою. Базовий системний ресурс (наприклад, дескриптор "
"файлу) також закривається, коли закриваються всі файлові об’єкти з :meth:"
"`makefile()`. Як тільки це станеться, усі подальші операції над об’єктом "
"сокета не вдадуться. Віддалена сторона більше не отримуватиме даних (після "
"видалення даних із черги)."

#: ../../library/socket.rst:1220
msgid ""
"Sockets are automatically closed when they are garbage-collected, but it is "
"recommended to :meth:`close` them explicitly, or to use a :keyword:`with` "
"statement around them."
msgstr ""
"Сокети автоматично закриваються під час збирання сміття, але рекомендується :"
"meth:`close` їх явно або використовувати оператор :keyword:`with` навколо "
"них."

#: ../../library/socket.rst:1224
msgid ""
":exc:`OSError` is now raised if an error occurs when the underlying :c:func:"
"`close` call is made."
msgstr ""
":exc:`OSError` тепер викликається, якщо виникає помилка під час основного "
"виклику :c:func:`close`."

#: ../../library/socket.rst:1230
msgid ""
":meth:`close()` releases the resource associated with a connection but does "
"not necessarily close the connection immediately.  If you want to close the "
"connection in a timely fashion, call :meth:`shutdown()` before :meth:"
"`close()`."
msgstr ""
":meth:`close()` звільняє ресурс, пов’язаний із з’єднанням, але не "
"обов’язково закриває з’єднання негайно. Якщо ви хочете своєчасно закрити "
"з’єднання, викличте :meth:`shutdown()` перед :meth:`close()`."

#: ../../library/socket.rst:1238
msgid ""
"Connect to a remote socket at *address*. (The format of *address* depends on "
"the address family --- see above.)"
msgstr ""
"Підключіться до віддаленої розетки за *адресою*. (Формат *адреси* залежить "
"від групи адрес --- див. вище.)"

#: ../../library/socket.rst:1241
msgid ""
"If the connection is interrupted by a signal, the method waits until the "
"connection completes, or raise a :exc:`socket.timeout` on timeout, if the "
"signal handler doesn't raise an exception and the socket is blocking or has "
"a timeout. For non-blocking sockets, the method raises an :exc:"
"`InterruptedError` exception if the connection is interrupted by a signal "
"(or the exception raised by the signal handler)."
msgstr ""

#: ../../library/socket.rst:1248 ../../library/socket.rst:1266
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.connect`` with arguments "
"``self``, ``address``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``socket.connect`` com os "
"argumentos ``self``, ``address``."

#: ../../library/socket.rst:1250
msgid ""
"The method now waits until the connection completes instead of raising an :"
"exc:`InterruptedError` exception if the connection is interrupted by a "
"signal, the signal handler doesn't raise an exception and the socket is "
"blocking or has a timeout (see the :pep:`475` for the rationale)."
msgstr ""
"Тепер метод очікує, доки з’єднання завершиться, замість того, щоб викликати "
"виняток :exc:`InterruptedError`, якщо з’єднання перервано сигналом, обробник "
"сигналу не викликає виключення, а сокет блокується або має тайм-аут (див. :"
"pep:`475` для обґрунтування)."

#: ../../library/socket.rst:1259
msgid ""
"Like ``connect(address)``, but return an error indicator instead of raising "
"an exception for errors returned by the C-level :c:func:`connect` call "
"(other problems, such as \"host not found,\" can still raise exceptions).  "
"The error indicator is ``0`` if the operation succeeded, otherwise the value "
"of the :c:data:`errno` variable.  This is useful to support, for example, "
"asynchronous connects."
msgstr ""
"Подібно до ``connect(address)``, але повертає індикатор помилки замість "
"виклику винятку для помилок, які повертає виклик :c:func:`connect` рівня C "
"(інші проблеми, такі як \"хост не знайдено\", можуть все ще викликають "
"винятки). Індикатор помилки – ``0``, якщо операція виконана успішно, інакше "
"значення змінної :c:data:`errno`. Це корисно для підтримки, наприклад, "
"асинхронних підключень."

#: ../../library/socket.rst:1270
msgid ""
"Put the socket object into closed state without actually closing the "
"underlying file descriptor.  The file descriptor is returned, and can be "
"reused for other purposes."
msgstr ""
"Переведіть об’єкт сокета в закритий стан, фактично не закриваючи базовий "
"файловий дескриптор. Файловий дескриптор повертається, і його можна повторно "
"використовувати для інших цілей."

#: ../../library/socket.rst:1279
msgid "Duplicate the socket."
msgstr "Дублюйте розетку."

#: ../../library/socket.rst:1289
msgid ""
"Return the socket's file descriptor (a small integer), or -1 on failure. "
"This is useful with :func:`select.select`."
msgstr ""
"Повертає дескриптор файлу сокета (мале ціле число) або -1 у разі помилки. Це "
"корисно з :func:`select.select`."

#: ../../library/socket.rst:1292
msgid ""
"Under Windows the small integer returned by this method cannot be used where "
"a file descriptor can be used (such as :func:`os.fdopen`).  Unix does not "
"have this limitation."
msgstr ""
"Під Windows мале ціле число, яке повертає цей метод, не можна "
"використовувати там, де можна використовувати дескриптор файлу (наприклад, :"
"func:`os.fdopen`). Unix не має цього обмеження."

#: ../../library/socket.rst:1298
msgid ""
"Get the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle: ``True`` if the socket can be inherited in "
"child processes, ``False`` if it cannot."
msgstr ""
"Отримайте :ref:`inheritable flag <fd_inheritance>` дескриптора файлу сокета "
"або дескриптора сокета: ``True``, якщо сокет можна успадкувати в дочірніх "
"процесах, ``False``, якщо це неможливо."

#: ../../library/socket.rst:1307
msgid ""
"Return the remote address to which the socket is connected.  This is useful "
"to find out the port number of a remote IPv4/v6 socket, for instance. (The "
"format of the address returned depends on the address family --- see "
"above.)  On some systems this function is not supported."
msgstr ""
"Повертає віддалену адресу, до якої підключений сокет. Це корисно, наприклад, "
"щоб дізнатися номер порту віддаленого сокета IPv4/v6. (Формат адреси, що "
"повертається, залежить від родини адрес --- див. вище.) У деяких системах ця "
"функція не підтримується."

#: ../../library/socket.rst:1315
msgid ""
"Return the socket's own address.  This is useful to find out the port number "
"of an IPv4/v6 socket, for instance. (The format of the address returned "
"depends on the address family --- see above.)"
msgstr ""
"Повернути власну адресу сокета. Це корисно, наприклад, щоб дізнатися номер "
"порту сокета IPv4/v6. (Формат адреси, що повертається, залежить від "
"сімейства адрес --- див. вище.)"

#: ../../library/socket.rst:1322
msgid ""
"Return the value of the given socket option (see the Unix man page :manpage:"
"`getsockopt(2)`).  The needed symbolic constants (:const:`SO_\\*` etc.) are "
"defined in this module.  If *buflen* is absent, an integer option is assumed "
"and its integer value is returned by the function.  If *buflen* is present, "
"it specifies the maximum length of the buffer used to receive the option in, "
"and this buffer is returned as a bytes object.  It is up to the caller to "
"decode the contents of the buffer (see the optional built-in module :mod:"
"`struct` for a way to decode C structures encoded as byte strings)."
msgstr ""
"Повертає значення вказаного параметра сокета (див. сторінку довідки Unix :"
"manpage:`getsockopt(2)`). Необхідні символічні константи (:const:`SO_\\*` "
"тощо) визначені в цьому модулі. Якщо *buflen* відсутній, передбачається "
"цілочисельний параметр, і функція повертає його ціле значення. Якщо "
"присутній *buflen*, він визначає максимальну довжину буфера, який "
"використовується для отримання опції, і цей буфер повертається як об’єкт "
"bytes. Вміст буфера повинен розшифровувати той, хто викликає (перегляньте "
"додатковий вбудований модуль :mod:`struct`, щоб дізнатися про спосіб "
"декодування структур C, закодованих як рядки байтів)."

#: ../../library/socket.rst:1334
msgid ""
"Return ``True`` if socket is in blocking mode, ``False`` if in non-blocking."
msgstr ""
"Повертає ``True``, якщо сокет знаходиться в режимі блокування, ``False``, "
"якщо він не блокується."

#: ../../library/socket.rst:1337
msgid "This is equivalent to checking ``socket.gettimeout() == 0``."
msgstr "Це еквівалентно перевірці ``socket.gettimeout() == 0``."

#: ../../library/socket.rst:1344
msgid ""
"Return the timeout in seconds (float) associated with socket operations, or "
"``None`` if no timeout is set.  This reflects the last call to :meth:"
"`setblocking` or :meth:`settimeout`."
msgstr ""
"Повертає тайм-аут у секундах (float), пов’язаний з операціями сокета, або "
"``None``, якщо тайм-аут не встановлено. Це відображає останній виклик :meth:"
"`setblocking` або :meth:`settimeout`."

#: ../../library/socket.rst:0
msgid "platform"
msgstr "platform"

#: ../../library/socket.rst:1351
msgid "Windows"
msgstr "Windows"

#: ../../library/socket.rst:1353
msgid ""
"The :meth:`ioctl` method is a limited interface to the WSAIoctl system "
"interface.  Please refer to the `Win32 documentation <https://msdn.microsoft."
"com/en-us/library/ms741621%28VS.85%29.aspx>`_ for more information."
msgstr ""
"Метод :meth:`ioctl` є обмеженим інтерфейсом системного інтерфейсу WSAIoctl. "
"Будь ласка, зверніться до `документації Win32 <https://msdn.microsoft.com/en-"
"us/library/ms741621%28VS.85%29.aspx>`_ для отримання додаткової інформації."

#: ../../library/socket.rst:1358
msgid ""
"On other platforms, the generic :func:`fcntl.fcntl` and :func:`fcntl.ioctl` "
"functions may be used; they accept a socket object as their first argument."
msgstr ""
"На інших платформах можна використовувати загальні функції :func:`fcntl."
"fcntl` і :func:`fcntl.ioctl`; вони приймають об'єкт сокета як свій перший "
"аргумент."

#: ../../library/socket.rst:1361
msgid ""
"Currently only the following control codes are supported: ``SIO_RCVALL``, "
"``SIO_KEEPALIVE_VALS``, and ``SIO_LOOPBACK_FAST_PATH``."
msgstr ""
"Наразі підтримуються лише такі керуючі коди: ``SIO_RCVALL``, "
"``SIO_KEEPALIVE_VALS`` і ``SIO_LOOPBACK_FAST_PATH``."

#: ../../library/socket.rst:1369
msgid ""
"Enable a server to accept connections.  If *backlog* is specified, it must "
"be at least 0 (if it is lower, it is set to 0); it specifies the number of "
"unaccepted connections that the system will allow before refusing new "
"connections. If not specified, a default reasonable value is chosen."
msgstr ""
"Увімкніть сервер для прийняття підключень. Якщо вказано *backlog*, воно має "
"бути принаймні 0 (якщо менше, то встановлюється на 0); він визначає "
"кількість неприйнятих підключень, які система дозволить перед тим, як "
"відхилити нові підключення. Якщо не вказано, вибирається розумне значення за "
"умовчанням."

#: ../../library/socket.rst:1374
msgid "The *backlog* parameter is now optional."
msgstr "Параметр *backlog* тепер необов’язковий."

#: ../../library/socket.rst:1382
msgid ""
"Return a :term:`file object` associated with the socket.  The exact returned "
"type depends on the arguments given to :meth:`makefile`.  These arguments "
"are interpreted the same way as by the built-in :func:`open` function, "
"except the only supported *mode* values are ``'r'`` (default), ``'w'`` and "
"``'b'``."
msgstr ""
"Повертає :term:`file object`, пов’язаний із сокетом. Точний тип, що "
"повертається, залежить від аргументів, наданих :meth:`makefile`. Ці "
"аргументи інтерпретуються так само, як і вбудована функція :func:`open`, за "
"винятком підтримуваних тільки значень *mode*: ``'r'`` (за замовчуванням), "
"``'w'`` і ``'b'``."

#: ../../library/socket.rst:1387
msgid ""
"The socket must be in blocking mode; it can have a timeout, but the file "
"object's internal buffer may end up in an inconsistent state if a timeout "
"occurs."
msgstr ""
"Розетка повинна бути в режимі блокування; він може мати тайм-аут, але "
"внутрішній буфер файлового об’єкта може опинитися в неузгодженому стані, "
"якщо відбудеться тайм-аут."

#: ../../library/socket.rst:1391
msgid ""
"Closing the file object returned by :meth:`makefile` won't close the "
"original socket unless all other file objects have been closed and :meth:"
"`socket.close` has been called on the socket object."
msgstr ""
"Закриття файлового об’єкта, який повертає :meth:`makefile`, не закриє "
"оригінальний сокет, якщо всі інші файлові об’єкти не закриті та :meth:"
"`socket.close` не викликано для об’єкта сокета."

#: ../../library/socket.rst:1397
msgid ""
"On Windows, the file-like object created by :meth:`makefile` cannot be used "
"where a file object with a file descriptor is expected, such as the stream "
"arguments of :meth:`subprocess.Popen`."
msgstr ""
"У Windows файлоподібний об’єкт, створений :meth:`makefile`, не можна "
"використовувати там, де очікується файловий об’єкт із дескриптором файлу, "
"наприклад аргументи потоку :meth:`subprocess.Popen`."

#: ../../library/socket.rst:1404
msgid ""
"Receive data from the socket.  The return value is a bytes object "
"representing the data received.  The maximum amount of data to be received "
"at once is specified by *bufsize*.  See the Unix manual page :manpage:"
"`recv(2)` for the meaning of the optional argument *flags*; it defaults to "
"zero."
msgstr ""
"Отримувати дані з розетки. Повернене значення — це об’єкт байтів, що "
"представляє отримані дані. Максимальний обсяг даних, які потрібно отримати "
"одночасно, визначається *bufsize*. Перегляньте сторінку посібника Unix :"
"manpage:`recv(2)` для визначення значення необов’язкового аргументу *flags*; "
"за замовчуванням він дорівнює нулю."

#: ../../library/socket.rst:1411
msgid ""
"For best match with hardware and network realities, the value of  *bufsize* "
"should be a relatively small power of 2, for example, 4096."
msgstr ""
"Для найкращої відповідності апаратному забезпеченню та мережевим реаліям "
"значення *bufsize* має бути відносно малим ступенем 2, наприклад, 4096."

#: ../../library/socket.rst:1422
msgid ""
"Receive data from the socket.  The return value is a pair ``(bytes, "
"address)`` where *bytes* is a bytes object representing the data received "
"and *address* is the address of the socket sending the data.  See the Unix "
"manual page :manpage:`recv(2)` for the meaning of the optional argument "
"*flags*; it defaults to zero. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"Отримувати дані з розетки. Поверненим значенням є пара ``(байти, адреса)``, "
"де *байт* — об’єкт байтів, що представляє отримані дані, а *адреса* — адреса "
"сокета, який надсилає дані. Перегляньте сторінку посібника Unix :manpage:"
"`recv(2)` для визначення значення необов’язкового аргументу *flags*; за "
"замовчуванням він дорівнює нулю. (Формат *адреси* залежить від групи адрес "
"--- див. вище.)"

#: ../../library/socket.rst:1433
msgid ""
"For multicast IPv6 address, first item of *address* does not contain "
"``%scope_id`` part anymore. In order to get full IPv6 address use :func:"
"`getnameinfo`."
msgstr ""
"Для багатоадресної адреси IPv6 перший елемент *address* більше не містить "
"частини ``%scope_id``. Щоб отримати повну адресу IPv6, використовуйте :func:"
"`getnameinfo`."

#: ../../library/socket.rst:1440
msgid ""
"Receive normal data (up to *bufsize* bytes) and ancillary data from the "
"socket.  The *ancbufsize* argument sets the size in bytes of the internal "
"buffer used to receive the ancillary data; it defaults to 0, meaning that no "
"ancillary data will be received.  Appropriate buffer sizes for ancillary "
"data can be calculated using :func:`CMSG_SPACE` or :func:`CMSG_LEN`, and "
"items which do not fit into the buffer might be truncated or discarded.  The "
"*flags* argument defaults to 0 and has the same meaning as for :meth:`recv`."
msgstr ""
"Отримувати звичайні дані (до *bufsize* байтів) і допоміжні дані з сокета. "
"Аргумент *ancbufsize* встановлює розмір у байтах внутрішнього буфера, який "
"використовується для отримання допоміжних даних; за замовчуванням він "
"дорівнює 0, що означає, що допоміжні дані не будуть отримані. Відповідні "
"розміри буферів для допоміжних даних можна обчислити за допомогою :func:"
"`CMSG_SPACE` або :func:`CMSG_LEN`, а елементи, які не вміщаються в буфер, "
"можуть бути скорочені або відкинуті. Аргумент *flags* за умовчанням дорівнює "
"0 і має те саме значення, що й для :meth:`recv`."

#: ../../library/socket.rst:1450
msgid ""
"The return value is a 4-tuple: ``(data, ancdata, msg_flags, address)``.  The "
"*data* item is a :class:`bytes` object holding the non-ancillary data "
"received.  The *ancdata* item is a list of zero or more tuples "
"``(cmsg_level, cmsg_type, cmsg_data)`` representing the ancillary data "
"(control messages) received: *cmsg_level* and *cmsg_type* are integers "
"specifying the protocol level and protocol-specific type respectively, and "
"*cmsg_data* is a :class:`bytes` object holding the associated data.  The "
"*msg_flags* item is the bitwise OR of various flags indicating conditions on "
"the received message; see your system documentation for details. If the "
"receiving socket is unconnected, *address* is the address of the sending "
"socket, if available; otherwise, its value is unspecified."
msgstr ""
"Повернене значення – це 4-кортеж: ``(data, ancdata, msg_flags, address)``. "
"Елемент *data* — це об’єкт :class:`bytes`, що містить отримані непобічні "
"дані. Елемент *ancdata* — це список із нуля або більше кортежів "
"``(cmsg_level, cmsg_type, cmsg_data)``, що представляють отримані допоміжні "
"дані (керуючі повідомлення): *cmsg_level* і *cmsg_type* — цілі числа, що "
"визначають рівень протоколу та протокол- певного типу відповідно, і "
"*cmsg_data* є об’єктом :class:`bytes`, що містить пов’язані дані. Елемент "
"*msg_flags* — це порозрядне АБО різних прапорів, що вказують на умови "
"отриманого повідомлення; подробиці дивіться в системній документації. Якщо "
"сокет-одержувач не підключений, *адреса* є адресою сокета-відправника, якщо "
"він доступний; інакше його значення не вказано."

#: ../../library/socket.rst:1464
msgid ""
"On some systems, :meth:`sendmsg` and :meth:`recvmsg` can be used to pass "
"file descriptors between processes over an :const:`AF_UNIX` socket.  When "
"this facility is used (it is often restricted to :const:`SOCK_STREAM` "
"sockets), :meth:`recvmsg` will return, in its ancillary data, items of the "
"form ``(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)``, where *fds* is a :"
"class:`bytes` object representing the new file descriptors as a binary array "
"of the native C :c:type:`int` type.  If :meth:`recvmsg` raises an exception "
"after the system call returns, it will first attempt to close any file "
"descriptors received via this mechanism."
msgstr ""

#: ../../library/socket.rst:1475
msgid ""
"Some systems do not indicate the truncated length of ancillary data items "
"which have been only partially received.  If an item appears to extend "
"beyond the end of the buffer, :meth:`recvmsg` will issue a :exc:"
"`RuntimeWarning`, and will return the part of it which is inside the buffer "
"provided it has not been truncated before the start of its associated data."
msgstr ""
"Деякі системи не вказують скорочену довжину елементів допоміжних даних, які "
"були отримані лише частково. Якщо елемент виходить за кінець буфера, :meth:"
"`recvmsg` видає :exc:`RuntimeWarning` і повертає його частину, яка "
"знаходиться всередині буфера, за умови, що вона не була скорочена до початку "
"своїх пов’язаних даних."

#: ../../library/socket.rst:1482
msgid ""
"On systems which support the :const:`SCM_RIGHTS` mechanism, the following "
"function will receive up to *maxfds* file descriptors, returning the message "
"data and a list containing the descriptors (while ignoring unexpected "
"conditions such as unrelated control messages being received).  See also :"
"meth:`sendmsg`. ::"
msgstr ""
"У системах, які підтримують механізм :const:`SCM_RIGHTS`, наступна функція "
"отримає до *maxfds* файлових дескрипторів, повертаючи дані повідомлення та "
"список, що містить дескриптори (ігноруючи неочікувані умови, такі як "
"отримання непов’язаних керуючих повідомлень). Дивіться також :meth:"
"`sendmsg`. ::"

#: ../../library/socket.rst:1511
msgid ""
"Receive normal data and ancillary data from the socket, behaving as :meth:"
"`recvmsg` would, but scatter the non-ancillary data into a series of buffers "
"instead of returning a new bytes object.  The *buffers* argument must be an "
"iterable of objects that export writable buffers (e.g. :class:`bytearray` "
"objects); these will be filled with successive chunks of the non-ancillary "
"data until it has all been written or there are no more buffers.  The "
"operating system may set a limit (:func:`~os.sysconf` value ``SC_IOV_MAX``) "
"on the number of buffers that can be used.  The *ancbufsize* and *flags* "
"arguments have the same meaning as for :meth:`recvmsg`."
msgstr ""
"Отримувати звичайні дані та допоміжні дані з сокета, поводячись так, як це "
"зробив би :meth:`recvmsg`, але розкидати не допоміжні дані в ряд буферів "
"замість повернення нового об’єкта bytes. Аргумент *buffers* має бути "
"ітерованим об’єктами, які експортують записувані буфери (наприклад, об’єкти :"
"class:`bytearray`); вони будуть заповнені послідовними фрагментами "
"непоміжних даних, доки вони не будуть записані або більше не залишиться "
"буферів. Операційна система може встановити обмеження (:func:`~os.sysconf` "
"значення ``SC_IOV_MAX``) на кількість буферів, які можна використовувати. "
"Аргументи *ancbufsize* і *flags* мають те саме значення, що й для :meth:"
"`recvmsg`."

#: ../../library/socket.rst:1522
msgid ""
"The return value is a 4-tuple: ``(nbytes, ancdata, msg_flags, address)``, "
"where *nbytes* is the total number of bytes of non-ancillary data written "
"into the buffers, and *ancdata*, *msg_flags* and *address* are the same as "
"for :meth:`recvmsg`."
msgstr ""
"Повернене значення — це 4-кортеж: ``(nbytes, ancdata, msg_flags, address)``, "
"де *nbytes* — загальна кількість байтів непоміжних даних, записаних у "
"буфери, а *ancdata*, *msg_flags* і *адреса* такі самі, як і для :meth:"
"`recvmsg`."

#: ../../library/socket.rst:1527
msgid "Example::"
msgstr "Exemplo::"

#: ../../library/socket.rst:1548
msgid ""
"Receive data from the socket, writing it into *buffer* instead of creating a "
"new bytestring.  The return value is a pair ``(nbytes, address)`` where "
"*nbytes* is the number of bytes received and *address* is the address of the "
"socket sending the data.  See the Unix manual page :manpage:`recv(2)` for "
"the meaning of the optional argument *flags*; it defaults to zero.  (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"Отримувати дані з сокета, записуючи їх у *буфер* замість створення нового "
"байтового рядка. Поверненим значенням є пара ``(nbytes, address)``, де "
"*nbytes* — це кількість отриманих байтів, а *address* — це адреса сокета, "
"який надсилає дані. Перегляньте сторінку посібника Unix :manpage:`recv(2)` "
"для визначення значення необов’язкового аргументу *flags*; за замовчуванням "
"він дорівнює нулю. (Формат *адреси* залежить від групи адрес --- див. вище.)"

#: ../../library/socket.rst:1558
msgid ""
"Receive up to *nbytes* bytes from the socket, storing the data into a buffer "
"rather than creating a new bytestring.  If *nbytes* is not specified (or 0), "
"receive up to the size available in the given buffer.  Returns the number of "
"bytes received.  See the Unix manual page :manpage:`recv(2)` for the meaning "
"of the optional argument *flags*; it defaults to zero."
msgstr ""
"Отримайте до *nbytes* байт із сокета, зберігаючи дані в буфері, а не "
"створюючи новий рядок байтів. Якщо *nbytes* не вказано (або 0), отримати до "
"розміру, доступного в даному буфері. Повертає кількість отриманих байтів. "
"Перегляньте сторінку посібника Unix :manpage:`recv(2)` для визначення "
"значення необов’язкового аргументу *flags*; за замовчуванням він дорівнює "
"нулю."

#: ../../library/socket.rst:1567
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Returns the number of bytes sent. Applications are responsible for "
"checking that all data has been sent; if only some of the data was "
"transmitted, the application needs to attempt delivery of the remaining "
"data. For further information on this topic, consult the :ref:`socket-howto`."
msgstr ""
"Надіслати дані в сокет. Розетка повинна бути підключена до віддаленої "
"розетки. Необов’язковий аргумент *flags* має те саме значення, що й для :"
"meth:`recv` вище. Повертає кількість надісланих байтів. Додатки відповідають "
"за перевірку того, що всі дані були надіслані; якщо було передано лише "
"частину даних, програма повинна спробувати доставити решту даних. Для "
"отримання додаткової інформації з цієї теми зверніться до :ref:`socket-"
"howto`."

#: ../../library/socket.rst:1582
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Unlike :meth:`send`, this method continues to send data from *bytes* "
"until either all data has been sent or an error occurs.  ``None`` is "
"returned on success.  On error, an exception is raised, and there is no way "
"to determine how much data, if any, was successfully sent."
msgstr ""
"Надіслати дані в сокет. Розетка повинна бути підключена до віддаленої "
"розетки. Необов’язковий аргумент *flags* має те саме значення, що й для :"
"meth:`recv` вище. На відміну від :meth:`send`, цей метод продовжує надсилати "
"дані з *байтів*, доки не буде надіслано всі дані або не станеться помилка. "
"``None`` повертається в разі успіху. У разі помилки виникає виняток, і немає "
"способу визначити, скільки даних було успішно надіслано, якщо такі були."

#: ../../library/socket.rst:1589
msgid ""
"The socket timeout is no more reset each time data is sent successfully. The "
"socket timeout is now the maximum total duration to send all data."
msgstr ""

#: ../../library/socket.rst:1602
msgid ""
"Send data to the socket.  The socket should not be connected to a remote "
"socket, since the destination socket is specified by *address*.  The "
"optional *flags* argument has the same meaning as for :meth:`recv` above.  "
"Return the number of bytes sent. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"Надіслати дані в сокет. Сокет не слід підключати до віддаленого сокета, "
"оскільки сокет призначення вказується *адресою*. Необов’язковий аргумент "
"*flags* має те саме значення, що й для :meth:`recv` вище. Повертає кількість "
"надісланих байтів. (Формат *адреси* залежить від групи адрес --- див. вище.)"

#: ../../library/socket.rst:1608
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendto`` with arguments "
"``self``, ``address``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``socket.sendto`` com os "
"argumentos ``self``, ``address``."

#: ../../library/socket.rst:1618
msgid ""
"Send normal and ancillary data to the socket, gathering the non-ancillary "
"data from a series of buffers and concatenating it into a single message.  "
"The *buffers* argument specifies the non-ancillary data as an iterable of :"
"term:`bytes-like objects <bytes-like object>` (e.g. :class:`bytes` objects); "
"the operating system may set a limit (:func:`~os.sysconf` value "
"``SC_IOV_MAX``) on the number of buffers that can be used.  The *ancdata* "
"argument specifies the ancillary data (control messages) as an iterable of "
"zero or more tuples ``(cmsg_level, cmsg_type, cmsg_data)``, where "
"*cmsg_level* and *cmsg_type* are integers specifying the protocol level and "
"protocol-specific type respectively, and *cmsg_data* is a bytes-like object "
"holding the associated data.  Note that some systems (in particular, systems "
"without :func:`CMSG_SPACE`) might support sending only one control message "
"per call.  The *flags* argument defaults to 0 and has the same meaning as "
"for :meth:`send`.  If *address* is supplied and not ``None``, it sets a "
"destination address for the message.  The return value is the number of "
"bytes of non-ancillary data sent."
msgstr ""
"Надсилайте звичайні та допоміжні дані в сокет, збираючи недопоміжні дані з "
"ряду буферів і об’єднуючи їх в одне повідомлення. Аргумент *buffers* вказує "
"на не допоміжні дані як ітерацію :term:`bytes-подібних об’єктів <bytes-like "
"object>` (наприклад, :class:`bytes` об’єктів); операційна система може "
"встановити обмеження (:func:`~os.sysconf` значення ``SC_IOV_MAX``) на "
"кількість буферів, які можна використовувати. Аргумент *ancdata* визначає "
"допоміжні дані (керуючі повідомлення) як ітерацію з нуля або більше кортежів "
"``(cmsg_level, cmsg_type, cmsg_data)``, де *cmsg_level* і *cmsg_type* є "
"цілими числами, що визначають рівень протоколу та протокол- певного типу "
"відповідно, а *cmsg_data* — це байтиподібний об’єкт, що містить пов’язані "
"дані. Зверніть увагу, що деякі системи (зокрема, системи без :func:"
"`CMSG_SPACE`) можуть підтримувати надсилання лише одного керуючого "
"повідомлення на виклик. Аргумент *flags* за умовчанням дорівнює 0 і має те "
"саме значення, що й для :meth:`send`. Якщо вказано *address*, а не ``None``, "
"це встановлює адресу призначення для повідомлення. Повернене значення — це "
"кількість байтів надісланих непоміжних даних."

#: ../../library/socket.rst:1638
msgid ""
"The following function sends the list of file descriptors *fds* over an :"
"const:`AF_UNIX` socket, on systems which support the :const:`SCM_RIGHTS` "
"mechanism.  See also :meth:`recvmsg`. ::"
msgstr ""
"Наступна функція надсилає список дескрипторів файлів *fds* через сокет :"
"const:`AF_UNIX` у системах, які підтримують механізм :const:`SCM_RIGHTS`. "
"Дивіться також :meth:`recvmsg`. ::"

#: ../../library/socket.rst:1649
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendmsg`` with arguments "
"``self``, ``address``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``socket.sendmsg`` com os "
"argumentos ``self``, ``address``."

#: ../../library/socket.rst:1660
msgid ""
"Specialized version of :meth:`~socket.sendmsg` for :const:`AF_ALG` socket. "
"Set mode, IV, AEAD associated data length and flags for :const:`AF_ALG` "
"socket."
msgstr ""
"Спеціалізована версія :meth:`~socket.sendmsg` для :const:`AF_ALG` сокета. "
"Установіть довжину пов’язаних даних режиму, IV, AEAD і прапорці для сокета :"
"const:`AF_ALG`."

#: ../../library/socket.rst:1669
msgid ""
"Send a file until EOF is reached by using high-performance :mod:`os."
"sendfile` and return the total number of bytes which were sent. *file* must "
"be a regular file object opened in binary mode. If :mod:`os.sendfile` is not "
"available (e.g. Windows) or *file* is not a regular file :meth:`send` will "
"be used instead. *offset* tells from where to start reading the file. If "
"specified, *count* is the total number of bytes to transmit as opposed to "
"sending the file until EOF is reached. File position is updated on return or "
"also in case of error in which case :meth:`file.tell() <io.IOBase.tell>` can "
"be used to figure out the number of bytes which were sent. The socket must "
"be of :const:`SOCK_STREAM` type. Non-blocking sockets are not supported."
msgstr ""
"Надсилайте файл до досягнення EOF за допомогою високопродуктивного :mod:`os."
"sendfile` і повертайте загальну кількість надісланих байтів. *file* має бути "
"звичайним файловим об’єктом, відкритим у двійковому режимі. Якщо :mod:`os."
"sendfile` недоступний (наприклад, Windows) або *file* не є звичайним файлом, "
"замість нього буде використано :meth:`send`. *offset* вказує, звідки почати "
"читання файлу. Якщо вказано, *count* — це загальна кількість байтів для "
"передачі, а не надсилання файлу до досягнення EOF. Позиція файлу оновлюється "
"при поверненні або також у разі помилки, у цьому випадку :meth:`file.tell() "
"<io.IOBase.tell>` можна використовувати для визначення кількості надісланих "
"байтів. Сокет має бути типу :const:`SOCK_STREAM`. Неблокуючі сокети не "
"підтримуються."

#: ../../library/socket.rst:1685
msgid ""
"Set the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle."
msgstr ""
"Установіть :ref:`inheritable flag <fd_inheritance>` дескриптора файлу сокета "
"або дескриптора сокета."

#: ../../library/socket.rst:1693
msgid ""
"Set blocking or non-blocking mode of the socket: if *flag* is false, the "
"socket is set to non-blocking, else to blocking mode."
msgstr ""
"Встановіть блокуючий або неблокуючий режим сокета: якщо *flag* має значення "
"false, сокет встановлено в неблокуючий режим, інакше в режим блокування."

#: ../../library/socket.rst:1696
msgid ""
"This method is a shorthand for certain :meth:`~socket.settimeout` calls:"
msgstr "Цей метод є скороченням певних викликів :meth:`~socket.settimeout`:"

#: ../../library/socket.rst:1698
msgid "``sock.setblocking(True)`` is equivalent to ``sock.settimeout(None)``"
msgstr "``sock.setblocking(True)`` еквівалентно ``sock.settimeout(None)``"

#: ../../library/socket.rst:1700
msgid "``sock.setblocking(False)`` is equivalent to ``sock.settimeout(0.0)``"
msgstr "``sock.setblocking(False)`` еквівалентний ``sock.settimeout(0.0)``"

#: ../../library/socket.rst:1702
msgid ""
"The method no longer applies :const:`SOCK_NONBLOCK` flag on :attr:`socket."
"type`."
msgstr ""
"Метод більше не застосовує прапор :const:`SOCK_NONBLOCK` до :attr:`socket."
"type`."

#: ../../library/socket.rst:1709
msgid ""
"Set a timeout on blocking socket operations.  The *value* argument can be a "
"nonnegative floating point number expressing seconds, or ``None``. If a non-"
"zero value is given, subsequent socket operations will raise a :exc:"
"`timeout` exception if the timeout period *value* has elapsed before the "
"operation has completed.  If zero is given, the socket is put in non-"
"blocking mode. If ``None`` is given, the socket is put in blocking mode."
msgstr ""
"Встановіть тайм-аут для блокування операцій сокетів. Аргументом *value* може "
"бути невід’ємне число з плаваючою комою, що виражає секунди, або ``None``. "
"Якщо задано ненульове значення, наступні операції з сокетом викличуть "
"виняток :exc:`timeout`, якщо період очікування *значення* минув до "
"завершення операції. Якщо вказано нуль, сокет переходить у неблокуючий "
"режим. Якщо задано ``None``, сокет переходить у режим блокування."

#: ../../library/socket.rst:1716
msgid ""
"For further information, please consult the :ref:`notes on socket timeouts "
"<socket-timeouts>`."
msgstr ""
"Щоб отримати додаткову інформацію, зверніться до :ref:`приміток щодо тайм-"
"аутів сокетів <socket-timeouts>`."

#: ../../library/socket.rst:1718
msgid ""
"The method no longer toggles :const:`SOCK_NONBLOCK` flag on :attr:`socket."
"type`."
msgstr ""
"Метод більше не вмикає прапор :const:`SOCK_NONBLOCK` на :attr:`socket.type`."

#: ../../library/socket.rst:1731
msgid ""
"Set the value of the given socket option (see the Unix manual page :manpage:"
"`setsockopt(2)`).  The needed symbolic constants are defined in the :mod:"
"`socket` module (:const:`SO_\\*` etc.).  The value can be an integer, "
"``None`` or a :term:`bytes-like object` representing a buffer. In the later "
"case it is up to the caller to ensure that the bytestring contains the "
"proper bits (see the optional built-in module :mod:`struct` for a way to "
"encode C structures as bytestrings). When *value* is set to ``None``, "
"*optlen* argument is required. It's equivalent to call :c:func:`setsockopt` "
"C function with ``optval=NULL`` and ``optlen=optlen``."
msgstr ""
"Встановіть значення даного параметра сокета (дивіться сторінку посібника "
"Unix :manpage:`setsockopt(2)`). Необхідні символічні константи визначені в "
"модулі :mod:`socket` (:const:`SO_\\*` тощо). Значення може бути цілим "
"числом, ``None`` або :term:`bytes-like object`, що представляє буфер. У "
"останньому випадку абонент повинен переконатися, що байтовий рядок містить "
"правильні біти (дивіться необов’язковий вбудований модуль :mod:`struct` для "
"того, щоб закодувати структури C як байтові рядки). Якщо *value* має "
"значення ``None``, аргумент *optlen* є обов’язковим. Це еквівалентно "
"виклику :c:func:`setsockopt` функції C з ``optval=NULL`` і ``optlen=optlen``."

#: ../../library/socket.rst:1745
msgid "setsockopt(level, optname, None, optlen: int) form added."
msgstr "Додано форму setsockopt(level, optname, None, optlen: int)."

#: ../../library/socket.rst:1751
msgid ""
"Shut down one or both halves of the connection.  If *how* is :const:"
"`SHUT_RD`, further receives are disallowed.  If *how* is :const:`SHUT_WR`, "
"further sends are disallowed.  If *how* is :const:`SHUT_RDWR`, further sends "
"and receives are disallowed."
msgstr ""
"Вимкніть одну або обидві половини з’єднання. Якщо *how* :const:`SHUT_RD`, "
"подальші прийоми заборонені. Якщо *how* :const:`SHUT_WR`, подальші "
"надсилання заборонені. Якщо *how* :const:`SHUT_RDWR`, подальше надсилання та "
"отримання заборонено."

#: ../../library/socket.rst:1759
msgid ""
"Duplicate a socket and prepare it for sharing with a target process.  The "
"target process must be provided with *process_id*.  The resulting bytes "
"object can then be passed to the target process using some form of "
"interprocess communication and the socket can be recreated there using :func:"
"`fromshare`. Once this method has been called, it is safe to close the "
"socket since the operating system has already duplicated it for the target "
"process."
msgstr ""
"Скопіюйте сокет і підготуйте його для спільного використання з цільовим "
"процесом. Цільовому процесу має бути надано *process_id*. Отриманий об’єкт "
"bytes потім можна передати цільовому процесу за допомогою певної форми "
"міжпроцесного зв’язку, а сокет можна відтворити там за допомогою :func:"
"`fromshare`. Після виклику цього методу можна безпечно закрити сокет, "
"оскільки операційна система вже скопіювала його для цільового процесу."

#: ../../library/socket.rst:1771
msgid ""
"Note that there are no methods :meth:`read` or :meth:`write`; use :meth:"
"`~socket.recv` and :meth:`~socket.send` without *flags* argument instead."
msgstr ""
"Зверніть увагу, що немає методів :meth:`read` або :meth:`write`; замість "
"цього використовуйте :meth:`~socket.recv` і :meth:`~socket.send` без "
"аргументу *flags*."

#: ../../library/socket.rst:1774
msgid ""
"Socket objects also have these (read-only) attributes that correspond to the "
"values given to the :class:`~socket.socket` constructor."
msgstr ""
"Об’єкти Socket також мають ці атрибути (лише для читання), які відповідають "
"значенням, наданим конструктору :class:`~socket.socket`."

#: ../../library/socket.rst:1780
msgid "The socket family."
msgstr "Сімейство розеток."

#: ../../library/socket.rst:1785
msgid "The socket type."
msgstr "Тип розетки."

#: ../../library/socket.rst:1790
msgid "The socket protocol."
msgstr "Протокол сокета."

#: ../../library/socket.rst:1797
msgid "Notes on socket timeouts"
msgstr "Notas sobre tempo limite de soquete"

#: ../../library/socket.rst:1799
msgid ""
"A socket object can be in one of three modes: blocking, non-blocking, or "
"timeout.  Sockets are by default always created in blocking mode, but this "
"can be changed by calling :func:`setdefaulttimeout`."
msgstr ""
"Um objeto soquete pode estar em um dos três modos: bloqueio, não-bloqueio ou "
"tempo limite. Por padrão, os soquetes sempre são criados no modo de "
"bloqueio, mas isso pode ser alterado chamando :func:`setdefaulttimeout`."

#: ../../library/socket.rst:1803
msgid ""
"In *blocking mode*, operations block until complete or the system returns an "
"error (such as connection timed out)."
msgstr ""
"У *режимі блокування* операції блокуються до завершення або доки система не "
"поверне повідомлення про помилку (наприклад, час очікування підключення "
"закінчився)."

#: ../../library/socket.rst:1806
msgid ""
"In *non-blocking mode*, operations fail (with an error that is unfortunately "
"system-dependent) if they cannot be completed immediately: functions from "
"the :mod:`select` can be used to know when and whether a socket is available "
"for reading or writing."
msgstr ""

#: ../../library/socket.rst:1811
msgid ""
"In *timeout mode*, operations fail if they cannot be completed within the "
"timeout specified for the socket (they raise a :exc:`timeout` exception) or "
"if the system returns an error."
msgstr ""
"У *режимі тайм-ауту* операції завершуються невдало, якщо їх не можна "
"завершити протягом тайм-ауту, указаного для сокета (вони викликають виняток :"
"exc:`timeout`) або якщо система повертає помилку."

#: ../../library/socket.rst:1816
msgid ""
"At the operating system level, sockets in *timeout mode* are internally set "
"in non-blocking mode.  Also, the blocking and timeout modes are shared "
"between file descriptors and socket objects that refer to the same network "
"endpoint. This implementation detail can have visible consequences if e.g. "
"you decide to use the :meth:`~socket.fileno()` of a socket."
msgstr ""
"На рівні операційної системи сокети в *режимі тайм-ауту* внутрішньо "
"налаштовані на неблокуючий режим. Крім того, режими блокування та тайм-ауту "
"розподіляються між файловими дескрипторами та об’єктами сокетів, які "
"посилаються на ту саму кінцеву точку мережі. Ця деталь впровадження може "
"мати видимі наслідки, якщо, напр. ви вирішили використовувати :meth:`~socket."
"fileno()` сокета."

#: ../../library/socket.rst:1823
msgid "Timeouts and the ``connect`` method"
msgstr "Час очікування та метод ``connect``"

#: ../../library/socket.rst:1825
msgid ""
"The :meth:`~socket.connect` operation is also subject to the timeout "
"setting, and in general it is recommended to call :meth:`~socket.settimeout` "
"before calling :meth:`~socket.connect` or pass a timeout parameter to :meth:"
"`create_connection`.  However, the system network stack may also return a "
"connection timeout error of its own regardless of any Python socket timeout "
"setting."
msgstr ""
"Операція :meth:`~socket.connect` також залежить від параметра тайм-ауту, і "
"загалом рекомендується викликати :meth:`~socket.settimeout` перед викликом :"
"meth:`~socket.connect` або передати параметр часу очікування для :meth:"
"`create_connection`. Однак системний мережевий стек також може повертати "
"власну помилку очікування підключення незалежно від будь-якого параметра "
"часу очікування сокета Python."

#: ../../library/socket.rst:1833
msgid "Timeouts and the ``accept`` method"
msgstr "Час очікування та метод ``accept``"

#: ../../library/socket.rst:1835
msgid ""
"If :func:`getdefaulttimeout` is not :const:`None`, sockets returned by the :"
"meth:`~socket.accept` method inherit that timeout.  Otherwise, the behaviour "
"depends on settings of the listening socket:"
msgstr ""
"Якщо :func:`getdefaulttimeout` не :const:`None`, сокети, повернуті методом :"
"meth:`~socket.accept`, успадковують цей час очікування. В іншому випадку "
"поведінка залежить від налаштувань прослуховувального сокета:"

#: ../../library/socket.rst:1839
msgid ""
"if the listening socket is in *blocking mode* or in *timeout mode*, the "
"socket returned by :meth:`~socket.accept` is in *blocking mode*;"
msgstr ""
"якщо прослуховувальний сокет знаходиться в *режимі блокування* або в *режимі "
"очікування*, сокет, який повертає :meth:`~socket.accept`, знаходиться в "
"*режимі блокування*;"

#: ../../library/socket.rst:1842
msgid ""
"if the listening socket is in *non-blocking mode*, whether the socket "
"returned by :meth:`~socket.accept` is in blocking or non-blocking mode is "
"operating system-dependent.  If you want to ensure cross-platform behaviour, "
"it is recommended you manually override this setting."
msgstr ""
"якщо сокет, що прослуховує, знаходиться в *неблокуючому режимі*, чи є сокет, "
"повернутий :meth:`~socket.accept` у блокуючому чи неблокуючому режимі, "
"залежить від операційної системи. Якщо ви хочете забезпечити кросплатформну "
"поведінку, радимо вручну змінити це налаштування."

#: ../../library/socket.rst:1851
msgid "Example"
msgstr "Exemplo"

#: ../../library/socket.rst:1853
msgid ""
"Here are four minimal example programs using the TCP/IP protocol: a server "
"that echoes all data that it receives back (servicing only one client), and "
"a client using it.  Note that a server must perform the sequence :func:`."
"socket`, :meth:`~socket.bind`, :meth:`~socket.listen`, :meth:`~socket."
"accept` (possibly repeating the :meth:`~socket.accept` to service more than "
"one client), while a client only needs the sequence :func:`.socket`, :meth:"
"`~socket.connect`.  Also note that the server does not :meth:`~socket."
"sendall`/:meth:`~socket.recv` on the socket it is listening on but on the "
"new socket returned by :meth:`~socket.accept`."
msgstr ""
"Ось чотири мінімальні приклади програм, які використовують протокол TCP/IP: "
"сервер, який відтворює всі отримані дані (обслуговуючи лише одного клієнта), "
"і клієнт, який його використовує. Зауважте, що сервер повинен виконати "
"послідовність :func:`.socket`, :meth:`~socket.bind`, :meth:`~socket."
"listen`, :meth:`~socket.accept` (можливо, повторюючи :meth:`~socket.accept` "
"для обслуговування більш ніж одного клієнта), тоді як клієнту потрібна лише "
"послідовність :func:`.socket`, :meth:`~socket.connect`. Також зауважте, що "
"сервер не :meth:`~socket.sendall`/:meth:`~socket.recv` на сокет, який він "
"прослуховує, а на новий сокет, повернутий :meth:`~socket.accept`."

#: ../../library/socket.rst:1863
msgid "The first two examples support IPv4 only. ::"
msgstr "Перші два приклади підтримують лише IPv4. ::"

#: ../../library/socket.rst:1894
msgid ""
"The next two examples are identical to the above two, but support both IPv4 "
"and IPv6. The server side will listen to the first address family available "
"(it should listen to both instead). On most of IPv6-ready systems, IPv6 will "
"take precedence and the server may not accept IPv4 traffic. The client side "
"will try to connect to the all addresses returned as a result of the name "
"resolution, and sends traffic to the first one connected successfully. ::"
msgstr ""
"Наступні два приклади ідентичні наведеним вище, але підтримують як IPv4, так "
"і IPv6. Сторона сервера прослуховуватиме перше доступне сімейство адрес "
"(замість цього вона має прослуховувати обидва). У більшості систем із "
"підтримкою IPv6 IPv6 матиме пріоритет, і сервер може не приймати трафік "
"IPv4. Клієнтська сторона спробує підключитися до всіх адрес, отриманих у "
"результаті розпізнавання імен, і надсилає трафік на першу з успішно "
"підключених адрес. ::"

#: ../../library/socket.rst:1966
msgid ""
"The next example shows how to write a very simple network sniffer with raw "
"sockets on Windows. The example requires administrator privileges to modify "
"the interface::"
msgstr ""
"У наступному прикладі показано, як написати дуже простий мережевий сніфер із "
"необробленими сокетами у Windows. У прикладі потрібні права адміністратора, "
"щоб змінити інтерфейс:"

#: ../../library/socket.rst:1991
msgid ""
"The next example shows how to use the socket interface to communicate to a "
"CAN network using the raw socket protocol. To use CAN with the broadcast "
"manager protocol instead, open a socket with::"
msgstr ""
"У наступному прикладі показано, як використовувати інтерфейс сокета для "
"зв’язку з мережею CAN за допомогою необробленого протоколу сокета. Щоб "
"замість цього використовувати CAN із протоколом диспетчера трансляції, "
"відкрийте сокет за допомогою:"

#: ../../library/socket.rst:1997
msgid ""
"After binding (:const:`CAN_RAW`) or connecting (:const:`CAN_BCM`) the "
"socket, you can use the :meth:`socket.send`, and the :meth:`socket.recv` "
"operations (and their counterparts) on the socket object as usual."
msgstr ""

#: ../../library/socket.rst:2001
msgid "This last example might require special privileges::"
msgstr "Цей останній приклад може вимагати спеціальних привілеїв:"

#: ../../library/socket.rst:2041
msgid ""
"Running an example several times with too small delay between executions, "
"could lead to this error::"
msgstr ""
"Запуск прикладу кілька разів із занадто малою затримкою між виконаннями може "
"призвести до цієї помилки::"

#: ../../library/socket.rst:2046
msgid ""
"This is because the previous execution has left the socket in a "
"``TIME_WAIT`` state, and can't be immediately reused."
msgstr ""
"Це пов’язано з тим, що попереднє виконання залишило сокет у стані "
"``TIME_WAIT`` і не може бути негайно повторно використано."

#: ../../library/socket.rst:2049
msgid ""
"There is a :mod:`socket` flag to set, in order to prevent this, :data:"
"`socket.SO_REUSEADDR`::"
msgstr ""
"Існує прапорець :mod:`socket`, щоб запобігти цьому, :data:`socket."
"SO_REUSEADDR`::"

#: ../../library/socket.rst:2056
msgid ""
"the :data:`SO_REUSEADDR` flag tells the kernel to reuse a local socket in "
"``TIME_WAIT`` state, without waiting for its natural timeout to expire."
msgstr ""
"прапорець :data:`SO_REUSEADDR` повідомляє ядру повторно використовувати "
"локальний сокет у стані ``TIME_WAIT``, не чекаючи закінчення його природного "
"часу очікування."

#: ../../library/socket.rst:2062
msgid ""
"For an introduction to socket programming (in C), see the following papers:"
msgstr ""
"Para uma introdução à programação de socket (em C), veja os seguintes "
"artigos:"

#: ../../library/socket.rst:2064
msgid ""
"*An Introductory 4.3BSD Interprocess Communication Tutorial*, by Stuart "
"Sechrest"
msgstr ""
"*Вступний навчальний посібник із взаємодії між процесами 4.3BSD*, Стюарт "
"Сехрест"

#: ../../library/socket.rst:2066
msgid ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*, by Samuel J.  "
"Leffler et al,"
msgstr ""
"*Навчальний посібник із розширеного міжпроцесного зв’язку 4.3BSD*, Семюел "
"Дж. Леффлер та інші,"

#: ../../library/socket.rst:2069
msgid ""
"both in the UNIX Programmer's Manual, Supplementary Documents 1 (sections "
"PS1:7 and PS1:8).  The platform-specific reference material for the various "
"socket-related system calls are also a valuable source of information on the "
"details of socket semantics.  For Unix, refer to the manual pages; for "
"Windows, see the WinSock (or Winsock 2) specification.  For IPv6-ready APIs, "
"readers may want to refer to :rfc:`3493` titled Basic Socket Interface "
"Extensions for IPv6."
msgstr ""
"обидва в Посібнику програміста UNIX, Додаткові документи 1 (розділи PS1:7 та "
"PS1:8). Довідковий матеріал для певної платформи для різноманітних системних "
"викликів, пов’язаних із сокетами, також є цінним джерелом інформації про "
"деталі семантики сокетів. Для Unix зверніться до сторінок посібника; для "
"Windows дивіться специфікацію WinSock (або Winsock 2). Щодо API, готових до "
"IPv6, читачі можуть звернутися до :rfc:`3493` під назвою Basic Socket "
"Interface Extensions for IPv6."

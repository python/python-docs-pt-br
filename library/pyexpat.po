# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# And Past <andrepgs@gmail.com>, 2021
# i17obot <i17obot@rougeth.com>, 2021
# Marco Rougeth <marco@rougeth.com>, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 14:21+0000\n"
"PO-Revision-Date: 2021-06-28 01:12+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/pyexpat.rst:2
msgid ":mod:`!xml.parsers.expat` --- Fast XML parsing using Expat"
msgstr ""

#: ../../library/pyexpat.rst:21
msgid ""
"If you need to parse untrusted or unauthenticated data, see :ref:`xml-"
"security`."
msgstr ""
"Se você precisar analisar dados não confiáveis ou não autenticados, "
"consulte :ref:`xml-security`."

#: ../../library/pyexpat.rst:27
msgid ""
"The :mod:`xml.parsers.expat` module is a Python interface to the Expat non-"
"validating XML parser. The module provides a single extension type, :class:"
"`xmlparser`, that represents the current state of an XML parser.  After an :"
"class:`xmlparser` object has been created, various attributes of the object "
"can be set to handler functions.  When an XML document is then fed to the "
"parser, the handler functions are called for the character data and markup "
"in the XML document."
msgstr ""
"O módulo :mod:`xml.parsers.expat` é uma interface Python para o analisador "
"XML sem validação do Expat. O módulo fornece um único tipo de extensão, :"
"class:`xmlparser`, que representa o estado atual de um analisador XML. Após "
"um objeto :class:`xmlparser` ter sido criado, vários atributos do objeto "
"podem ser configurados para funções manipuladoras. Quando um documento XML é "
"alimentado no analisador, as funções de tratamento são chamadas para os "
"dados de caracteres e marcação no documento XML."

#: ../../library/pyexpat.rst:37
msgid ""
"This module uses the :mod:`pyexpat` module to provide access to the Expat "
"parser.  Direct use of the :mod:`pyexpat` module is deprecated."
msgstr ""
"Este módulo usa o módulo :mod:`pyexpat` para fornecer acesso ao analisador "
"sintático Expat. O uso direto do módulo :mod:`pyexpat` foi descontinuado."

#: ../../library/pyexpat.rst:40
msgid "This module provides one exception and one type object:"
msgstr "Este módulo fornece uma exceção e um objeto de tipo:"

#: ../../library/pyexpat.rst:45
msgid ""
"The exception raised when Expat reports an error.  See section :ref:"
"`expaterror-objects` for more information on interpreting Expat errors."
msgstr ""
"A exceção levantada quando o Expat relata um erro. Veja a seção :ref:"
"`expaterror-objects` para mais informações sobre como interpretar erros do "
"Expat."

#: ../../library/pyexpat.rst:51
msgid "Alias for :exc:`ExpatError`."
msgstr "Apelido para :exc:`ExpatError`."

#: ../../library/pyexpat.rst:56
msgid "The type of the return values from the :func:`ParserCreate` function."
msgstr "O tipo dos valores de retorno da função :func:`ParserCreate`."

#: ../../library/pyexpat.rst:58
msgid "The :mod:`xml.parsers.expat` module contains two functions:"
msgstr "O módulo :mod:`xml.parsers.expat` contém duas funções:"

#: ../../library/pyexpat.rst:63
msgid "Returns an explanatory string for a given error number *errno*."
msgstr ""
"Retorna uma string explicativa para um determinado número de erro *errno*."

#: ../../library/pyexpat.rst:68
msgid ""
"Creates and returns a new :class:`xmlparser` object.   *encoding*, if "
"specified, must be a string naming the encoding  used by the XML data.  "
"Expat doesn't support as many encodings as Python does, and its repertoire "
"of encodings can't be extended; it supports UTF-8, UTF-16, ISO-8859-1 "
"(Latin1), and ASCII.  If *encoding* [1]_ is given it will override the "
"implicit or explicit encoding of the document."
msgstr ""
"Cria e retorna um novo objeto :class:`xmlparser`. *encoding*, se "
"especificado, deve ser uma string que nomeia a codificação usada pelos dados "
"XML. Expat não provê tantas codificações quanto Python e seu repertório de "
"codificações não pode ser estendido; provê UTF-8, UTF-16, ISO-8859-1 "
"(Latin1) e ASCII. Se *encoding* [1]_ for fornecido, ele substituirá a "
"codificação implícita ou explícita do documento."

#: ../../library/pyexpat.rst:75
msgid ""
"Expat can optionally do XML namespace processing for you, enabled by "
"providing a value for *namespace_separator*.  The value must be a one-"
"character string; a :exc:`ValueError` will be raised if the string has an "
"illegal length (``None`` is considered the same as omission).  When "
"namespace processing is enabled, element type names and attribute names that "
"belong to a namespace will be expanded.  The element name passed to the "
"element handlers :attr:`StartElementHandler` and :attr:`EndElementHandler` "
"will be the concatenation of the namespace URI, the namespace separator "
"character, and the local part of the name.  If the namespace separator is a "
"zero byte (``chr(0)``) then the namespace URI and the local part will be "
"concatenated without any separator."
msgstr ""
"Opcionalmente, o Expat pode fazer o processamento de espaço de nomes XML "
"para você, habilitado ao fornecer um valor para *namespace_separator*. O "
"valor deve ser uma string de um caractere; uma exceção :exc:`ValueError` "
"será levantada se a string tiver um comprimento ilegal (``None`` é "
"considerado o mesmo que omissão). Quando o processamento de espaço de nomes "
"estiver ativado, os nomes de tipos de elementos e nomes de atributos que "
"pertencem a um espaço de nomes serão expandidos. O nome do elemento passado "
"para os manipuladores de elemento :attr:`StartElementHandler` e :attr:"
"`EndElementHandler` será a concatenação do URI do espaço de nomes, o "
"caractere separador do espaço de nomes e a parte local do nome. Se o "
"separador do espaço de nomes for um byte zero (``chr(0)``), então o URI do "
"espaço de nomes e a parte local serão concatenados sem qualquer separador."

#: ../../library/pyexpat.rst:87
msgid ""
"For example, if *namespace_separator* is set to a space character (``' '``) "
"and the following document is parsed:"
msgstr ""
"Por exemplo, se *namespace_separator* for definido como um caractere de "
"espaço (``' '``) e o seguinte documento for analisado:"

#: ../../library/pyexpat.rst:90
msgid ""
"<?xml version=\"1.0\"?>\n"
"<root xmlns    = \"http://default-namespace.org/\"\n"
"      xmlns:py = \"http://www.python.org/ns/\">\n"
"  <py:elem1 />\n"
"  <elem2 xmlns=\"\" />\n"
"</root>"
msgstr ""

#: ../../library/pyexpat.rst:99
msgid ""
":attr:`StartElementHandler` will receive the following strings for each "
"element::"
msgstr ""
":attr:`StartElementHandler` receberá as seguintes strings para cada "
"elemento::"

#: ../../library/pyexpat.rst:102
msgid ""
"http://default-namespace.org/ root\n"
"http://www.python.org/ns/ elem1\n"
"elem2"
msgstr ""

#: ../../library/pyexpat.rst:106
msgid ""
"Due to limitations in the ``Expat`` library used by :mod:`pyexpat`, the :"
"class:`xmlparser` instance returned can only be used to parse a single XML "
"document.  Call ``ParserCreate`` for each document to provide unique parser "
"instances."
msgstr ""
"Devido a limitações na biblioteca ``Expat`` usada por :mod:`pyexpat`, a "
"instância :class:`xmlparser` retornada só pode ser usada para analisar um "
"único documento XML. Chame ``ParserCreate`` para cada documento para "
"fornecer instâncias exclusivas do analisador sintático."

#: ../../library/pyexpat.rst:114
msgid "`The Expat XML Parser <http://www.libexpat.org/>`_"
msgstr "`Expat, analisador sintático de XML <http://www.libexpat.org/>`_"

#: ../../library/pyexpat.rst:115
msgid "Home page of the Expat project."
msgstr "Site do projeto Expat"

#: ../../library/pyexpat.rst:121
msgid "XMLParser Objects"
msgstr "Objetos XMLParser"

#: ../../library/pyexpat.rst:123
msgid ":class:`xmlparser` objects have the following methods:"
msgstr "Об’єкти :class:`xmlparser` мають такі методи:"

#: ../../library/pyexpat.rst:128
msgid ""
"Parses the contents of the string *data*, calling the appropriate handler "
"functions to process the parsed data.  *isfinal* must be true on the final "
"call to this method; it allows the parsing of a single file in fragments, "
"not the submission of multiple files. *data* can be the empty string at any "
"time."
msgstr ""
"Аналізує вміст рядка *data*, викликаючи відповідні функції обробки для "
"обробки аналізованих даних. *isfinal* має бути true під час останнього "
"виклику цього методу; це дозволяє розбирати один файл у фрагментах, а не "
"надсилати кілька файлів. *data* може бути порожнім рядком у будь-який час."

#: ../../library/pyexpat.rst:137
msgid ""
"Parse XML data reading from the object *file*.  *file* only needs to provide "
"the ``read(nbytes)`` method, returning the empty string when there's no more "
"data."
msgstr ""
"Проаналізуйте читання даних XML з об'єктного *файлу*. *file* потребує лише "
"надання методу ``read(nbytes)``, повертаючи порожній рядок, коли більше "
"немає даних."

#: ../../library/pyexpat.rst:144
msgid ""
"Sets the base to be used for resolving relative URIs in system identifiers "
"in declarations.  Resolving relative identifiers is left to the application: "
"this value will be passed through as the *base* argument to the :func:"
"`ExternalEntityRefHandler`, :func:`NotationDeclHandler`, and :func:"
"`UnparsedEntityDeclHandler` functions."
msgstr ""
"Встановлює базу для визначення відносних URI у системних ідентифікаторах у "
"оголошеннях. Розпізнавання відносних ідентифікаторів залишається за "
"додатком: це значення буде передано як аргумент *base* до функцій :func:"
"`ExternalEntityRefHandler`, :func:`NotationDeclHandler` і :func:"
"`UnparsedEntityDeclHandler`."

#: ../../library/pyexpat.rst:153
msgid ""
"Returns a string containing the base set by a previous call to :meth:"
"`SetBase`, or ``None`` if  :meth:`SetBase` hasn't been called."
msgstr ""
"Повертає рядок, що містить базовий набір попереднім викликом :meth:`SetBase` "
"або ``None``, якщо :meth:`SetBase` не викликався."

#: ../../library/pyexpat.rst:159
msgid ""
"Returns the input data that generated the current event as a string. The "
"data is in the encoding of the entity which contains the text. When called "
"while an event handler is not active, the return value is ``None``."
msgstr ""
"Повертає вхідні дані, які згенерували поточну подію, у вигляді рядка. Дані "
"знаходяться в кодуванні сутності, яка містить текст. Під час виклику, коли "
"обробник події неактивний, повертається значення ``None``."

#: ../../library/pyexpat.rst:166
msgid ""
"Create a \"child\" parser which can be used to parse an external parsed "
"entity referred to by content parsed by the parent parser.  The *context* "
"parameter should be the string passed to the :meth:"
"`ExternalEntityRefHandler` handler function, described below. The child "
"parser is created with the :attr:`ordered_attributes` and :attr:"
"`specified_attributes` set to the values of this parser."
msgstr ""
"Створіть \"дочірній\" аналізатор, який можна використовувати для аналізу "
"зовнішньої проаналізованої сутності, на яку посилається вміст, розібраний "
"батьківським аналізатором. Параметр *context* має бути рядком, який "
"передається до функції обробки :meth:`ExternalEntityRefHandler`, описаної "
"нижче. Дочірній аналізатор створюється з :attr:`ordered_attributes` і :attr:"
"`specified_attributes`, встановленими на значення цього аналізатора."

#: ../../library/pyexpat.rst:175
msgid ""
"Control parsing of parameter entities (including the external DTD subset). "
"Possible *flag* values are :const:`XML_PARAM_ENTITY_PARSING_NEVER`, :const:"
"`XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE` and :const:"
"`XML_PARAM_ENTITY_PARSING_ALWAYS`.  Return true if setting the flag was "
"successful."
msgstr ""
"Контроль аналізу сутностей параметрів (включаючи підмножину зовнішнього "
"DTD). Можливі значення *flag*: :const:`XML_PARAM_ENTITY_PARSING_NEVER`, :"
"const:`XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE` і :const:"
"`XML_PARAM_ENTITY_PARSING_ALWAYS`. Повертає true, якщо прапорець встановлено "
"успішно."

#: ../../library/pyexpat.rst:183
msgid ""
"Calling this with a true value for *flag* (the default) will cause Expat to "
"call the :attr:`ExternalEntityRefHandler` with :const:`None` for all "
"arguments to allow an alternate DTD to be loaded.  If the document does not "
"contain a document type declaration, the :attr:`ExternalEntityRefHandler` "
"will still be called, but the :attr:`StartDoctypeDeclHandler` and :attr:"
"`EndDoctypeDeclHandler` will not be called."
msgstr ""
"Виклик цього з істинним значенням для *flag* (за замовчуванням) змусить "
"Expat викликати :attr:`ExternalEntityRefHandler` з :const:`None` для всіх "
"аргументів, щоб дозволити завантажувати альтернативний DTD. Якщо документ не "
"містить оголошення типу документа, :attr:`ExternalEntityRefHandler` все одно "
"буде викликано, але :attr:`StartDoctypeDeclHandler` і :attr:"
"`EndDoctypeDeclHandler` не буде викликано."

#: ../../library/pyexpat.rst:190
msgid ""
"Passing a false value for *flag* will cancel a previous call that passed a "
"true value, but otherwise has no effect."
msgstr ""
"Передача хибного значення для *flag* призведе до скасування попереднього "
"виклику, який передав істинне значення, але в іншому випадку не матиме "
"ефекту."

#: ../../library/pyexpat.rst:193
msgid ""
"This method can only be called before the :meth:`Parse` or :meth:`ParseFile` "
"methods are called; calling it after either of those have been called "
"causes :exc:`ExpatError` to be raised with the :attr:`code` attribute set to "
"``errors.codes[errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING]``."
msgstr ""
"Цей метод можна викликати лише перед викликом методів :meth:`Parse` або :"
"meth:`ParseFile`; його виклик після виклику будь-якого з них викликає :exc:"
"`ExpatError`, коли атрибут :attr:`code` має значення ``errors.codes[errors."
"XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING]``."

#: ../../library/pyexpat.rst:202
msgid ""
"Calling ``SetReparseDeferralEnabled(False)`` has security implications, as "
"detailed below; please make sure to understand these consequences prior to "
"using the ``SetReparseDeferralEnabled`` method."
msgstr ""
"Вызов SetReparseDeferralEnabled(False) имеет последствия для безопасности, "
"как подробно описано ниже; пожалуйста, убедитесь, что вы понимаете эти "
"последствия, прежде чем использовать метод SetReparseDeferralEnabled."

#: ../../library/pyexpat.rst:206
msgid ""
"Expat 2.6.0 introduced a security mechanism called \"reparse deferral\" "
"where instead of causing denial of service through quadratic runtime from "
"reparsing large tokens, reparsing of unfinished tokens is now delayed by "
"default until a sufficient amount of input is reached. Due to this delay, "
"registered handlers may — depending of the sizing of input chunks pushed to "
"Expat — no longer be called right after pushing new input to the parser.  "
"Where immediate feedback and taking over responsibility of protecting "
"against denial of service from large tokens are both wanted, calling "
"``SetReparseDeferralEnabled(False)`` disables reparse deferral for the "
"current Expat parser instance, temporarily or altogether. Calling "
"``SetReparseDeferralEnabled(True)`` allows re-enabling reparse deferral."
msgstr ""

#: ../../library/pyexpat.rst:219
msgid ""
"Note that :meth:`SetReparseDeferralEnabled` has been backported to some "
"prior releases of CPython as a security fix.  Check for availability of :"
"meth:`SetReparseDeferralEnabled` using :func:`hasattr` if used in code "
"running across a variety of Python versions."
msgstr ""
"Обратите внимание, что :meth:`SetReparseDeferralEnabled` был перенесен в "
"некоторые предыдущие выпуски CPython в качестве исправления безопасности. "
"Проверьте доступность :meth:`SetReparseDeferralEnabled` с помощью :func:"
"`hasattr`, если он используется в коде, работающем в различных версиях "
"Python."

#: ../../library/pyexpat.rst:228
msgid ""
"Returns whether reparse deferral is currently enabled for the given Expat "
"parser instance."
msgstr ""
"Возвращает, включена ли в данный момент отсрочка повторной обработки для "
"данного экземпляра парсера Expat."

#: ../../library/pyexpat.rst:234
msgid ":class:`xmlparser` objects have the following attributes:"
msgstr "Об’єкти :class:`xmlparser` мають такі атрибути:"

#: ../../library/pyexpat.rst:239
msgid ""
"The size of the buffer used when :attr:`buffer_text` is true. A new buffer "
"size can be set by assigning a new integer value to this attribute. When the "
"size is changed, the buffer will be flushed."
msgstr ""
"Розмір буфера, який використовується, коли :attr:`buffer_text` має значення "
"true. Новий розмір буфера можна встановити, присвоївши цьому атрибуту нове "
"ціле значення. Коли розмір змінено, буфер буде очищено."

#: ../../library/pyexpat.rst:247
msgid ""
"Setting this to true causes the :class:`xmlparser` object to buffer textual "
"content returned by Expat to avoid multiple calls to the :meth:"
"`CharacterDataHandler` callback whenever possible.  This can improve "
"performance substantially since Expat normally breaks character data into "
"chunks at every line ending.  This attribute is false by default, and may be "
"changed at any time. Note that when it is false, data that does not contain "
"newlines may be chunked too."
msgstr ""

#: ../../library/pyexpat.rst:258
msgid ""
"If :attr:`buffer_text` is enabled, the number of bytes stored in the buffer. "
"These bytes represent UTF-8 encoded text.  This attribute has no meaningful "
"interpretation when :attr:`buffer_text` is false."
msgstr ""
"Якщо :attr:`buffer_text` увімкнено, кількість байтів, що зберігаються в "
"буфері. Ці байти представляють текст у кодуванні UTF-8. Цей атрибут не має "
"значущої інтерпретації, якщо :attr:`buffer_text` має значення false."

#: ../../library/pyexpat.rst:265
msgid ""
"Setting this attribute to a non-zero integer causes the attributes to be "
"reported as a list rather than a dictionary.  The attributes are presented "
"in the order found in the document text.  For each attribute, two list "
"entries are presented: the attribute name and the attribute value.  (Older "
"versions of this module also used this format.)  By default, this attribute "
"is false; it may be changed at any time."
msgstr ""
"Встановлення для цього атрибута ненульового цілого числа призводить до того, "
"що атрибути повідомлятимуться як список, а не як словник. Атрибути "
"представлені в порядку, указаному в тексті документа. Для кожного атрибута "
"представлено два записи списку: назва атрибута та значення атрибута. "
"(Старіші версії цього модуля також використовували цей формат.) За "
"замовчуванням цей атрибут має значення false; його можна змінити в будь-який "
"час."

#: ../../library/pyexpat.rst:275
msgid ""
"If set to a non-zero integer, the parser will report only those attributes "
"which were specified in the document instance and not those which were "
"derived from attribute declarations.  Applications which set this need to be "
"especially careful to use what additional information is available from the "
"declarations as needed to comply with the standards for the behavior of XML "
"processors.  By default, this attribute is false; it may be changed at any "
"time."
msgstr ""
"Якщо встановлено ненульове ціле число, аналізатор повідомлятиме лише про ті "
"атрибути, які були вказані в екземплярі документа, а не про ті, які були "
"отримані з оголошень атрибутів. Програми, які встановлюють це, повинні бути "
"особливо обережними, щоб використовувати додаткову інформацію, доступну з "
"декларацій, якщо це необхідно для відповідності стандартам поведінки "
"процесорів XML. За замовчуванням цей атрибут має значення false; його можна "
"змінити в будь-який час."

#: ../../library/pyexpat.rst:283
msgid ""
"The following attributes contain values relating to the most recent error "
"encountered by an :class:`xmlparser` object, and will only have correct "
"values once a call to :meth:`Parse` or :meth:`ParseFile` has raised an :exc:"
"`xml.parsers.expat.ExpatError` exception."
msgstr ""
"Наступні атрибути містять значення, пов’язані з останньою помилкою, яку "
"виявив об’єкт :class:`xmlparser`, і матимуть правильні значення лише тоді, "
"коли виклик :meth:`Parse` або :meth:`ParseFile` викликає Виняток :exc:`xml."
"parsers.expat.ExpatError`."

#: ../../library/pyexpat.rst:291
msgid "Byte index at which an error occurred."
msgstr "Індекс байта, на якому сталася помилка."

#: ../../library/pyexpat.rst:296
msgid ""
"Numeric code specifying the problem.  This value can be passed to the :func:"
"`ErrorString` function, or compared to one of the constants defined in the "
"``errors`` object."
msgstr ""
"Числовий код, що визначає проблему. Це значення можна передати у функцію :"
"func:`ErrorString` або порівняти з однією з констант, визначених в об’єкті "
"``errors``."

#: ../../library/pyexpat.rst:303
msgid "Column number at which an error occurred."
msgstr "Номер стовпця, в якому сталася помилка."

#: ../../library/pyexpat.rst:308
msgid "Line number at which an error occurred."
msgstr "Номер рядка, в якому сталася помилка."

#: ../../library/pyexpat.rst:310
msgid ""
"The following attributes contain values relating to the current parse "
"location in an :class:`xmlparser` object.  During a callback reporting a "
"parse event they indicate the location of the first of the sequence of "
"characters that generated the event.  When called outside of a callback, the "
"position indicated will be just past the last parse event (regardless of "
"whether there was an associated callback)."
msgstr ""
"Наступні атрибути містять значення, пов’язані з поточним місцем аналізу в "
"об’єкті :class:`xmlparser`. Під час зворотного виклику, повідомляючи про "
"подію синтаксичного аналізу, вони вказують розташування першого з "
"послідовності символів, які породили подію. При виклику за межами зворотного "
"виклику вказана позиція буде відразу після останньої події аналізу "
"(незалежно від того, чи був пов’язаний зворотний виклик)."

#: ../../library/pyexpat.rst:320
msgid "Current byte index in the parser input."
msgstr "Поточний індекс байта у вхідних даних аналізатора."

#: ../../library/pyexpat.rst:325
msgid "Current column number in the parser input."
msgstr "Поточний номер стовпця у вхідних даних аналізатора."

#: ../../library/pyexpat.rst:330
msgid "Current line number in the parser input."
msgstr "Поточний номер рядка у вхідних даних аналізатора."

#: ../../library/pyexpat.rst:332
msgid ""
"Here is the list of handlers that can be set.  To set a handler on an :class:"
"`xmlparser` object *o*, use ``o.handlername = func``.  *handlername* must be "
"taken from the following list, and *func* must be a callable object "
"accepting the correct number of arguments.  The arguments are all strings, "
"unless otherwise stated."
msgstr ""
"Ось список обробників, які можна встановити. Щоб встановити обробник для "
"об’єкта :class:`xmlparser` *o*, використовуйте ``o.handlername = func``. "
"*handlername* має бути взято з наступного списку, а *func* має бути "
"викликаним об’єктом, який приймає правильну кількість аргументів. Усі "
"аргументи є рядками, якщо не вказано інше."

#: ../../library/pyexpat.rst:341
msgid ""
"Called when the XML declaration is parsed.  The XML declaration is the "
"(optional) declaration of the applicable version of the XML recommendation, "
"the encoding of the document text, and an optional \"standalone\" "
"declaration. *version* and *encoding* will be strings, and *standalone* will "
"be ``1`` if the document is declared standalone, ``0`` if it is declared not "
"to be standalone, or ``-1`` if the standalone clause was omitted. This is "
"only available with Expat version 1.95.0 or newer."
msgstr ""
"Викликається під час аналізу XML-декларації. Оголошення XML – це "
"(необов’язкове) оголошення відповідної версії рекомендації XML, кодування "
"тексту документа та необов’язкове \"окреме\" оголошення. *version* і "
"*encoding* будуть рядками, а *standalone* матиме значення ``1``, якщо "
"документ оголошено автономним, ``0``, якщо він оголошено не автономним, або "
"``-1`` якщо окреме речення було пропущено. Це доступно лише для Expat версії "
"1.95.0 або новішої."

#: ../../library/pyexpat.rst:352
msgid ""
"Called when Expat begins parsing the document type declaration (``<!"
"DOCTYPE ...``).  The *doctypeName* is provided exactly as presented.  The "
"*systemId* and *publicId* parameters give the system and public identifiers "
"if specified, or ``None`` if omitted.  *has_internal_subset* will be true if "
"the document contains and internal document declaration subset. This "
"requires Expat version 1.2 or newer."
msgstr ""
"Викликається, коли Expat починає розбирати декларацію типу документа (``<!"
"DOCTYPE ...``). *doctypeName* надається точно так, як представлено. "
"Параметри *systemId* і *publicId* дають системний і публічний "
"ідентифікатори, якщо вказано, або ``None``, якщо опущено. "
"*has_internal_subset* матиме значення true, якщо документ містить підмножину "
"декларацій внутрішнього документа. Для цього потрібна версія Expat 1.2 або "
"новіша."

#: ../../library/pyexpat.rst:362
msgid ""
"Called when Expat is done parsing the document type declaration. This "
"requires Expat version 1.2 or newer."
msgstr ""
"Викликається, коли Expat завершує аналіз декларації типу документа. Для "
"цього потрібна версія Expat 1.2 або новіша."

#: ../../library/pyexpat.rst:368
msgid ""
"Called once for each element type declaration.  *name* is the name of the "
"element type, and *model* is a representation of the content model."
msgstr ""
"Викликається один раз для кожного оголошення типу елемента. *name* — це ім’я "
"типу елемента, а *model* — це представлення моделі вмісту."

#: ../../library/pyexpat.rst:374
msgid ""
"Called for each declared attribute for an element type.  If an attribute "
"list declaration declares three attributes, this handler is called three "
"times, once for each attribute.  *elname* is the name of the element to "
"which the declaration applies and *attname* is the name of the attribute "
"declared.  The attribute type is a string passed as *type*; the possible "
"values are ``'CDATA'``, ``'ID'``, ``'IDREF'``, ... *default* gives the "
"default value for the attribute used when the attribute is not specified by "
"the document instance, or ``None`` if there is no default value "
"(``#IMPLIED`` values).  If the attribute is required to be given in the "
"document instance, *required* will be true. This requires Expat version "
"1.95.0 or newer."
msgstr ""
"Викликається для кожного оголошеного атрибута для типу елемента. Якщо "
"оголошення списку атрибутів оголошує три атрибути, цей обробник викликається "
"тричі, по одному для кожного атрибута. *elname* — це ім’я елемента, до якого "
"застосовується оголошення, а *attname* — це ім’я оголошеного атрибута. Тип "
"атрибута — це рядок, що передається як *type*; можливі значення: "
"``'CDATA'``, ``'ID'``, ``'IDREF'``, ... *default* дає значення за "
"замовчуванням для атрибута, який використовується, коли атрибут не вказано в "
"екземпляр документа або ``None``, якщо немає значення за замовчуванням "
"(``#IMPLIED`` значення). Якщо атрибут потрібно вказати в екземплярі "
"документа, *required* матиме значення true. Для цього потрібна версія Expat "
"1.95.0 або новіша."

#: ../../library/pyexpat.rst:388
msgid ""
"Called for the start of every element.  *name* is a string containing the "
"element name, and *attributes* is the element attributes. If :attr:"
"`ordered_attributes` is true, this is a list (see :attr:`ordered_attributes` "
"for a full description). Otherwise it's a dictionary mapping names to values."
msgstr ""
"Викликається для початку кожного елемента. *name* — це рядок, що містить "
"назву елемента, а *attributes* — це атрибути елемента. Якщо :attr:"
"`ordered_attributes` має значення true, це список (див. :attr:"
"`ordered_attributes` для повного опису). В іншому випадку це словник, який "
"зіставляє імена зі значеннями."

#: ../../library/pyexpat.rst:397
msgid "Called for the end of every element."
msgstr "Викликається в кінці кожного елемента."

#: ../../library/pyexpat.rst:402
msgid "Called for every processing instruction."
msgstr "Викликається для кожної інструкції з обробки."

#: ../../library/pyexpat.rst:407
msgid ""
"Called for character data.  This will be called for normal character data, "
"CDATA marked content, and ignorable whitespace.  Applications which must "
"distinguish these cases can use the :attr:`StartCdataSectionHandler`, :attr:"
"`EndCdataSectionHandler`, and :attr:`ElementDeclHandler` callbacks to "
"collect the required information. Note that the character data may be "
"chunked even if it is short and so you may receive more than one call to :"
"meth:`CharacterDataHandler`. Set the :attr:`buffer_text` instance attribute "
"to ``True`` to avoid that."
msgstr ""

#: ../../library/pyexpat.rst:419
msgid ""
"Called for unparsed (NDATA) entity declarations.  This is only present for "
"version 1.2 of the Expat library; for more recent versions, use :attr:"
"`EntityDeclHandler` instead.  (The underlying function in the Expat library "
"has been declared obsolete.)"
msgstr ""
"Викликається для нерозібраних (NDATA) декларацій сутностей. Це доступно лише "
"для версії 1.2 бібліотеки Expat; для останніх версій замість цього "
"використовуйте :attr:`EntityDeclHandler`. (Основну функцію в бібліотеці "
"Expat було оголошено застарілою.)"

#: ../../library/pyexpat.rst:427
msgid ""
"Called for all entity declarations.  For parameter and internal entities, "
"*value* will be a string giving the declared contents of the entity; this "
"will be ``None`` for external entities.  The *notationName* parameter will "
"be ``None`` for parsed entities, and the name of the notation for unparsed "
"entities. *is_parameter_entity* will be true if the entity is a parameter "
"entity or false for general entities (most applications only need to be "
"concerned with general entities). This is only available starting with "
"version 1.95.0 of the Expat library."
msgstr ""
"Викликається для всіх декларацій сутностей. Для параметрів і внутрішніх "
"сутностей *value* буде рядком, що надає оголошений вміст сутності; це буде "
"``None`` для зовнішніх об'єктів. Параметр *notationName* матиме значення "
"``None`` для проаналізованих сутностей і ім’я нотації для нерозібраних "
"сутностей. *is_parameter_entity* матиме значення true, якщо сутність є "
"параметром, або false для загальних сутностей (більшості програм потрібно "
"мати справу лише із загальними сутностями). Це доступно лише з версії 1.95.0 "
"бібліотеки Expat."

#: ../../library/pyexpat.rst:439
msgid ""
"Called for notation declarations.  *notationName*, *base*, and *systemId*, "
"and *publicId* are strings if given.  If the public identifier is omitted, "
"*publicId* will be ``None``."
msgstr ""
"Викликані нотні декларації. *notationName*, *base*, *systemId* і *publicId* "
"є рядками, якщо вони задані. Якщо публічний ідентифікатор пропущено, "
"*publicId* матиме значення ``None``."

#: ../../library/pyexpat.rst:446
msgid ""
"Called when an element contains a namespace declaration.  Namespace "
"declarations are processed before the :attr:`StartElementHandler` is called "
"for the element on which declarations are placed."
msgstr ""
"Викликається, коли елемент містить оголошення простору імен. Оголошення "
"простору імен обробляються перед викликом :attr:`StartElementHandler` для "
"елемента, на якому розміщено оголошення."

#: ../../library/pyexpat.rst:453
msgid ""
"Called when the closing tag is reached for an element  that contained a "
"namespace declaration.  This is called once for each namespace declaration "
"on the element in the reverse of the order for which the :attr:"
"`StartNamespaceDeclHandler` was called to indicate the start of each "
"namespace declaration's scope.  Calls to this handler are made after the "
"corresponding :attr:`EndElementHandler` for the end of the element."
msgstr ""
"Викликається, коли досягається закриваючий тег для елемента, який містив "
"оголошення простору імен. Це викликається один раз для кожної декларації "
"простору імен для елемента в порядку, зворотному порядку, для якого було "
"викликано :attr:`StartNamespaceDeclHandler`, щоб вказати початок кожної "
"області декларації простору імен. Виклики цього обробника здійснюються після "
"відповідного :attr:`EndElementHandler` для кінця елемента."

#: ../../library/pyexpat.rst:463
msgid ""
"Called for comments.  *data* is the text of the comment, excluding the "
"leading ``'<!-``\\ ``-'`` and trailing ``'-``\\ ``->'``."
msgstr ""
"Звертався за коментарями. *data* — це текст коментаря, за винятком "
"початкового ``'<!-``\\ ``-'`` і кінцевого ``'-``\\ ``->'``."

#: ../../library/pyexpat.rst:469
msgid ""
"Called at the start of a CDATA section.  This and :attr:"
"`EndCdataSectionHandler` are needed to be able to identify the syntactical "
"start and end for CDATA sections."
msgstr ""
"Викликається на початку розділу CDATA. Це та :attr:`EndCdataSectionHandler` "
"потрібні, щоб мати можливість ідентифікувати синтаксичний початок і кінець "
"для розділів CDATA."

#: ../../library/pyexpat.rst:476
msgid "Called at the end of a CDATA section."
msgstr "Викликається в кінці розділу CDATA."

#: ../../library/pyexpat.rst:481
msgid ""
"Called for any characters in the XML document for which no applicable "
"handler has been specified.  This means characters that are part of a "
"construct which could be reported, but for which no handler has been "
"supplied."
msgstr ""
"Викликається для будь-яких символів у документі XML, для яких не вказано "
"відповідний обробник. Це означає символи, які є частиною конструкції, про "
"яку можна повідомити, але для яких не надано обробник."

#: ../../library/pyexpat.rst:488
msgid ""
"This is the same as the :func:`DefaultHandler`,  but doesn't inhibit "
"expansion of internal entities. The entity reference will not be passed to "
"the default handler."
msgstr ""
"Це те саме, що :func:`DefaultHandler`, але не перешкоджає розширенню "
"внутрішніх сутностей. Посилання на сутність не буде передано обробнику за "
"замовчуванням."

#: ../../library/pyexpat.rst:495
msgid ""
"Called if the XML document hasn't been declared as being a standalone "
"document. This happens when there is an external subset or a reference to a "
"parameter entity, but the XML declaration does not set standalone to ``yes`` "
"in an XML declaration.  If this handler returns ``0``, then the parser will "
"raise an :const:`XML_ERROR_NOT_STANDALONE` error.  If this handler is not "
"set, no exception is raised by the parser for this condition."
msgstr ""
"Викликається, якщо документ XML не оголошено як окремий документ. Це "
"трапляється, коли існує зовнішня підмножина або посилання на сутність "
"параметра, але XML-декларація не встановлює standalone на ``yes`` в XML-"
"декларації. Якщо цей обробник повертає ``0``, тоді аналізатор викличе "
"помилку :const:`XML_ERROR_NOT_STANDALONE`. Якщо цей обробник не встановлено, "
"синтаксичний аналізатор не створює винятків для цієї умови."

#: ../../library/pyexpat.rst:505
msgid ""
"Called for references to external entities.  *base* is the current base, as "
"set by a previous call to :meth:`SetBase`.  The public and system "
"identifiers, *systemId* and *publicId*, are strings if given; if the public "
"identifier is not given, *publicId* will be ``None``.  The *context* value "
"is opaque and should only be used as described below."
msgstr ""
"Викликаються посилання на зовнішні сутності. *base* — це поточна база, "
"встановлена попереднім викликом :meth:`SetBase`. Загальнодоступні та "
"системні ідентифікатори, *systemId* і *publicId*, є рядками, якщо вони "
"задані; якщо публічний ідентифікатор не вказано, *publicId* буде ``None``. "
"Значення *context* є непрозорим і його слід використовувати лише як описано "
"нижче."

#: ../../library/pyexpat.rst:511
msgid ""
"For external entities to be parsed, this handler must be implemented. It is "
"responsible for creating the sub-parser using "
"``ExternalEntityParserCreate(context)``, initializing it with the "
"appropriate callbacks, and parsing the entity.  This handler should return "
"an integer; if it returns ``0``, the parser will raise an :const:"
"`XML_ERROR_EXTERNAL_ENTITY_HANDLING` error, otherwise parsing will continue."
msgstr ""
"Для аналізу зовнішніх об’єктів цей обробник має бути реалізований. Він "
"відповідає за створення суб-парсера за допомогою "
"``ExternalEntityParserCreate(context)``, його ініціалізацію за допомогою "
"відповідних зворотних викликів і аналіз сутності. Цей обробник має повертати "
"ціле число; якщо він повертає ``0``, аналізатор викличе помилку :const:"
"`XML_ERROR_EXTERNAL_ENTITY_HANDLING`, інакше аналіз продовжиться."

#: ../../library/pyexpat.rst:519
msgid ""
"If this handler is not provided, external entities are reported by the :attr:"
"`DefaultHandler` callback, if provided."
msgstr ""
"Якщо цей обробник не надано, зовнішні сутності повідомляються зворотним "
"викликом :attr:`DefaultHandler`, якщо він надається."

#: ../../library/pyexpat.rst:526
msgid "ExpatError Exceptions"
msgstr "Exceções ExpatError"

#: ../../library/pyexpat.rst:531
msgid ":exc:`ExpatError` exceptions have a number of interesting attributes:"
msgstr "Винятки :exc:`ExpatError` мають ряд цікавих атрибутів:"

#: ../../library/pyexpat.rst:536
msgid ""
"Expat's internal error number for the specific error.  The :data:`errors."
"messages <xml.parsers.expat.errors.messages>` dictionary maps these error "
"numbers to Expat's error messages.  For example::"
msgstr ""
"Внутрішній номер помилки Expat для конкретної помилки. Словник :data:`errors."
"messages <xml.parsers.expat.errors.messages>` зіставляє ці номери помилок із "
"повідомленнями про помилки Expat. Наприклад::"

#: ../../library/pyexpat.rst:540
msgid ""
"from xml.parsers.expat import ParserCreate, ExpatError, errors\n"
"\n"
"p = ParserCreate()\n"
"try:\n"
"    p.Parse(some_xml_document)\n"
"except ExpatError as err:\n"
"    print(\"Error:\", errors.messages[err.code])"
msgstr ""

#: ../../library/pyexpat.rst:548
msgid ""
"The :mod:`~xml.parsers.expat.errors` module also provides error message "
"constants and a dictionary :data:`~xml.parsers.expat.errors.codes` mapping "
"these messages back to the error codes, see below."
msgstr ""
"Модуль :mod:`~xml.parsers.expat.errors` також надає константи повідомлень "
"про помилки та словник :data:`~xml.parsers.expat.errors.codes`, який "
"відображає ці повідомлення назад до кодів помилок, див. нижче."

#: ../../library/pyexpat.rst:555
msgid ""
"Line number on which the error was detected.  The first line is numbered "
"``1``."
msgstr "Номер рядка, в якому виявлено помилку. Перший рядок має номер ``1``."

#: ../../library/pyexpat.rst:560
msgid ""
"Character offset into the line where the error occurred.  The first column "
"is numbered ``0``."
msgstr ""
"Зміщення символу в рядку, де сталася помилка. Перший стовпець має номер "
"``0``."

#: ../../library/pyexpat.rst:567
msgid "Example"
msgstr "Exemplo"

#: ../../library/pyexpat.rst:569
msgid ""
"The following program defines three handlers that just print out their "
"arguments. ::"
msgstr ""
"Наступна програма визначає три обробники, які просто виводять свої "
"аргументи. ::"

#: ../../library/pyexpat.rst:572
msgid ""
"import xml.parsers.expat\n"
"\n"
"# 3 handler functions\n"
"def start_element(name, attrs):\n"
"    print('Start element:', name, attrs)\n"
"def end_element(name):\n"
"    print('End element:', name)\n"
"def char_data(data):\n"
"    print('Character data:', repr(data))\n"
"\n"
"p = xml.parsers.expat.ParserCreate()\n"
"\n"
"p.StartElementHandler = start_element\n"
"p.EndElementHandler = end_element\n"
"p.CharacterDataHandler = char_data\n"
"\n"
"p.Parse(\"\"\"<?xml version=\"1.0\"?>\n"
"<parent id=\"top\"><child1 name=\"paul\">Text goes here</child1>\n"
"<child2 name=\"fred\">More text</child2>\n"
"</parent>\"\"\", 1)"
msgstr ""

#: ../../library/pyexpat.rst:593
msgid "The output from this program is::"
msgstr "Результат цієї програми:"

#: ../../library/pyexpat.rst:595
msgid ""
"Start element: parent {'id': 'top'}\n"
"Start element: child1 {'name': 'paul'}\n"
"Character data: 'Text goes here'\n"
"End element: child1\n"
"Character data: '\\n'\n"
"Start element: child2 {'name': 'fred'}\n"
"Character data: 'More text'\n"
"End element: child2\n"
"Character data: '\\n'\n"
"End element: parent"
msgstr ""

#: ../../library/pyexpat.rst:610
msgid "Content Model Descriptions"
msgstr "Опис моделі вмісту"

#: ../../library/pyexpat.rst:616
msgid ""
"Content models are described using nested tuples.  Each tuple contains four "
"values: the type, the quantifier, the name, and a tuple of children.  "
"Children are simply additional content model descriptions."
msgstr ""
"Моделі вмісту описуються за допомогою вкладених кортежів. Кожен кортеж "
"містить чотири значення: тип, квантор, ім’я та кортеж дітей. Дочірні "
"елементи – це просто додаткові описи моделі контенту."

#: ../../library/pyexpat.rst:620
msgid ""
"The values of the first two fields are constants defined in the :mod:`xml."
"parsers.expat.model` module.  These constants can be collected in two "
"groups: the model type group and the quantifier group."
msgstr ""
"Значення перших двох полів є константами, визначеними в модулі :mod:`xml."
"parsers.expat.model`. Ці константи можна зібрати у дві групи: групу типу "
"моделі та групу квантора."

#: ../../library/pyexpat.rst:624
msgid "The constants in the model type group are:"
msgstr "Константи в групі типу моделі:"

#: ../../library/pyexpat.rst:630
msgid ""
"The element named by the model name was declared to have a content model of "
"``ANY``."
msgstr ""
"Елемент, названий іменем моделі, було оголошено таким, що має модель вмісту "
"\"БУДЬ-ЯКА\"."

#: ../../library/pyexpat.rst:637
msgid ""
"The named element allows a choice from a number of options; this is used for "
"content models such as ``(A | B | C)``."
msgstr ""
"Названий елемент дозволяє вибирати з кількох варіантів; це використовується "
"для моделей вмісту, таких як ``(A | B | C)``."

#: ../../library/pyexpat.rst:644
msgid "Elements which are declared to be ``EMPTY`` have this model type."
msgstr "Елементи, які оголошено як ``EMPTY``, мають цей тип моделі."

#: ../../library/pyexpat.rst:658
msgid ""
"Models which represent a series of models which follow one after the other "
"are indicated with this model type.  This is used for models such as ``(A, "
"B, C)``."
msgstr ""
"Моделі, які представляють серію моделей, що йдуть одна за одною, "
"позначаються цим типом моделі. Це використовується для таких моделей, як "
"\"(A, B, C)\"."

#: ../../library/pyexpat.rst:661
msgid "The constants in the quantifier group are:"
msgstr "Константи в групі кванторів такі:"

#: ../../library/pyexpat.rst:667
msgid "No modifier is given, so it can appear exactly once, as for ``A``."
msgstr ""
"Модифікатор не надано, тому він може з’явитися лише один раз, як для ``A``."

#: ../../library/pyexpat.rst:673
msgid "The model is optional: it can appear once or not at all, as for ``A?``."
msgstr ""
"Модель необов'язкова: вона може з'являтися один раз або не з'являтися "
"взагалі, як для ``A?``."

#: ../../library/pyexpat.rst:679
msgid "The model must occur one or more times (like ``A+``)."
msgstr "Модель має зустрічатися один або кілька разів (наприклад, ``A+``)."

#: ../../library/pyexpat.rst:685
msgid "The model must occur zero or more times, as for ``A*``."
msgstr "Модель має зустрічатися нуль або більше разів, як для ``A*``."

#: ../../library/pyexpat.rst:691
msgid "Expat error constants"
msgstr "Константи помилок Expat"

#: ../../library/pyexpat.rst:695
msgid ""
"The following constants are provided in the :mod:`xml.parsers.expat.errors` "
"module.  These constants are useful in interpreting some of the attributes "
"of the :exc:`ExpatError` exception objects raised when an error has "
"occurred. Since for backwards compatibility reasons, the constants' value is "
"the error *message* and not the numeric error *code*, you do this by "
"comparing its :attr:`code` attribute with :samp:`errors.codes[errors."
"XML_ERROR_{CONSTANT_NAME}]`."
msgstr ""
"Наступні константи надаються в модулі :mod:`xml.parsers.expat.errors`. Ці "
"константи корисні для інтерпретації деяких атрибутів об’єктів винятку :exc:"
"`ExpatError`, які виникають у разі виникнення помилки. Оскільки з міркувань "
"зворотної сумісності значенням констант є *повідомлення про помилку*, а не "
"числова *код* помилки, ви робите це, порівнюючи його атрибут :attr:`code` з :"
"samp:`errors.codes[errors.XML_ERROR_ {CONSTANT_NAME}]`."

#: ../../library/pyexpat.rst:703
msgid "The ``errors`` module has the following attributes:"
msgstr "Модуль ``errors`` має такі атрибути:"

#: ../../library/pyexpat.rst:707
msgid "A dictionary mapping string descriptions to their error codes."
msgstr "Словник, що зіставляє описи рядків із їхніми кодами помилок."

#: ../../library/pyexpat.rst:714
msgid "A dictionary mapping numeric error codes to their string descriptions."
msgstr "Словник, що зіставляє числові коди помилок з їхніми описами рядків."

#: ../../library/pyexpat.rst:724
msgid ""
"An entity reference in an attribute value referred to an external entity "
"instead of an internal entity."
msgstr ""
"Посилання на сутність у значенні атрибута посилалося на зовнішню сутність "
"замість внутрішньої сутності."

#: ../../library/pyexpat.rst:730
msgid ""
"A character reference referred to a character which is illegal in XML (for "
"example, character ``0``, or '``&#0;``')."
msgstr ""
"Посилання на символ стосується символу, який є недопустимим у XML "
"(наприклад, символ ``0`` або '``&#0;``')."

#: ../../library/pyexpat.rst:736
msgid ""
"An entity reference referred to an entity which was declared with a "
"notation, so cannot be parsed."
msgstr ""
"Посилання на сутність посилається на сутність, яка була оголошена за "
"допомогою нотації, тому не може бути проаналізована."

#: ../../library/pyexpat.rst:742
msgid "An attribute was used more than once in a start tag."
msgstr "Атрибут використовувався більше одного разу в початковому тегу."

#: ../../library/pyexpat.rst:750
msgid ""
"Raised when an input byte could not properly be assigned to a character; for "
"example, a NUL byte (value ``0``) in a UTF-8 input stream."
msgstr ""
"Викликається, коли вхідний байт не може бути належним чином призначений "
"символу; наприклад, байт NUL (значення ``0``) у вхідному потоці UTF-8."

#: ../../library/pyexpat.rst:756
msgid "Something other than whitespace occurred after the document element."
msgstr "Щось інше, ніж пробіл, сталося після елемента документа."

#: ../../library/pyexpat.rst:761
msgid ""
"An XML declaration was found somewhere other than the start of the input "
"data."
msgstr "Оголошення XML знайдено не на початку вхідних даних."

#: ../../library/pyexpat.rst:766
msgid ""
"The document contains no elements (XML requires all documents to contain "
"exactly one top-level element).."
msgstr ""
"Документ не містить елементів (XML вимагає, щоб усі документи містили рівно "
"один елемент верхнього рівня)."

#: ../../library/pyexpat.rst:772
msgid "Expat was not able to allocate memory internally."
msgstr "Expat не зміг внутрішньо виділити пам’ять."

#: ../../library/pyexpat.rst:777
msgid "A parameter entity reference was found where it was not allowed."
msgstr "Знайдено посилання на сутність параметра там, де це було заборонено."

#: ../../library/pyexpat.rst:782
msgid "An incomplete character was found in the input."
msgstr "У вхідних даних знайдено неповний символ."

#: ../../library/pyexpat.rst:787
msgid ""
"An entity reference contained another reference to the same entity; possibly "
"via a different name, and possibly indirectly."
msgstr ""
"Посилання на сутність містило інше посилання на ту саму сутність; можливо, "
"через інше ім'я та, можливо, опосередковано."

#: ../../library/pyexpat.rst:793
msgid "Some unspecified syntax error was encountered."
msgstr "Виявлено невідому синтаксичну помилку."

#: ../../library/pyexpat.rst:798
msgid "An end tag did not match the innermost open start tag."
msgstr "Кінцевий тег не збігається з внутрішнім відкритим початковим тегом."

#: ../../library/pyexpat.rst:803
msgid ""
"Some token (such as a start tag) was not closed before the end of the stream "
"or the next token was encountered."
msgstr ""
"Деякий маркер (наприклад, початковий тег) не було закрито до кінця потоку "
"або виявлено наступний маркер."

#: ../../library/pyexpat.rst:809
msgid "A reference was made to an entity which was not defined."
msgstr "Було зроблено посилання на сутність, яка не була визначена."

#: ../../library/pyexpat.rst:814
msgid "The document encoding is not supported by Expat."
msgstr "Кодування документа не підтримується Expat."

#: ../../library/pyexpat.rst:819
msgid "A CDATA marked section was not closed."
msgstr "Розділ, позначений CDATA, не було закрито."

#: ../../library/pyexpat.rst:827
msgid ""
"The parser determined that the document was not \"standalone\" though it "
"declared itself to be in the XML declaration, and the :attr:"
"`NotStandaloneHandler` was set and returned ``0``."
msgstr ""
"Синтаксичний аналізатор визначив, що документ не був \"автономним\", хоча "
"він оголошував себе таким у декларації XML, а :attr:`NotStandaloneHandler` "
"було встановлено та повернуто ``0``."

#: ../../library/pyexpat.rst:840
msgid ""
"An operation was requested that requires DTD support to be compiled in, but "
"Expat was configured without DTD support.  This should never be reported by "
"a standard build of the :mod:`xml.parsers.expat` module."
msgstr ""
"Був запит на операцію, яка потребує підтримки DTD для компіляції, але Expat "
"було налаштовано без підтримки DTD. Стандартна збірка модуля :mod:`xml."
"parsers.expat` ніколи не повинна повідомляти про це."

#: ../../library/pyexpat.rst:847
msgid ""
"A behavioral change was requested after parsing started that can only be "
"changed before parsing has started.  This is (currently) only raised by :"
"meth:`UseForeignDTD`."
msgstr ""
"Після початку аналізу надійшов запит на зміну поведінки, яку можна змінити "
"лише до початку аналізу. Це (наразі) викликає лише :meth:`UseForeignDTD`."

#: ../../library/pyexpat.rst:854
msgid "An undeclared prefix was found when namespace processing was enabled."
msgstr ""
"Коли обробку простору імен було ввімкнено, виявлено неоголошений префікс."

#: ../../library/pyexpat.rst:859
msgid ""
"The document attempted to remove the namespace declaration associated with a "
"prefix."
msgstr ""
"У документі зроблено спробу видалити декларацію простору імен, пов’язану з "
"префіксом."

#: ../../library/pyexpat.rst:865
msgid "A parameter entity contained incomplete markup."
msgstr "Сутність параметра містила неповну розмітку."

#: ../../library/pyexpat.rst:870
msgid "The document contained no document element at all."
msgstr "Документ взагалі не містив елемента документа."

#: ../../library/pyexpat.rst:875
msgid "There was an error parsing a text declaration in an external entity."
msgstr ""
"Під час синтаксичного аналізу текстової декларації у зовнішній сутності "
"сталася помилка."

#: ../../library/pyexpat.rst:880
msgid "Characters were found in the public id that are not allowed."
msgstr "У загальнодоступному ідентифікаторі знайдено неприпустимі символи."

#: ../../library/pyexpat.rst:885
msgid ""
"The requested operation was made on a suspended parser, but isn't allowed.  "
"This includes attempts to provide additional input or to stop the parser."
msgstr ""
"Потрібну операцію було виконано на призупиненому аналізаторі, але вона не "
"дозволена. Це включає спроби надати додаткові вхідні дані або зупинити "
"аналізатор."

#: ../../library/pyexpat.rst:891
msgid ""
"An attempt to resume the parser was made when the parser had not been "
"suspended."
msgstr ""
"Спроба відновити аналізатор була зроблена, коли аналізатор не було "
"призупинено."

#: ../../library/pyexpat.rst:896 ../../library/pyexpat.rst:929
#: ../../library/pyexpat.rst:934
msgid "This should not be reported to Python applications."
msgstr "Про це не слід повідомляти програми Python."

#: ../../library/pyexpat.rst:901
msgid ""
"The requested operation was made on a parser which was finished parsing "
"input, but isn't allowed.  This includes attempts to provide additional "
"input or to stop the parser."
msgstr ""
"Потрібну операцію було виконано на синтаксичному аналізаторі, який завершив "
"розбір вхідних даних, але це не дозволено. Це включає спроби надати "
"додаткові вхідні дані або зупинити аналізатор."

#: ../../library/pyexpat.rst:911
msgid ""
"An attempt was made to undeclare reserved namespace prefix ``xml`` or to "
"bind it to another namespace URI."
msgstr ""

#: ../../library/pyexpat.rst:918
msgid ""
"An attempt was made to declare or undeclare reserved namespace prefix "
"``xmlns``."
msgstr ""

#: ../../library/pyexpat.rst:923
msgid ""
"An attempt was made to bind the URI of one the reserved namespace prefixes "
"``xml`` and ``xmlns`` to another namespace prefix."
msgstr ""

#: ../../library/pyexpat.rst:939
msgid ""
"The limit on input amplification factor (from DTD and entities) has been "
"breached."
msgstr ""

#: ../../library/pyexpat.rst:945
msgid "The parser was tried to be stopped or suspended before it started."
msgstr ""

#: ../../library/pyexpat.rst:951
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../library/pyexpat.rst:952
msgid ""
"The encoding string included in XML output should conform to the appropriate "
"standards. For example, \"UTF-8\" is valid, but \"UTF8\" is not. See https://"
"www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl and https://www.iana."
"org/assignments/character-sets/character-sets.xhtml."
msgstr ""
"Рядок кодування, включений у вивід XML, має відповідати відповідним "
"стандартам. Наприклад, \"UTF-8\" дійсний, а \"UTF8\" – ні. Див. https://www."
"w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl і https://www.iana.org/"
"assignments/character-sets/character-sets.xhtml."

#: ../../library/pyexpat.rst:25
msgid "Expat"
msgstr ""

#: ../../library/pyexpat.rst:35
msgid "module"
msgstr "módulo"

#: ../../library/pyexpat.rst:35
msgid "pyexpat"
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-21 14:14+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/pdb.rst:4
msgid ":mod:`pdb` --- The Python Debugger"
msgstr ":mod:`pdb` --- O depurador do Python"

#: ../../library/pdb.rst:9
msgid "**Source code:** :source:`Lib/pdb.py`"
msgstr "**Código-fonte:** :source:`Lib/pdb.py`"

#: ../../library/pdb.rst:15
msgid ""
"The module :mod:`pdb` defines an interactive source code debugger for Python "
"programs.  It supports setting (conditional) breakpoints and single stepping "
"at the source line level, inspection of stack frames, source code listing, "
"and evaluation of arbitrary Python code in the context of any stack frame.  "
"It also supports post-mortem debugging and can be called under program "
"control."
msgstr ""
"O módulo :mod:`pdb` define um depurador de código-fonte interativo para "
"programas Python. Ele possui suporte a definição de pontos de interrupção "
"(condicionais) e passo único no nível da linha de origem, inspeção de "
"quadros de pilha, listagem de código-fonte e avaliação de código Python "
"arbitrário no contexto de qualquer quadro de pilha. Ele também tem suporte a "
"depuração *post-mortem* e pode ser chamado sob controle do programa."

#: ../../library/pdb.rst:26
msgid ""
"The debugger is extensible -- it is actually defined as the class :class:"
"`Pdb`. This is currently undocumented but easily understood by reading the "
"source.  The extension interface uses the modules :mod:`bdb` and :mod:`cmd`."
msgstr ""
"O depurador é extensível -- na verdade, ele é definido como a classe :class:"
"`Pdb`. Atualmente, isso não está documentado, mas é facilmente compreendido "
"pela leitura do código-fonte. A interface de extensão usa os módulos :mod:"
"`bdb` e :mod:`cmd`."

#: ../../library/pdb.rst:32
msgid "Module :mod:`faulthandler`"
msgstr "Módulo :mod:`faulthandler`"

#: ../../library/pdb.rst:33
msgid ""
"Used to dump Python tracebacks explicitly, on a fault, after a timeout, or "
"on a user signal."
msgstr ""
"Usado para despejar tracebacks (situação da pilha de execução) do Python "
"explicitamente, em uma falha, após um tempo limite ou em um sinal do usuário."

#: ../../library/pdb.rst:36
msgid "Module :mod:`traceback`"
msgstr "Módulo :mod:`traceback`"

#: ../../library/pdb.rst:37
msgid ""
"Standard interface to extract, format and print stack traces of Python "
"programs."
msgstr ""
"Interface padrão para extrair, formatar e imprimir rastreamentos de pilha de "
"programas Python."

#: ../../library/pdb.rst:39
msgid "The typical usage to break into the debugger is to insert::"
msgstr "O uso típico para entrar no depurador é inserir::"

#: ../../library/pdb.rst:41
msgid "import pdb; pdb.set_trace()"
msgstr "import pdb; pdb.set_trace()"

#: ../../library/pdb.rst:43
msgid "Or::"
msgstr "ou::"

#: ../../library/pdb.rst:45
msgid "breakpoint()"
msgstr "breakpoint()"

#: ../../library/pdb.rst:47
msgid ""
"at the location you want to break into the debugger, and then run the "
"program. You can then step through the code following this statement, and "
"continue running without the debugger using the :pdbcmd:`continue` command."
msgstr ""
"no local que você deseja entrar o depurador e, em seguida, executar o "
"programa. Você pode percorrer o código seguindo esta instrução e continuar "
"executando sem o depurador usando o comando :pdbcmd:`continue`."

#: ../../library/pdb.rst:51
msgid ""
"The built-in :func:`breakpoint`, when called with defaults, can be used "
"instead of ``import pdb; pdb.set_trace()``."
msgstr ""
"A função embutida :func:`breakpoint`, quando chamada com valores padrão, "
"pode ser usada em vez de ``import pdb; pdb.set_trace()``."

#: ../../library/pdb.rst:57
msgid ""
"def double(x):\n"
"   breakpoint()\n"
"   return x * 2\n"
"val = 3\n"
"print(f\"{val} * 2 is {double(val)}\")"
msgstr ""
"def double(x):\n"
"   breakpoint()\n"
"   return x * 2\n"
"val = 3\n"
"print(f\"{val} * 2 is {double(val)}\")"

#: ../../library/pdb.rst:63
msgid ""
"The debugger's prompt is ``(Pdb)``, which is the indicator that you are in "
"debug mode::"
msgstr ""
"O prompt do depurador é ``(Pdb)``, que é o indicador de que você está no "
"modo de depuração::"

#: ../../library/pdb.rst:65
msgid ""
"> ...(2)double()\n"
"-> breakpoint()\n"
"(Pdb) p x\n"
"3\n"
"(Pdb) continue\n"
"3 * 2 is 6"
msgstr ""
"> ...(2)double()\n"
"-> breakpoint()\n"
"(Pdb) p x\n"
"3\n"
"(Pdb) continue\n"
"3 * 2 is 6"

#: ../../library/pdb.rst:72
msgid ""
"Tab-completion via the :mod:`readline` module is available for commands and "
"command arguments, e.g. the current global and local names are offered as "
"arguments of the ``p`` command."
msgstr ""
"O preenchimento por tabulação através do módulo :mod:`readline` está "
"disponível para comandos e argumentos de comando, por exemplo os nomes "
"globais e locais atuais são oferecidos como argumentos do comando ``p``."

#: ../../library/pdb.rst:81
msgid "Command-line interface"
msgstr "Interface de linha de comando"

#: ../../library/pdb.rst:85
msgid ""
"You can also invoke :mod:`pdb` from the command line to debug other "
"scripts.  For example::"
msgstr ""
"Você também pode invocar :mod:`pdb` na linha de comando para depurar outros "
"scripts. Por exemplo::"

#: ../../library/pdb.rst:88
msgid "python -m pdb [-c command] (-m module | -p pid | pyfile) [args ...]"
msgstr ""
"python -m pdb [-c comando] (-m módulo | -p pid | arquivo_python) "
"[argumentos ...]"

#: ../../library/pdb.rst:90
msgid ""
"When invoked as a module, pdb will automatically enter post-mortem debugging "
"if the program being debugged exits abnormally.  After post-mortem debugging "
"(or after normal exit of the program), pdb will restart the program.  "
"Automatic restarting preserves pdb's state (such as breakpoints) and in most "
"cases is more useful than quitting the debugger upon program's exit."
msgstr ""
"Quando invocado como um módulo, o pdb entra automaticamente na depuração "
"*post-mortem* se o programa que está sendo depurado for encerrado de forma "
"anormal. Após a depuração *post-mortem* (ou após a saída normal do "
"programa), o pdb reiniciará o programa. A reinicialização automática "
"preserva o estado do pdb (p.ex., pontos de interrupção) e, na maioria dos "
"casos, é mais útil do que encerrar o depurador na saída do programa."

#: ../../library/pdb.rst:98
msgid ""
"To execute commands as if given in a :file:`.pdbrc` file; see :ref:`debugger-"
"commands`."
msgstr ""
"Para executar comandos como se fossem dados em um arquivo :file:`.pdbrc`. "
"Veja :ref:`debugger-commands`."

#: ../../library/pdb.rst:101
msgid "Added the ``-c`` option."
msgstr "Adicionada a opção ``-c``."

#: ../../library/pdb.rst:106
msgid ""
"To execute modules similar to the way ``python -m`` does. As with a script, "
"the debugger will pause execution just before the first line of the module."
msgstr ""
"Para executar módulos de maneira similar ao ``python -m``. Assim como em um "
"script, o depurador pausará a execução logo antes da primeira linha do "
"módulo."

#: ../../library/pdb.rst:109
msgid "Added the ``-m`` option."
msgstr "Adicionada a opção ``-m``."

#: ../../library/pdb.rst:114
msgid "Attach to the process with the specified PID."
msgstr "Anexa ao processo com o PID especificado."

#: ../../library/pdb.rst:119
msgid ""
"To attach to a running Python process for remote debugging, use the ``-p`` "
"or ``--pid`` option with the target process's PID::"
msgstr ""
"Para anexar a um processo Python em execução para depuração remota, use a "
"opção ``-p`` ou ``--pid`` com o PID do processo de destino::"

#: ../../library/pdb.rst:122
msgid "python -m pdb -p 1234"
msgstr "python -m pdb -p 1234"

#: ../../library/pdb.rst:126
msgid ""
"Attaching to a process that is blocked in a system call or waiting for I/O "
"will only work once the next bytecode instruction is executed or when the "
"process receives a signal."
msgstr ""
"Anexar a um processo remoto bloqueado em uma chamada de sistema ou "
"aguardando E/S só funcionará quando a próxima instrução de bytecode for "
"executada ou quando o processo receber um sinal."

#: ../../library/pdb.rst:130
msgid "Typical usage to execute a statement under control of the debugger is::"
msgstr ""
"O uso típico para executar uma instrução sob o controle do depurador é::"

#: ../../library/pdb.rst:132
msgid ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
">>> pdb.run(\"f(2)\")\n"
"> <string>(1)<module>()\n"
"(Pdb) continue\n"
"0.5\n"
">>>"
msgstr ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
">>> pdb.run(\"f(2)\")\n"
"> <string>(1)<module>()\n"
"(Pdb) continue\n"
"0.5\n"
">>>"

#: ../../library/pdb.rst:141
msgid "The typical usage to inspect a crashed program is::"
msgstr "O uso típico para inspecionar um programa com falha é::"

#: ../../library/pdb.rst:143
msgid ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
"...\n"
">>> f(0)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 2, in f\n"
"ZeroDivisionError: division by zero\n"
">>> pdb.pm()\n"
"> <stdin>(2)f()\n"
"(Pdb) p x\n"
"0\n"
"(Pdb)"
msgstr ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
"...\n"
">>> f(0)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 2, in f\n"
"ZeroDivisionError: division by zero\n"
">>> pdb.pm()\n"
"> <stdin>(2)f()\n"
"(Pdb) p x\n"
"0\n"
"(Pdb)"

#: ../../library/pdb.rst:158
msgid ""
"The implementation of :pep:`667` means that name assignments made via "
"``pdb`` will immediately affect the active scope, even when running inside "
"an :term:`optimized scope`."
msgstr ""
"A implementação da :pep:`667` significa que atribuições de nomes feitas via "
"``pdb`` afetarão imediatamente o escopo ativo, mesmo quando executado dentro "
"de um :term:`escopo otimizado`."

#: ../../library/pdb.rst:164
msgid ""
"The module defines the following functions; each enters the debugger in a "
"slightly different way:"
msgstr ""
"O módulo define as seguintes funções; cada uma entra no depurador de uma "
"maneira ligeiramente diferente:"

#: ../../library/pdb.rst:169
msgid ""
"Execute the *statement* (given as a string or a code object) under debugger "
"control.  The debugger prompt appears before any code is executed; you can "
"set breakpoints and type :pdbcmd:`continue`, or you can step through the "
"statement using :pdbcmd:`step` or :pdbcmd:`next` (all these commands are "
"explained below).  The optional *globals* and *locals* arguments specify the "
"environment in which the code is executed; by default the dictionary of the "
"module :mod:`__main__` is used.  (See the explanation of the built-in :func:"
"`exec` or :func:`eval` functions.)"
msgstr ""
"Executa a instrução *statement* (fornecida como uma string ou um objeto "
"código) sob controle do depurador. O prompt do depurador aparece antes de "
"qualquer código ser executado; você pode definir pontos de interrupção e "
"digitar :pdbcmd:`continue` ou pode percorrer a instrução usando :pdbcmd:"
"`step` ou :pdbcmd:`next` (todos esses comandos são explicados abaixo). Os "
"argumentos opcionais *globals* e *locals* especificam o ambiente em que o "
"código é executado; por padrão, o dicionário do módulo :mod:`__main__` é "
"usado. (Veja a explicação das funções embutidas :func:`exec` ou :func:"
"`eval`.)"

#: ../../library/pdb.rst:181
msgid ""
"Evaluate the *expression* (given as a string or a code object) under "
"debugger control.  When :func:`runeval` returns, it returns the value of the "
"*expression*.  Otherwise this function is similar to :func:`run`."
msgstr ""
"Avalia a expressão *expression* (fornecida como uma string ou um objeto "
"código) sob controle do depurador. Quando :func:`runeval` retorna, ele "
"retorna o valor de *expression*. Caso contrário, esta função é semelhante a :"
"func:`run`."

#: ../../library/pdb.rst:188
msgid ""
"Call the *function* (a function or method object, not a string) with the "
"given arguments.  When :func:`runcall` returns, it returns whatever the "
"function call returned.  The debugger prompt appears as soon as the function "
"is entered."
msgstr ""
"Chama a função *function* (um objeto função ou método, não uma string) com "
"os argumentos fornecidos. Quando :func:`runcall` retorna, ele retorna "
"qualquer que seja a chamada de função retornada. O prompt do depurador "
"aparece assim que a função é inserida."

#: ../../library/pdb.rst:196
msgid ""
"Enter the debugger at the calling stack frame.  This is useful to hard-code "
"a breakpoint at a given point in a program, even if the code is not "
"otherwise being debugged (e.g. when an assertion fails).  If given, *header* "
"is printed to the console just before debugging begins. The *commands* "
"argument, if given, is a list of commands to execute when the debugger "
"starts."
msgstr ""
"Entra no depurador no quadro da pilha de chamada. Isso é útil para codificar "
"um ponto de interrupção em um determinado ponto de um programa, mesmo que o "
"código não esteja sendo depurado de outra forma (por exemplo, quando uma "
"asserção falha). Se fornecido, *header* é impresso no console imediatamente "
"antes do início da depuração. O argumento *commands*, se fornecido, é uma "
"lista de comandos para executar quando o depurador é iniciado."

#: ../../library/pdb.rst:204
msgid "The keyword-only argument *header*."
msgstr "O argumento somente-nomeado *header*."

#: ../../library/pdb.rst:207
msgid ""
":func:`set_trace` will enter the debugger immediately, rather than on the "
"next line of code to be executed."
msgstr ""
":func:`set_trace` entrará no depurador imediatamente, em vez da próxima "
"linha de código a ser executada."

#: ../../library/pdb.rst:211
msgid "The *commands* argument."
msgstr "O argumento *commands*."

#: ../../library/pdb.rst:217
msgid ""
"async version of :func:`set_trace`. This function should be used inside an "
"async function with :keyword:`await`."
msgstr ""
"Versão async de :func:`set_trace`. Esta função deve ser usada dentro de uma "
"função async com :keyword:`await`."

#: ../../library/pdb.rst:220
msgid ""
"async def f():\n"
"    await pdb.set_trace_async()"
msgstr ""
"async def f():\n"
"    await pdb.set_trace_async()"

#: ../../library/pdb.rst:225
msgid ""
":keyword:`await` statements are supported if the debugger is invoked by this "
"function."
msgstr ""
"As instruções :keyword:`await` são suportadas se o depurador for invocado "
"por esta função."

#: ../../library/pdb.rst:231
msgid ""
"Enter post-mortem debugging of the given exception or :ref:`traceback object "
"<traceback-objects>`. If no value is given, it uses the exception that is "
"currently being handled, or raises ``ValueError`` if there isn’t one."
msgstr ""
"Entra em depuração post-mortem da exceção fornecida ou :ref:`objeto "
"traceback <traceback-objects>`. Se nenhum valor for fornecido, usa a exceção "
"que está sendo tratada no momento ou levanta ``ValueError`` se não houver "
"nenhuma."

#: ../../library/pdb.rst:236
msgid "Support for exception objects was added."
msgstr "Adiciona suporte a objetos exceção."

#: ../../library/pdb.rst:241
msgid ""
"Enter post-mortem debugging of the exception found in :data:`sys.last_exc`."
msgstr ""
"Entra a depuração post-mortem da exceção encontrada em :data:`sys.last_exc`."

#: ../../library/pdb.rst:246
msgid ""
"There are two supported backends for pdb: ``'settrace'`` and "
"``'monitoring'``. See :class:`bdb.Bdb` for details. The user can set the "
"default backend to use if none is specified when instantiating :class:`Pdb`. "
"If no backend is specified, the default is ``'settrace'``."
msgstr ""
"Há dois backends suportados para pdb: ``'settrace'`` e ``'monitoring'``. "
"Consulte :class:`bdb.Bdb` para obter detalhes. O usuário pode definir o "
"backend padrão a ser usado caso nenhum seja especificado ao instanciar :"
"class:`Pdb`. Se nenhum backend for especificado, o padrão será "
"``'settrace'``."

#: ../../library/pdb.rst:253
msgid ""
":func:`breakpoint` and :func:`set_trace` will not be affected by this "
"function. They always use ``'monitoring'`` backend."
msgstr ""
":func:`breakpoint` e :func:`set_trace` não serão afetados por esta função. "
"Eles sempre usam o backend ``'monitoring'``."

#: ../../library/pdb.rst:260
msgid "Returns the default backend for pdb."
msgstr "Retorna o backend padrão para pdb."

#: ../../library/pdb.rst:264
msgid ""
"The ``run*`` functions and :func:`set_trace` are aliases for instantiating "
"the :class:`Pdb` class and calling the method of the same name.  If you want "
"to access further features, you have to do this yourself:"
msgstr ""
"As funções ``run*`` e a :func:`set_trace` são aliases, ou apelidos, para "
"instanciar a classe :class:`Pdb` e chamar o método com o mesmo nome. Se você "
"deseja acessar outros recursos, faça você mesmo:"

#: ../../library/pdb.rst:271
msgid ":class:`Pdb` is the debugger class."
msgstr ":class:`Pdb` é a classe do depurador."

#: ../../library/pdb.rst:273
msgid ""
"The *completekey*, *stdin* and *stdout* arguments are passed to the "
"underlying :class:`cmd.Cmd` class; see the description there."
msgstr ""
"Os argumentos *completekey*, *stdin* e *stdout* são passados para a classe "
"subjacente :class:`cmd.Cmd`; veja a descrição lá."

#: ../../library/pdb.rst:276
msgid ""
"The *skip* argument, if given, must be an iterable of glob-style module name "
"patterns.  The debugger will not step into frames that originate in a module "
"that matches one of these patterns. [1]_"
msgstr ""
"O argumento *skip*, se fornecido, deve ser um iterável de padrões de nome de "
"módulo no estilo glob. O depurador não entrará nos quadros que se originam "
"em um módulo que corresponde a um desses padrões. [1]_"

#: ../../library/pdb.rst:280
msgid ""
"By default, Pdb sets a handler for the SIGINT signal (which is sent when the "
"user presses :kbd:`Ctrl-C` on the console) when you give a :pdbcmd:"
"`continue` command. This allows you to break into the debugger again by "
"pressing :kbd:`Ctrl-C`.  If you want Pdb not to touch the SIGINT handler, "
"set *nosigint* to true."
msgstr ""
"Por padrão, o Pdb define um manipulador para o sinal SIGINT (que é enviado "
"quando o usuário pressiona :kbd:`Ctrl-C` no console) quando você dá um "
"comando :pdbcmd:`continue`. Isso permite que você entre no depurador "
"novamente pressionando :kbd:`Ctrl-C`. Se você deseja que o Pdb não toque no "
"manipulador SIGINT, defina *nosigint* como verdadeiro."

#: ../../library/pdb.rst:285
msgid ""
"The *readrc* argument defaults to true and controls whether Pdb will load ."
"pdbrc files from the filesystem."
msgstr ""
"O argumento *readrc* é padronizado como verdadeiro e controla se o Pdb "
"carregará arquivos .pdbrc do sistema de arquivos."

#: ../../library/pdb.rst:288
msgid ""
"The *mode* argument specifies how the debugger was invoked. It impacts the "
"workings of some debugger commands. Valid values are ``'inline'`` (used by "
"the breakpoint() builtin), ``'cli'`` (used by the command line invocation) "
"or ``None`` (for backwards compatible behaviour, as before the *mode* "
"argument was added)."
msgstr ""
"O argumento *mode* especifica como o depurador foi invocado. Ele afeta o "
"funcionamento de alguns comandos do depurador. Os valores válidos são "
"``'inline'`` (usado pelo comando embutido breakpoint()), ``'cli'`` (usado "
"pela invocação da linha de comando) ou ``None`` (para comportamento "
"retrocompatível, como antes da adição do argumento *mode*)."

#: ../../library/pdb.rst:295
msgid ""
"The *backend* argument specifies the backend to use for the debugger. If "
"``None`` is passed, the default backend will be used. See :func:"
"`set_default_backend`. Otherwise the supported backends are ``'settrace'`` "
"and ``'monitoring'``."
msgstr ""
"O argumento *backend* especifica o backend a ser usado pelo depurador. Se "
"``None`` for passado, o backend padrão será usado. Consulte :func:"
"`set_default_backend`. Caso contrário, os backends implementados são "
"``'settrace'`` e ``'monitoring'``."

#: ../../library/pdb.rst:299
msgid ""
"The *colorize* argument, if set to ``True``, will enable colorized output in "
"the debugger, if color is supported. This will highlight source code "
"displayed in pdb."
msgstr ""
"O argumento *colorize*, se definido como ``True``, habilitará a saída "
"colorida no depurador, se houver suporte para cores. Isso destacará o código-"
"fonte exibido no pdb."

#: ../../library/pdb.rst:302
msgid "Example call to enable tracing with *skip*::"
msgstr "Exemplo de chamada para habilitar rastreamento com *skip*::"

#: ../../library/pdb.rst:304
msgid "import pdb; pdb.Pdb(skip=['django.*']).set_trace()"
msgstr "import pdb; pdb.Pdb(skip=['django.*']).set_trace()"

#: ../../library/pdb.rst:306
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pdb.Pdb`` with no arguments."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``pdb.Pdb`` sem argumentos."

#: ../../library/pdb.rst:308
msgid "Added the *skip* parameter."
msgstr "Adicionado o parâmetro *skip*."

#: ../../library/pdb.rst:311
msgid ""
"Added the *nosigint* parameter. Previously, a SIGINT handler was never set "
"by Pdb."
msgstr ""
"Adicionado o parâmetro *nosigint*. Anteriormente, um manipulador de SIGINT "
"nunca era definido por Pdb."

#: ../../library/pdb.rst:315
msgid "The *readrc* argument."
msgstr "O argumento *readrc*."

#: ../../library/pdb.rst:318
msgid "Added the *mode* argument."
msgstr "Adicionado o argumento *mode*."

#: ../../library/pdb.rst:321
msgid "Added the *backend* argument."
msgstr "Adicionado o argumento *backend*."

#: ../../library/pdb.rst:324
msgid "Added the *colorize* argument."
msgstr "Adicionado o argumento *colorize*."

#: ../../library/pdb.rst:327
msgid ""
"Inline breakpoints like :func:`breakpoint` or :func:`pdb.set_trace` will "
"always stop the program at calling frame, ignoring the *skip* pattern (if "
"any)."
msgstr ""
"Pontos de interrupção em linha como :func:`breakpoint` ou :func:`pdb."
"set_trace` sempre interromperão o programa ao chamar o quadro, ignorando o "
"padrão *skip* (se houver)."

#: ../../library/pdb.rst:336
msgid "See the documentation for the functions explained above."
msgstr "Consulte a documentação para as funções explicadas acima."

#: ../../library/pdb.rst:342
msgid "Debugger commands"
msgstr "Comandos de depuração"

#: ../../library/pdb.rst:344
msgid ""
"The commands recognized by the debugger are listed below.  Most commands can "
"be abbreviated to one or two letters as indicated; e.g. ``h(elp)`` means "
"that either ``h`` or ``help`` can be used to enter the help command (but not "
"``he`` or ``hel``, nor ``H`` or ``Help`` or ``HELP``).  Arguments to "
"commands must be separated by whitespace (spaces or tabs).  Optional "
"arguments are enclosed in square brackets (``[]``) in the command syntax; "
"the square brackets must not be typed.  Alternatives in the command syntax "
"are separated by a vertical bar (``|``)."
msgstr ""
"Os comandos reconhecidos pelo depurador estão listados abaixo. A maioria dos "
"comandos pode ser abreviada para uma ou duas letras, conforme indicado; por "
"exemplo, ``h(elp)`` significa que ``h`` ou ``help`` podem ser usados para "
"inserir o comando de ajuda (mas não ``he`` ou ``hel``, nem ``H`` ou ``Help`` "
"ou ``HELP``). Os argumentos para os comandos devem ser separados por espaços "
"em branco (espaços ou tabulações). Os argumentos opcionais estão entre "
"colchetes (``[]``) na sintaxe do comando; os colchetes não devem ser "
"digitados. As alternativas na sintaxe de comando são separadas por uma barra "
"vertical (``|``)."

#: ../../library/pdb.rst:353
msgid ""
"Entering a blank line repeats the last command entered.  Exception: if the "
"last command was a :pdbcmd:`list` command, the next 11 lines are listed."
msgstr ""
"Digitar uma linha em branco repete o último comando digitado. Exceção: se o "
"último comando foi um comando :pdbcmd:`list`, as próximas 11 linhas serão "
"listadas."

#: ../../library/pdb.rst:356
msgid ""
"Commands that the debugger doesn't recognize are assumed to be Python "
"statements and are executed in the context of the program being debugged.  "
"Python statements can also be prefixed with an exclamation point (``!``).  "
"This is a powerful way to inspect the program being debugged; it is even "
"possible to change a variable or call a function.  When an exception occurs "
"in such a statement, the exception name is printed but the debugger's state "
"is not changed."
msgstr ""
"Os comandos que o depurador não reconhece são presumidos como instruções "
"Python e são executados no contexto do programa que está sendo depurado. As "
"instruções Python também podem ser prefixadas com um ponto de exclamação (``!"
"``). Essa é uma maneira poderosa de inspecionar o programa que está sendo "
"depurado; é até possível alterar uma variável ou chamar uma função. Quando "
"ocorre uma exceção em uma instrução, o nome da exceção é impresso, mas o "
"estado do depurador não é alterado."

#: ../../library/pdb.rst:364
msgid ""
"Expressions/Statements whose prefix is a pdb command are now correctly "
"identified and executed."
msgstr ""
"Expressões/instruções, cujo prefixo é um comando pdb, agora são "
"identificadas e executadas corretamente."

#: ../../library/pdb.rst:368
msgid ""
"The debugger supports :ref:`aliases <debugger-aliases>`.  Aliases can have "
"parameters which allows one a certain level of adaptability to the context "
"under examination."
msgstr ""
"O depurador possui suporte a :ref:`aliases <debugger-aliases>`. Os aliases "
"podem ter parâmetros que permitem um certo nível de adaptabilidade ao "
"contexto em exame."

#: ../../library/pdb.rst:372
msgid ""
"Multiple commands may be entered on a single line, separated by ``;;``.  (A "
"single ``;`` is not used as it is the separator for multiple commands in a "
"line that is passed to the Python parser.)  No intelligence is applied to "
"separating the commands; the input is split at the first ``;;`` pair, even "
"if it is in the middle of a quoted string. A workaround for strings with "
"double semicolons is to use implicit string concatenation ``';'';'`` or ``\";"
"\"\";\"``."
msgstr ""
"Vários comandos podem ser inseridos em uma única linha, separados por ``;;"
"``. (Um único ``;`` não é usado, pois é o separador para vários comandos em "
"uma linha que é passada para o analisador Python.) Nenhuma inteligência é "
"aplicada para separar os comandos; a entrada é dividida no primeiro par ``;;"
"``, mesmo que esteja no meio de uma string entre aspas. Uma solução "
"alternativa para strings com caractere de ponto e vírgula duplo é usar a "
"concatenação de string implícita ``';'';'`` ou ``\";\"\";\"``."

#: ../../library/pdb.rst:379
msgid ""
"To set a temporary global variable, use a *convenience variable*. A "
"*convenience variable* is a variable whose name starts with ``$``.  For "
"example, ``$foo = 1`` sets a global variable ``$foo`` which you can use in "
"the debugger session.  The *convenience variables* are cleared when the "
"program resumes execution so it's less likely to interfere with your program "
"compared to using normal variables like ``foo = 1``."
msgstr ""
"Para definir uma variável global temporária, use uma *variável de "
"conveniência*. Uma *variável de conveniência* é uma variável cujo nome "
"começa com ``$``. Por exemplo, ``$foo = 1`` define uma variável global "
"``$foo`` que você pode usar na sessão do depurador. As *variáveis de "
"conveniência* são limpas quando o programa retoma a execução, portanto é "
"menos provável que interfira em seu programa em comparação ao uso de "
"variáveis normais como ``foo = 1``."

#: ../../library/pdb.rst:386
msgid "There are four preset *convenience variables*:"
msgstr "Existem quatro *variáveis de conveniência* predefinidas:"

#: ../../library/pdb.rst:388
msgid "``$_frame``: the current frame you are debugging"
msgstr "``$_frame``: o quadro atual que você está depurando"

#: ../../library/pdb.rst:389
msgid "``$_retval``: the return value if the frame is returning"
msgstr "``$_retval``: o valor de retorno se o quadro estiver retornando"

#: ../../library/pdb.rst:390
msgid "``$_exception``: the exception if the frame is raising an exception"
msgstr "``$_exception``: a exceção se o quadro estiver levantando uma exceção"

#: ../../library/pdb.rst:391
msgid "``$_asynctask``: the asyncio task if pdb stops in an async function"
msgstr ""
"``$_asynctask``: a tarefa asyncio se o pdb parar em uma função assíncrona"

#: ../../library/pdb.rst:395
msgid "Added the *convenience variable* feature."
msgstr "Adicionado o recurso de *variável de conveniência*."

#: ../../library/pdb.rst:397
msgid "Added the ``$_asynctask`` convenience variable."
msgstr "Adicionada a variável de conveniência ``$_asynctask``."

#: ../../library/pdb.rst:404
msgid ""
"If a file :file:`.pdbrc` exists in the user's home directory or in the "
"current directory, it is read with ``'utf-8'`` encoding and executed as if "
"it had been typed at the debugger prompt, with the exception that empty "
"lines and lines starting with ``#`` are ignored.  This is particularly "
"useful for aliases.  If both files exist, the one in the home directory is "
"read first and aliases defined there can be overridden by the local file."
msgstr ""
"Se um arquivo :file:`.pdbrc` existe no diretório inicial do usuário ou no "
"diretório atual, ele é lido com a codificação ``'utf-8'`` e executado como "
"se tivesse sido digitado no prompt do depurador, com a exceção de que linhas "
"vazias e linhas iniciando com ``#`` são ignoradas. Isso é particularmente "
"útil para aliases. Se ambos os arquivos existirem, aquele no diretório "
"inicial será lido primeiro e os aliases definidos poderão ser substituídos "
"pelo arquivo local."

#: ../../library/pdb.rst:411
msgid ""
":file:`.pdbrc` can now contain commands that continue debugging, such as :"
"pdbcmd:`continue` or :pdbcmd:`next`.  Previously, these commands had no "
"effect."
msgstr ""
":file:`.pdbrc` agora pode conter comandos que continuam a depuração, como :"
"pdbcmd:`continue` ou :pdbcmd:`next`. Anteriormente, esses comandos não "
"tinham efeito."

#: ../../library/pdb.rst:416
msgid ""
":file:`.pdbrc` is now read with ``'utf-8'`` encoding. Previously, it was "
"read with the system locale encoding."
msgstr ""
":file:`.pdbrc` agora é lido com a codificação ``'utf-8'``. Anteriormente, "
"ele era lido com a codificação da localidade do sistema."

#: ../../library/pdb.rst:423
msgid ""
"Without argument, print the list of available commands.  With a *command* as "
"argument, print help about that command.  ``help pdb`` displays the full "
"documentation (the docstring of the :mod:`pdb` module).  Since the *command* "
"argument must be an identifier, ``help exec`` must be entered to get help on "
"the ``!`` command."
msgstr ""
"Sem argumento, imprime a lista de comandos disponíveis. Com um *command* "
"como argumento, imprime ajuda sobre esse comando. ``help pdb`` exibe a "
"documentação completa (a docstring do módulo :mod:`pdb`). Como o argumento "
"*command* deve ser um identificador, ``help exec`` deve ser inserido para "
"obter ajuda sobre o comando ``!``."

#: ../../library/pdb.rst:431
msgid ""
"Print a stack trace, with the most recent frame at the bottom.  if *count* "
"is 0, print the current frame entry. If *count* is negative, print the least "
"recent - *count* frames. If *count* is positive, print the most recent "
"*count* frames.  An arrow (``>``) indicates the current frame, which "
"determines the context of most commands."
msgstr ""
"Exibe um stack trace (situação da pilha de execução), com o quadro mais "
"recente na parte inferior. Se *count* for 0, exibe a entrada do quadro "
"atual. Se *count* for negativo, exibe os quadros menos recentes - *count*. "
"Se *count* for positivo, exibe os quadros *count* mais recentes. Uma seta "
"(``>``) indica o quadro atual, que determina o contexto da maioria dos "
"comandos."

#: ../../library/pdb.rst:437
msgid "*count* argument is added."
msgstr "o argumento *count* foi adicionado"

#: ../../library/pdb.rst:442
msgid ""
"Move the current frame *count* (default one) levels down in the stack trace "
"(to a newer frame)."
msgstr ""
"Move os níveis do quadro atual *count* (padrão 1) para baixo no stack trace "
"(para um quadro mais recente)."

#: ../../library/pdb.rst:447
msgid ""
"Move the current frame *count* (default one) levels up in the stack trace "
"(to an older frame)."
msgstr ""
"Move os níveis do quadro atual na *count* (padrão 1) para cima no stack "
"trace (para um quadro mais antigo)."

#: ../../library/pdb.rst:452
msgid ""
"With a *lineno* argument, set a break at line *lineno* in the current file. "
"The line number may be prefixed with a *filename* and a colon, to specify a "
"breakpoint in another file (possibly one that hasn't been loaded yet).  The "
"file is searched on :data:`sys.path`.  Acceptable forms of *filename* are ``/"
"abspath/to/file.py``, ``relpath/file.py``, ``module`` and ``package.module``."
msgstr ""
"Com um argumento *lineno*, define uma quebra na linha *lineno* no arquivo "
"atual. O número da linha pode ser prefixado com *filename* e dois pontos, "
"para especificar um ponto de interrupção em outro arquivo (possivelmente um "
"que ainda não tenha sido carregado). O arquivo é pesquisado em :data:`sys."
"path`. Formas aceitáveis de *filename* são ``/caminhoabsoluto/para/arquivo."
"py``, ``caminhorelativo/do/arquivo.py``, ``módulo`` e ``pacote.módulo``."

#: ../../library/pdb.rst:459
msgid ""
"With a *function* argument, set a break at the first executable statement "
"within that function. *function* can be any expression that evaluates to a "
"function in the current namespace."
msgstr ""
"Com um argumento *function*, define uma interrupção na primeira instrução "
"executável dentro dessa função. *function* pode ser qualquer expressão "
"avaliada como uma função no espaço de nomes atual."

#: ../../library/pdb.rst:463
msgid ""
"If a second argument is present, it is an expression which must evaluate to "
"true before the breakpoint is honored."
msgstr ""
"Se um segundo argumento estiver presente, é uma expressão que deve ser "
"avaliada como verdadeira antes que o ponto de interrupção seja respeitado."

#: ../../library/pdb.rst:466
msgid ""
"Without argument, list all breaks, including for each breakpoint, the number "
"of times that breakpoint has been hit, the current ignore count, and the "
"associated condition if any."
msgstr ""
"Sem argumento, lista todas as quebras, inclusive para cada ponto de "
"interrupção, o número de vezes que o ponto de interrupção foi atingido, a "
"contagem atual de ignorados e a condição associada, se houver."

#: ../../library/pdb.rst:470
msgid ""
"Each breakpoint is assigned a number to which all the other breakpoint "
"commands refer."
msgstr ""
"Cada ponto de interrupção recebe um número ao qual todos os outros comandos "
"de ponto de interrupção se referem."

#: ../../library/pdb.rst:475
msgid ""
"Temporary breakpoint, which is removed automatically when it is first hit. "
"The arguments are the same as for :pdbcmd:`break`."
msgstr ""
"Ponto de interrupção temporário, que é removido automaticamente quando é "
"atingido pela primeira vez. Os argumentos são os mesmos que para :pdbcmd:"
"`break`."

#: ../../library/pdb.rst:480
msgid ""
"With a *filename:lineno* argument, clear all the breakpoints at this line. "
"With a space separated list of breakpoint numbers, clear those breakpoints. "
"Without argument, clear all breaks (but first ask confirmation)."
msgstr ""
"Com um argumento *filename:lineno*, limpa todos os pontos de interrupção "
"nessa linha. Com uma lista separada por espaços de números de ponto de "
"interrupção, limpa esses pontos de interrupção. Sem argumento, limpa todas "
"as quebras (mas primeiro pede a confirmação)."

#: ../../library/pdb.rst:486
msgid ""
"Disable the breakpoints given as a space separated list of breakpoint "
"numbers.  Disabling a breakpoint means it cannot cause the program to stop "
"execution, but unlike clearing a breakpoint, it remains in the list of "
"breakpoints and can be (re-)enabled."
msgstr ""
"Desativa os pontos de interrupção fornecidos como uma lista separada por "
"espaços de números de pontos de interrupção. Desabilitar um ponto de "
"interrupção significa que ele não pode interromper a execução do programa, "
"mas, ao contrário de limpar um ponto de interrupção, ele permanece na lista "
"de pontos de interrupção e pode ser (re)ativado."

#: ../../library/pdb.rst:493
msgid "Enable the breakpoints specified."
msgstr "Ativa o ponto de interrupção especificado."

#: ../../library/pdb.rst:497
msgid ""
"Set the ignore count for the given breakpoint number.  If *count* is "
"omitted, the ignore count is set to 0.  A breakpoint becomes active when the "
"ignore count is zero.  When non-zero, the *count* is decremented each time "
"the breakpoint is reached and the breakpoint is not disabled and any "
"associated condition evaluates to true."
msgstr ""
"Define a contagem de ignorados para o número do ponto de interrupção "
"especificado. Se *count* for omitida, a contagem de ignorados será definida "
"como 0. Um ponto de interrupção se torna ativo quando a contagem de "
"ignorados é zero. Quando diferente de zero, a contagem é decrementada cada "
"vez que o ponto de interrupção é atingido e o ponto de interrupção não é "
"desativado e qualquer condição associada é avaliada como verdadeira."

#: ../../library/pdb.rst:505
msgid ""
"Set a new *condition* for the breakpoint, an expression which must evaluate "
"to true before the breakpoint is honored.  If *condition* is absent, any "
"existing condition is removed; i.e., the breakpoint is made unconditional."
msgstr ""
"Define uma nova *condition* para o ponto de interrupção, uma expressão que "
"deve ser avaliada como verdadeira antes que o ponto de interrupção seja "
"respeitado. Se *condition* for omitida, qualquer condição existente será "
"removida; isto é, o ponto de interrupção é tornado incondicional."

#: ../../library/pdb.rst:511
msgid ""
"Specify a list of commands for breakpoint number *bpnumber*.  The commands "
"themselves appear on the following lines.  Type a line containing just "
"``end`` to terminate the commands. An example::"
msgstr ""
"Especifica uma lista de comandos para o número do ponto de interrupção "
"*bpnumber*. Os próprios comandos aparecem nas linhas seguintes. Digite em "
"uma linha contendo apenas ``end`` para finalizar os comandos. Um exemplo::"

#: ../../library/pdb.rst:515
msgid ""
"(Pdb) commands 1\n"
"(com) p some_variable\n"
"(com) end\n"
"(Pdb)"
msgstr ""
"(Pdb) commands 1\n"
"(com) p alguma_variável\n"
"(com) end\n"
"(Pdb)"

#: ../../library/pdb.rst:520
msgid ""
"To remove all commands from a breakpoint, type ``commands`` and follow it "
"immediately with ``end``; that is, give no commands."
msgstr ""
"Para remover todos os comandos de um ponto de interrupção, digite "
"``commands`` e siga-o imediatamente com ``end``; isto é, não dê comandos."

#: ../../library/pdb.rst:523
msgid ""
"With no *bpnumber* argument, ``commands`` refers to the last breakpoint set."
msgstr ""
"Sem argumento *bpnumber*, ``commands`` refere-se ao último conjunto de "
"pontos de interrupção."

#: ../../library/pdb.rst:525
msgid ""
"You can use breakpoint commands to start your program up again.  Simply use "
"the :pdbcmd:`continue` command, or :pdbcmd:`step`, or any other command that "
"resumes execution."
msgstr ""
"Você pode usar comandos de ponto de interrupção para iniciar seu programa "
"novamente. Simplesmente use o comando :pdbcmd:`continue`, ou :pdbcmd:`step`, "
"ou qualquer outro comando que reinicie a execução."

#: ../../library/pdb.rst:529
msgid ""
"Specifying any command resuming execution (currently :pdbcmd:`continue`, :"
"pdbcmd:`step`, :pdbcmd:`next`, :pdbcmd:`return`, :pdbcmd:`until`, :pdbcmd:"
"`jump`, :pdbcmd:`quit` and their abbreviations) terminates the command list "
"(as if that command was immediately followed by end). This is because any "
"time you resume execution (even with a simple next or step), you may "
"encounter another breakpoint—which could have its own command list, leading "
"to ambiguities about which list to execute."
msgstr ""
"Especificar qualquer comando que retome a execução (atualmente :pdbcmd:"
"`continue`, :pdbcmd:`step`, :pdbcmd:`next`, :pdbcmd:`return`, :pdbcmd:"
"`until`, :pdbcmd:`jump`, :pdbcmd:`quit` e suas abreviações) finaliza a lista "
"de comandos (como se esse comando fosse imediatamente seguido pelo end). "
"Isso ocorre porque sempre que você retoma a execução (mesmo com um simples "
"next ou step), você pode encontrar outro ponto de interrupção — que pode ter "
"sua própria lista de comandos, levando a ambiguidades sobre qual lista "
"executar."

#: ../../library/pdb.rst:538
msgid ""
"If the list of commands contains the ``silent`` command, or a command that "
"resumes execution, then the breakpoint message containing information about "
"the frame is not displayed."
msgstr ""
"Se a lista de comandos contiver o comando ``silent`` ou um comando que "
"retome a execução, a mensagem de ponto de interrupção contendo informações "
"sobre o quadro não será exibida."

#: ../../library/pdb.rst:542
msgid ""
"Frame information will not be displayed if a command that resumes execution "
"is present in the command list."
msgstr ""
"As informações do quadro não serão exibidas se um comando que retome a "
"execução estiver presente na lista de comandos."

#: ../../library/pdb.rst:548
msgid ""
"Execute the current line, stop at the first possible occasion (either in a "
"function that is called or on the next line in the current function)."
msgstr ""
"Executa a linha atual, interrompe na primeira ocasião possível (em uma "
"função chamada ou na próxima linha na função atual)."

#: ../../library/pdb.rst:553
msgid ""
"Continue execution until the next line in the current function is reached or "
"it returns.  (The difference between :pdbcmd:`next` and :pdbcmd:`step` is "
"that :pdbcmd:`step` stops inside a called function, while :pdbcmd:`next` "
"executes called functions at (nearly) full speed, only stopping at the next "
"line in the current function.)"
msgstr ""
"Continua a execução até que a próxima linha na função atual seja atingida ou "
"ela retorne. (A diferença entre :pdbcmd:`next` e :pdbcmd:`step` é que :"
"pdbcmd:`step` para dentro de uma função chamada, enquanto :pdbcmd:`next` "
"executa funções chamadas em (quase) velocidade máxima, parando apenas na "
"próxima linha da função atual.)"

#: ../../library/pdb.rst:561
msgid ""
"Without argument, continue execution until the line with a number greater "
"than the current one is reached."
msgstr ""
"Sem argumento, continua a execução até que a linha com um número maior que o "
"atual seja atingida."

#: ../../library/pdb.rst:564
msgid ""
"With *lineno*, continue execution until a line with a number greater or "
"equal to *lineno* is reached.  In both cases, also stop when the current "
"frame returns."
msgstr ""
"Com *lineno*, continua a execução até que uma linha com um número maior ou "
"igual a *lineno* ser alcançada. Nos dois casos, também interrompe quando o "
"quadro atual retornar."

#: ../../library/pdb.rst:568
msgid "Allow giving an explicit line number."
msgstr "Permite fornecer um número de linha explícito."

#: ../../library/pdb.rst:573
msgid "Continue execution until the current function returns."
msgstr "Continua a execução até que a função atual retorne."

#: ../../library/pdb.rst:577
msgid "Continue execution, only stop when a breakpoint is encountered."
msgstr ""
"Continua a execução, interrompe apenas quando um ponto de interrupção for "
"encontrado."

#: ../../library/pdb.rst:581
msgid ""
"Set the next line that will be executed.  Only available in the bottom-most "
"frame.  This lets you jump back and execute code again, or jump forward to "
"skip code that you don't want to run."
msgstr ""
"Define a próxima linha que será executada. Disponível apenas no quadro mais "
"inferior. Isso permite voltar e executar o código novamente ou avançar para "
"pular o código que você não deseja executar."

#: ../../library/pdb.rst:585
msgid ""
"It should be noted that not all jumps are allowed -- for instance it is not "
"possible to jump into the middle of a :keyword:`for` loop or out of a :"
"keyword:`finally` clause."
msgstr ""
"Deve-se notar que nem todos os saltos são permitidos -- por exemplo, não é "
"possível pular para o meio de um loop de :keyword:`for` ou sair de uma "
"cláusula :keyword:`finally`."

#: ../../library/pdb.rst:591
msgid ""
"List source code for the current file.  Without arguments, list 11 lines "
"around the current line or continue the previous listing.  With ``.`` as "
"argument, list 11 lines around the current line.  With one argument, list 11 "
"lines around at that line.  With two arguments, list the given range; if the "
"second argument is less than the first, it is interpreted as a count."
msgstr ""
"Lista o código-fonte do arquivo atual. Sem argumentos, lista 11 linhas ao "
"redor da linha atual ou continue a listagem anterior. Com ``.`` como "
"argumento, lista 11 linhas ao redor da linha atual. Com um argumento, lista "
"11 linhas nessa linha. Com dois argumentos, lista o intervalo especificado; "
"se o segundo argumento for menor que o primeiro, ele será interpretado como "
"uma contagem."

#: ../../library/pdb.rst:597
msgid ""
"The current line in the current frame is indicated by ``->``.  If an "
"exception is being debugged, the line where the exception was originally "
"raised or propagated is indicated by ``>>``, if it differs from the current "
"line."
msgstr ""
"A linha atual no quadro atual é indicada por ``->``. Se uma exceção estiver "
"sendo depurada, a linha em que a exceção foi originalmente gerada ou "
"propagada é indicada por ``>>``, se for diferente da linha atual."

#: ../../library/pdb.rst:602
msgid "Added the ``>>`` marker."
msgstr "Adicionado o marcador ``>>``."

#: ../../library/pdb.rst:607
msgid ""
"List all source code for the current function or frame.  Interesting lines "
"are marked as for :pdbcmd:`list`."
msgstr ""
"Lista todo o código-fonte da função ou quadro atual. As linhas interessantes "
"estão marcadas como para :pdbcmd:`list`."

#: ../../library/pdb.rst:614
msgid "Print the arguments of the current function and their current values."
msgstr "Imprime os argumentos da função atual e seus valores atuais."

#: ../../library/pdb.rst:618
msgid "Evaluate *expression* in the current context and print its value."
msgstr "Avalia *expression* no contexto atual e imprima seu valor."

#: ../../library/pdb.rst:622
msgid ""
"``print()`` can also be used, but is not a debugger command --- this "
"executes the Python :func:`print` function."
msgstr ""
"``print()`` também pode ser usado, mas não é um comando de depuração --- "
"isso executa a função Python :func:`print`."

#: ../../library/pdb.rst:628
msgid ""
"Like the :pdbcmd:`p` command, except the value of *expression* is pretty-"
"printed using the :mod:`pprint` module."
msgstr ""
"Como o comando :pdbcmd:`p`, exceto que o valor de *expression* é bastante "
"impresso usando o módulo :mod:`pprint`."

#: ../../library/pdb.rst:633
msgid "Print the type of *expression*."
msgstr "Exibe o tipo de *expression*."

#: ../../library/pdb.rst:637
msgid "Try to get source code of *expression* and display it."
msgstr "Tenta obter o código-fonte de *expression* e exibe-o."

#: ../../library/pdb.rst:643
msgid ""
"Display the value of *expression* if it changed, each time execution stops "
"in the current frame."
msgstr ""
"Exibe o valor de *expression* caso ela tenha sido alterada, sempre que a "
"execução for interrompida no quadro atual."

#: ../../library/pdb.rst:646
msgid ""
"Without *expression*, list all display expressions for the current frame."
msgstr ""
"Sem *expression*, lista todas as expressões de exibição para o quadro atual."

#: ../../library/pdb.rst:650
msgid ""
"Display evaluates *expression* and compares to the result of the previous "
"evaluation of *expression*, so when the result is mutable, display may not "
"be able to pick up the changes."
msgstr ""
"Display avalia *expression* e compara com o resultado da avaliação anterior "
"de *expression*, portanto, quando o resultado é mutável, display pode não "
"ser capaz de captar as alterações."

#: ../../library/pdb.rst:654 ../../library/pdb.rst:819
msgid "Example::"
msgstr "Exemplo::"

#: ../../library/pdb.rst:656
msgid ""
"lst = []\n"
"breakpoint()\n"
"pass\n"
"lst.append(1)\n"
"print(lst)"
msgstr ""
"lst = []\n"
"breakpoint()\n"
"pass\n"
"lst.append(1)\n"
"print(lst)"

#: ../../library/pdb.rst:662
msgid ""
"Display won't realize ``lst`` has been changed because the result of "
"evaluation is modified in place by ``lst.append(1)`` before being compared::"
msgstr ""
"Display não perceberá que ``lst`` foi alterado porque o resultado da "
"avaliação foi modificado internamente por ``lst.append(1)`` antes de ser "
"comparado::"

#: ../../library/pdb.rst:665
msgid ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst\n"
"display lst: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"(Pdb)"
msgstr ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst\n"
"display lst: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"(Pdb)"

#: ../../library/pdb.rst:677
msgid "You can do some tricks with copy mechanism to make it work::"
msgstr ""
"Você pode fazer alguns truques com o mecanismo de cópia para fazê-lo "
"funcionar::"

#: ../../library/pdb.rst:679
msgid ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst[:]\n"
"display lst[:]: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"display lst[:]: [1]  [old: []]\n"
"(Pdb)"
msgstr ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst[:]\n"
"display lst[:]: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"display lst[:]: [1]  [old: []]\n"
"(Pdb)"

#: ../../library/pdb.rst:696
msgid ""
"Do not display *expression* anymore in the current frame.  Without "
"*expression*, clear all display expressions for the current frame."
msgstr ""
"Não exibe mais *expression* no quadro atual. Sem expressão, limpa todas as "
"expressões de exibição para o quadro atual."

#: ../../library/pdb.rst:703
msgid ""
"Start an interactive interpreter (using the :mod:`code` module) in a new "
"global namespace initialised from the local and global namespaces for the "
"current scope. Use ``exit()`` or ``quit()`` to exit the interpreter and "
"return to the debugger."
msgstr ""
"Inicia um interpretador interativo (usando o módulo :mod:`code`) em um novo "
"espaço de nomes global inicializado a partir dos espaços de nomes locais e "
"globais para o escopo atual. Use ``exit()`` ou ``quit()`` para sair do "
"interpretador e retornar ao depurador."

#: ../../library/pdb.rst:710
msgid ""
"As ``interact`` creates a new dedicated namespace for code execution, "
"assignments to variables will not affect the original namespaces. However, "
"modifications to any referenced mutable objects will be reflected in the "
"original namespaces as usual."
msgstr ""
"Como ``interact`` cria um novo espaço de nomes dedicado para execução de "
"código, atribuições a variáveis não afetarão os espaços de nomes originais. "
"No entanto, as modificações em quaisquer objetos mutáveis referenciados "
"serão refletidas nos espaços de nomes originais, como de costume."

#: ../../library/pdb.rst:717
msgid ""
"``exit()`` and ``quit()`` can be used to exit the :pdbcmd:`interact` command."
msgstr ""
"``exit()`` e ``quit()`` podem ser usados para sair do comando :pdbcmd:"
"`interact`."

#: ../../library/pdb.rst:721
msgid ""
":pdbcmd:`interact` directs its output to the debugger's output channel "
"rather than :data:`sys.stderr`."
msgstr ""
":pdbcmd:`interact` direciona sua saída para o canal de saída do depurador em "
"vez de :data:`sys.stderr`."

#: ../../library/pdb.rst:729
msgid ""
"Create an alias called *name* that executes *command*.  The *command* must "
"*not* be enclosed in quotes.  Replaceable parameters can be indicated by "
"``%1``, ``%2``, ... and ``%9``, while ``%*`` is replaced by all the "
"parameters. If *command* is omitted, the current alias for *name* is shown. "
"If no arguments are given, all aliases are listed."
msgstr ""
"Cria um apelido chamado *name* que executa *command*. O comando *command* "
"*não* deve ser colocado entre aspas. Parâmetros substituíveis podem ser "
"indicados por ``%1``, ``%2``, ... e ``%9``, enquanto ``%*`` é substituído "
"por todos os parâmetros. Se *command* for omitido, o apelido atual para "
"*name* será mostrado. Se nenhum argumento for fornecido, todos os apelidos "
"serão listados."

#: ../../library/pdb.rst:735
msgid ""
"Aliases may be nested and can contain anything that can be legally typed at "
"the pdb prompt.  Note that internal pdb commands *can* be overridden by "
"aliases.  Such a command is then hidden until the alias is removed.  "
"Aliasing is recursively applied to the first word of the command line; all "
"other words in the line are left alone."
msgstr ""
"Os aliases podem ser aninhados e podem conter qualquer coisa que possa ser "
"digitada legalmente no prompt do pdb. Observe que os comandos internos do "
"pdb *podem* ser substituídos por aliases. Esse comando é oculto até que o "
"alias seja removido. O alias é aplicado recursivamente à primeira palavra da "
"linha de comando; todas as outras palavras da linha são deixadas em paz."

#: ../../library/pdb.rst:741
msgid ""
"As an example, here are two useful aliases (especially when placed in the :"
"file:`.pdbrc` file)::"
msgstr ""
"Como exemplo, aqui estão dois aliases úteis (especialmente quando colocados "
"no arquivo :file:`.pdbrc`)::"

#: ../../library/pdb.rst:744
msgid ""
"# Print instance variables (usage \"pi classInst\")\n"
"alias pi for k in %1.__dict__.keys(): print(f\"%1.{k} = {%1.__dict__[k]}\")\n"
"# Print instance variables in self\n"
"alias ps pi self"
msgstr ""
"# Exibe variáveis de instância (use em \"pi classInst\")\n"
"alias pi for k in %1.__dict__.keys(): print(f\"%1.{k} = {%1.__dict__[k]}\")\n"
"# Exibe variáveis de instância em self\n"
"alias ps pi self"

#: ../../library/pdb.rst:751
msgid "Delete the specified alias *name*."
msgstr "Executa o alias *name* especificado."

#: ../../library/pdb.rst:755
msgid ""
"Execute the (one-line) *statement* in the context of the current stack "
"frame. The exclamation point can be omitted unless the first word of the "
"statement resembles a debugger command, e.g.:"
msgstr ""
"Executa a instrução *statement* (de uma só linha) no contexto do quadro de "
"pilha atual. O ponto de exclamação pode ser omitido, a menos que a primeira "
"palavra da instrução seja semelhante a um comando de depuração, por exemplo:"

#: ../../library/pdb.rst:759
msgid ""
"(Pdb) ! n=42\n"
"(Pdb)"
msgstr ""
"(Pdb) ! n=42\n"
"(Pdb)"

#: ../../library/pdb.rst:764
msgid ""
"To set a global variable, you can prefix the assignment command with a :"
"keyword:`global` statement on the same line, e.g.:"
msgstr ""
"Para definir uma variável global, você pode prefixar o comando de atribuição "
"com uma instrução :keyword:`global` na mesma linha, por exemplo:"

#: ../../library/pdb.rst:767
msgid ""
"(Pdb) global list_options; list_options = ['-l']\n"
"(Pdb)"
msgstr ""
"(Pdb) global list_options; list_options = ['-l']\n"
"(Pdb)"

#: ../../library/pdb.rst:775
msgid ""
"Restart the debugged Python program.  If *args* is supplied, it is split "
"with :mod:`shlex` and the result is used as the new :data:`sys.argv`. "
"History, breakpoints, actions and debugger options are preserved. :pdbcmd:"
"`restart` is an alias for :pdbcmd:`run`."
msgstr ""
"Reinicia o programa Python depurado. Se *args* for fornecido, ele é dividido "
"com :mod:`shlex` e o resultado é usado como o novo :data:`sys.argv`. "
"Histórico, pontos de interrupção, ações e opções do depurador são "
"preservados. :pdbcmd:`restart` é um apelido para :pdbcmd:`run`."

#: ../../library/pdb.rst:780
msgid ""
":pdbcmd:`run` and :pdbcmd:`restart` commands are disabled when the debugger "
"is invoked in ``'inline'`` mode."
msgstr ""
"Os comandos :pdbcmd:`run` e :pdbcmd:`restart` são desabilitados quando o "
"depurador é invocado no modo ``'inline'``."

#: ../../library/pdb.rst:786
msgid ""
"Quit from the debugger.  The program being executed is aborted. An end-of-"
"file input is equivalent to :pdbcmd:`quit`."
msgstr ""
"Sai do depurador. O programa que está sendo executado é abortado. Uma "
"entrada com fim de arquivo equivale a :pdbcmd:`quit`."

#: ../../library/pdb.rst:789
msgid ""
"A confirmation prompt will be shown if the debugger is invoked in "
"``'inline'`` mode. Either ``y``, ``Y``, ``<Enter>`` or ``EOF`` will confirm "
"the quit."
msgstr ""
"Um prompt de confirmação será exibido se o depurador for invocado no modo "
"``'inline'``. ``y``, ``Y``, ``<Enter>`` ou ``EOF`` confirmarão o "
"encerramento."

#: ../../library/pdb.rst:793
msgid ""
"A confirmation prompt will be shown if the debugger is invoked in "
"``'inline'`` mode. After the confirmation, the debugger will call :func:`sys."
"exit` immediately, instead of raising :exc:`bdb.BdbQuit` in the next trace "
"event."
msgstr ""
"Um prompt de confirmação será exibido se o depurador for invocado no modo "
"``'inline'``. Após a confirmação, o depurador chamará :func:`sys.exit` "
"imediatamente, em vez de levantar :exc:`bdb.BdbQuit` no próximo evento de "
"rastreamento."

#: ../../library/pdb.rst:801
msgid ""
"Enter a recursive debugger that steps through *code* (which is an arbitrary "
"expression or statement to be executed in the current environment)."
msgstr ""
"Entra em um depurador recursivo que percorre *code* (que é uma expressão ou "
"instrução arbitrária a ser executada no ambiente atual)."

#: ../../library/pdb.rst:807
msgid "Print the return value for the last return of the current function."
msgstr "Exibe o valor de retorno para o último retorno de a função atual."

#: ../../library/pdb.rst:811
msgid "List or jump between chained exceptions."
msgstr "Lista ou salta entre exceções encadeadas."

#: ../../library/pdb.rst:813
msgid ""
"When using ``pdb.pm()``  or ``Pdb.post_mortem(...)`` with a chained "
"exception instead of a traceback, it allows the user to move between the "
"chained exceptions using ``exceptions`` command to list exceptions, and "
"``exceptions <number>`` to switch to that exception."
msgstr ""
"Ao usar ``pdb.pm()`` ou ``Pdb.post_mortem(...)`` com uma exceção encadeada "
"em vez de um traceback, permite ao usuário mover entre as exceções "
"encadeadas usando o comando ``exceptions`` para listar exceções e "
"``exceptions <número>`` para mudar para essa exceção."

#: ../../library/pdb.rst:821
msgid ""
"def out():\n"
"    try:\n"
"        middle()\n"
"    except Exception as e:\n"
"        raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"def middle():\n"
"    try:\n"
"        return inner(0)\n"
"    except Exception as e:\n"
"        raise ValueError(\"Middle fail\")\n"
"\n"
"def inner(x):\n"
"    1 / x\n"
"\n"
" out()"
msgstr ""
"def out():\n"
"    try:\n"
"        middle()\n"
"    except Exception as e:\n"
"        raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"def middle():\n"
"    try:\n"
"        return inner(0)\n"
"    except Exception as e:\n"
"        raise ValueError(\"Middle fail\")\n"
"\n"
"def inner(x):\n"
"    1 / x\n"
"\n"
" out()"

#: ../../library/pdb.rst:838
msgid "calling ``pdb.pm()`` will allow to move between exceptions::"
msgstr "chamar ``pdb.pm()`` permitirá mover entre exceções::"

#: ../../library/pdb.rst:840
msgid ""
"> example.py(5)out()\n"
"-> raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"(Pdb) exceptions\n"
"  0 ZeroDivisionError('division by zero')\n"
"  1 ValueError('Middle fail')\n"
"> 2 ValueError('reraise middle() error')\n"
"\n"
"(Pdb) exceptions 0\n"
"> example.py(16)inner()\n"
"-> 1 / x\n"
"\n"
"(Pdb) up\n"
"> example.py(10)middle()\n"
"-> return inner(0)"
msgstr ""
"> example.py(5)out()\n"
"-> raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"(Pdb) exceptions\n"
"  0 ZeroDivisionError('division by zero')\n"
"  1 ValueError('Middle fail')\n"
"> 2 ValueError('reraise middle() error')\n"
"\n"
"(Pdb) exceptions 0\n"
"> example.py(16)inner()\n"
"-> 1 / x\n"
"\n"
"(Pdb) up\n"
"> example.py(10)middle()\n"
"-> return inner(0)"

#: ../../library/pdb.rst:859
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../library/pdb.rst:860
msgid ""
"Whether a frame is considered to originate in a certain module is determined "
"by the ``__name__`` in the frame globals."
msgstr ""
"Se um quadro é considerado originário de um determinado módulo é determinado "
"pelo ``__name__`` nos globais do quadro."

#: ../../library/pdb.rst:11
msgid "debugging"
msgstr "depuração"

#: ../../library/pdb.rst:21
msgid "Pdb (class in pdb)"
msgstr "Pdb (classe no pdb)"

#: ../../library/pdb.rst:21
msgid "module"
msgstr "módulo"

#: ../../library/pdb.rst:21
msgid "bdb"
msgstr "bdb"

#: ../../library/pdb.rst:21
msgid "cmd"
msgstr "cmd"

#: ../../library/pdb.rst:400
msgid ".pdbrc"
msgstr ".pdbrc"

#: ../../library/pdb.rst:400
msgid "file"
msgstr "arquivo"

#: ../../library/pdb.rst:400
msgid "debugger"
msgstr "depurador"

#: ../../library/pdb.rst:400
msgid "configuration"
msgstr "configuração"

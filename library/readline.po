# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# And Past <andrepgs@gmail.com>, 2021
# i17obot <i17obot@rougeth.com>, 2021
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-30 14:22+0000\n"
"PO-Revision-Date: 2021-06-28 01:12+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/readline.rst:2
msgid ":mod:`!readline` --- GNU readline interface"
msgstr ":mod:`!readline` --- Interface para o GNU readline"

#: ../../library/readline.rst:12
msgid ""
"The :mod:`readline` module defines a number of functions to facilitate "
"completion and reading/writing of history files from the Python interpreter. "
"This module can be used directly, or via the :mod:`rlcompleter` module, "
"which supports completion of Python identifiers at the interactive prompt.  "
"Settings made using  this module affect the behaviour of both the "
"interpreter's interactive prompt  and the prompts offered by the built-in :"
"func:`input` function."
msgstr ""
"O módulo :mod:`readline` define uma série de funções para facilitar o "
"autocomplemento e leitura/gravação de arquivos históricos do interpretador "
"Python. Este módulo pode ser usado diretamente ou através do módulo :mod:"
"`rlcompleter`, que provê o autocomplemento de identificadores Python no "
"prompt interativo. As configurações feitas usando este módulo afetam o "
"comportamento do prompt interativo do interpretador e dos prompts oferecidos "
"pela função embutida :func:`input`."

#: ../../library/readline.rst:20
msgid ""
"Readline keybindings may be configured via an initialization file, typically "
"``.inputrc`` in your home directory.  See `Readline Init File <https://"
"tiswww.cwru.edu/php/chet/readline/rluserman.html#Readline-Init-File>`_ in "
"the GNU Readline manual for information about the format and allowable "
"constructs of that file, and the capabilities of the Readline library in "
"general."
msgstr ""
"As combinações de teclas do Readline podem ser configuradas através de um "
"arquivo de inicialização, normalmente ``.inputrc`` em seu diretório inicial. "
"Consulte `Readline Init File <https://tiswww.cwru.edu/php/chet/readline/"
"rluserman.html#Readline-Init-File>`_ no manual do GNU Readline para obter "
"informações sobre o formato e construções permitidas desse arquivo e os "
"recursos da biblioteca do Readline em geral."

#: ../../includes/wasm-mobile-notavail.rst:3
msgid "Availability"
msgstr "Disponibilidade"

#: ../../includes/wasm-mobile-notavail.rst:5
msgid ""
"This module is not supported on :ref:`mobile platforms <mobile-"
"availability>` or :ref:`WebAssembly platforms <wasm-availability>`."
msgstr ""
"Este módulo não tem suporte em :ref:`plataformas móveis <mobile-"
"availability>` ou :ref:`plataformas WebAssembly <wasm-availability>`."

#: ../../library/readline.rst:31
msgid ""
"The underlying Readline library API may be implemented by the ``editline`` "
"(``libedit``) library instead of GNU readline. On macOS the :mod:`readline` "
"module detects which library is being used at run time."
msgstr ""
"A API da biblioteca subjacente do Readline pode ser implementada pela "
"biblioteca ``editline`` (``libedit``) em vez do GNU readline. No macOS, o "
"módulo :mod:`readline` detecta qual biblioteca está sendo usada em tempo de "
"execução."

#: ../../library/readline.rst:36
msgid ""
"The configuration file for ``editline`` is different from that of GNU "
"readline. If you programmatically load configuration strings you can use :"
"data:`backend` to determine which library is being used."
msgstr ""
"O arquivo de configuração do ``editline`` é diferente daquele do GNU "
"readline. Se você carregar strings de configuração programaticamente, você "
"pode usar :data:`backend` para determinar qual biblioteca está sendo usada."

#: ../../library/readline.rst:40
msgid ""
"If you use ``editline``/``libedit`` readline emulation on macOS, the "
"initialization file located in your home directory is named ``.editrc``. For "
"example, the following content in ``~/.editrc`` will turn ON *vi* "
"keybindings and TAB completion::"
msgstr ""
"Se você usar a emulação de readline do ``editline``/``libedit`` no macOS, o "
"arquivo de inicialização localizado em seu diretório inicial será denominado "
"``.editrc``. Por exemplo, o seguinte conteúdo em ``~/.editrc`` ativará os "
"atalhos de teclado *vi* e o autocomplemento de TAB::"

#: ../../library/readline.rst:45
msgid ""
"python:bind -v\n"
"python:bind ^I rl_complete"
msgstr ""
"python:bind -v\n"
"python:bind ^I rl_complete"

#: ../../library/readline.rst:48
msgid ""
"Also note that different libraries may use different history file formats. "
"When switching the underlying library, existing history files may become "
"unusable."
msgstr ""
"Observe também que bibliotecas diferentes podem usar formatos de arquivo de "
"histórico diferentes. Ao alternar a biblioteca subjacente, os arquivos de "
"histórico existentes podem se tornar inutilizáveis."

#: ../../library/readline.rst:54
msgid ""
"The name of the underlying Readline library being used, either "
"``\"readline\"`` or ``\"editline\"``."
msgstr ""
"O nome da biblioteca Readline subjacente que está sendo usada, seja "
"``\"readline\"`` ou ``\"editline\"``."

#: ../../library/readline.rst:60
msgid "Init file"
msgstr "Arquivo init"

#: ../../library/readline.rst:62
msgid "The following functions relate to the init file and user configuration:"
msgstr ""
"As seguintes funções estão relacionadas ao arquivo init e à configuração do "
"usuário:"

#: ../../library/readline.rst:67
msgid ""
"Execute the init line provided in the *string* argument. This calls :c:func:"
"`!rl_parse_and_bind` in the underlying library."
msgstr ""
"Executa a linha de init fornecida no argumento *string*. Isso chama :c:func:"
"`!rl_parse_and_bind` na biblioteca subjacente."

#: ../../library/readline.rst:73
msgid ""
"Execute a readline initialization file. The default filename is the last "
"filename used. This calls :c:func:`!rl_read_init_file` in the underlying "
"library. It raises an :ref:`auditing event <auditing>` ``open`` with the "
"file name if given, and :code:`\"<readline_init_file>\"` otherwise, "
"regardless of which file the library resolves."
msgstr ""
"Executa um arquivo de inicialização readline. O nome de arquivo padrão é o "
"último usado. Isso chama :c:func:`!rl_read_init_file` na biblioteca "
"subjacente. Ele levanta um :ref:`evento de auditoria <auditing>` ``open`` "
"com o nome do arquivo, se fornecido, e :code:`\"<readline_init_file>\"` caso "
"contrário, independentemente de qual arquivo a biblioteca resolve."

#: ../../library/readline.rst:79 ../../library/readline.rst:122
#: ../../library/readline.rst:134 ../../library/readline.rst:149
msgid "The auditing event was added."
msgstr "O evento de auditoria foi adicionado."

#: ../../library/readline.rst:84
msgid "Line buffer"
msgstr "Buffer de linha"

#: ../../library/readline.rst:86
msgid "The following functions operate on the line buffer:"
msgstr "As seguintes funções operam no buffer de linha:"

#: ../../library/readline.rst:91
msgid ""
"Return the current contents of the line buffer (:c:data:`!rl_line_buffer` in "
"the underlying library)."
msgstr ""
"Retorna o conteúdo atual do buffer de linha (:c:data:`!rl_line_buffer` na "
"biblioteca subjacente)."

#: ../../library/readline.rst:97
msgid ""
"Insert text into the line buffer at the cursor position.  This calls :c:func:"
"`!rl_insert_text` in the underlying library, but ignores the return value."
msgstr ""
"Insere texto no buffer de linha na posição do cursor. Isso chama :c:func:`!"
"rl_insert_text` na biblioteca subjacente, mas ignora o valor de retorno."

#: ../../library/readline.rst:104
msgid ""
"Change what's displayed on the screen to reflect the current contents of the "
"line buffer.  This calls :c:func:`!rl_redisplay` in the underlying library."
msgstr ""
"Altera o que é exibido na tela para refletir o conteúdo atual do buffer de "
"linha. Isso chama :c:func:`!rl_redisplay` na biblioteca subjacente."

#: ../../library/readline.rst:109
msgid "History file"
msgstr "Arquivo de histórico"

#: ../../library/readline.rst:111
msgid "The following functions operate on a history file:"
msgstr "As seguintes funções operam em um arquivo histórico:"

#: ../../library/readline.rst:116
msgid ""
"Load a readline history file, and append it to the history list. The default "
"filename is :file:`~/.history`.  This calls :c:func:`!read_history` in the "
"underlying library and raises an :ref:`auditing event <auditing>` ``open`` "
"with the file name if given and :code:`\"~/.history\"` otherwise."
msgstr ""
"Carrega um arquivo de histórico do readline e anexa-o à lista de histórico. "
"O nome do arquivo padrão é :file:`~/.history`. Isso chama :c:func:`!"
"read_history` na biblioteca subjacente e levanta um :ref:`evento de "
"auditoria <auditing>` ``open`` com o nome de arquivo se dado e, do "
"contrário, :code:`\"~/.history\"`."

#: ../../library/readline.rst:128
msgid ""
"Save the history list to a readline history file, overwriting any existing "
"file.  The default filename is :file:`~/.history`.  This calls :c:func:`!"
"write_history` in the underlying library and raises an :ref:`auditing event "
"<auditing>` ``open`` with the file name if given and :code:`\"~/.history\"` "
"otherwise."
msgstr ""
"Salva a lista de histórico para um arquivo de histórico do readline, "
"sobrescrevendo qualquer arquivo existente. O nome do arquivo padrão é :file:"
"`~/.history`. Isso chama :c:func:`!write_history` na biblioteca subjacente e "
"levanta um :ref:`evento de auditoria <auditing>` ``open`` com o nome de "
"arquivo se dado e, do contrário, :code:`\"~/.history\"`."

#: ../../library/readline.rst:140
msgid ""
"Append the last *nelements* items of history to a file.  The default "
"filename is :file:`~/.history`.  The file must already exist.  This calls :c:"
"func:`!append_history` in the underlying library.  This function only exists "
"if Python was compiled for a version of the library that supports it. It "
"raises an :ref:`auditing event <auditing>` ``open`` with the file name if "
"given and :code:`\"~/.history\"` otherwise."
msgstr ""
"Anexa os últimos *nelements* itens do histórico a um arquivo. O nome do "
"arquivo padrão é :file:`~/.history`. O arquivo já deve existir. Isso chama :"
"c:func:`!append_history` na biblioteca subjacente. Esta função só existe se "
"o Python foi compilado para uma versão da biblioteca que a suporta. Ela "
"levanta um :ref:`evento de auditoria <auditing>` ``open`` com o nome de "
"arquivo se dado e, do contrário, :code:`\"~/.history\"`."

#: ../../library/readline.rst:156
msgid ""
"Set or return the desired number of lines to save in the history file. The :"
"func:`write_history_file` function uses this value to truncate the history "
"file, by calling :c:func:`!history_truncate_file` in the underlying "
"library.  Negative values imply unlimited history file size."
msgstr ""
"Define ou retorna o número desejado de linhas para salvar no arquivo de "
"histórico. A função :func:`write_history_file` usa este valor para truncar o "
"arquivo de histórico, chamando :c:func:`!history_truncate_file` na "
"biblioteca subjacente. Valores negativos implicam tamanho ilimitado do "
"arquivo de histórico."

#: ../../library/readline.rst:164
msgid "History list"
msgstr "Lista de histórico"

#: ../../library/readline.rst:166
msgid "The following functions operate on a global history list:"
msgstr "As seguintes funções operam em uma lista de histórico global:"

#: ../../library/readline.rst:171
msgid ""
"Clear the current history.  This calls :c:func:`!clear_history` in the "
"underlying library.  The Python function only exists if Python was compiled "
"for a version of the library that supports it."
msgstr ""
"Limpa o histórico atual. Isso chama :c:func:`!clear_history` na biblioteca "
"subjacente. A função Python só existe se o Python foi compilado para uma "
"versão da biblioteca que a suporta."

#: ../../library/readline.rst:178
msgid ""
"Return the number of items currently in the history.  (This is different "
"from :func:`get_history_length`, which returns the maximum number of lines "
"that will be written to a history file.)"
msgstr ""
"Retorna o número de itens atualmente no histórico. (Isso é diferente de :"
"func:`get_history_length`, que retorna o número máximo de linhas que serão "
"gravadas em um arquivo de histórico.)"

#: ../../library/readline.rst:185
msgid ""
"Return the current contents of history item at *index*.  The item index is "
"one-based.  This calls :c:func:`!history_get` in the underlying library."
msgstr ""
"Retorna o conteúdo atual do item do histórico em *index*. O índice do item é "
"baseado em um. Isso chama :c:func:`!history_get` na biblioteca subjacente."

#: ../../library/readline.rst:191
msgid ""
"Remove history item specified by its position from the history. The position "
"is zero-based.  This calls :c:func:`!remove_history` in the underlying "
"library."
msgstr ""
"Remove o item de histórico especificado por sua posição do histórico. A "
"posição conta a partir de zero. Isso chama :c:func:`!remove_history` na "
"biblioteca subjacente."

#: ../../library/readline.rst:198
msgid ""
"Replace history item specified by its position with *line*. The position is "
"zero-based.  This calls :c:func:`!replace_history_entry` in the underlying "
"library."
msgstr ""
"Substitui o item de histórico especificado pela sua posição por *linha*. A "
"posição conta a partir do zero. Isso chama :c:func:`!replace_history_entry` "
"na biblioteca subjacente."

#: ../../library/readline.rst:205
msgid ""
"Append *line* to the history buffer, as if it was the last line typed. This "
"calls :c:func:`!add_history` in the underlying library."
msgstr ""
"Acrescenta *line* ao buffer do histórico, como se fosse a última linha "
"digitada. Isso chama :c:func:`!add_history` na biblioteca subjacente."

#: ../../library/readline.rst:211
msgid ""
"Enable or disable automatic calls to :c:func:`!add_history` when reading "
"input via readline.  The *enabled* argument should be a Boolean value that "
"when true, enables auto history, and that when false, disables auto history."
msgstr ""
"Habilita ou desabilita chamadas automáticas para :c:func:`!add_history` ao "
"ler a entrada via readline. O argumento *enabled* deve ser um valor booleano "
"que, quando verdadeiro, ativa o histórico automático e, quando falso, "
"desativa o histórico automático."

#: ../../library/readline.rst:219
msgid ""
"Auto history is enabled by default, and changes to this do not persist "
"across multiple sessions."
msgstr ""
"O histórico automático está ativado por padrão e as alterações não persistem "
"em várias sessões."

#: ../../library/readline.rst:224
msgid "Startup hooks"
msgstr "Ganchos de inicialização"

#: ../../library/readline.rst:229
msgid ""
"Set or remove the function invoked by the :c:data:`!rl_startup_hook` "
"callback of the underlying library.  If *function* is specified, it will be "
"used as the new hook function; if omitted or ``None``, any function already "
"installed is removed.  The hook is called with no arguments just before "
"readline prints the first prompt."
msgstr ""
"Define ou remove a função invocada pelo retorno de chamada :c:data:`!"
"rl_startup_hook` da biblioteca subjacente. Se *function* for especificada, "
"ela será usada como a nova função de gancho; se omitido ou ``None``, "
"qualquer função já instalada será removida. O gancho é chamado sem "
"argumentos antes de readline imprimir o primeiro prompt."

#: ../../library/readline.rst:238
msgid ""
"Set or remove the function invoked by the :c:data:`!rl_pre_input_hook` "
"callback of the underlying library.  If *function* is specified, it will be "
"used as the new hook function; if omitted or ``None``, any function already "
"installed is removed.  The hook is called with no arguments after the first "
"prompt has been printed and just before readline starts reading input "
"characters.  This function only exists if Python was compiled for a version "
"of the library that supports it."
msgstr ""
"Define ou remove a função invocada pelo retorno de chamada :c:data:`!"
"rl_pre_input_hook` da biblioteca subjacente. Se *function* for especificada, "
"ela será usada como a nova função de gancho; se omitida ou ``None``, "
"qualquer função já instalada será removida. O gancho é chamado sem "
"argumentos após a impressão do primeiro prompt e pouco antes de readline "
"começar a ler os caracteres de entrada. Esta função só existe se o Python "
"foi compilado para uma versão da biblioteca que a suporta."

#: ../../library/readline.rst:250
msgid "Completion"
msgstr "Autocomplemento"

#: ../../library/readline.rst:252
msgid ""
"The following functions relate to implementing a custom word completion "
"function.  This is typically operated by the Tab key, and can suggest and "
"automatically complete a word being typed.  By default, Readline is set up "
"to be used by :mod:`rlcompleter` to complete Python identifiers for the "
"interactive interpreter.  If the :mod:`readline` module is to be used with a "
"custom completer, a different set of word delimiters should be set."
msgstr ""
"As funções a seguir estão relacionadas à implementação de uma função "
"personalizada de autocomplemento ou *completion*, em inglês, de palavras. "
"Isso normalmente é operado pela tecla Tab e pode sugerir e completar "
"automaticamente uma palavra que está sendo digitada. Por padrão, Readline "
"está configurado para ser usado por :mod:`rlcompleter` para completar "
"identificadores Python para o interpretador interativo. Se o módulo :mod:"
"`readline` for usado com um autocomplemento personalizado, um conjunto "
"diferente de delimitadores de palavras deverá ser definido."

#: ../../library/readline.rst:262
msgid ""
"Set or remove the completer function.  If *function* is specified, it will "
"be used as the new completer function; if omitted or ``None``, any completer "
"function already installed is removed.  The completer function is called as "
"``function(text, state)``, for *state* in ``0``, ``1``, ``2``, ..., until it "
"returns a non-string value.  It should return the next possible completion "
"starting with *text*."
msgstr ""
"Define ou remove a função de autocomplemento. Se *function* for "
"especificada, ela será usada como a nova função de autocomplemento; se "
"omitido ou ``None``, qualquer função de autocomplemento já instalada será "
"removida. A função de autocomplemento é chamada como ``function(text, "
"state)``, para *state* em ``0``, ``1``, ``2``, ..., até retornar um valor "
"que não seja string. Deve retornar o próximo autocomplemento possível "
"começando com *text*."

#: ../../library/readline.rst:269
msgid ""
"The installed completer function is invoked by the *entry_func* callback "
"passed to :c:func:`!rl_completion_matches` in the underlying library. The "
"*text* string comes from the first parameter to the :c:data:`!"
"rl_attempted_completion_function` callback of the underlying library."
msgstr ""
"A função de autocomplemento instalada é invocada pelo retorno de chamada "
"*entry_func* passado para :c:func:`!rl_completion_matches` na biblioteca "
"subjacente. A string *text* vem do primeiro parâmetro para o retorno de "
"chamada :c:data:`!rl_attempted_completion_function` da biblioteca subjacente."

#: ../../library/readline.rst:278
msgid ""
"Get the completer function, or ``None`` if no completer function has been "
"set."
msgstr ""
"Obtém a função de autocomplemento ou ``None`` se nenhuma função de "
"autocomplemento tiver sido definida."

#: ../../library/readline.rst:283
msgid ""
"Get the type of completion being attempted.  This returns the :c:data:`!"
"rl_completion_type` variable in the underlying library as an integer."
msgstr ""
"Obtém o tipo de autocomplemento que está sendo tentado. Isso retorna a "
"variável :c:data:`!rl_completion_type` na biblioteca subjacente como um "
"número inteiro."

#: ../../library/readline.rst:291
msgid ""
"Get the beginning or ending index of the completion scope. These indexes are "
"the *start* and *end* arguments passed to the :c:data:`!"
"rl_attempted_completion_function` callback of the underlying library.  The "
"values may be different in the same input editing scenario based on the "
"underlying C readline implementation. Ex: libedit is known to behave "
"differently than libreadline."
msgstr ""
"Obtém o índice inicial ou final do escopo de autocomplemento. Esses índices "
"são os argumentos *start* e *end* passados para o retorno de chamada :c:data:"
"`!rl_attempted_completion_function` da biblioteca subjacente. Os valores "
"podem ser diferentes no mesmo cenário de edição de entrada com base na "
"implementação de C readline subjacente. Por exemplo, sabe-se que o libedit "
"se comporta de maneira diferente do libreadline."

#: ../../library/readline.rst:302
msgid ""
"Set or get the word delimiters for completion.  These determine the start of "
"the word to be considered for completion (the completion scope). These "
"functions access the :c:data:`!rl_completer_word_break_characters` variable "
"in the underlying library."
msgstr ""
"Define ou obtém os delimitadores de palavras para autocomplemento. Estes "
"determinam o início da palavra a ser considerada para autocomplemento (o "
"escopo de autocomplemento). Essas funções acessam a variável :c:data:`!"
"rl_completer_word_break_characters` na biblioteca subjacente."

#: ../../library/readline.rst:310
msgid ""
"Set or remove the completion display function.  If *function* is specified, "
"it will be used as the new completion display function; if omitted or "
"``None``, any completion display function already installed is removed.  "
"This sets or clears the :c:data:`!rl_completion_display_matches_hook` "
"callback in the underlying library.  The completion display function is "
"called as ``function(substitution, [matches], longest_match_length)`` once "
"each time matches need to be displayed."
msgstr ""
"Define ou remove a função de exibição de autocomplemento. Se *function* for "
"especificada, ela será usada como a nova função de exibição de "
"autocomplemento; se omitida ou ``None``, qualquer função de exibição de "
"autocomplemento já instalada será removida. Isso define ou limpa o retorno "
"de chamada :c:data:`!rl_completion_display_matches_hook` na biblioteca "
"subjacente. A função de exibição de autocomplemento é chamada como "
"``function(substitution, [matches], longest_match_length)`` uma vez que cada "
"correspondência precisa ser exibida."

#: ../../library/readline.rst:323
msgid "Example"
msgstr "Exemplo"

#: ../../library/readline.rst:325
msgid ""
"The following example demonstrates how to use the :mod:`readline` module's "
"history reading and writing functions to automatically load and save a "
"history file named :file:`.python_history` from the user's home directory.  "
"The code below would normally be executed automatically during interactive "
"sessions from the user's :envvar:`PYTHONSTARTUP` file. ::"
msgstr ""
"O exemplo a seguir demonstra como usar as funções de leitura e gravação de "
"histórico do módulo :mod:`readline` para carregar e salvar automaticamente "
"um arquivo de histórico chamado :file:`.python_history` do diretório inicial "
"do usuário. O código abaixo normalmente seria executado automaticamente "
"durante sessões interativas do arquivo :envvar:`PYTHONSTARTUP` do usuário. ::"

#: ../../library/readline.rst:331
msgid ""
"import atexit\n"
"import os\n"
"import readline\n"
"\n"
"histfile = os.path.join(os.path.expanduser(\"~\"), \".python_history\")\n"
"try:\n"
"    readline.read_history_file(histfile)\n"
"    # default history len is -1 (infinite), which may grow unruly\n"
"    readline.set_history_length(1000)\n"
"except FileNotFoundError:\n"
"    pass\n"
"\n"
"atexit.register(readline.write_history_file, histfile)"
msgstr ""
"import atexit\n"
"import os\n"
"import readline\n"
"\n"
"histfile = os.path.join(os.path.expanduser(\"~\"), \".python_history\")\n"
"try:\n"
"    readline.read_history_file(histfile)\n"
"    # comprimento padrão do histórico é -1 (infinito), que pode crescer sem "
"controle\n"
"    readline.set_history_length(1000)\n"
"except FileNotFoundError:\n"
"    pass\n"
"\n"
"atexit.register(readline.write_history_file, histfile)"

#: ../../library/readline.rst:345
msgid ""
"This code is actually automatically run when Python is run in :ref:"
"`interactive mode <tut-interactive>` (see :ref:`rlcompleter-config`)."
msgstr ""
"Na verdade, este código é executado automaticamente quando o Python é "
"executado no :ref:`modo interativo <tut-interactive>` (veja :ref:"
"`rlcompleter-config`)."

#: ../../library/readline.rst:348
msgid ""
"The following example achieves the same goal but supports concurrent "
"interactive sessions, by only appending the new history. ::"
msgstr ""
"O exemplo a seguir atinge o mesmo objetivo, mas oferece suporte a sessões "
"interativas simultâneas, anexando apenas o novo histórico. ::"

#: ../../library/readline.rst:351
msgid ""
"import atexit\n"
"import os\n"
"import readline\n"
"histfile = os.path.join(os.path.expanduser(\"~\"), \".python_history\")\n"
"\n"
"try:\n"
"    readline.read_history_file(histfile)\n"
"    h_len = readline.get_current_history_length()\n"
"except FileNotFoundError:\n"
"    open(histfile, 'wb').close()\n"
"    h_len = 0\n"
"\n"
"def save(prev_h_len, histfile):\n"
"    new_h_len = readline.get_current_history_length()\n"
"    readline.set_history_length(1000)\n"
"    readline.append_history_file(new_h_len - prev_h_len, histfile)\n"
"atexit.register(save, h_len, histfile)"
msgstr ""
"import atexit\n"
"import os\n"
"import readline\n"
"histfile = os.path.join(os.path.expanduser(\"~\"), \".python_history\")\n"
"\n"
"try:\n"
"    readline.read_history_file(histfile)\n"
"    h_len = readline.get_current_history_length()\n"
"except FileNotFoundError:\n"
"    open(histfile, 'wb').close()\n"
"    h_len = 0\n"
"\n"
"def save(prev_h_len, histfile):\n"
"    new_h_len = readline.get_current_history_length()\n"
"    readline.set_history_length(1000)\n"
"    readline.append_history_file(new_h_len - prev_h_len, histfile)\n"
"atexit.register(save, h_len, histfile)"

#: ../../library/readline.rst:369
msgid ""
"The following example extends the :class:`code.InteractiveConsole` class to "
"support history save/restore. ::"
msgstr ""
"O exemplo a seguir estende a classe :class:`code.InteractiveConsole` para "
"prover salvamento/restauração do histórico. ::"

#: ../../library/readline.rst:372
msgid ""
"import atexit\n"
"import code\n"
"import os\n"
"import readline\n"
"\n"
"class HistoryConsole(code.InteractiveConsole):\n"
"    def __init__(self, locals=None, filename=\"<console>\",\n"
"                 histfile=os.path.expanduser(\"~/.console-history\")):\n"
"        code.InteractiveConsole.__init__(self, locals, filename)\n"
"        self.init_history(histfile)\n"
"\n"
"    def init_history(self, histfile):\n"
"        readline.parse_and_bind(\"tab: complete\")\n"
"        if hasattr(readline, \"read_history_file\"):\n"
"            try:\n"
"                readline.read_history_file(histfile)\n"
"            except FileNotFoundError:\n"
"                pass\n"
"            atexit.register(self.save_history, histfile)\n"
"\n"
"    def save_history(self, histfile):\n"
"        readline.set_history_length(1000)\n"
"        readline.write_history_file(histfile)"
msgstr ""
"import atexit\n"
"import code\n"
"import os\n"
"import readline\n"
"\n"
"class HistoryConsole(code.InteractiveConsole):\n"
"    def __init__(self, locals=None, filename=\"<console>\",\n"
"                 histfile=os.path.expanduser(\"~/.console-history\")):\n"
"        code.InteractiveConsole.__init__(self, locals, filename)\n"
"        self.init_history(histfile)\n"
"\n"
"    def init_history(self, histfile):\n"
"        readline.parse_and_bind(\"tab: complete\")\n"
"        if hasattr(readline, \"read_history_file\"):\n"
"            try:\n"
"                readline.read_history_file(histfile)\n"
"            except FileNotFoundError:\n"
"                pass\n"
"            atexit.register(self.save_history, histfile)\n"
"\n"
"    def save_history(self, histfile):\n"
"        readline.set_history_length(1000)\n"
"        readline.write_history_file(histfile)"

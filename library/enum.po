# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2017
# Cauê Baasch de Souza <cauebaasch@gmail.com>, 2017
# Marco Rougeth <marco@rougeth.com>, 2020
# i17obot <i17obot@rougeth.com>, 2020
# Vitor Buxbaum Orlandi, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 17:51+0000\n"
"PO-Revision-Date: 2017-02-16 23:09+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/enum.rst:2
msgid ":mod:`enum` --- Support for enumerations"
msgstr ":mod:`enum` --- Suporte a enumerações"

#: ../../library/enum.rst:14
msgid "**Source code:** :source:`Lib/enum.py`"
msgstr "**Código-fonte:** :source:`Lib/enum.py`"

#: ../../library/enum.rst:18
msgid ""
"An enumeration is a set of symbolic names (members) bound to unique, "
"constant values.  Within an enumeration, the members can be compared by "
"identity, and the enumeration itself can be iterated over."
msgstr ""
"Uma enumeração é um conjunto de nomes simbólicos (membros) vinculados a "
"valores únicos e constantes. Dentro de uma enumeração, os membros podem ser "
"comparados por identidade, e a enumeração em si pode ser iterada."

#: ../../library/enum.rst:22
msgid "Case of Enum Members"
msgstr "Maiúsculas em membros de Enums"

#: ../../library/enum.rst:24
msgid ""
"Because Enums are used to represent constants we recommend using UPPER_CASE "
"names for enum members, and will be using that style in our examples."
msgstr ""
"Enumクラス群は定数を表現するために使われるため、列挙型のメンバーの名前には"
"UPPER_CASEを使うことを推奨します。本ページのドキュメントのサンプルでもそのス"
"タイルを採用します。"

#: ../../library/enum.rst:30
msgid "Module Contents"
msgstr "Conteúdo do módulo"

#: ../../library/enum.rst:32
msgid ""
"This module defines four enumeration classes that can be used to define "
"unique sets of names and values: :class:`Enum`, :class:`IntEnum`, :class:"
"`Flag`, and :class:`IntFlag`.  It also defines one decorator, :func:"
"`unique`, and one helper, :class:`auto`."
msgstr ""
"Este módulo define quatro classes de enumeração que podem ser usadas para "
"definir conjuntos de nomes e valores: :class:`Enum`, :class:`IntEnum`, :"
"class:`Flag`, and :class:`IntFlag`. Ele também define um decorador, :func:"
"`unique`, e um auxiliar, :class:`auto`."

#: ../../library/enum.rst:39
msgid ""
"Base class for creating enumerated constants.  See section `Functional API`_ "
"for an alternate construction syntax."
msgstr ""
"Classe base para criação de constantes enumeradas. Veja a seção `API "
"Funcional`_ para uma sintaxe alternativa de construção."

#: ../../library/enum.rst:44
msgid ""
"Base class for creating enumerated constants that are also subclasses of :"
"class:`int`."
msgstr ":class:`int` のサブクラスでもある列挙型定数を作成する基底クラスです。"

#: ../../library/enum.rst:49
msgid ""
"Base class for creating enumerated constants that can be combined using the "
"bitwise operators without losing their :class:`IntFlag` membership. :class:"
"`IntFlag` members are also subclasses of :class:`int`."
msgstr ""
"列挙型定数を作成する基底クラスで、ビット演算子を使って組み合わせられ、その結"
"果も :class:`IntFlag` メンバーになります。\n"
":class:`IntFlag` は :class:`int` のサブクラスでもあります。"

#: ../../library/enum.rst:55
msgid ""
"Base class for creating enumerated constants that can be combined using the "
"bitwise operations without losing their :class:`Flag` membership."
msgstr ""
"Classe base para criar constantes enumeradas que podem ser combinadas usando "
"operações bit a bit sem perder sua associação :class:`Flag`."

#: ../../library/enum.rst:61
msgid ""
"Enum class decorator that ensures only one name is bound to any one value."
msgstr ""
"Decorador de classe Enum que garante que apenas um nome seja vinculado a "
"cada valor."

#: ../../library/enum.rst:65
msgid ""
"Instances are replaced with an appropriate value for Enum members.  By "
"default, the initial value starts at 1."
msgstr ""
"インスタンスはそれぞれ、適切な値で置き換えられます。デフォルトでは、値は1から"
"はじまります。"

#: ../../library/enum.rst:67
msgid "``Flag``, ``IntFlag``, ``auto``"
msgstr "``Flag``, ``IntFlag``, ``auto``"

#: ../../library/enum.rst:71
msgid "Creating an Enum"
msgstr "Enum の作成"

#: ../../library/enum.rst:73
msgid ""
"Enumerations are created using the :keyword:`class` syntax, which makes them "
"easy to read and write.  An alternative creation method is described in "
"`Functional API`_.  To define an enumeration, subclass :class:`Enum` as "
"follows::"
msgstr ""
"列挙型は読み書きが容易になるよう :keyword:`class` 文を使って作成します。もう"
"ひとつの作成方法は `機能 API`_ で説明しています。列挙型は以下のように :class:"
"`Enum` のサブクラスとして定義します::"

#: ../../library/enum.rst:85
msgid "Enum member values"
msgstr "Значення члена Enum"

#: ../../library/enum.rst:87
msgid ""
"Member values can be anything: :class:`int`, :class:`str`, etc..  If the "
"exact value is unimportant you may use :class:`auto` instances and an "
"appropriate value will be chosen for you.  Care must be taken if you mix :"
"class:`auto` with other values."
msgstr ""
"Значення членів можуть бути будь-якими: :class:`int`, :class:`str` тощо. "
"Якщо точне значення неважливе, ви можете використовувати екземпляри :class:"
"`auto`, і відповідне значення буде вибрано для вас. Слід бути обережним, "
"якщо ви змішуєте :class:`auto` з іншими значеннями."

#: ../../library/enum.rst:92
msgid "Nomenclature"
msgstr "Nomenclatura"

#: ../../library/enum.rst:94
msgid "The class :class:`Color` is an *enumeration* (or *enum*)"
msgstr "Клас :class:`Color` є *переліком* (або *enum*)"

#: ../../library/enum.rst:95
msgid ""
"The attributes :attr:`Color.RED`, :attr:`Color.GREEN`, etc., are "
"*enumeration members* (or *enum members*) and are functionally constants."
msgstr ""
"属性 :attr:`Color.RED`, :attr:`Color.GREEN` などは *列挙型のメンバー* (また"
"は *Enum メンバー*) で、機能的には定数です。"

#: ../../library/enum.rst:97
msgid ""
"The enum members have *names* and *values* (the name of :attr:`Color.RED` is "
"``RED``, the value of :attr:`Color.BLUE` is ``3``, etc.)"
msgstr ""
"Члени enum мають *імена* та *значення* (ім’я :attr:`Color.RED` — ``RED``, "
"значення :attr:`Color.BLUE` — ``3`` тощо). )"

#: ../../library/enum.rst:103
msgid ""
"Even though we use the :keyword:`class` syntax to create Enums, Enums are "
"not normal Python classes.  See `How are Enums different?`_ for more details."
msgstr ""
"Enum の作成に :keyword:`class` 文を使用するものの、Enum は通常の Python クラ"
"スではありません。詳細は `Enum はどう違うのか?`_ を参照してください。"

#: ../../library/enum.rst:107
msgid "Enumeration members have human readable string representations::"
msgstr "列挙型のメンバーは人が読める文字列表現を持ちます::"

#: ../../library/enum.rst:112
msgid "...while their ``repr`` has more information::"
msgstr "...その一方でそれらの ``repr`` はより多くの情報を持っています::"

#: ../../library/enum.rst:117
msgid "The *type* of an enumeration member is the enumeration it belongs to::"
msgstr "列挙型メンバーの *データ型* はそれが所属する列挙型になります::"

#: ../../library/enum.rst:125
msgid "Enum members also have a property that contains just their item name::"
msgstr "Enum メンバーは自身の名前を持つだけのプロパティも持っています::"

#: ../../library/enum.rst:130
msgid "Enumerations support iteration, in definition order::"
msgstr "列挙型は定義順でのイテレーションをサポートしています::"

#: ../../library/enum.rst:146
msgid ""
"Enumeration members are hashable, so they can be used in dictionaries and "
"sets::"
msgstr "列挙型のメンバーはハッシュ化可能なため、辞書や集合で使用できます::"

#: ../../library/enum.rst:156
msgid "Programmatic access to enumeration members and their attributes"
msgstr "Acesso programático aos membros da enumeração e seus atributos."

#: ../../library/enum.rst:158
msgid ""
"Sometimes it's useful to access members in enumerations programmatically (i."
"e. situations where ``Color.RED`` won't do because the exact color is not "
"known at program-writing time).  ``Enum`` allows such access::"
msgstr ""
"Em alguns momentos, é util ter acesso aos membros na enumeração de forma "
"programática (ou seja, em situações em que ``Cor.RED`` não é adequado porque "
"a cor exata não é conhecida no momento da escrita do programa). Classes "
"``Enum`` permitem esse tipo de acesso::"

#: ../../library/enum.rst:167
msgid "If you want to access enum members by *name*, use item access::"
msgstr ""
"Se você deseja ter acesso aos membros do enum pelo *nome*, use o acesso por "
"itens:"

#: ../../library/enum.rst:174
msgid "If you have an enum member and need its :attr:`name` or :attr:`value`::"
msgstr ""
"Se você tem um membro do enum e precisa do seu :attr:`name` ou :attr:`value`:"

#: ../../library/enum.rst:184
msgid "Duplicating enum members and values"
msgstr "Membros e valores duplicados em enums"

#: ../../library/enum.rst:186
msgid "Having two enum members with the same name is invalid::"
msgstr "Ter dois membros de um enum com o mesmo nome é inválido:"

#: ../../library/enum.rst:196
msgid ""
"However, two enum members are allowed to have the same value.  Given two "
"members A and B with the same value (and A defined first), B is an alias to "
"A.  By-value lookup of the value of A and B will return A.  By-name lookup "
"of B will also return A::"
msgstr ""
"ただし、複数の列挙型メンバーが同じ値を持つことはできます。同じ値を持つ 2 つの"
"メンバー A および B (先に定義したのは A) が与えられたとき、B は A の別名にな"
"ります。A および B を値で調べたとき、A が返されます。B を名前で調べたとき、A "
"が返されます::"

#: ../../library/enum.rst:216
msgid ""
"Attempting to create a member with the same name as an already defined "
"attribute (another member, a method, etc.) or attempting to create an "
"attribute with the same name as a member is not allowed."
msgstr ""
"Tentar criar um membro com o mesmo nome de um atributo já definido (outro "
"membro, um método, etc.) ou tentar criar um atributo com o mesmo nome de um "
"membro não é permitido."

#: ../../library/enum.rst:222
msgid "Ensuring unique enumeration values"
msgstr "Garantindo valores únicos na enumeração"

#: ../../library/enum.rst:224
msgid ""
"By default, enumerations allow multiple names as aliases for the same value. "
"When this behavior isn't desired, the following decorator can be used to "
"ensure each value is used only once in the enumeration:"
msgstr ""
"デフォルトでは、前述のように複数の名前への同じ値の定義は別名とすることで許さ"
"れています。この挙動を望まない場合、以下のデコレーターを使用することで各値が"
"列挙型内で一意かどうか確認できます:"

#: ../../library/enum.rst:230
msgid ""
"A :keyword:`class` decorator specifically for enumerations.  It searches an "
"enumeration's :attr:`__members__` gathering any aliases it finds; if any are "
"found :exc:`ValueError` is raised with the details::"
msgstr ""
"列挙型専用の :keyword:`class` デコレーターです。列挙型の :attr:`__members__` "
"に別名がないかどうか検索します; 見つかった場合、:exc:`ValueError` が詳細情報"
"とともに送出されます::"

#: ../../library/enum.rst:248
msgid "Using automatic values"
msgstr "Usando valores automáticos"

#: ../../library/enum.rst:250
msgid "If the exact value is unimportant you can use :class:`auto`::"
msgstr "Se o valor em si não é importante, você pode usar :class:`auto`::"

#: ../../library/enum.rst:261
msgid ""
"The values are chosen by :func:`_generate_next_value_`, which can be "
"overridden::"
msgstr ""
"Os valores são escolhidos por :func:`_generate_next_value_`, o qual pode ser "
"substituído:"

#: ../../library/enum.rst:279
msgid ""
"The goal of the default :meth:`_generate_next_value_` method is to provide "
"the next :class:`int` in sequence with the last :class:`int` provided, but "
"the way it does this is an implementation detail and may change."
msgstr ""
"デフォルトの :meth:`_generate_next_value_` メソッドの目的は、最後に提供した :"
"class:`int` の次から順々に :class:`int` を提供することですが、この動作は実装"
"詳細であり変更される可能性があります。"

#: ../../library/enum.rst:285
msgid ""
"The :meth:`_generate_next_value_` method must be defined before any members."
msgstr ""
"O método :meth:`_generate_next_value_`  deve ser definido antes de qualquer "
"membro."

#: ../../library/enum.rst:288
msgid "Iteration"
msgstr "Iteração"

#: ../../library/enum.rst:290
msgid "Iterating over the members of an enum does not provide the aliases::"
msgstr "Iterar sobre os membros de um enum não fornece os apelidos::"

#: ../../library/enum.rst:295
msgid ""
"The special attribute ``__members__`` is a read-only ordered mapping of "
"names to members.  It includes all names defined in the enumeration, "
"including the aliases::"
msgstr ""
"O atributo especial ``__members__`` é um mapeamento ordenado de somente "
"leitura dos nomes para os membros. Isso inclui todos os nomes definidos na "
"enumeração, incluindo os apelidos::"

#: ../../library/enum.rst:307
msgid ""
"The ``__members__`` attribute can be used for detailed programmatic access "
"to the enumeration members.  For example, finding all the aliases::"
msgstr ""
"O atributo ``__members__`` pode ser usado para um acesso programático "
"detalhado aos membros da enumeração. Por exemplo, achar todos os apelidos::"

#: ../../library/enum.rst:315
msgid "Comparisons"
msgstr "Comparações"

#: ../../library/enum.rst:317
msgid "Enumeration members are compared by identity::"
msgstr "Membros de uma enumeração são comparados por identidade::"

#: ../../library/enum.rst:326
msgid ""
"Ordered comparisons between enumeration values are *not* supported.  Enum "
"members are not integers (but see `IntEnum`_ below)::"
msgstr ""
"Упорядковані порівняння між значеннями перерахування *не* підтримуються. "
"Члени Enum не є цілими числами (але дивіться `IntEnum`_ нижче):"

#: ../../library/enum.rst:334
msgid "Equality comparisons are defined though::"
msgstr "Однак порівняння рівності визначено:"

#: ../../library/enum.rst:343
msgid ""
"Comparisons against non-enumeration values will always compare not equal "
"(again, :class:`IntEnum` was explicitly designed to behave differently, see "
"below)::"
msgstr ""
"Порівняння зі значеннями, не пов’язаними з перерахуванням, завжди "
"порівнюватиметься нерівними (знову ж таки, :class:`IntEnum` був явно "
"розроблений для іншої поведінки, див. нижче)::"

#: ../../library/enum.rst:352
msgid "Allowed members and attributes of enumerations"
msgstr "Membros e atributos permitidos em enumerações"

#: ../../library/enum.rst:354
msgid ""
"The examples above use integers for enumeration values.  Using integers is "
"short and handy (and provided by default by the `Functional API`_), but not "
"strictly enforced.  In the vast majority of use-cases, one doesn't care what "
"the actual value of an enumeration is.  But if the value *is* important, "
"enumerations can have arbitrary values."
msgstr ""
"上述の例では列挙型の値に整数を使用しています。整数の使用は短くて使いやすい "
"(そして `機能 API`_ でデフォルトで提供されています) のですが、厳密には強制で"
"はありません。ほとんどの事例では列挙型の実際の値が何かを気にしていません。し"
"かし、値が重要で *ある* 場合、列挙型は任意の値を持つことができます。"

#: ../../library/enum.rst:360
msgid ""
"Enumerations are Python classes, and can have methods and special methods as "
"usual.  If we have this enumeration::"
msgstr ""
"Enumeções são classes Python, e podem ter métodos e até mesmo métodos "
"especiais como de usual. Se temos essa enumeração::"

#: ../../library/enum.rst:380
msgid "Then::"
msgstr "Então::"

#: ../../library/enum.rst:389
msgid ""
"The rules for what is allowed are as follows: names that start and end with "
"a single underscore are reserved by enum and cannot be used; all other "
"attributes defined within an enumeration will become members of this "
"enumeration, with the exception of special methods (:meth:`__str__`, :meth:"
"`__add__`, etc.), descriptors (methods are also descriptors), and variable "
"names listed in :attr:`_ignore_`."
msgstr ""
"Дозволені правила такі: імена, які починаються і закінчуються одним "
"підкресленням, зарезервовані enum і не можуть використовуватися; усі інші "
"атрибути, визначені в переліку, стануть членами цього переліку, за винятком "
"спеціальних методів (:meth:`__str__`, :meth:`__add__` тощо), дескрипторів "
"(методи також є дескрипторами) і імен змінних перераховані в :attr:"
"`_ignore_`."

#: ../../library/enum.rst:396
msgid ""
"Note:  if your enumeration defines :meth:`__new__` and/or :meth:`__init__` "
"then any value(s) given to the enum member will be passed into those "
"methods. See `Planet`_ for an example."
msgstr ""
"Примітка: якщо ваш перелік визначає :meth:`__new__` та/або :meth:`__init__`, "
"тоді будь-яке значення, надане члену enum, буде передано в ці методи. "
"Перегляньте `Planet`_ для прикладу."

#: ../../library/enum.rst:402
msgid "Restricted Enum subclassing"
msgstr "Обмежений підклас Enum"

#: ../../library/enum.rst:404
msgid ""
"A new :class:`Enum` class must have one base Enum class, up to one concrete "
"data type, and as many :class:`object`-based mixin classes as needed.  The "
"order of these base classes is::"
msgstr ""
"新しい :class:`Enum` クラスは、ベースのEnumクラスを1つ、具象データ型を1つ、複"
"数の :class:`object` ベースのミックスインクラスが許容されます。これらのベース"
"クラスの順序は次の通りです::"

#: ../../library/enum.rst:411
msgid ""
"Also, subclassing an enumeration is allowed only if the enumeration does not "
"define any members.  So this is forbidden::"
msgstr ""
"Além disso, criar uma subclasse de uma enumeração é permitido apenas se a "
"enumeção não define nenhum membro. Pontando isso é proibido::"

#: ../../library/enum.rst:421
msgid "But this is allowed::"
msgstr "Mas isso é permitido::"

#: ../../library/enum.rst:432
msgid ""
"Allowing subclassing of enums that define members would lead to a violation "
"of some important invariants of types and instances.  On the other hand, it "
"makes sense to allow sharing some common behavior between a group of "
"enumerations. (See `OrderedEnum`_ for an example.)"
msgstr ""
"Дозвіл створення підкласів для переліків, які визначають члени, призведе до "
"порушення деяких важливих інваріантів типів і екземплярів. З іншого боку, "
"має сенс дозволити спільну поведінку між групою перерахувань. (Див. "
"`OrderedEnum`_ для прикладу.)"

#: ../../library/enum.rst:439
msgid "Pickling"
msgstr "Pickling"

#: ../../library/enum.rst:441
msgid "Enumerations can be pickled and unpickled::"
msgstr "Перерахування можна маринувати і не маринувати:"

#: ../../library/enum.rst:448
msgid ""
"The usual restrictions for pickling apply: picklable enums must be defined "
"in the top level of a module, since unpickling requires them to be "
"importable from that module."
msgstr ""
"Застосовуються звичайні обмеження для маркування: переліки, які можна "
"піклувати, повинні бути визначені на верхньому рівні модуля, оскільки для "
"скасування потрібно, щоб їх можна було імпортувати з цього модуля."

#: ../../library/enum.rst:454
msgid ""
"With pickle protocol version 4 it is possible to easily pickle enums nested "
"in other classes."
msgstr ""
"За допомогою протоколу pickle версії 4 можна легко маринувати переліки, "
"вкладені в інші класи."

#: ../../library/enum.rst:457
msgid ""
"It is possible to modify how Enum members are pickled/unpickled by defining :"
"meth:`__reduce_ex__` in the enumeration class."
msgstr ""
"Enum メンバーをどう pickle 化/unpickle 化するかは、列挙型クラス内の :meth:"
"`__reduce_ex__` で定義することで変更できます。"

#: ../../library/enum.rst:462
msgid "Functional API"
msgstr "API funcional"

#: ../../library/enum.rst:464
msgid ""
"The :class:`Enum` class is callable, providing the following functional API::"
msgstr ""
"A classe :class:`Enum` é chamável, fornecendo a API funcional a seguir::"

#: ../../library/enum.rst:476
msgid ""
"The semantics of this API resemble :class:`~collections.namedtuple`. The "
"first argument of the call to :class:`Enum` is the name of the enumeration."
msgstr ""
"Семантика цього API нагадує :class:`~collections.namedtuple`. Першим "
"аргументом виклику :class:`Enum` є назва переліку."

#: ../../library/enum.rst:479
msgid ""
"The second argument is the *source* of enumeration member names.  It can be "
"a whitespace-separated string of names, a sequence of names, a sequence of 2-"
"tuples with key/value pairs, or a mapping (e.g. dictionary) of names to "
"values.  The last two options enable assigning arbitrary values to "
"enumerations; the others auto-assign increasing integers starting with 1 "
"(use the ``start`` parameter to specify a different starting value).  A new "
"class derived from :class:`Enum` is returned.  In other words, the above "
"assignment to :class:`Animal` is equivalent to::"
msgstr ""
"Другим аргументом є *джерело* імен членів переліку. Це може бути рядок імен, "
"розділених пробілами, послідовність імен, послідовність 2-кортежів із парами "
"ключ/значення або зіставлення (наприклад, словник) імен із значеннями. "
"Останні два параметри дозволяють присвоювати довільні значення "
"перерахуванням; інші автоматично призначають зростаючі цілі числа, починаючи "
"з 1 (використовуйте параметр ``start``, щоб вказати інше початкове "
"значення). Повертається новий клас, похідний від :class:`Enum`. Іншими "
"словами, наведене вище призначення :class:`Animal` еквівалентне::"

#: ../../library/enum.rst:495
msgid ""
"The reason for defaulting to ``1`` as the starting number and not ``0`` is "
"that ``0`` is ``False`` in a boolean sense, but enum members all evaluate to "
"``True``."
msgstr ""
"デフォルトの開始番号が ``0`` ではなく ``1`` である理由は、``0`` がブール演算"
"子では ``False`` になりますが、すべての列挙型メンバーの評価は ``True`` でなけ"
"ればならないためです。"

#: ../../library/enum.rst:499
msgid ""
"Pickling enums created with the functional API can be tricky as frame stack "
"implementation details are used to try and figure out which module the "
"enumeration is being created in (e.g. it will fail if you use a utility "
"function in separate module, and also may not work on IronPython or Jython). "
"The solution is to specify the module name explicitly as follows::"
msgstr ""
"機能 API による Enum の pickle 化は、その列挙型がどのモジュールで作成されたか"
"を見つけ出すためにフレームスタックの実装の詳細が使われるので、トリッキーにな"
"ることがあります (例えば別のモジュールのユーティリティ関数を使うと失敗します"
"し、IronPython や Jython ではうまくいきません)。解決策は、以下のようにモ"
"ジュール名を明示的に指定することです::"

#: ../../library/enum.rst:509
msgid ""
"If ``module`` is not supplied, and Enum cannot determine what it is, the new "
"Enum members will not be unpicklable; to keep errors closer to the source, "
"pickling will be disabled."
msgstr ""
"Якщо ``module`` не вказано, і Enum не може визначити, що це таке, нові члени "
"Enum не можна буде вибрати; щоб зберегти помилки ближче до джерела, "
"травлення буде вимкнено."

#: ../../library/enum.rst:513
msgid ""
"The new pickle protocol 4 also, in some circumstances, relies on :attr:"
"`~definition.__qualname__` being set to the location where pickle will be "
"able to find the class.  For example, if the class was made available in "
"class SomeData in the global scope::"
msgstr ""
"Новий протокол pickle 4 також, за деяких обставин, покладається на те, що :"
"attr:`~definition.__qualname__` встановлено на місце, де pickle зможе знайти "
"клас. Наприклад, якщо клас був доступний у класі SomeData у глобальній "
"області::"

#: ../../library/enum.rst:520
msgid "The complete signature is::"
msgstr "A assinatura completa é::"

#: ../../library/enum.rst:0
msgid "value"
msgstr "valor"

#: ../../library/enum.rst:524
msgid "What the new Enum class will record as its name."
msgstr "新しい Enum クラスに記録されるそれ自身の名前です。"

#: ../../library/enum.rst:0
msgid "names"
msgstr "nomes"

#: ../../library/enum.rst:526
msgid ""
"The Enum members.  This can be a whitespace or comma separated string "
"(values will start at 1 unless otherwise specified)::"
msgstr ""
"Enum のメンバーです。\n"
"空白またはカンマで区切った文字列でも構いません (特に指定がない限り、値は 1 か"
"ら始まります)::"

#: ../../library/enum.rst:531
msgid "or an iterator of names::"
msgstr "або ітератор імен::"

#: ../../library/enum.rst:535
msgid "or an iterator of (name, value) pairs::"
msgstr "або ітератор пар (ім'я, значення)::"

#: ../../library/enum.rst:539
msgid "or a mapping::"
msgstr "або відображення::"

#: ../../library/enum.rst:0
msgid "module"
msgstr "módulo"

#: ../../library/enum.rst:543
msgid "name of module where new Enum class can be found."
msgstr "新しい Enum クラスが属するモジュールの名前です。"

#: ../../library/enum.rst:0
msgid "qualname"
msgstr "qualname"

#: ../../library/enum.rst:545
msgid "where in module new Enum class can be found."
msgstr "新しい Enum クラスが属するモジュールの場所です。"

#: ../../library/enum.rst:0
msgid "type"
msgstr "tipo"

#: ../../library/enum.rst:547
msgid "type to mix in to new Enum class."
msgstr "新しい Enum クラスに複合されるデータ型です。"

#: ../../library/enum.rst:0
msgid "start"
msgstr "start"

#: ../../library/enum.rst:549
msgid "number to start counting at if only names are passed in."
msgstr "число для початку підрахунку, якщо передано лише імена."

#: ../../library/enum.rst:551
msgid "The *start* parameter was added."
msgstr "Додано параметр *start*."

#: ../../library/enum.rst:556
msgid "Derived Enumerations"
msgstr "Похідні перерахування"

#: ../../library/enum.rst:559
msgid "IntEnum"
msgstr "IntEnum"

#: ../../library/enum.rst:561
msgid ""
"The first variation of :class:`Enum` that is provided is also a subclass of :"
"class:`int`.  Members of an :class:`IntEnum` can be compared to integers; by "
"extension, integer enumerations of different types can also be compared to "
"each other::"
msgstr ""
"Перший наданий варіант :class:`Enum` також є підкласом :class:`int`. Члени :"
"class:`IntEnum` можна порівняти з цілими числами; за розширенням, "
"цілочисельні перерахування різних типів також можна порівнювати один з одним:"

#: ../../library/enum.rst:582
msgid ""
"However, they still can't be compared to standard :class:`Enum` "
"enumerations::"
msgstr ""
"Однак їх все ще не можна порівняти зі стандартними перерахуваннями :class:"
"`Enum`::"

#: ../../library/enum.rst:595
msgid ""
":class:`IntEnum` values behave like integers in other ways you'd expect::"
msgstr "Значення :class:`IntEnum` поводяться як цілі числа іншим чином:"

#: ../../library/enum.rst:606
msgid "IntFlag"
msgstr "IntFlag"

#: ../../library/enum.rst:608
msgid ""
"The next variation of :class:`Enum` provided, :class:`IntFlag`, is also "
"based on :class:`int`.  The difference being :class:`IntFlag` members can be "
"combined using the bitwise operators (&, \\|, ^, ~) and the result is still "
"an :class:`IntFlag` member.  However, as the name implies, :class:`IntFlag` "
"members also subclass :class:`int` and can be used wherever an :class:`int` "
"is used.  Any operation on an :class:`IntFlag` member besides the bit-wise "
"operations will lose the :class:`IntFlag` membership."
msgstr ""
"提供されている 2 つ目の :class:`Enum` の派生型 :class:`IntFlag` も :class:"
"`int` を基底クラスとしています。\n"
":class:`IntFlag` メンバーが  :class:`Enum` メンバーと異なるのは、ビット演算"
"子 (&, \\|, ^, ~) を使って組み合わせられ、その結果も :class:`IntFlag` メン"
"バーになることです。\n"
"しかし、名前が示すように、 :class:`IntFlag` は :class:`int` のサブクラスでも"
"あり、 :class:`int` が使われるところでもどこでも使えます。\n"
":class:`IntFlag` メンバーに対してビット演算以外のどんな演算をしても、その結果"
"は :class:`IntFlag` メンバーではなくなります。"

#: ../../library/enum.rst:618
msgid "Sample :class:`IntFlag` class::"
msgstr "Приклад :class:`IntFlag` class::"

#: ../../library/enum.rst:634
msgid "It is also possible to name the combinations::"
msgstr "Також можна назвати комбінації:"

#: ../../library/enum.rst:646
msgid ""
"Another important difference between :class:`IntFlag` and :class:`Enum` is "
"that if no flags are set (the value is 0), its boolean evaluation is :data:"
"`False`::"
msgstr ""
"Ще одна важлива відмінність між :class:`IntFlag` і :class:`Enum` полягає в "
"тому, що якщо не встановлено жодного прапора (значення дорівнює 0), його "
"логічна оцінка буде :data:`False`::"

#: ../../library/enum.rst:654
msgid ""
"Because :class:`IntFlag` members are also subclasses of :class:`int` they "
"can be combined with them::"
msgstr ""
":class:`IntFlag` は :class:`int` のサブクラスでもあるので、その両者を組み合わ"
"せられます::"

#: ../../library/enum.rst:662
msgid "Flag"
msgstr "Sinalizador"

#: ../../library/enum.rst:664
msgid ""
"The last variation is :class:`Flag`.  Like :class:`IntFlag`, :class:`Flag` "
"members can be combined using the bitwise operators (&, \\|, ^, ~).  Unlike :"
"class:`IntFlag`, they cannot be combined with, nor compared against, any "
"other :class:`Flag` enumeration, nor :class:`int`.  While it is possible to "
"specify the values directly it is recommended to use :class:`auto` as the "
"value and let :class:`Flag` select an appropriate value."
msgstr ""
"Останнім варіантом є :class:`Flag`. Подібно до :class:`IntFlag`, члени :"
"class:`Flag` можна комбінувати за допомогою порозрядних операторів (&, \\|, "
"^, ~). На відміну від :class:`IntFlag`, їх не можна комбінувати з будь-яким "
"іншим переліком :class:`Flag` або :class:`int`, ані порівнювати з ними. Хоча "
"можна вказати значення безпосередньо, рекомендується використовувати :class:"
"`auto` як значення, а :class:`Flag` вибрати відповідне значення."

#: ../../library/enum.rst:673
msgid ""
"Like :class:`IntFlag`, if a combination of :class:`Flag` members results in "
"no flags being set, the boolean evaluation is :data:`False`::"
msgstr ""
"Подібно до :class:`IntFlag`, якщо комбінація членів :class:`Flag` не "
"призводить до встановлення прапорів, логічна оцінка буде :data:`False`::"

#: ../../library/enum.rst:687
msgid ""
"Individual flags should have values that are powers of two (1, 2, 4, "
"8, ...), while combinations of flags won't::"
msgstr ""
"Індивідуальні прапори повинні мати значення, які є степенями двійки (1, 2, "
"4, 8, ...), тоді як комбінації прапорів не матимуть:"

#: ../../library/enum.rst:699
msgid ""
"Giving a name to the \"no flags set\" condition does not change its boolean "
"value::"
msgstr ""
"Присвоєння назви умові \"прапори не встановлено\" не змінює її логічного "
"значення::"

#: ../../library/enum.rst:715
msgid ""
"For the majority of new code, :class:`Enum` and :class:`Flag` are strongly "
"recommended, since :class:`IntEnum` and :class:`IntFlag` break some semantic "
"promises of an enumeration (by being comparable to integers, and thus by "
"transitivity to other unrelated enumerations).  :class:`IntEnum` and :class:"
"`IntFlag` should be used only in cases where :class:`Enum` and :class:`Flag` "
"will not do; for example, when integer constants are replaced with "
"enumerations, or for interoperability with other systems."
msgstr ""
"Для більшості нового коду наполегливо рекомендується використовувати :class:"
"`Enum` і :class:`Flag`, оскільки :class:`IntEnum` і :class:`IntFlag` "
"порушують деякі семантичні обіцянки перерахування (через їх порівняння з "
"цілі числа, і, таким чином, через перехідність до інших непов’язаних "
"перерахувань). :class:`IntEnum` і :class:`IntFlag` слід використовувати лише "
"у випадках, коли :class:`Enum` і :class:`Flag` не підходять; наприклад, коли "
"цілі константи замінюються перерахуваннями або для взаємодії з іншими "
"системами."

#: ../../library/enum.rst:725
msgid "Others"
msgstr "Outros"

#: ../../library/enum.rst:727
msgid ""
"While :class:`IntEnum` is part of the :mod:`enum` module, it would be very "
"simple to implement independently::"
msgstr ""
"Хоча :class:`IntEnum` є частиною модуля :mod:`enum`, його було б дуже просто "
"реалізувати незалежно:"

#: ../../library/enum.rst:733
msgid ""
"This demonstrates how similar derived enumerations can be defined; for "
"example a :class:`StrEnum` that mixes in :class:`str` instead of :class:"
"`int`."
msgstr ""
"ここでは似たような列挙型の派生を定義する方法を紹介します; 例えば、:class:"
"`StrEnum` は :class:`int` ではなく :class:`str` で複合させたものです。"

#: ../../library/enum.rst:736
msgid "Some rules:"
msgstr "Algumas regras:"

#: ../../library/enum.rst:738
msgid ""
"When subclassing :class:`Enum`, mix-in types must appear before :class:"
"`Enum` itself in the sequence of bases, as in the :class:`IntEnum` example "
"above."
msgstr ""
"Під час створення підкласу :class:`Enum` змішані типи повинні з’являтися "
"перед самим :class:`Enum` у послідовності основ, як у прикладі :class:"
"`IntEnum` вище."

#: ../../library/enum.rst:741
msgid ""
"While :class:`Enum` can have members of any type, once you mix in an "
"additional type, all the members must have values of that type, e.g. :class:"
"`int` above.  This restriction does not apply to mix-ins which only add "
"methods and don't specify another type."
msgstr ""
"Хоча :class:`Enum` може мати члени будь-якого типу, коли ви додаєте "
"додатковий тип, усі члени повинні мати значення цього типу, наприклад. :"
"class:`int` вище. Це обмеження не стосується змішувань, які лише додають "
"методи і не вказують інший тип."

#: ../../library/enum.rst:745
msgid ""
"When another data type is mixed in, the :attr:`value` attribute is *not the "
"same* as the enum member itself, although it is equivalent and will compare "
"equal."
msgstr ""
"Коли додається інший тип даних, атрибут :attr:`value` *не такий самий*, як "
"сам член переліку, хоча він еквівалентний і порівнюватиметься рівним."

#: ../../library/enum.rst:748
msgid ""
"%-style formatting:  `%s` and `%r` call the :class:`Enum` class's :meth:"
"`__str__` and :meth:`__repr__` respectively; other codes (such as `%i` or "
"`%h` for IntEnum) treat the enum member as its mixed-in type."
msgstr ""
"%-方式の書式:  `%s` および `%r` はそれぞれ :class:`Enum` クラスの :meth:"
"`__str__` および :meth:`__repr__` を呼び出します;\n"
"その他のコード (IntEnum の `%i` や `%h` など) は列挙型のメンバーを複合された"
"データ型として扱います。"

#: ../../library/enum.rst:751
msgid ""
":ref:`Formatted string literals <f-strings>`, :meth:`str.format`, and :func:"
"`format` will use the mixed-in type's :meth:`__format__` unless :meth:"
"`__str__` or :meth:`__format__` is overridden in the subclass, in which case "
"the overridden methods or :class:`Enum` methods will be used. Use the !s "
"and !r format codes to force usage of the :class:`Enum` class's :meth:"
"`__str__` and :meth:`__repr__` methods."
msgstr ""
":ref:`フォーマット済み文字列リテラル <f-strings>` 、 :meth:`str.format` 、 :"
"func:`format` は、 :meth:`__str__` やサブクラスでオーバーライドされた :meth:"
"`__format__` よりもミックスイン型の :meth:`__format__` を優先して使います。!s"
"や!rフォーマットコードを使うと、 :class:`Enum` クラスの :meth:`__str__` や :"
"meth:`__repr__` メソッドが強制的に使われます。"

#: ../../library/enum.rst:759
msgid "When to use :meth:`__new__` vs. :meth:`__init__`"
msgstr "Quando usar :meth:`__new__` vs. :meth:`__init__`"

#: ../../library/enum.rst:761
msgid ""
":meth:`__new__` must be used whenever you want to customize the actual value "
"of the :class:`Enum` member.  Any other modifications may go in either :meth:"
"`__new__` or :meth:`__init__`, with :meth:`__init__` being preferred."
msgstr ""
":meth:`__new__` потрібно використовувати щоразу, коли ви хочете налаштувати "
"фактичне значення члена :class:`Enum`. Будь-які інші модифікації можна "
"вносити в :meth:`__new__` або :meth:`__init__`, причому перевага віддається :"
"meth:`__init__`."

#: ../../library/enum.rst:765
msgid ""
"For example, if you want to pass several items to the constructor, but only "
"want one of them to be the value::"
msgstr ""
"Наприклад, якщо ви хочете передати кілька елементів у конструктор, але "
"хочете, щоб лише один із них був значенням::"

#: ../../library/enum.rst:791
msgid "Interesting examples"
msgstr "興味深い例"

#: ../../library/enum.rst:793
msgid ""
"While :class:`Enum`, :class:`IntEnum`, :class:`IntFlag`, and :class:`Flag` "
"are expected to cover the majority of use-cases, they cannot cover them "
"all.  Here are recipes for some different types of enumerations that can be "
"used directly, or as examples for creating one's own."
msgstr ""
":class:`Enum`, :class:`IntEnum`, :class:`IntFlag`, :class:`Flag` は用途の大部"
"分をカバーすると予想されますが、そのすべてをカバーできているわけではありませ"
"ん。\n"
"ここでは、そのまま、あるいは独自の列挙型を作る例として使える、様々なタイプの"
"列挙型を紹介します。"

#: ../../library/enum.rst:800
msgid "Omitting values"
msgstr "Пропуск значень"

#: ../../library/enum.rst:802
msgid ""
"In many use-cases one doesn't care what the actual value of an enumeration "
"is. There are several ways to define this type of simple enumeration:"
msgstr ""
"多くの用途では、列挙型の実際の値が何かは気にされません。\n"
"このタイプの単純な列挙型を定義する方法はいくつかあります:"

#: ../../library/enum.rst:805
msgid "use instances of :class:`auto` for the value"
msgstr "використовувати екземпляри :class:`auto` для значення"

#: ../../library/enum.rst:806
msgid "use instances of :class:`object` as the value"
msgstr "використовуйте екземпляри :class:`object` як значення"

#: ../../library/enum.rst:807
msgid "use a descriptive string as the value"
msgstr "використовуйте описовий рядок як значення"

#: ../../library/enum.rst:808
msgid ""
"use a tuple as the value and a custom :meth:`__new__` to replace the tuple "
"with an :class:`int` value"
msgstr ""
"використовуйте кортеж як значення та спеціальний :meth:`__new__`, щоб "
"замінити кортеж на значення :class:`int`"

#: ../../library/enum.rst:811
msgid ""
"Using any of these methods signifies to the user that these values are not "
"important, and also enables one to add, remove, or reorder members without "
"having to renumber the remaining members."
msgstr ""
"Використання будь-якого з цих методів означає для користувача, що ці "
"значення не є важливими, а також дозволяє додавати, видаляти або змінювати "
"порядок членів без необхідності перенумеровувати решту членів."

#: ../../library/enum.rst:815
msgid ""
"Whichever method you choose, you should provide a :meth:`repr` that also "
"hides the (unimportant) value::"
msgstr ""
"どの方法を選んでも、(重要でない) 値を隠す :meth:`repr` を提供すべきです::"

#: ../../library/enum.rst:825
msgid "Using :class:`auto`"
msgstr "Використання :class:`auto`"

#: ../../library/enum.rst:827
msgid "Using :class:`auto` would look like::"
msgstr "Використання :class:`auto` виглядатиме так::"

#: ../../library/enum.rst:839
msgid "Using :class:`object`"
msgstr "Використання :class:`object`"

#: ../../library/enum.rst:841
msgid "Using :class:`object` would look like::"
msgstr "Використання :class:`object` виглядатиме так::"

#: ../../library/enum.rst:853
msgid "Using a descriptive string"
msgstr "Використання описового рядка"

#: ../../library/enum.rst:855
msgid "Using a string as the value would look like::"
msgstr "Використання рядка як значення виглядатиме так::"

#: ../../library/enum.rst:869
msgid "Using a custom :meth:`__new__`"
msgstr "Usando um :meth:`__new__` personalizado"

#: ../../library/enum.rst:871
msgid "Using an auto-numbering :meth:`__new__` would look like::"
msgstr "Використання автоматичної нумерації :meth:`__new__` виглядатиме так::"

#: ../../library/enum.rst:890
msgid ""
"To make a more general purpose ``AutoNumber``, add ``*args`` to the "
"signature::"
msgstr ""
"Щоб зробити ``AutoNumber`` більш загального призначення, додайте ``*args`` "
"до підпису::"

#: ../../library/enum.rst:900
msgid ""
"Then when you inherit from ``AutoNumber`` you can write your own "
"``__init__`` to handle any extra arguments::"
msgstr ""
"Тоді, коли ви успадкуєте від ``AutoNumber``, ви можете написати свій власний "
"``__init__`` для обробки будь-яких додаткових аргументів::"

#: ../../library/enum.rst:919
msgid ""
"The :meth:`__new__` method, if defined, is used during creation of the Enum "
"members; it is then replaced by Enum's :meth:`__new__` which is used after "
"class creation for lookup of existing members."
msgstr ""
"Метод :meth:`__new__`, якщо його визначено, використовується під час "
"створення елементів Enum; потім його замінює :meth:`__new__` Enum, який "
"використовується після створення класу для пошуку існуючих членів."

#: ../../library/enum.rst:925
msgid "OrderedEnum"
msgstr "OrderedEnum"

#: ../../library/enum.rst:927
msgid ""
"An ordered enumeration that is not based on :class:`IntEnum` and so "
"maintains the normal :class:`Enum` invariants (such as not being comparable "
"to other enumerations)::"
msgstr ""
"Упорядковане перерахування, яке не базується на :class:`IntEnum` і тому "
"підтримує звичайні інваріанти :class:`Enum` (наприклад, не порівнюється з "
"іншими переліками):"

#: ../../library/enum.rst:961
msgid "DuplicateFreeEnum"
msgstr "DuplicateFreeEnum"

#: ../../library/enum.rst:963
msgid ""
"Raises an error if a duplicate member name is found instead of creating an "
"alias::"
msgstr ""
"Викликає помилку, якщо замість створення псевдоніма знайдено повторюване "
"ім’я члена::"

#: ../../library/enum.rst:988
msgid ""
"This is a useful example for subclassing Enum to add or change other "
"behaviors as well as disallowing aliases.  If the only desired change is "
"disallowing aliases, the :func:`unique` decorator can be used instead."
msgstr ""
"Це корисний приклад для підкласу Enum для додавання або зміни іншої "
"поведінки, а також заборони псевдонімів. Якщо єдиною бажаною зміною є "
"заборона псевдонімів, натомість можна використати декоратор :func:`unique`."

#: ../../library/enum.rst:994
msgid "Planet"
msgstr "Планета"

#: ../../library/enum.rst:996
msgid ""
"If :meth:`__new__` or :meth:`__init__` is defined the value of the enum "
"member will be passed to those methods::"
msgstr ""
":meth:`__new__` や :meth:`__init__` が定義されている場合、列挙型メンバーの値"
"はこれらのメソッドに渡されます::"

#: ../../library/enum.rst:1024
msgid "TimePeriod"
msgstr "TimePeriod"

#: ../../library/enum.rst:1026
msgid "An example to show the :attr:`_ignore_` attribute in use::"
msgstr "Приклад використання атрибута :attr:`_ignore_`::"

#: ../../library/enum.rst:1043
msgid "How are Enums different?"
msgstr "Чим відрізняються Enum?"

#: ../../library/enum.rst:1045
msgid ""
"Enums have a custom metaclass that affects many aspects of both derived Enum "
"classes and their instances (members)."
msgstr ""
"Enum は Enum 派生クラスやそれらのインスタンス (メンバー) 双方の多くの側面に影"
"響を及ぼすカスタムメタクラスを持っています。"

#: ../../library/enum.rst:1050
msgid "Enum Classes"
msgstr "Класи Enum"

#: ../../library/enum.rst:1052
msgid ""
"The :class:`EnumMeta` metaclass is responsible for providing the :meth:"
"`__contains__`, :meth:`__dir__`, :meth:`__iter__` and other methods that "
"allow one to do things with an :class:`Enum` class that fail on a typical "
"class, such as `list(Color)` or `some_enum_var in Color`.  :class:`EnumMeta` "
"is responsible for ensuring that various other methods on the final :class:"
"`Enum` class are correct (such as :meth:`__new__`, :meth:`__getnewargs__`, :"
"meth:`__str__` and :meth:`__repr__`)."
msgstr ""
":class:`EnumMeta` メタクラスは、:meth:`__contains__`、:meth:`__dir__`、:meth:"
"`__iter__` および標準的なクラスでは失敗するが :class:`Enum` クラスでは動作す"
"るその他のメソッド (`list(Color)` や `some_enum_var in Color` など) を責任を"
"持って提供します。:class:`EnumMeta` は最終的な :class:`Enum` クラスのさまざま"
"なメソッド (:meth:`__new__`、:meth:`__getnewargs__`、:meth:`__str__` および :"
"meth:`__repr__`) が正しいことを責任を持って保証します。"

#: ../../library/enum.rst:1062
msgid "Enum Members (aka instances)"
msgstr "Члени Enum (також відомі як екземпляри)"

#: ../../library/enum.rst:1064
msgid ""
"The most interesting thing about Enum members is that they are singletons. :"
"class:`EnumMeta` creates them all while it is creating the :class:`Enum` "
"class itself, and then puts a custom :meth:`__new__` in place to ensure that "
"no new ones are ever instantiated by returning only the existing member "
"instances."
msgstr ""
"Enum メンバーについて最も興味深いのは、それらがシングルトンであるということで"
"す。:class:`EnumMeta` は :class:`Enum` 自身を作成し、メンバーを作成し、新しい"
"インスタンスが作成されていないかどうかを確認するために既存のメンバーインスタ"
"ンスだけを返すカスタム :meth:`__new__` を追加します。"

#: ../../library/enum.rst:1072
msgid "Finer Points"
msgstr "Більш тонкі точки"

#: ../../library/enum.rst:1075
msgid "Supported ``__dunder__`` names"
msgstr "Nomes ``__dunder__`` suportados"

#: ../../library/enum.rst:1077
msgid ""
":attr:`__members__` is a read-only ordered mapping of ``member_name``:"
"``member`` items.  It is only available on the class."
msgstr ""
":attr:`__members__` — це впорядковане зіставлення елементів ``member_name``:"
"``member`` лише для читання. Це доступно лише в класі."

#: ../../library/enum.rst:1080
msgid ""
":meth:`__new__`, if specified, must create and return the enum members; it "
"is also a very good idea to set the member's :attr:`_value_` appropriately.  "
"Once all the members are created it is no longer used."
msgstr ""
":meth:`__new__`, якщо вказано, має створити та повернути члени enum; також "
"дуже гарна ідея належним чином встановити :attr:`_value_` члена. Після "
"створення всіх учасників він більше не використовується."

#: ../../library/enum.rst:1086
msgid "Supported ``_sunder_`` names"
msgstr "Nomes ``_sunder_`` suportados"

#: ../../library/enum.rst:1088
msgid "``_name_`` -- name of the member"
msgstr "``_name_`` -- nome do membro"

#: ../../library/enum.rst:1089
msgid ""
"``_value_`` -- value of the member; can be set / modified in ``__new__``"
msgstr ""
"``_value_`` -- valor do membro; pode ser definido / modificado em ``__new__``"

#: ../../library/enum.rst:1091
msgid ""
"``_missing_`` -- a lookup function used when a value is not found; may be "
"overridden"
msgstr ""
"``_missing_`` -- uma função de pesquisa usada quando um valor não é "
"encontrado; pode ser substituída"

#: ../../library/enum.rst:1093
msgid ""
"``_ignore_`` -- a list of names, either as a :class:`list` or a :class:"
"`str`, that will not be transformed into members, and will be removed from "
"the final class"
msgstr ""
"``_ignore_`` -- uma lista de nomes, seja como :class:`list` ou :class:`str`, "
"que não serão transformados em membros e serão removidos da classe final"

#: ../../library/enum.rst:1096
msgid ""
"``_order_`` -- used in Python 2/3 code to ensure member order is consistent "
"(class attribute, removed during class creation)"
msgstr ""
"``_order_`` -- usado no código Python 2/3 para garantir que a ordem dos "
"membros seja consistente (atributo de classe, removido durante a criação da "
"classe)"

#: ../../library/enum.rst:1098
msgid ""
"``_generate_next_value_`` -- used by the `Functional API`_ and by :class:"
"`auto` to get an appropriate value for an enum member; may be overridden"
msgstr ""
"``_generate_next_value_`` -- використовується `Functional API`_ і :class:"
"`auto` для отримання відповідного значення для члена enum; може бути "
"перевизначено"

#: ../../library/enum.rst:1102
msgid "``_missing_``, ``_order_``, ``_generate_next_value_``"
msgstr "``_missing_``, ``_order_``, ``_generate_next_value_``"

#: ../../library/enum.rst:1103
msgid "``_ignore_``"
msgstr "``_ignore_``"

#: ../../library/enum.rst:1105
msgid ""
"To help keep Python 2 / Python 3 code in sync an :attr:`_order_` attribute "
"can be provided.  It will be checked against the actual order of the "
"enumeration and raise an error if the two do not match::"
msgstr ""
"Щоб підтримувати синхронізацію коду Python 2 / Python 3, можна надати "
"атрибут :attr:`_order_`. Його буде перевірено на фактичний порядок "
"перерахування та викличе помилку, якщо вони не збігаються:"

#: ../../library/enum.rst:1121
msgid ""
"In Python 2 code the :attr:`_order_` attribute is necessary as definition "
"order is lost before it can be recorded."
msgstr ""
"У коді Python 2 атрибут :attr:`_order_` необхідний, оскільки порядок "
"визначення втрачається, перш ніж його можна записати."

#: ../../library/enum.rst:1126
msgid "_Private__names"
msgstr "_Private__names"

#: ../../library/enum.rst:1128
msgid ""
":ref:`Private names <private-name-mangling>` will be normal attributes in "
"Python 3.11 instead of either an error or a member (depending on if the name "
"ends with an underscore). Using these names in 3.9 and 3.10 will issue a :"
"exc:`DeprecationWarning`."
msgstr ""

#: ../../library/enum.rst:1134
msgid "``Enum`` member type"
msgstr "Тип члена ``Enum``"

#: ../../library/enum.rst:1136
msgid ""
":class:`Enum` members are instances of their :class:`Enum` class, and are "
"normally accessed as ``EnumClass.member``.  Under certain circumstances they "
"can also be accessed as ``EnumClass.member.member``, but you should never do "
"this as that lookup may fail or, worse, return something besides the :class:"
"`Enum` member you are looking for (this is another good reason to use all-"
"uppercase names for members)::"
msgstr ""
":class:`Enum` メンバーは、それらの :class:`Enum` クラスのインスタンスで、通常"
"は ``EnumClass.member`` のようにアクセスします。\n"
"ある状況下では、 ``EnumClass.member.member`` としてもアクセスできますが、この"
"方法は絶対に使うべきではありません。\n"
"というのは、この検索は失敗するか、さらに悪い場合には、探している :class:"
"`Enum` メンバー以外のものを返す場合もあるからです (これがメンバーの名前に大文"
"字のみを使うのが良い理由の 1 つでもあります)::"

#: ../../library/enum.rst:1155
msgid "This behavior is deprecated and will be removed in 3.11."
msgstr "这一行为已被废弃，并将在 3.11 中被删除。"

#: ../../library/enum.rst:1161
msgid "Boolean value of ``Enum`` classes and members"
msgstr "Логічне значення класів і членів ``Enum``"

#: ../../library/enum.rst:1163
msgid ""
":class:`Enum` members that are mixed with non-:class:`Enum` types (such as :"
"class:`int`, :class:`str`, etc.) are evaluated according to the mixed-in "
"type's rules; otherwise, all members evaluate as :data:`True`.  To make your "
"own Enum's boolean evaluation depend on the member's value add the following "
"to your class::"
msgstr ""
"(:class:`int`, :class:`str` などのような) 非 :class:`Enum` 型と複合させた :"
"class:`Enum` のメンバーは、その複合された型の規則に従って評価されます;\n"
"そうでない場合は、全てのメンバーは :data:`True` と評価されます。\n"
"メンバーの値に依存する独自の Enum の真偽値評価を行うには、クラスに次のコード"
"を追加してください::"

#: ../../library/enum.rst:1172
msgid ":class:`Enum` classes always evaluate as :data:`True`."
msgstr ":class:`Enum` クラスは常に :data:`True` と評価されます。"

#: ../../library/enum.rst:1176
msgid "``Enum`` classes with methods"
msgstr "``Enum`` класи з методами"

#: ../../library/enum.rst:1178
msgid ""
"If you give your :class:`Enum` subclass extra methods, like the `Planet`_ "
"class above, those methods will show up in a :func:`dir` of the member, but "
"not of the class::"
msgstr ""
":class:`Enum` サブクラスに追加のメソッドを与えた場合、上述の `Planet`_ クラス"
"のように、そのメソッドはメンバーの :func:`dir` に表示されますが、クラスの :"
"func:`dir` には表示されません::"

#: ../../library/enum.rst:1189
msgid "Combining members of ``Flag``"
msgstr "Об'єднання членів ``Прапора``"

#: ../../library/enum.rst:1191
msgid ""
"If a combination of Flag members is not named, the :func:`repr` will include "
"all named flags and all named combinations of flags that are in the value::"
msgstr ""
"Flag メンバーの組み合わせに名前が無い場合、 :func:`repr` の出力には、その値に"
"ある全ての名前を持つフラグと全ての名前を持つ組み合わせが含まれます::"

#: ../../library/enum.rst:1209
msgid ""
"In 3.11 unnamed combinations of flags will only produce the canonical flag "
"members (aka single-value flags).  So ``Color(7)`` would produce something "
"like ``<Color.BLUE|GREEN|RED: 7>``."
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Hildeberto Abreu Magalhães <hildeberto@gmail.com>, 2021
# Marco Rougeth <marco@rougeth.com>, 2021
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2021
# Humberto Rocha <humrochagf@gmail.com>, 2021
# Rafael Fontenelle <rffontenelle@gmail.com>, 2021
# Raphael Mendonça, 2021
# Italo Penaforte <italo.penaforte@gmail.com>, 2021
# i17obot <i17obot@rougeth.com>, 2021
# Vinicius Gubiani Ferreira <vini.g.fer@gmail.com>, 2021
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-08-18 13:46+0000\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: Vinicius Gubiani Ferreira <vini.g.fer@gmail.com>, 2021\n"
"Language-Team: Portuguese (Brazil) (https://www.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../library/asyncio-eventloop.rst:6
msgid "Event Loop"
msgstr "Laço de Eventos"

#: ../../library/asyncio-eventloop.rst:8
msgid ""
"**Source code:** :source:`Lib/asyncio/events.py`, :source:`Lib/asyncio/"
"base_events.py`"
msgstr ""
"**Código-fonte:** :source:`Lib/asyncio/events.py`, :source:`Lib/asyncio/"
"base_events.py`"

#: ../../library/asyncio-eventloop.rst:14
msgid "Preface"
msgstr "Prefácio"

#: ../../library/asyncio-eventloop.rst:15
msgid ""
"The event loop is the core of every asyncio application. Event loops run "
"asynchronous tasks and callbacks, perform network IO operations, and run "
"subprocesses."
msgstr ""
"O laço de eventos é o núcleo de toda aplicação asyncio. Laços de eventos "
"executam tarefas e funções de retorno assíncronas, realizam operações de "
"entrada e saída e executam subprocessos."

#: ../../library/asyncio-eventloop.rst:19
msgid ""
"Application developers should typically use the high-level asyncio "
"functions, such as :func:`asyncio.run`, and should rarely need to reference "
"the loop object or call its methods.  This section is intended mostly for "
"authors of lower-level code, libraries, and frameworks, who need finer "
"control over the event loop behavior."
msgstr ""
"Os desenvolvedores de aplicação normalmente devem usar as funções asyncio de "
"alto nível, como :func:`asyncio.run`, e devem raramente precisar fazer "
"referência ao objeto de loop ou chamar seus métodos. Esta seção destina-se "
"principalmente a autores de código de baixo nível, bibliotecas e frameworks, "
"que precisam de um controle mais preciso sobre o comportamento do laço de "
"evento."

#: ../../library/asyncio-eventloop.rst:26
msgid "Obtaining the Event Loop"
msgstr "Obtendo o laço de eventos"

#: ../../library/asyncio-eventloop.rst:27
msgid ""
"The following low-level functions can be used to get, set, or create an "
"event loop:"
msgstr ""
"As seguintes funções baixo nível podem ser usadas para obter, definir, ou "
"criar um laço de eventos:"

#: ../../library/asyncio-eventloop.rst:32
msgid "Return the running event loop in the current OS thread."
msgstr ""
"Retorna o laço de eventos em execução na thread atual do sistema operacional."

#: ../../library/asyncio-eventloop.rst:34
msgid ""
"If there is no running event loop a :exc:`RuntimeError` is raised. This "
"function can only be called from a coroutine or a callback."
msgstr ""
"Se não existir nenhum laço de eventos em execução, um :exc:`RuntimeError` é "
"levantado. Esta função somente pode ser chamada a partir de uma corrotina ou "
"uma função de retorno."

#: ../../library/asyncio-eventloop.rst:41
msgid "Get the current event loop."
msgstr "Obtém o laço de eventos atual."

#: ../../library/asyncio-eventloop.rst:43
msgid ""
"If there is no current event loop set in the current OS thread, the OS "
"thread is main, and :func:`set_event_loop` has not yet been called, asyncio "
"will create a new event loop and set it as the current one."
msgstr ""
"Se não existe nenhum laço de eventos definido na thread atual do sistema "
"operacional, é a thread principal do sistema operacional, e :func:"
"`set_event_loop` ainda não foi chamada, asyncio irá criar um novo laço de "
"eventos e defini-lo como o atual."

#: ../../library/asyncio-eventloop.rst:48
msgid ""
"Because this function has rather complex behavior (especially when custom "
"event loop policies are in use), using the :func:`get_running_loop` function "
"is preferred to :func:`get_event_loop` in coroutines and callbacks."
msgstr ""
"Devido ao fato desta função ter um comportamento particularmente complexo "
"(especialmente quando políticas de laço de eventos customizadas estão sendo "
"usadas), usar a função :func:`get_running_loop` é preferido ao invés de :"
"func:`get_event_loop` em corrotinas e funções de retorno."

#: ../../library/asyncio-eventloop.rst:53
msgid ""
"Consider also using the :func:`asyncio.run` function instead of using lower "
"level functions to manually create and close an event loop."
msgstr ""
"Considere também usar a função :func:`asyncio.run` ao invés de usar funções "
"de baixo nível para manualmente criar e fechar um laço de eventos."

#: ../../library/asyncio-eventloop.rst:56
msgid ""
"Deprecation warning is emitted if there is no running event loop. In future "
"Python releases, this function will be an alias of :func:`get_running_loop`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:63
msgid "Set *loop* as a current event loop for the current OS thread."
msgstr ""
"Define *loop* como o laço de eventos atual para a thread atual do sistema "
"operacional."

#: ../../library/asyncio-eventloop.rst:67
msgid "Create a new event loop object."
msgstr "Cria um novo objeto de laço de eventos."

#: ../../library/asyncio-eventloop.rst:69
msgid ""
"Note that the behaviour of :func:`get_event_loop`, :func:`set_event_loop`, "
"and :func:`new_event_loop` functions can be altered by :ref:`setting a "
"custom event loop policy <asyncio-policies>`."
msgstr ""
"Perceba que o comportamento das funções :func:`get_event_loop`, :func:"
"`set_event_loop`, e :func:`new_event_loop` podem ser alteradas :ref:"
"`definindo uma política de laço de eventos customizada <asyncio-policies>`."

#: ../../library/asyncio-eventloop.rst:75
msgid "Contents"
msgstr "Conteúdo"

#: ../../library/asyncio-eventloop.rst:76
msgid "This documentation page contains the following sections:"
msgstr "Esta página de documentação contém as seguintes seções:"

#: ../../library/asyncio-eventloop.rst:78
msgid ""
"The `Event Loop Methods`_ section is the reference documentation of the "
"event loop APIs;"
msgstr ""
"A seção `Métodos do laço de eventos`_ é a documentação de referência das "
"APIs de laço de eventos;"

#: ../../library/asyncio-eventloop.rst:81
msgid ""
"The `Callback Handles`_ section documents the :class:`Handle` and :class:"
"`TimerHandle` instances which are returned from scheduling methods such as :"
"meth:`loop.call_soon` and :meth:`loop.call_later`;"
msgstr ""
"A seção `Tratadores de função de retorno`_ documenta as instâncias das "
"classes :class:`Handle` e :class:`TimerHandle`, que são retornadas por "
"métodos de agendamento tais como :meth:`loop.call_soon` e :meth:`loop."
"call_later`;"

#: ../../library/asyncio-eventloop.rst:85
msgid ""
"The `Server Objects`_ section documents types returned from event loop "
"methods like :meth:`loop.create_server`;"
msgstr ""
"A seção `Objetos Server`_ documenta tipos retornados a partir de métodos de "
"laço de eventos, como :meth:`loop.create_server`;"

#: ../../library/asyncio-eventloop.rst:88
msgid ""
"The `Event Loop Implementations`_ section documents the :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop` classes;"
msgstr ""
"A seção `Implementações do Laço de Eventos`_ documenta as classes :class:"
"`SelectorEventLoop` e :class:`ProactorEventLoop`;"

#: ../../library/asyncio-eventloop.rst:91
msgid ""
"The `Examples`_ section showcases how to work with some event loop APIs."
msgstr ""
"A seção `Exemplos`_ demonstra como trabalhar com algumas APIs do laço de "
"eventos APIs."

#: ../../library/asyncio-eventloop.rst:98
msgid "Event Loop Methods"
msgstr "Métodos do laço de eventos"

#: ../../library/asyncio-eventloop.rst:100
msgid "Event loops have **low-level** APIs for the following:"
msgstr ""
"Laços de eventos possuem APIs de **baixo nível** para as seguintes situações:"

#: ../../library/asyncio-eventloop.rst:108
msgid "Running and stopping the loop"
msgstr "Executar e interromper o laço"

#: ../../library/asyncio-eventloop.rst:112
msgid "Run until the *future* (an instance of :class:`Future`) has completed."
msgstr ""
"Executar até que o *future* (uma instância da classe :class:`Future`) seja "
"completada."

#: ../../library/asyncio-eventloop.rst:115
msgid ""
"If the argument is a :ref:`coroutine object <coroutine>` it is implicitly "
"scheduled to run as a :class:`asyncio.Task`."
msgstr ""
"Se o argumento é um :ref:`objeto corrotina <coroutine>`, ele é "
"implicitamente agendado para executar como uma :class:`asyncio.Task`."

#: ../../library/asyncio-eventloop.rst:118
msgid "Return the Future's result or raise its exception."
msgstr "Retorna o resultado do Future ou levanta sua exceção."

#: ../../library/asyncio-eventloop.rst:122
msgid "Run the event loop until :meth:`stop` is called."
msgstr "Executa o laço de eventos até que :meth:`stop` seja chamado."

#: ../../library/asyncio-eventloop.rst:124
msgid ""
"If :meth:`stop` is called before :meth:`run_forever()` is called, the loop "
"will poll the I/O selector once with a timeout of zero, run all callbacks "
"scheduled in response to I/O events (and those that were already scheduled), "
"and then exit."
msgstr ""
"Se :meth:`stop` for chamado antes que :meth:`run_forever()` seja chamado, o "
"laço  irá pesquisar o seletor de E/S uma vez com um tempo limite de zero, "
"executar todas as funções de retorno agendadas na resposta de eventos de E/S "
"(e aqueles que já estavam agendados), e então sair."

#: ../../library/asyncio-eventloop.rst:129
msgid ""
"If :meth:`stop` is called while :meth:`run_forever` is running, the loop "
"will run the current batch of callbacks and then exit. Note that new "
"callbacks scheduled by callbacks will not run in this case; instead, they "
"will run the next time :meth:`run_forever` or :meth:`run_until_complete` is "
"called."
msgstr ""
"Se :meth:`stop` for chamado enquanto :meth:`run_forever` estiver executando, "
"o laço irá executar o lote atual de funções de retorno e então sair. Perceba "
"que novas funções de retorno agendadas por funções de retorno não serão "
"executadas neste caso; ao invés disso, elas serão executadas na próxima vez "
"que :meth:`run_forever` ou :meth:`run_until_complete` forem chamadas."

#: ../../library/asyncio-eventloop.rst:137
msgid "Stop the event loop."
msgstr "Para o laço de eventos."

#: ../../library/asyncio-eventloop.rst:141
msgid "Return ``True`` if the event loop is currently running."
msgstr "Retorna ``True`` se o laço de eventos estiver em execução."

#: ../../library/asyncio-eventloop.rst:145
msgid "Return ``True`` if the event loop was closed."
msgstr "Retorna ``True`` se o laço de eventos foi fechado."

#: ../../library/asyncio-eventloop.rst:149
msgid "Close the event loop."
msgstr "Fecha o laço de eventos."

#: ../../library/asyncio-eventloop.rst:151
msgid ""
"The loop must not be running when this function is called. Any pending "
"callbacks will be discarded."
msgstr ""
"O laço não deve estar em execução quando esta função for chamada. Qualquer "
"função de retorno pendente será descartada."

#: ../../library/asyncio-eventloop.rst:154
msgid ""
"This method clears all queues and shuts down the executor, but does not wait "
"for the executor to finish."
msgstr ""
"Este método limpa todas as filas e desliga o executor, mas não aguarda pelo "
"encerramento do executor."

#: ../../library/asyncio-eventloop.rst:157
msgid ""
"This method is idempotent and irreversible.  No other methods should be "
"called after the event loop is closed."
msgstr ""
"Este método é idempotente e irreversível. Nenhum outro método deve ser "
"chamado depois que o laço de eventos esteja fechado."

#: ../../library/asyncio-eventloop.rst:162
msgid ""
"Schedule all currently open :term:`asynchronous generator` objects to close "
"with an :meth:`~agen.aclose()` call.  After calling this method, the event "
"loop will issue a warning if a new asynchronous generator is iterated. This "
"should be used to reliably finalize all scheduled asynchronous generators."
msgstr ""
"Agenda todos os objetos :term:`geradores assíncronos <asynchronous "
"generator>` atualmente abertos para serem fechados com uma chamada :meth:"
"`~agen.aclose()`. Após chamar este método, o laço de eventos emitirá um "
"aviso se um novo gerador assíncrono for iterado. Isso deve ser utilizado "
"para finalizar  de forma confiável todos os geradores assíncronos agendados."

#: ../../library/asyncio-eventloop.rst:168
#: ../../library/asyncio-eventloop.rst:188
msgid ""
"Note that there is no need to call this function when :func:`asyncio.run` is "
"used."
msgstr ""
"Perceba que não é necessário chamar esta função quando :func:`asyncio.run` "
"for usado."

#: ../../library/asyncio-eventloop.rst:171
#: ../../library/asyncio-eventloop.rst:1083
#: ../../library/asyncio-eventloop.rst:1468
msgid "Example::"
msgstr "Exemplo::"

#: ../../library/asyncio-eventloop.rst:183
msgid ""
"Schedule the closure of the default executor and wait for it to join all of "
"the threads in the :class:`ThreadPoolExecutor`. After calling this method, "
"a :exc:`RuntimeError` will be raised if :meth:`loop.run_in_executor` is "
"called while using the default executor."
msgstr ""
"Agenda o encerramento do executor padrão e aguarda ele se juntar a todas as "
"threads no :class:`ThreadPoolExecutor`. Após chamar este método, um :exc:"
"`RuntimeError` será levantado se :meth:`loop.run_in_executor` for chamado "
"enquanto estiver usando o executor padrão."

#: ../../library/asyncio-eventloop.rst:195
msgid "Scheduling callbacks"
msgstr "Agendando funções de retorno"

#: ../../library/asyncio-eventloop.rst:199
msgid ""
"Schedule the *callback* :term:`callback` to be called with *args* arguments "
"at the next iteration of the event loop."
msgstr ""
"Agenda a *função de retorno* :term:`callback` para ser chamada com "
"argumentos *args* na próxima iteração do laço de eventos."

#: ../../library/asyncio-eventloop.rst:202
msgid ""
"Callbacks are called in the order in which they are registered. Each "
"callback will be called exactly once."
msgstr ""
"Funções de retorno são chamadas na ordem em que elas foram registradas. Cada "
"função de retorno será chamada exatamente uma vez."

#: ../../library/asyncio-eventloop.rst:205
#: ../../library/asyncio-eventloop.rst:272
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"Um argumento opcional somente-nomeado *context* permite especificar um :"
"class:`contextvars.Context` customizado para executar na *função de "
"retorno*. O contexto atual é usado quando nenhum *context* é fornecido."

#: ../../library/asyncio-eventloop.rst:209
msgid ""
"An instance of :class:`asyncio.Handle` is returned, which can be used later "
"to cancel the callback."
msgstr ""
"Uma instância de :class:`asyncio.Handle` é retornado, o qual pode ser usado "
"posteriormente para cancelar a função de retorno."

#: ../../library/asyncio-eventloop.rst:212
msgid "This method is not thread-safe."
msgstr "Este método não é seguro para thread."

#: ../../library/asyncio-eventloop.rst:216
msgid ""
"A thread-safe variant of :meth:`call_soon`.  Must be used to schedule "
"callbacks *from another thread*."
msgstr ""
"Uma variante segura para thread do :meth:`call_soon`. Deve ser usada para "
"agendar funções de retorno *a partir de outra thread*."

#: ../../library/asyncio-eventloop.rst:219
msgid ""
"Raises :exc:`RuntimeError` if called on a loop that's been closed. This can "
"happen on a secondary thread when the main application is shutting down."
msgstr ""

#: ../../library/asyncio-eventloop.rst:223
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Veja a seção :ref:`concorrência e multithreading <asyncio-multithreading>` "
"da documentação."

#: ../../library/asyncio-eventloop.rst:226
#: ../../library/asyncio-eventloop.rst:276
#: ../../library/asyncio-eventloop.rst:296
msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr ""
"O parâmetro somente-nomeado *context* foi adicionado. Veja :pep:`567` para "
"mais detalhes."

#: ../../library/asyncio-eventloop.rst:234
msgid ""
"Most :mod:`asyncio` scheduling functions don't allow passing keyword "
"arguments.  To do that, use :func:`functools.partial`::"
msgstr ""
"Maior parte das funções de agendamento :mod:`asyncio` não permite passar "
"argumentos nomeados. Para fazer isso, use :func:`functools.partial`::"

#: ../../library/asyncio-eventloop.rst:241
msgid ""
"Using partial objects is usually more convenient than using lambdas, as "
"asyncio can render partial objects better in debug and error messages."
msgstr ""
"Usar objetos parciais é usualmente mais conveniente que usar lambdas, pois "
"asyncio pode renderizar objetos parciais melhor durante debug e mensagens de "
"erro."

#: ../../library/asyncio-eventloop.rst:249
msgid "Scheduling delayed callbacks"
msgstr "Agendando funções de retorno atrasadas"

#: ../../library/asyncio-eventloop.rst:251
msgid ""
"Event loop provides mechanisms to schedule callback functions to be called "
"at some point in the future.  Event loop uses monotonic clocks to track time."
msgstr ""
"Laço de eventos fornece mecanismos para agendar funções de retorno para "
"serem chamadas em algum ponto no futuro. Laço de eventos usa relógios "
"monotônico para acompanhar o tempo."

#: ../../library/asyncio-eventloop.rst:258
msgid ""
"Schedule *callback* to be called after the given *delay* number of seconds "
"(can be either an int or a float)."
msgstr ""
"Agenda *callback* para ser chamada após o *delay* número de segundos "
"fornecido (pode ser um inteiro ou um ponto flutuante)."

#: ../../library/asyncio-eventloop.rst:261
#: ../../library/asyncio-eventloop.rst:293
msgid ""
"An instance of :class:`asyncio.TimerHandle` is returned which can be used to "
"cancel the callback."
msgstr ""
"Uma instância de :class:`asyncio.TimerHandle` é retornada, a qual pode ser "
"usada para cancelar a função de retorno."

#: ../../library/asyncio-eventloop.rst:264
msgid ""
"*callback* will be called exactly once.  If two callbacks are scheduled for "
"exactly the same time, the order in which they are called is undefined."
msgstr ""
"*callback* será chamada exatamente uma vez. Se duas funções de retorno são "
"agendadas para exatamente o mesmo tempo, a ordem na qual elas são chamadas é "
"indefinida."

#: ../../library/asyncio-eventloop.rst:268
msgid ""
"The optional positional *args* will be passed to the callback when it is "
"called. If you want the callback to be called with keyword arguments use :"
"func:`functools.partial`."
msgstr ""
"O *args* posicional opcional será passado para a função de retorno quando "
"ela for chamada. Se você quiser que a função de retorno seja chamada com "
"argumentos nomeados, use :func:`functools.partial`."

#: ../../library/asyncio-eventloop.rst:280
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"*delay* could not exceed one day. This has been fixed in Python 3.8."
msgstr ""
"No Python 3.7 e anterior, com a implementação padrão do laço de eventos, o "
"*delay* não poderia exceder um dia. Isto foi ajustado no Python 3.8."

#: ../../library/asyncio-eventloop.rst:287
msgid ""
"Schedule *callback* to be called at the given absolute timestamp *when* (an "
"int or a float), using the same time reference as :meth:`loop.time`."
msgstr ""
"Agenda *callback* para ser chamada no timestamp absoluto fornecido *when* "
"(um inteiro ou um ponto flutuante), usando o mesmo horário de referência "
"que :meth:`loop.time`."

#: ../../library/asyncio-eventloop.rst:291
msgid "This method's behavior is the same as :meth:`call_later`."
msgstr "O comportamento deste método é o mesmo que :meth:`call_later`."

#: ../../library/asyncio-eventloop.rst:300
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"difference between *when* and the current time could not exceed one day.  "
"This has been fixed in Python 3.8."
msgstr ""
"No Python 3.7 e anterior, com a implementação padrão do laço de eventos, a "
"diferença entre *when* e o horário atual não poderia exceder um dia. Isto "
"foi ajustado no Python 3.8."

#: ../../library/asyncio-eventloop.rst:307
msgid ""
"Return the current time, as a :class:`float` value, according to the event "
"loop's internal monotonic clock."
msgstr ""
"Retorna o horário atual, como um valor :class:`float`, de acordo com o "
"relógio monotônico interno do laço de eventos."

#: ../../library/asyncio-eventloop.rst:311
msgid ""
"In Python 3.7 and earlier timeouts (relative *delay* or absolute *when*) "
"should not exceed one day.  This has been fixed in Python 3.8."
msgstr ""
"No Python 3.7 e anterior, tempos limites (*delay* relativo ou *when* "
"absoluto) não poderiam exceder um dia. Isto foi ajustado no Python 3.8."

#: ../../library/asyncio-eventloop.rst:317
msgid "The :func:`asyncio.sleep` function."
msgstr "A função :func:`asyncio.sleep`."

#: ../../library/asyncio-eventloop.rst:321
msgid "Creating Futures and Tasks"
msgstr "Criando Futures e Tasks"

#: ../../library/asyncio-eventloop.rst:325
msgid "Create an :class:`asyncio.Future` object attached to the event loop."
msgstr "Cria um objeto :class:`asyncio.Future` atachado ao laço de eventos."

#: ../../library/asyncio-eventloop.rst:327
msgid ""
"This is the preferred way to create Futures in asyncio. This lets third-"
"party event loops provide alternative implementations of the Future object "
"(with better performance or instrumentation)."
msgstr ""
"Este é o modo preferido para criar Futures em asyncio. Isto permite que "
"laços de eventos de terceiros forneçam implementações alternativas do objeto "
"Future (com melhor desempenho ou instrumentação)."

#: ../../library/asyncio-eventloop.rst:335
msgid ""
"Schedule the execution of a :ref:`coroutine`. Return a :class:`Task` object."
msgstr ""
"Agenda a execução de uma :ref:`corrotina <coroutine>`. Retorna um objeto :"
"class:`Task`."

#: ../../library/asyncio-eventloop.rst:338
msgid ""
"Third-party event loops can use their own subclass of :class:`Task` for "
"interoperability. In this case, the result type is a subclass of :class:"
"`Task`."
msgstr ""
"Laços de eventos de terceiros podem usar suas próprias subclasses de :class:"
"`Task` para interoperabilidade. Neste caso, o tipo do resultado é uma "
"subclasse de :class:`Task`."

#: ../../library/asyncio-eventloop.rst:342
msgid ""
"If the *name* argument is provided and not ``None``, it is set as the name "
"of the task using :meth:`Task.set_name`."
msgstr ""
"Se o argumento *name* for fornecido e não é ``None``, ele é definido como o "
"nome da tarefa, usando :meth:`Task.set_name`."

#: ../../library/asyncio-eventloop.rst:345
msgid "Added the ``name`` parameter."
msgstr "Adicionado o parâmetro ``name``."

#: ../../library/asyncio-eventloop.rst:350
msgid "Set a task factory that will be used by :meth:`loop.create_task`."
msgstr ""
"Define a factory da tarefa que será usada por :meth:`loop.create_task`."

#: ../../library/asyncio-eventloop.rst:353
msgid ""
"If *factory* is ``None`` the default task factory will be set. Otherwise, "
"*factory* must be a *callable* with the signature matching ``(loop, coro)``, "
"where *loop* is a reference to the active event loop, and *coro* is a "
"coroutine object.  The callable must return a :class:`asyncio.Future`-"
"compatible object."
msgstr ""
"Se *factory* for ``None``, a factory da task padrão será definida. Caso "
"contrário, *factory* deve ser algo *chamável* com a assinatura coincidindo "
"com ``(loop, coro)``, onde *loop* é uma referência para o laço de eventos "
"ativo, e *coro* é um objeto corrotina. O objeto chamável deve retornar um "
"objeto compatível com :class:`asyncio.Future`."

#: ../../library/asyncio-eventloop.rst:361
msgid "Return a task factory or ``None`` if the default one is in use."
msgstr ""
"Retorna uma factory de tarefa ou ``None`` se a factory padrão estiver em uso."

#: ../../library/asyncio-eventloop.rst:365
msgid "Opening network connections"
msgstr "Abrindo conexões de rede"

#: ../../library/asyncio-eventloop.rst:374
msgid ""
"Open a streaming transport connection to a given address specified by *host* "
"and *port*."
msgstr ""
"Abre uma conexão de transporte para streaming, para um endereço fornecido, "
"especificado por *host* e *port*."

#: ../../library/asyncio-eventloop.rst:377
msgid ""
"The socket family can be either :py:data:`~socket.AF_INET` or :py:data:"
"`~socket.AF_INET6` depending on *host* (or the *family* argument, if "
"provided)."
msgstr ""
"A família de soquetes pode ser :py:data:`~socket.AF_INET` ou :py:data:"
"`~socket.AF_INET6` dependendo do *host* (ou do argumento *family*, se "
"fornecido)."

#: ../../library/asyncio-eventloop.rst:381
msgid "The socket type will be :py:data:`~socket.SOCK_STREAM`."
msgstr "O tipo de soquete será :py:data:`~socket.SOCK_STREAM`."

#: ../../library/asyncio-eventloop.rst:383
#: ../../library/asyncio-eventloop.rst:999
#: ../../library/asyncio-eventloop.rst:1015
msgid ""
"*protocol_factory* must be a callable returning an :ref:`asyncio protocol "
"<asyncio-protocol>` implementation."
msgstr ""
"*protocol_factory* deve ser um chamável que retorne uma implementação do :"
"ref:`protocolo asyncio <asyncio-protocol>`."

#: ../../library/asyncio-eventloop.rst:386
msgid ""
"This method will try to establish the connection in the background. When "
"successful, it returns a ``(transport, protocol)`` pair."
msgstr ""
"Este método tentará estabelecer a conexão em segundo plano. Quando tiver "
"sucesso, ele retorna um par ``(transport, protocol)``."

#: ../../library/asyncio-eventloop.rst:389
msgid "The chronological synopsis of the underlying operation is as follows:"
msgstr "A sinopse cronológica da operação subjacente é conforme abaixo:"

#: ../../library/asyncio-eventloop.rst:391
msgid ""
"The connection is established and a :ref:`transport <asyncio-transport>` is "
"created for it."
msgstr ""
"A conexão é estabelecida e um :ref:`transporte <asyncio-transport>` é criado "
"para ela."

#: ../../library/asyncio-eventloop.rst:394
msgid ""
"*protocol_factory* is called without arguments and is expected to return a :"
"ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"*protocol_factory* é chamada sem argumentos e é esperada que retorne uma "
"instância de :ref:`protocolo <asyncio-protocol>`."

#: ../../library/asyncio-eventloop.rst:397
msgid ""
"The protocol instance is coupled with the transport by calling its :meth:"
"`~BaseProtocol.connection_made` method."
msgstr ""
"A instância de protocolo é acoplada com o transporte, através da chamada do "
"seu método :meth:`~BaseProtocol.connection_made`."

#: ../../library/asyncio-eventloop.rst:400
msgid "A ``(transport, protocol)`` tuple is returned on success."
msgstr "Uma tupla ``(transport, protocol)`` é retornada ao ter sucesso."

#: ../../library/asyncio-eventloop.rst:402
msgid ""
"The created transport is an implementation-dependent bidirectional stream."
msgstr ""
"O transporte criado é um stream bi-direcional dependente de implementação."

#: ../../library/asyncio-eventloop.rst:405
#: ../../library/asyncio-eventloop.rst:527
msgid "Other arguments:"
msgstr "Outros argumentos:"

#: ../../library/asyncio-eventloop.rst:407
msgid ""
"*ssl*: if given and not false, a SSL/TLS transport is created (by default a "
"plain TCP transport is created).  If *ssl* is a :class:`ssl.SSLContext` "
"object, this context is used to create the transport; if *ssl* is :const:"
"`True`, a default context returned from :func:`ssl.create_default_context` "
"is used."
msgstr ""
"*ssl*: se fornecido e não for falso, um transporte SSL/TLS é criado (por "
"padrão um transporte TCP simples é criado). Se *ssl* for um objeto :class:"
"`ssl.SSLContext`, este contexto é usado para criar o transporte; se *ssl* "
"for :const:`True`, um contexto padrão retornado de :func:`ssl."
"create_default_context` é usado."

#: ../../library/asyncio-eventloop.rst:413
msgid ":ref:`SSL/TLS security considerations <ssl-security>`"
msgstr ":ref:`Considerações de segurança sobre SSL/TLS <ssl-security>`"

#: ../../library/asyncio-eventloop.rst:415
msgid ""
"*server_hostname* sets or overrides the hostname that the target server's "
"certificate will be matched against.  Should only be passed if *ssl* is not "
"``None``.  By default the value of the *host* argument is used.  If *host* "
"is empty, there is no default and you must pass a value for "
"*server_hostname*.  If *server_hostname* is an empty string, hostname "
"matching is disabled (which is a serious security risk, allowing for "
"potential man-in-the-middle attacks)."
msgstr ""
"*server_hostname* define ou substitui o hostname que o certificado do "
"servidor de destino será pareado contra. Deve ser passado apenas se *ssl* "
"não for ``None``. Por padrão o valor do argumento *host* é usado. Se *host* "
"for vazio, não existe valor padrão e você deve passar um valor para "
"*server_hostname*. Se *server_hostname* for uma string vazia, o pareamento "
"de hostname é desabilitado (o que é um risco de segurança sério, permitindo "
"ataques potenciais man-in-the-middle)."

#: ../../library/asyncio-eventloop.rst:423
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to getaddrinfo() for *host* resolution. If given, "
"these should all be integers from the corresponding :mod:`socket` module "
"constants."
msgstr ""
"*family*, *proto*, *flags* são os endereços familiares, protocolos e "
"sinalizadores opcionais a serem passados por getaddrinfo() para resolução do "
"*host*. Se fornecidos, eles devem ser todos inteiros e constantes "
"correspondentes do módulo :mod:`socket`."

#: ../../library/asyncio-eventloop.rst:428
msgid ""
"*happy_eyeballs_delay*, if given, enables Happy Eyeballs for this "
"connection. It should be a floating-point number representing the amount of "
"time in seconds to wait for a connection attempt to complete, before "
"starting the next attempt in parallel. This is the \"Connection Attempt Delay"
"\" as defined in :rfc:`8305`. A sensible default value recommended by the "
"RFC is ``0.25`` (250 milliseconds)."
msgstr ""
"*happy_eyeballs_delay*, se fornecido, habilita Happy Eyeballs para esta "
"conexão. Ele deve ser um número de ponto flutuante representando o tempo em "
"segundos para aguardar uma tentativa de conexão encerrar, antes de começar a "
"próxima tentativa em paralelo. Este é o \"Atraso na tentativa de conexão\" "
"conforme definido na :rfc:`8305`. Um valor padrão sensível recomendado pela  "
"RFC é``0.25`` (250 millisegundos)."

#: ../../library/asyncio-eventloop.rst:436
msgid ""
"*interleave* controls address reordering when a host name resolves to "
"multiple IP addresses. If ``0`` or unspecified, no reordering is done, and "
"addresses are tried in the order returned by :meth:`getaddrinfo`. If a "
"positive integer is specified, the addresses are interleaved by address "
"family, and the given integer is interpreted as \"First Address Family Count"
"\" as defined in :rfc:`8305`. The default is ``0`` if *happy_eyeballs_delay* "
"is not specified, and ``1`` if it is."
msgstr ""
"*interleave* controla o reordenamento de endereços quando um nome de "
"servidor resolve para múltiplos endereços IP. Se ``0`` ou não especificado, "
"nenhum reordenamento é feito, e endereços são tentados na ordem retornada "
"por :meth:`getaddrinfo`. Se um inteiro positivo for especificado, os "
"endereços são intercalados por um endereço familiar, e o inteiro fornecido é "
"interpretado como \"Contagem da família do primeiro endereço\" conforme "
"definido na :rfc:`8305`. O padrão é ``0`` se *happy_eyeballs_delay* não for "
"especificado, e ``1`` se ele for."

#: ../../library/asyncio-eventloop.rst:445
msgid ""
"*sock*, if given, should be an existing, already connected :class:`socket."
"socket` object to be used by the transport. If *sock* is given, none of "
"*host*, *port*, *family*, *proto*, *flags*, *happy_eyeballs_delay*, "
"*interleave* and *local_addr* should be specified."
msgstr ""
"*sock*, se fornecido, deve ser um objeto :class:`socket.socket` já "
"existente, já conectado, para ser usado por transporte. Se *sock* é "
"fornecido, *host*, *port*, *family*, *proto*, *flags*, "
"*happy_eyeballs_delay*, *interleave* e *local_addr* não devem ser "
"especificados."

#: ../../library/asyncio-eventloop.rst:451
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket locally.  The *local_host* and *local_port* are looked up using "
"``getaddrinfo()``, similarly to *host* and *port*."
msgstr ""
"*local_addr*, se fornecido, é uma tupla de ``(local_host, local_port)`` "
"usada para se ligar ao soquete localmente. O *local_host* e a *local_port* "
"são procurados usando ``getaddrinfo()``, de forma similar para *host* e "
"*port*."

#: ../../library/asyncio-eventloop.rst:455
#: ../../library/asyncio-eventloop.rst:808
msgid ""
"*ssl_handshake_timeout* is (for a TLS connection) the time in seconds to "
"wait for the TLS handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* é (para uma conexão TLS) o tempo em segundos para "
"aguardar pelo encerramento do aperto de mão TLS, antes de abortar a conexão. "
"``60.0`` segundos se for``None`` (valor padrão)."

#: ../../library/asyncio-eventloop.rst:461
msgid "Added the *happy_eyeballs_delay* and *interleave* parameters."
msgstr "Adicionado os parâmetros *happy_eyeballs_delay* e *interleave*."

#: ../../library/asyncio-eventloop.rst:463
msgid ""
"Happy Eyeballs Algorithm: Success with Dual-Stack Hosts. When a server's "
"IPv4 path and protocol are working, but the server's IPv6 path and protocol "
"are not working, a dual-stack client application experiences significant "
"connection delay compared to an IPv4-only client.  This is undesirable "
"because it causes the dual- stack client to have a worse user experience.  "
"This document specifies requirements for algorithms that reduce this user-"
"visible delay and provides an algorithm."
msgstr ""
"Algoritmo Happy Eyeballs: Sucesso com servidores de pilha dupla. Quando o "
"endereço e protocolo de um servidor IPv4 estão funcionando, mas o endereço e "
"protocolo de um servidor IPv6 não estão, uma aplicação cliente de pilha "
"dupla experiência atraso de conexão significativo comparado com um cliente "
"puramente IPv4. Isso é indesejável porque causa o cliente de pilha dupla a "
"ter uma experiência de usuário pior. Este documento espeifica requisitos "
"para algoritmos, que reduzem esse atraso visível pelo usuário e fornece um "
"algoritmo."

#: ../../library/asyncio-eventloop.rst:472
msgid "For more information: https://tools.ietf.org/html/rfc6555"
msgstr "Para mais informações: https://tools.ietf.org/html/rfc6555"

#: ../../library/asyncio-eventloop.rst:476
#: ../../library/asyncio-eventloop.rst:593
#: ../../library/asyncio-eventloop.rst:746
msgid "The *ssl_handshake_timeout* parameter."
msgstr "O parâmetro *ssl_handshake_timeout*."

#: ../../library/asyncio-eventloop.rst:480
#: ../../library/asyncio-eventloop.rst:676
msgid ""
"The socket option :py:data:`~socket.TCP_NODELAY` is set by default for all "
"TCP connections."
msgstr ""
"A opção de soquete :py:data:`~socket.TCP_NODELAY` é definida por padrão para "
"todas as conexões TCP."

#: ../../library/asyncio-eventloop.rst:485
#: ../../library/asyncio-eventloop.rst:681
msgid "Added support for SSL/TLS in :class:`ProactorEventLoop`."
msgstr "Adicionado suporte para SSL/TLS na :class:`ProactorEventLoop`."

#: ../../library/asyncio-eventloop.rst:489
msgid ""
"The :func:`open_connection` function is a high-level alternative API.  It "
"returns a pair of (:class:`StreamReader`, :class:`StreamWriter`) that can be "
"used directly in async/await code."
msgstr ""
"A função :func:`open_connection` é uma API alternativa de alto nível. Ela "
"retorna um par de (:class:`StreamReader`, :class:`StreamWriter`) que pode "
"ser usado diretamente em código async/await."

#: ../../library/asyncio-eventloop.rst:500
msgid ""
"The parameter *reuse_address* is no longer supported, as using :py:data:"
"`~sockets.SO_REUSEADDR` poses a significant security concern for UDP. "
"Explicitly passing ``reuse_address=True`` will raise an exception."
msgstr ""
"O parâmetro *reuse_address* não é mais suportado, assim como usar :py:data:"
"`~sockets.SO_REUSEADDR` representa uma preocupação de segurança "
"significativa para UDP. Passar ``reuse_address=True`` explicitamente irá "
"levantar uma exceção."

#: ../../library/asyncio-eventloop.rst:504
msgid ""
"When multiple processes with differing UIDs assign sockets to an identical "
"UDP socket address with ``SO_REUSEADDR``, incoming packets can become "
"randomly distributed among the sockets."
msgstr ""
"Quando múltiplos processos com diferentes UIDs atribuem soquetes para um "
"endereço de soquete UDP idêntico com ``SO_REUSEADDR``, pacotes recebidos "
"podem ser distribuídos aleatoriamente entre os soquetes."

#: ../../library/asyncio-eventloop.rst:508
msgid ""
"For supported platforms, *reuse_port* can be used as a replacement for "
"similar functionality. With *reuse_port*, :py:data:`~sockets.SO_REUSEPORT` "
"is used instead, which specifically prevents processes with differing UIDs "
"from assigning sockets to the same socket address."
msgstr ""
"Para plataformas suportadas, *reuse_port* pode ser usado como um substituto "
"para funcionalidades similares. Com *reuse_port*, :py:data:`~sockets."
"SO_REUSEPORT` é usado ao invés, o qual especificamente previne processos com "
"diferentes UIDs de atribuir soquetes para o mesmo endereço do soquete."

#: ../../library/asyncio-eventloop.rst:514
msgid "Create a datagram connection."
msgstr "Cria uma conexão de datagrama."

#: ../../library/asyncio-eventloop.rst:516
msgid ""
"The socket family can be either :py:data:`~socket.AF_INET`, :py:data:"
"`~socket.AF_INET6`, or :py:data:`~socket.AF_UNIX`, depending on *host* (or "
"the *family* argument, if provided)."
msgstr ""
"A família de soquetes pode ser :py:data:`~socket.AF_INET`, :py:data:`~socket."
"AF_INET6`, ou :py:data:`~socket.AF_UNIX`, dependendo do *host* (ou do "
"argumento *family*, se fornecido)."

#: ../../library/asyncio-eventloop.rst:520
msgid "The socket type will be :py:data:`~socket.SOCK_DGRAM`."
msgstr "O tipo de soquete será :py:data:`~socket.SOCK_DGRAM`."

#: ../../library/asyncio-eventloop.rst:522
#: ../../library/asyncio-eventloop.rst:618
#: ../../library/asyncio-eventloop.rst:729
msgid ""
"*protocol_factory* must be a callable returning a :ref:`protocol <asyncio-"
"protocol>` implementation."
msgstr ""
"*protocol_factory* deve ser algo chamável, retornando uma implementação de :"
"ref:`protocolo <asyncio-protocol>`."

#: ../../library/asyncio-eventloop.rst:525
#: ../../library/asyncio-eventloop.rst:579
msgid "A tuple of ``(transport, protocol)`` is returned on success."
msgstr "Uma tupla de ``(transport, protocol)`` é retornada em caso de sucesso."

#: ../../library/asyncio-eventloop.rst:529
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket locally.  The *local_host* and *local_port* are looked up using :"
"meth:`getaddrinfo`."
msgstr ""
"*local_addr*, se fornecido, é uma tupla de ``(local_host, local_port)`` "
"usada para ligar o soquete localmente. O *local_host* e a *local_port* são "
"procurados usando :meth:`getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:533
msgid ""
"*remote_addr*, if given, is a ``(remote_host, remote_port)`` tuple used to "
"connect the socket to a remote address.  The *remote_host* and *remote_port* "
"are looked up using :meth:`getaddrinfo`."
msgstr ""
"*remote_addr*, se fornecido, é uma tupla de ``(remote_host, remote_port)`` "
"usada para conectar o soquete a um endereço remoto. O *remote_host* e a "
"*remote_port* são procurados usando :meth:`getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:537
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to :meth:`getaddrinfo` for *host* resolution. If "
"given, these should all be integers from the corresponding :mod:`socket` "
"module constants."
msgstr ""
"*family*, *proto*, *flags* são os endereços familiares, protocolo e flags "
"opcionais a serem passados para :meth:`getaddrinfo` para resolução do "
"*host*. Se fornecido, esses devem ser todos inteiros do módulo de "
"constantes :mod:`socket` correspondente."

#: ../../library/asyncio-eventloop.rst:542
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows and some "
"Unixes. If the :py:data:`~socket.SO_REUSEPORT` constant is not defined then "
"this capability is unsupported."
msgstr ""
"*reuse_port* avisa o kernel para permitir este endpoint para ser ligado a "
"mesma porta da mesma forma que outros endpoints existentes estão ligados a, "
"contanto que todos eles definam este flag quando forem criados. Esta opção "
"não é suportada no Windows e em alguns sistemas Unix. Se a constante :py:"
"data:`~socket.SO_REUSEPORT` não estiver definida, então esta capacidade não "
"é suportada."

#: ../../library/asyncio-eventloop.rst:548
msgid ""
"*allow_broadcast* tells the kernel to allow this endpoint to send messages "
"to the broadcast address."
msgstr ""
"*allow_broadcast* avisa o kernel para permitir que este endpoint envie "
"mensagens para o endereço de broadcast."

#: ../../library/asyncio-eventloop.rst:551
msgid ""
"*sock* can optionally be specified in order to use a preexisting, already "
"connected, :class:`socket.socket` object to be used by the transport. If "
"specified, *local_addr* and *remote_addr* should be omitted (must be :const:"
"`None`)."
msgstr ""
"*sock* pode opcionalmente ser especificado em ordem para usar um objeto :"
"class:`socket.socket` pre-existente, já conectado, para ser usado pelo "
"transporte. Se especificado, *local_addr* e *remote_addr* devem ser omitidos "
"(devem ser :const:`None`)."

#: ../../library/asyncio-eventloop.rst:556
msgid ""
"See :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` and :"
"ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` examples."
msgstr ""
"Veja :ref:`protocolo UDP eco cliente <asyncio-udp-echo-client-protocol>` e :"
"ref:`protocolo UDP eco servidor <asyncio-udp-echo-server-protocol>` para "
"exemplos."

#: ../../library/asyncio-eventloop.rst:559
msgid ""
"The *family*, *proto*, *flags*, *reuse_address*, *reuse_port, "
"*allow_broadcast*, and *sock* parameters were added."
msgstr ""
"Os parâmetros *family*, *proto*, *flags*, *reuse_address*, *reuse_port, "
"*allow_broadcast*, e *sock* foram adicionados."

#: ../../library/asyncio-eventloop.rst:563
msgid ""
"The *reuse_address* parameter is no longer supported due to security "
"concerns."
msgstr ""
"O parâmetro *reuse_address* não é mais suportado devido a preocupações de "
"segurança."

#: ../../library/asyncio-eventloop.rst:567
msgid "Added support for Windows."
msgstr "Adicionado suporte para Windows."

#: ../../library/asyncio-eventloop.rst:574
msgid "Create a Unix connection."
msgstr "Cria uma conexão Unix."

#: ../../library/asyncio-eventloop.rst:576
msgid ""
"The socket family will be :py:data:`~socket.AF_UNIX`; socket type will be :"
"py:data:`~socket.SOCK_STREAM`."
msgstr ""
"A família de soquete será :py:data:`~socket.AF_UNIX`; o tipo de soquete "
"será :py:data:`~socket.SOCK_STREAM`."

#: ../../library/asyncio-eventloop.rst:581
msgid ""
"*path* is the name of a Unix domain socket and is required, unless a *sock* "
"parameter is specified.  Abstract Unix sockets, :class:`str`, :class:"
"`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* é o nome de um soquete de domínio Unix e é obrigatório, a não ser que "
"um parâmetro *sock* seja esecificado. Soquetes Unix abstratos, :class:"
"`str`, :class:`bytes`, e caminhos :class:`~pathlib.Path` são suportados."

#: ../../library/asyncio-eventloop.rst:586
msgid ""
"See the documentation of the :meth:`loop.create_connection` method for "
"information about arguments to this method."
msgstr ""
"Veja a documentação do método :meth:`loop.create_connection` para "
"informações a respeito de argumentos para este método."

#: ../../library/asyncio-eventloop.rst:590
#: ../../library/asyncio-eventloop.rst:710
#: ../../library/asyncio-eventloop.rst:1066
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`Disponibilidade <availability>`: Unix."

#: ../../library/asyncio-eventloop.rst:597
msgid "The *path* parameter can now be a :term:`path-like object`."
msgstr ""
"O parâmetro *path* agora pode ser um :term:`objeto caminho ou similar <path-"
"like object>`."

#: ../../library/asyncio-eventloop.rst:601
msgid "Creating network servers"
msgstr "Criando servidores de rede"

#: ../../library/asyncio-eventloop.rst:611
msgid ""
"Create a TCP server (socket type :data:`~socket.SOCK_STREAM`) listening on "
"*port* of the *host* address."
msgstr ""
"Cria um servidor TCP (tipo de soquete :data:`~socket.SOCK_STREAM`) escutando "
"em *port* do entedeço *host*."

#: ../../library/asyncio-eventloop.rst:614
msgid "Returns a :class:`Server` object."
msgstr "Retorna um objeto :class:`Server`."

#: ../../library/asyncio-eventloop.rst:616
msgid "Arguments:"
msgstr "Argumentos:"

#: ../../library/asyncio-eventloop.rst:621
msgid ""
"The *host* parameter can be set to several types which determine where the "
"server would be listening:"
msgstr ""
"O parâmetro *host* pode ser definido para diversos tipos, o qual determina "
"onde o servidor deve escutar:"

#: ../../library/asyncio-eventloop.rst:624
msgid ""
"If *host* is a string, the TCP server is bound to a single network interface "
"specified by *host*."
msgstr ""
"Se *host* for uma string, o servidor TCP está vinculado a apenas uma "
"interface de rede, especificada por *host*."

#: ../../library/asyncio-eventloop.rst:627
msgid ""
"If *host* is a sequence of strings, the TCP server is bound to all network "
"interfaces specified by the sequence."
msgstr ""
"Se *host* é uma sequência de strings, o servidor TCP está vinculado a todas "
"as interfaces de rede especificadas pela sequência."

#: ../../library/asyncio-eventloop.rst:630
msgid ""
"If *host* is an empty string or ``None``, all interfaces are assumed and a "
"list of multiple sockets will be returned (most likely one for IPv4 and "
"another one for IPv6)."
msgstr ""
"Se *host* é uma string vazia ou ``None``, todas as interfaces são assumidas "
"e uma lista de múltiplos soquetes será retornada (muito provavelmente um "
"para IPv4 e outro para IPv6)."

#: ../../library/asyncio-eventloop.rst:634
msgid ""
"*family* can be set to either :data:`socket.AF_INET` or :data:`~socket."
"AF_INET6` to force the socket to use IPv4 or IPv6. If not set, the *family* "
"will be determined from host name (defaults to :data:`~socket.AF_UNSPEC`)."
msgstr ""
"*family* pode ser definido para :data:`socket.AF_INET` ou :data:`~socket."
"AF_INET6` para forçar o soquete a usar IPv4 ou IPv6. Se não for definido, "
"*family* será determinado a partir do nome do servidor (por padrão será :"
"data:`~socket.AF_UNSPEC`)."

#: ../../library/asyncio-eventloop.rst:639
msgid "*flags* is a bitmask for :meth:`getaddrinfo`."
msgstr "*flags* é uma máscara de bits para :meth:`getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:641
msgid ""
"*sock* can optionally be specified in order to use a preexisting socket "
"object. If specified, *host* and *port* must not be specified."
msgstr ""
"*sock* pode opcionalmente ser especificado para usar um objeto soquete pré-"
"existente. Se especificado, *host* e *port* não devem ser especificados."

#: ../../library/asyncio-eventloop.rst:644
msgid ""
"*backlog* is the maximum number of queued connections passed to :meth:"
"`~socket.socket.listen` (defaults to 100)."
msgstr ""
"*backlog* é o número máximo de conexões enfileiradas pasadas para :meth:"
"`~socket.socket.listen` (padrão é 100)."

#: ../../library/asyncio-eventloop.rst:647
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` instance to enable TLS over "
"the accepted connections."
msgstr ""
"*ssl* pode ser definido para uma instância de :class:`~ssl.SSLContext` para "
"habilitar TLS sobre as conexões aceitas."

#: ../../library/asyncio-eventloop.rst:650
msgid ""
"*reuse_address* tells the kernel to reuse a local socket in ``TIME_WAIT`` "
"state, without waiting for its natural timeout to expire. If not specified "
"will automatically be set to ``True`` on Unix."
msgstr ""
"*reuse_address* diz ao kernel para reusar um soquete local em estado "
"``TIME_WAIT``, serm aguardar pela expiração natural do seu tempo limite. Se "
"não especificado, será automaticamente definida como ``True`` no Unix."

#: ../../library/asyncio-eventloop.rst:655
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows."
msgstr ""
"*reuse_port* diz ao kernel para permitir que este endpoint seja vinculado a "
"mesma porta que outros endpoints existentes estão vinculados, contanto que "
"todos eles definam este sinalizador quando forem criados. Esta opção não é "
"suportada no Windows."

#: ../../library/asyncio-eventloop.rst:660
msgid ""
"*ssl_handshake_timeout* is (for a TLS server) the time in seconds to wait "
"for the TLS handshake to complete before aborting the connection. ``60.0`` "
"seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* é (para um servidor TLS) o tempo em segundos para "
"aguardar pelo aperto de mão TLS ser concluído, antes de abortar a conexão. "
"``60.0`` segundos se ``None`` (valor padrão)."

#: ../../library/asyncio-eventloop.rst:664
msgid ""
"*start_serving* set to ``True`` (the default) causes the created server to "
"start accepting connections immediately.  When set to ``False``, the user "
"should await on :meth:`Server.start_serving` or :meth:`Server.serve_forever` "
"to make the server to start accepting connections."
msgstr ""
"Definir *start_serving* para ``True`` (o valor padrão) faz o servidor criado "
"começar a aceitar conexões imediatamente. Quando definido para ``False``, o "
"usuário deve aguardar com :meth:`Server.start_serving` ou :meth:`Server."
"serve_forever` para fazer o servidor começar a aceitar conexões."

#: ../../library/asyncio-eventloop.rst:672
msgid "Added *ssl_handshake_timeout* and *start_serving* parameters."
msgstr "Adicionado os parâmetros *ssl_handshake_timeout* e *start_serving*."

#: ../../library/asyncio-eventloop.rst:685
msgid "The *host* parameter can be a sequence of strings."
msgstr "O parâmetro *host* pode ser uma sequência de strings."

#: ../../library/asyncio-eventloop.rst:689
msgid ""
"The :func:`start_server` function is a higher-level alternative API that "
"returns a pair of :class:`StreamReader` and :class:`StreamWriter` that can "
"be used in an async/await code."
msgstr ""
"A função :func:`start_server` é uma API alternativa de alto nível que "
"retorna um par de :class:`StreamReader` e :class:`StreamWriter` que pode ser "
"usado em um código async/await."

#: ../../library/asyncio-eventloop.rst:698
msgid ""
"Similar to :meth:`loop.create_server` but works with the :py:data:`~socket."
"AF_UNIX` socket family."
msgstr ""
"Similar a :meth:`loop.create_server`, mas trabalha com a familia de soquete :"
"py:data:`~socket.AF_UNIX`."

#: ../../library/asyncio-eventloop.rst:701
msgid ""
"*path* is the name of a Unix domain socket, and is required, unless a *sock* "
"argument is provided.  Abstract Unix sockets, :class:`str`, :class:`bytes`, "
"and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* é o nome de um soquete de domínio Unix, e é obrigatório, a não ser "
"que um argumento *sock* seja fornecido. Soquetes Unix abstratos, :class:"
"`str`, :class:`bytes`, e caminhos :class:`~pathlib.Path` são suportados."

#: ../../library/asyncio-eventloop.rst:706
msgid ""
"See the documentation of the :meth:`loop.create_server` method for "
"information about arguments to this method."
msgstr ""
"Veja a documentação do método :meth:`loop.create_server` para informações "
"sobre argumentos para este método."

#: ../../library/asyncio-eventloop.rst:713
msgid "The *ssl_handshake_timeout* and *start_serving* parameters."
msgstr "Os parâmetros *ssl_handshake_timeout* e *start_serving*."

#: ../../library/asyncio-eventloop.rst:717
msgid "The *path* parameter can now be a :class:`~pathlib.Path` object."
msgstr "O parâmetro *path* agora pode ser um objeto :class:`~pathlib.Path`."

#: ../../library/asyncio-eventloop.rst:722
msgid "Wrap an already accepted connection into a transport/protocol pair."
msgstr "Envolve uma conexão já aceita em um par transporte/protocolo."

#: ../../library/asyncio-eventloop.rst:724
msgid ""
"This method can be used by servers that accept connections outside of "
"asyncio but that use asyncio to handle them."
msgstr ""
"Este método pode ser usado por servidores que aceitam conexões fora do "
"asyncio, mas que usam asyncio para manipulá-las."

#: ../../library/asyncio-eventloop.rst:727
#: ../../library/asyncio-eventloop.rst:794
msgid "Parameters:"
msgstr "Parâmetros:"

#: ../../library/asyncio-eventloop.rst:732
msgid ""
"*sock* is a preexisting socket object returned from :meth:`socket.accept "
"<socket.socket.accept>`."
msgstr ""
"*sock* é um objeto soquete pré-existente retornado a partir de :meth:`socket."
"accept <socket.socket.accept>`."

#: ../../library/asyncio-eventloop.rst:735
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` to enable SSL over the "
"accepted connections."
msgstr ""
"*ssl* pode ser definido para um :class:`~ssl.SSLContext` para habilitar SSL "
"sobre as conexões aceitas."

#: ../../library/asyncio-eventloop.rst:738
msgid ""
"*ssl_handshake_timeout* is (for an SSL connection) the time in seconds to "
"wait for the SSL handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* é (para uma conexão SSL) o tempo em segundos para "
"aguardar pelo aperto de mão SSL ser concluído, antes de abortar a conexão. "
"``60.0`` segundos se ``None`` (valor padrão)."

#: ../../library/asyncio-eventloop.rst:742
msgid "Returns a ``(transport, protocol)`` pair."
msgstr "Retorna um par ``(transport, protocol)``."

#: ../../library/asyncio-eventloop.rst:752
msgid "Transferring files"
msgstr "Transferindo arquivos"

#: ../../library/asyncio-eventloop.rst:757
msgid ""
"Send a *file* over a *transport*.  Return the total number of bytes sent."
msgstr ""
"Envia um *file* sobre um *transport*. Retorna o número total de bytes "
"enviados."

#: ../../library/asyncio-eventloop.rst:760
msgid "The method uses high-performance :meth:`os.sendfile` if available."
msgstr "O método usa :meth:`os.sendfile` de alto desempenho, se disponível."

#: ../../library/asyncio-eventloop.rst:762
msgid "*file* must be a regular file object opened in binary mode."
msgstr "*file* deve ser um objeto arquivo regular aberto em modo binário."

#: ../../library/asyncio-eventloop.rst:764
#: ../../library/asyncio-eventloop.rst:954
msgid ""
"*offset* tells from where to start reading the file. If specified, *count* "
"is the total number of bytes to transmit as opposed to sending the file "
"until EOF is reached. File position is always updated, even when this method "
"raises an error, and :meth:`file.tell() <io.IOBase.tell>` can be used to "
"obtain the actual number of bytes sent."
msgstr ""
"*offset* indica a partir de onde deve iniciar a leitura do arquivo. Se "
"especificado, *count* é o número total de bytes para transmitir, ao "
"contrário de transmitir o arquivo até que EOF seja atingido. A posição do "
"arquivo é sempre atualizada, mesmo quando este método levanta um erro, e :"
"meth:`file.tell() <io.IOBase.tell>` pode ser usado para obter o número atual "
"de bytes enviados."

#: ../../library/asyncio-eventloop.rst:771
msgid ""
"*fallback* set to ``True`` makes asyncio to manually read and send the file "
"when the platform does not support the sendfile system call (e.g. Windows or "
"SSL socket on Unix)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:775
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support the "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""

#: ../../library/asyncio-eventloop.rst:782
msgid "TLS Upgrade"
msgstr ""

#: ../../library/asyncio-eventloop.rst:788
msgid "Upgrade an existing transport-based connection to TLS."
msgstr ""

#: ../../library/asyncio-eventloop.rst:790
msgid ""
"Return a new transport instance, that the *protocol* must start using "
"immediately after the *await*.  The *transport* instance passed to the "
"*start_tls* method should never be used again."
msgstr ""

#: ../../library/asyncio-eventloop.rst:796
msgid ""
"*transport* and *protocol* instances that methods like :meth:`~loop."
"create_server` and :meth:`~loop.create_connection` return."
msgstr ""

#: ../../library/asyncio-eventloop.rst:800
msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:802
msgid ""
"*server_side* pass ``True`` when a server-side connection is being upgraded "
"(like the one created by :meth:`~loop.create_server`)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:805
msgid ""
"*server_hostname*: sets or overrides the host name that the target server's "
"certificate will be matched against."
msgstr ""

#: ../../library/asyncio-eventloop.rst:816
msgid "Watching file descriptors"
msgstr ""

#: ../../library/asyncio-eventloop.rst:820
msgid ""
"Start monitoring the *fd* file descriptor for read availability and invoke "
"*callback* with the specified arguments once *fd* is available for reading."
msgstr ""

#: ../../library/asyncio-eventloop.rst:826
msgid "Stop monitoring the *fd* file descriptor for read availability."
msgstr ""

#: ../../library/asyncio-eventloop.rst:830
msgid ""
"Start monitoring the *fd* file descriptor for write availability and invoke "
"*callback* with the specified arguments once *fd* is available for writing."
msgstr ""

#: ../../library/asyncio-eventloop.rst:834
#: ../../library/asyncio-eventloop.rst:1053
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *callback*."
msgstr ""

#: ../../library/asyncio-eventloop.rst:839
msgid "Stop monitoring the *fd* file descriptor for write availability."
msgstr ""

#: ../../library/asyncio-eventloop.rst:841
msgid ""
"See also :ref:`Platform Support <asyncio-platform-support>` section for some "
"limitations of these methods."
msgstr ""

#: ../../library/asyncio-eventloop.rst:846
msgid "Working with socket objects directly"
msgstr ""

#: ../../library/asyncio-eventloop.rst:848
msgid ""
"In general, protocol implementations that use transport-based APIs such as :"
"meth:`loop.create_connection` and :meth:`loop.create_server` are faster than "
"implementations that work with sockets directly. However, there are some use "
"cases when performance is not critical, and working with :class:`~socket."
"socket` objects directly is more convenient."
msgstr ""

#: ../../library/asyncio-eventloop.rst:857
msgid ""
"Receive up to *nbytes* from *sock*.  Asynchronous version of :meth:`socket."
"recv() <socket.socket.recv>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:860
msgid "Return the received data as a bytes object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:862
#: ../../library/asyncio-eventloop.rst:876
#: ../../library/asyncio-eventloop.rst:891
#: ../../library/asyncio-eventloop.rst:904
#: ../../library/asyncio-eventloop.rst:930
#: ../../library/asyncio-eventloop.rst:968
msgid "*sock* must be a non-blocking socket."
msgstr ""

#: ../../library/asyncio-eventloop.rst:864
msgid ""
"Even though this method was always documented as a coroutine method, "
"releases before Python 3.7 returned a :class:`Future`. Since Python 3.7 this "
"is an ``async def`` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:871
msgid ""
"Receive data from *sock* into the *buf* buffer.  Modeled after the blocking :"
"meth:`socket.recv_into() <socket.socket.recv_into>` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:874
msgid "Return the number of bytes written to the buffer."
msgstr ""

#: ../../library/asyncio-eventloop.rst:882
msgid ""
"Send *data* to the *sock* socket. Asynchronous version of :meth:`socket."
"sendall() <socket.socket.sendall>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:885
msgid ""
"This method continues to send to the socket until either all data in *data* "
"has been sent or an error occurs.  ``None`` is returned on success.  On "
"error, an exception is raised. Additionally, there is no way to determine "
"how much data, if any, was successfully processed by the receiving end of "
"the connection."
msgstr ""

#: ../../library/asyncio-eventloop.rst:893
msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned an :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:900
msgid "Connect *sock* to a remote socket at *address*."
msgstr ""

#: ../../library/asyncio-eventloop.rst:902
msgid ""
"Asynchronous version of :meth:`socket.connect() <socket.socket.connect>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:906
msgid ""
"``address`` no longer needs to be resolved.  ``sock_connect`` will try to "
"check if the *address* is already resolved by calling :func:`socket."
"inet_pton`.  If not, :meth:`loop.getaddrinfo` will be used to resolve the "
"*address*."
msgstr ""

#: ../../library/asyncio-eventloop.rst:915
msgid ""
":meth:`loop.create_connection` and  :func:`asyncio.open_connection() "
"<open_connection>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:921
msgid ""
"Accept a connection.  Modeled after the blocking :meth:`socket.accept() "
"<socket.socket.accept>` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:924
msgid ""
"The socket must be bound to an address and listening for connections. The "
"return value is a pair ``(conn, address)`` where *conn* is a *new* socket "
"object usable to send and receive data on the connection, and *address* is "
"the address bound to the socket on the other end of the connection."
msgstr ""

#: ../../library/asyncio-eventloop.rst:932
msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned a :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:939
msgid ":meth:`loop.create_server` and :func:`start_server`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:944
msgid ""
"Send a file using high-performance :mod:`os.sendfile` if possible. Return "
"the total number of bytes sent."
msgstr ""

#: ../../library/asyncio-eventloop.rst:947
msgid ""
"Asynchronous version of :meth:`socket.sendfile() <socket.socket.sendfile>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:949
msgid ""
"*sock* must be a non-blocking :const:`socket.SOCK_STREAM` :class:`~socket."
"socket`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:952
msgid "*file* must be a regular file object open in binary mode."
msgstr ""

#: ../../library/asyncio-eventloop.rst:961
msgid ""
"*fallback*, when set to ``True``, makes asyncio manually read and send the "
"file when the platform does not support the sendfile syscall (e.g. Windows "
"or SSL socket on Unix)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:965
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""

#: ../../library/asyncio-eventloop.rst:974
msgid "DNS"
msgstr "DNS"

#: ../../library/asyncio-eventloop.rst:979
msgid "Asynchronous version of :meth:`socket.getaddrinfo`."
msgstr "Versão assíncrona de :meth:`socket.getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:983
msgid "Asynchronous version of :meth:`socket.getnameinfo`."
msgstr "Versão assíncrona de :meth:`socket.getnameinfo`."

#: ../../library/asyncio-eventloop.rst:985
msgid ""
"Both *getaddrinfo* and *getnameinfo* methods were always documented to "
"return a coroutine, but prior to Python 3.7 they were, in fact, returning :"
"class:`asyncio.Future` objects.  Starting with Python 3.7 both methods are "
"coroutines."
msgstr ""

#: ../../library/asyncio-eventloop.rst:993
msgid "Working with pipes"
msgstr ""

#: ../../library/asyncio-eventloop.rst:997
msgid "Register the read end of *pipe* in the event loop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1002
msgid "*pipe* is a :term:`file-like object <file object>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1004
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports the :class:"
"`ReadTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1008
#: ../../library/asyncio-eventloop.rst:1024
msgid ""
"With :class:`SelectorEventLoop` event loop, the *pipe* is set to non-"
"blocking mode."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1013
msgid "Register the write end of *pipe* in the event loop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1018
msgid "*pipe* is :term:`file-like object <file object>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1020
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports :class:"
"`WriteTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1029
msgid ""
":class:`SelectorEventLoop` does not support the above methods on Windows.  "
"Use :class:`ProactorEventLoop` instead for Windows."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1034
msgid ""
"The :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` methods."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1039
msgid "Unix signals"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1043
msgid "Set *callback* as the handler for the *signum* signal."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1045
msgid ""
"The callback will be invoked by *loop*, along with other queued callbacks "
"and runnable coroutines of that event loop. Unlike signal handlers "
"registered using :func:`signal.signal`, a callback registered with this "
"function is allowed to interact with the event loop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1050
msgid ""
"Raise :exc:`ValueError` if the signal number is invalid or uncatchable. "
"Raise :exc:`RuntimeError` if there is a problem setting up the handler."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1056
msgid ""
"Like :func:`signal.signal`, this function must be invoked in the main thread."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1061
msgid "Remove the handler for the *sig* signal."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1063
msgid ""
"Return ``True`` if the signal handler was removed, or ``False`` if no "
"handler was set for the given signal."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1070
msgid "The :mod:`signal` module."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1074
msgid "Executing code in thread or process pools"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1078
msgid "Arrange for *func* to be called in the specified executor."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1080
msgid ""
"The *executor* argument should be an :class:`concurrent.futures.Executor` "
"instance. The default executor is used if *executor* is ``None``."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1124
msgid "This method returns a :class:`asyncio.Future` object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1126
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *func*."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1129
msgid ""
":meth:`loop.run_in_executor` no longer configures the ``max_workers`` of the "
"thread pool executor it creates, instead leaving it up to the thread pool "
"executor (:class:`~concurrent.futures.ThreadPoolExecutor`) to set the "
"default."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1138
msgid ""
"Set *executor* as the default executor used by :meth:`run_in_executor`. "
"*executor* should be an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1142
msgid ""
"Using an executor that is not an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor` is deprecated and will trigger an error in Python 3.9."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1147
msgid ""
"*executor* must be an instance of :class:`concurrent.futures."
"ThreadPoolExecutor`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1152
msgid "Error Handling API"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1154
msgid "Allows customizing how exceptions are handled in the event loop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1158
msgid "Set *handler* as the new event loop exception handler."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1160
msgid ""
"If *handler* is ``None``, the default exception handler will be set.  "
"Otherwise, *handler* must be a callable with the signature matching ``(loop, "
"context)``, where ``loop`` is a reference to the active event loop, and "
"``context`` is a ``dict`` object containing the details of the exception "
"(see :meth:`call_exception_handler` documentation for details about context)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1170
msgid ""
"Return the current exception handler, or ``None`` if no custom exception "
"handler was set."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1177
msgid "Default exception handler."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1179
msgid ""
"This is called when an exception occurs and no exception handler is set. "
"This can be called by a custom exception handler that wants to defer to the "
"default handler behavior."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1183
msgid ""
"*context* parameter has the same meaning as in :meth:"
"`call_exception_handler`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1188
msgid "Call the current event loop exception handler."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1190
msgid ""
"*context* is a ``dict`` object containing the following keys (new keys may "
"be introduced in future Python versions):"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1193
msgid "'message': Error message;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1194
msgid "'exception' (optional): Exception object;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1195
msgid "'future' (optional): :class:`asyncio.Future` instance;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1196
msgid "'task' (optional): :class:`asyncio.Task` instance;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1197
msgid "'handle' (optional): :class:`asyncio.Handle` instance;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1198
msgid "'protocol' (optional): :ref:`Protocol <asyncio-protocol>` instance;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1199
msgid "'transport' (optional): :ref:`Transport <asyncio-transport>` instance;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1200
msgid "'socket' (optional): :class:`socket.socket` instance;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1202
msgid "'asyncgen' (optional): Asynchronous generator that caused"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1202
msgid "the exception."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1206
msgid ""
"This method should not be overloaded in subclassed event loops.  For custom "
"exception handling, use the :meth:`set_exception_handler()` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1211
msgid "Enabling debug mode"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1215
msgid "Get the debug mode (:class:`bool`) of the event loop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1217
msgid ""
"The default value is ``True`` if the environment variable :envvar:"
"`PYTHONASYNCIODEBUG` is set to a non-empty string, ``False`` otherwise."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1223
msgid "Set the debug mode of the event loop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1227
msgid ""
"The new :ref:`Python Development Mode <devmode>` can now also be used to "
"enable the debug mode."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1232
msgid "The :ref:`debug mode of asyncio <asyncio-debug-mode>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1236
msgid "Running Subprocesses"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1238
msgid ""
"Methods described in this subsections are low-level.  In regular async/await "
"code consider using the high-level :func:`asyncio.create_subprocess_shell` "
"and :func:`asyncio.create_subprocess_exec` convenience functions instead."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1245
msgid ""
"The default asyncio event loop on **Windows** does not support subprocesses. "
"See :ref:`Subprocess Support on Windows <asyncio-windows-subprocess>` for "
"details."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1253
msgid ""
"Create a subprocess from one or more string arguments specified by *args*."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1256
msgid "*args* must be a list of strings represented by:"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1258
msgid ":class:`str`;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1259
msgid ""
"or :class:`bytes`, encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1262
msgid ""
"The first string specifies the program executable, and the remaining strings "
"specify the arguments.  Together, string arguments form the ``argv`` of the "
"program."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1266
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=False`` and the list of strings passed as the first "
"argument; however, where :class:`~subprocess.Popen` takes a single argument "
"which is list of strings, *subprocess_exec* takes multiple string arguments."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1272
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`asyncio.SubprocessProtocol` class."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1275
msgid "Other parameters:"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1277
msgid "*stdin* can be any of these:"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1279
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard input stream using :meth:`~loop.connect_write_pipe`"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1282
#: ../../library/asyncio-eventloop.rst:1294
#: ../../library/asyncio-eventloop.rst:1306
msgid ""
"the :const:`subprocess.PIPE` constant (default) which will create a new pipe "
"and connect it,"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1284
#: ../../library/asyncio-eventloop.rst:1296
#: ../../library/asyncio-eventloop.rst:1308
msgid ""
"the value ``None`` which will make the subprocess inherit the file "
"descriptor from this process"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1286
#: ../../library/asyncio-eventloop.rst:1298
#: ../../library/asyncio-eventloop.rst:1310
msgid ""
"the :const:`subprocess.DEVNULL` constant which indicates that the special :"
"data:`os.devnull` file will be used"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1289
msgid "*stdout* can be any of these:"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1291
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard output stream using :meth:`~loop.connect_write_pipe`"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1301
msgid "*stderr* can be any of these:"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1303
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard error stream using :meth:`~loop.connect_write_pipe`"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1312
msgid ""
"the :const:`subprocess.STDOUT` constant which will connect the standard "
"error stream to the process' standard output stream"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1315
msgid ""
"All other keyword arguments are passed to :class:`subprocess.Popen` without "
"interpretation, except for *bufsize*, *universal_newlines*, *shell*, *text*, "
"*encoding* and *errors*, which should not be specified at all."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1320
msgid ""
"The ``asyncio`` subprocess API does not support decoding the streams as "
"text. :func:`bytes.decode` can be used to convert the bytes returned from "
"the stream to text."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1324
msgid ""
"See the constructor of the :class:`subprocess.Popen` class for documentation "
"on other arguments."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1327
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`asyncio.SubprocessTransport` base class and *protocol* is an "
"object instantiated by the *protocol_factory*."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1335
msgid ""
"Create a subprocess from *cmd*, which can be a :class:`str` or a :class:"
"`bytes` string encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`, using the platform's \"shell\" syntax."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1340
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=True``."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1343
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`SubprocessProtocol` class."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1346
msgid ""
"See :meth:`~loop.subprocess_exec` for more details about the remaining "
"arguments."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1349
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`SubprocessTransport` base class and *protocol* is an object "
"instantiated by the *protocol_factory*."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1354
msgid ""
"It is the application's responsibility to ensure that all whitespace and "
"special characters are quoted appropriately to avoid `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"vulnerabilities. The :func:`shlex.quote` function can be used to properly "
"escape whitespace and special characters in strings that are going to be "
"used to construct shell commands."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1363
msgid "Callback Handles"
msgstr "Tratadores de função de retorno"

#: ../../library/asyncio-eventloop.rst:1367
msgid ""
"A callback wrapper object returned by :meth:`loop.call_soon`, :meth:`loop."
"call_soon_threadsafe`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1372
msgid ""
"Cancel the callback.  If the callback has already been canceled or executed, "
"this method has no effect."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1377
msgid "Return ``True`` if the callback was cancelled."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1383
msgid ""
"A callback wrapper object returned by :meth:`loop.call_later`, and :meth:"
"`loop.call_at`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1386
msgid "This class is a subclass of :class:`Handle`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1390
msgid "Return a scheduled callback time as :class:`float` seconds."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1392
msgid ""
"The time is an absolute timestamp, using the same time reference as :meth:"
"`loop.time`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1399
msgid "Server Objects"
msgstr "Objetos Server"

#: ../../library/asyncio-eventloop.rst:1401
msgid ""
"Server objects are created by :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :func:`start_server`, and :func:`start_unix_server` "
"functions."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1405
msgid "Do not instantiate the class directly."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1409
msgid ""
"*Server* objects are asynchronous context managers.  When used in an ``async "
"with`` statement, it's guaranteed that the Server object is closed and not "
"accepting new connections when the ``async with`` statement is completed::"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1422
msgid "Server object is an asynchronous context manager since Python 3.7."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1427
msgid ""
"Stop serving: close listening sockets and set the :attr:`sockets` attribute "
"to ``None``."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1430
msgid ""
"The sockets that represent existing incoming client connections are left "
"open."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1433
msgid ""
"The server is closed asynchronously, use the :meth:`wait_closed` coroutine "
"to wait until the server is closed."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1438
msgid "Return the event loop associated with the server object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1444
msgid "Start accepting connections."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1446
msgid ""
"This method is idempotent, so it can be called when the server is already "
"being serving."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1449
msgid ""
"The *start_serving* keyword-only parameter to :meth:`loop.create_server` "
"and :meth:`asyncio.start_server` allows creating a Server object that is not "
"accepting connections initially.  In this case ``Server.start_serving()``, "
"or :meth:`Server.serve_forever` can be used to make the Server start "
"accepting connections."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1460
msgid ""
"Start accepting connections until the coroutine is cancelled. Cancellation "
"of ``serve_forever`` task causes the server to be closed."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1464
msgid ""
"This method can be called if the server is already accepting connections.  "
"Only one ``serve_forever`` task can exist per one *Server* object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1486
msgid "Return ``True`` if the server is accepting new connections."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1492
msgid "Wait until the :meth:`close` method completes."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1496
msgid "List of :class:`socket.socket` objects the server is listening on."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1498
msgid ""
"Prior to Python 3.7 ``Server.sockets`` used to return an internal list of "
"server sockets directly.  In 3.7 a copy of that list is returned."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1507
msgid "Event Loop Implementations"
msgstr "Implementações do Laço de Eventos"

#: ../../library/asyncio-eventloop.rst:1509
msgid ""
"asyncio ships with two different event loop implementations: :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop`."
msgstr ""
"asyncio vem com duas implementações de laço de eventos diferente: :class:"
"`SelectorEventLoop` e :class:`ProactorEventLoop`."

#: ../../library/asyncio-eventloop.rst:1512
msgid ""
"By default asyncio is configured to use :class:`SelectorEventLoop` on Unix "
"and :class:`ProactorEventLoop` on Windows."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1518
msgid "An event loop based on the :mod:`selectors` module."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1520
msgid ""
"Uses the most efficient *selector* available for the given platform.  It is "
"also possible to manually configure the exact selector implementation to be "
"used::"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1532
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`Disponibilidade<availability>`: Unix, Windows."

#: ../../library/asyncio-eventloop.rst:1537
msgid "An event loop for Windows that uses \"I/O Completion Ports\" (IOCP)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1540
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Disponibilidade <availability>`: Windows."

#: ../../library/asyncio-eventloop.rst:1543
msgid ""
"`MSDN documentation on I/O Completion Ports <https://docs.microsoft.com/en-"
"ca/windows/desktop/FileIO/i-o-completion-ports>`_."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1549
msgid "Abstract base class for asyncio-compliant event loops."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1551
msgid ""
"The :ref:`Event Loop Methods <asyncio-event-loop>` section lists all methods "
"that an alternative implementation of ``AbstractEventLoop`` should have "
"defined."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1557
msgid "Examples"
msgstr "Exemplos"

#: ../../library/asyncio-eventloop.rst:1559
msgid ""
"Note that all examples in this section **purposefully** show how to use the "
"low-level event loop APIs, such as :meth:`loop.run_forever` and :meth:`loop."
"call_soon`.  Modern asyncio applications rarely need to be written this way; "
"consider using the high-level functions like :func:`asyncio.run`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1569
msgid "Hello World with call_soon()"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1571
msgid ""
"An example using the :meth:`loop.call_soon` method to schedule a callback. "
"The callback displays ``\"Hello World\"`` and then stops the event loop::"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1595
msgid ""
"A similar :ref:`Hello World <coroutine>` example created with a coroutine "
"and the :func:`run` function."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1602
msgid "Display the current date with call_later()"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1604
msgid ""
"An example of a callback displaying the current date every second. The "
"callback uses the :meth:`loop.call_later` method to reschedule itself after "
"5 seconds, and then stops the event loop::"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1632
msgid ""
"A similar :ref:`current date <asyncio_example_sleep>` example created with a "
"coroutine and the :func:`run` function."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1639
msgid "Watch a file descriptor for read events"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1641
msgid ""
"Wait until a file descriptor received some data using the :meth:`loop."
"add_reader` method and then close the event loop::"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1679
msgid ""
"A similar :ref:`example <asyncio_example_create_connection>` using "
"transports, protocols, and the :meth:`loop.create_connection` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1683
msgid ""
"Another similar :ref:`example <asyncio_example_create_connection-streams>` "
"using the high-level :func:`asyncio.open_connection` function and streams."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1691
msgid "Set signal handlers for SIGINT and SIGTERM"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1693
msgid "(This ``signals`` example only works on Unix.)"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1695
msgid ""
"Register handlers for signals :py:data:`SIGINT` and :py:data:`SIGTERM` using "
"the :meth:`loop.add_signal_handler` method::"
msgstr ""

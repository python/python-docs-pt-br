# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# i17obot <i17obot@rougeth.com>, 2021
# Marco Rougeth <marco@rougeth.com>, 2022
# Danilo Lima <djkcond@gmail.com>, 2023
# Vitor Buxbaum Orlandi, 2023
# Pedro Fonini, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-29 14:18+0000\n"
"PO-Revision-Date: 2021-06-28 01:04+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/dis.rst:2
msgid ":mod:`!dis` --- Disassembler for Python bytecode"
msgstr ":mod:`!dis` --- Disassembler de bytecode do Python"

#: ../../library/dis.rst:7
msgid "**Source code:** :source:`Lib/dis.py`"
msgstr "**Código-fonte:** :source:`Lib/dis.py`"

#: ../../library/dis.rst:17
msgid ""
"The :mod:`dis` module supports the analysis of CPython :term:`bytecode` by "
"disassembling it. The CPython bytecode which this module takes as an input "
"is defined in the file :file:`Include/opcode.h` and used by the compiler and "
"the interpreter."
msgstr ""
"O módulo :mod:`dis` oferece suporte à análise de :term:`bytecode` do "
"CPython, desmontando-o. O bytecode do CPython que o módulo leva como entrada "
"é definido no arquivo :file:`Include/opcode.h` e usado pelo compilador e "
"pelo interpretador."

#: ../../library/dis.rst:24
msgid ""
"Bytecode is an implementation detail of the CPython interpreter.  No "
"guarantees are made that bytecode will not be added, removed, or changed "
"between versions of Python.  Use of this module should not be considered to "
"work across Python VMs or Python releases."
msgstr ""
"O bytecode é um detalhe de implementação do interpretador CPython. Não há "
"garantias de que bytecodes não serão adicionados, removidos ou alterados "
"entre as versões do Python. O uso deste módulo não deve ser considerado que "
"funcionará em todas as VMs do Python ou mesmo versões do Python."

#: ../../library/dis.rst:29
msgid ""
"Use 2 bytes for each instruction. Previously the number of bytes varied by "
"instruction."
msgstr ""
"Cada instrução ocupa 2 bytes. Anteriormente, o número de bytes variava de "
"acordo com a instrução."

#: ../../library/dis.rst:33
msgid ""
"The argument of jump, exception handling and loop instructions is now the "
"instruction offset rather than the byte offset."
msgstr ""
"O argumento para instruções de pulo, tratamento de exceção e laço é agora o "
"deslocamento em instruções, ao invés de em bytes."

#: ../../library/dis.rst:37
msgid ""
"Some instructions are accompanied by one or more inline cache entries, which "
"take the form of :opcode:`CACHE` instructions. These instructions are hidden "
"by default, but can be shown by passing ``show_caches=True`` to any :mod:"
"`dis` utility. Furthermore, the interpreter now adapts the bytecode to "
"specialize it for different runtime conditions. The adaptive bytecode can be "
"shown by passing ``adaptive=True``."
msgstr ""
"Algumas instruções vêm acompanhadas de uma ou mais entradas de cache em "
"linha, as quais assumem a forma de instruções :opcode:`CACHE`. Tais "
"instruções são escondidas por padrão, mas podem ser visualizadas passando "
"``show_caches=True`` para qualquer utilidade do :mod:`dis`. Além disso, o "
"interpretador agora adapta o bytecode para especializá-lo a diferentes "
"condições de tempo de execução. O bytecode adaptativo pode ser visualizado "
"passando ``adaptive=True``."

#: ../../library/dis.rst:45
msgid ""
"The argument of a jump is the offset of the target instruction relative to "
"the instruction that appears immediately after the jump instruction's :"
"opcode:`CACHE` entries."
msgstr ""
"O argumento de um pulo é o deslocamento da instrução alvo relativo à "
"instrução que aparece imediatamente após as entradas :opcode:`CACHE` da "
"instrução de pulo."

#: ../../library/dis.rst:50
msgid ""
"As a consequence, the presence of the :opcode:`CACHE` instructions is "
"transparent for forward jumps but needs to be taken into account when "
"reasoning about backward jumps."
msgstr ""
"Como consequência, a presença de instruções :opcode:`CACHE` é transparente "
"para pulos adiante, mas precisa ser considerada ao lidar com pulos para trás."

#: ../../library/dis.rst:54
msgid ""
"The output shows logical labels rather than instruction offsets for jump "
"targets and exception handlers. The ``-O`` command line option and the "
"``show_offsets`` argument were added."
msgstr ""
"A saída agora mostra rótulos lógicos ao invés dos deslocamentos das "
"instruções para alvos de pulos e de tratadores de exceções. A opção de linha "
"de comando ``-O`` e o argumento ``show_offsets`` foram adicionados."

#: ../../library/dis.rst:59
msgid "Example: Given the function :func:`!myfunc`::"
msgstr "Exemplo: Dada a função :func:`!myfunc`::"

#: ../../library/dis.rst:61
msgid ""
"def myfunc(alist):\n"
"    return len(alist)"
msgstr ""

#: ../../library/dis.rst:64
msgid ""
"the following command can be used to display the disassembly of :func:`!"
"myfunc`:"
msgstr ""
"o comando a seguir pode ser usado para mostrar a desconstrução de :func:`!"
"myfunc`:"

#: ../../library/dis.rst:67
msgid ""
">>> dis.dis(myfunc)\n"
"  2           RESUME                   0\n"
"\n"
"  3           LOAD_GLOBAL              1 (len + NULL)\n"
"              LOAD_FAST                0 (alist)\n"
"              CALL                     1\n"
"              RETURN_VALUE"
msgstr ""

#: ../../library/dis.rst:77
msgid "(The \"2\" is a line number)."
msgstr "(O \"2\" é o número da linha)."

#: ../../library/dis.rst:82
msgid "Command-line interface"
msgstr "Interface de linha de comando"

#: ../../library/dis.rst:84
msgid "The :mod:`dis` module can be invoked as a script from the command line:"
msgstr ""
"O módulo :mod:`dis` pode ser invocado como um script na linha de comando:"

#: ../../library/dis.rst:86
msgid "python -m dis [-h] [-C] [-O] [infile]"
msgstr ""

#: ../../library/dis.rst:90
msgid "The following options are accepted:"
msgstr "As seguintes opções são aceitas:"

#: ../../library/dis.rst:96
msgid "Display usage and exit."
msgstr "Exibe o modo de uso e sai."

#: ../../library/dis.rst:100
msgid "Show inline caches."
msgstr "Mostra caches em linha"

#: ../../library/dis.rst:104
msgid "Show offsets of instructions."
msgstr "Mostra os deslocamentos das instruções"

#: ../../library/dis.rst:106
msgid ""
"If :file:`infile` is specified, its disassembled code will be written to "
"stdout. Otherwise, disassembly is performed on compiled source code received "
"from stdin."
msgstr ""
"Se :file:`infile` for especificada, o seu código desmontado será escrito no "
"stdout. Caso contrário, será feito o desmonte da compilação do código-fonte "
"recebido do stdin."

#: ../../library/dis.rst:110
msgid "Bytecode analysis"
msgstr "Análise de bytecode"

#: ../../library/dis.rst:114
msgid ""
"The bytecode analysis API allows pieces of Python code to be wrapped in a :"
"class:`Bytecode` object that provides easy access to details of the compiled "
"code."
msgstr ""
"A API de análise de bytecode permite que partes do código Python sejam "
"encapsuladas em um objeto :class:`Bytecode` que facilite o acesso aos "
"detalhes do código compilado."

#: ../../library/dis.rst:121
msgid ""
"Analyse the bytecode corresponding to a function, generator, asynchronous "
"generator, coroutine, method, string of source code, or a code object (as "
"returned by :func:`compile`)."
msgstr ""
"Analisa o bytecode correspondente a uma função, um gerador, um gerador "
"assíncrono, uma corrotina, um método, uma string de código-fonte, ou um "
"objeto de código (conforme retornado por :func:`compile`)."

#: ../../library/dis.rst:125
msgid ""
"This is a convenience wrapper around many of the functions listed below, "
"most notably :func:`get_instructions`, as iterating over a :class:`Bytecode` "
"instance yields the bytecode operations as :class:`Instruction` instances."
msgstr ""
"Esta é um invólucro de conveniência que encapsula muitas das funções "
"listadas abaixo, principalmente a :func:`get_instructions`, já que iterar "
"sobre sobre uma instância de :class:`Bytecode` produz operações bytecode "
"como instâncias de :class:`Instruction`."

#: ../../library/dis.rst:129 ../../library/dis.rst:326
msgid ""
"If *first_line* is not ``None``, it indicates the line number that should be "
"reported for the first source line in the disassembled code.  Otherwise, the "
"source line information (if any) is taken directly from the disassembled "
"code object."
msgstr ""
"Se *first_line* não for ``None``, ele indica o número de linha que deve ser "
"reportado para a primeira linha de código-fonte no código desmontado.  Caso "
"contrário, a informação de linha de código-fonte (se houver) é extraída "
"diretamente da desconstrução do objeto de código."

#: ../../library/dis.rst:134
msgid ""
"If *current_offset* is not ``None``, it refers to an instruction offset in "
"the disassembled code. Setting this means :meth:`.dis` will display a "
"\"current instruction\" marker against the specified opcode."
msgstr ""
"Se *current_offset* não for ``None``, ele é um deslocamento em instruções no "
"código desconstruído. Definir este argumento significa que o :meth:`.dis` "
"vai mostrar um marcador de \"instrução atual\" sobre o opcode especificado."

#: ../../library/dis.rst:138
msgid ""
"If *show_caches* is ``True``, :meth:`.dis` will display inline cache entries "
"used by the interpreter to specialize the bytecode."
msgstr ""
"Se *show_caches* for ``True``, o :meth:`.dis` vai exibir entradas de cache "
"em linha usadas pelo interpretador para especializar o bytecode."

#: ../../library/dis.rst:141
msgid ""
"If *adaptive* is ``True``, :meth:`.dis` will display specialized bytecode "
"that may be different from the original bytecode."
msgstr ""
"Se *adaptive* for ``True``, o :meth:`.dis` vai exibir bytecode especializado "
"que pode ser diferente do bytecode original."

#: ../../library/dis.rst:144
msgid ""
"If *show_offsets* is ``True``, :meth:`.dis` will include instruction offsets "
"in the output."
msgstr ""
"Se *show_offsets* for ``True``, o :meth:`.dis` vai incluir deslocamentos em "
"instruções na saída."

#: ../../library/dis.rst:149
msgid ""
"Construct a :class:`Bytecode` instance from the given traceback, setting "
"*current_offset* to the instruction responsible for the exception."
msgstr ""
"Constrói uma instância de :class:`Bytecode` a partir do traceback fornecido, "
"definindo *current_offset* apontando para a instrução responsável pela "
"exceção."

#: ../../library/dis.rst:154
msgid "The compiled code object."
msgstr "O objeto de código compilado."

#: ../../library/dis.rst:158
msgid "The first source line of the code object (if available)"
msgstr ""
"A primeira linha de código-fonte do objeto de código (caso disponível)."

#: ../../library/dis.rst:162
msgid ""
"Return a formatted view of the bytecode operations (the same as printed by :"
"func:`dis.dis`, but returned as a multi-line string)."
msgstr ""
"Retorna uma visualização formatada das operações em bytecode (as mesmas que "
"seriam impressas pela :func:`dis.dis`, mas retornadas como uma string "
"multilinha)."

#: ../../library/dis.rst:167
msgid ""
"Return a formatted multi-line string with detailed information about the "
"code object, like :func:`code_info`."
msgstr ""
"Retorna uma string multilinha formatada com informação detalhada sobre o "
"objeto de código, como :func:`code_info`."

#: ../../library/dis.rst:170 ../../library/dis.rst:210
#: ../../library/dis.rst:262
msgid "This can now handle coroutine and asynchronous generator objects."
msgstr ""
"Este método agora lida com objetos de corrotina e de gerador assíncrono."

#: ../../library/dis.rst:173 ../../library/dis.rst:265
#: ../../library/dis.rst:282 ../../library/dis.rst:312
#: ../../library/dis.rst:335
msgid "Added the *show_caches* and *adaptive* parameters."
msgstr "Adicionados os parâmetros *show_caches* e *adaptive*."

#: ../../library/dis.rst:176
msgid "Example:"
msgstr "Exemplo:"

#: ../../library/dis.rst:178
msgid ""
">>> bytecode = dis.Bytecode(myfunc)\n"
">>> for instr in bytecode:\n"
"...     print(instr.opname)\n"
"...\n"
"RESUME\n"
"LOAD_GLOBAL\n"
"LOAD_FAST\n"
"CALL\n"
"RETURN_VALUE"
msgstr ""

#: ../../library/dis.rst:192
msgid "Analysis functions"
msgstr "Funções de análise"

#: ../../library/dis.rst:194
msgid ""
"The :mod:`dis` module also defines the following analysis functions that "
"convert the input directly to the desired output. They can be useful if only "
"a single operation is being performed, so the intermediate analysis object "
"isn't useful:"
msgstr ""
"O módulo :mod:`dis` também define as seguintes funções que convertem a "
"entrada diretamente para a saída desejada. Elas podem ser úteis se somente "
"uma única operação está sendo feita, de forma que o objeto de análise "
"intermediário não é útil:"

#: ../../library/dis.rst:200
msgid ""
"Return a formatted multi-line string with detailed code object information "
"for the supplied function, generator, asynchronous generator, coroutine, "
"method, source code string or code object."
msgstr ""
"Retorna uma string multilinha formatada com informação detalhada sobre o "
"objeto de código correspondente à função, gerador, gerador assíncrono, "
"corrotina, método, string de código-fonte ou objeto de código fornecido."

#: ../../library/dis.rst:204
msgid ""
"Note that the exact contents of code info strings are highly implementation "
"dependent and they may change arbitrarily across Python VMs or Python "
"releases."
msgstr ""
"Observe que o conteúdo exato de strings de informação de código são "
"altamente dependentes da implementação e podem mudar de forma arbitrária "
"através de VMs Python ou lançamentos do Python."

#: ../../library/dis.rst:216
msgid ""
"Print detailed code object information for the supplied function, method, "
"source code string or code object to *file* (or ``sys.stdout`` if *file* is "
"not specified)."
msgstr ""
"Imprime no arquivo *file* (ou ``sys.stdout`` caso *file* não seja "
"especificado) informações detalhadas sobre o objeto de código correspondente "
"à função, método, string de código-fonte fornecido."

#: ../../library/dis.rst:220
msgid ""
"This is a convenient shorthand for ``print(code_info(x), file=file)``, "
"intended for interactive exploration at the interpreter prompt."
msgstr ""
"Este é um atalho conveniente para ``print(code_info(x), file=file)``, "
"destinado à exploração interativa no prompt do interpretador."

#: ../../library/dis.rst:225 ../../library/dis.rst:256
#: ../../library/dis.rst:279 ../../library/dis.rst:309
msgid "Added *file* parameter."
msgstr "Adicionado o parâmetro *file*."

#: ../../library/dis.rst:231
msgid ""
"Disassemble the *x* object.  *x* can denote either a module, a class, a "
"method, a function, a generator, an asynchronous generator, a coroutine, a "
"code object, a string of source code or a byte sequence of raw bytecode. For "
"a module, it disassembles all functions. For a class, it disassembles all "
"methods (including class and static methods). For a code object or sequence "
"of raw bytecode, it prints one line per bytecode instruction. It also "
"recursively disassembles nested code objects. These can include generator "
"expressions, nested functions, the bodies of nested classes, and the code "
"objects used for :ref:`annotation scopes <annotation-scopes>`. Strings are "
"first compiled to code objects with the :func:`compile` built-in function "
"before being disassembled.  If no object is provided, this function "
"disassembles the last traceback."
msgstr ""
"Desmonta o objeto *x*.  *x* pode denotar um módulo, uma classe, um método, "
"uma função, um gerador, um gerador assíncrono, uma corrotina, um objeto de "
"código, uma string de código-fonte ou uma sequência de bytes contendo "
"bytecode bruto. Para um módulo, são desmontadas todas as funções. Para uma "
"classe, são desmontados todos os métodos (incluindo métodos de classe e "
"estáticos). Para um objeto de código ou sequência de bytecodes brutos, é "
"impressa uma linha para cada instrução de bytecode. Além disso, objetos de "
"código aninhados são desmontados recursivamente. Estes podem incluir "
"expressões geradoras, funções aninhadas, corpos de classes aninhadas, e "
"objetos de código usados para :ref:`escopos de anotação <annotation-"
"scopes>`. Strings são compiladas para objetos de código com a função "
"embutida :func:`compile` antes de serem desmontadas.  Se nenhum objeto for "
"fornecido, o último traceback é desmontado."

#: ../../library/dis.rst:244 ../../library/dis.rst:276
#: ../../library/dis.rst:306
msgid ""
"The disassembly is written as text to the supplied *file* argument if "
"provided and to ``sys.stdout`` otherwise."
msgstr ""
"O resultado é escrito como texto no arquivo *file* caso tenha sido fornecido "
"como argumento, ou para ``sys.stdout`` caso contrário."

#: ../../library/dis.rst:247
msgid ""
"The maximal depth of recursion is limited by *depth* unless it is ``None``. "
"``depth=0`` means no recursion."
msgstr ""
"A profundidade máxima de recursão é limitada por *depth* a menos que seja "
"``None``. ``depth=0`` significa não fazer recursão."

#: ../../library/dis.rst:250
msgid ""
"If *show_caches* is ``True``, this function will display inline cache "
"entries used by the interpreter to specialize the bytecode."
msgstr ""
"Se *show_caches* for ``True``, essa função vai exibir entradas de cache em "
"linha usadas pelo interpretador para especializar o bytecode."

#: ../../library/dis.rst:253
msgid ""
"If *adaptive* is ``True``, this function will display specialized bytecode "
"that may be different from the original bytecode."
msgstr ""
"Se *adaptive* for ``True``, essa função vai exibir bytecode especializado "
"que pode ser diferente do bytecode original."

#: ../../library/dis.rst:259
msgid "Implemented recursive disassembling and added *depth* parameter."
msgstr ""
"Foi implementada a desmontagem recursiva, e adicionado o parâmetro *depth*."

#: ../../library/dis.rst:272
msgid ""
"Disassemble the top-of-stack function of a traceback, using the last "
"traceback if none was passed.  The instruction causing the exception is "
"indicated."
msgstr ""
"Desmonta a função no topo da pilha de um traceback, usando o último "
"traceback caso nenhum tenha sido passado.  A instrução que causou a exceção "
"é indicada."

#: ../../library/dis.rst:285 ../../library/dis.rst:315
msgid "Added the *show_offsets* parameter."
msgstr "Foi adicionado o parâmetro *show_offsets*."

#: ../../library/dis.rst:292
msgid ""
"Disassemble a code object, indicating the last instruction if *lasti* was "
"provided.  The output is divided in the following columns:"
msgstr ""
"Desmonta um objeto de código, indicando a última instrução se *lasti* tiver "
"sido fornecido.  A saída é dividida em colunas da seguinte forma:"

#: ../../library/dis.rst:295
msgid "the line number, for the first instruction of each line"
msgstr "o número da linha, para a primeira instrução de cada linha"

#: ../../library/dis.rst:296
msgid "the current instruction, indicated as ``-->``,"
msgstr "a instrução atual, indicada por ``-->``,"

#: ../../library/dis.rst:297
msgid "a labelled instruction, indicated with ``>>``,"
msgstr "um rótulo da instrução, indicado com ``>>``,"

#: ../../library/dis.rst:298
msgid "the address of the instruction,"
msgstr "o endereço da instrução"

#: ../../library/dis.rst:299
msgid "the operation code name,"
msgstr "o nome do código da operação,"

#: ../../library/dis.rst:300
msgid "operation parameters, and"
msgstr "os parâmetros da operação, e"

#: ../../library/dis.rst:301
msgid "interpretation of the parameters in parentheses."
msgstr "a interpretação dos parâmetros, em parênteses."

#: ../../library/dis.rst:303
msgid ""
"The parameter interpretation recognizes local and global variable names, "
"constant values, branch targets, and compare operators."
msgstr ""
"A interpretação dos parâmetros reconhece nomes de variáveis locais e "
"globais, valores de constantes, alvos de ramificações, e operadores de "
"comparação."

#: ../../library/dis.rst:320
msgid ""
"Return an iterator over the instructions in the supplied function, method, "
"source code string or code object."
msgstr ""
"Retorna um iterador sobre as instruções na função, método, string de código-"
"fonte ou objeto de código fornecido."

#: ../../library/dis.rst:323
msgid ""
"The iterator generates a series of :class:`Instruction` named tuples giving "
"the details of each operation in the supplied code."
msgstr ""
"O iterador gera uma série de tuplas nomeadas :class:`Instruction` contendo "
"detalhes de cada operação no código fornecido."

#: ../../library/dis.rst:331
msgid "The *adaptive* parameter works as it does in :func:`dis`."
msgstr "O parâmetro *adaptive* funciona assim como na função :func:`dis`."

#: ../../library/dis.rst:338
msgid ""
"The *show_caches* parameter is deprecated and has no effect. The iterator "
"generates the :class:`Instruction` instances with the *cache_info* field "
"populated (regardless of the value of *show_caches*) and it no longer "
"generates separate items for the cache entries."
msgstr ""
"O parâmetro *show_caches* foi descontinuado e não tem mais efeito. O "
"iterador gera as instâncias da :class:`Instruction` com o campo *cache_info* "
"populado (independentemente do valor de *show_caches*) e não gera mais items "
"separados para as entradas de cache."

#: ../../library/dis.rst:346
msgid ""
"This generator function uses the :meth:`~codeobject.co_lines` method of the :"
"ref:`code object <code-objects>` *code* to find the offsets which are starts "
"of lines in the source code.  They are generated as ``(offset, lineno)`` "
"pairs."
msgstr ""
"Essa função geradora usa o método :meth:`~codeobject.co_lines` do :ref:"
"`objeto de código <code-objects>` *code* para encontrar as posições que "
"correspondem aos inícios de cada linha do código-fonte.  Elas são geradas em "
"pares ``(offset, lineno)``."

#: ../../library/dis.rst:351
msgid "Line numbers can be decreasing. Before, they were always increasing."
msgstr ""
"Números de linhas podem ser decrescentes. Antes, eles eram sempre crescentes."

#: ../../library/dis.rst:354
msgid ""
"The :pep:`626` :meth:`~codeobject.co_lines` method is used instead of the :"
"attr:`~codeobject.co_firstlineno` and :attr:`~codeobject.co_lnotab` "
"attributes of the :ref:`code object <code-objects>`."
msgstr ""
"O método :meth:`~codeobject.co_lines` da :pep:`626` é usado ao invés dos "
"atributos :attr:`~codeobject.co_firstlineno` e :attr:`~codeobject.co_lnotab` "
"do :ref:`objeto de código <code-objects>`."

#: ../../library/dis.rst:359
msgid ""
"Line numbers can be ``None`` for bytecode that does not map to source lines."
msgstr ""
"Números de linha podem ser ``None`` para bytecode que não corresponde a um "
"código-fonte."

#: ../../library/dis.rst:365
msgid ""
"Detect all offsets in the raw compiled bytecode string *code* which are jump "
"targets, and return a list of these offsets."
msgstr ""
"Detecta todas as posições na string de bytecode compilado bruto *code* que "
"são alvos de pulos, e as retorna em uma lista."

#: ../../library/dis.rst:371
msgid "Compute the stack effect of *opcode* with argument *oparg*."
msgstr "Calcula o efeito que o *opcode* com argumento *oparg* tem na pilha."

#: ../../library/dis.rst:373
msgid ""
"If the code has a jump target and *jump* is ``True``, :func:`~stack_effect` "
"will return the stack effect of jumping.  If *jump* is ``False``, it will "
"return the stack effect of not jumping. And if *jump* is ``None`` (default), "
"it will return the maximal stack effect of both cases."
msgstr ""
"Se a operação tiver um alvo de pulo e *jump* for ``True``, :func:"
"`~stack_effect` vai retornar o efeito na pilha de realizar o pulo.  Se "
"*jump* for ``False``, ela vai retornar o efeito na pilha de não pular. E se "
"*jump* for ``None`` (o padrão), vai retornar o efeito máximo na pilha dentre "
"os dois casos."

#: ../../library/dis.rst:380
msgid "Added *jump* parameter."
msgstr "Adicionado o parâmetro *jump*."

#: ../../library/dis.rst:383
msgid ""
"If ``oparg`` is omitted (or ``None``), the stack effect is now returned for "
"``oparg=0``. Previously this was an error for opcodes that use their arg. It "
"is also no longer an error to pass an integer ``oparg`` when the ``opcode`` "
"does not use it; the ``oparg`` in this case is ignored."
msgstr ""
"Se ``oparg`` for omitido (ou ``None``), agora é retornado o efeito na pilha "
"para o caso ``oparg=0``. Anteriormente isso era um erro caso o opcode usasse "
"o seu argumento. Além disso, agora não é mais um erro passar um inteiro como "
"``oparg`` quando o ``opcode`` não o usa; o ``oparg`` nesse caso é ignorado."

#: ../../library/dis.rst:393
msgid "Python Bytecode Instructions"
msgstr "Instruções em bytecode do Python"

#: ../../library/dis.rst:395
msgid ""
"The :func:`get_instructions` function and :class:`Bytecode` class provide "
"details of bytecode instructions as :class:`Instruction` instances:"
msgstr ""
"A função :func:`get_instructions` e a classe :class:`Bytecode` fornecem "
"detalhes de instruções de bytecode como instâncias de :class:`Instruction`:"

#: ../../library/dis.rst:400
msgid "Details for a bytecode operation"
msgstr "Detalhes de uma operação em bytecode"

#: ../../library/dis.rst:404
msgid ""
"numeric code for operation, corresponding to the opcode values listed below "
"and the bytecode values in the :ref:`opcode_collections`."
msgstr ""
"código numérico da operação, correspondendo aos valores dos opcodes listados "
"abaixo e aos valores dos bytecodes nas :ref:`opcode_collections`."

#: ../../library/dis.rst:410
msgid "human readable name for operation"
msgstr "nome legível por humanos para a operação"

#: ../../library/dis.rst:415
msgid ""
"numeric code for the base operation if operation is specialized; otherwise "
"equal to :data:`opcode`"
msgstr ""
"código numérico para a operação base caso a operação seja especializada; "
"caso contrário, igual ao :data:`opcode`"

#: ../../library/dis.rst:421
msgid ""
"human readable name for the base operation if operation is specialized; "
"otherwise equal to :data:`opname`"
msgstr ""
"nome legível por humanos para a operação base caso a operação seja "
"especializada; caso contrário, igual ao :data:`opname`"

#: ../../library/dis.rst:427
msgid "numeric argument to operation (if any), otherwise ``None``"
msgstr ""
"argumento numérico para a operação (se houver), caso contrário ``None``"

#: ../../library/dis.rst:431
msgid "alias for :data:`arg`"
msgstr "apelido para :data:`arg`"

#: ../../library/dis.rst:435
msgid "resolved arg value (if any), otherwise ``None``"
msgstr "valor resolvido do argumento (se houver), caso contrário ``None``"

#: ../../library/dis.rst:440
msgid ""
"human readable description of operation argument (if any), otherwise an "
"empty string."
msgstr ""
"descrição legível por humanos do argumento da operação (se houver), caso "
"contrário uma string vazia."

#: ../../library/dis.rst:446
msgid "start index of operation within bytecode sequence"
msgstr "índice de início da operação dentro da sequência de bytecodes"

#: ../../library/dis.rst:451
msgid ""
"start index of operation within bytecode sequence, including prefixed "
"``EXTENDED_ARG`` operations if present; otherwise equal to :data:`offset`"
msgstr ""
"índice de início da operação dentro da sequência de bytecodes, incluindo as "
"operações de ``EXTENDED_ARG`` prefixadas, caso presentes; caso contrário, "
"igual a :data:`offset`"

#: ../../library/dis.rst:457
msgid "start index of the cache entries following the operation"
msgstr "índice de início das entradas de cache que seguem a operação"

#: ../../library/dis.rst:462
msgid "end index of the cache entries following the operation"
msgstr "índice de fim das entradas de cache que seguem a operação"

#: ../../library/dis.rst:467
msgid "``True`` if this opcode starts a source line, otherwise ``False``"
msgstr "``True`` se esse opcode inicia uma linha, ``False`` caso contrário"

#: ../../library/dis.rst:472
msgid ""
"source line number associated with this opcode (if any), otherwise ``None``"
msgstr ""
"linha de código-fonte associada a esse opcode (se houver), senão ``None``"

#: ../../library/dis.rst:477
msgid "``True`` if other code jumps to here, otherwise ``False``"
msgstr "``True`` se algum outro código pula para cá, senão ``False``"

#: ../../library/dis.rst:482
msgid ""
"bytecode index of the jump target if this is a jump operation, otherwise "
"``None``"
msgstr ""
"índice do bytecode que é alvo do pulo caso essa seja uma operação de pulo, "
"caso contrário ``None``"

#: ../../library/dis.rst:488
msgid ""
":class:`dis.Positions` object holding the start and end locations that are "
"covered by this instruction."
msgstr ""
"objeto :class:`dis.Positions` contendo os pontos de início e fim cobertos "
"por esta instrução."

#: ../../library/dis.rst:503
msgid "Field ``positions`` is added."
msgstr "Adicionado o campo ``positions``."

#: ../../library/dis.rst:507
msgid "Changed field ``starts_line``."
msgstr "Alterado o campo ``starts_line``."

#: ../../library/dis.rst:509
msgid ""
"Added fields ``start_offset``, ``cache_offset``, ``end_offset``, "
"``baseopname``, ``baseopcode``, ``jump_target``, ``oparg``, ``line_number`` "
"and ``cache_info``."
msgstr ""
"Adicionados os campos ``start_offset``, ``cache_offset``, ``end_offset``, "
"``baseopname``, ``baseopcode``, ``jump_target``, ``oparg``, ``line_number`` "
"e ``cache_info``."

#: ../../library/dis.rst:516
msgid ""
"In case the information is not available, some fields might be ``None``."
msgstr ""
"Caso a informação não esteja disponível, alguns campos podem ser ``None``."

#: ../../library/dis.rst:526
msgid ""
"The Python compiler currently generates the following bytecode instructions."
msgstr ""
"O compilador de Python atualmente gera as seguintes instruções de bytecode."

#: ../../library/dis.rst:529
msgid "**General instructions**"
msgstr "**Instruções gerais**"

#: ../../library/dis.rst:531
msgid ""
"In the following, We will refer to the interpreter stack as ``STACK`` and "
"describe operations on it as if it was a Python list. The top of the stack "
"corresponds to ``STACK[-1]`` in this language."
msgstr ""
"A seguir, vamos usar ``STACK`` para nos referirmos à pilha do interpretador, "
"e vamos descrever operações nela como se ela fosse uma lista do Python. "
"Nessa linguagem, ``STACK[-1]`` é o topo da pilha."

#: ../../library/dis.rst:537
msgid ""
"Do nothing code.  Used as a placeholder by the bytecode optimizer, and to "
"generate line tracing events."
msgstr ""
"Código para não fazer nada.  Usado como espaço reservado pelo otimizador de "
"bytecode, e para gerar eventos de rastreamento de linha."

#: ../../library/dis.rst:543
msgid "Removes the top-of-stack item::"
msgstr "Remove o item no topo da pilha::"

#: ../../library/dis.rst:545
msgid "STACK.pop()"
msgstr ""

#: ../../library/dis.rst:550
msgid ""
"Removes the top-of-stack item. Equivalent to ``POP_TOP``. Used to clean up "
"at the end of loops, hence the name."
msgstr ""
"Remove o item no topo da pilha. Equivalente a ``POP_TOP``. Usado como "
"limpeza ao final de laços, o que explica o nome."

#: ../../library/dis.rst:559
msgid "Implements ``del STACK[-2]``. Used to clean up when a generator exits."
msgstr ""
"Implementa ``del STACK[-2]``. Usado como limpeza quando um gerador termina."

#: ../../library/dis.rst:567
msgid ""
"Push the i-th item to the top of the stack without removing it from its "
"original location::"
msgstr ""
"Coloca o i-ésimo item no topo da pilha sem removê-lo da sua posição "
"original::"

#: ../../library/dis.rst:570
msgid ""
"assert i > 0\n"
"STACK.append(STACK[-i])"
msgstr ""

#: ../../library/dis.rst:578
msgid "Swap the top of the stack with the i-th element::"
msgstr "Troca o topo da pilha de lugar com o i-ésimo elemento."

#: ../../library/dis.rst:580
msgid "STACK[-i], STACK[-1] = STACK[-1], STACK[-i]"
msgstr ""

#: ../../library/dis.rst:587
msgid ""
"Rather than being an actual instruction, this opcode is used to mark extra "
"space for the interpreter to cache useful data directly in the bytecode "
"itself. It is automatically hidden by all ``dis`` utilities, but can be "
"viewed with ``show_caches=True``."
msgstr ""
"Ao invés de ser uma instrução de fato, este opcode é usado para demarcar "
"espaço extra para o interpretador armazernar dados úteis diretamente no "
"próprio bytecode. É escondido automaticamente por todas as utilidades do "
"``dis``, mas pode ser visualizado com ``show_caches=True``."

#: ../../library/dis.rst:592
msgid ""
"Logically, this space is part of the preceding instruction. Many opcodes "
"expect to be followed by an exact number of caches, and will instruct the "
"interpreter to skip over them at runtime."
msgstr ""
"Do ponto de vista lógico, este espaço faz parte da instrução anterior. "
"Muitos opcodes esperam ser seguidos por um número exato de caches, e "
"instruem o interpretador a pulá-los em tempo de execução."

#: ../../library/dis.rst:596
msgid ""
"Populated caches can look like arbitrary instructions, so great care should "
"be taken when reading or modifying raw, adaptive bytecode containing "
"quickened data."
msgstr ""
"Caches populados podem se parecer com qualquer instrução, de forma que ler "
"ou modificar bytecode adaptativo bruto contendo dados \"quickened\" requer "
"muito cuidado."

#: ../../library/dis.rst:603
msgid "**Unary operations**"
msgstr "**Operações unárias**"

#: ../../library/dis.rst:605
msgid ""
"Unary operations take the top of the stack, apply the operation, and push "
"the result back on the stack."
msgstr ""
"Operações unárias tiram o topo da pilha, aplicam a operação, e põem o "
"resultado de volta na pilha."

#: ../../library/dis.rst:611
msgid "Implements ``STACK[-1] = -STACK[-1]``."
msgstr "Implementa ``STACK[-1] = -STACK[-1]``."

#: ../../library/dis.rst:616
msgid "Implements ``STACK[-1] = not STACK[-1]``."
msgstr "Implementa ``STACK[-1] = not STACK[-1]``."

#: ../../library/dis.rst:618 ../../library/dis.rst:1314
#: ../../library/dis.rst:1330
msgid "This instruction now requires an exact :class:`bool` operand."
msgstr ""
"Essa instrução agora requer que o operando seja exatamente do tipo :class:"
"`bool`."

#: ../../library/dis.rst:624
msgid "Implements ``STACK[-1] = ~STACK[-1]``."
msgstr "Implementa ``STACK[-1] = ~STACK[-1]``."

#: ../../library/dis.rst:629
msgid "Implements ``STACK[-1] = iter(STACK[-1])``."
msgstr "Implementa ``STACK[-1] = iter(STACK[-1])``."

#: ../../library/dis.rst:634
msgid ""
"If ``STACK[-1]`` is a :term:`generator iterator` or :term:`coroutine` object "
"it is left as is.  Otherwise, implements ``STACK[-1] = iter(STACK[-1])``."
msgstr ""
"Se ``STACK[-1]`` for um :term:`iterador gerador` ou um objeto :term:"
"`corrotina`, nada acontece.  Caso contrário, implementa ``STACK[-1] = "
"iter(STACK[-1])``."

#: ../../library/dis.rst:642
msgid "Implements ``STACK[-1] = bool(STACK[-1])``."
msgstr "Implementa ``STACK[-1] = bool(STACK[-1])``."

#: ../../library/dis.rst:647
msgid "**Binary and in-place operations**"
msgstr "**Operações binárias e internas**"

#: ../../library/dis.rst:649
msgid ""
"Binary operations remove the top two items from the stack (``STACK[-1]`` and "
"``STACK[-2]``). They perform the operation, then put the result back on the "
"stack."
msgstr ""
"Operações binárias removem os dois itens no topo da pilha (``STACK[-1]`` e "
"``STACK[-2]``). A operação é realizada, e o resultado é colocado de volta na "
"pilha."

#: ../../library/dis.rst:652
msgid ""
"In-place operations are like binary operations, but the operation is done in-"
"place when ``STACK[-2]`` supports it, and the resulting ``STACK[-1]`` may be "
"(but does not have to be) the original ``STACK[-2]``."
msgstr ""
"As operações internas são como as operações binárias, só que a operação é "
"feita internamente caso suportado por ``STACK[-2]``, e o ``STACK[-1]`` "
"resultante pode ser (mas não necessariamente é) o ``STACK[-2]`` original."

#: ../../library/dis.rst:659
msgid ""
"Implements the binary and in-place operators (depending on the value of "
"*op*)::"
msgstr ""
"Implementa os operadores binários e locais (depende do valor de *op*)::"

#: ../../library/dis.rst:662
msgid ""
"rhs = STACK.pop()\n"
"lhs = STACK.pop()\n"
"STACK.append(lhs op rhs)"
msgstr ""

#: ../../library/dis.rst:671 ../../library/dis.rst:680
#: ../../library/dis.rst:690 ../../library/dis.rst:698
#: ../../library/dis.rst:710 ../../library/dis.rst:798
#: ../../library/dis.rst:808 ../../library/dis.rst:818
#: ../../library/dis.rst:1042 ../../library/dis.rst:1053
#: ../../library/dis.rst:1157 ../../library/dis.rst:1169
#: ../../library/dis.rst:1181
msgid "Implements::"
msgstr "Implementa::"

#: ../../library/dis.rst:673
msgid ""
"key = STACK.pop()\n"
"container = STACK.pop()\n"
"STACK.append(container[key])"
msgstr ""

#: ../../library/dis.rst:682
msgid ""
"key = STACK.pop()\n"
"container = STACK.pop()\n"
"value = STACK.pop()\n"
"container[key] = value"
msgstr ""

#: ../../library/dis.rst:692
msgid ""
"key = STACK.pop()\n"
"container = STACK.pop()\n"
"del container[key]"
msgstr ""

#: ../../library/dis.rst:700
msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"container = STACK.pop()\n"
"STACK.append(container[start:end])"
msgstr ""

#: ../../library/dis.rst:712
msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"container = STACK.pop()\n"
"values = STACK.pop()\n"
"container[start:end] = value"
msgstr ""

#: ../../library/dis.rst:721
msgid "**Coroutine opcodes**"
msgstr "**Opcodes para corrotinas**"

#: ../../library/dis.rst:725
msgid ""
"Implements ``STACK[-1] = get_awaitable(STACK[-1])``, where "
"``get_awaitable(o)`` returns ``o`` if ``o`` is a coroutine object or a "
"generator object with the :data:`~inspect.CO_ITERABLE_COROUTINE` flag, or "
"resolves ``o.__await__``."
msgstr ""
"Implementa ``STACK[-1] = get_awaitable(STACK[-1])``, onde "
"``get_awaitable(o)`` retorna ``o`` se ``o`` for um objeto de corrotina ou um "
"gerador com o sinalizador :data:`~inspect.CO_ITERABLE_COROUTINE`, ou então "
"resolve ``o.__await__``."

#: ../../library/dis.rst:730
msgid ""
"If the ``where`` operand is nonzero, it indicates where the instruction "
"occurs:"
msgstr ""
"Se o operando ``where`` não for zero, ele indica onde a instrução ocorre:"

#: ../../library/dis.rst:733
msgid "``1``: After a call to ``__aenter__``"
msgstr "``1``: Após uma chamada a ``__aenter__``"

#: ../../library/dis.rst:734
msgid "``2``: After a call to ``__aexit__``"
msgstr "``2``: Após uma chamada a ``__aexit__``"

#: ../../library/dis.rst:738
msgid "Previously, this instruction did not have an oparg."
msgstr "Anteriormente, esta instrução não tinha um oparg."

#: ../../library/dis.rst:744
msgid "Implements ``STACK[-1] = STACK[-1].__aiter__()``."
msgstr "Implementa ``STACK[-1] = STACK[-1].__aiter__()``."

#: ../../library/dis.rst:747
msgid "Returning awaitable objects from ``__aiter__`` is no longer supported."
msgstr "Não é mais aceitado que o ``__aiter__`` retorne objetos aguardáveis."

#: ../../library/dis.rst:754
msgid ""
"Implement ``STACK.append(get_awaitable(STACK[-1].__anext__()))`` to the "
"stack. See ``GET_AWAITABLE`` for details about ``get_awaitable``."
msgstr ""
"Implementa ``STACK.append(get_awaitable(STACK[-1].__anext__()))``. Veja "
"``GET_AWAITABLE`` para o significado de ``get_awaitable``."

#: ../../library/dis.rst:762
msgid ""
"Terminates an :keyword:`async for` loop.  Handles an exception raised when "
"awaiting a next item. The stack contains the async iterable in ``STACK[-2]`` "
"and the raised exception in ``STACK[-1]``. Both are popped. If the exception "
"is not :exc:`StopAsyncIteration`, it is re-raised."
msgstr ""
"Termina um laço :keyword:`async for`.  Trata exceções levantadas ao aguardar "
"um item seguinte. A pilha contém o iterável async em ``STACK[-2]`` e a "
"exceção levantada em ``STACK[-1]``. Ambos são retirados. Se a exceção não "
"for :exc:`StopAsyncIteration`, ela é re-levantada."

#: ../../library/dis.rst:769 ../../library/dis.rst:877
#: ../../library/dis.rst:888
msgid ""
"Exception representation on the stack now consist of one, not three, items."
msgstr ""
"A representação da exceção na pilha consiste agora de um item, ao invés de "
"três."

#: ../../library/dis.rst:775
msgid ""
"Handles an exception raised during a :meth:`~generator.throw` or :meth:"
"`~generator.close` call through the current frame.  If ``STACK[-1]`` is an "
"instance of :exc:`StopIteration`, pop three values from the stack and push "
"its ``value`` member.  Otherwise, re-raise ``STACK[-1]``."
msgstr ""
"Trata uma exceção levantada durante um chamada a :meth:`~generator.throw` "
"ou :meth:`~generator.close` através do quadro atual.  Se ``STACK[-1]`` for "
"uma instância de :exc:`StopIteration`, remove três valores da pilha e põe de "
"volta o seu membro ``value``.  Caso contrário, re-levanta ``STACK[-1]``."

#: ../../library/dis.rst:785
msgid ""
"Resolves ``__aenter__`` and ``__aexit__`` from ``STACK[-1]``. Pushes "
"``__aexit__`` and result of ``__aenter__()`` to the stack::"
msgstr ""
"Resolve os métodos especiais ``__aenter__`` e ``__aexit__`` de "
"``STACK[-1]``. Põe na pilha ``__aexit__`` e o resultado de ``__aenter__()``::"

#: ../../library/dis.rst:788
msgid "STACK.extend((__aexit__, __aenter__())"
msgstr ""

#: ../../library/dis.rst:794
msgid "**Miscellaneous opcodes**"
msgstr "**Opcodes genéricos**"

#: ../../library/dis.rst:800
msgid ""
"item = STACK.pop()\n"
"set.add(STACK[-i], item)"
msgstr ""

#: ../../library/dis.rst:803
msgid "Used to implement set comprehensions."
msgstr "Usado para implementar compreensões de conjuntos."

#: ../../library/dis.rst:810
msgid ""
"item = STACK.pop()\n"
"list.append(STACK[-i], item)"
msgstr ""

#: ../../library/dis.rst:813
msgid "Used to implement list comprehensions."
msgstr "Usado para implementar compreensões de lista."

#: ../../library/dis.rst:820
msgid ""
"value = STACK.pop()\n"
"key = STACK.pop()\n"
"dict.__setitem__(STACK[-i], key, value)"
msgstr ""

#: ../../library/dis.rst:824
msgid "Used to implement dict comprehensions."
msgstr "Usado para implementar compreensões de dicionário."

#: ../../library/dis.rst:827
msgid ""
"Map value is ``STACK[-1]`` and map key is ``STACK[-2]``. Before, those were "
"reversed."
msgstr ""
"O valor do mapa é ``STACK[-1]``, e a sua chave, ``STACK[-2]``. Antes, eles "
"estavam ao contrário."

#: ../../library/dis.rst:831
msgid ""
"For all of the :opcode:`SET_ADD`, :opcode:`LIST_APPEND` and :opcode:"
"`MAP_ADD` instructions, while the added value or key/value pair is popped "
"off, the container object remains on the stack so that it is available for "
"further iterations of the loop."
msgstr ""
"Para as instruções :opcode:`SET_ADD`, :opcode:`LIST_APPEND` e :opcode:"
"`MAP_ADD`, o valor ou par chave/valor é removido da pilha, mas o objeto de "
"contêiner continua na pilha para que ele esteja disponível para as iterações "
"seguintes do laço."

#: ../../library/dis.rst:839
msgid "Returns with ``STACK[-1]`` to the caller of the function."
msgstr "Retorna ``STACK[-1]`` para quem chamou a função."

#: ../../library/dis.rst:844
msgid "Returns with ``co_consts[consti]`` to the caller of the function."
msgstr "Retorna ``co_consts[consti]`` para quem chamou a função."

#: ../../library/dis.rst:851
msgid "Yields ``STACK.pop()`` from a :term:`generator`."
msgstr "Gera ``STACK.pop()`` a partir de um :term:`gerador`."

#: ../../library/dis.rst:853
msgid "oparg set to be the stack depth."
msgstr "oparg definido como sendo a profundidade da pilha."

#: ../../library/dis.rst:856
msgid ""
"oparg set to be the exception block depth, for efficient closing of "
"generators."
msgstr ""
"oparg definido como sendo a profundidade do bloco exception, para o "
"fechamento eficiente de geradores."

#: ../../library/dis.rst:859
msgid ""
"oparg is ``1`` if this instruction is part of a yield-from or await, and "
"``0`` otherwise."
msgstr ""
"oparg é ``1`` caso esta instrução seja parte de um yield-from ou await, e "
"``0`` caso contrário."

#: ../../library/dis.rst:865
msgid ""
"Checks whether ``__annotations__`` is defined in ``locals()``, if not it is "
"set up to an empty ``dict``. This opcode is only emitted if a class or "
"module body contains :term:`variable annotations <variable annotation>` "
"statically."
msgstr ""
"Verifica se ``__annotations__`` está definido em ``locals()`` e, se não "
"estiver, é inicializado como um ``dict`` vazio. Este opcode é emitido "
"somente se o corpo de uma classe ou módulo contém :term:`anotações de "
"variáveis <anotação de variável>` estaticamente."

#: ../../library/dis.rst:875
msgid ""
"Pops a value from the stack, which is used to restore the exception state."
msgstr ""
"Remove o valor no topo da pilha, o qual é usado para restaurar o estado de "
"exceção."

#: ../../library/dis.rst:882
msgid ""
"Re-raises the exception currently on top of the stack. If oparg is non-zero, "
"pops an additional value from the stack which is used to set :attr:`~frame."
"f_lasti` of the current frame."
msgstr ""
"Re-levanta a exceção que se encontra no topo da pilha. Se o oparg não for "
"zero, remove um valor adicional do topo da pilha, o qual é atribuído ao :"
"attr:`~frame.f_lasti`` do quadro atual."

#: ../../library/dis.rst:893
msgid ""
"Pops a value from the stack. Pushes the current exception to the top of the "
"stack. Pushes the value originally popped back to the stack. Used in "
"exception handlers."
msgstr ""
"Remove um valor do topo da pilha. Põe a exceção atual no topo da pilha. Põe "
"de volta no topo da pilha o valor que foi removido inicialmente. Usado em "
"tratadores de exceções."

#: ../../library/dis.rst:901
msgid ""
"Performs exception matching for ``except``. Tests whether the ``STACK[-2]`` "
"is an exception matching ``STACK[-1]``. Pops ``STACK[-1]`` and pushes the "
"boolean result of the test."
msgstr ""
"Verifica correspondências de exceções em ``except``. Testa de ``STACK[-2]`` "
"é uma exceção que corresponde a ``STACK[-1]``. Remove ``STACK[-1]`` do topo "
"da pilha, e põe no seu lugar o resultado booleano do teste."

#: ../../library/dis.rst:909
msgid ""
"Performs exception matching for ``except*``. Applies ``split(STACK[-1])`` on "
"the exception group representing ``STACK[-2]``."
msgstr ""
"Verifica correspondências de exceções em ``except*``. Aplica "
"``split(STACK[-1])`` no grupo de exceções que representa ``STACK[-2]``."

#: ../../library/dis.rst:912
msgid ""
"In case of a match, pops two items from the stack and pushes the non-"
"matching subgroup (``None`` in case of full match) followed by the matching "
"subgroup. When there is no match, pops one item (the match type) and pushes "
"``None``."
msgstr ""
"No caso de uma correspondência, remove dois itens do topo da pilha e põe "
"nela o subgrupo que falhou a correspondência (``None`` caso a "
"correspondência tenha sido total), seguido pelo subgrupo que correspondeu. "
"Quando não há correspondência nenhuma, remove um item (o tipo da "
"correspondêcia) e põe ``None`` no seu lugar."

#: ../../library/dis.rst:921
msgid ""
"Calls the function in position 4 on the stack with arguments (type, val, tb) "
"representing the exception at the top of the stack. Used to implement the "
"call ``context_manager.__exit__(*exc_info())`` when an exception has "
"occurred in a :keyword:`with` statement."
msgstr ""
"Chama a função na posição 4 da pilha com argumentos (tipo, val, tb) "
"representando a exceção no topo da pilha. Usado para implementar a chamada "
"``context_manager.__exit__(*exc_info())`` quando uma exceção ocorreu em uma "
"instrução :keyword:`with`."

#: ../../library/dis.rst:928
msgid ""
"The ``__exit__`` function is in position 4 of the stack rather than 7. "
"Exception representation on the stack now consist of one, not three, items."
msgstr ""
"A função ``__exit__`` fica agora na posição 4 pilha, ao invés da 7. A "
"representação da exceção pilha consiste agora de um item, não três."

#: ../../library/dis.rst:935
msgid ""
"Pushes :exc:`AssertionError` onto the stack.  Used by the :keyword:`assert` "
"statement."
msgstr ""
"Põe :exc:`AssertionError` no topo da pilha.  Usado pela instrução :keyword:"
"`assert`."

#: ../../library/dis.rst:943
msgid ""
"Pushes :func:`!builtins.__build_class__` onto the stack.  It is later called "
"to construct a class."
msgstr ""
"Põe a função :func:`!builtins.__build_class__` no topo da pilha.  Ela será "
"chamada posteriormente para construir uma classe."

#: ../../library/dis.rst:949
msgid ""
"This opcode performs several operations before a with block starts.  First, "
"it loads :meth:`~object.__exit__` from the context manager and pushes it "
"onto the stack for later use by :opcode:`WITH_EXCEPT_START`.  Then, :meth:"
"`~object.__enter__` is called. Finally, the result of calling the "
"``__enter__()`` method is pushed onto the stack."
msgstr ""
"Este opcode realiza várias operações antes do início de um bloco \"with\".  "
"Primeiro, ele carrega o :meth:`~object.__exit__` do gerenciador de contexto "
"e o coloca no topo da pilha para ser usado posteriormente pela :opcode:"
"`WITH_EXCEPT_START`.  Então, o método :meth:`~object.__enter__` é chamado. "
"Por fim, o resultado do ``__enter__()`` é posto no topo da pilha."

#: ../../library/dis.rst:960
msgid ""
"Perform ``STACK.append(len(STACK[-1]))``. Used in :keyword:`match` "
"statements where comparison with structure of pattern is needed."
msgstr ""

#: ../../library/dis.rst:968
msgid ""
"If ``STACK[-1]`` is an instance of :class:`collections.abc.Mapping` (or, "
"more technically: if it has the :c:macro:`Py_TPFLAGS_MAPPING` flag set in "
"its :c:member:`~PyTypeObject.tp_flags`), push ``True`` onto the stack.  "
"Otherwise, push ``False``."
msgstr ""
"Se ``STACK[-1]`` for uma instância de :class:`collections.abc.Mapping` (ou, "
"de forma mais técnica: se tiver o sinalizador :c:macro:`Py_TPFLAGS_MAPPING` "
"definido no seu :c:member:`~PyTypeObject.tp_flags`), põe ``True`` no topo da "
"pilha. Caso contrário, põe ``False``."

#: ../../library/dis.rst:978
msgid ""
"If ``STACK[-1]`` is an instance of :class:`collections.abc.Sequence` and is "
"*not* an instance of :class:`str`/:class:`bytes`/:class:`bytearray` (or, "
"more technically: if it has the :c:macro:`Py_TPFLAGS_SEQUENCE` flag set in "
"its :c:member:`~PyTypeObject.tp_flags`), push ``True`` onto the stack.  "
"Otherwise, push ``False``."
msgstr ""
"Se ``STACK[-1]`` for uma instância de :class:`collections.abc.Sequence` e "
"*não* for uma instância de :class:`str`/:class:`bytes`/:class:`bytearray` "
"(ou, de forma mais técnica: se tiver o sinalizador :c:macro:"
"`Py_TPFLAGS_SEQUENCE` definido no seu :c:member:`~PyTypeObject.tp_flags`), "
"põe ``True`` no topo da pilha. Caso contrário, põe ``False``."

#: ../../library/dis.rst:988
msgid ""
"``STACK[-1]`` is a tuple of mapping keys, and ``STACK[-2]`` is the match "
"subject. If ``STACK[-2]`` contains all of the keys in ``STACK[-1]``, push a :"
"class:`tuple` containing the corresponding values. Otherwise, push ``None``."
msgstr ""
"``STACK[-1]`` é uma tupla de chaves de um mapeamento, e ``STACK[-2]`` é o "
"sujeito de uma correspondência. Se ``STACK[-2]`` contiver todas as chaves em "
"``STACK[-1]``, põe no topo da pilha um :class:`tuple` contendo os valores "
"correspondentes. Caso contrário, põe ``None``."

#: ../../library/dis.rst:994 ../../library/dis.rst:1665
msgid ""
"Previously, this instruction also pushed a boolean value indicating success "
"(``True``) or failure (``False``)."
msgstr ""
"Anteriormente, essa instrução também colocava na pilha um valor booleano "
"indicando sucesso (``True``) ou falha (``False``)."

#: ../../library/dis.rst:1001
msgid ""
"Implements ``name = STACK.pop()``. *namei* is the index of *name* in the "
"attribute :attr:`~codeobject.co_names` of the :ref:`code object <code-"
"objects>`. The compiler tries to use :opcode:`STORE_FAST` or :opcode:"
"`STORE_GLOBAL` if possible."
msgstr ""
"Implementa ``name = STACK.pop()``. *namei* é o índice de *name* no atributo :"
"attr:`~codeobject.co_names` do :ref:`objeto de código <code-objects>`. O "
"compilador tenta usar :opcode:`STORE_FAST` ou :opcode:`STORE_GLOBAL` se "
"possível."

#: ../../library/dis.rst:1008
msgid ""
"Implements ``del name``, where *namei* is the index into :attr:`~codeobject."
"co_names` attribute of the :ref:`code object <code-objects>`."
msgstr ""
"Implementa ``del name``, onde *namei* é o índice no atributo :attr:"
"`~codeobject.co_names` do :ref:`objeto de código <code-objects>`."

#: ../../library/dis.rst:1014
msgid ""
"Unpacks ``STACK[-1]`` into *count* individual values, which are put onto the "
"stack right-to-left. Require there to be exactly *count* values.::"
msgstr ""
"Desempacota ``STACK[-1]`` em *count* valores individuais, os quais são "
"postos na pilha da direita para a esquerda. Requer que haja exatamente "
"*count* valores::"

#: ../../library/dis.rst:1017
msgid ""
"assert(len(STACK[-1]) == count)\n"
"STACK.extend(STACK.pop()[:-count-1:-1])"
msgstr ""

#: ../../library/dis.rst:1023
msgid ""
"Implements assignment with a starred target: Unpacks an iterable in "
"``STACK[-1]`` into individual values, where the total number of values can "
"be smaller than the number of items in the iterable: one of the new values "
"will be a list of all leftover items."
msgstr ""
"Implementa atribuição com um alvo estrelado: desempacota o iterável "
"``STACK[-1]`` em valores individuais, sendo que pode haver menos valores do "
"que itens no iterável: um dos novos valores será a lista de todos os itens "
"que sobraram."

#: ../../library/dis.rst:1028
msgid "The number of values before and after the list value is limited to 255."
msgstr ""
"A quantidade de valores antes e após o valor que será a lista é limitada a "
"255."

#: ../../library/dis.rst:1030
msgid ""
"The number of values before the list value is encoded in the argument of the "
"opcode. The number of values after the list if any is encoded using an "
"``EXTENDED_ARG``. As a consequence, the argument can be seen as a two bytes "
"values where the low byte of *counts* is the number of values before the "
"list value, the high byte of *counts* the number of values after it."
msgstr ""
"A quantidade de valores antes do valor lista é passada no argumento do "
"opcode. A quantidade de valores após a lista, se houver, é passada usando um "
"``EXTENDED_ARG``. A consequência é que o argumento pode ser visto como um "
"valor de dois bytes, onde o byte \"de baixo\" de *counts* é a quantidade de "
"valores antes do valor lista, e o byte \"de cima\" de *counts*, a quantidade "
"após."

#: ../../library/dis.rst:1036
msgid ""
"The extracted values are put onto the stack right-to-left, i.e. ``a, *b, c = "
"d`` will be stored after execution as ``STACK.extend((a, b, c))``."
msgstr ""
"Os valores extraídos são postos na pilha da direita para a esquerda, ou "
"seja, após executar ``a, *b, c = d`` os valores serão armazenados como "
"``STACK.extend((a, b, c))``."

#: ../../library/dis.rst:1044
msgid ""
"obj = STACK.pop()\n"
"value = STACK.pop()\n"
"obj.name = value"
msgstr ""

#: ../../library/dis.rst:1048
msgid ""
"where *namei* is the index of name in :attr:`~codeobject.co_names` of the :"
"ref:`code object <code-objects>`."
msgstr ""
"onde *namei* é o índice do nome no :attr:`~codeobject.co_names` do :ref:"
"`objeto de código <code-objects>`."

#: ../../library/dis.rst:1055
msgid ""
"obj = STACK.pop()\n"
"del obj.name"
msgstr ""

#: ../../library/dis.rst:1058
msgid ""
"where *namei* is the index of name into :attr:`~codeobject.co_names` of the :"
"ref:`code object <code-objects>`."
msgstr ""
"onde *namei* é o índice do nome no :attr:`~codeobject.co_names` do :ref:"
"`objeto de código <code-objects>`."

#: ../../library/dis.rst:1064
msgid "Works as :opcode:`STORE_NAME`, but stores the name as a global."
msgstr ""
"Funciona como o :opcode:`STORE_NAME`, mas o nome é armazenado com um nome "
"global."

#: ../../library/dis.rst:1069
msgid "Works as :opcode:`DELETE_NAME`, but deletes a global name."
msgstr "Funciona como o :opcode:`DELETE_NAME`, mas deleta um nome global."

#: ../../library/dis.rst:1074
msgid "Pushes ``co_consts[consti]`` onto the stack."
msgstr "Põe ``co_consts[consti]`` no topo da pilha."

#: ../../library/dis.rst:1079
msgid ""
"Pushes the value associated with ``co_names[namei]`` onto the stack. The "
"name is looked up within the locals, then the globals, then the builtins."
msgstr ""
"Põe no topo da pilha o valor associado a ``co_names[namei]``. O nome é "
"procurado nos locais, nos globais, e então nos embutidos."

#: ../../library/dis.rst:1085
msgid ""
"Pushes a reference to the locals dictionary onto the stack.  This is used to "
"prepare namespace dictionaries for :opcode:`LOAD_FROM_DICT_OR_DEREF` and :"
"opcode:`LOAD_FROM_DICT_OR_GLOBALS`."
msgstr ""

#: ../../library/dis.rst:1094
msgid ""
"Pops a mapping off the stack and looks up the value for ``co_names[namei]``. "
"If the name is not found there, looks it up in the globals and then the "
"builtins, similar to :opcode:`LOAD_GLOBAL`. This is used for loading global "
"variables in :ref:`annotation scopes <annotation-scopes>` within class "
"bodies."
msgstr ""

#: ../../library/dis.rst:1105
msgid ""
"Creates a tuple consuming *count* items from the stack, and pushes the "
"resulting tuple onto the stack::"
msgstr ""

#: ../../library/dis.rst:1108
msgid ""
"if count == 0:\n"
"    value = ()\n"
"else:\n"
"    value = tuple(STACK[-count:])\n"
"    STACK = STACK[:-count]\n"
"\n"
"STACK.append(value)"
msgstr ""

#: ../../library/dis.rst:1119
msgid "Works as :opcode:`BUILD_TUPLE`, but creates a list."
msgstr ""

#: ../../library/dis.rst:1124
msgid "Works as :opcode:`BUILD_TUPLE`, but creates a set."
msgstr ""

#: ../../library/dis.rst:1129
msgid ""
"Pushes a new dictionary object onto the stack.  Pops ``2 * count`` items so "
"that the dictionary holds *count* entries: ``{..., STACK[-4]: STACK[-3], "
"STACK[-2]: STACK[-1]}``."
msgstr ""

#: ../../library/dis.rst:1133
msgid ""
"The dictionary is created from stack items instead of creating an empty "
"dictionary pre-sized to hold *count* items."
msgstr ""

#: ../../library/dis.rst:1140
msgid ""
"The version of :opcode:`BUILD_MAP` specialized for constant keys. Pops the "
"top element on the stack which contains a tuple of keys, then starting from "
"``STACK[-2]``, pops *count* values to form values in the built dictionary."
msgstr ""

#: ../../library/dis.rst:1149
msgid ""
"Concatenates *count* strings from the stack and pushes the resulting string "
"onto the stack."
msgstr ""

#: ../../library/dis.rst:1159
msgid ""
"seq = STACK.pop()\n"
"list.extend(STACK[-i], seq)"
msgstr ""

#: ../../library/dis.rst:1162
msgid "Used to build lists."
msgstr ""

#: ../../library/dis.rst:1171
msgid ""
"seq = STACK.pop()\n"
"set.update(STACK[-i], seq)"
msgstr ""

#: ../../library/dis.rst:1174
msgid "Used to build sets."
msgstr ""

#: ../../library/dis.rst:1183
msgid ""
"map = STACK.pop()\n"
"dict.update(STACK[-i], map)"
msgstr ""

#: ../../library/dis.rst:1186
msgid "Used to build dicts."
msgstr ""

#: ../../library/dis.rst:1193
msgid "Like :opcode:`DICT_UPDATE` but raises an exception for duplicate keys."
msgstr ""

#: ../../library/dis.rst:1200
msgid ""
"If the low bit of ``namei`` is not set, this replaces ``STACK[-1]`` with "
"``getattr(STACK[-1], co_names[namei>>1])``."
msgstr ""

#: ../../library/dis.rst:1203
msgid ""
"If the low bit of ``namei`` is set, this will attempt to load a method named "
"``co_names[namei>>1]`` from the ``STACK[-1]`` object. ``STACK[-1]`` is "
"popped. This bytecode distinguishes two cases: if ``STACK[-1]`` has a method "
"with the correct name, the bytecode pushes the unbound method and "
"``STACK[-1]``. ``STACK[-1]`` will be used as the first argument (``self``) "
"by :opcode:`CALL` or :opcode:`CALL_KW` when calling the unbound method. "
"Otherwise, ``NULL`` and the object returned by the attribute lookup are "
"pushed."
msgstr ""

#: ../../library/dis.rst:1212
msgid ""
"If the low bit of ``namei`` is set, then a ``NULL`` or ``self`` is pushed to "
"the stack before the attribute or unbound method respectively."
msgstr ""

#: ../../library/dis.rst:1219
msgid ""
"This opcode implements :func:`super`, both in its zero-argument and two-"
"argument forms (e.g. ``super().method()``, ``super().attr`` and ``super(cls, "
"self).method()``, ``super(cls, self).attr``)."
msgstr ""

#: ../../library/dis.rst:1223
msgid "It pops three values from the stack (from top of stack down):"
msgstr ""

#: ../../library/dis.rst:1225
msgid "``self``: the first argument to the current method"
msgstr ""

#: ../../library/dis.rst:1226
msgid "``cls``: the class within which the current method was defined"
msgstr ""

#: ../../library/dis.rst:1227
msgid "the global ``super``"
msgstr ""

#: ../../library/dis.rst:1229
msgid ""
"With respect to its argument, it works similarly to :opcode:`LOAD_ATTR`, "
"except that ``namei`` is shifted left by 2 bits instead of 1."
msgstr ""

#: ../../library/dis.rst:1232
msgid ""
"The low bit of ``namei`` signals to attempt a method load, as with :opcode:"
"`LOAD_ATTR`, which results in pushing ``NULL`` and the loaded method. When "
"it is unset a single value is pushed to the stack."
msgstr ""

#: ../../library/dis.rst:1236
msgid ""
"The second-low bit of ``namei``, if set, means that this was a two-argument "
"call to :func:`super` (unset means zero-argument)."
msgstr ""

#: ../../library/dis.rst:1244
msgid ""
"Performs a Boolean operation.  The operation name can be found in "
"``cmp_op[opname >> 5]``. If the fifth-lowest bit of ``opname`` is set "
"(``opname & 16``), the result should be coerced to ``bool``."
msgstr ""

#: ../../library/dis.rst:1248
msgid ""
"The fifth-lowest bit of the oparg now indicates a forced conversion to :"
"class:`bool`."
msgstr ""

#: ../../library/dis.rst:1255
msgid "Performs ``is`` comparison, or ``is not`` if ``invert`` is 1."
msgstr ""

#: ../../library/dis.rst:1262
msgid "Performs ``in`` comparison, or ``not in`` if ``invert`` is 1."
msgstr ""

#: ../../library/dis.rst:1269
msgid ""
"Imports the module ``co_names[namei]``.  ``STACK[-1]`` and ``STACK[-2]`` are "
"popped and provide the *fromlist* and *level* arguments of :func:"
"`__import__`. The module object is pushed onto the stack.  The current "
"namespace is not affected: for a proper import statement, a subsequent :"
"opcode:`STORE_FAST` instruction modifies the namespace."
msgstr ""

#: ../../library/dis.rst:1277
msgid ""
"Loads the attribute ``co_names[namei]`` from the module found in "
"``STACK[-1]``. The resulting object is pushed onto the stack, to be "
"subsequently stored by a :opcode:`STORE_FAST` instruction."
msgstr ""

#: ../../library/dis.rst:1284
msgid "Increments bytecode counter by *delta*."
msgstr ""

#: ../../library/dis.rst:1289
msgid "Decrements bytecode counter by *delta*. Checks for interrupts."
msgstr ""

#: ../../library/dis.rst:1296
msgid "Decrements bytecode counter by *delta*. Does not check for interrupts."
msgstr ""

#: ../../library/dis.rst:1303
msgid ""
"If ``STACK[-1]`` is true, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""

#: ../../library/dis.rst:1306 ../../library/dis.rst:1322
msgid ""
"The oparg is now a relative delta rather than an absolute target. This "
"opcode is a pseudo-instruction, replaced in final bytecode by the directed "
"versions (forward/backward)."
msgstr ""

#: ../../library/dis.rst:1311 ../../library/dis.rst:1327
#: ../../library/dis.rst:1343 ../../library/dis.rst:1357
msgid "This is no longer a pseudo-instruction."
msgstr ""

#: ../../library/dis.rst:1319
msgid ""
"If ``STACK[-1]`` is false, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""

#: ../../library/dis.rst:1335
msgid ""
"If ``STACK[-1]`` is not ``None``, increments the bytecode counter by "
"*delta*. ``STACK[-1]`` is popped."
msgstr ""

#: ../../library/dis.rst:1338 ../../library/dis.rst:1352
msgid ""
"This opcode is a pseudo-instruction, replaced in final bytecode by the "
"directed versions (forward/backward)."
msgstr ""

#: ../../library/dis.rst:1349
msgid ""
"If ``STACK[-1]`` is ``None``, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""

#: ../../library/dis.rst:1362
msgid ""
"``STACK[-1]`` is an :term:`iterator`.  Call its :meth:`~iterator.__next__` "
"method. If this yields a new value, push it on the stack (leaving the "
"iterator below it).  If the iterator indicates it is exhausted then the byte "
"code counter is incremented by *delta*."
msgstr ""

#: ../../library/dis.rst:1367
msgid "Up until 3.11 the iterator was popped when it was exhausted."
msgstr ""

#: ../../library/dis.rst:1372
msgid "Loads the global named ``co_names[namei>>1]`` onto the stack."
msgstr ""

#: ../../library/dis.rst:1374
msgid ""
"If the low bit of ``namei`` is set, then a ``NULL`` is pushed to the stack "
"before the global variable."
msgstr ""

#: ../../library/dis.rst:1380
msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack."
msgstr ""

#: ../../library/dis.rst:1382
msgid ""
"This opcode is now only used in situations where the local variable is "
"guaranteed to be initialized. It cannot raise :exc:`UnboundLocalError`."
msgstr ""

#: ../../library/dis.rst:1388
msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack, "
"raising an :exc:`UnboundLocalError` if the local variable has not been "
"initialized."
msgstr ""

#: ../../library/dis.rst:1396
msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack (or "
"pushes ``NULL`` onto the stack if the local variable has not been "
"initialized) and sets ``co_varnames[var_num]`` to ``NULL``."
msgstr ""

#: ../../library/dis.rst:1404
msgid "Stores ``STACK.pop()`` into the local ``co_varnames[var_num]``."
msgstr ""

#: ../../library/dis.rst:1409
msgid "Deletes local ``co_varnames[var_num]``."
msgstr ""

#: ../../library/dis.rst:1414
msgid ""
"Creates a new cell in slot ``i``.  If that slot is nonempty then that value "
"is stored into the new cell."
msgstr ""

#: ../../library/dis.rst:1422
msgid ""
"Loads the cell contained in slot ``i`` of the \"fast locals\" storage. "
"Pushes a reference to the object the cell contains on the stack."
msgstr ""

#: ../../library/dis.rst:1425 ../../library/dis.rst:1447
#: ../../library/dis.rst:1458
msgid ""
"``i`` is no longer offset by the length of :attr:`~codeobject.co_varnames`."
msgstr ""

#: ../../library/dis.rst:1431
msgid ""
"Pops a mapping off the stack and looks up the name associated with slot "
"``i`` of the \"fast locals\" storage in this mapping. If the name is not "
"found there, loads it from the cell contained in slot ``i``, similar to :"
"opcode:`LOAD_DEREF`. This is used for loading :term:`closure variables "
"<closure variable>` in class bodies (which previously used :opcode:`!"
"LOAD_CLASSDEREF`) and in :ref:`annotation scopes <annotation-scopes>` within "
"class bodies."
msgstr ""

#: ../../library/dis.rst:1444
msgid ""
"Stores ``STACK.pop()`` into the cell contained in slot ``i`` of the \"fast "
"locals\" storage."
msgstr ""

#: ../../library/dis.rst:1453
msgid ""
"Empties the cell contained in slot ``i`` of the \"fast locals\" storage. "
"Used by the :keyword:`del` statement."
msgstr ""

#: ../../library/dis.rst:1464
msgid ""
"Copies the ``n`` :term:`free (closure) variables <closure variable>` from "
"the closure into the frame. Removes the need for special code on the "
"caller's side when calling closures."
msgstr ""
"Copia as ``n`` :term:`variáveis livres (de clausura) <closure variable>` do "
"fechamento para o quadro. Remove a necessidade de código especial do lado do "
"chamador ao chamar closures."

#: ../../library/dis.rst:1473
msgid ""
"Raises an exception using one of the 3 forms of the ``raise`` statement, "
"depending on the value of *argc*:"
msgstr ""

#: ../../library/dis.rst:1476
msgid "0: ``raise`` (re-raise previous exception)"
msgstr ""

#: ../../library/dis.rst:1477
msgid ""
"1: ``raise STACK[-1]`` (raise exception instance or type at ``STACK[-1]``)"
msgstr ""

#: ../../library/dis.rst:1478
msgid ""
"2: ``raise STACK[-2] from STACK[-1]`` (raise exception instance or type at "
"``STACK[-2]`` with ``__cause__`` set to ``STACK[-1]``)"
msgstr ""

#: ../../library/dis.rst:1484
msgid ""
"Calls a callable object with the number of arguments specified by ``argc``. "
"On the stack are (in ascending order):"
msgstr ""

#: ../../library/dis.rst:1487 ../../library/dis.rst:1511
msgid "The callable"
msgstr ""

#: ../../library/dis.rst:1488 ../../library/dis.rst:1512
msgid "``self`` or ``NULL``"
msgstr ""

#: ../../library/dis.rst:1489 ../../library/dis.rst:1513
msgid "The remaining positional arguments"
msgstr ""

#: ../../library/dis.rst:1491
msgid "``argc`` is the total of the positional arguments, excluding ``self``."
msgstr ""

#: ../../library/dis.rst:1493
msgid ""
"``CALL`` pops all arguments and the callable object off the stack, calls the "
"callable object with those arguments, and pushes the return value returned "
"by the callable object."
msgstr ""

#: ../../library/dis.rst:1499
msgid "The callable now always appears at the same position on the stack."
msgstr ""

#: ../../library/dis.rst:1502
msgid "Calls with keyword arguments are now handled by :opcode:`CALL_KW`."
msgstr ""

#: ../../library/dis.rst:1508
msgid ""
"Calls a callable object with the number of arguments specified by ``argc``, "
"including one or more named arguments. On the stack are (in ascending order):"
msgstr ""

#: ../../library/dis.rst:1514
msgid "The named arguments"
msgstr ""

#: ../../library/dis.rst:1515
msgid "A :class:`tuple` of keyword argument names"
msgstr ""

#: ../../library/dis.rst:1517
msgid ""
"``argc`` is the total of the positional and named arguments, excluding "
"``self``. The length of the tuple of keyword argument names is the number of "
"named arguments."
msgstr ""

#: ../../library/dis.rst:1520
msgid ""
"``CALL_KW`` pops all arguments, the keyword names, and the callable object "
"off the stack, calls the callable object with those arguments, and pushes "
"the return value returned by the callable object."
msgstr ""

#: ../../library/dis.rst:1529
msgid ""
"Calls a callable object with variable set of positional and keyword "
"arguments.  If the lowest bit of *flags* is set, the top of the stack "
"contains a mapping object containing additional keyword arguments. Before "
"the callable is called, the mapping object and iterable object are each "
"\"unpacked\" and their contents passed in as keyword and positional "
"arguments respectively. ``CALL_FUNCTION_EX`` pops all arguments and the "
"callable object off the stack, calls the callable object with those "
"arguments, and pushes the return value returned by the callable object."
msgstr ""

#: ../../library/dis.rst:1544
msgid ""
"Pushes a ``NULL`` to the stack. Used in the call sequence to match the "
"``NULL`` pushed by :opcode:`LOAD_METHOD` for non-method calls."
msgstr ""

#: ../../library/dis.rst:1553
msgid ""
"Pushes a new function object on the stack built from the code object at "
"``STACK[-1]``."
msgstr ""

#: ../../library/dis.rst:1555
msgid "Flag value ``0x04`` is a tuple of strings instead of dictionary"
msgstr ""

#: ../../library/dis.rst:1558
msgid "Qualified name at ``STACK[-1]`` was removed."
msgstr ""

#: ../../library/dis.rst:1561
msgid ""
"Extra function attributes on the stack, signaled by oparg flags, were "
"removed. They now use :opcode:`SET_FUNCTION_ATTRIBUTE`."
msgstr ""

#: ../../library/dis.rst:1568
msgid ""
"Sets an attribute on a function object. Expects the function at "
"``STACK[-1]`` and the attribute value to set at ``STACK[-2]``; consumes both "
"and leaves the function at ``STACK[-1]``. The flag determines which "
"attribute to set:"
msgstr ""

#: ../../library/dis.rst:1572
msgid ""
"``0x01`` a tuple of default values for positional-only and positional-or-"
"keyword parameters in positional order"
msgstr ""

#: ../../library/dis.rst:1574
msgid "``0x02`` a dictionary of keyword-only parameters' default values"
msgstr ""

#: ../../library/dis.rst:1575
msgid "``0x04`` a tuple of strings containing parameters' annotations"
msgstr ""

#: ../../library/dis.rst:1576
msgid "``0x08`` a tuple containing cells for free variables, making a closure"
msgstr ""

#: ../../library/dis.rst:1585
msgid ""
"Pushes a slice object on the stack.  *argc* must be 2 or 3.  If it is 2, "
"implements::"
msgstr ""

#: ../../library/dis.rst:1587
msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"STACK.append(slice(start, end))"
msgstr ""

#: ../../library/dis.rst:1591
msgid "if it is 3, implements::"
msgstr ""

#: ../../library/dis.rst:1593
msgid ""
"step = STACK.pop()\n"
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"STACK.append(slice(start, end, step))"
msgstr ""

#: ../../library/dis.rst:1598
msgid "See the :func:`slice` built-in function for more information."
msgstr ""

#: ../../library/dis.rst:1603
msgid ""
"Prefixes any opcode which has an argument too big to fit into the default "
"one byte. *ext* holds an additional byte which act as higher bits in the "
"argument. For each opcode, at most three prefixal ``EXTENDED_ARG`` are "
"allowed, forming an argument from two-byte to four-byte."
msgstr ""

#: ../../library/dis.rst:1611
msgid "Convert value to a string, depending on ``oparg``::"
msgstr ""

#: ../../library/dis.rst:1613
msgid ""
"value = STACK.pop()\n"
"result = func(value)\n"
"STACK.append(result)"
msgstr ""

#: ../../library/dis.rst:1617
msgid "``oparg == 1``: call :func:`str` on *value*"
msgstr ""

#: ../../library/dis.rst:1618
msgid "``oparg == 2``: call :func:`repr` on *value*"
msgstr ""

#: ../../library/dis.rst:1619
msgid "``oparg == 3``: call :func:`ascii` on *value*"
msgstr ""

#: ../../library/dis.rst:1621 ../../library/dis.rst:1634
#: ../../library/dis.rst:1647
msgid "Used for implementing formatted literal strings (f-strings)."
msgstr ""

#: ../../library/dis.rst:1628
msgid "Formats the value on top of stack::"
msgstr ""

#: ../../library/dis.rst:1630
msgid ""
"value = STACK.pop()\n"
"result = value.__format__(\"\")\n"
"STACK.append(result)"
msgstr ""

#: ../../library/dis.rst:1640
msgid "Formats the given value with the given format spec::"
msgstr ""

#: ../../library/dis.rst:1642
msgid ""
"spec = STACK.pop()\n"
"value = STACK.pop()\n"
"result = value.__format__(spec)\n"
"STACK.append(result)"
msgstr ""

#: ../../library/dis.rst:1654
msgid ""
"``STACK[-1]`` is a tuple of keyword attribute names, ``STACK[-2]`` is the "
"class being matched against, and ``STACK[-3]`` is the match subject.  "
"*count* is the number of positional sub-patterns."
msgstr ""

#: ../../library/dis.rst:1658
msgid ""
"Pop ``STACK[-1]``, ``STACK[-2]``, and ``STACK[-3]``. If ``STACK[-3]`` is an "
"instance of ``STACK[-2]`` and has the positional and keyword attributes "
"required by *count* and ``STACK[-1]``, push a tuple of extracted attributes. "
"Otherwise, push ``None``."
msgstr ""

#: ../../library/dis.rst:1672
msgid "A no-op. Performs internal tracing, debugging and optimization checks."
msgstr ""

#: ../../library/dis.rst:1674
msgid ""
"The ``context`` oparand consists of two parts. The lowest two bits indicate "
"where the ``RESUME`` occurs:"
msgstr ""

#: ../../library/dis.rst:1677
msgid ""
"``0`` The start of a function, which is neither a generator, coroutine nor "
"an async generator"
msgstr ""

#: ../../library/dis.rst:1679
msgid "``1`` After a ``yield`` expression"
msgstr "``1`` Depois de uma expressão ``yield``"

#: ../../library/dis.rst:1680
msgid "``2`` After a ``yield from`` expression"
msgstr ""

#: ../../library/dis.rst:1681
msgid "``3`` After an ``await`` expression"
msgstr "``3`` Depois de uma expressão ``await``"

#: ../../library/dis.rst:1683
msgid ""
"The next bit is ``1`` if the RESUME is at except-depth ``1``, and ``0`` "
"otherwise."
msgstr ""

#: ../../library/dis.rst:1688
msgid "The oparg value changed to include information about except-depth"
msgstr ""

#: ../../library/dis.rst:1694
msgid ""
"Create a generator, coroutine, or async generator from the current frame. "
"Used as first opcode of in code object for the above mentioned callables. "
"Clear the current frame and return the newly created generator."
msgstr ""

#: ../../library/dis.rst:1703
msgid ""
"Equivalent to ``STACK[-1] = STACK[-2].send(STACK[-1])``. Used in ``yield "
"from`` and ``await`` statements."
msgstr ""

#: ../../library/dis.rst:1706
msgid ""
"If the call raises :exc:`StopIteration`, pop the top value from the stack, "
"push the exception's ``value`` attribute, and increment the bytecode counter "
"by *delta*."
msgstr ""

#: ../../library/dis.rst:1715
msgid ""
"This is not really an opcode.  It identifies the dividing line between "
"opcodes in the range [0,255] which don't use their argument and those that "
"do (``< HAVE_ARGUMENT`` and ``>= HAVE_ARGUMENT``, respectively)."
msgstr ""

#: ../../library/dis.rst:1719
msgid ""
"If your application uses pseudo instructions or specialized instructions, "
"use the :data:`hasarg` collection instead."
msgstr ""

#: ../../library/dis.rst:1722
msgid ""
"Now every instruction has an argument, but opcodes ``< HAVE_ARGUMENT`` "
"ignore it. Before, only opcodes ``>= HAVE_ARGUMENT`` had an argument."
msgstr ""

#: ../../library/dis.rst:1726
msgid ""
"Pseudo instructions were added to the :mod:`dis` module, and for them it is "
"not true that comparison with ``HAVE_ARGUMENT`` indicates whether they use "
"their arg."
msgstr ""

#: ../../library/dis.rst:1731
msgid "Use :data:`hasarg` instead."
msgstr ""

#: ../../library/dis.rst:1736
msgid ""
"Calls an intrinsic function with one argument. Passes ``STACK[-1]`` as the "
"argument and sets ``STACK[-1]`` to the result. Used to implement "
"functionality that is not performance critical."
msgstr ""

#: ../../library/dis.rst:1740 ../../library/dis.rst:1794
msgid "The operand determines which intrinsic function is called:"
msgstr ""

#: ../../library/dis.rst:1743 ../../library/dis.rst:1797
msgid "Operand"
msgstr ""

#: ../../library/dis.rst:1743 ../../library/dis.rst:1797
msgid "Description"
msgstr "Descrição"

#: ../../library/dis.rst:1745
msgid "``INTRINSIC_1_INVALID``"
msgstr "``INTRINSIC_1_INVALID``"

#: ../../library/dis.rst:1745 ../../library/dis.rst:1799
msgid "Not valid"
msgstr ""

#: ../../library/dis.rst:1747
msgid "``INTRINSIC_PRINT``"
msgstr "``INTRINSIC_PRINT``"

#: ../../library/dis.rst:1747
msgid "Prints the argument to standard out. Used in the REPL."
msgstr ""

#: ../../library/dis.rst:1750
msgid "``INTRINSIC_IMPORT_STAR``"
msgstr "``INTRINSIC_IMPORT_STAR``"

#: ../../library/dis.rst:1750
msgid "Performs ``import *`` for the named module."
msgstr ""

#: ../../library/dis.rst:1753
msgid "``INTRINSIC_STOPITERATION_ERROR``"
msgstr "``INTRINSIC_STOPITERATION_ERROR``"

#: ../../library/dis.rst:1753
msgid "Extracts the return value from a ``StopIteration`` exception."
msgstr ""

#: ../../library/dis.rst:1756
msgid "``INTRINSIC_ASYNC_GEN_WRAP``"
msgstr "``INTRINSIC_ASYNC_GEN_WRAP``"

#: ../../library/dis.rst:1756
msgid "Wraps an async generator value"
msgstr ""

#: ../../library/dis.rst:1758
msgid "``INTRINSIC_UNARY_POSITIVE``"
msgstr "``INTRINSIC_UNARY_POSITIVE``"

#: ../../library/dis.rst:1758
msgid "Performs the unary ``+`` operation"
msgstr ""

#: ../../library/dis.rst:1761
msgid "``INTRINSIC_LIST_TO_TUPLE``"
msgstr "``INTRINSIC_LIST_TO_TUPLE``"

#: ../../library/dis.rst:1761
msgid "Converts a list to a tuple"
msgstr ""

#: ../../library/dis.rst:1763
msgid "``INTRINSIC_TYPEVAR``"
msgstr "``INTRINSIC_TYPEVAR``"

#: ../../library/dis.rst:1763
msgid "Creates a :class:`typing.TypeVar`"
msgstr "Cria um :class:`typing.TypeVar`"

#: ../../library/dis.rst:1765
msgid "``INTRINSIC_PARAMSPEC``"
msgstr "``INTRINSIC_PARAMSPEC``"

#: ../../library/dis.rst:1765
msgid "Creates a :class:`typing.ParamSpec`"
msgstr "Cria um :class:`typing.ParamSpec`"

#: ../../library/dis.rst:1768
msgid "``INTRINSIC_TYPEVARTUPLE``"
msgstr "``INTRINSIC_TYPEVARTUPLE``"

#: ../../library/dis.rst:1768
msgid "Creates a :class:`typing.TypeVarTuple`"
msgstr "Cria um :class:`typing.TypeVarTuple`"

#: ../../library/dis.rst:1771
msgid "``INTRINSIC_SUBSCRIPT_GENERIC``"
msgstr "``INTRINSIC_SUBSCRIPT_GENERIC``"

#: ../../library/dis.rst:1771
msgid "Returns :class:`typing.Generic` subscripted with the argument"
msgstr ""

#: ../../library/dis.rst:1774
msgid "``INTRINSIC_TYPEALIAS``"
msgstr "``INTRINSIC_TYPEALIAS``"

#: ../../library/dis.rst:1774
msgid ""
"Creates a :class:`typing.TypeAliasType`; used in the :keyword:`type` "
"statement. The argument is a tuple of the type alias's name, type "
"parameters, and value."
msgstr ""

#: ../../library/dis.rst:1786
msgid ""
"Calls an intrinsic function with two arguments. Used to implement "
"functionality that is not performance critical::"
msgstr ""

#: ../../library/dis.rst:1789
msgid ""
"arg2 = STACK.pop()\n"
"arg1 = STACK.pop()\n"
"result = intrinsic2(arg1, arg2)\n"
"STACK.append(result)"
msgstr ""

#: ../../library/dis.rst:1799
msgid "``INTRINSIC_2_INVALID``"
msgstr "``INTRINSIC_2_INVALID``"

#: ../../library/dis.rst:1801
msgid "``INTRINSIC_PREP_RERAISE_STAR``"
msgstr "``INTRINSIC_PREP_RERAISE_STAR``"

#: ../../library/dis.rst:1801
msgid "Calculates the :exc:`ExceptionGroup` to raise from a ``try-except*``."
msgstr ""

#: ../../library/dis.rst:1805
msgid "``INTRINSIC_TYPEVAR_WITH_BOUND``"
msgstr "``INTRINSIC_TYPEVAR_WITH_BOUND``"

#: ../../library/dis.rst:1805
msgid "Creates a :class:`typing.TypeVar` with a bound."
msgstr ""

#: ../../library/dis.rst:1808
msgid "``INTRINSIC_TYPEVAR_WITH_CONSTRAINTS``"
msgstr "``INTRINSIC_TYPEVAR_WITH_CONSTRAINTS``"

#: ../../library/dis.rst:1808
msgid "Creates a :class:`typing.TypeVar` with constraints."
msgstr ""

#: ../../library/dis.rst:1812
msgid "``INTRINSIC_SET_FUNCTION_TYPE_PARAMS``"
msgstr "``INTRINSIC_SET_FUNCTION_TYPE_PARAMS``"

#: ../../library/dis.rst:1812
msgid "Sets the ``__type_params__`` attribute of a function."
msgstr ""

#: ../../library/dis.rst:1819
msgid "**Pseudo-instructions**"
msgstr ""

#: ../../library/dis.rst:1821
msgid ""
"These opcodes do not appear in Python bytecode. They are used by the "
"compiler but are replaced by real opcodes or removed before bytecode is "
"generated."
msgstr ""

#: ../../library/dis.rst:1826
msgid ""
"Set up an exception handler for the following code block. If an exception "
"occurs, the value stack level is restored to its current state and control "
"is transferred to the exception handler at ``target``."
msgstr ""

#: ../../library/dis.rst:1833
msgid ""
"Like ``SETUP_FINALLY``, but in case of an exception also pushes the last "
"instruction (``lasti``) to the stack so that ``RERAISE`` can restore it. If "
"an exception occurs, the value stack level and the last instruction on the "
"frame are restored to their current state, and control is transferred to the "
"exception handler at ``target``."
msgstr ""

#: ../../library/dis.rst:1842
msgid ""
"Like ``SETUP_CLEANUP``, but in case of an exception one more item is popped "
"from the stack before control is transferred to the exception handler at "
"``target``."
msgstr ""

#: ../../library/dis.rst:1846
msgid ""
"This variant is used in :keyword:`with` and :keyword:`async with` "
"constructs, which push the return value of the context manager's :meth:"
"`~object.__enter__` or :meth:`~object.__aenter__` to the stack."
msgstr ""

#: ../../library/dis.rst:1853
msgid ""
"Marks the end of the code block associated with the last ``SETUP_FINALLY``, "
"``SETUP_CLEANUP`` or ``SETUP_WITH``."
msgstr ""

#: ../../library/dis.rst:1859
msgid ""
"Undirected relative jump instructions which are replaced by their directed "
"(forward/backward) counterparts by the assembler."
msgstr ""

#: ../../library/dis.rst:1864
msgid ""
"Pushes a reference to the cell contained in slot ``i`` of the \"fast "
"locals\" storage."
msgstr ""

#: ../../library/dis.rst:1867
msgid ""
"Note that ``LOAD_CLOSURE`` is replaced with ``LOAD_FAST`` in the assembler."
msgstr ""

#: ../../library/dis.rst:1869
msgid "This opcode is now a pseudo-instruction."
msgstr ""

#: ../../library/dis.rst:1875
msgid ""
"Optimized unbound method lookup. Emitted as a ``LOAD_ATTR`` opcode with a "
"flag set in the arg."
msgstr ""

#: ../../library/dis.rst:1882
msgid "Opcode collections"
msgstr ""

#: ../../library/dis.rst:1884
msgid ""
"These collections are provided for automatic introspection of bytecode "
"instructions:"
msgstr ""

#: ../../library/dis.rst:1887
msgid ""
"The collections now contain pseudo instructions and instrumented "
"instructions as well. These are opcodes with values ``>= MIN_PSEUDO_OPCODE`` "
"and ``>= MIN_INSTRUMENTED_OPCODE``."
msgstr ""

#: ../../library/dis.rst:1894
msgid "Sequence of operation names, indexable using the bytecode."
msgstr ""

#: ../../library/dis.rst:1899
msgid "Dictionary mapping operation names to bytecodes."
msgstr ""

#: ../../library/dis.rst:1904
msgid "Sequence of all compare operation names."
msgstr ""

#: ../../library/dis.rst:1909
msgid "Sequence of bytecodes that use their argument."
msgstr ""

#: ../../library/dis.rst:1916
msgid "Sequence of bytecodes that access a constant."
msgstr ""

#: ../../library/dis.rst:1921
msgid ""
"Sequence of bytecodes that access a :term:`free (closure) variable <closure "
"variable>`. 'free' in this context refers to names in the current scope that "
"are referenced by inner scopes or names in outer scopes that are referenced "
"from this scope.  It does *not* include references to global or builtin "
"scopes."
msgstr ""

#: ../../library/dis.rst:1929
msgid "Sequence of bytecodes that access an attribute by name."
msgstr ""

#: ../../library/dis.rst:1934
msgid "Sequence of bytecodes that have a jump target. All jumps are relative."
msgstr ""

#: ../../library/dis.rst:1941
msgid "Sequence of bytecodes that access a local variable."
msgstr ""

#: ../../library/dis.rst:1946
msgid "Sequence of bytecodes of Boolean operations."
msgstr ""

#: ../../library/dis.rst:1950
msgid "Sequence of bytecodes that set an exception handler."
msgstr ""

#: ../../library/dis.rst:1957
msgid "Sequence of bytecodes that have a relative jump target."
msgstr ""

#: ../../library/dis.rst:1959
msgid "All jumps are now relative. Use :data:`hasjump`."
msgstr ""

#: ../../library/dis.rst:1965
msgid "Sequence of bytecodes that have an absolute jump target."
msgstr ""

#: ../../library/dis.rst:1967
msgid "All jumps are now relative. This list is empty."
msgstr ""

#: ../../library/dis.rst:1583
msgid "built-in function"
msgstr "função embutida"

#: ../../library/dis.rst:1583
msgid "slice"
msgstr "fatia"

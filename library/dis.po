# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-11 14:48+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/dis.rst:2
msgid ":mod:`!dis` --- Disassembler for Python bytecode"
msgstr ":mod:`!dis` --- Disassembler de bytecode do Python"

#: ../../library/dis.rst:7
msgid "**Source code:** :source:`Lib/dis.py`"
msgstr "**Código-fonte:** :source:`Lib/dis.py`"

#: ../../library/dis.rst:17
msgid ""
"The :mod:`dis` module supports the analysis of CPython :term:`bytecode` by "
"disassembling it. The CPython bytecode which this module takes as an input "
"is defined in the file :file:`Include/opcode.h` and used by the compiler and "
"the interpreter."
msgstr ""
"O módulo :mod:`dis` oferece suporte à análise de :term:`bytecode` do "
"CPython, desmontando-o. O bytecode do CPython que o módulo leva como entrada "
"é definido no arquivo :file:`Include/opcode.h` e usado pelo compilador e "
"pelo interpretador."

#: ../../library/dis.rst:24
msgid ""
"Bytecode is an implementation detail of the CPython interpreter.  No "
"guarantees are made that bytecode will not be added, removed, or changed "
"between versions of Python.  Use of this module should not be considered to "
"work across Python VMs or Python releases."
msgstr ""
"O bytecode é um detalhe de implementação do interpretador CPython. Não há "
"garantias de que bytecodes não serão adicionados, removidos ou alterados "
"entre as versões do Python. O uso deste módulo não deve ser considerado que "
"funcionará em todas as VMs do Python ou mesmo versões do Python."

#: ../../library/dis.rst:29
msgid ""
"Use 2 bytes for each instruction. Previously the number of bytes varied by "
"instruction."
msgstr ""
"Cada instrução ocupa 2 bytes. Anteriormente, o número de bytes variava de "
"acordo com a instrução."

#: ../../library/dis.rst:33
msgid ""
"The argument of jump, exception handling and loop instructions is now the "
"instruction offset rather than the byte offset."
msgstr ""
"O argumento para instruções de pulo, tratamento de exceção e laço é agora o "
"deslocamento em instruções, ao invés de em bytes."

#: ../../library/dis.rst:37
msgid ""
"Some instructions are accompanied by one or more inline cache entries, which "
"take the form of :opcode:`CACHE` instructions. These instructions are hidden "
"by default, but can be shown by passing ``show_caches=True`` to any :mod:"
"`dis` utility. Furthermore, the interpreter now adapts the bytecode to "
"specialize it for different runtime conditions. The adaptive bytecode can be "
"shown by passing ``adaptive=True``."
msgstr ""
"Algumas instruções vêm acompanhadas de uma ou mais entradas de cache em "
"linha, as quais assumem a forma de instruções :opcode:`CACHE`. Tais "
"instruções são escondidas por padrão, mas podem ser visualizadas passando "
"``show_caches=True`` para qualquer utilidade do :mod:`dis`. Além disso, o "
"interpretador agora adapta o bytecode para especializá-lo a diferentes "
"condições de tempo de execução. O bytecode adaptativo pode ser visualizado "
"passando ``adaptive=True``."

#: ../../library/dis.rst:45
msgid ""
"The argument of a jump is the offset of the target instruction relative to "
"the instruction that appears immediately after the jump instruction's :"
"opcode:`CACHE` entries."
msgstr ""
"O argumento de um pulo é o deslocamento da instrução alvo relativo à "
"instrução que aparece imediatamente após as entradas :opcode:`CACHE` da "
"instrução de pulo."

#: ../../library/dis.rst:50
msgid ""
"As a consequence, the presence of the :opcode:`CACHE` instructions is "
"transparent for forward jumps but needs to be taken into account when "
"reasoning about backward jumps."
msgstr ""
"Como consequência, a presença de instruções :opcode:`CACHE` é transparente "
"para pulos adiante, mas precisa ser considerada ao lidar com pulos para trás."

#: ../../library/dis.rst:54
msgid "Example: Given the function :func:`!myfunc`::"
msgstr "Exemplo: Dada a função :func:`!myfunc`::"

#: ../../library/dis.rst:56
msgid ""
"def myfunc(alist):\n"
"    return len(alist)"
msgstr ""

#: ../../library/dis.rst:59
msgid ""
"the following command can be used to display the disassembly of :func:`!"
"myfunc`:"
msgstr ""
"o comando a seguir pode ser usado para mostrar a desconstrução de :func:`!"
"myfunc`:"

#: ../../library/dis.rst:62
msgid ""
">>> dis.dis(myfunc)\n"
"  2           0 RESUME                   0\n"
"\n"
"  3           2 LOAD_GLOBAL              1 (NULL + len)\n"
"             12 LOAD_FAST                0 (alist)\n"
"             14 CALL                     1\n"
"             22 RETURN_VALUE"
msgstr ""

#: ../../library/dis.rst:72
msgid "(The \"2\" is a line number)."
msgstr "(O \"2\" é o número da linha)."

#: ../../library/dis.rst:77
msgid "Command-line interface"
msgstr "Interface de linha de comando"

#: ../../library/dis.rst:79
msgid "The :mod:`dis` module can be invoked as a script from the command line:"
msgstr ""
"O módulo :mod:`dis` pode ser invocado como um script na linha de comando:"

#: ../../library/dis.rst:81
msgid "python -m dis [-h] [infile]"
msgstr ""

#: ../../library/dis.rst:85
msgid "The following options are accepted:"
msgstr "As seguintes opções são aceitas:"

#: ../../library/dis.rst:91
msgid "Display usage and exit."
msgstr "Exibe o modo de uso e sai."

#: ../../library/dis.rst:93
msgid ""
"If :file:`infile` is specified, its disassembled code will be written to "
"stdout. Otherwise, disassembly is performed on compiled source code recieved "
"from stdin."
msgstr ""

#: ../../library/dis.rst:97
msgid "Bytecode analysis"
msgstr "Análise de bytecode"

#: ../../library/dis.rst:101
msgid ""
"The bytecode analysis API allows pieces of Python code to be wrapped in a :"
"class:`Bytecode` object that provides easy access to details of the compiled "
"code."
msgstr ""
"A API de análise de bytecode permite que partes do código Python sejam "
"encapsuladas em um objeto :class:`Bytecode` que facilite o acesso aos "
"detalhes do código compilado."

#: ../../library/dis.rst:108
msgid ""
"Analyse the bytecode corresponding to a function, generator, asynchronous "
"generator, coroutine, method, string of source code, or a code object (as "
"returned by :func:`compile`)."
msgstr ""
"Analisa o bytecode correspondente a uma função, um gerador, um gerador "
"assíncrono, uma corrotina, um método, uma string de código-fonte, ou um "
"objeto de código (conforme retornado por :func:`compile`)."

#: ../../library/dis.rst:112
msgid ""
"This is a convenience wrapper around many of the functions listed below, "
"most notably :func:`get_instructions`, as iterating over a :class:`Bytecode` "
"instance yields the bytecode operations as :class:`Instruction` instances."
msgstr ""
"Esta é um invólucro de conveniência que encapsula muitas das funções "
"listadas abaixo, principalmente a :func:`get_instructions`, já que iterar "
"sobre sobre uma instância de :class:`Bytecode` produz operações bytecode "
"como instâncias de :class:`Instruction`."

#: ../../library/dis.rst:116 ../../library/dis.rst:304
msgid ""
"If *first_line* is not ``None``, it indicates the line number that should be "
"reported for the first source line in the disassembled code.  Otherwise, the "
"source line information (if any) is taken directly from the disassembled "
"code object."
msgstr ""
"Se *first_line* não for ``None``, ele indica o número de linha que deve ser "
"reportado para a primeira linha de código-fonte no código desmontado.  Caso "
"contrário, a informação de linha de código-fonte (se houver) é extraída "
"diretamente da desconstrução do objeto de código."

#: ../../library/dis.rst:121
msgid ""
"If *current_offset* is not ``None``, it refers to an instruction offset in "
"the disassembled code. Setting this means :meth:`.dis` will display a "
"\"current instruction\" marker against the specified opcode."
msgstr ""
"Se *current_offset* não for ``None``, ele é um deslocamento em instruções no "
"código desconstruído. Definir este argumento significa que o :meth:`.dis` "
"vai mostrar um marcador de \"instrução atual\" sobre o opcode especificado."

#: ../../library/dis.rst:125
msgid ""
"If *show_caches* is ``True``, :meth:`.dis` will display inline cache entries "
"used by the interpreter to specialize the bytecode."
msgstr ""
"Se *show_caches* for ``True``, o :meth:`.dis` vai exibir entradas de cache "
"em linha usadas pelo interpretador para especializar o bytecode."

#: ../../library/dis.rst:128
msgid ""
"If *adaptive* is ``True``, :meth:`.dis` will display specialized bytecode "
"that may be different from the original bytecode."
msgstr ""
"Se *adaptive* for ``True``, o :meth:`.dis` vai exibir bytecode especializado "
"que pode ser diferente do bytecode original."

#: ../../library/dis.rst:133
msgid ""
"Construct a :class:`Bytecode` instance from the given traceback, setting "
"*current_offset* to the instruction responsible for the exception."
msgstr ""
"Constrói uma instância de :class:`Bytecode` a partir do traceback fornecido, "
"definindo *current_offset* apontando para a instrução responsável pela "
"exceção."

#: ../../library/dis.rst:138
msgid "The compiled code object."
msgstr "O objeto de código compilado."

#: ../../library/dis.rst:142
msgid "The first source line of the code object (if available)"
msgstr ""
"A primeira linha de código-fonte do objeto de código (caso disponível)."

#: ../../library/dis.rst:146
msgid ""
"Return a formatted view of the bytecode operations (the same as printed by :"
"func:`dis.dis`, but returned as a multi-line string)."
msgstr ""
"Retorna uma visualização formatada das operações em bytecode (as mesmas que "
"seriam impressas pela :func:`dis.dis`, mas retornadas como uma string "
"multilinha)."

#: ../../library/dis.rst:151
msgid ""
"Return a formatted multi-line string with detailed information about the "
"code object, like :func:`code_info`."
msgstr ""
"Retorna uma string multilinha formatada com informação detalhada sobre o "
"objeto de código, como :func:`code_info`."

#: ../../library/dis.rst:154 ../../library/dis.rst:194
#: ../../library/dis.rst:246
msgid "This can now handle coroutine and asynchronous generator objects."
msgstr ""
"Este método agora lida com objetos de corrotina e de gerador assíncrono."

#: ../../library/dis.rst:157 ../../library/dis.rst:249
#: ../../library/dis.rst:265 ../../library/dis.rst:292
#: ../../library/dis.rst:313
msgid "Added the *show_caches* and *adaptive* parameters."
msgstr "Adicionados os parâmetros *show_caches* e *adaptive*."

#: ../../library/dis.rst:160
msgid "Example:"
msgstr "Exemplo:"

#: ../../library/dis.rst:162
msgid ""
">>> bytecode = dis.Bytecode(myfunc)\n"
">>> for instr in bytecode:\n"
"...     print(instr.opname)\n"
"...\n"
"RESUME\n"
"LOAD_GLOBAL\n"
"LOAD_FAST\n"
"CALL\n"
"RETURN_VALUE"
msgstr ""

#: ../../library/dis.rst:176
msgid "Analysis functions"
msgstr "Funções de análise"

#: ../../library/dis.rst:178
msgid ""
"The :mod:`dis` module also defines the following analysis functions that "
"convert the input directly to the desired output. They can be useful if only "
"a single operation is being performed, so the intermediate analysis object "
"isn't useful:"
msgstr ""
"O módulo :mod:`dis` também define as seguintes funções que convertem a "
"entrada diretamente para a saída desejada. Elas podem ser úteis se somente "
"uma única operação está sendo feita, de forma que o objeto de análise "
"intermediário não é útil:"

#: ../../library/dis.rst:184
msgid ""
"Return a formatted multi-line string with detailed code object information "
"for the supplied function, generator, asynchronous generator, coroutine, "
"method, source code string or code object."
msgstr ""
"Retorna uma string multilinha formatada com informação detalhada sobre o "
"objeto de código correspondente à função, gerador, gerador assíncrono, "
"corrotina, método, string de código-fonte ou objeto de código fornecido."

#: ../../library/dis.rst:188
msgid ""
"Note that the exact contents of code info strings are highly implementation "
"dependent and they may change arbitrarily across Python VMs or Python "
"releases."
msgstr ""
"Observe que o conteúdo exato de strings de informação de código são "
"altamente dependentes da implementação e podem mudar de forma arbitrária "
"através de VMs Python ou lançamentos do Python."

#: ../../library/dis.rst:200
msgid ""
"Print detailed code object information for the supplied function, method, "
"source code string or code object to *file* (or ``sys.stdout`` if *file* is "
"not specified)."
msgstr ""
"Imprime no arquivo *file* (ou ``sys.stdout`` caso *file* não seja "
"especificado) informações detalhadas sobre o objeto de código correspondente "
"à função, método, string de código-fonte fornecido."

#: ../../library/dis.rst:204
msgid ""
"This is a convenient shorthand for ``print(code_info(x), file=file)``, "
"intended for interactive exploration at the interpreter prompt."
msgstr ""
"Este é um atalho conveniente para ``print(code_info(x), file=file)``, "
"destinado à exploração interativa no prompt do interpretador."

#: ../../library/dis.rst:209 ../../library/dis.rst:240
#: ../../library/dis.rst:262 ../../library/dis.rst:289
msgid "Added *file* parameter."
msgstr "Adicionado o parâmetro *file*."

#: ../../library/dis.rst:215
msgid ""
"Disassemble the *x* object.  *x* can denote either a module, a class, a "
"method, a function, a generator, an asynchronous generator, a coroutine, a "
"code object, a string of source code or a byte sequence of raw bytecode. For "
"a module, it disassembles all functions. For a class, it disassembles all "
"methods (including class and static methods). For a code object or sequence "
"of raw bytecode, it prints one line per bytecode instruction. It also "
"recursively disassembles nested code objects. These can include generator "
"expressions, nested functions, the bodies of nested classes, and the code "
"objects used for :ref:`annotation scopes <annotation-scopes>`. Strings are "
"first compiled to code objects with the :func:`compile` built-in function "
"before being disassembled.  If no object is provided, this function "
"disassembles the last traceback."
msgstr ""
"Desmonta o objeto *x*.  *x* pode denotar um módulo, uma classe, um método, "
"uma função, um gerador, um gerador assíncrono, uma corrotina, um objeto de "
"código, uma string de código-fonte ou uma sequência de bytes contendo "
"bytecode bruto. Para um módulo, são desmontadas todas as funções. Para uma "
"classe, são desmontados todos os métodos (incluindo métodos de classe e "
"estáticos). Para um objeto de código ou sequência de bytecodes brutos, é "
"impressa uma linha para cada instrução de bytecode. Além disso, objetos de "
"código aninhados são desmontados recursivamente. Estes podem incluir "
"expressões geradoras, funções aninhadas, corpos de classes aninhadas, e "
"objetos de código usados para :ref:`escopos de anotação <annotation-"
"scopes>`. Strings são compiladas para objetos de código com a função "
"embutida :func:`compile` antes de serem desmontadas.  Se nenhum objeto for "
"fornecido, o último traceback é desmontado."

#: ../../library/dis.rst:228 ../../library/dis.rst:259
#: ../../library/dis.rst:286
msgid ""
"The disassembly is written as text to the supplied *file* argument if "
"provided and to ``sys.stdout`` otherwise."
msgstr ""
"O resultado é escrito como texto no arquivo *file* caso tenha sido fornecido "
"como argumento, ou para ``sys.stdout`` caso contrário."

#: ../../library/dis.rst:231
msgid ""
"The maximal depth of recursion is limited by *depth* unless it is ``None``. "
"``depth=0`` means no recursion."
msgstr ""
"A profundidade máxima de recursão é limitada por *depth* a menos que seja "
"``None``. ``depth=0`` significa não fazer recursão."

#: ../../library/dis.rst:234
msgid ""
"If *show_caches* is ``True``, this function will display inline cache "
"entries used by the interpreter to specialize the bytecode."
msgstr ""
"Se *show_caches* for ``True``, essa função vai exibir entradas de cache em "
"linha usadas pelo interpretador para especializar o bytecode."

#: ../../library/dis.rst:237
msgid ""
"If *adaptive* is ``True``, this function will display specialized bytecode "
"that may be different from the original bytecode."
msgstr ""
"Se *adaptive* for ``True``, essa função vai exibir bytecode especializado "
"que pode ser diferente do bytecode original."

#: ../../library/dis.rst:243
msgid "Implemented recursive disassembling and added *depth* parameter."
msgstr ""
"Foi implementada a desmontagem recursiva, e adicionado o parâmetro *depth*."

#: ../../library/dis.rst:255
msgid ""
"Disassemble the top-of-stack function of a traceback, using the last "
"traceback if none was passed.  The instruction causing the exception is "
"indicated."
msgstr ""
"Desmonta a função no topo da pilha de um traceback, usando o último "
"traceback caso nenhum tenha sido passado.  A instrução que causou a exceção "
"é indicada."

#: ../../library/dis.rst:272
msgid ""
"Disassemble a code object, indicating the last instruction if *lasti* was "
"provided.  The output is divided in the following columns:"
msgstr ""
"Desmonta um objeto de código, indicando a última instrução se *lasti* tiver "
"sido fornecido.  A saída é dividida em colunas da seguinte forma:"

#: ../../library/dis.rst:275
msgid "the line number, for the first instruction of each line"
msgstr "o número da linha, para a primeira instrução de cada linha"

#: ../../library/dis.rst:276
msgid "the current instruction, indicated as ``-->``,"
msgstr "a instrução atual, indicada por ``-->``,"

#: ../../library/dis.rst:277
msgid "a labelled instruction, indicated with ``>>``,"
msgstr "um rótulo da instrução, indicado com ``>>``,"

#: ../../library/dis.rst:278
msgid "the address of the instruction,"
msgstr "o endereço da instrução"

#: ../../library/dis.rst:279
msgid "the operation code name,"
msgstr "o nome do código da operação,"

#: ../../library/dis.rst:280
msgid "operation parameters, and"
msgstr "os parâmetros da operação, e"

#: ../../library/dis.rst:281
msgid "interpretation of the parameters in parentheses."
msgstr "a interpretação dos parâmetros, em parênteses."

#: ../../library/dis.rst:283
msgid ""
"The parameter interpretation recognizes local and global variable names, "
"constant values, branch targets, and compare operators."
msgstr ""
"A interpretação dos parâmetros reconhece nomes de variáveis locais e "
"globais, valores de constantes, alvos de ramificações, e operadores de "
"comparação."

#: ../../library/dis.rst:298
msgid ""
"Return an iterator over the instructions in the supplied function, method, "
"source code string or code object."
msgstr ""
"Retorna um iterador sobre as instruções na função, método, string de código-"
"fonte ou objeto de código fornecido."

#: ../../library/dis.rst:301
msgid ""
"The iterator generates a series of :class:`Instruction` named tuples giving "
"the details of each operation in the supplied code."
msgstr ""
"O iterador gera uma série de tuplas nomeadas :class:`Instruction` contendo "
"detalhes de cada operação no código fornecido."

#: ../../library/dis.rst:309
msgid ""
"The *show_caches* and *adaptive* parameters work as they do in :func:`dis`."
msgstr ""

#: ../../library/dis.rst:319
msgid ""
"This generator function uses the :meth:`~codeobject.co_lines` method of the :"
"ref:`code object <code-objects>` *code* to find the offsets which are starts "
"of lines in the source code.  They are generated as ``(offset, lineno)`` "
"pairs."
msgstr ""
"Essa função geradora usa o método :meth:`~codeobject.co_lines` do :ref:"
"`objeto de código <code-objects>` *code* para encontrar as posições que "
"correspondem aos inícios de cada linha do código-fonte.  Elas são geradas em "
"pares ``(offset, lineno)``."

#: ../../library/dis.rst:324
msgid "Line numbers can be decreasing. Before, they were always increasing."
msgstr ""
"Números de linhas podem ser decrescentes. Antes, eles eram sempre crescentes."

#: ../../library/dis.rst:327
msgid ""
"The :pep:`626` :meth:`~codeobject.co_lines` method is used instead of the :"
"attr:`~codeobject.co_firstlineno` and :attr:`~codeobject.co_lnotab` "
"attributes of the :ref:`code object <code-objects>`."
msgstr ""
"O método :meth:`~codeobject.co_lines` da :pep:`626` é usado ao invés dos "
"atributos :attr:`~codeobject.co_firstlineno` e :attr:`~codeobject.co_lnotab` "
"do :ref:`objeto de código <code-objects>`."

#: ../../library/dis.rst:335
msgid ""
"Detect all offsets in the raw compiled bytecode string *code* which are jump "
"targets, and return a list of these offsets."
msgstr ""
"Detecta todas as posições na string de bytecode compilado bruto *code* que "
"são alvos de pulos, e as retorna em uma lista."

#: ../../library/dis.rst:341
msgid "Compute the stack effect of *opcode* with argument *oparg*."
msgstr "Calcula o efeito que o *opcode* com argumento *oparg* tem na pilha."

#: ../../library/dis.rst:343
msgid ""
"If the code has a jump target and *jump* is ``True``, :func:`~stack_effect` "
"will return the stack effect of jumping.  If *jump* is ``False``, it will "
"return the stack effect of not jumping. And if *jump* is ``None`` (default), "
"it will return the maximal stack effect of both cases."
msgstr ""
"Se a operação tiver um alvo de pulo e *jump* for ``True``, :func:"
"`~stack_effect` vai retornar o efeito na pilha de realizar o pulo.  Se "
"*jump* for ``False``, ela vai retornar o efeito na pilha de não pular. E se "
"*jump* for ``None`` (o padrão), vai retornar o efeito máximo na pilha dentre "
"os dois casos."

#: ../../library/dis.rst:350
msgid "Added *jump* parameter."
msgstr "Adicionado o parâmetro *jump*."

#: ../../library/dis.rst:357
msgid "Python Bytecode Instructions"
msgstr "Instruções em bytecode do Python"

#: ../../library/dis.rst:359
msgid ""
"The :func:`get_instructions` function and :class:`Bytecode` class provide "
"details of bytecode instructions as :class:`Instruction` instances:"
msgstr ""
"A função :func:`get_instructions` e a classe :class:`Bytecode` fornecem "
"detalhes de instruções de bytecode como instâncias de :class:`Instruction`:"

#: ../../library/dis.rst:364
msgid "Details for a bytecode operation"
msgstr "Detalhes de uma operação em bytecode"

#: ../../library/dis.rst:368
msgid ""
"numeric code for operation, corresponding to the opcode values listed below "
"and the bytecode values in the :ref:`opcode_collections`."
msgstr ""
"código numérico da operação, correspondendo aos valores dos opcodes listados "
"abaixo e aos valores dos bytecodes nas :ref:`opcode_collections`."

#: ../../library/dis.rst:374
msgid "human readable name for operation"
msgstr "nome legível por humanos para a operação"

#: ../../library/dis.rst:379
msgid "numeric argument to operation (if any), otherwise ``None``"
msgstr ""
"argumento numérico para a operação (se houver), caso contrário ``None``"

#: ../../library/dis.rst:384
msgid "resolved arg value (if any), otherwise ``None``"
msgstr "valor resolvido do argumento (se houver), caso contrário ``None``"

#: ../../library/dis.rst:389
msgid ""
"human readable description of operation argument (if any), otherwise an "
"empty string."
msgstr ""
"descrição legível por humanos do argumento da operação (se houver), caso "
"contrário uma string vazia."

#: ../../library/dis.rst:395
msgid "start index of operation within bytecode sequence"
msgstr "índice de início da operação dentro da sequência de bytecodes"

#: ../../library/dis.rst:400
msgid "line started by this opcode (if any), otherwise ``None``"
msgstr ""

#: ../../library/dis.rst:405
msgid "``True`` if other code jumps to here, otherwise ``False``"
msgstr "``True`` se algum outro código pula para cá, senão ``False``"

#: ../../library/dis.rst:410
msgid ""
":class:`dis.Positions` object holding the start and end locations that are "
"covered by this instruction."
msgstr ""
"objeto :class:`dis.Positions` contendo os pontos de início e fim cobertos "
"por esta instrução."

#: ../../library/dis.rst:417
msgid "Field ``positions`` is added."
msgstr "Adicionado o campo ``positions``."

#: ../../library/dis.rst:422
msgid ""
"In case the information is not available, some fields might be ``None``."
msgstr ""
"Caso a informação não esteja disponível, alguns campos podem ser ``None``."

#: ../../library/dis.rst:432
msgid ""
"The Python compiler currently generates the following bytecode instructions."
msgstr ""
"O compilador de Python atualmente gera as seguintes instruções de bytecode."

#: ../../library/dis.rst:435
msgid "**General instructions**"
msgstr "**Instruções gerais**"

#: ../../library/dis.rst:437
msgid ""
"In the following, We will refer to the interpreter stack as ``STACK`` and "
"describe operations on it as if it was a Python list. The top of the stack "
"corresponds to ``STACK[-1]`` in this language."
msgstr ""
"A seguir, vamos usar ``STACK`` para nos referirmos à pilha do interpretador, "
"e vamos descrever operações nela como se ela fosse uma lista do Python. "
"Nessa linguagem, ``STACK[-1]`` é o topo da pilha."

#: ../../library/dis.rst:443
msgid ""
"Do nothing code.  Used as a placeholder by the bytecode optimizer, and to "
"generate line tracing events."
msgstr ""
"Código para não fazer nada.  Usado como espaço reservado pelo otimizador de "
"bytecode, e para gerar eventos de rastreamento de linha."

#: ../../library/dis.rst:449
msgid "Removes the top-of-stack item::"
msgstr "Remove o item no topo da pilha::"

#: ../../library/dis.rst:451
msgid "STACK.pop()"
msgstr ""

#: ../../library/dis.rst:456
msgid ""
"Removes the top two values from the stack. Equivalent to ``POP_TOP``; "
"``POP_TOP``. Used to clean up at the end of loops, hence the name."
msgstr ""

#: ../../library/dis.rst:465
msgid "Implements ``del STACK[-2]``. Used to clean up when a generator exits."
msgstr ""
"Implementa ``del STACK[-2]``. Usado como limpeza quando um gerador termina."

#: ../../library/dis.rst:473
msgid ""
"Push the i-th item to the top of the stack without removing it from its "
"original location::"
msgstr ""
"Coloca o i-ésimo item no topo da pilha sem removê-lo da sua posição "
"original::"

#: ../../library/dis.rst:476
msgid ""
"assert i > 0\n"
"STACK.append(STACK[-i])"
msgstr ""

#: ../../library/dis.rst:484
msgid "Swap the top of the stack with the i-th element::"
msgstr "Troca o topo da pilha de lugar com o i-ésimo elemento."

#: ../../library/dis.rst:486
msgid "STACK[-i], STACK[-1] = STACK[-1], STACK[-i]"
msgstr ""

#: ../../library/dis.rst:493
msgid ""
"Rather than being an actual instruction, this opcode is used to mark extra "
"space for the interpreter to cache useful data directly in the bytecode "
"itself. It is automatically hidden by all ``dis`` utilities, but can be "
"viewed with ``show_caches=True``."
msgstr ""
"Ao invés de ser uma instrução de fato, este opcode é usado para demarcar "
"espaço extra para o interpretador armazernar dados úteis diretamente no "
"próprio bytecode. É escondido automaticamente por todas as utilidades do "
"``dis``, mas pode ser visualizado com ``show_caches=True``."

#: ../../library/dis.rst:498
msgid ""
"Logically, this space is part of the preceding instruction. Many opcodes "
"expect to be followed by an exact number of caches, and will instruct the "
"interpreter to skip over them at runtime."
msgstr ""
"Do ponto de vista lógico, este espaço faz parte da instrução anterior. "
"Muitos opcodes esperam ser seguidos por um número exato de caches, e "
"instruem o interpretador a pulá-los em tempo de execução."

#: ../../library/dis.rst:502
msgid ""
"Populated caches can look like arbitrary instructions, so great care should "
"be taken when reading or modifying raw, adaptive bytecode containing "
"quickened data."
msgstr ""
"Caches populados podem se parecer com qualquer instrução, de forma que ler "
"ou modificar bytecode adaptativo bruto contendo dados \"quickened\" requer "
"muito cuidado."

#: ../../library/dis.rst:509
msgid "**Unary operations**"
msgstr "**Operações unárias**"

#: ../../library/dis.rst:511
msgid ""
"Unary operations take the top of the stack, apply the operation, and push "
"the result back on the stack."
msgstr ""
"Operações unárias tiram o topo da pilha, aplicam a operação, e põem o "
"resultado de volta na pilha."

#: ../../library/dis.rst:517
msgid "Implements ``STACK[-1] = -STACK[-1]``."
msgstr "Implementa ``STACK[-1] = -STACK[-1]``."

#: ../../library/dis.rst:522
msgid "Implements ``STACK[-1] = not STACK[-1]``."
msgstr "Implementa ``STACK[-1] = not STACK[-1]``."

#: ../../library/dis.rst:527
msgid "Implements ``STACK[-1] = ~STACK[-1]``."
msgstr "Implementa ``STACK[-1] = ~STACK[-1]``."

#: ../../library/dis.rst:532
msgid "Implements ``STACK[-1] = iter(STACK[-1])``."
msgstr "Implementa ``STACK[-1] = iter(STACK[-1])``."

#: ../../library/dis.rst:537
msgid ""
"If ``STACK[-1]`` is a :term:`generator iterator` or :term:`coroutine` object "
"it is left as is.  Otherwise, implements ``STACK[-1] = iter(STACK[-1])``."
msgstr ""
"Se ``STACK[-1]`` for um :term:`iterador gerador` ou um objeto :term:"
"`corrotina`, nada acontece.  Caso contrário, implementa ``STACK[-1] = "
"iter(STACK[-1])``."

#: ../../library/dis.rst:543
msgid "**Binary and in-place operations**"
msgstr "**Operações binárias e internas**"

#: ../../library/dis.rst:545
msgid ""
"Binary operations remove the top two items from the stack (``STACK[-1]`` and "
"``STACK[-2]``). They perform the operation, then put the result back on the "
"stack."
msgstr ""
"Operações binárias removem os dois itens no topo da pilha (``STACK[-1]`` e "
"``STACK[-2]``). A operação é realizada, e o resultado é colocado de volta na "
"pilha."

#: ../../library/dis.rst:548
msgid ""
"In-place operations are like binary operations, but the operation is done in-"
"place when ``STACK[-2]`` supports it, and the resulting ``STACK[-1]`` may be "
"(but does not have to be) the original ``STACK[-2]``."
msgstr ""
"As operações internas são como as operações binárias, só que a operação é "
"feita internamente caso suportado por ``STACK[-2]``, e o ``STACK[-1]`` "
"resultante pode ser (mas não necessariamente é) o ``STACK[-2]`` original."

#: ../../library/dis.rst:555
msgid ""
"Implements the binary and in-place operators (depending on the value of "
"*op*)::"
msgstr ""
"Implementa os operadores binários e locais (depende do valor de *op*)::"

#: ../../library/dis.rst:558
msgid ""
"rhs = STACK.pop()\n"
"lhs = STACK.pop()\n"
"STACK.append(lhs op rhs)"
msgstr ""

#: ../../library/dis.rst:567 ../../library/dis.rst:576
#: ../../library/dis.rst:586 ../../library/dis.rst:594
#: ../../library/dis.rst:606 ../../library/dis.rst:694
#: ../../library/dis.rst:704 ../../library/dis.rst:714
#: ../../library/dis.rst:935 ../../library/dis.rst:946
#: ../../library/dis.rst:1050 ../../library/dis.rst:1062
#: ../../library/dis.rst:1074
msgid "Implements::"
msgstr "Implementa::"

#: ../../library/dis.rst:569
msgid ""
"key = STACK.pop()\n"
"container = STACK.pop()\n"
"STACK.append(container[key])"
msgstr ""

#: ../../library/dis.rst:578
msgid ""
"key = STACK.pop()\n"
"container = STACK.pop()\n"
"value = STACK.pop()\n"
"container[key] = value"
msgstr ""

#: ../../library/dis.rst:588
msgid ""
"key = STACK.pop()\n"
"container = STACK.pop()\n"
"del container[key]"
msgstr ""

#: ../../library/dis.rst:596
msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"container = STACK.pop()\n"
"STACK.append(container[start:end])"
msgstr ""

#: ../../library/dis.rst:608
msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"container = STACK.pop()\n"
"values = STACK.pop()\n"
"container[start:end] = value"
msgstr ""

#: ../../library/dis.rst:617
msgid "**Coroutine opcodes**"
msgstr "**Opcodes para corrotinas**"

#: ../../library/dis.rst:621
msgid ""
"Implements ``STACK[-1] = get_awaitable(STACK[-1])``, where "
"``get_awaitable(o)`` returns ``o`` if ``o`` is a coroutine object or a "
"generator object with the :data:`~inspect.CO_ITERABLE_COROUTINE` flag, or "
"resolves ``o.__await__``."
msgstr ""
"Implementa ``STACK[-1] = get_awaitable(STACK[-1])``, onde "
"``get_awaitable(o)`` retorna ``o`` se ``o`` for um objeto de corrotina ou um "
"gerador com o sinalizador :data:`~inspect.CO_ITERABLE_COROUTINE`, ou então "
"resolve ``o.__await__``."

#: ../../library/dis.rst:626
msgid ""
"If the ``where`` operand is nonzero, it indicates where the instruction "
"occurs:"
msgstr ""
"Se o operando ``where`` não for zero, ele indica onde a instrução ocorre:"

#: ../../library/dis.rst:629
msgid "``1``: After a call to ``__aenter__``"
msgstr "``1``: Após uma chamada a ``__aenter__``"

#: ../../library/dis.rst:630
msgid "``2``: After a call to ``__aexit__``"
msgstr "``2``: Após uma chamada a ``__aexit__``"

#: ../../library/dis.rst:634
msgid "Previously, this instruction did not have an oparg."
msgstr "Anteriormente, esta instrução não tinha um oparg."

#: ../../library/dis.rst:640
msgid "Implements ``STACK[-1] = STACK[-1].__aiter__()``."
msgstr "Implementa ``STACK[-1] = STACK[-1].__aiter__()``."

#: ../../library/dis.rst:643
msgid "Returning awaitable objects from ``__aiter__`` is no longer supported."
msgstr "Não é mais aceitado que o ``__aiter__`` retorne objetos aguardáveis."

#: ../../library/dis.rst:650
msgid ""
"Implement ``STACK.append(get_awaitable(STACK[-1].__anext__()))`` to the "
"stack. See ``GET_AWAITABLE`` for details about ``get_awaitable``."
msgstr ""
"Implementa ``STACK.append(get_awaitable(STACK[-1].__anext__()))``. Veja "
"``GET_AWAITABLE`` para o significado de ``get_awaitable``."

#: ../../library/dis.rst:658
msgid ""
"Terminates an :keyword:`async for` loop.  Handles an exception raised when "
"awaiting a next item. The stack contains the async iterable in ``STACK[-2]`` "
"and the raised exception in ``STACK[-1]``. Both are popped. If the exception "
"is not :exc:`StopAsyncIteration`, it is re-raised."
msgstr ""
"Termina um laço :keyword:`async for`.  Trata exceções levantadas ao aguardar "
"um item seguinte. A pilha contém o iterável async em ``STACK[-2]`` e a "
"exceção levantada em ``STACK[-1]``. Ambos são retirados. Se a exceção não "
"for :exc:`StopAsyncIteration`, ela é re-levantada."

#: ../../library/dis.rst:665 ../../library/dis.rst:770
#: ../../library/dis.rst:781
msgid ""
"Exception representation on the stack now consist of one, not three, items."
msgstr ""
"A representação da exceção na pilha consiste agora de um item, ao invés de "
"três."

#: ../../library/dis.rst:671
msgid ""
"Handles an exception raised during a :meth:`~generator.throw` or :meth:"
"`~generator.close` call through the current frame.  If ``STACK[-1]`` is an "
"instance of :exc:`StopIteration`, pop three values from the stack and push "
"its ``value`` member.  Otherwise, re-raise ``STACK[-1]``."
msgstr ""
"Trata uma exceção levantada durante um chamada a :meth:`~generator.throw` "
"ou :meth:`~generator.close` através do quadro atual.  Se ``STACK[-1]`` for "
"uma instância de :exc:`StopIteration`, remove três valores da pilha e põe de "
"volta o seu membro ``value``.  Caso contrário, re-levanta ``STACK[-1]``."

#: ../../library/dis.rst:681
msgid ""
"Resolves ``__aenter__`` and ``__aexit__`` from ``STACK[-1]``. Pushes "
"``__aexit__`` and result of ``__aenter__()`` to the stack::"
msgstr ""
"Resolve os métodos especiais ``__aenter__`` e ``__aexit__`` de "
"``STACK[-1]``. Põe na pilha ``__aexit__`` e o resultado de ``__aenter__()``::"

#: ../../library/dis.rst:684
msgid "STACK.extend((__aexit__, __aenter__())"
msgstr ""

#: ../../library/dis.rst:690
msgid "**Miscellaneous opcodes**"
msgstr "**Opcodes genéricos**"

#: ../../library/dis.rst:696
msgid ""
"item = STACK.pop()\n"
"set.add(STACK[-i], item)"
msgstr ""

#: ../../library/dis.rst:699
msgid "Used to implement set comprehensions."
msgstr "Usado para implementar compreensões de conjuntos."

#: ../../library/dis.rst:706
msgid ""
"item = STACK.pop()\n"
"list.append(STACK[-i], item)"
msgstr ""

#: ../../library/dis.rst:709
msgid "Used to implement list comprehensions."
msgstr "Usado para implementar compreensões de lista."

#: ../../library/dis.rst:716
msgid ""
"value = STACK.pop()\n"
"key = STACK.pop()\n"
"dict.__setitem__(STACK[-i], key, value)"
msgstr ""

#: ../../library/dis.rst:720
msgid "Used to implement dict comprehensions."
msgstr "Usado para implementar compreensões de dicionário."

#: ../../library/dis.rst:723
msgid ""
"Map value is ``STACK[-1]`` and map key is ``STACK[-2]``. Before, those were "
"reversed."
msgstr ""
"O valor do mapa é ``STACK[-1]``, e a sua chave, ``STACK[-2]``. Antes, eles "
"estavam ao contrário."

#: ../../library/dis.rst:727
msgid ""
"For all of the :opcode:`SET_ADD`, :opcode:`LIST_APPEND` and :opcode:"
"`MAP_ADD` instructions, while the added value or key/value pair is popped "
"off, the container object remains on the stack so that it is available for "
"further iterations of the loop."
msgstr ""
"Para as instruções :opcode:`SET_ADD`, :opcode:`LIST_APPEND` e :opcode:"
"`MAP_ADD`, o valor ou par chave/valor é removido da pilha, mas o objeto de "
"contêiner continua na pilha para que ele esteja disponível para as iterações "
"seguintes do laço."

#: ../../library/dis.rst:735
msgid "Returns with ``STACK[-1]`` to the caller of the function."
msgstr "Retorna ``STACK[-1]`` para quem chamou a função."

#: ../../library/dis.rst:740
msgid "Returns with ``co_consts[consti]`` to the caller of the function."
msgstr "Retorna ``co_consts[consti]`` para quem chamou a função."

#: ../../library/dis.rst:747
msgid "Yields ``STACK.pop()`` from a :term:`generator`."
msgstr "Gera ``STACK.pop()`` a partir de um :term:`gerador`."

#: ../../library/dis.rst:749
msgid "oparg set to be the stack depth."
msgstr "oparg definido como sendo a profundidade da pilha."

#: ../../library/dis.rst:752
msgid ""
"oparg set to be the exception block depth, for efficient closing of "
"generators."
msgstr ""
"oparg definido como sendo a profundidade do bloco exception, para o "
"fechamento eficiente de geradores."

#: ../../library/dis.rst:758
msgid ""
"Checks whether ``__annotations__`` is defined in ``locals()``, if not it is "
"set up to an empty ``dict``. This opcode is only emitted if a class or "
"module body contains :term:`variable annotations <variable annotation>` "
"statically."
msgstr ""
"Verifica se ``__annotations__`` está definido em ``locals()`` e, se não "
"estiver, é inicializado como um ``dict`` vazio. Este opcode é emitido "
"somente se o corpo de uma classe ou módulo contém :term:`anotações de "
"variáveis <anotação de variável>` estaticamente."

#: ../../library/dis.rst:768
msgid ""
"Pops a value from the stack, which is used to restore the exception state."
msgstr ""
"Remove o valor no topo da pilha, o qual é usado para restaurar o estado de "
"exceção."

#: ../../library/dis.rst:775
msgid ""
"Re-raises the exception currently on top of the stack. If oparg is non-zero, "
"pops an additional value from the stack which is used to set :attr:`~frame."
"f_lasti` of the current frame."
msgstr ""
"Re-levanta a exceção que se encontra no topo da pilha. Se o oparg não for "
"zero, remove um valor adicional do topo da pilha, o qual é atribuído ao :"
"attr:`~frame.f_lasti`` do quadro atual."

#: ../../library/dis.rst:786
msgid ""
"Pops a value from the stack. Pushes the current exception to the top of the "
"stack. Pushes the value originally popped back to the stack. Used in "
"exception handlers."
msgstr ""
"Remove um valor do topo da pilha. Põe a exceção atual no topo da pilha. Põe "
"de volta no topo da pilha o valor que foi removido inicialmente. Usado em "
"tratadores de exceções."

#: ../../library/dis.rst:794
msgid ""
"Performs exception matching for ``except``. Tests whether the ``STACK[-2]`` "
"is an exception matching ``STACK[-1]``. Pops ``STACK[-1]`` and pushes the "
"boolean result of the test."
msgstr ""
"Verifica correspondências de exceções em ``except``. Testa de ``STACK[-2]`` "
"é uma exceção que corresponde a ``STACK[-1]``. Remove ``STACK[-1]`` do topo "
"da pilha, e põe no seu lugar o resultado booleano do teste."

#: ../../library/dis.rst:802
msgid ""
"Performs exception matching for ``except*``. Applies ``split(STACK[-1])`` on "
"the exception group representing ``STACK[-2]``."
msgstr ""
"Verifica correspondências de exceções em ``except*``. Aplica "
"``split(STACK[-1])`` no grupo de exceções que representa ``STACK[-2]``."

#: ../../library/dis.rst:805
msgid ""
"In case of a match, pops two items from the stack and pushes the non-"
"matching subgroup (``None`` in case of full match) followed by the matching "
"subgroup. When there is no match, pops one item (the match type) and pushes "
"``None``."
msgstr ""
"No caso de uma correspondência, remove dois itens do topo da pilha e põe "
"nela o subgrupo que falhou a correspondência (``None`` caso a "
"correspondência tenha sido total), seguido pelo subgrupo que correspondeu. "
"Quando não há correspondência nenhuma, remove um item (o tipo da "
"correspondêcia) e põe ``None`` no seu lugar."

#: ../../library/dis.rst:814
msgid ""
"Calls the function in position 4 on the stack with arguments (type, val, tb) "
"representing the exception at the top of the stack. Used to implement the "
"call ``context_manager.__exit__(*exc_info())`` when an exception has "
"occurred in a :keyword:`with` statement."
msgstr ""
"Chama a função na posição 4 da pilha com argumentos (tipo, val, tb) "
"representando a exceção no topo da pilha. Usado para implementar a chamada "
"``context_manager.__exit__(*exc_info())`` quando uma exceção ocorreu em uma "
"instrução :keyword:`with`."

#: ../../library/dis.rst:821
msgid ""
"The ``__exit__`` function is in position 4 of the stack rather than 7. "
"Exception representation on the stack now consist of one, not three, items."
msgstr ""
"A função ``__exit__`` fica agora na posição 4 pilha, ao invés da 7. A "
"representação da exceção pilha consiste agora de um item, não três."

#: ../../library/dis.rst:828
msgid ""
"Pushes :exc:`AssertionError` onto the stack.  Used by the :keyword:`assert` "
"statement."
msgstr ""
"Põe :exc:`AssertionError` no topo da pilha.  Usado pela instrução :keyword:"
"`assert`."

#: ../../library/dis.rst:836
msgid ""
"Pushes :func:`!builtins.__build_class__` onto the stack.  It is later called "
"to construct a class."
msgstr ""
"Põe a função :func:`!builtins.__build_class__` no topo da pilha.  Ela será "
"chamada posteriormente para construir uma classe."

#: ../../library/dis.rst:842
msgid ""
"This opcode performs several operations before a with block starts.  First, "
"it loads :meth:`~object.__exit__` from the context manager and pushes it "
"onto the stack for later use by :opcode:`WITH_EXCEPT_START`.  Then, :meth:"
"`~object.__enter__` is called. Finally, the result of calling the "
"``__enter__()`` method is pushed onto the stack."
msgstr ""
"Este opcode realiza várias operações antes do início de um bloco \"with\".  "
"Primeiro, ele carrega o :meth:`~object.__exit__` do gerenciador de contexto "
"e o coloca no topo da pilha para ser usado posteriormente pela :opcode:"
"`WITH_EXCEPT_START`.  Então, o método :meth:`~object.__enter__` é chamado. "
"Por fim, o resultado do ``__enter__()`` é posto no topo da pilha."

#: ../../library/dis.rst:853
msgid ""
"Perform ``STACK.append(len(STACK[-1]))``. Used in :keyword:`match` "
"statements where comparison with structure of pattern is needed."
msgstr ""

#: ../../library/dis.rst:861
msgid ""
"If ``STACK[-1]`` is an instance of :class:`collections.abc.Mapping` (or, "
"more technically: if it has the :c:macro:`Py_TPFLAGS_MAPPING` flag set in "
"its :c:member:`~PyTypeObject.tp_flags`), push ``True`` onto the stack.  "
"Otherwise, push ``False``."
msgstr ""
"Se ``STACK[-1]`` for uma instância de :class:`collections.abc.Mapping` (ou, "
"de forma mais técnica: se tiver o sinalizador :c:macro:`Py_TPFLAGS_MAPPING` "
"definido no seu :c:member:`~PyTypeObject.tp_flags`), põe ``True`` no topo da "
"pilha. Caso contrário, põe ``False``."

#: ../../library/dis.rst:871
msgid ""
"If ``STACK[-1]`` is an instance of :class:`collections.abc.Sequence` and is "
"*not* an instance of :class:`str`/:class:`bytes`/:class:`bytearray` (or, "
"more technically: if it has the :c:macro:`Py_TPFLAGS_SEQUENCE` flag set in "
"its :c:member:`~PyTypeObject.tp_flags`), push ``True`` onto the stack.  "
"Otherwise, push ``False``."
msgstr ""
"Se ``STACK[-1]`` for uma instância de :class:`collections.abc.Sequence` e "
"*não* for uma instância de :class:`str`/:class:`bytes`/:class:`bytearray` "
"(ou, de forma mais técnica: se tiver o sinalizador :c:macro:"
"`Py_TPFLAGS_SEQUENCE` definido no seu :c:member:`~PyTypeObject.tp_flags`), "
"põe ``True`` no topo da pilha. Caso contrário, põe ``False``."

#: ../../library/dis.rst:881
msgid ""
"``STACK[-1]`` is a tuple of mapping keys, and ``STACK[-2]`` is the match "
"subject. If ``STACK[-2]`` contains all of the keys in ``STACK[-1]``, push a :"
"class:`tuple` containing the corresponding values. Otherwise, push ``None``."
msgstr ""
"``STACK[-1]`` é uma tupla de chaves de um mapeamento, e ``STACK[-2]`` é o "
"sujeito de uma correspondência. Se ``STACK[-2]`` contiver todas as chaves em "
"``STACK[-1]``, põe no topo da pilha um :class:`tuple` contendo os valores "
"correspondentes. Caso contrário, põe ``None``."

#: ../../library/dis.rst:887 ../../library/dis.rst:1521
msgid ""
"Previously, this instruction also pushed a boolean value indicating success "
"(``True``) or failure (``False``)."
msgstr ""
"Anteriormente, essa instrução também colocava na pilha um valor booleano "
"indicando sucesso (``True``) ou falha (``False``)."

#: ../../library/dis.rst:894
msgid ""
"Implements ``name = STACK.pop()``. *namei* is the index of *name* in the "
"attribute :attr:`~codeobject.co_names` of the :ref:`code object <code-"
"objects>`. The compiler tries to use :opcode:`STORE_FAST` or :opcode:"
"`STORE_GLOBAL` if possible."
msgstr ""
"Implementa ``name = STACK.pop()``. *namei* é o índice de *name* no atributo :"
"attr:`~codeobject.co_names` do :ref:`objeto de código <code-objects>`. O "
"compilador tenta usar :opcode:`STORE_FAST` ou :opcode:`STORE_GLOBAL` se "
"possível."

#: ../../library/dis.rst:901
msgid ""
"Implements ``del name``, where *namei* is the index into :attr:`~codeobject."
"co_names` attribute of the :ref:`code object <code-objects>`."
msgstr ""
"Implementa ``del name``, onde *namei* é o índice no atributo :attr:"
"`~codeobject.co_names` do :ref:`objeto de código <code-objects>`."

#: ../../library/dis.rst:907
msgid ""
"Unpacks ``STACK[-1]`` into *count* individual values, which are put onto the "
"stack right-to-left. Require there to be exactly *count* values.::"
msgstr ""
"Desempacota ``STACK[-1]`` em *count* valores individuais, os quais são "
"postos na pilha da direita para a esquerda. Requer que haja exatamente "
"*count* valores::"

#: ../../library/dis.rst:910
msgid ""
"assert(len(STACK[-1]) == count)\n"
"STACK.extend(STACK.pop()[:-count-1:-1])"
msgstr ""

#: ../../library/dis.rst:916
msgid ""
"Implements assignment with a starred target: Unpacks an iterable in "
"``STACK[-1]`` into individual values, where the total number of values can "
"be smaller than the number of items in the iterable: one of the new values "
"will be a list of all leftover items."
msgstr ""
"Implementa atribuição com um alvo estrelado: desempacota o iterável "
"``STACK[-1]`` em valores individuais, sendo que pode haver menos valores do "
"que itens no iterável: um dos novos valores será a lista de todos os itens "
"que sobraram."

#: ../../library/dis.rst:921
msgid "The number of values before and after the list value is limited to 255."
msgstr ""
"A quantidade de valores antes e após o valor que será a lista é limitada a "
"255."

#: ../../library/dis.rst:923
msgid ""
"The number of values before the list value is encoded in the argument of the "
"opcode. The number of values after the list if any is encoded using an "
"``EXTENDED_ARG``. As a consequence, the argument can be seen as a two bytes "
"values where the low byte of *counts* is the number of values before the "
"list value, the high byte of *counts* the number of values after it."
msgstr ""
"A quantidade de valores antes do valor lista é passada no argumento do "
"opcode. A quantidade de valores após a lista, se houver, é passada usando um "
"``EXTENDED_ARG``. A consequência é que o argumento pode ser visto como um "
"valor de dois bytes, onde o byte \"de baixo\" de *counts* é a quantidade de "
"valores antes do valor lista, e o byte \"de cima\" de *counts*, a quantidade "
"após."

#: ../../library/dis.rst:929
msgid ""
"The extracted values are put onto the stack right-to-left, i.e. ``a, *b, c = "
"d`` will be stored after execution as ``STACK.extend((a, b, c))``."
msgstr ""
"Os valores extraídos são postos na pilha da direita para a esquerda, ou "
"seja, após executar ``a, *b, c = d`` os valores serão armazenados como "
"``STACK.extend((a, b, c))``."

#: ../../library/dis.rst:937
msgid ""
"obj = STACK.pop()\n"
"value = STACK.pop()\n"
"obj.name = value"
msgstr ""

#: ../../library/dis.rst:941
msgid ""
"where *namei* is the index of name in :attr:`~codeobject.co_names` of the :"
"ref:`code object <code-objects>`."
msgstr ""
"onde *namei* é o índice do nome no :attr:`~codeobject.co_names` do :ref:"
"`objeto de código <code-objects>`."

#: ../../library/dis.rst:948
msgid ""
"obj = STACK.pop()\n"
"del obj.name"
msgstr ""

#: ../../library/dis.rst:951
msgid ""
"where *namei* is the index of name into :attr:`~codeobject.co_names` of the :"
"ref:`code object <code-objects>`."
msgstr ""
"onde *namei* é o índice do nome no :attr:`~codeobject.co_names` do :ref:"
"`objeto de código <code-objects>`."

#: ../../library/dis.rst:957
msgid "Works as :opcode:`STORE_NAME`, but stores the name as a global."
msgstr ""
"Funciona como o :opcode:`STORE_NAME`, mas o nome é armazenado com um nome "
"global."

#: ../../library/dis.rst:962
msgid "Works as :opcode:`DELETE_NAME`, but deletes a global name."
msgstr "Funciona como o :opcode:`DELETE_NAME`, mas deleta um nome global."

#: ../../library/dis.rst:967
msgid "Pushes ``co_consts[consti]`` onto the stack."
msgstr "Põe ``co_consts[consti]`` no topo da pilha."

#: ../../library/dis.rst:972
msgid ""
"Pushes the value associated with ``co_names[namei]`` onto the stack. The "
"name is looked up within the locals, then the globals, then the builtins."
msgstr ""
"Põe no topo da pilha o valor associado a ``co_names[namei]``. O nome é "
"procurado nos locais, nos globais, e então nos embutidos."

#: ../../library/dis.rst:978
msgid ""
"Pushes a reference to the locals dictionary onto the stack.  This is used to "
"prepare namespace dictionaries for :opcode:`LOAD_FROM_DICT_OR_DEREF` and :"
"opcode:`LOAD_FROM_DICT_OR_GLOBALS`."
msgstr ""

#: ../../library/dis.rst:987
msgid ""
"Pops a mapping off the stack and looks up the value for ``co_names[namei]``. "
"If the name is not found there, looks it up in the globals and then the "
"builtins, similar to :opcode:`LOAD_GLOBAL`. This is used for loading global "
"variables in :ref:`annotation scopes <annotation-scopes>` within class "
"bodies."
msgstr ""

#: ../../library/dis.rst:998
msgid ""
"Creates a tuple consuming *count* items from the stack, and pushes the "
"resulting tuple onto the stack::"
msgstr ""

#: ../../library/dis.rst:1001
msgid ""
"if count == 0:\n"
"    value = ()\n"
"else:\n"
"    value = tuple(STACK[-count:])\n"
"    STACK = STACK[:-count]\n"
"\n"
"STACK.append(value)"
msgstr ""

#: ../../library/dis.rst:1012
msgid "Works as :opcode:`BUILD_TUPLE`, but creates a list."
msgstr ""

#: ../../library/dis.rst:1017
msgid "Works as :opcode:`BUILD_TUPLE`, but creates a set."
msgstr ""

#: ../../library/dis.rst:1022
msgid ""
"Pushes a new dictionary object onto the stack.  Pops ``2 * count`` items so "
"that the dictionary holds *count* entries: ``{..., STACK[-4]: STACK[-3], "
"STACK[-2]: STACK[-1]}``."
msgstr ""

#: ../../library/dis.rst:1026
msgid ""
"The dictionary is created from stack items instead of creating an empty "
"dictionary pre-sized to hold *count* items."
msgstr ""

#: ../../library/dis.rst:1033
msgid ""
"The version of :opcode:`BUILD_MAP` specialized for constant keys. Pops the "
"top element on the stack which contains a tuple of keys, then starting from "
"``STACK[-2]``, pops *count* values to form values in the built dictionary."
msgstr ""

#: ../../library/dis.rst:1042
msgid ""
"Concatenates *count* strings from the stack and pushes the resulting string "
"onto the stack."
msgstr ""

#: ../../library/dis.rst:1052
msgid ""
"seq = STACK.pop()\n"
"list.extend(STACK[-i], seq)"
msgstr ""

#: ../../library/dis.rst:1055
msgid "Used to build lists."
msgstr ""

#: ../../library/dis.rst:1064
msgid ""
"seq = STACK.pop()\n"
"set.update(STACK[-i], seq)"
msgstr ""

#: ../../library/dis.rst:1067
msgid "Used to build sets."
msgstr ""

#: ../../library/dis.rst:1076
msgid ""
"map = STACK.pop()\n"
"dict.update(STACK[-i], map)"
msgstr ""

#: ../../library/dis.rst:1079
msgid "Used to build dicts."
msgstr ""

#: ../../library/dis.rst:1086
msgid "Like :opcode:`DICT_UPDATE` but raises an exception for duplicate keys."
msgstr ""

#: ../../library/dis.rst:1093
msgid ""
"If the low bit of ``namei`` is not set, this replaces ``STACK[-1]`` with "
"``getattr(STACK[-1], co_names[namei>>1])``."
msgstr ""

#: ../../library/dis.rst:1096
msgid ""
"If the low bit of ``namei`` is set, this will attempt to load a method named "
"``co_names[namei>>1]`` from the ``STACK[-1]`` object. ``STACK[-1]`` is "
"popped. This bytecode distinguishes two cases: if ``STACK[-1]`` has a method "
"with the correct name, the bytecode pushes the unbound method and "
"``STACK[-1]``. ``STACK[-1]`` will be used as the first argument (``self``) "
"by :opcode:`CALL` when calling the unbound method. Otherwise, ``NULL`` and "
"the object returned by the attribute lookup are pushed."
msgstr ""

#: ../../library/dis.rst:1104
msgid ""
"If the low bit of ``namei`` is set, then a ``NULL`` or ``self`` is pushed to "
"the stack before the attribute or unbound method respectively."
msgstr ""

#: ../../library/dis.rst:1111
msgid ""
"This opcode implements :func:`super`, both in its zero-argument and two-"
"argument forms (e.g. ``super().method()``, ``super().attr`` and ``super(cls, "
"self).method()``, ``super(cls, self).attr``)."
msgstr ""

#: ../../library/dis.rst:1115
msgid ""
"It pops three values from the stack (from top of stack down): - ``self``: "
"the first argument to the current method -  ``cls``: the class within which "
"the current method was defined -  the global ``super``"
msgstr ""

#: ../../library/dis.rst:1120
msgid ""
"With respect to its argument, it works similarly to :opcode:`LOAD_ATTR`, "
"except that ``namei`` is shifted left by 2 bits instead of 1."
msgstr ""

#: ../../library/dis.rst:1123
msgid ""
"The low bit of ``namei`` signals to attempt a method load, as with :opcode:"
"`LOAD_ATTR`, which results in pushing ``NULL`` and the loaded method. When "
"it is unset a single value is pushed to the stack."
msgstr ""

#: ../../library/dis.rst:1127
msgid ""
"The second-low bit of ``namei``, if set, means that this was a two-argument "
"call to :func:`super` (unset means zero-argument)."
msgstr ""

#: ../../library/dis.rst:1135
msgid ""
"Performs a Boolean operation.  The operation name can be found in "
"``cmp_op[opname >> 4]``."
msgstr ""

#: ../../library/dis.rst:1138
msgid ""
"The cmp_op index is now stored in the four-highest bits of oparg instead of "
"the four-lowest bits of oparg."
msgstr ""

#: ../../library/dis.rst:1144
msgid "Performs ``is`` comparison, or ``is not`` if ``invert`` is 1."
msgstr ""

#: ../../library/dis.rst:1151
msgid "Performs ``in`` comparison, or ``not in`` if ``invert`` is 1."
msgstr ""

#: ../../library/dis.rst:1158
msgid ""
"Imports the module ``co_names[namei]``.  ``STACK[-1]`` and ``STACK[-2]`` are "
"popped and provide the *fromlist* and *level* arguments of :func:"
"`__import__`. The module object is pushed onto the stack.  The current "
"namespace is not affected: for a proper import statement, a subsequent :"
"opcode:`STORE_FAST` instruction modifies the namespace."
msgstr ""

#: ../../library/dis.rst:1166
msgid ""
"Loads the attribute ``co_names[namei]`` from the module found in "
"``STACK[-1]``. The resulting object is pushed onto the stack, to be "
"subsequently stored by a :opcode:`STORE_FAST` instruction."
msgstr ""

#: ../../library/dis.rst:1173
msgid "Increments bytecode counter by *delta*."
msgstr ""

#: ../../library/dis.rst:1178
msgid "Decrements bytecode counter by *delta*. Checks for interrupts."
msgstr ""

#: ../../library/dis.rst:1185
msgid "Decrements bytecode counter by *delta*. Does not check for interrupts."
msgstr ""

#: ../../library/dis.rst:1192
msgid ""
"If ``STACK[-1]`` is true, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""

#: ../../library/dis.rst:1195 ../../library/dis.rst:1208
msgid ""
"The oparg is now a relative delta rather than an absolute target. This "
"opcode is a pseudo-instruction, replaced in final bytecode by the directed "
"versions (forward/backward)."
msgstr ""

#: ../../library/dis.rst:1200 ../../library/dis.rst:1213
#: ../../library/dis.rst:1226 ../../library/dis.rst:1240
msgid "This is no longer a pseudo-instruction."
msgstr ""

#: ../../library/dis.rst:1205
msgid ""
"If ``STACK[-1]`` is false, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""

#: ../../library/dis.rst:1218
msgid ""
"If ``STACK[-1]`` is not ``None``, increments the bytecode counter by "
"*delta*. ``STACK[-1]`` is popped."
msgstr ""

#: ../../library/dis.rst:1221 ../../library/dis.rst:1235
msgid ""
"This opcode is a pseudo-instruction, replaced in final bytecode by the "
"directed versions (forward/backward)."
msgstr ""

#: ../../library/dis.rst:1232
msgid ""
"If ``STACK[-1]`` is ``None``, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""

#: ../../library/dis.rst:1245
msgid ""
"``STACK[-1]`` is an :term:`iterator`.  Call its :meth:`~iterator.__next__` "
"method. If this yields a new value, push it on the stack (leaving the "
"iterator below it).  If the iterator indicates it is exhausted then the byte "
"code counter is incremented by *delta*."
msgstr ""

#: ../../library/dis.rst:1250
msgid "Up until 3.11 the iterator was popped when it was exhausted."
msgstr ""

#: ../../library/dis.rst:1255
msgid "Loads the global named ``co_names[namei>>1]`` onto the stack."
msgstr ""

#: ../../library/dis.rst:1257
msgid ""
"If the low bit of ``namei`` is set, then a ``NULL`` is pushed to the stack "
"before the global variable."
msgstr ""

#: ../../library/dis.rst:1263
msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack."
msgstr ""

#: ../../library/dis.rst:1265
msgid ""
"This opcode is now only used in situations where the local variable is "
"guaranteed to be initialized. It cannot raise :exc:`UnboundLocalError`."
msgstr ""

#: ../../library/dis.rst:1271
msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack, "
"raising an :exc:`UnboundLocalError` if the local variable has not been "
"initialized."
msgstr ""

#: ../../library/dis.rst:1279
msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack (or "
"pushes ``NULL`` onto the stack if the local variable has not been "
"initialized) and sets ``co_varnames[var_num]`` to ``NULL``."
msgstr ""

#: ../../library/dis.rst:1287
msgid "Stores ``STACK.pop()`` into the local ``co_varnames[var_num]``."
msgstr ""

#: ../../library/dis.rst:1292
msgid "Deletes local ``co_varnames[var_num]``."
msgstr ""

#: ../../library/dis.rst:1297
msgid ""
"Creates a new cell in slot ``i``.  If that slot is nonempty then that value "
"is stored into the new cell."
msgstr ""

#: ../../library/dis.rst:1305
msgid ""
"Pushes a reference to the cell contained in slot ``i`` of the \"fast "
"locals\" storage.  The name of the variable is ``co_fastlocalnames[i]``."
msgstr ""

#: ../../library/dis.rst:1308
msgid ""
"Note that ``LOAD_CLOSURE`` is effectively an alias for ``LOAD_FAST``. It "
"exists to keep bytecode a little more readable."
msgstr ""

#: ../../library/dis.rst:1311
msgid "``i`` is no longer offset by the length of ``co_varnames``."
msgstr ""

#: ../../library/dis.rst:1317
msgid ""
"Loads the cell contained in slot ``i`` of the \"fast locals\" storage. "
"Pushes a reference to the object the cell contains on the stack."
msgstr ""

#: ../../library/dis.rst:1320 ../../library/dis.rst:1342
#: ../../library/dis.rst:1353
msgid ""
"``i`` is no longer offset by the length of :attr:`~codeobject.co_varnames`."
msgstr ""

#: ../../library/dis.rst:1326
msgid ""
"Pops a mapping off the stack and looks up the name associated with slot "
"``i`` of the \"fast locals\" storage in this mapping. If the name is not "
"found there, loads it from the cell contained in slot ``i``, similar to :"
"opcode:`LOAD_DEREF`. This is used for loading free variables in class bodies "
"(which previously used :opcode:`!LOAD_CLASSDEREF`) and in :ref:`annotation "
"scopes <annotation-scopes>` within class bodies."
msgstr ""

#: ../../library/dis.rst:1339
msgid ""
"Stores ``STACK.pop()`` into the cell contained in slot ``i`` of the \"fast "
"locals\" storage."
msgstr ""

#: ../../library/dis.rst:1348
msgid ""
"Empties the cell contained in slot ``i`` of the \"fast locals\" storage. "
"Used by the :keyword:`del` statement."
msgstr ""

#: ../../library/dis.rst:1359
msgid ""
"Copies the ``n`` free variables from the closure into the frame. Removes the "
"need for special code on the caller's side when calling closures."
msgstr ""

#: ../../library/dis.rst:1368
msgid ""
"Raises an exception using one of the 3 forms of the ``raise`` statement, "
"depending on the value of *argc*:"
msgstr ""

#: ../../library/dis.rst:1371
msgid "0: ``raise`` (re-raise previous exception)"
msgstr ""

#: ../../library/dis.rst:1372
msgid ""
"1: ``raise STACK[-1]`` (raise exception instance or type at ``STACK[-1]``)"
msgstr ""

#: ../../library/dis.rst:1373
msgid ""
"2: ``raise STACK[-2] from STACK[-1]`` (raise exception instance or type at "
"``STACK[-2]`` with ``__cause__`` set to ``STACK[-1]``)"
msgstr ""

#: ../../library/dis.rst:1379
msgid ""
"Calls a callable object with the number of arguments specified by ``argc``, "
"including the named arguments specified by the preceding :opcode:`KW_NAMES`, "
"if any. On the stack are (in ascending order), either:"
msgstr ""

#: ../../library/dis.rst:1384
msgid "NULL"
msgstr "NULL"

#: ../../library/dis.rst:1385 ../../library/dis.rst:1391
msgid "The callable"
msgstr ""

#: ../../library/dis.rst:1386
msgid "The positional arguments"
msgstr ""

#: ../../library/dis.rst:1387 ../../library/dis.rst:1394
msgid "The named arguments"
msgstr ""

#: ../../library/dis.rst:1389
msgid "or:"
msgstr ""

#: ../../library/dis.rst:1392
msgid "``self``"
msgstr "``self``"

#: ../../library/dis.rst:1393
msgid "The remaining positional arguments"
msgstr ""

#: ../../library/dis.rst:1396
msgid ""
"``argc`` is the total of the positional and named arguments, excluding "
"``self`` when a ``NULL`` is not present."
msgstr ""

#: ../../library/dis.rst:1399
msgid ""
"``CALL`` pops all arguments and the callable object off the stack, calls the "
"callable object with those arguments, and pushes the return value returned "
"by the callable object."
msgstr ""

#: ../../library/dis.rst:1408
msgid ""
"Calls a callable object with variable set of positional and keyword "
"arguments.  If the lowest bit of *flags* is set, the top of the stack "
"contains a mapping object containing additional keyword arguments. Before "
"the callable is called, the mapping object and iterable object are each "
"\"unpacked\" and their contents passed in as keyword and positional "
"arguments respectively. ``CALL_FUNCTION_EX`` pops all arguments and the "
"callable object off the stack, calls the callable object with those "
"arguments, and pushes the return value returned by the callable object."
msgstr ""

#: ../../library/dis.rst:1423
msgid ""
"Pushes a ``NULL`` to the stack. Used in the call sequence to match the "
"``NULL`` pushed by :opcode:`LOAD_METHOD` for non-method calls."
msgstr ""

#: ../../library/dis.rst:1432
msgid ""
"Prefixes :opcode:`CALL`. Stores a reference to ``co_consts[consti]`` into an "
"internal variable for use by :opcode:`CALL`. ``co_consts[consti]`` must be a "
"tuple of strings."
msgstr ""

#: ../../library/dis.rst:1441
msgid ""
"Pushes a new function object on the stack.  From bottom to top, the consumed "
"stack must consist of values if the argument carries a specified flag value"
msgstr ""

#: ../../library/dis.rst:1444
msgid ""
"``0x01`` a tuple of default values for positional-only and positional-or-"
"keyword parameters in positional order"
msgstr ""

#: ../../library/dis.rst:1446
msgid "``0x02`` a dictionary of keyword-only parameters' default values"
msgstr ""

#: ../../library/dis.rst:1447
msgid "``0x04`` a tuple of strings containing parameters' annotations"
msgstr ""

#: ../../library/dis.rst:1448
msgid "``0x08`` a tuple containing cells for free variables, making a closure"
msgstr ""

#: ../../library/dis.rst:1449
msgid "the code associated with the function (at ``STACK[-1]``)"
msgstr ""

#: ../../library/dis.rst:1451
msgid "Flag value ``0x04`` is a tuple of strings instead of dictionary"
msgstr ""

#: ../../library/dis.rst:1454
msgid "Qualified name at ``STACK[-1]`` was removed."
msgstr ""

#: ../../library/dis.rst:1462
msgid ""
"Pushes a slice object on the stack.  *argc* must be 2 or 3.  If it is 2, "
"implements::"
msgstr ""

#: ../../library/dis.rst:1464
msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"STACK.append(slice(start, end))"
msgstr ""

#: ../../library/dis.rst:1468
msgid "if it is 3, implements::"
msgstr ""

#: ../../library/dis.rst:1470
msgid ""
"step = STACK.pop()\n"
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"STACK.append(slice(start, end, step))"
msgstr ""

#: ../../library/dis.rst:1475
msgid "See the :func:`slice` built-in function for more information."
msgstr ""

#: ../../library/dis.rst:1480
msgid ""
"Prefixes any opcode which has an argument too big to fit into the default "
"one byte. *ext* holds an additional byte which act as higher bits in the "
"argument. For each opcode, at most three prefixal ``EXTENDED_ARG`` are "
"allowed, forming an argument from two-byte to four-byte."
msgstr ""

#: ../../library/dis.rst:1488
msgid ""
"Used for implementing formatted literal strings (f-strings).  Pops an "
"optional *fmt_spec* from the stack, then a required *value*. *flags* is "
"interpreted as follows:"
msgstr ""

#: ../../library/dis.rst:1492
msgid "``(flags & 0x03) == 0x00``: *value* is formatted as-is."
msgstr ""

#: ../../library/dis.rst:1493
msgid ""
"``(flags & 0x03) == 0x01``: call :func:`str` on *value* before formatting it."
msgstr ""

#: ../../library/dis.rst:1495
msgid ""
"``(flags & 0x03) == 0x02``: call :func:`repr` on *value* before formatting "
"it."
msgstr ""

#: ../../library/dis.rst:1497
msgid ""
"``(flags & 0x03) == 0x03``: call :func:`ascii` on *value* before formatting "
"it."
msgstr ""

#: ../../library/dis.rst:1499
msgid ""
"``(flags & 0x04) == 0x04``: pop *fmt_spec* from the stack and use it, else "
"use an empty *fmt_spec*."
msgstr ""

#: ../../library/dis.rst:1502
msgid ""
"Formatting is performed using :c:func:`PyObject_Format`.  The result is "
"pushed on the stack."
msgstr ""

#: ../../library/dis.rst:1510
msgid ""
"``STACK[-1]`` is a tuple of keyword attribute names, ``STACK[-2]`` is the "
"class being matched against, and ``STACK[-3]`` is the match subject.  "
"*count* is the number of positional sub-patterns."
msgstr ""

#: ../../library/dis.rst:1514
msgid ""
"Pop ``STACK[-1]``, ``STACK[-2]``, and ``STACK[-3]``. If ``STACK[-3]`` is an "
"instance of ``STACK[-2]`` and has the positional and keyword attributes "
"required by *count* and ``STACK[-1]``, push a tuple of extracted attributes. "
"Otherwise, push ``None``."
msgstr ""

#: ../../library/dis.rst:1528
msgid "A no-op. Performs internal tracing, debugging and optimization checks."
msgstr ""

#: ../../library/dis.rst:1530
msgid "The ``where`` operand marks where the ``RESUME`` occurs:"
msgstr ""

#: ../../library/dis.rst:1532
msgid ""
"``0`` The start of a function, which is neither a generator, coroutine nor "
"an async generator"
msgstr ""

#: ../../library/dis.rst:1534
msgid "``1`` After a ``yield`` expression"
msgstr "``1`` Depois de uma expressão ``yield``"

#: ../../library/dis.rst:1535
msgid "``2`` After a ``yield from`` expression"
msgstr ""

#: ../../library/dis.rst:1536
msgid "``3`` After an ``await`` expression"
msgstr "``3`` Depois de uma expressão ``await``"

#: ../../library/dis.rst:1543
msgid ""
"Create a generator, coroutine, or async generator from the current frame. "
"Used as first opcode of in code object for the above mentioned callables. "
"Clear the current frame and return the newly created generator."
msgstr ""

#: ../../library/dis.rst:1552
msgid ""
"Equivalent to ``STACK[-1] = STACK[-2].send(STACK[-1])``. Used in ``yield "
"from`` and ``await`` statements."
msgstr ""

#: ../../library/dis.rst:1555
msgid ""
"If the call raises :exc:`StopIteration`, pop the top value from the stack, "
"push the exception's ``value`` attribute, and increment the bytecode counter "
"by *delta*."
msgstr ""

#: ../../library/dis.rst:1564
msgid ""
"This is not really an opcode.  It identifies the dividing line between "
"opcodes in the range [0,255] which don't use their argument and those that "
"do (``< HAVE_ARGUMENT`` and ``>= HAVE_ARGUMENT``, respectively)."
msgstr ""

#: ../../library/dis.rst:1568
msgid ""
"If your application uses pseudo instructions, use the :data:`hasarg` "
"collection instead."
msgstr ""

#: ../../library/dis.rst:1571
msgid ""
"Now every instruction has an argument, but opcodes ``< HAVE_ARGUMENT`` "
"ignore it. Before, only opcodes ``>= HAVE_ARGUMENT`` had an argument."
msgstr ""

#: ../../library/dis.rst:1575
msgid ""
"Pseudo instructions were added to the :mod:`dis` module, and for them it is "
"not true that comparison with ``HAVE_ARGUMENT`` indicates whether they use "
"their arg."
msgstr ""

#: ../../library/dis.rst:1583
msgid ""
"Calls an intrinsic function with one argument. Passes ``STACK[-1]`` as the "
"argument and sets ``STACK[-1]`` to the result. Used to implement "
"functionality that is not performance critical."
msgstr ""

#: ../../library/dis.rst:1587 ../../library/dis.rst:1641
msgid "The operand determines which intrinsic function is called:"
msgstr ""

#: ../../library/dis.rst:1590 ../../library/dis.rst:1644
msgid "Operand"
msgstr ""

#: ../../library/dis.rst:1590 ../../library/dis.rst:1644
msgid "Description"
msgstr "Descrição"

#: ../../library/dis.rst:1592
msgid "``INTRINSIC_1_INVALID``"
msgstr "``INTRINSIC_1_INVALID``"

#: ../../library/dis.rst:1592 ../../library/dis.rst:1646
msgid "Not valid"
msgstr ""

#: ../../library/dis.rst:1594
msgid "``INTRINSIC_PRINT``"
msgstr "``INTRINSIC_PRINT``"

#: ../../library/dis.rst:1594
msgid "Prints the argument to standard out. Used in the REPL."
msgstr ""

#: ../../library/dis.rst:1597
msgid "``INTRINSIC_IMPORT_STAR``"
msgstr "``INTRINSIC_IMPORT_STAR``"

#: ../../library/dis.rst:1597
msgid "Performs ``import *`` for the named module."
msgstr ""

#: ../../library/dis.rst:1600
msgid "``INTRINSIC_STOPITERATION_ERROR``"
msgstr "``INTRINSIC_STOPITERATION_ERROR``"

#: ../../library/dis.rst:1600
msgid "Extracts the return value from a ``StopIteration`` exception."
msgstr ""

#: ../../library/dis.rst:1603
msgid "``INTRINSIC_ASYNC_GEN_WRAP``"
msgstr "``INTRINSIC_ASYNC_GEN_WRAP``"

#: ../../library/dis.rst:1603
msgid "Wraps an async generator value"
msgstr ""

#: ../../library/dis.rst:1605
msgid "``INTRINSIC_UNARY_POSITIVE``"
msgstr "``INTRINSIC_UNARY_POSITIVE``"

#: ../../library/dis.rst:1605
msgid "Performs the unary ``+`` operation"
msgstr ""

#: ../../library/dis.rst:1608
msgid "``INTRINSIC_LIST_TO_TUPLE``"
msgstr "``INTRINSIC_LIST_TO_TUPLE``"

#: ../../library/dis.rst:1608
msgid "Converts a list to a tuple"
msgstr ""

#: ../../library/dis.rst:1610
msgid "``INTRINSIC_TYPEVAR``"
msgstr "``INTRINSIC_TYPEVAR``"

#: ../../library/dis.rst:1610
msgid "Creates a :class:`typing.TypeVar`"
msgstr "Cria um :class:`typing.TypeVar`"

#: ../../library/dis.rst:1612
msgid "``INTRINSIC_PARAMSPEC``"
msgstr "``INTRINSIC_PARAMSPEC``"

#: ../../library/dis.rst:1612
msgid "Creates a :class:`typing.ParamSpec`"
msgstr "Cria um :class:`typing.ParamSpec`"

#: ../../library/dis.rst:1615
msgid "``INTRINSIC_TYPEVARTUPLE``"
msgstr "``INTRINSIC_TYPEVARTUPLE``"

#: ../../library/dis.rst:1615
msgid "Creates a :class:`typing.TypeVarTuple`"
msgstr "Cria um :class:`typing.TypeVarTuple`"

#: ../../library/dis.rst:1618
msgid "``INTRINSIC_SUBSCRIPT_GENERIC``"
msgstr "``INTRINSIC_SUBSCRIPT_GENERIC``"

#: ../../library/dis.rst:1618
msgid "Returns :class:`typing.Generic` subscripted with the argument"
msgstr ""

#: ../../library/dis.rst:1621
msgid "``INTRINSIC_TYPEALIAS``"
msgstr "``INTRINSIC_TYPEALIAS``"

#: ../../library/dis.rst:1621
msgid ""
"Creates a :class:`typing.TypeAliasType`; used in the :keyword:`type` "
"statement. The argument is a tuple of the type alias's name, type "
"parameters, and value."
msgstr ""

#: ../../library/dis.rst:1633
msgid ""
"Calls an intrinsic function with two arguments. Used to implement "
"functionality that is not performance critical::"
msgstr ""

#: ../../library/dis.rst:1636
msgid ""
"arg2 = STACK.pop()\n"
"arg1 = STACK.pop()\n"
"result = intrinsic2(arg1, arg2)\n"
"STACK.push(result)"
msgstr ""

#: ../../library/dis.rst:1646
msgid "``INTRINSIC_2_INVALID``"
msgstr "``INTRINSIC_2_INVALID``"

#: ../../library/dis.rst:1648
msgid "``INTRINSIC_PREP_RERAISE_STAR``"
msgstr "``INTRINSIC_PREP_RERAISE_STAR``"

#: ../../library/dis.rst:1648
msgid "Calculates the :exc:`ExceptionGroup` to raise from a ``try-except*``."
msgstr ""

#: ../../library/dis.rst:1652
msgid "``INTRINSIC_TYPEVAR_WITH_BOUND``"
msgstr "``INTRINSIC_TYPEVAR_WITH_BOUND``"

#: ../../library/dis.rst:1652
msgid "Creates a :class:`typing.TypeVar` with a bound."
msgstr ""

#: ../../library/dis.rst:1655
msgid "``INTRINSIC_TYPEVAR_WITH_CONSTRAINTS``"
msgstr "``INTRINSIC_TYPEVAR_WITH_CONSTRAINTS``"

#: ../../library/dis.rst:1655
msgid "Creates a :class:`typing.TypeVar` with constraints."
msgstr ""

#: ../../library/dis.rst:1659
msgid "``INTRINSIC_SET_FUNCTION_TYPE_PARAMS``"
msgstr "``INTRINSIC_SET_FUNCTION_TYPE_PARAMS``"

#: ../../library/dis.rst:1659
msgid "Sets the ``__type_params__`` attribute of a function."
msgstr ""

#: ../../library/dis.rst:1666
msgid "**Pseudo-instructions**"
msgstr ""

#: ../../library/dis.rst:1668
msgid ""
"These opcodes do not appear in Python bytecode. They are used by the "
"compiler but are replaced by real opcodes or removed before bytecode is "
"generated."
msgstr ""

#: ../../library/dis.rst:1673
msgid ""
"Set up an exception handler for the following code block. If an exception "
"occurs, the value stack level is restored to its current state and control "
"is transferred to the exception handler at ``target``."
msgstr ""

#: ../../library/dis.rst:1680
msgid ""
"Like ``SETUP_FINALLY``, but in case of an exception also pushes the last "
"instruction (``lasti``) to the stack so that ``RERAISE`` can restore it. If "
"an exception occurs, the value stack level and the last instruction on the "
"frame are restored to their current state, and control is transferred to the "
"exception handler at ``target``."
msgstr ""

#: ../../library/dis.rst:1689
msgid ""
"Like ``SETUP_CLEANUP``, but in case of an exception one more item is popped "
"from the stack before control is transferred to the exception handler at "
"``target``."
msgstr ""

#: ../../library/dis.rst:1693
msgid ""
"This variant is used in :keyword:`with` and :keyword:`async with` "
"constructs, which push the return value of the context manager's :meth:"
"`~object.__enter__` or :meth:`~object.__aenter__` to the stack."
msgstr ""

#: ../../library/dis.rst:1700
msgid ""
"Marks the end of the code block associated with the last ``SETUP_FINALLY``, "
"``SETUP_CLEANUP`` or ``SETUP_WITH``."
msgstr ""

#: ../../library/dis.rst:1706
msgid ""
"Undirected relative jump instructions which are replaced by their directed "
"(forward/backward) counterparts by the assembler."
msgstr ""

#: ../../library/dis.rst:1711
msgid ""
"Optimized unbound method lookup. Emitted as a ``LOAD_ATTR`` opcode with a "
"flag set in the arg."
msgstr ""

#: ../../library/dis.rst:1718
msgid "Opcode collections"
msgstr ""

#: ../../library/dis.rst:1720
msgid ""
"These collections are provided for automatic introspection of bytecode "
"instructions:"
msgstr ""

#: ../../library/dis.rst:1723
msgid ""
"The collections now contain pseudo instructions and instrumented "
"instructions as well. These are opcodes with values ``>= MIN_PSEUDO_OPCODE`` "
"and ``>= MIN_INSTRUMENTED_OPCODE``."
msgstr ""

#: ../../library/dis.rst:1730
msgid "Sequence of operation names, indexable using the bytecode."
msgstr ""

#: ../../library/dis.rst:1735
msgid "Dictionary mapping operation names to bytecodes."
msgstr ""

#: ../../library/dis.rst:1740
msgid "Sequence of all compare operation names."
msgstr ""

#: ../../library/dis.rst:1745
msgid "Sequence of bytecodes that use their argument."
msgstr ""

#: ../../library/dis.rst:1752
msgid "Sequence of bytecodes that access a constant."
msgstr ""

#: ../../library/dis.rst:1757
msgid ""
"Sequence of bytecodes that access a free variable. 'free' in this context "
"refers to names in the current scope that are referenced by inner scopes or "
"names in outer scopes that are referenced from this scope.  It does *not* "
"include references to global or builtin scopes."
msgstr ""

#: ../../library/dis.rst:1765
msgid "Sequence of bytecodes that access an attribute by name."
msgstr ""

#: ../../library/dis.rst:1770
msgid "Sequence of bytecodes that have a relative jump target."
msgstr ""

#: ../../library/dis.rst:1775
msgid "Sequence of bytecodes that have an absolute jump target."
msgstr ""

#: ../../library/dis.rst:1780
msgid "Sequence of bytecodes that access a local variable."
msgstr ""

#: ../../library/dis.rst:1785
msgid "Sequence of bytecodes of Boolean operations."
msgstr ""

#: ../../library/dis.rst:1789
msgid "Sequence of bytecodes that set an exception handler."
msgstr ""

#: ../../library/dis.rst:1460
msgid "built-in function"
msgstr "função embutida"

#: ../../library/dis.rst:1460
msgid "slice"
msgstr "fatia"

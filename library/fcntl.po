# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2021
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-25 14:19+0000\n"
"PO-Revision-Date: 2021-06-28 01:06+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/fcntl.rst:2
msgid ":mod:`!fcntl` --- The ``fcntl`` and ``ioctl`` system calls"
msgstr ":mod:`!fcntl` --- as chamadas de sistema ``fcntl`` e ``ioctl``"

#: ../../library/fcntl.rst:16
msgid ""
"This module performs file and I/O control on file descriptors. It is an "
"interface to the :c:func:`fcntl` and :c:func:`ioctl` Unix routines. See "
"the :manpage:`fcntl(2)` and :manpage:`ioctl(2)` Unix manual pages for full "
"details."
msgstr ""
"Este módulo executa o controle de arquivos e de E/S em descritores de "
"arquivos. É uma interface para as rotinas :c:func:`fcntl` e :c:func:`ioctl` "
"do Unix. Veja as páginas de manual do Unix  :manpage:`fcntl(2)` "
"e :manpage:`ioctl(2)` para mais detalhes."

#: ../../library/fcntl.rst:21
msgid "Availability"
msgstr "Disponibilidade"

#: ../../library/fcntl.rst:23
msgid ""
"All functions in this module take a file descriptor *fd* as their first "
"argument.  This can be an integer file descriptor, such as returned by "
"``sys.stdin.fileno()``, or an :class:`io.IOBase` object, such as "
"``sys.stdin`` itself, which provides a :meth:`~io.IOBase.fileno` that "
"returns a genuine file descriptor."
msgstr ""
"Todas as funções neste módulo recebem um descritor de arquivo *fd* como seu "
"primeiro argumento. Este pode ser um descritor de arquivo inteiro, como "
"retornado por ``sys.stdin.fileno()``, ou um objeto :class:`io.IOBase`, como "
"o próprio ``sys.stdin``, que fornece um :meth:`~io.IOBase.fileno` que "
"retorna um descritor de arquivo genuíno."

#: ../../library/fcntl.rst:29
msgid ""
"Operations in this module used to raise an :exc:`IOError` where they now "
"raise an :exc:`OSError`."
msgstr ""
"As operações neste módulo costumavam levantar um :exc:`IOError`, mas agora "
"levantam um :exc:`OSError`."

#: ../../library/fcntl.rst:33
msgid ""
"The :mod:`!fcntl` module now contains ``F_ADD_SEALS``, ``F_GET_SEALS``, and "
"``F_SEAL_*`` constants for sealing of :func:`os.memfd_create` file "
"descriptors."
msgstr ""
"O módulo :mod:`!fcntl` agora contém constantes ``F_ADD_SEALS``, "
"``F_GET_SEALS`` e ``F_SEAL_*`` para selar descritores de "
"arquivo :func:`os.memfd_create`."

#: ../../library/fcntl.rst:38
msgid ""
"On macOS, the :mod:`!fcntl` module exposes the ``F_GETPATH`` constant, which "
"obtains the path of a file from a file descriptor. On Linux(>=3.15), "
"the :mod:`!fcntl` module exposes the ``F_OFD_GETLK``, ``F_OFD_SETLK`` and "
"``F_OFD_SETLKW`` constants, which are used when working with open file "
"description locks."
msgstr ""
"No macOS, o módulo :mod:`!fcntl` expõe a constante ``F_GETPATH``, que obtém "
"o caminho de um arquivo de um descritor de arquivo. No Linux(>=3.15), o "
"módulo :mod:`!fcntl` expõe as constantes ``F_OFD_GETLK``, ``F_OFD_SETLK`` e "
"``F_OFD_SETLKW``, que são usadas ao trabalhar com travas de descrição de "
"arquivo aberto."

#: ../../library/fcntl.rst:45
msgid ""
"On Linux >= 2.6.11, the :mod:`!fcntl` module exposes the ``F_GETPIPE_SZ`` "
"and ``F_SETPIPE_SZ`` constants, which allow to check and modify a pipe's "
"size respectively."
msgstr ""
"No Linux >= 2.6.11, o módulo :mod:`!fcntl` expõe as constantes "
"``F_GETPIPE_SZ`` e ``F_SETPIPE_SZ``, que permitem verificar e modificar o "
"tamanho de um encadeamento, respectivamente."

#: ../../library/fcntl.rst:50
msgid ""
"On FreeBSD, the :mod:`!fcntl` module exposes the ``F_DUP2FD`` and "
"``F_DUP2FD_CLOEXEC`` constants, which allow to duplicate a file descriptor, "
"the latter setting ``FD_CLOEXEC`` flag in addition."
msgstr ""
"No FreeBSD, o módulo :mod:`!fcntl` expõe as constantes ``F_DUP2FD`` e "
"``F_DUP2FD_CLOEXEC``, que permitem duplicar um descritor de arquivo, sendo "
"que esta última define também o sinalizador ``FD_CLOEXEC``."

#: ../../library/fcntl.rst:55
msgid ""
"On Linux >= 4.5, the :mod:`fcntl` module exposes the ``FICLONE`` and "
"``FICLONERANGE`` constants, which allow to share some data of one file with "
"another file by reflinking on some filesystems (e.g., btrfs, OCFS2, and "
"XFS). This behavior is commonly referred to as \"copy-on-write\"."
msgstr ""
"No Linux >= 4.5, o módulo :mod:`fcntl` expõe as constantes ``FICLONE`` e "
"``FICLONERANGE``, que permitem compartilhar alguns dados de um arquivo com "
"outro arquivo por meio de reflinking em alguns sistemas de arquivos (por "
"exemplo, btrfs, OCFS2 e XFS). Esse comportamento é comumente chamado de "
"\"copy-on-write\"."

#: ../../library/fcntl.rst:61
msgid ""
"On Linux >= 2.6.32, the :mod:`!fcntl` module exposes the ``F_GETOWN_EX``, "
"``F_SETOWN_EX``, ``F_OWNER_TID``, ``F_OWNER_PID``, ``F_OWNER_PGRP`` "
"constants, which allow to direct I/O availability signals to a specific "
"thread, process, or process group. On Linux >= 4.13, the :mod:`!fcntl` "
"module exposes the ``F_GET_RW_HINT``, ``F_SET_RW_HINT``, "
"``F_GET_FILE_RW_HINT``, ``F_SET_FILE_RW_HINT``, and ``RWH_WRITE_LIFE_*`` "
"constants, which allow to inform the kernel about the relative expected "
"lifetime of writes on a given inode or via a particular open file "
"description. On Linux >= 5.1 and NetBSD, the :mod:`!fcntl` module exposes "
"the ``F_SEAL_FUTURE_WRITE`` constant for use with ``F_ADD_SEALS`` and "
"``F_GET_SEALS`` operations. On FreeBSD, the :mod:`!fcntl` module exposes the "
"``F_READAHEAD``, ``F_ISUNIONSTACK``, and ``F_KINFO`` constants. On macOS and "
"FreeBSD, the :mod:`!fcntl` module exposes the ``F_RDAHEAD`` constant. On "
"NetBSD and AIX, the :mod:`!fcntl` module exposes the ``F_CLOSEM`` constant. "
"On NetBSD, the :mod:`!fcntl` module exposes the ``F_MAXFD`` constant. On "
"macOS and NetBSD, the :mod:`!fcntl` module exposes the ``F_GETNOSIGPIPE`` "
"and ``F_SETNOSIGPIPE`` constant."
msgstr ""
"No Linux >= 2.6.32, o módulo :mod:`!fcntl` expõe as constantes "
"``F_GETOWN_EX``, ``F_SETOWN_EX``, ``F_OWNER_TID``, ``F_OWNER_PID``, "
"``F_OWNER_PGRP``, que permitem direcionar sinais de disponibilidade de E/S "
"para uma thread, processo ou grupo de processos específico. No Linux >= "
"4.13, o módulo :mod:`!fcntl` expõe as constantes ``F_GET_RW_HINT``, "
"``F_SET_RW_HINT``, ``F_GET_FILE_RW_HINT``, ``F_SET_FILE_RW_HINT`` e "
"``RWH_WRITE_LIFE_*``, que permitem informar o kernel sobre o tempo de vida "
"relativo esperado de gravações em um determinado nó-i ou por meio de uma "
"descrição de arquivo aberto específica. No Linux >= 5.1 e NetBSD, o "
"módulo :mod:`!fcntl` expõe a constante ``F_SEAL_FUTURE_WRITE`` para uso com "
"as operações ``F_ADD_SEALS`` e ``F_GET_SEALS``. No FreeBSD, o módulo :mod:`!"
"fcntl` expõe as constantes ``F_READAHEAD``, ``F_ISUNIONSTACK`` e "
"``F_KINFO``. No macOS e FreeBSD, o módulo :mod:`!fcntl` expõe a constante "
"``F_RDAHEAD``. No NetBSD e AIX, o módulo :mod:`!fcntl` expõe a constante "
"``F_CLOSEM``. No NetBSD, o módulo :mod:`!fcntl` expõe a constante "
"``F_MAXFD``. No macOS e no NetBSD, o módulo :mod:`!fcntl` expõe as "
"constantes ``F_GETNOSIGPIPE`` e ``F_SETNOSIGPIPE``."

#: ../../library/fcntl.rst:82
msgid "The module defines the following functions:"
msgstr "O módulo define as seguintes funções:"

#: ../../library/fcntl.rst:87
msgid ""
"Perform the operation *cmd* on file descriptor *fd* (file objects providing "
"a :meth:`~io.IOBase.fileno` method are accepted as well).  The values used "
"for *cmd* are operating system dependent, and are available as constants in "
"the :mod:`fcntl` module, using the same names as used in the relevant C "
"header files. The argument *arg* can either be an integer value, "
"a :class:`bytes` object, or a string. The type and size of *arg* must match "
"the type and size of the argument of the operation as specified in the "
"relevant C documentation."
msgstr ""
"Executa a operação *cmd* no descritor de arquivo *fd* (objetos arquivo que "
"fornecem um método :meth:`~io.IOBase.fileno` também são aceitos). Os valores "
"usados ​​para *cmd* dependem do sistema operacional e estão disponíveis como "
"constantes no módulo :mod:`fcntl`, usando os mesmos nomes usados ​​nos "
"arquivos de cabeçalho C relevantes. O argumento *arg* pode ser um valor "
"inteiro, um objeto :class:`bytes` ou uma string. O tipo e o tamanho de *arg* "
"devem corresponder ao tipo e ao tamanho do argumento da operação, conforme "
"especificado na documentação C relevante."

#: ../../library/fcntl.rst:96
msgid ""
"When *arg* is an integer, the function returns the integer return value of "
"the C :c:func:`fcntl` call."
msgstr ""
"Quando *arg* é um inteiro, a função retorna o valor de retorno inteiro da "
"chamada C :c:func:`fcntl`."

#: ../../library/fcntl.rst:99
msgid ""
"When the argument is bytes, it represents a binary structure, for example, "
"created by :func:`struct.pack`. A string value is encoded to binary using "
"the UTF-8 encoding. The binary data is copied to a buffer whose address is "
"passed to the C :c:func:`fcntl` call.  The return value after a successful "
"call is the contents of the buffer, converted to a :class:`bytes` object. "
"The length of the returned object will be the same as the length of the "
"*arg* argument. This is limited to 1024 bytes."
msgstr ""
"Quando o argumento é bytes, ele representa uma estrutura binária, por "
"exemplo, criada por :func:`struct.pack`. Um valor de string é codificado em "
"binário usando a codificação UTF-8. Os dados binários são copiados para um "
"buffer cujo endereço é passado para a chamada :c:func:`fcntl` em C. O valor "
"de retorno após uma chamada bem-sucedida é o conteúdo do buffer, convertido "
"em um objeto :class:`bytes`. O comprimento do objeto retornado será igual ao "
"comprimento do argumento *arg*. Este é limitado a 1024 bytes."

#: ../../library/fcntl.rst:108
msgid "If the :c:func:`fcntl` call fails, an :exc:`OSError` is raised."
msgstr ""
"Se a chamada a :c:func:`fcntl` falhar, um exceção :exc:`OSError` é levantada."

#: ../../library/fcntl.rst:111
msgid ""
"If the type or the size of *arg* does not match the type or size of the "
"argument of the operation (for example, if an integer is passed when a "
"pointer is expected, or the information returned in the buffer by the "
"operating system is larger than 1024 bytes), this is most likely to result "
"in a segmentation violation or a more subtle data corruption."
msgstr ""
"Se o tipo ou o tamanho de *arg* não corresponder ao tipo ou tamanho do "
"argumento da operação (por exemplo, se um inteiro for passado quando um "
"ponteiro for esperado, ou se as informações retornadas no buffer pelo "
"sistema operacional forem maiores que 1024 bytes), é mais provável que isso "
"resulte em uma violação de segmentação ou em uma corrupção de dados mais "
"sutil."

#: ../../library/fcntl.rst:118
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.fcntl`` with arguments "
"``fd``, ``cmd``, ``arg``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``fcntl.fcntl`` com os "
"argumentos ``fd``, ``cmd``, ``arg``."

#: ../../library/fcntl.rst:123
msgid ""
"This function is identical to the :func:`~fcntl.fcntl` function, except that "
"the argument handling is even more complicated."
msgstr ""
"Esta função é idêntica à função :func:`~fcntl.fcntl`, exceto que o "
"tratamento de argumentos é ainda mais complicado."

#: ../../library/fcntl.rst:126
msgid ""
"The *request* parameter is limited to values that can fit in 32-bits or 64-"
"bits, depending on the platform. Additional constants of interest for use as "
"the *request* argument can be found in the :mod:`termios` module, under the "
"same names as used in the relevant C header files."
msgstr ""
"O parâmetro *request* é limitado a valores que cabem em 32 ou 64 bits, "
"dependendo da plataforma. Constantes adicionais de interesse para uso como "
"argumento *request* podem ser encontradas no módulo :mod:`termios`, com os "
"mesmos nomes usados ​​nos arquivos de cabeçalho C relevantes."

#: ../../library/fcntl.rst:132
msgid ""
"The parameter *arg* can be an integer, a :term:`bytes-like object`, or a "
"string. The type and size of *arg* must match the type and size of the "
"argument of the operation as specified in the relevant C documentation."
msgstr ""
"O parâmetro *arg* pode ser um inteiro, um :term:`objeto byte ou similar` ou "
"uma string. O tipo e o tamanho de *arg* devem corresponder ao tipo e ao "
"tamanho do argumento da operação, conforme especificado na documentação C "
"relevante."

#: ../../library/fcntl.rst:137
msgid ""
"If *arg* does not support the read-write buffer interface or the "
"*mutate_flag* is false, behavior is as for the :func:`~fcntl.fcntl` function."
msgstr ""
"Se *arg* não oferecer suporte à interface de buffer de leitura e escrita ou "
"o *mutate_flag* for falso, o comportamento será o mesmo da "
"função :func:`~fcntl.fcntl`."

#: ../../library/fcntl.rst:141
msgid ""
"If *arg* supports the read-write buffer interface (like :class:`bytearray`) "
"and *mutate_flag* is true (the default), then the buffer is (in effect) "
"passed to the underlying :c:func:`!ioctl` system call, the latter's return "
"code is passed back to the calling Python, and the buffer's new contents "
"reflect the action of the :c:func:`ioctl`.  This is a slight simplification, "
"because if the supplied buffer is less than 1024 bytes long it is first "
"copied into a static buffer 1024 bytes long which is then passed "
"to :func:`ioctl` and copied back into the supplied buffer."
msgstr ""
"Se *arg* oferece suporte à interface de buffer de leitura e escrita "
"(como :class:`bytearray`) e *mutate_flag* for true (o padrão), o buffer será "
"(na prática) passado para a chamada de sistema subjacente :c:func:`!ioctl`, "
"o código de retorno desta última será passado de volta para o Python que fez "
"a chamada, e o novo conteúdo do buffer refletirá a ação de :c:func:`ioctl`. "
"Esta é uma pequena simplificação, pois se o buffer fornecido tiver menos de "
"1024 bytes, ele será primeiro copiado para um buffer estático de 1024 bytes, "
"que será então passado para :func:`ioctl` e copiado de volta para o buffer "
"fornecido."

#: ../../library/fcntl.rst:150
msgid ""
"If the :c:func:`ioctl` call fails, an :exc:`OSError` exception is raised."
msgstr ""
"Se a chamada a :c:func:`ioctl` falhar, uma exceção :exc:`OSError` é "
"levantada."

#: ../../library/fcntl.rst:153
msgid ""
"If the type or size of *arg* does not match the type or size of the "
"operation's argument (for example, if an integer is passed when a pointer is "
"expected, or the information returned in the buffer by the operating system "
"is larger than 1024 bytes, or the size of the mutable bytes-like object is "
"too small), this is most likely to result in a segmentation violation or a "
"more subtle data corruption."
msgstr ""
"Se o tipo ou o tamanho de *arg* não corresponder ao tipo ou tamanho do "
"argumento da operação (por exemplo, se um inteiro for passado quando um "
"ponteiro for esperado, ou se as informações retornadas no buffer pelo "
"sistema operacional forem maiores que 1024 bytes ou o tamanho do objeto byte "
"ou similar mutável é pequeno demais), é mais provável que isso resulte em "
"uma violação de segmentação ou em uma corrupção de dados mais sutil."

#: ../../library/fcntl.rst:161
msgid "An example::"
msgstr "Um exemplo::"

#: ../../library/fcntl.rst:163
msgid ""
">>> import array, fcntl, struct, termios, os\n"
">>> os.getpgrp()\n"
"13341\n"
">>> struct.unpack('h', fcntl.ioctl(0, termios.TIOCGPGRP, \"  \"))[0]\n"
"13341\n"
">>> buf = array.array('h', [0])\n"
">>> fcntl.ioctl(0, termios.TIOCGPGRP, buf, 1)\n"
"0\n"
">>> buf\n"
"array('h', [13341])"
msgstr ""
">>> import array, fcntl, struct, termios, os\n"
">>> os.getpgrp()\n"
"13341\n"
">>> struct.unpack('h', fcntl.ioctl(0, termios.TIOCGPGRP, \"  \"))[0]\n"
"13341\n"
">>> buf = array.array('h', [0])\n"
">>> fcntl.ioctl(0, termios.TIOCGPGRP, buf, 1)\n"
"0\n"
">>> buf\n"
"array('h', [13341])"

#: ../../library/fcntl.rst:174
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.ioctl`` with arguments "
"``fd``, ``request``, ``arg``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``fcntl.ioctl`` com os "
"argumentos ``fd``, ``request``, ``arg``."

#: ../../library/fcntl.rst:179
msgid ""
"Perform the lock operation *operation* on file descriptor *fd* (file objects "
"providing a :meth:`~io.IOBase.fileno` method are accepted as well). See the "
"Unix manual :manpage:`flock(2)` for details.  (On some systems, this "
"function is emulated using :c:func:`fcntl`.)"
msgstr ""
"Executa a operação de trava *operation* no descritor de arquivo *fd* "
"(objetos arquivo que fornecem um método :meth:`~io.IOBase.fileno` também são "
"aceitos). Consulte o manual do Unix :manpage:`flock(2)` para obter detalhes. "
"(Em alguns sistemas, esta função é emulada usando :c:func:`fcntl`.)"

#: ../../library/fcntl.rst:184
msgid ""
"If the :c:func:`flock` call fails, an :exc:`OSError` exception is raised."
msgstr ""
"Se a chamada :c:func:`flock` falhar, uma exceção :exc:`OSError` será "
"levantada."

#: ../../library/fcntl.rst:186
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.flock`` with arguments "
"``fd``, ``operation``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``fcntl.flock`` com os "
"argumentos ``fd`` e ``operation``."

#: ../../library/fcntl.rst:191
msgid ""
"This is essentially a wrapper around the :func:`~fcntl.fcntl` locking calls. "
"*fd* is the file descriptor (file objects providing "
"a :meth:`~io.IOBase.fileno` method are accepted as well) of the file to lock "
"or unlock, and *cmd* is one of the following values:"
msgstr ""
"Este é essencialmente um invólucro em torno das chamadas de "
"trava :func:`~fcntl.fcntl`. *fd* é o descritor de arquivo (objetos arquivo "
"que fornecem um método :meth:`~io.IOBase.fileno` também são aceitos) do "
"arquivo para travar ou destravar, e *cmd* é um dos seguintes valores:"

#: ../../library/fcntl.rst:198
msgid "Release an existing lock."
msgstr "Libera uma trava existente."

#: ../../library/fcntl.rst:202
msgid "Acquire a shared lock."
msgstr "Adquire uma trava compartilhada."

#: ../../library/fcntl.rst:206
msgid "Acquire an exclusive lock."
msgstr "Adquire uma trava exclusiva."

#: ../../library/fcntl.rst:210
msgid ""
"Bitwise OR with any of the other three ``LOCK_*`` constants to make the "
"request non-blocking."
msgstr ""
"Aplica OU (OR) bit a bit com qualquer uma das outras três constantes "
"``LOCK_*`` para tornar a solicitação não bloqueante."

#: ../../library/fcntl.rst:213
msgid ""
"If :const:`!LOCK_NB` is used and the lock cannot be acquired, "
"an :exc:`OSError` will be raised and the exception will have an *errno* "
"attribute set to :const:`~errno.EACCES` or :const:`~errno.EAGAIN` (depending "
"on the operating system; for portability, check for both values).  On at "
"least some systems, :const:`!LOCK_EX` can only be used if the file "
"descriptor refers to a file opened for writing."
msgstr ""
"Se :const:`!LOCK_NB` for usado e a trava não puder ser obtido, uma "
"exceção :exc:`OSError` será levantada e terá um atributo *errno* definido "
"como :const:`~errno.EACCES` ou :const:`~errno.EAGAIN` (dependendo do sistema "
"operacional; para portabilidade, verifique ambos os valores). Em pelo menos "
"alguns sistemas, :const:`!LOCK_EX` só pode ser usado se o descritor de "
"arquivo se referir a um arquivo aberto para escrita."

#: ../../library/fcntl.rst:220
msgid ""
"*len* is the number of bytes to lock, *start* is the byte offset at which "
"the lock starts, relative to *whence*, and *whence* is as "
"with :func:`io.IOBase.seek`, specifically:"
msgstr ""
"*len* é o número de bytes para travar, *start* é o deslocamento de bytes em "
"que a trava começa, em relação a *whence*, e *whence* é como "
"em :func:`io.IOBase.seek`, especificamente:"

#: ../../library/fcntl.rst:224
msgid "``0`` -- relative to the start of the file (:const:`os.SEEK_SET`)"
msgstr "``0`` -- relativo ao início do arquivo (:const:`os.SEEK_SET`)"

#: ../../library/fcntl.rst:225
msgid "``1`` -- relative to the current buffer position (:const:`os.SEEK_CUR`)"
msgstr "``1`` -- relativo à posição atual do buffer (:const:`os.SEEK_CUR`)"

#: ../../library/fcntl.rst:226
msgid "``2`` -- relative to the end of the file (:const:`os.SEEK_END`)"
msgstr "``2`` -- relativo ao fim do arquivo (:const:`os.SEEK_END`)"

#: ../../library/fcntl.rst:228
msgid ""
"The default for *start* is 0, which means to start at the beginning of the "
"file. The default for *len* is 0 which means to lock to the end of the "
"file.  The default for *whence* is also 0."
msgstr ""
"O padrão para *start* é 0, o que significa iniciar no início do arquivo. O "
"padrão para *len* é 0, o que significa travar no final do arquivo. O padrão "
"para *whence* também é 0."

#: ../../library/fcntl.rst:232
msgid ""
"Raises an :ref:`auditing event <auditing>` ``fcntl.lockf`` with arguments "
"``fd``, ``cmd``, ``len``, ``start``, ``whence``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``fcntl.lockf`` com os "
"argumentos ``fd``, ``cmd``, ``len``, ``start``, ``whence``."

#: ../../library/fcntl.rst:234
msgid "Examples (all on a SVR4 compliant system)::"
msgstr "Exemplos (todos em um sistema compatível com SVR4)::"

#: ../../library/fcntl.rst:236
msgid ""
"import struct, fcntl, os\n"
"\n"
"f = open(...)\n"
"rv = fcntl.fcntl(f, fcntl.F_SETFL, os.O_NDELAY)\n"
"\n"
"lockdata = struct.pack('hhllhh', fcntl.F_WRLCK, 0, 0, 0, 0, 0)\n"
"rv = fcntl.fcntl(f, fcntl.F_SETLKW, lockdata)"
msgstr ""
"import struct, fcntl, os\n"
"\n"
"f = open(...)\n"
"rv = fcntl.fcntl(f, fcntl.F_SETFL, os.O_NDELAY)\n"
"\n"
"lockdata = struct.pack('hhllhh', fcntl.F_WRLCK, 0, 0, 0, 0, 0)\n"
"rv = fcntl.fcntl(f, fcntl.F_SETLKW, lockdata)"

#: ../../library/fcntl.rst:244
msgid ""
"Note that in the first example the return value variable *rv* will hold an "
"integer value; in the second example it will hold a :class:`bytes` object.  "
"The structure lay-out for the *lockdata* variable is system dependent --- "
"therefore using the :func:`flock` call may be better."
msgstr ""
"Observe que, no primeiro exemplo, a variável de valor de retorno *rv* "
"conterá um valor inteiro; no segundo exemplo, ela conterá um "
"objeto :class:`bytes`. O layout da estrutura da variável *lockdata* depende "
"do sistema --- portanto, usar a chamada :func:`flock` pode ser melhor."

#: ../../library/fcntl.rst:252
msgid "Module :mod:`os`"
msgstr "Módulo :mod:`os`"

#: ../../library/fcntl.rst:253
msgid ""
"If the locking flags :const:`~os.O_SHLOCK` and :const:`~os.O_EXLOCK` are "
"present in the :mod:`os` module (on BSD only), the :func:`os.open` function "
"provides an alternative to the :func:`lockf` and :func:`flock` functions."
msgstr ""
"Se os sinalizadores de trava :const:`~os.O_SHLOCK` e :const:`~os.O_EXLOCK` "
"estiverem presentes no módulo :mod:`os` (somente no BSD), a "
"função :func:`os.open` fornece uma alternativa às funções :func:`lockf` "
"e :func:`flock`."

#: ../../library/fcntl.rst:10
msgid "UNIX"
msgstr "UNIX"

#: ../../library/fcntl.rst:10
msgid "file control"
msgstr "controle de arquivo"

#: ../../library/fcntl.rst:10
msgid "I/O control"
msgstr "controle de E/S"

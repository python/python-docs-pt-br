# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 17:51+0000\n"
"PO-Revision-Date: 2017-02-16 23:34+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/urllib.request.rst:2
msgid ":mod:`urllib.request` --- Extensible library for opening URLs"
msgstr ":mod:`urllib.request` --- Biblioteca extensível para abrir URLs"

#: ../../library/urllib.request.rst:11
msgid "**Source code:** :source:`Lib/urllib/request.py`"
msgstr "**Código-fonte:** :source:`Lib/urllib/request.py`"

#: ../../library/urllib.request.rst:15
msgid ""
"The :mod:`urllib.request` module defines functions and classes which help in "
"opening URLs (mostly HTTP) in a complex world --- basic and digest "
"authentication, redirections, cookies and more."
msgstr ""
"O módulo :mod:`urllib.request` define funções e classes que ajudam a abrir "
"URLs (principalmente HTTP) em um mundo complexo --- autenticação básica ou "
"por digest, redirecionamentos, cookies e muito mais."

#: ../../library/urllib.request.rst:21
msgid ""
"The `Requests package <https://requests.readthedocs.io/en/master/>`_ is "
"recommended for a higher-level HTTP client interface."
msgstr ""
"O `pacote Requests <https://requests.readthedocs.io/en/master/>`_ é "
"recomendado para uma interface alto nível de cliente HTTP."

#: ../../library/urllib.request.rst:25
msgid "The :mod:`urllib.request` module defines the following functions:"
msgstr "O módulo :mod:`urllib.request` define as seguintes funções:"

#: ../../library/urllib.request.rst:30
msgid ""
"Open the URL *url*, which can be either a string or a :class:`Request` "
"object."
msgstr ""
"Abre o URL *url*, que pode ser uma string ou um objeto :class:`Request`."

#: ../../library/urllib.request.rst:33
msgid ""
"*data* must be an object specifying additional data to be sent to the "
"server, or ``None`` if no such data is needed.  See :class:`Request` for "
"details."
msgstr ""
"*data* deve ser um objeto que especifique dados adicionais a serem enviados "
"ao servidor ou ``None``, se nenhum dado for necessário. Veja :class:"
"`Request` para detalhes."

#: ../../library/urllib.request.rst:37
msgid ""
"urllib.request module uses HTTP/1.1 and includes ``Connection:close`` header "
"in its HTTP requests."
msgstr ""
"O módulo urllib.request usa HTTP/1.1 e inclui o cabeçalho ``Connection:"
"close`` em suas solicitações HTTP."

#: ../../library/urllib.request.rst:40
msgid ""
"The optional *timeout* parameter specifies a timeout in seconds for blocking "
"operations like the connection attempt (if not specified, the global default "
"timeout setting will be used).  This actually only works for HTTP, HTTPS and "
"FTP connections."
msgstr ""
"O parâmetro opcional *timeout* especifica um tempo limite em segundos para "
"bloquear operações como a tentativa de conexão (se não for especificado, a "
"configuração de tempo limite padrão global será usada). Na verdade, isso só "
"funciona para conexões HTTP, HTTPS e FTP."

#: ../../library/urllib.request.rst:45
msgid ""
"If *context* is specified, it must be a :class:`ssl.SSLContext` instance "
"describing the various SSL options. See :class:`~http.client."
"HTTPSConnection` for more details."
msgstr ""
"Se *context* for especificado, deve ser uma instância de :class:`ssl."
"SSLContext` descrevendo as várias opções SSL. Veja  :class:`~http.client."
"HTTPSConnection` para mais detalhes."

#: ../../library/urllib.request.rst:49
msgid ""
"The optional *cafile* and *capath* parameters specify a set of trusted CA "
"certificates for HTTPS requests.  *cafile* should point to a single file "
"containing a bundle of CA certificates, whereas *capath* should point to a "
"directory of hashed certificate files.  More information can be found in :"
"meth:`ssl.SSLContext.load_verify_locations`."
msgstr ""
"Os parâmetros opcionais *cafile* e *capath* especificam um conjunto de "
"certificados de AC confiáveis para solicitações HTTPS. *cafile* deve apontar "
"para um único arquivo contendo um pacote de certificados de AC, enquanto "
"*capath* deve apontar para um diretório de arquivos de certificado em hash. "
"Mais informações podem ser encontradas em :meth:`ssl.SSLContext."
"load_verify_locations`."

#: ../../library/urllib.request.rst:55
msgid "The *cadefault* parameter is ignored."
msgstr "O parâmetro *cadefault* é ignorado."

#: ../../library/urllib.request.rst:57
msgid ""
"This function always returns an object which can work as a :term:`context "
"manager` and has the properties *url*, *headers*, and *status*. See :class:"
"`urllib.response.addinfourl` for more detail on these properties."
msgstr ""
"Esta função sempre retorna um objeto que pode funcionar como um :term:"
"`gerenciador de contexto` e tem as propriedades *url*, *headers* e *status*. "
"Veja :class:`urllib.response.addinfourl` para mais detalhes sobre essas "
"propriedades."

#: ../../library/urllib.request.rst:61
msgid ""
"For HTTP and HTTPS URLs, this function returns a :class:`http.client."
"HTTPResponse` object slightly modified. In addition to the three new methods "
"above, the msg attribute contains the same information as the :attr:`~http."
"client.HTTPResponse.reason` attribute --- the reason phrase returned by "
"server --- instead of the response headers as it is specified in the "
"documentation for :class:`~http.client.HTTPResponse`."
msgstr ""
"Para URLs HTTP e HTTPS, esta função retorna um objeto :class:`http.client."
"HTTPResponse` ligeiramente modificado. Além dos três novos métodos acima, o "
"atributo msg contém as mesmas informações que o atributo :attr:`~http.client."
"HTTPResponse.reason` --- a frase de razão retornada pelo servidor --- em vez "
"dos cabeçalhos de resposta como é especificado na documentação para :class:"
"`~http.client.HTTPResponse`."

#: ../../library/urllib.request.rst:69
msgid ""
"For FTP, file, and data URLs and requests explicitly handled by legacy :"
"class:`URLopener` and :class:`FancyURLopener` classes, this function returns "
"a :class:`urllib.response.addinfourl` object."
msgstr ""
"Para FTP, arquivo e URLs de dados e solicitações explicitamente tratadas "
"pelas classes legadas :class:`URLopener` e :class:`FancyURLopener`, esta "
"função retorna um objeto :class:`urllib.response.addinfourl`."

#: ../../library/urllib.request.rst:73
msgid "Raises :exc:`~urllib.error.URLError` on protocol errors."
msgstr ""
"Levanta :exc:`~urllib.error.URLError` quando ocorrer erros de protocolo."

#: ../../library/urllib.request.rst:75
msgid ""
"Note that ``None`` may be returned if no handler handles the request (though "
"the default installed global :class:`OpenerDirector` uses :class:"
"`UnknownHandler` to ensure this never happens)."
msgstr ""
"Observe que ``None`` pode ser retornado se nenhum manipulador lidar com a "
"solicitação (embora a :class:`OpenerDirector` global instalada padrão use :"
"class:`UnknownHandler` para garantir que isso nunca aconteça)."

#: ../../library/urllib.request.rst:79
msgid ""
"In addition, if proxy settings are detected (for example, when a ``*_proxy`` "
"environment variable like :envvar:`http_proxy` is set), :class:"
"`ProxyHandler` is default installed and makes sure the requests are handled "
"through the proxy."
msgstr ""
"Além disso, se as configurações de proxy forem detectadas (por exemplo, "
"quando uma variável de ambiente ``*_proxy`` como :envvar:`http_proxy` é "
"definida), :class:`ProxyHandler` é instalado por padrão e garante que as "
"solicitações sejam tratadas por meio o proxy."

#: ../../library/urllib.request.rst:84
msgid ""
"The legacy ``urllib.urlopen`` function from Python 2.6 and earlier has been "
"discontinued; :func:`urllib.request.urlopen` corresponds to the old "
"``urllib2.urlopen``.  Proxy handling, which was done by passing a dictionary "
"parameter to ``urllib.urlopen``, can be obtained by using :class:"
"`ProxyHandler` objects."
msgstr ""
"A função legada ``urllib.urlopen`` do Python 2.6 e anteriores foi "
"descontinuada; :func:`urllib.request.urlopen` corresponde à antiga ``urllib2."
"urlopen``. O tratamento de proxy, que foi feito passando um parâmetro de "
"dicionário para ``urllib.urlopen``, pode ser obtido usando objetos :class:"
"`ProxyHandler`."

#: ../../library/urllib.request.rst:90
msgid ""
"Raises an :ref:`auditing event <auditing>` ``urllib.Request`` with arguments "
"``fullurl``, ``data``, ``headers``, ``method``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``urllib.Request`` com "
"argumentos ``fullurl``, ``data``, ``headers``, ``method``."

#: ../../library/urllib.request.rst:92
msgid ""
"The default opener raises an :ref:`auditing event <auditing>` ``urllib."
"Request`` with arguments ``fullurl``, ``data``, ``headers``, ``method`` "
"taken from the request object."
msgstr ""
"O abridor padrão levanta um :ref:`evento de auditoria<auditing>` ``urllib."
"Request`` com os argumentos ``fullurl``, ``data``, ``headers``, ``method`` "
"obtidos do objeto de requisição."

#: ../../library/urllib.request.rst:96
msgid "*cafile* and *capath* were added."
msgstr "*cafile* e *capath* foram adicionados."

#: ../../library/urllib.request.rst:99
msgid ""
"HTTPS virtual hosts are now supported if possible (that is, if :data:`ssl."
"HAS_SNI` is true)."
msgstr ""
"Hosts virtuais HTTPS agora são suportados, se possível (ou seja, se :data:"
"`ssl.HAS_SNI` for verdadeiro)."

#: ../../library/urllib.request.rst:103
msgid "*data* can be an iterable object."
msgstr "*data* pode ser um objeto iterável."

#: ../../library/urllib.request.rst:106
msgid "*cadefault* was added."
msgstr "*cadefault* foi adicionado."

#: ../../library/urllib.request.rst:109
msgid "*context* was added."
msgstr "*context* foi adicionado."

#: ../../library/urllib.request.rst:114
msgid ""
"*cafile*, *capath* and *cadefault* are deprecated in favor of *context*. "
"Please use :meth:`ssl.SSLContext.load_cert_chain` instead, or let :func:`ssl."
"create_default_context` select the system's trusted CA certificates for you."
msgstr ""
"*cafile*, *capath* e *cadefault* estão descontinuados em favor de *context*. "
"Por favor, em vez disso, utilize :meth:`ssl.SSLContext.load_cert_chain` ou "
"deixe :func:`ssl.create_default_context` selecionar os certificados AC "
"confiáveis do sistema para você."

#: ../../library/urllib.request.rst:122
msgid ""
"Install an :class:`OpenerDirector` instance as the default global opener. "
"Installing an opener is only necessary if you want urlopen to use that "
"opener; otherwise, simply call :meth:`OpenerDirector.open` instead of :func:"
"`~urllib.request.urlopen`.  The code does not check for a real :class:"
"`OpenerDirector`, and any class with the appropriate interface will work."
msgstr ""
"Встановіть екземпляр :class:`OpenerDirector` як глобальний засіб відкриття "
"за умовчанням. Встановлення відкривача необхідно, лише якщо ви хочете, щоб "
"urlopen використовував цей відкривач; інакше просто викликайте :meth:"
"`OpenerDirector.open` замість :func:`~urllib.request.urlopen`. Код не "
"перевіряє справжнього :class:`OpenerDirector`, і будь-який клас із "
"відповідним інтерфейсом працюватиме."

#: ../../library/urllib.request.rst:132
msgid ""
"Return an :class:`OpenerDirector` instance, which chains the handlers in the "
"order given. *handler*\\s can be either instances of :class:`BaseHandler`, "
"or subclasses of :class:`BaseHandler` (in which case it must be possible to "
"call the constructor without any parameters).  Instances of the following "
"classes will be in front of the *handler*\\s, unless the *handler*\\s "
"contain them, instances of them or subclasses of them: :class:`ProxyHandler` "
"(if proxy settings are detected), :class:`UnknownHandler`, :class:"
"`HTTPHandler`, :class:`HTTPDefaultErrorHandler`, :class:"
"`HTTPRedirectHandler`, :class:`FTPHandler`, :class:`FileHandler`, :class:"
"`HTTPErrorProcessor`."
msgstr ""
"Повертає екземпляр :class:`OpenerDirector`, який об’єднує обробники у "
"вказаному порядку. *handler*\\s можуть бути або екземплярами :class:"
"`BaseHandler`, або підкласами :class:`BaseHandler` (у цьому випадку повинна "
"бути можливість викликати конструктор без будь-яких параметрів). Екземпляри "
"наступних класів будуть перед *обробниками*\\s, якщо тільки *обробники*\\ не "
"містять їх, їх екземпляри або їхні підкласи: :class:`ProxyHandler` (якщо "
"виявлено налаштування проксі),  :class:`UnknownHandler`, :class:"
"`HTTPHandler`, :class:`HTTPDefaultErrorHandler`, :class:"
"`HTTPRedirectHandler`, :class:`FTPHandler`, :class:`FileHandler`, :class:"
"`HTTPErrorProcessor`."

#: ../../library/urllib.request.rst:142
msgid ""
"If the Python installation has SSL support (i.e., if the :mod:`ssl` module "
"can be imported), :class:`HTTPSHandler` will also be added."
msgstr ""
"Якщо встановлення Python підтримує SSL (тобто якщо модуль :mod:`ssl` можна "
"імпортувати), :class:`HTTPSHandler` також буде додано."

#: ../../library/urllib.request.rst:145
msgid ""
"A :class:`BaseHandler` subclass may also change its :attr:`handler_order` "
"attribute to modify its position in the handlers list."
msgstr ""
"Підклас :class:`BaseHandler` також може змінити свій атрибут :attr:"
"`handler_order`, щоб змінити його позицію в списку обробників."

#: ../../library/urllib.request.rst:151
msgid ""
"Convert the pathname *path* from the local syntax for a path to the form "
"used in the path component of a URL.  This does not produce a complete URL.  "
"The return value will already be quoted using the :func:`~urllib.parse."
"quote` function."
msgstr ""
"Перетворіть назву шляху *path* із локального синтаксису шляху на форму, яка "
"використовується в компоненті шляху URL-адреси. Це не створює повну URL-"
"адресу. Повернене значення вже буде взято в лапки за допомогою функції :func:"
"`~urllib.parse.quote`."

#: ../../library/urllib.request.rst:158
msgid ""
"Convert the path component *path* from a percent-encoded URL to the local "
"syntax for a path.  This does not accept a complete URL.  This function "
"uses :func:`~urllib.parse.unquote` to decode *path*."
msgstr ""
"Перетворіть компонент шляху *path* із URL-адреси у відсотковому кодуванні на "
"локальний синтаксис для шляху. Це не приймає повну URL-адресу. Ця функція "
"використовує :func:`~urllib.parse.unquote` для декодування *шляху*."

#: ../../library/urllib.request.rst:164
msgid ""
"This helper function returns a dictionary of scheme to proxy server URL "
"mappings. It scans the environment for variables named ``<scheme>_proxy``, "
"in a case insensitive approach, for all operating systems first, and when it "
"cannot find it, looks for proxy information from System Configuration for "
"macOS and Windows Systems Registry for Windows. If both lowercase and "
"uppercase environment variables exist (and disagree), lowercase is preferred."
msgstr ""
"Ця допоміжна функція повертає словник схеми зіставлення URL-адрес проксі-"
"сервера. Він сканує середовище на наявність змінних із назвою ``<scheme> "
"_proxy``, без урахування регістру, для всіх операційних систем спочатку, а "
"якщо не може їх знайти, шукає інформацію про проксі-сервер у системній "
"конфігурації для macOS і системному реєстрі Windows для Windows. Якщо "
"існують (і не узгоджуються) змінні середовища як у нижньому, так і у "
"верхньому регістрах, перевага віддається нижньому регістру."

#: ../../library/urllib.request.rst:174
msgid ""
"If the environment variable ``REQUEST_METHOD`` is set, which usually "
"indicates your script is running in a CGI environment, the environment "
"variable ``HTTP_PROXY`` (uppercase ``_PROXY``) will be ignored. This is "
"because that variable can be injected by a client using the \"Proxy:\" HTTP "
"header. If you need to use an HTTP proxy in a CGI environment, either use "
"``ProxyHandler`` explicitly, or make sure the variable name is in lowercase "
"(or at least the ``_proxy`` suffix)."
msgstr ""
"Якщо встановлено змінну середовища ``REQUEST_METHOD``, що зазвичай вказує на "
"те, що ваш сценарій працює в середовищі CGI, змінна середовища "
"``HTTP_PROXY`` (великий регістр ``_PROXY``) буде проігноровано. Це "
"пояснюється тим, що ця змінна може бути введена клієнтом за допомогою HTTP-"
"заголовка \"Proxy:\". Якщо вам потрібно використовувати HTTP-проксі в "
"середовищі CGI, або явно використовуйте ``ProxyHandler``, або переконайтеся, "
"що назва змінної написана малими літерами (або принаймні суфікс ``_proxy``)."

#: ../../library/urllib.request.rst:183
msgid "The following classes are provided:"
msgstr "As sequintes classes são disponibilizadas:"

#: ../../library/urllib.request.rst:187
msgid "This class is an abstraction of a URL request."
msgstr "Цей клас є абстракцією URL-запиту."

#: ../../library/urllib.request.rst:189
msgid "*url* should be a string containing a valid URL."
msgstr ""

#: ../../library/urllib.request.rst:191
msgid ""
"*data* must be an object specifying additional data to send to the server, "
"or ``None`` if no such data is needed.  Currently HTTP requests are the only "
"ones that use *data*.  The supported object types include bytes, file-like "
"objects, and iterables of bytes-like objects. If no ``Content-Length`` nor "
"``Transfer-Encoding`` header field has been provided, :class:`HTTPHandler` "
"will set these headers according to the type of *data*.  ``Content-Length`` "
"will be used to send bytes objects, while ``Transfer-Encoding: chunked`` as "
"specified in :rfc:`7230`, Section 3.3.1 will be used to send files and other "
"iterables."
msgstr ""
"*data* має бути об’єктом, який визначає додаткові дані для надсилання на "
"сервер, або ``None``, якщо такі дані не потрібні. Наразі запити HTTP є "
"єдиними, які використовують *data*. Підтримувані типи об’єктів включають "
"байти, файлоподібні об’єкти та ітерації байтоподібних об’єктів. Якщо поля "
"заголовка ``Content-Length`` або ``Transfer-Encoding`` не надано, :class:"
"`HTTPHandler` встановить ці заголовки відповідно до типу *data*. ``Content-"
"Length`` використовуватиметься для надсилання байтових об’єктів, тоді як "
"``Transfer-Encoding: chunked``, як зазначено в :rfc:`7230`, розділ 3.3.1, "
"використовуватиметься для надсилання файлів та інших ітерацій."

#: ../../library/urllib.request.rst:201
msgid ""
"For an HTTP POST request method, *data* should be a buffer in the standard :"
"mimetype:`application/x-www-form-urlencoded` format.  The :func:`urllib."
"parse.urlencode` function takes a mapping or sequence of 2-tuples and "
"returns an ASCII string in this format. It should be encoded to bytes before "
"being used as the *data* parameter."
msgstr ""
"Для методу запиту HTTP POST *data* має бути буфером у стандартному форматі :"
"mimetype:`application/x-www-form-urlencoded`. Функція :func:`urllib.parse."
"urlencode` приймає відображення або послідовність 2-кортежів і повертає "
"рядок ASCII у цьому форматі. Перш ніж використовувати як параметр *data*, "
"його слід закодувати в байти."

#: ../../library/urllib.request.rst:207
msgid ""
"*headers* should be a dictionary, and will be treated as if :meth:"
"`add_header` was called with each key and value as arguments. This is often "
"used to \"spoof\" the ``User-Agent`` header value, which is used by a "
"browser to identify itself -- some HTTP servers only allow requests coming "
"from common browsers as opposed to scripts. For example, Mozilla Firefox may "
"identify itself as ``\"Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 "
"Firefox/2.0.0.11\"``, while :mod:`urllib`'s default user agent string is "
"``\"Python-urllib/2.6\"`` (on Python 2.6). All header keys are sent in camel "
"case."
msgstr ""
"*headers* має бути словником і розглядатиметься так, ніби було викликано :"
"meth:`add_header` з кожним ключем і значенням як аргументами. Це часто "
"використовується для \"підробки\" значення заголовка ``User-Agent``, яке "
"використовується браузером для самоідентифікації - деякі HTTP-сервери "
"дозволяють лише запити, що надходять із звичайних браузерів, на відміну від "
"сценаріїв. Наприклад, Mozilla Firefox може ідентифікувати себе як "
"``\"Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11\"``, "
"тоді як рядок агента користувача за замовчуванням :mod:`urllib` є ``\"Python-"
"urllib/2.6\"`` (на Python 2.6). Усі ключі заголовка надсилаються у "
"верблюжому футлярі."

#: ../../library/urllib.request.rst:218
msgid ""
"An appropriate ``Content-Type`` header should be included if the *data* "
"argument is present.  If this header has not been provided and *data* is not "
"None, ``Content-Type: application/x-www-form-urlencoded`` will be added as a "
"default."
msgstr ""
"Відповідний заголовок ``Content-Type`` слід включити, якщо присутній "
"аргумент *data*. Якщо цей заголовок не було надано і *data* не є None, "
"``Content-Type: application/x-www-form-urlencoded`` буде додано за "
"умовчанням."

#: ../../library/urllib.request.rst:223
msgid ""
"The next two arguments are only of interest for correct handling of third-"
"party HTTP cookies:"
msgstr ""
"Наступні два аргументи цікаві лише для правильної обробки сторонніх файлів "
"cookie HTTP:"

#: ../../library/urllib.request.rst:226
msgid ""
"*origin_req_host* should be the request-host of the origin transaction, as "
"defined by :rfc:`2965`.  It defaults to ``http.cookiejar."
"request_host(self)``.  This is the host name or IP address of the original "
"request that was initiated by the user. For example, if the request is for "
"an image in an HTML document, this should be the request-host of the request "
"for the page containing the image."
msgstr ""
"*origin_req_host* має бути хостом запиту вихідної транзакції, як визначено :"
"rfc:`2965`. За замовчуванням ``http.cookiejar.request_host(self)``. Це ім’я "
"хоста або IP-адреса вихідного запиту, ініційованого користувачем. Наприклад, "
"якщо запит стосується зображення в документі HTML, це має бути хост запиту "
"для сторінки, що містить зображення."

#: ../../library/urllib.request.rst:234
msgid ""
"*unverifiable* should indicate whether the request is unverifiable, as "
"defined by :rfc:`2965`.  It defaults to ``False``.  An unverifiable request "
"is one whose URL the user did not have the option to approve.  For example, "
"if the request is for an image in an HTML document, and the user had no "
"option to approve the automatic fetching of the image, this should be true."
msgstr ""
"*unverifiable* має вказувати, чи є запит неперевіреним, як визначено :rfc:"
"`2965`. За замовчуванням має значення ``False``. Неперевірений запит — це "
"запит, URL-адресу якого користувач не мав можливості схвалити. Наприклад, "
"якщо запит стосується зображення в документі HTML, і користувач не мав "
"можливості підтвердити автоматичне отримання зображення, це має бути правдою."

#: ../../library/urllib.request.rst:241
msgid ""
"*method* should be a string that indicates the HTTP request method that will "
"be used (e.g. ``'HEAD'``).  If provided, its value is stored in the :attr:"
"`~Request.method` attribute and is used by :meth:`get_method()`. The default "
"is ``'GET'`` if *data* is ``None`` or ``'POST'`` otherwise. Subclasses may "
"indicate a different default method by setting the :attr:`~Request.method` "
"attribute in the class itself."
msgstr ""
"*method* має бути рядком, що вказує на метод запиту HTTP, який буде "
"використано (наприклад, ``'HEAD'``). Якщо вказано, його значення "
"зберігається в атрибуті :attr:`~Request.method` і використовується :meth:"
"`get_method()`. Типовим значенням є ``'GET'``, якщо *data* має значення "
"``None`` або ``'POST'`` інакше. Підкласи можуть вказувати інший метод за "
"замовчуванням, встановивши атрибут :attr:`~Request.method` у самому класі."

#: ../../library/urllib.request.rst:249
msgid ""
"The request will not work as expected if the data object is unable to "
"deliver its content more than once (e.g. a file or an iterable that can "
"produce the content only once) and the request is retried for HTTP redirects "
"or authentication.  The *data* is sent to the HTTP server right away after "
"the headers.  There is no support for a 100-continue expectation in the "
"library."
msgstr ""
"Запит не працюватиме належним чином, якщо об’єкт даних не зможе доставити "
"свій вміст більше одного разу (наприклад, файл або ітераційний елемент, який "
"може створити вміст лише один раз), і запит повторюється для перенаправлення "
"HTTP або автентифікації. *Дані* надсилаються на сервер HTTP одразу після "
"заголовків. У бібліотеці немає підтримки очікування 100 продовжень."

#: ../../library/urllib.request.rst:256
msgid ":attr:`Request.method` argument is added to the Request class."
msgstr " Аргумент  :attr:`Request.method` додається до класу Request."

#: ../../library/urllib.request.rst:259
msgid "Default :attr:`Request.method` may be indicated at the class level."
msgstr "Типовий :attr:`Request.method` може бути вказаний на рівні класу."

#: ../../library/urllib.request.rst:262
msgid ""
"Do not raise an error if the ``Content-Length`` has not been provided and "
"*data* is neither ``None`` nor a bytes object. Fall back to use chunked "
"transfer encoding instead."
msgstr ""
"Не створюйте повідомлення про помилку, якщо ``Content-Length`` не було "
"надано, а *data* не є ні ``None``, ні об'єктом bytes. Поверніться до "
"використання фрагментованого кодування передачі."

#: ../../library/urllib.request.rst:269
msgid ""
"The :class:`OpenerDirector` class opens URLs via :class:`BaseHandler`\\ s "
"chained together. It manages the chaining of handlers, and recovery from "
"errors."
msgstr ""
"Клас :class:`OpenerDirector` відкриває URL-адреси через :class:"
"`BaseHandler`\\ об’єднані разом. Він керує ланцюжком обробників і "
"відновленням після помилок."

#: ../../library/urllib.request.rst:275
msgid ""
"This is the base class for all registered handlers --- and handles only the "
"simple mechanics of registration."
msgstr ""
"Це базовий клас для всіх зареєстрованих обробників --- і обробляє лише "
"просту механіку реєстрації."

#: ../../library/urllib.request.rst:281
msgid ""
"A class which defines a default handler for HTTP error responses; all "
"responses are turned into :exc:`~urllib.error.HTTPError` exceptions."
msgstr ""
"Клас, який визначає обробник за замовчуванням для відповідей на помилки "
"HTTP; усі відповіді перетворюються на винятки :exc:`~urllib.error.HTTPError`."

#: ../../library/urllib.request.rst:287
msgid "A class to handle redirections."
msgstr "Uma classe para lidar com redirecionamentos."

#: ../../library/urllib.request.rst:292
msgid "A class to handle HTTP Cookies."
msgstr "Classe para lidar com Cookies HTTP."

#: ../../library/urllib.request.rst:297
msgid ""
"Cause requests to go through a proxy. If *proxies* is given, it must be a "
"dictionary mapping protocol names to URLs of proxies. The default is to read "
"the list of proxies from the environment variables ``<protocol>_proxy``.  If "
"no proxy environment variables are set, then in a Windows environment proxy "
"settings are obtained from the registry's Internet Settings section, and in "
"a macOS environment proxy information is retrieved from the System "
"Configuration Framework."
msgstr ""
"Змусити запити проходити через проксі. Якщо вказано *проксі*, це має бути "
"словник, який зіставляє назви протоколів з URL-адресами проксі. За "
"замовчуванням список проксі-серверів читається зі змінних середовища "
"``<protocol> _proxy``. Якщо не встановлено жодних змінних середовища проксі, "
"у середовищі Windows параметри проксі-сервера отримуються з розділу "
"параметрів Інтернету реєстру, а в середовищі macOS інформація проксі-сервера "
"отримується з System Configuration Framework."

#: ../../library/urllib.request.rst:305
msgid "To disable autodetected proxy pass an empty dictionary."
msgstr ""
"Щоб вимкнути автоматичне визначення проксі, передайте порожній словник."

#: ../../library/urllib.request.rst:307
msgid ""
"The :envvar:`no_proxy` environment variable can be used to specify hosts "
"which shouldn't be reached via proxy; if set, it should be a comma-separated "
"list of hostname suffixes, optionally with ``:port`` appended, for example "
"``cern.ch,ncsa.uiuc.edu,some.host:8080``."
msgstr ""
"Змінну середовища :envvar:`no_proxy` можна використовувати для визначення "
"хостів, до яких не можна звертатися через проксі; якщо встановлено, це має "
"бути розділений комами список суфіксів імен хостів, необов’язково з "
"додаванням ``:port``, наприклад ``cern.ch,ncsa.uiuc.edu,some.host:8080``."

#: ../../library/urllib.request.rst:314
msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; see "
"the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"``HTTP_PROXY`` será ignorado se uma variável ``REQUEST_METHOD`` estiver "
"definida; veja a documentação em :func:`~urllib.request.getproxies`."

#: ../../library/urllib.request.rst:320
msgid "Keep a database of  ``(realm, uri) -> (user, password)`` mappings."
msgstr ""
"Зберігайте базу даних відповідностей ``(сфера, uri) -> (користувач, "
"пароль)``."

#: ../../library/urllib.request.rst:325
msgid ""
"Keep a database of  ``(realm, uri) -> (user, password)`` mappings. A realm "
"of ``None`` is considered a catch-all realm, which is searched if no other "
"realm fits."
msgstr ""
"Зберігайте базу даних відповідностей ``(сфера, uri) -> (користувач, "
"пароль)``. Сфера ``None`` вважається всеохоплюючою областю, у якій "
"виконується пошук, якщо жодна інша область не підходить."

#: ../../library/urllib.request.rst:332
msgid ""
"A variant of :class:`HTTPPasswordMgrWithDefaultRealm` that also has a "
"database of ``uri -> is_authenticated`` mappings.  Can be used by a "
"BasicAuth handler to determine when to send authentication credentials "
"immediately instead of waiting for a ``401`` response first."
msgstr ""
"Варіант :class:`HTTPPasswordMgrWithDefaultRealm`, який також має базу даних "
"зіставлень ``uri -> is_authenticated``. Може використовуватися обробником "
"BasicAuth, щоб визначити, коли надсилати облікові дані для автентифікації "
"негайно замість очікування відповіді ``401``."

#: ../../library/urllib.request.rst:342
msgid ""
"This is a mixin class that helps with HTTP authentication, both to the "
"remote host and to a proxy. *password_mgr*, if given, should be something "
"that is compatible with :class:`HTTPPasswordMgr`; refer to section :ref:"
"`http-password-mgr` for information on the interface that must be "
"supported.  If *passwd_mgr* also provides ``is_authenticated`` and "
"``update_authenticated`` methods (see :ref:`http-password-mgr-with-prior-"
"auth`), then the handler will use the ``is_authenticated`` result for a "
"given URI to determine whether or not to send authentication credentials "
"with the request.  If ``is_authenticated`` returns ``True`` for the URI, "
"credentials are sent.  If ``is_authenticated`` is ``False``, credentials are "
"not sent, and then if a ``401`` response is received the request is re-sent "
"with the authentication credentials.  If authentication succeeds, "
"``update_authenticated`` is called to set ``is_authenticated`` ``True`` for "
"the URI, so that subsequent requests to the URI or any of its super-URIs "
"will automatically include the authentication credentials."
msgstr ""
"Це клас mixin, який допомагає з автентифікацією HTTP як на віддаленому "
"хості, так і на проксі. *password_mgr*, якщо надано, має бути чимось "
"сумісним із :class:`HTTPPasswordMgr`; зверніться до розділу :ref:`http-"
"password-mgr` для отримання інформації про інтерфейс, який має "
"підтримуватися. Якщо *passwd_mgr* також надає методи ``is_authenticated`` і "
"``update_authenticated`` (див. :ref:`http-password-mgr-with-prior-auth`), "
"тоді обробник використовуватиме результат ``is_authenticated`` для заданого "
"URI, щоб визначити, чи надсилати облікові дані автентифікації разом із "
"запитом. Якщо ``is_authenticated`` повертає ``True`` для URI, облікові дані "
"надсилаються. Якщо ``is_authenticated`` має значення ``False``, облікові "
"дані не надсилаються, а потім, якщо отримано відповідь ``401``, запит "
"повторно надсилається з обліковими даними автентифікації. Якщо "
"автентифікація проходить успішно, ``update_authenticated`` викликається, щоб "
"встановити ``is_authenticated`` ``True`` для URI, щоб наступні запити до URI "
"або будь-якого з його супер-URI автоматично включали облікові дані "
"автентифікації."

#: ../../library/urllib.request.rst:359
msgid "Added ``is_authenticated`` support."
msgstr "Додано підтримку ``is_authenticated``."

#: ../../library/urllib.request.rst:365
msgid ""
"Handle authentication with the remote host. *password_mgr*, if given, should "
"be something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that must "
"be supported. HTTPBasicAuthHandler will raise a :exc:`ValueError` when "
"presented with a wrong Authentication scheme."
msgstr ""
"Керувати автентифікацією на віддаленому хості. *password_mgr*, якщо його "
"вказано, має бути сумісним із :class:`HTTPPasswordMgr`; зверніться до "
"розділу :ref:`http-password-mgr` для отримання інформації про інтерфейс, "
"який має підтримуватися. HTTPBasicAuthHandler викличе помилку :exc:"
"`ValueError`, якщо надано неправильну схему автентифікації."

#: ../../library/urllib.request.rst:374 ../../library/urllib.request.rst:408
msgid ""
"Handle authentication with the proxy. *password_mgr*, if given, should be "
"something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that must "
"be supported."
msgstr ""
"Керувати автентифікацією за допомогою проксі. *password_mgr*, якщо його "
"вказано, має бути сумісним із :class:`HTTPPasswordMgr`; зверніться до "
"розділу :ref:`http-password-mgr` для отримання інформації про інтерфейс, "
"який має підтримуватися."

#: ../../library/urllib.request.rst:382
msgid ""
"This is a mixin class that helps with HTTP authentication, both to the "
"remote host and to a proxy. *password_mgr*, if given, should be something "
"that is compatible with :class:`HTTPPasswordMgr`; refer to section :ref:"
"`http-password-mgr` for information on the interface that must be supported."
msgstr ""
"Це клас mixin, який допомагає з автентифікацією HTTP як на віддаленому "
"хості, так і на проксі. *password_mgr*, якщо його вказано, має бути сумісним "
"із :class:`HTTPPasswordMgr`; зверніться до розділу :ref:`http-password-mgr` "
"для отримання інформації про інтерфейс, який має підтримуватися."

#: ../../library/urllib.request.rst:391
msgid ""
"Handle authentication with the remote host. *password_mgr*, if given, should "
"be something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that must "
"be supported. When both Digest Authentication Handler and Basic "
"Authentication Handler are both added, Digest Authentication is always tried "
"first. If the Digest Authentication returns a 40x response again, it is sent "
"to Basic Authentication handler to Handle.  This Handler method will raise "
"a :exc:`ValueError` when presented with an authentication scheme other than "
"Digest or Basic."
msgstr ""
"Керувати автентифікацією на віддаленому хості. *password_mgr*, якщо його "
"вказано, має бути сумісним із :class:`HTTPPasswordMgr`; зверніться до "
"розділу :ref:`http-password-mgr` для отримання інформації про інтерфейс, "
"який має підтримуватися. Якщо додано як обробник дайджест-автентифікації, "
"так і обробник базової автентифікації, дайджест-автентифікація завжди "
"виконується першою. Якщо дайджест автентифікації знову повертає відповідь "
"40x, він надсилається обробнику базової автентифікації для обробки. Цей "
"метод обробника викличе :exc:`ValueError`, коли представлено схему "
"автентифікації, відмінну від Digest або Basic."

#: ../../library/urllib.request.rst:401
msgid "Raise :exc:`ValueError` on unsupported Authentication Scheme."
msgstr "Викликати :exc:`ValueError` на непідтримуваній схемі автентифікації."

#: ../../library/urllib.request.rst:416
msgid "A class to handle opening of HTTP URLs."
msgstr "Клас для обробки відкриття URL-адрес HTTP."

#: ../../library/urllib.request.rst:421
msgid ""
"A class to handle opening of HTTPS URLs.  *context* and *check_hostname* "
"have the same meaning as in :class:`http.client.HTTPSConnection`."
msgstr ""
"Клас для обробки URL-адрес HTTPS. *context* і *check_hostname* мають те саме "
"значення, що й у :class:`http.client.HTTPSConnection`."

#: ../../library/urllib.request.rst:424
msgid "*context* and *check_hostname* were added."
msgstr "*context* і *check_hostname* були додані."

#: ../../library/urllib.request.rst:430
msgid "Open local files."
msgstr "Abre arquivos locais."

#: ../../library/urllib.request.rst:434
msgid "Open data URLs."
msgstr "Abre dados das URLs."

#: ../../library/urllib.request.rst:440
msgid "Open FTP URLs."
msgstr "Abre URLs de FTP."

#: ../../library/urllib.request.rst:445
msgid ""
"Open FTP URLs, keeping a cache of open FTP connections to minimize delays."
msgstr ""
"Відкриті URL-адреси FTP, зберігаючи кеш відкритих з’єднань FTP, щоб "
"мінімізувати затримки."

#: ../../library/urllib.request.rst:450
msgid "A catch-all class to handle unknown URLs."
msgstr "Універсальний клас для обробки невідомих URL-адрес."

#: ../../library/urllib.request.rst:455 ../../library/urllib.request.rst:1151
msgid "Process HTTP error responses."
msgstr "Обробляти відповіді на помилки HTTP."

#: ../../library/urllib.request.rst:461
msgid "Request Objects"
msgstr "Objeto Request"

#: ../../library/urllib.request.rst:463
msgid ""
"The following methods describe :class:`Request`'s public interface, and so "
"all may be overridden in subclasses.  It also defines several public "
"attributes that can be used by clients to inspect the parsed request."
msgstr ""
"Наступні методи описують публічний інтерфейс :class:`Request`, тому всі вони "
"можуть бути перевизначені в підкласах. Він також визначає кілька публічних "
"атрибутів, які можуть використовуватися клієнтами для перевірки "
"аналізованого запиту."

#: ../../library/urllib.request.rst:470
msgid "The original URL passed to the constructor."
msgstr "Вихідна URL-адреса передається конструктору."

#: ../../library/urllib.request.rst:474
msgid ""
"Request.full_url is a property with setter, getter and a deleter. Getting :"
"attr:`~Request.full_url` returns the original request URL with the fragment, "
"if it was present."
msgstr ""
"Request.full_url — це властивість із установником, отримувачем і видаленням. "
"Отримання :attr:`~Request.full_url` повертає початкову URL-адресу запиту з "
"фрагментом, якщо він був присутній."

#: ../../library/urllib.request.rst:480
msgid "The URI scheme."
msgstr "Схема URI."

#: ../../library/urllib.request.rst:484
msgid ""
"The URI authority, typically a host, but may also contain a port separated "
"by a colon."
msgstr ""
"Повноваження URI, як правило, хост, але також може містити порт, розділений "
"двокрапкою."

#: ../../library/urllib.request.rst:489
msgid "The original host for the request, without port."
msgstr "Оригінальний хост для запиту, без порту."

#: ../../library/urllib.request.rst:493
msgid ""
"The URI path.  If the :class:`Request` uses a proxy, then selector will be "
"the full URL that is passed to the proxy."
msgstr ""
"Шлях URI. Якщо :class:`Request` використовує проксі, тоді селектором буде "
"повна URL-адреса, яка передається проксі."

#: ../../library/urllib.request.rst:498
msgid "The entity body for the request, or ``None`` if not specified."
msgstr "Тіло сутності для запиту або ``None``, якщо не вказано."

#: ../../library/urllib.request.rst:500
msgid ""
"Changing value of :attr:`Request.data` now deletes \"Content-Length\" header "
"if it was previously set or calculated."
msgstr ""
"Зміна значення :attr:`Request.data` тепер видаляє заголовок \"Content-"
"Length\", якщо він був раніше встановлений або обчислений."

#: ../../library/urllib.request.rst:506
msgid ""
"boolean, indicates whether the request is unverifiable as defined by :rfc:"
"`2965`."
msgstr ""
"логічне значення, вказує, чи запит не можна перевірити, як визначено :rfc:"
"`2965`."

#: ../../library/urllib.request.rst:511
msgid ""
"The HTTP request method to use.  By default its value is :const:`None`, "
"which means that :meth:`~Request.get_method` will do its normal computation "
"of the method to be used.  Its value can be set (thus overriding the default "
"computation in :meth:`~Request.get_method`) either by providing a default "
"value by setting it at the class level in a :class:`Request` subclass, or by "
"passing a value in to the :class:`Request` constructor via the *method* "
"argument."
msgstr ""
"Метод запиту HTTP для використання. За замовчуванням його значення :const:"
"`None`, що означає, що :meth:`~Request.get_method` виконає звичайне "
"обчислення методу, який буде використано. Його значення можна встановити "
"(таким чином замінюючи обчислення за замовчуванням у :meth:`~Request."
"get_method`) або шляхом надання значення за замовчуванням, установивши його "
"на рівні класу в підкласі :class:`Request`, або передавши значення у "
"конструктор :class:`Request` через аргумент *method*."

#: ../../library/urllib.request.rst:521
msgid ""
"A default value can now be set in subclasses; previously it could only be "
"set via the constructor argument."
msgstr ""
"Значення за замовчуванням тепер можна встановити в підкласах; раніше його "
"можна було встановити лише через аргумент конструктора."

#: ../../library/urllib.request.rst:528
msgid ""
"Return a string indicating the HTTP request method.  If :attr:`Request."
"method` is not ``None``, return its value, otherwise return ``'GET'`` if :"
"attr:`Request.data` is ``None``, or ``'POST'`` if it's not. This is only "
"meaningful for HTTP requests."
msgstr ""
"Повертає рядок із зазначенням методу запиту HTTP. Якщо :attr:`Request."
"method` не є ``None``, поверніть його значення, інакше поверніть ``'GET'``, "
"якщо :attr:`Request.data` має значення ``None`` або ``' POST''``, якщо це не "
"так. Це має значення лише для запитів HTTP."

#: ../../library/urllib.request.rst:533
msgid "get_method now looks at the value of :attr:`Request.method`."
msgstr "get_method тепер переглядає значення :attr:`Request.method`."

#: ../../library/urllib.request.rst:539
msgid ""
"Add another header to the request.  Headers are currently ignored by all "
"handlers except HTTP handlers, where they are added to the list of headers "
"sent to the server.  Note that there cannot be more than one header with the "
"same name, and later calls will overwrite previous calls in case the *key* "
"collides. Currently, this is no loss of HTTP functionality, since all "
"headers which have meaning when used more than once have a (header-specific) "
"way of gaining the same functionality using only one header.  Note that "
"headers added using this method are also added to redirected requests."
msgstr ""
"Додайте інший заголовок до запиту. Наразі заголовки ігноруються всіма "
"обробниками, крім обробників HTTP, де вони додаються до списку заголовків, "
"надісланих на сервер. Зауважте, що не може бути більше одного заголовка з "
"однаковим іменем, і пізніші виклики перезапишуть попередні виклики, якщо "
"*ключ* зіткнеться. Наразі це не втрачає функціональність HTTP, оскільки всі "
"заголовки, які мають значення при повторному використанні, мають "
"(специфічний для заголовка) спосіб отримати ту саму функціональність, "
"використовуючи лише один заголовок. Зауважте, що заголовки, додані за "
"допомогою цього методу, також додаються до перенаправлених запитів."

#: ../../library/urllib.request.rst:551
msgid "Add a header that will not be added to a redirected request."
msgstr "Додайте заголовок, який не буде додано до переспрямованого запиту."

#: ../../library/urllib.request.rst:556
msgid ""
"Return whether the instance has the named header (checks both regular and "
"unredirected)."
msgstr ""
"Повертає, чи має екземпляр названий заголовок (перевіряє як звичайний, так і "
"неперенаправлений)."

#: ../../library/urllib.request.rst:562
msgid ""
"Remove named header from the request instance (both from regular and "
"unredirected headers)."
msgstr ""
"Remove o cabeçalho nomeado da instância de solicitação (tanto de cabeçalhos "
"regulares como de cabeçalhos não-redirecionados)."

#: ../../library/urllib.request.rst:570
msgid "Return the URL given in the constructor."
msgstr "Повертає URL-адресу, указану в конструкторі."

#: ../../library/urllib.request.rst:574
msgid "Returns :attr:`Request.full_url`"
msgstr "Повертає :attr:`Request.full_url`"

#: ../../library/urllib.request.rst:579
msgid ""
"Prepare the request by connecting to a proxy server. The *host* and *type* "
"will replace those of the instance, and the instance's selector will be the "
"original URL given in the constructor."
msgstr ""
"Підготуйте запит, підключившись до проксі-сервера. *host* і *type* замінять "
"параметри екземпляра, а селектор екземпляра буде оригінальною URL-адресою, "
"заданою в конструкторі."

#: ../../library/urllib.request.rst:586
msgid ""
"Return the value of the given header. If the header is not present, return "
"the default value."
msgstr ""
"Повертає значення заданого заголовка. Якщо заголовок відсутній, поверніть "
"значення за замовчуванням."

#: ../../library/urllib.request.rst:592
msgid ""
"Return a list of tuples (header_name, header_value) of the Request headers."
msgstr ""
"Повертає список кортежів (header_name, header_value) заголовків запиту."

#: ../../library/urllib.request.rst:594
msgid ""
"The request methods add_data, has_data, get_data, get_type, get_host, "
"get_selector, get_origin_req_host and is_unverifiable that were deprecated "
"since 3.3 have been removed."
msgstr ""
"Методи запиту add_data, has_data, get_data, get_type, get_host, "
"get_selector, get_origin_req_host і is_unverifiable, які були застарілими з "
"3.3, були видалені."

#: ../../library/urllib.request.rst:603
msgid "OpenerDirector Objects"
msgstr "Об’єкти OpenerDirector"

#: ../../library/urllib.request.rst:605
msgid ":class:`OpenerDirector` instances have the following methods:"
msgstr "Екземпляри :class:`OpenerDirector` мають такі методи:"

#: ../../library/urllib.request.rst:610
msgid ""
"*handler* should be an instance of :class:`BaseHandler`.  The following "
"methods are searched, and added to the possible chains (note that HTTP "
"errors are a special case).  Note that, in the following, *protocol* should "
"be replaced with the actual protocol to handle, for example :meth:"
"`http_response` would be the HTTP protocol response handler.  Also *type* "
"should be replaced with the actual HTTP code, for example :meth:"
"`http_error_404` would handle HTTP 404 errors."
msgstr ""
"*handler* має бути екземпляром :class:`BaseHandler`. Наступні методи "
"шукаються та додаються до можливих ланцюжків (зверніть увагу, що помилки "
"HTTP є окремим випадком). Зауважте, що далі *протокол* слід замінити на "
"фактичний протокол для обробки, наприклад, :meth:`http_response` буде "
"обробником відповіді протоколу HTTP. Також *type* слід замінити фактичним "
"кодом HTTP, наприклад, :meth:`http_error_404` оброблятиме помилки HTTP 404."

#: ../../library/urllib.request.rst:618
msgid ""
":meth:`<protocol>_open` --- signal that the handler knows how to open "
"*protocol* URLs."
msgstr ""

#: ../../library/urllib.request.rst:621
msgid "See |protocol_open|_ for more information."
msgstr "Veja |protocol_open|_ para maiores informações."

#: ../../library/urllib.request.rst:623
msgid ""
":meth:`http_error_\\<type\\>` --- signal that the handler knows how to "
"handle HTTP errors with HTTP error code *type*."
msgstr ""

#: ../../library/urllib.request.rst:626
msgid "See |http_error_nnn|_ for more information."
msgstr "Veja |http_error_nnn|_ para maiores informações."

#: ../../library/urllib.request.rst:628
msgid ""
":meth:`<protocol>_error` --- signal that the handler knows how to handle "
"errors from (non-\\ ``http``) *protocol*."
msgstr ""

#: ../../library/urllib.request.rst:631
msgid ""
":meth:`<protocol>_request` --- signal that the handler knows how to pre-"
"process *protocol* requests."
msgstr ""

#: ../../library/urllib.request.rst:634
msgid "See |protocol_request|_ for more information."
msgstr "Veja |protocol_request|_ para maiores informações."

#: ../../library/urllib.request.rst:636
msgid ""
":meth:`<protocol>_response` --- signal that the handler knows how to post-"
"process *protocol* responses."
msgstr ""

#: ../../library/urllib.request.rst:639
msgid "See |protocol_response|_ for more information."
msgstr "Veja |protocol_response|_ para maiores informações."

#: ../../library/urllib.request.rst:648
msgid ""
"Open the given *url* (which can be a request object or a string), optionally "
"passing the given *data*. Arguments, return values and exceptions raised are "
"the same as those of :func:`urlopen` (which simply calls the :meth:`open` "
"method on the currently installed global :class:`OpenerDirector`).  The "
"optional *timeout* parameter specifies a timeout in seconds for blocking "
"operations like the connection attempt (if not specified, the global default "
"timeout setting will be used). The timeout feature actually works only for "
"HTTP, HTTPS and FTP connections."
msgstr ""
"Відкрийте вказаний *url* (який може бути об’єктом запиту або рядком), "
"необов’язково передаючи вказані *дані*. Аргументи, значення, що "
"повертаються, і викликані винятки такі самі, як у :func:`urlopen` (який "
"просто викликає метод :meth:`open` у поточному встановленому глобальному :"
"class:`OpenerDirector`). Необов’язковий параметр *timeout* визначає час "
"очікування в секундах для блокування таких операцій, як спроба підключення "
"(якщо не вказано, буде використано глобальне налаштування часу очікування за "
"умовчанням). Функція тайм-ауту фактично працює лише для з’єднань HTTP, HTTPS "
"і FTP."

#: ../../library/urllib.request.rst:660
msgid ""
"Handle an error of the given protocol.  This will call the registered error "
"handlers for the given protocol with the given arguments (which are protocol "
"specific).  The HTTP protocol is a special case which uses the HTTP response "
"code to determine the specific error handler; refer to the :meth:"
"`http_error_\\<type\\>` methods of the handler classes."
msgstr ""

#: ../../library/urllib.request.rst:666
msgid ""
"Return values and exceptions raised are the same as those of :func:`urlopen`."
msgstr ""
"Повернуті значення та викликані винятки такі самі, як і для :func:`urlopen`."

#: ../../library/urllib.request.rst:668
msgid "OpenerDirector objects open URLs in three stages:"
msgstr "Об’єкти OpenerDirector відкривають URL-адреси в три етапи:"

#: ../../library/urllib.request.rst:670
msgid ""
"The order in which these methods are called within each stage is determined "
"by sorting the handler instances."
msgstr ""
"Порядок, у якому ці методи викликаються на кожному етапі, визначається "
"сортуванням екземплярів обробника."

#: ../../library/urllib.request.rst:673
msgid ""
"Every handler with a method named like :meth:`<protocol>_request` has that "
"method called to pre-process the request."
msgstr ""

#: ../../library/urllib.request.rst:676
msgid ""
"Handlers with a method named like :meth:`<protocol>_open` are called to "
"handle the request. This stage ends when a handler either returns a non-\\ :"
"const:`None` value (ie. a response), or raises an exception (usually :exc:"
"`~urllib.error.URLError`).  Exceptions are allowed to propagate."
msgstr ""

#: ../../library/urllib.request.rst:681
msgid ""
"In fact, the above algorithm is first tried for methods named :meth:"
"`default_open`.  If all such methods return :const:`None`, the algorithm is "
"repeated for methods named like :meth:`<protocol>_open`.  If all such "
"methods return :const:`None`, the algorithm is repeated for methods named :"
"meth:`unknown_open`."
msgstr ""

#: ../../library/urllib.request.rst:687
msgid ""
"Note that the implementation of these methods may involve calls of the "
"parent :class:`OpenerDirector` instance's :meth:`~OpenerDirector.open` and :"
"meth:`~OpenerDirector.error` methods."
msgstr ""
"Зауважте, що реалізація цих методів може передбачати виклики методів :meth:"
"`~OpenerDirector.open` і :meth:`~OpenerDirector.error` примірника "
"батьківського :class:`OpenerDirector`."

#: ../../library/urllib.request.rst:691
msgid ""
"Every handler with a method named like :meth:`<protocol>_response` has that "
"method called to post-process the response."
msgstr ""

#: ../../library/urllib.request.rst:698
msgid "BaseHandler Objects"
msgstr "Об’єкти BaseHandler"

#: ../../library/urllib.request.rst:700
msgid ""
":class:`BaseHandler` objects provide a couple of methods that are directly "
"useful, and others that are meant to be used by derived classes.  These are "
"intended for direct use:"
msgstr ""
"Об’єкти :class:`BaseHandler` надають кілька методів, які є безпосередньо "
"корисними, а також інші, які призначені для використання похідними класами. "
"Вони призначені для безпосереднього використання:"

#: ../../library/urllib.request.rst:707
msgid "Add a director as parent."
msgstr "Додати директора як батька."

#: ../../library/urllib.request.rst:712
msgid "Remove any parents."
msgstr "Видаліть усіх батьків."

#: ../../library/urllib.request.rst:714
msgid ""
"The following attribute and methods should only be used by classes derived "
"from :class:`BaseHandler`."
msgstr ""
"Наступний атрибут і методи мають використовуватися лише класами, похідними "
"від :class:`BaseHandler`."

#: ../../library/urllib.request.rst:719
msgid ""
"The convention has been adopted that subclasses defining :meth:"
"`<protocol>_request` or :meth:`<protocol>_response` methods are named :class:"
"`\\*Processor`; all others are named :class:`\\*Handler`."
msgstr ""

#: ../../library/urllib.request.rst:726
msgid ""
"A valid :class:`OpenerDirector`, which can be used to open using a different "
"protocol, or handle errors."
msgstr ""
"Дійсний :class:`OpenerDirector`, який можна використовувати для відкриття за "
"допомогою іншого протоколу або обробки помилок."

#: ../../library/urllib.request.rst:732
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to catch all URLs."
msgstr ""
"Цей метод *не* визначено в :class:`BaseHandler`, але підкласи повинні "
"визначити його, якщо вони хочуть перехоплювати всі URL-адреси."

#: ../../library/urllib.request.rst:735
msgid ""
"This method, if implemented, will be called by the parent :class:"
"`OpenerDirector`.  It should return a file-like object as described in the "
"return value of the :meth:`~OpenerDirector.open` method of :class:"
"`OpenerDirector`, or ``None``. It should raise :exc:`~urllib.error."
"URLError`, unless a truly exceptional thing happens (for example, :exc:"
"`MemoryError` should not be mapped to :exc:`URLError`)."
msgstr ""

#: ../../library/urllib.request.rst:742
msgid "This method will be called before any protocol-specific open method."
msgstr "Цей метод буде викликано перед будь-яким відкритим методом протоколу."

#: ../../library/urllib.request.rst:749
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to handle URLs with the given protocol."
msgstr ""
"Цей метод *не* визначено в :class:`BaseHandler`, але підкласи повинні "
"визначити його, якщо вони хочуть обробляти URL-адреси за допомогою заданого "
"протоколу."

#: ../../library/urllib.request.rst:752
msgid ""
"This method, if defined, will be called by the parent :class:"
"`OpenerDirector`. Return values should be the same as for  :meth:"
"`default_open`."
msgstr ""

#: ../../library/urllib.request.rst:758
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to catch all URLs with no specific registered handler "
"to open it."
msgstr ""
"Цей метод *не* визначено в :class:`BaseHandler`, але підкласи повинні "
"визначити його, якщо вони хочуть перехопити всі URL-адреси без спеціального "
"зареєстрованого обробника для його відкриття."

#: ../../library/urllib.request.rst:762
msgid ""
"This method, if implemented, will be called by the :attr:`parent` :class:"
"`OpenerDirector`.  Return values should be the same as for :meth:"
"`default_open`."
msgstr ""
"Цей метод, якщо він реалізований, буде викликаний :attr:`parent` :class:"
"`OpenerDirector`. Повернуті значення мають бути такими ж, як і для :meth:"
"`default_open`."

#: ../../library/urllib.request.rst:769
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"override it if they intend to provide a catch-all for otherwise unhandled "
"HTTP errors.  It will be called automatically by the  :class:"
"`OpenerDirector` getting the error, and should not normally be called in "
"other circumstances."
msgstr ""
"Цей метод *не* визначено в :class:`BaseHandler`, але підкласи повинні "
"перевизначати його, якщо вони мають намір надати збірку для всіх "
"необроблених помилок HTTP. Він автоматично викликається :class:"
"`OpenerDirector`, який отримує помилку, і зазвичай не повинен викликатися за "
"інших обставин."

#: ../../library/urllib.request.rst:774
msgid ""
"*req* will be a :class:`Request` object, *fp* will be a file-like object "
"with the HTTP error body, *code* will be the three-digit code of the error, "
"*msg* will be the user-visible explanation of the code and *hdrs* will be a "
"mapping object with the headers of the error."
msgstr ""
"*req* буде об’єктом :class:`Request`, *fp* буде файлоподібним об’єктом із "
"тілом помилки HTTP, *code* буде тризначним кодом помилки, *msg* буде видиме "
"для користувача пояснення коду та *hdrs* буде об’єктом відображення із "
"заголовками помилки."

#: ../../library/urllib.request.rst:779
msgid ""
"Return values and exceptions raised should be the same as those of :func:"
"`urlopen`."
msgstr ""
"Повернуті значення та викликані винятки мають бути такими самими, як у :func:"
"`urlopen`."

#: ../../library/urllib.request.rst:786
msgid ""
"*nnn* should be a three-digit HTTP error code.  This method is also not "
"defined in :class:`BaseHandler`, but will be called, if it exists, on an "
"instance of a subclass, when an HTTP error with code *nnn* occurs."
msgstr ""
"*nnn* має бути тризначним кодом помилки HTTP. Цей метод також не визначено "
"в :class:`BaseHandler`, але буде викликаний, якщо він існує, на екземплярі "
"підкласу, коли виникає помилка HTTP з кодом *nnn*."

#: ../../library/urllib.request.rst:790
msgid "Subclasses should override this method to handle specific HTTP errors."
msgstr ""
"Підкласи повинні замінити цей метод для обробки конкретних помилок HTTP."

#: ../../library/urllib.request.rst:792
msgid ""
"Arguments, return values and exceptions raised should be the same as for :"
"meth:`http_error_default`."
msgstr ""

#: ../../library/urllib.request.rst:800
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to pre-process requests of the given protocol."
msgstr ""
"Цей метод *не* визначено в :class:`BaseHandler`, але підкласи повинні "
"визначити його, якщо вони хочуть попередньо обробляти запити даного "
"протоколу."

#: ../../library/urllib.request.rst:803
msgid ""
"This method, if defined, will be called by the parent :class:"
"`OpenerDirector`. *req* will be a :class:`Request` object. The return value "
"should be a :class:`Request` object."
msgstr ""
"Цей метод, якщо його визначено, буде викликано батьківським :class:"
"`OpenerDirector`. *req* буде об’єктом :class:`Request`. Поверненим значенням "
"має бути об’єкт :class:`Request`."

#: ../../library/urllib.request.rst:812
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to post-process responses of the given protocol."
msgstr ""
"Цей метод *не* визначено в :class:`BaseHandler`, але підкласи повинні "
"визначити його, якщо вони хочуть постобробити відповіді заданого протоколу."

#: ../../library/urllib.request.rst:815
msgid ""
"This method, if defined, will be called by the parent :class:"
"`OpenerDirector`. *req* will be a :class:`Request` object. *response* will "
"be an object implementing the same interface as the return value of :func:"
"`urlopen`.  The return value should implement the same interface as the "
"return value of :func:`urlopen`."
msgstr ""
"Цей метод, якщо його визначено, буде викликано батьківським :class:"
"`OpenerDirector`. *req* буде об’єктом :class:`Request`. *response* буде "
"об’єктом, який реалізує той самий інтерфейс, що й значення, що повертається :"
"func:`urlopen`. Значення, що повертається, має реалізовувати той самий "
"інтерфейс, що й значення, що повертається :func:`urlopen`."

#: ../../library/urllib.request.rst:825
msgid "HTTPRedirectHandler Objects"
msgstr "Об’єкти HTTPRedirectHandler"

#: ../../library/urllib.request.rst:829
msgid ""
"Some HTTP redirections require action from this module's client code.  If "
"this is the case, :exc:`~urllib.error.HTTPError` is raised.  See :rfc:`2616` "
"for details of the precise meanings of the various redirection codes."
msgstr ""
"Деякі перенаправлення HTTP вимагають дії від клієнтського коду цього модуля. "
"Якщо це так, виникає :exc:`~urllib.error.HTTPError`. Див. :rfc:`2616` для "
"детальної інформації про точні значення різних кодів перенаправлення."

#: ../../library/urllib.request.rst:833
msgid ""
"An :class:`HTTPError` exception raised as a security consideration if the "
"HTTPRedirectHandler is presented with a redirected URL which is not an HTTP, "
"HTTPS or FTP URL."
msgstr ""

#: ../../library/urllib.request.rst:840
msgid ""
"Return a :class:`Request` or ``None`` in response to a redirect. This is "
"called by the default implementations of the :meth:`http_error_30\\*` "
"methods when a redirection is received from the server.  If a redirection "
"should take place, return a new :class:`Request` to allow :meth:"
"`http_error_30\\*` to perform the redirect to *newurl*.  Otherwise, raise :"
"exc:`~urllib.error.HTTPError` if no other handler should try to handle this "
"URL, or return ``None`` if you can't but another handler might."
msgstr ""

#: ../../library/urllib.request.rst:850
msgid ""
"The default implementation of this method does not strictly follow :rfc:"
"`2616`, which says that 301 and 302 responses to ``POST`` requests must not "
"be automatically redirected without confirmation by the user.  In reality, "
"browsers do allow automatic redirection of these responses, changing the "
"POST to a ``GET``, and the default implementation reproduces this behavior."
msgstr ""
"Стандартна реалізація цього методу не відповідає суворо :rfc:`2616`, яка "
"говорить, що відповіді 301 і 302 на запити ``POST`` не повинні автоматично "
"перенаправлятися без підтвердження користувача. Насправді браузери "
"дозволяють автоматичне перенаправлення цих відповідей, змінюючи POST на "
"``GET``, і реалізація за замовчуванням відтворює цю поведінку."

#: ../../library/urllib.request.rst:859
msgid ""
"Redirect to the ``Location:`` or ``URI:`` URL.  This method is called by the "
"parent :class:`OpenerDirector` when getting an HTTP 'moved permanently' "
"response."
msgstr ""
"Переспрямування на URL-адресу ``Location:`` або ``URI:``. Цей метод "
"викликається батьківським :class:`OpenerDirector` під час отримання HTTP-"
"відповіді \"переміщено назавжди\"."

#: ../../library/urllib.request.rst:865
msgid ""
"The same as :meth:`http_error_301`, but called for the 'found' response."
msgstr ""
"Те саме, що :meth:`http_error_301`, але викликається відповідь 'знайдено'."

#: ../../library/urllib.request.rst:870
msgid ""
"The same as :meth:`http_error_301`, but called for the 'see other' response."
msgstr ""
"Те саме, що :meth:`http_error_301`, але викликається відповідь \"переглянути "
"інше\"."

#: ../../library/urllib.request.rst:875
msgid ""
"The same as :meth:`http_error_301`, but called for the 'temporary redirect' "
"response."
msgstr ""

#: ../../library/urllib.request.rst:882
msgid "HTTPCookieProcessor Objects"
msgstr "Об’єкти HTTPCookieProcessor"

#: ../../library/urllib.request.rst:884
msgid ":class:`HTTPCookieProcessor` instances have one attribute:"
msgstr "Екземпляри :class:`HTTPCookieProcessor` мають один атрибут:"

#: ../../library/urllib.request.rst:888
msgid "The :class:`http.cookiejar.CookieJar` in which cookies are stored."
msgstr ":class:`http.cookiejar.CookieJar`, у якому зберігаються файли cookie."

#: ../../library/urllib.request.rst:894
msgid "ProxyHandler Objects"
msgstr "Об’єкти ProxyHandler"

#: ../../library/urllib.request.rst:900
msgid ""
"The :class:`ProxyHandler` will have a method :meth:`<protocol>_open` for "
"every *protocol* which has a proxy in the *proxies* dictionary given in the "
"constructor.  The method will modify requests to go through the proxy, by "
"calling ``request.set_proxy()``, and call the next handler in the chain to "
"actually execute the protocol."
msgstr ""

#: ../../library/urllib.request.rst:910
msgid "HTTPPasswordMgr Objects"
msgstr "Об’єкти HTTPPasswordMgr"

#: ../../library/urllib.request.rst:912
msgid ""
"These methods are available on :class:`HTTPPasswordMgr` and :class:"
"`HTTPPasswordMgrWithDefaultRealm` objects."
msgstr ""
"Ці методи доступні в об’єктах :class:`HTTPPasswordMgr` і :class:"
"`HTTPPasswordMgrWithDefaultRealm`."

#: ../../library/urllib.request.rst:918
msgid ""
"*uri* can be either a single URI, or a sequence of URIs. *realm*, *user* and "
"*passwd* must be strings. This causes ``(user, passwd)`` to be used as "
"authentication tokens when authentication for *realm* and a super-URI of any "
"of the given URIs is given."
msgstr ""
"*uri* може бути або одним URI, або послідовністю URI. *realm*, *user* і "
"*passwd* мають бути рядками. Це спричиняє використання ``(user, passwd)`` як "
"маркерів автентифікації, коли надається автентифікація для *сфери* та супер-"
"URI будь-якого з указаних URI."

#: ../../library/urllib.request.rst:926
msgid ""
"Get user/password for given realm and URI, if any.  This method will return "
"``(None, None)`` if there is no matching user/password."
msgstr ""
"Отримайте користувача/пароль для заданої області та URI, якщо є. Цей метод "
"поверне ``(None, None)``, якщо немає відповідного користувача/паролю."

#: ../../library/urllib.request.rst:929
msgid ""
"For :class:`HTTPPasswordMgrWithDefaultRealm` objects, the realm ``None`` "
"will be searched if the given *realm* has no matching user/password."
msgstr ""
"Для об’єктів :class:`HTTPPasswordMgrWithDefaultRealm` шукатиметься область "
"``None``, якщо дана *сфера* не має відповідного користувача/паролю."

#: ../../library/urllib.request.rst:936
msgid "HTTPPasswordMgrWithPriorAuth Objects"
msgstr "Об’єкти HTTPPasswordMgrWithPriorAuth"

#: ../../library/urllib.request.rst:938
msgid ""
"This password manager extends :class:`HTTPPasswordMgrWithDefaultRealm` to "
"support tracking URIs for which authentication credentials should always be "
"sent."
msgstr ""
"Цей менеджер паролів розширює :class:`HTTPPasswordMgrWithDefaultRealm` для "
"підтримки URI відстеження, для яких завжди слід надсилати облікові дані "
"автентифікації."

#: ../../library/urllib.request.rst:945
msgid ""
"*realm*, *uri*, *user*, *passwd* are as for :meth:`HTTPPasswordMgr."
"add_password`.  *is_authenticated* sets the initial value of the "
"``is_authenticated`` flag for the given URI or list of URIs. If "
"*is_authenticated* is specified as ``True``, *realm* is ignored."
msgstr ""
"*realm*, *uri*, *user*, *passwd* такі ж, як для :meth:`HTTPPasswordMgr."
"add_password`. *is_authenticated* встановлює початкове значення прапора "
"``is_authenticated`` для даного URI або списку URI. Якщо *is_authenticated* "
"указано як ``True``, *realm* ігнорується."

#: ../../library/urllib.request.rst:953
msgid "Same as for :class:`HTTPPasswordMgrWithDefaultRealm` objects"
msgstr "Те саме, що для об’єктів :class:`HTTPPasswordMgrWithDefaultRealm`"

#: ../../library/urllib.request.rst:959
msgid ""
"Update the ``is_authenticated`` flag for the given *uri* or list of URIs."
msgstr ""
"Оновіть прапорець ``is_authenticated`` для заданого *uri* або списку URI."

#: ../../library/urllib.request.rst:965
msgid ""
"Returns the current state of the ``is_authenticated`` flag for the given URI."
msgstr "Повертає поточний стан прапора ``is_authenticated`` для вказаного URI."

#: ../../library/urllib.request.rst:972
msgid "AbstractBasicAuthHandler Objects"
msgstr "Об’єкти AbstractBasicAuthHandler"

#: ../../library/urllib.request.rst:977
msgid ""
"Handle an authentication request by getting a user/password pair, and re-"
"trying the request.  *authreq* should be the name of the header where the "
"information about the realm is included in the request, *host* specifies the "
"URL and path to authenticate for, *req* should be the (failed) :class:"
"`Request` object, and *headers* should be the error headers."
msgstr ""
"Обробіть запит на автентифікацію, отримавши пару користувач/пароль і "
"повторивши запит. *authreq* має бути ім’ям заголовка, де інформація про "
"область включена в запит, *host* визначає URL-адресу та шлях для "
"автентифікації, *req* має бути (не вдалося) об’єктом :class:`Request` , а "
"*headers* мають бути заголовками помилок."

#: ../../library/urllib.request.rst:983
msgid ""
"*host* is either an authority (e.g. ``\"python.org\"``) or a URL containing "
"an authority component (e.g. ``\"http://python.org/\"``). In either case, "
"the authority must not contain a userinfo component (so, ``\"python.org\"`` "
"and ``\"python.org:80\"`` are fine, ``\"joe:password@python.org\"`` is not)."
msgstr ""
"*host* — це або повноваження (наприклад, ``\"python.org\"``), або URL-"
"адреса, що містить компонент повноважень (наприклад, ``\"http://python.org/"
"\"``). У будь-якому випадку повноваження не повинні містити компонент "
"userinfo (тому ``\"python.org\"`` і ``\"python.org:80\"`` підходять, ``\"joe:"
"password@python.org\"`` не є)."

#: ../../library/urllib.request.rst:992
msgid "HTTPBasicAuthHandler Objects"
msgstr "Об’єкти HTTPBasicAuthHandler"

#: ../../library/urllib.request.rst:997 ../../library/urllib.request.rst:1008
#: ../../library/urllib.request.rst:1033 ../../library/urllib.request.rst:1044
msgid "Retry the request with authentication information, if available."
msgstr "Повторіть запит із інформацією для автентифікації, якщо вона доступна."

#: ../../library/urllib.request.rst:1003
msgid "ProxyBasicAuthHandler Objects"
msgstr "Об’єкти ProxyBasicAuthHandler"

#: ../../library/urllib.request.rst:1014
msgid "AbstractDigestAuthHandler Objects"
msgstr "Об’єкти AbstractDigestAuthHandler"

#: ../../library/urllib.request.rst:1019
msgid ""
"*authreq* should be the name of the header where the information about the "
"realm is included in the request, *host* should be the host to authenticate "
"to, *req* should be the (failed) :class:`Request` object, and *headers* "
"should be the error headers."
msgstr ""
"*authreq* має бути ім’ям заголовка, де інформація про область включена в "
"запит, *host* має бути хостом для автентифікації, *req* має бути (не "
"вдалося) об’єктом :class:`Request`, і *headers* повинні бути заголовками "
"помилок."

#: ../../library/urllib.request.rst:1028
msgid "HTTPDigestAuthHandler Objects"
msgstr "Об’єкти HTTPDigestAuthHandler"

#: ../../library/urllib.request.rst:1039
msgid "ProxyDigestAuthHandler Objects"
msgstr "Об’єкти ProxyDigestAuthHandler"

#: ../../library/urllib.request.rst:1050
msgid "HTTPHandler Objects"
msgstr "Об’єкти HTTPHandler"

#: ../../library/urllib.request.rst:1055
msgid ""
"Send an HTTP request, which can be either GET or POST, depending on ``req."
"has_data()``."
msgstr ""
"Надішліть запит HTTP, який може бути GET або POST, залежно від ``req."
"has_data()``."

#: ../../library/urllib.request.rst:1062
msgid "HTTPSHandler Objects"
msgstr "Objetos HTTPSHandler"

#: ../../library/urllib.request.rst:1067
msgid ""
"Send an HTTPS request, which can be either GET or POST, depending on ``req."
"has_data()``."
msgstr ""
"Надішліть запит HTTPS, який може бути GET або POST, залежно від ``req."
"has_data()``."

#: ../../library/urllib.request.rst:1074
msgid "FileHandler Objects"
msgstr "Об’єкти FileHandler"

#: ../../library/urllib.request.rst:1079
msgid ""
"Open the file locally, if there is no host name, or the host name is "
"``'localhost'``."
msgstr ""
"Відкрийте файл локально, якщо немає імені хоста або ім’я хоста "
"``'localhost'``."

#: ../../library/urllib.request.rst:1082
msgid ""
"This method is applicable only for local hostnames.  When a remote hostname "
"is given, an :exc:`~urllib.error.URLError` is raised."
msgstr ""
"Цей метод застосовний лише для локальних імен хостів. Коли вказано ім’я "
"віддаленого хоста, виникає :exc:`~urllib.error.URLError`."

#: ../../library/urllib.request.rst:1090
msgid "DataHandler Objects"
msgstr "Об’єкти DataHandler"

#: ../../library/urllib.request.rst:1094
msgid ""
"Read a data URL. This kind of URL contains the content encoded in the URL "
"itself. The data URL syntax is specified in :rfc:`2397`. This implementation "
"ignores white spaces in base64 encoded data URLs so the URL may be wrapped "
"in whatever source file it comes from. But even though some browsers don't "
"mind about a missing padding at the end of a base64 encoded data URL, this "
"implementation will raise an :exc:`ValueError` in that case."
msgstr ""
"Прочитайте URL-адресу даних. Цей вид URL-адреси містить вміст, закодований у "
"самій URL-адресі. Синтаксис URL-адреси даних указано в :rfc:`2397`. Ця "
"реалізація ігнорує пробіли в URL-адресах даних у кодуванні base64, тому URL-"
"адресу можна загорнути в будь-який вихідний файл, з якого вона надходить. "
"Але навіть незважаючи на те, що деякі браузери не заперечують щодо "
"відсутності заповнення в кінці URL-адреси даних у кодуванні base64, у цьому "
"випадку ця реалізація викличе :exc:`ValueError`."

#: ../../library/urllib.request.rst:1105
msgid "FTPHandler Objects"
msgstr "Об’єкти FTPHandler"

#: ../../library/urllib.request.rst:1110
msgid ""
"Open the FTP file indicated by *req*. The login is always done with empty "
"username and password."
msgstr ""
"Відкрийте файл FTP, позначений *req*. Вхід завжди виконується з порожнім "
"іменем користувача та паролем."

#: ../../library/urllib.request.rst:1117
msgid "CacheFTPHandler Objects"
msgstr "Об’єкти CacheFTPHandler"

#: ../../library/urllib.request.rst:1119
msgid ""
":class:`CacheFTPHandler` objects are :class:`FTPHandler` objects with the "
"following additional methods:"
msgstr ""
"Об’єкти :class:`CacheFTPHandler` — це об’єкти :class:`FTPHandler` із такими "
"додатковими методами:"

#: ../../library/urllib.request.rst:1125
msgid "Set timeout of connections to *t* seconds."
msgstr "Встановіть тайм-аут підключень на *t* секунд."

#: ../../library/urllib.request.rst:1130
msgid "Set maximum number of cached connections to *m*."
msgstr "Установіть максимальну кількість кешованих підключень до *m*."

#: ../../library/urllib.request.rst:1136
msgid "UnknownHandler Objects"
msgstr "Objetos UnknownHandler"

#: ../../library/urllib.request.rst:1141
msgid "Raise a :exc:`~urllib.error.URLError` exception."
msgstr "Викликати виняток :exc:`~urllib.error.URLError`."

#: ../../library/urllib.request.rst:1147
msgid "HTTPErrorProcessor Objects"
msgstr "Об’єкти HTTPErrorProcessor"

#: ../../library/urllib.request.rst:1153
msgid "For 200 error codes, the response object is returned immediately."
msgstr "Для 200 кодів помилок об’єкт відповіді повертається негайно."

#: ../../library/urllib.request.rst:1155
msgid ""
"For non-200 error codes, this simply passes the job on to the :meth:"
"`http_error_\\<type\\>` handler methods, via :meth:`OpenerDirector.error`. "
"Eventually, :class:`HTTPDefaultErrorHandler` will raise an :exc:`~urllib."
"error.HTTPError` if no other handler handles the error."
msgstr ""

#: ../../library/urllib.request.rst:1163
msgid "Process HTTPS error responses."
msgstr "Обробляти відповіді на помилки HTTPS."

#: ../../library/urllib.request.rst:1165
msgid "The behavior is same as :meth:`http_response`."
msgstr "Поведінка така ж, як :meth:`http_response`."

#: ../../library/urllib.request.rst:1171
msgid "Examples"
msgstr "Exemplos"

#: ../../library/urllib.request.rst:1173
msgid ""
"In addition to the examples below, more examples are given in :ref:`urllib-"
"howto`."
msgstr ""
"Крім наведених нижче прикладів, більше прикладів наведено в :ref:`urllib-"
"howto`."

#: ../../library/urllib.request.rst:1176
msgid ""
"This example gets the python.org main page and displays the first 300 bytes "
"of it. ::"
msgstr ""
"Цей приклад отримує головну сторінку python.org і відображає її перші 300 "
"байт. ::"

#: ../../library/urllib.request.rst:1189
msgid ""
"Note that urlopen returns a bytes object.  This is because there is no way "
"for urlopen to automatically determine the encoding of the byte stream it "
"receives from the HTTP server. In general, a program will decode the "
"returned bytes object to string once it determines or guesses the "
"appropriate encoding."
msgstr ""
"Зауважте, що urlopen повертає об’єкт bytes. Це тому, що urlopen не може "
"автоматично визначати кодування потоку байтів, який він отримує від сервера "
"HTTP. Загалом, програма декодує повернутий об’єкт bytes у рядок, як тільки "
"вона визначить або вгадає відповідне кодування."

#: ../../library/urllib.request.rst:1195
msgid ""
"The following W3C document, https://www.w3.org/International/O-charset\\ , "
"lists the various ways in which an (X)HTML or an XML document could have "
"specified its encoding information."
msgstr ""
"У наступному документі W3C, https://www.w3.org/International/O-charset\\, "
"наведено перелік різних способів, якими документ (X)HTML або XML міг би "
"вказати інформацію про кодування."

#: ../../library/urllib.request.rst:1199
msgid ""
"As the python.org website uses *utf-8* encoding as specified in its meta "
"tag, we will use the same for decoding the bytes object. ::"
msgstr ""
"Оскільки веб-сайт python.org використовує кодування *utf-8*, як зазначено в "
"його мета-тегу, ми будемо використовувати те саме для декодування об’єкта "
"bytes. ::"

#: ../../library/urllib.request.rst:1208
msgid ""
"It is also possible to achieve the same result without using the :term:"
"`context manager` approach. ::"
msgstr ""
"Також можна досягти того самого результату, не використовуючи підхід :term:"
"`context manager`. ::"

#: ../../library/urllib.request.rst:1217
msgid ""
"In the following example, we are sending a data-stream to the stdin of a CGI "
"and reading the data it returns to us. Note that this example will only work "
"when the Python installation supports SSL. ::"
msgstr ""
"У наступному прикладі ми надсилаємо потік даних на stdin CGI та зчитуємо "
"дані, які він повертає нам. Зауважте, що цей приклад працюватиме, лише якщо "
"інсталяція Python підтримує SSL. ::"

#: ../../library/urllib.request.rst:1229
msgid "The code for the sample CGI used in the above example is::"
msgstr "Код для прикладу CGI, використаного у наведеному вище прикладі, такий:"

#: ../../library/urllib.request.rst:1236
msgid "Here is an example of doing a ``PUT`` request using :class:`Request`::"
msgstr "Ось приклад виконання запиту ``PUT`` за допомогою :class:`Request`::"

#: ../../library/urllib.request.rst:1246
msgid "Use of Basic HTTP Authentication::"
msgstr "Використання базової автентифікації HTTP::"

#: ../../library/urllib.request.rst:1260
msgid ""
":func:`build_opener` provides many handlers by default, including a :class:"
"`ProxyHandler`.  By default, :class:`ProxyHandler` uses the environment "
"variables named ``<scheme>_proxy``, where ``<scheme>`` is the URL scheme "
"involved.  For example, the :envvar:`http_proxy` environment variable is "
"read to obtain the HTTP proxy's URL."
msgstr ""

#: ../../library/urllib.request.rst:1266
msgid ""
"This example replaces the default :class:`ProxyHandler` with one that uses "
"programmatically-supplied proxy URLs, and adds proxy authorization support "
"with :class:`ProxyBasicAuthHandler`. ::"
msgstr ""

#: ../../library/urllib.request.rst:1278
msgid "Adding HTTP headers:"
msgstr "Adicionando cabeçalhos HTTP:"

#: ../../library/urllib.request.rst:1280
msgid "Use the *headers* argument to the :class:`Request` constructor, or::"
msgstr ""
"Використовуйте аргумент *headers* для конструктора :class:`Request` або:"

#: ../../library/urllib.request.rst:1289
msgid ""
":class:`OpenerDirector` automatically adds a :mailheader:`User-Agent` header "
"to every :class:`Request`.  To change this::"
msgstr ""
":class:`OpenerDirector` автоматично додає заголовок :mailheader:`User-Agent` "
"до кожного :class:`Request`. Щоб змінити це:"

#: ../../library/urllib.request.rst:1297
msgid ""
"Also, remember that a few standard headers (:mailheader:`Content-Length`, :"
"mailheader:`Content-Type` and :mailheader:`Host`) are added when the :class:"
"`Request` is passed to :func:`urlopen` (or :meth:`OpenerDirector.open`)."
msgstr ""
"Також пам’ятайте, що кілька стандартних заголовків (:mailheader:`Content-"
"Length`, :mailheader:`Content-Type` і :mailheader:`Host`) додаються, коли :"
"class:`Request` передається до :func:`urlopen` (або :meth:`OpenerDirector."
"open`)."

#: ../../library/urllib.request.rst:1304
msgid ""
"Here is an example session that uses the ``GET`` method to retrieve a URL "
"containing parameters::"
msgstr ""
"Ось приклад сеансу, який використовує метод ``GET`` для отримання URL-"
"адреси, що містить параметри:"

#: ../../library/urllib.request.rst:1315
msgid ""
"The following example uses the ``POST`` method instead. Note that params "
"output from urlencode is encoded to bytes before it is sent to urlopen as "
"data::"
msgstr ""
"У наступному прикладі замість цього використовується метод ``POST``. "
"Зауважте, що параметри, виведені з urlencode, кодуються до байтів перед тим, "
"як надсилаються до urlopen як дані::"

#: ../../library/urllib.request.rst:1326
msgid ""
"The following example uses an explicitly specified HTTP proxy, overriding "
"environment settings::"
msgstr ""
"У наступному прикладі використовується явно вказаний проксі-сервер HTTP, "
"який замінює налаштування середовища:"

#: ../../library/urllib.request.rst:1336
msgid ""
"The following example uses no proxies at all, overriding environment "
"settings::"
msgstr ""
"У наступному прикладі проксі-сервери взагалі не використовуються, замінюючи "
"налаштування середовища:"

#: ../../library/urllib.request.rst:1346
msgid "Legacy interface"
msgstr "Застарілий інтерфейс"

#: ../../library/urllib.request.rst:1348
msgid ""
"The following functions and classes are ported from the Python 2 module "
"``urllib`` (as opposed to ``urllib2``).  They might become deprecated at "
"some point in the future."
msgstr ""
"Наступні функції та класи перенесено з модуля Python 2 ``urllib`` (на "
"відміну від ``urllib2``). Вони можуть стати застарілими в якийсь момент у "
"майбутньому."

#: ../../library/urllib.request.rst:1354
msgid ""
"Copy a network object denoted by a URL to a local file. If the URL points to "
"a local file, the object will not be copied unless filename is supplied. "
"Return a tuple ``(filename, headers)`` where *filename* is the local file "
"name under which the object can be found, and *headers* is whatever the :"
"meth:`info` method of the object returned by :func:`urlopen` returned (for a "
"remote object). Exceptions are the same as for :func:`urlopen`."
msgstr ""

#: ../../library/urllib.request.rst:1361
msgid ""
"The second argument, if present, specifies the file location to copy to (if "
"absent, the location will be a tempfile with a generated name). The third "
"argument, if present, is a callable that will be called once on "
"establishment of the network connection and once after each block read "
"thereafter.  The callable will be passed three arguments; a count of blocks "
"transferred so far, a block size in bytes, and the total size of the file.  "
"The third argument may be ``-1`` on older FTP servers which do not return a "
"file size in response to a retrieval request."
msgstr ""
"Другий аргумент, якщо він присутній, визначає розташування файлу, куди "
"потрібно скопіювати (якщо його немає, місцем буде тимчасовий файл зі "
"згенерованою назвою). Третій аргумент, якщо він присутній, є викликом, який "
"буде викликано один раз після встановлення мережевого з’єднання та один раз "
"після кожного блоку, який буде прочитано в подальшому. Викликається буде "
"передано три аргументи; кількість переданих блоків, розмір блоку в байтах і "
"загальний розмір файлу. Третім аргументом може бути ``-1`` на старих FTP-"
"серверах, які не повертають розмір файлу у відповідь на запит на отримання."

#: ../../library/urllib.request.rst:1370
msgid "The following example illustrates the most common usage scenario::"
msgstr "Наступний приклад ілюструє найпоширеніший сценарій використання:"

#: ../../library/urllib.request.rst:1377
msgid ""
"If the *url* uses the :file:`http:` scheme identifier, the optional *data* "
"argument may be given to specify a ``POST`` request (normally the request "
"type is ``GET``).  The *data* argument must be a bytes object in standard :"
"mimetype:`application/x-www-form-urlencoded` format; see the :func:`urllib."
"parse.urlencode` function."
msgstr ""
"Якщо *url* використовує ідентифікатор схеми :file:`http:`, можна надати "
"необов’язковий аргумент *data*, щоб визначити запит ``POST`` (зазвичай тип "
"запиту ``GET``). Аргумент *data* має бути об’єктом bytes у стандартному "
"форматі :mimetype:`application/x-www-form-urlencoded`; перегляньте функцію :"
"func:`urllib.parse.urlencode`."

#: ../../library/urllib.request.rst:1383
msgid ""
":func:`urlretrieve` will raise :exc:`ContentTooShortError` when it detects "
"that the amount of data available  was less than the expected amount (which "
"is the size reported by a  *Content-Length* header). This can occur, for "
"example, when the  download is interrupted."
msgstr ""

#: ../../library/urllib.request.rst:1388
msgid ""
"The *Content-Length* is treated as a lower bound: if there's more data  to "
"read, urlretrieve reads more data, but if less data is available,  it raises "
"the exception."
msgstr ""
"*Content-Length* розглядається як нижня межа: якщо є більше даних для "
"читання, urlretrieve зчитує більше даних, але якщо доступних даних менше, "
"виникає виняток."

#: ../../library/urllib.request.rst:1392
msgid ""
"You can still retrieve the downloaded data in this case, it is stored  in "
"the :attr:`content` attribute of the exception instance."
msgstr ""

#: ../../library/urllib.request.rst:1395
msgid ""
"If no *Content-Length* header was supplied, urlretrieve can not check the "
"size of the data it has downloaded, and just returns it.  In this case you "
"just have to assume that the download was successful."
msgstr ""
"Якщо заголовок *Content-Length* не надано, urlretrieve не може перевірити "
"розмір завантажених даних і просто повертає їх. У цьому випадку ви просто "
"повинні припустити, що завантаження пройшло успішно."

#: ../../library/urllib.request.rst:1401
msgid ""
"Cleans up temporary files that may have been left behind by previous calls "
"to :func:`urlretrieve`."
msgstr ""
"Очищає тимчасові файли, які могли бути залишені попередніми викликами :func:"
"`urlretrieve`."

#: ../../library/urllib.request.rst:1408
msgid ""
"Base class for opening and reading URLs.  Unless you need to support opening "
"objects using schemes other than :file:`http:`, :file:`ftp:`, or :file:`file:"
"`, you probably want to use :class:`FancyURLopener`."
msgstr ""
"Базовий клас для відкриття та читання URL-адрес. Якщо вам не потрібно "
"підтримувати відкриття об’єктів за допомогою схем, відмінних від :file:`http:"
"`, :file:`ftp:`або :file:`file:`, можливо, ви захочете використовувати :"
"class:`FancyURLopener`."

#: ../../library/urllib.request.rst:1412
msgid ""
"By default, the :class:`URLopener` class sends a :mailheader:`User-Agent` "
"header of ``urllib/VVV``, where *VVV* is the :mod:`urllib` version number. "
"Applications can define their own :mailheader:`User-Agent` header by "
"subclassing :class:`URLopener` or :class:`FancyURLopener` and setting the "
"class attribute :attr:`version` to an appropriate string value in the "
"subclass definition."
msgstr ""
"За замовчуванням клас :class:`URLopener` надсилає заголовок :mailheader:"
"`User-Agent` ``urllib/VVV``, де *VVV* — це номер версії :mod:`urllib`. "
"Програми можуть визначати власний заголовок :mailheader:`User-Agent`, "
"створивши підклас :class:`URLopener` або :class:`FancyURLopener` і "
"встановивши атрибуту класу :attr:`version` відповідне значення рядка у "
"визначенні підкласу."

#: ../../library/urllib.request.rst:1418
msgid ""
"The optional *proxies* parameter should be a dictionary mapping scheme names "
"to proxy URLs, where an empty dictionary turns proxies off completely.  Its "
"default value is ``None``, in which case environmental proxy settings will "
"be used if present, as discussed in the definition of :func:`urlopen`, above."
msgstr ""
"Необов’язковий параметр *proxies* має бути словником, що зіставляє імена "
"схем із URL-адресами проксі, де порожній словник повністю вимикає проксі. "
"Його значенням за замовчуванням є ``None``, у цьому випадку будуть "
"використані параметри середовища проксі, якщо вони присутні, як "
"обговорювалося у визначенні :func:`urlopen` вище."

#: ../../library/urllib.request.rst:1423
msgid ""
"Additional keyword parameters, collected in *x509*, may be used for "
"authentication of the client when using the :file:`https:` scheme.  The "
"keywords *key_file* and *cert_file* are supported to provide an  SSL key and "
"certificate; both are needed to support client authentication."
msgstr ""
"Додаткові параметри ключових слів, зібрані в *x509*, можуть "
"використовуватися для автентифікації клієнта під час використання схеми :"
"file:`https:`. Ключові слова *key_file* і *cert_file* підтримуються для "
"надання ключа SSL і сертифіката; обидва потрібні для підтримки "
"автентифікації клієнта."

#: ../../library/urllib.request.rst:1428
msgid ""
":class:`URLopener` objects will raise an :exc:`OSError` exception if the "
"server returns an error code."
msgstr ""
"Об’єкти :class:`URLopener` викличуть виняток :exc:`OSError`, якщо сервер "
"повертає код помилки."

#: ../../library/urllib.request.rst:1433
msgid ""
"Open *fullurl* using the appropriate protocol.  This method sets up cache "
"and proxy information, then calls the appropriate open method with its input "
"arguments.  If the scheme is not recognized, :meth:`open_unknown` is called. "
"The *data* argument has the same meaning as the *data* argument of :func:"
"`urlopen`."
msgstr ""
"Відкрийте *fullurl* за допомогою відповідного протоколу. Цей метод "
"налаштовує інформацію про кеш і проксі, а потім викликає відповідний "
"відкритий метод із його вхідними аргументами. Якщо схема не розпізнається, "
"викликається :meth:`open_unknown`. Аргумент *data* має те саме значення, що "
"й аргумент *data* :func:`urlopen`."

#: ../../library/urllib.request.rst:1439
msgid "This method always quotes *fullurl* using :func:`~urllib.parse.quote`."
msgstr ""
"Цей метод завжди цитує *fullurl* за допомогою :func:`~urllib.parse.quote`."

#: ../../library/urllib.request.rst:1443
msgid "Overridable interface to open unknown URL types."
msgstr "Перевизначений інтерфейс для відкриття невідомих типів URL."

#: ../../library/urllib.request.rst:1448
msgid ""
"Retrieves the contents of *url* and places it in *filename*.  The return "
"value is a tuple consisting of a local filename and either an :class:`email."
"message.Message` object containing the response headers (for remote URLs) or "
"``None`` (for local URLs).  The caller must then open and read the contents "
"of *filename*.  If *filename* is not given and the URL refers to a local "
"file, the input filename is returned.  If the URL is non-local and "
"*filename* is not given, the filename is the output of :func:`tempfile."
"mktemp` with a suffix that matches the suffix of the last path component of "
"the input URL.  If *reporthook* is given, it must be a function accepting "
"three numeric parameters: A chunk number, the maximum size chunks are read "
"in and the total size of the download (-1 if unknown).  It will be called "
"once at the start and after each chunk of data is read from the network.  "
"*reporthook* is ignored for local URLs."
msgstr ""
"Отримує вміст *url* і поміщає його в *filename*. Значення, що повертається, "
"є кортежем, що складається з імені локального файлу та об’єкта :class:`email."
"message.Message`, що містить заголовки відповіді (для віддалених URL-адрес) "
"або ``None`` (для локальних URL-адрес). Потім абонент повинен відкрити та "
"прочитати вміст *filename*. Якщо *ім’я файлу* не вказано, а URL-адреса "
"посилається на локальний файл, повертається ім’я вхідного файлу. Якщо URL-"
"адреса нелокальна і *filename* не вказано, ім’я файлу є результатом :func:"
"`tempfile.mktemp` із суфіксом, який відповідає суфіксу останнього компонента "
"шляху вхідної URL-адреси. Якщо вказано *reporthook*, це має бути функція, "
"яка приймає три числові параметри: номер блоку, максимальний розмір "
"фрагментів, які зчитуються, і загальний розмір завантаження (-1, якщо "
"невідомо). Він буде викликаний один раз на початку та після кожного "
"зчитування даних із мережі. *reporthook* ігнорується для локальних URL-адрес."

#: ../../library/urllib.request.rst:1461
msgid ""
"If the *url* uses the :file:`http:` scheme identifier, the optional *data* "
"argument may be given to specify a ``POST`` request (normally the request "
"type is ``GET``).  The *data* argument must in standard :mimetype:"
"`application/x-www-form-urlencoded` format; see the :func:`urllib.parse."
"urlencode` function."
msgstr ""
"Якщо *url* використовує ідентифікатор схеми :file:`http:`, можна надати "
"необов’язковий аргумент *data*, щоб визначити запит ``POST`` (зазвичай тип "
"запиту ``GET``). Аргумент *data* має бути в стандартному форматі :mimetype:"
"`application/x-www-form-urlencoded`; перегляньте функцію :func:`urllib.parse."
"urlencode`."

#: ../../library/urllib.request.rst:1470
msgid ""
"Variable that specifies the user agent of the opener object.  To get :mod:"
"`urllib` to tell servers that it is a particular user agent, set this in a "
"subclass as a class variable or in the constructor before calling the base "
"constructor."
msgstr ""
"Змінна, яка вказує агента користувача об’єкта відкривача. Щоб змусити :mod:"
"`urllib` повідомляти серверам, що це певний агент користувача, встановіть це "
"в підкласі як змінну класу або в конструкторі перед викликом базового "
"конструктора."

#: ../../library/urllib.request.rst:1480
msgid ""
":class:`FancyURLopener` subclasses :class:`URLopener` providing default "
"handling for the following HTTP response codes: 301, 302, 303, 307 and 401.  "
"For the 30x response codes listed above, the :mailheader:`Location` header "
"is used to fetch the actual URL.  For 401 response codes (authentication "
"required), basic HTTP authentication is performed.  For the 30x response "
"codes, recursion is bounded by the value of the *maxtries* attribute, which "
"defaults to 10."
msgstr ""
":class:`FancyURLopener` підкласи :class:`URLopener`, що забезпечує обробку "
"за замовчуванням для таких кодів відповіді HTTP: 301, 302, 303, 307 і 401. "
"Для кодів відповіді 30x, наведених вище, заголовок :mailheader:`Location` "
"використовується для отримання фактичної URL-адреси. Для кодів відповіді 401 "
"(потрібна автентифікація) виконується базова автентифікація HTTP. Для кодів "
"відповіді 30x рекурсія обмежена значенням атрибута *maxtries*, яке за "
"замовчуванням дорівнює 10."

#: ../../library/urllib.request.rst:1487
msgid ""
"For all other response codes, the method :meth:`http_error_default` is "
"called which you can override in subclasses to handle the error "
"appropriately."
msgstr ""

#: ../../library/urllib.request.rst:1492
msgid ""
"According to the letter of :rfc:`2616`, 301 and 302 responses to POST "
"requests must not be automatically redirected without confirmation by the "
"user.  In reality, browsers do allow automatic redirection of these "
"responses, changing the POST to a GET, and :mod:`urllib` reproduces this "
"behaviour."
msgstr ""
"Згідно з листом :rfc:`2616`, відповіді 301 і 302 на запити POST не повинні "
"автоматично перенаправлятися без підтвердження користувача. Насправді "
"браузери дозволяють автоматичне перенаправлення цих відповідей, змінюючи "
"POST на GET, і :mod:`urllib` відтворює цю поведінку."

#: ../../library/urllib.request.rst:1497
msgid ""
"The parameters to the constructor are the same as those for :class:"
"`URLopener`."
msgstr "Параметри конструктора такі самі, як і для :class:`URLopener`."

#: ../../library/urllib.request.rst:1501
msgid ""
"When performing basic authentication, a :class:`FancyURLopener` instance "
"calls its :meth:`prompt_user_passwd` method.  The default implementation "
"asks the users for the required information on the controlling terminal.  A "
"subclass may override this method to support more appropriate behavior if "
"needed."
msgstr ""
"Під час базової автентифікації екземпляр :class:`FancyURLopener` викликає "
"свій метод :meth:`prompt_user_passwd`. Стандартна реалізація запитує у "
"користувачів необхідну інформацію на керуючому терміналі. Підклас може "
"замінити цей метод для підтримки більш відповідної поведінки, якщо це "
"необхідно."

#: ../../library/urllib.request.rst:1506
msgid ""
"The :class:`FancyURLopener` class offers one additional method that should "
"be overloaded to provide the appropriate behavior:"
msgstr ""
"Клас :class:`FancyURLopener` пропонує один додатковий метод, який слід "
"перевантажити, щоб забезпечити належну поведінку:"

#: ../../library/urllib.request.rst:1511
msgid ""
"Return information needed to authenticate the user at the given host in the "
"specified security realm.  The return value should be a tuple, ``(user, "
"password)``, which can be used for basic authentication."
msgstr ""
"Повернути інформацію, необхідну для автентифікації користувача на даному "
"хості у вказаній області безпеки. Поверненим значенням має бути кортеж "
"``(користувач, пароль)``, який можна використовувати для базової "
"автентифікації."

#: ../../library/urllib.request.rst:1515
msgid ""
"The implementation prompts for this information on the terminal; an "
"application should override this method to use an appropriate interaction "
"model in the local environment."
msgstr ""
"Реалізація запитує цю інформацію на терміналі; програма повинна замінити цей "
"метод, щоб використовувати відповідну модель взаємодії в локальному "
"середовищі."

#: ../../library/urllib.request.rst:1521
msgid ":mod:`urllib.request` Restrictions"
msgstr ":mod:`urllib.request` Обмеження"

#: ../../library/urllib.request.rst:1527
msgid ""
"Currently, only the following protocols are supported: HTTP (versions 0.9 "
"and 1.0), FTP, local files, and data URLs."
msgstr ""
"Наразі підтримуються лише такі протоколи: HTTP (версії 0.9 і 1.0), FTP, "
"локальні файли та URL-адреси даних."

#: ../../library/urllib.request.rst:1530
msgid "Added support for data URLs."
msgstr "Додано підтримку URL-адрес даних."

#: ../../library/urllib.request.rst:1532
msgid ""
"The caching feature of :func:`urlretrieve` has been disabled until someone "
"finds the time to hack proper processing of Expiration time headers."
msgstr ""
"Функцію кешування :func:`urlretrieve` вимкнено, доки хтось не знайде час "
"зламати правильну обробку заголовків часу закінчення терміну дії."

#: ../../library/urllib.request.rst:1535
msgid ""
"There should be a function to query whether a particular URL is in the cache."
msgstr "Має бути функція для запиту, чи є певна URL-адреса в кеші."

#: ../../library/urllib.request.rst:1537
msgid ""
"For backward compatibility, if a URL appears to point to a local file but "
"the file can't be opened, the URL is re-interpreted using the FTP protocol.  "
"This can sometimes cause confusing error messages."
msgstr ""
"Для зворотної сумісності, якщо URL-адреса вказує на локальний файл, але файл "
"не може бути відкритий, URL-адреса повторно інтерпретується за допомогою "
"протоколу FTP. Іноді це може призвести до незрозумілих повідомлень про "
"помилки."

#: ../../library/urllib.request.rst:1541
msgid ""
"The :func:`urlopen` and :func:`urlretrieve` functions can cause arbitrarily "
"long delays while waiting for a network connection to be set up.  This means "
"that it is difficult to build an interactive Web client using these "
"functions without using threads."
msgstr ""

#: ../../library/urllib.request.rst:1550
msgid ""
"The data returned by :func:`urlopen` or :func:`urlretrieve` is the raw data "
"returned by the server.  This may be binary data (such as an image), plain "
"text or (for example) HTML.  The HTTP protocol provides type information in "
"the reply header, which can be inspected by looking at the :mailheader:"
"`Content-Type` header.  If the returned data is HTML, you can use the "
"module :mod:`html.parser` to parse it."
msgstr ""
"Дані, які повертає :func:`urlopen` або :func:`urlretrieve`, є необробленими "
"даними, які повертає сервер. Це можуть бути двійкові дані (наприклад, "
"зображення), звичайний текст або (наприклад) HTML. Протокол HTTP надає "
"інформацію про тип у заголовку відповіді, яку можна перевірити, подивившись "
"на заголовок :mailheader:`Content-Type`. Якщо повернуті дані є HTML, ви "
"можете використати модуль :mod:`html.parser` для їх аналізу."

#: ../../library/urllib.request.rst:1559
msgid ""
"The code handling the FTP protocol cannot differentiate between a file and a "
"directory.  This can lead to unexpected behavior when attempting to read a "
"URL that points to a file that is not accessible.  If the URL ends in a ``/"
"``, it is assumed to refer to a directory and will be handled accordingly.  "
"But if an attempt to read a file leads to a 550 error (meaning the URL "
"cannot be found or is not accessible, often for permission reasons), then "
"the path is treated as a directory in order to handle the case when a "
"directory is specified by a URL but the trailing ``/`` has been left off.  "
"This can cause misleading results when you try to fetch a file whose read "
"permissions make it inaccessible; the FTP code will try to read it, fail "
"with a 550 error, and then perform a directory listing for the unreadable "
"file. If fine-grained control is needed, consider using the :mod:`ftplib` "
"module, subclassing :class:`FancyURLopener`, or changing *_urlopener* to "
"meet your needs."
msgstr ""
"Код, який обробляє протокол FTP, не може відрізнити файл від каталогу. Це "
"може призвести до неочікуваної поведінки під час спроби прочитати URL-"
"адресу, яка вказує на файл, до якого немає доступу. Якщо URL-адреса "
"закінчується на ``/``, передбачається, що вона посилається на каталог і буде "
"оброблятися відповідно. Але якщо спроба прочитати файл призводить до помилки "
"550 (це означає, що URL-адресу неможливо знайти або вона недоступна, часто "
"через дозвіл), тоді шлях розглядається як каталог, щоб обробити випадок, "
"коли вказано каталог за URL-адресою, але кінцевий символ ``/`` було "
"пропущено. Це може призвести до оманливих результатів, коли ви намагаєтеся "
"отримати файл, дозволи на читання якого роблять його недоступним; код FTP "
"спробує прочитати його, зазнає помилки 550, а потім виконає перелік каталогу "
"для нечитабельного файлу. Якщо потрібен детальний контроль, розгляньте "
"можливість використання модуля :mod:`ftplib`, створення підкласу :class:"
"`FancyURLopener` або зміни *_urlopener* відповідно до ваших потреб."

#: ../../library/urllib.request.rst:1576
msgid ":mod:`urllib.response` --- Response classes used by urllib"
msgstr ":mod:`urllib.response` --- Класи відповідей, які використовує urllib"

#: ../../library/urllib.request.rst:1581
msgid ""
"The :mod:`urllib.response` module defines functions and classes which define "
"a minimal file-like interface, including ``read()`` and ``readline()``. "
"Functions defined by this module are used internally by the :mod:`urllib."
"request` module. The typical response object is a :class:`urllib.response."
"addinfourl` instance:"
msgstr ""
"Модуль :mod:`urllib.response` визначає функції та класи, які визначають "
"мінімальний файлоподібний інтерфейс, включаючи ``read()`` і ``readline()``. "
"Функції, визначені цим модулем, використовуються внутрішньо модулем :mod:"
"`urllib.request`. Типовий об’єкт відповіді – це екземпляр :class:`urllib."
"response.addinfourl`:"

#: ../../library/urllib.request.rst:1590
msgid ""
"URL of the resource retrieved, commonly used to determine if a redirect was "
"followed."
msgstr ""
"URL-адреса отриманого ресурсу, яка зазвичай використовується для визначення "
"того, чи було переспрямовано."

#: ../../library/urllib.request.rst:1594
msgid ""
"Returns the headers of the response in the form of an :class:`~email.message."
"EmailMessage` instance."
msgstr ""
"Повертає заголовки відповіді у формі екземпляра :class:`~email.message."
"EmailMessage`."

#: ../../library/urllib.request.rst:1600
msgid "Status code returned by server."
msgstr "Код статусу, повернутий сервером."

#: ../../library/urllib.request.rst:1604
msgid "Deprecated in favor of :attr:`~addinfourl.url`."
msgstr "Застаріло на користь :attr:`~addinfourl.url`."

#: ../../library/urllib.request.rst:1609
msgid "Deprecated in favor of :attr:`~addinfourl.headers`."
msgstr "Застаріло на користь :attr:`~addinfourl.headers`."

#: ../../library/urllib.request.rst:1614 ../../library/urllib.request.rst:1619
msgid "Deprecated in favor of :attr:`~addinfourl.status`."
msgstr "Застаріло на користь :attr:`~addinfourl.status`."

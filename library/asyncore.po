# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Marco Rougeth <marco@rougeth.com>, 2020
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 17:51+0000\n"
"PO-Revision-Date: 2017-02-16 17:50+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/asyncore.rst:2
msgid ":mod:`asyncore` --- Asynchronous socket handler"
msgstr "Moduł :mod:`asyncore` --- Asynchroniczna obsługa gniazda"

#: ../../library/asyncore.rst:14
msgid "**Source code:** :source:`Lib/asyncore.py`"
msgstr "**Código-fonte:** :source:`Lib/asyncore.py`"

#: ../../library/asyncore.rst:16
msgid ""
":mod:`asyncore` will be removed in Python 3.12 (see :pep:`PEP 594 "
"<594#asyncore>` for details). Please use :mod:`asyncio` instead."
msgstr ""
":mod:`asyncore` 将在 Python 3.12 版被移除（请参阅 :pep:`PEP 594 "
"<594#asyncore>` 了解详情）。 请改用 :mod:`asyncio`。"

#: ../../library/asyncore.rst:25
msgid ""
"This module exists for backwards compatibility only.  For new code we "
"recommend using :mod:`asyncio`."
msgstr ""
"Цей модуль існує лише для зворотної сумісності. Для нового коду ми "
"рекомендуємо використовувати :mod:`asyncio`."

#: ../../library/asyncore.rst:28
msgid ""
"This module provides the basic infrastructure for writing asynchronous  "
"socket service clients and servers."
msgstr ""
"Ten moduł dostarcza podstawową infrastrukturę do pisania asynchronicznych "
"klientów i serwerów usługi gniazd."

#: ../../library/asyncore.rst:31
msgid ""
"There are only two ways to have a program on a single processor do  \"more "
"than one thing at a time.\" Multi-threaded programming is the  simplest and "
"most popular way to do it, but there is another very different technique, "
"that lets you have nearly all the advantages of  multi-threading, without "
"actually using multiple threads.  It's really  only practical if your "
"program is largely I/O bound.  If your program is processor bound, then pre-"
"emptive scheduled threads are probably what you really need.  Network "
"servers are rarely processor bound, however."
msgstr ""
"Istnieją tylko dwa sposoby aby program na pojedynczym procesorze robił "
"\"więcej niż jedną rzecz na raz.\" Wielo-wątkowe programowanie jest "
"najprostszą i najczęściej spotykaną drogą aby to robić, ale istnieje inna "
"bardzo odmienna technika, która pozwala mieć prawie wszystkie zalety "
"wielowątkowości, bez używania wielu wątków. Jest ona tylko pomocna jeśli "
"twój program jest w większości związany z wejściem/wyjściem. Jeśli twój "
"program jest związany z procesorem, wtedy wywłaszczające planowane wątki są "
"najczęściej tym czego potrzebujesz. Serwery sieciowe jednakże są rzadko "
"związane z procesorem."

#: ../../library/asyncore.rst:40
msgid ""
"If your operating system supports the :c:func:`select` system call in its I/"
"O library (and nearly all do), then you can use it to juggle multiple "
"communication channels at once; doing other work while your I/O is taking "
"place in the \"background.\"  Although this strategy can seem strange and "
"complex, especially at first, it is in many ways easier to understand and "
"control than multi-threaded programming.  The :mod:`asyncore` module solves "
"many of the difficult problems for you, making the task of building "
"sophisticated high-performance network servers and clients a snap.  For "
"\"conversational\" applications and protocols the companion :mod:`asynchat` "
"module is invaluable."
msgstr ""
"Якщо ваша операційна система підтримує системний виклик :c:func:`select` у "
"своїй бібліотеці вводу-виводу (і майже всі так підтримує), ви можете "
"використовувати її для жонглювання кількома каналами зв’язку одночасно; "
"виконувати іншу роботу, поки ваш ввід/вивід виконується у \"фоновому "
"режимі\". Хоча ця стратегія може здатися дивною та складною, особливо "
"спочатку, її багато в чому легше зрозуміти та контролювати, ніж "
"багатопотокове програмування. Модуль :mod:`asyncore` вирішує багато складних "
"проблем, роблячи завдання побудови складних високопродуктивних мережевих "
"серверів і клієнтів миттєвим. Для \"розмовних\" програм і протоколів "
"супутній модуль :mod:`asynchat` є безцінним."

#: ../../library/asyncore.rst:51
msgid ""
"The basic idea behind both modules is to create one or more network "
"*channels*, instances of class :class:`asyncore.dispatcher` and :class:"
"`asynchat.async_chat`.  Creating the channels adds them to a global map, "
"used by the :func:`loop` function if you do not provide it with your own "
"*map*."
msgstr ""
"Podstawowym pomysłem stojącym za oboma modułami jest stworzenie jednego lub "
"więcej *kanałów*, przykładów uogólnienia :class:`asyncore.dispatcher` i :"
"class:`asynchat.async_chat`. Utworzenie kanałów dodaje je do globalnej mapy, "
"używanej przez funkcję :func:`loop` jeśli dostarczysz jej swojej własnej "
"*mapy*."

#: ../../library/asyncore.rst:57
msgid ""
"Once the initial channel(s) is(are) created, calling the :func:`loop` "
"function activates channel service, which continues until the last channel "
"(including any that have been added to the map during asynchronous service) "
"is closed."
msgstr ""
"Gdy początkowy(e) kanał(y) jest(są) tworzony(e), wywołanie funkcji :func:"
"`loop` aktywuje usługę kanału, która kontynuuje zanim ostatni kanał "
"(włączając w to jakiekolwiek które zostały dodane do mapy podczas "
"asynchronicznej usługi) nie zostanie zamknięty."

#: ../../library/asyncore.rst:64
msgid ""
"Enter a polling loop that terminates after count passes or all open channels "
"have been closed.  All arguments are optional.  The *count* parameter "
"defaults to ``None``, resulting in the loop terminating only when all "
"channels have been closed.  The *timeout* argument sets the timeout "
"parameter for the appropriate :func:`~select.select` or :func:`~select.poll` "
"call, measured in seconds; the default is 30 seconds.  The *use_poll* "
"parameter, if true, indicates that :func:`~select.poll` should be used in "
"preference to :func:`~select.select` (the default is ``False``)."
msgstr ""
"Введіть цикл опитування, який завершується після проходження підрахунку або "
"закриття всіх відкритих каналів. Усі аргументи необов’язкові. Параметр "
"*count* за замовчуванням має значення ``None``, що призводить до завершення "
"циклу лише після закриття всіх каналів. Аргумент *timeout* встановлює "
"параметр часу очікування для відповідного виклику :func:`~select.select` "
"або :func:`~select.poll`, виміряний у секундах; за замовчуванням 30 секунд. "
"Параметр *use_poll*, якщо він істинний, вказує, що :func:`~select.poll` слід "
"використовувати замість :func:`~select.select` (за замовчуванням ``False``)."

#: ../../library/asyncore.rst:73
msgid ""
"The *map* parameter is a dictionary whose items are the channels to watch. "
"As channels are closed they are deleted from their map.  If *map* is "
"omitted, a global map is used. Channels (instances of :class:`asyncore."
"dispatcher`, :class:`asynchat.async_chat` and subclasses thereof) can freely "
"be mixed in the map."
msgstr ""
"Parametr *map* jest słownikiem którego elementami są kanały do oglądania. "
"Gdy kanały są zamykane są one kasowane z ich mapy. Jeśli *mapa* jest "
"pominięta, nadrzędna mapa jest używana. Kanały (przykłady uogólnienia :class:"
"`asyncore.dispatcher` i :class:`asynchat.async_chat` i podrzędne uogólnienia "
"tychże) mogą dowolnie być mieszane wewnątrz mapy."

#: ../../library/asyncore.rst:82
msgid ""
"The :class:`dispatcher` class is a thin wrapper around a low-level socket "
"object. To make it more useful, it has a few methods for event-handling "
"which are called from the asynchronous loop.   Otherwise, it can be treated "
"as a normal non-blocking socket object."
msgstr ""
"Uogólnienie :class:`dispatcher` jest cienkim opakowaniem wokół "
"niskopoziomowego przedmiotu gniazda. Aby uczynić je bardziej użytecznym, ma "
"kilka sposobów postępowania dla obsługi-zdarzeń które są wzywane z "
"asynchronicznej pętli. Poza tym, może być traktowana jako zwyczajny "
"nieblokujący przedmiot gniazda."

#: ../../library/asyncore.rst:87
msgid ""
"The firing of low-level events at certain times or in certain connection "
"states tells the asynchronous loop that certain higher-level events have "
"taken place.  For example, if we have asked for a socket to connect to "
"another host, we know that the connection has been made when the socket "
"becomes writable for the first time (at this point you know that you may "
"write to it with the expectation of success).  The implied higher-level "
"events are:"
msgstr ""
"Odpalanie niskopoziomowych zdarzeń w konkretnych momentach lub w konkretnych "
"stanach połączeń mówi pętli asynchronicznej że konkretne wyższego poziomu "
"zdarzenia miały miejsce. Dla przykładu, jeśli żądaliśmy aby gniazdo "
"podłączone było do innego hosta, wiemy że połączenie zostało ustanowione gdy "
"gniazdo stanie się możliwe do zapisania po raz pierwszy (w tym momencie "
"wiesz że możesz zapisać do niego oczekując powodzenia). Dorozumiane "
"zdarzenia wyższego poziomu to:"

#: ../../library/asyncore.rst:96
msgid "Event"
msgstr "Evento"

#: ../../library/asyncore.rst:96
msgid "Description"
msgstr "Descrição"

#: ../../library/asyncore.rst:98
msgid "``handle_connect()``"
msgstr "``handle_connect()``"

#: ../../library/asyncore.rst:98
msgid "Implied by the first read or write event"
msgstr "Domyślne przez pierwsze zdarzenie odczytu lub zapisu"

#: ../../library/asyncore.rst:101
msgid "``handle_close()``"
msgstr "``handle_close()``"

#: ../../library/asyncore.rst:101
msgid "Implied by a read event with no data available"
msgstr "Domyślne przy zdarzeniu odczytu bez dostępnych danych"

#: ../../library/asyncore.rst:104
msgid "``handle_accepted()``"
msgstr "``handle_accepted()``"

#: ../../library/asyncore.rst:104
msgid "Implied by a read event on a listening socket"
msgstr "Domyślne przy zdarzeniu czytania na nasłuchującym gnieździe"

#: ../../library/asyncore.rst:108
msgid ""
"During asynchronous processing, each mapped channel's :meth:`readable` and :"
"meth:`writable` methods are used to determine whether the channel's socket "
"should be added to the list of channels :c:func:`select`\\ ed or :c:func:"
"`poll`\\ ed for read and write events."
msgstr ""
"Під час асинхронної обробки методи кожного зіставленого каналу :meth:"
"`readable` і :meth:`writable` використовуються для визначення того, чи слід "
"додати сокет каналу до списку каналів :c:func:`select`\\ ed або :c:func:"
"`poll`\\ для подій читання та запису."

#: ../../library/asyncore.rst:113
msgid ""
"Thus, the set of channel events is larger than the basic socket events.  The "
"full set of methods that can be overridden in your subclass follows:"
msgstr ""
"Dlatego, zestaw zdarzeń kanałów jest większy, niż podstawowych zdarzeń "
"gniazda. Pełny zestaw sposobów postępowania, które mogą być przesłonięte w "
"twoim podrzędnym uogólnieniu jest następujący:"

#: ../../library/asyncore.rst:119
msgid ""
"Called when the asynchronous loop detects that a :meth:`read` call on the "
"channel's socket will succeed."
msgstr ""
"Wywoływane, gdy asynchroniczna pętla wykryje, że wywołanie :meth:`read` na "
"gnieździe kanału odniesie sukces."

#: ../../library/asyncore.rst:125
msgid ""
"Called when the asynchronous loop detects that a writable socket can be "
"written.  Often this method will implement the necessary buffering for "
"performance.  For example::"
msgstr ""
"Wywoływane, gdy asynchroniczna pętla wykryje, że możliwe do zapisu gniazdo "
"może być zapisane. Często ten sposób postępowania będzie wypełniał konieczne "
"wczytywanie z wyprzedzeniem dla poprawy wydajności. Dla przykładu::"

#: ../../library/asyncore.rst:136
msgid ""
"Called when there is out of band (OOB) data for a socket connection.  This "
"will almost never happen, as OOB is tenuously supported and rarely used."
msgstr ""
"Chamado quando há dados fora da banda (00B) para uma conexão socket. Isso "
"quase nunca acontece, como a 00B é suportada com tenacidade e raramente "
"usada."

#: ../../library/asyncore.rst:142
msgid ""
"Called when the active opener's socket actually makes a connection.  Might "
"send a \"welcome\" banner, or initiate a protocol negotiation with the "
"remote endpoint, for example."
msgstr ""
"Wywoływane gdy gniazdo aktywnego otwierającego właściwie wywoła połączenie. "
"Może wysłać \"powitalny\" banner, lub zainicjować negocjację protokołu z "
"zewnętrznym punktem końcowym, dla przykładu."

#: ../../library/asyncore.rst:149
msgid "Called when the socket is closed."
msgstr "Wywoływany gdy gniazdo jest zamykane."

#: ../../library/asyncore.rst:154
msgid ""
"Called when an exception is raised and not otherwise handled.  The default "
"version prints a condensed traceback."
msgstr ""
"Wywoływane gdy wyjątek jest zgłaszany i nie jest inaczej obsługiwany. "
"Domyślna wersja wypisuje skumulowany wypis."

#: ../../library/asyncore.rst:160
msgid ""
"Called on listening channels (passive openers) when a connection can be "
"established with a new remote endpoint that has issued a :meth:`connect` "
"call for the local endpoint. Deprecated in version 3.2; use :meth:"
"`handle_accepted` instead."
msgstr ""
"Викликається на каналах прослуховування (пасивні відкривачі), коли можна "
"встановити з’єднання з новою віддаленою кінцевою точкою, яка випустила "
"виклик :meth:`connect` для локальної кінцевої точки. Застаріло у версії 3.2; "
"замість цього використовуйте :meth:`handle_accepted`."

#: ../../library/asyncore.rst:170
msgid ""
"Called on listening channels (passive openers) when a connection has been "
"established with a new remote endpoint that has issued a :meth:`connect` "
"call for the local endpoint.  *sock* is a *new* socket object usable to send "
"and receive data on the connection, and *addr* is the address bound to the "
"socket on the other end of the connection."
msgstr ""
"Викликається на каналах прослуховування (пасивні відкривачі), коли "
"встановлено з’єднання з новою віддаленою кінцевою точкою, яка випустила "
"виклик :meth:`connect` для локальної кінцевої точки. *sock* — це *новий* "
"об’єкт сокета, який можна використовувати для надсилання та отримання даних "
"у з’єднанні, а *addr* — це адреса, прив’язана до сокета на іншому кінці "
"з’єднання."

#: ../../library/asyncore.rst:181
msgid ""
"Called each time around the asynchronous loop to determine whether a "
"channel's socket should be added to the list on which read events can "
"occur.  The default method simply returns ``True``, indicating that by "
"default, all channels will be interested in read events."
msgstr ""
"Wywoływane za każdym razem dla asynchronicznej pętli aby ustalić, czy "
"gniazdo kanału powinno być dodane do listy na której zdarzenia wczytywania "
"mogą następować. Domyślny sposób po prostu zwraca ``Prawdę`` - z ang. - "
"``True``, wskazując że domyślnie wszystkie kanały będą zainteresowane "
"zdarzeniami wczytywania."

#: ../../library/asyncore.rst:189
msgid ""
"Called each time around the asynchronous loop to determine whether a "
"channel's socket should be added to the list on which write events can "
"occur.  The default method simply returns ``True``, indicating that by "
"default, all channels will be interested in write events."
msgstr ""
"Wywoływane za każdym razem dla asynchronicznej pętli aby ustalić, czy "
"gniazdo kanału powinno być dodawane do listy na której zdarzenia zapisu mogą "
"następować. Domyślny sposób postępowania po prostu zwraca ``Prawdę`` - z "
"ang. - ``True``, wskazując że domyślnie, wszystkie kanały będą "
"zainteresowane zdarzeniami zapisu."

#: ../../library/asyncore.rst:195
msgid ""
"In addition, each channel delegates or extends many of the socket methods. "
"Most of these are nearly identical to their socket partners."
msgstr ""
"Na dodatek, każdy kanał deleguje lub rozszerza wiele ze sposobów "
"postępowania gniazd. Większość z tych jest prawie identyczna z ich "
"partnerami gniazda."

#: ../../library/asyncore.rst:201
msgid ""
"This is identical to the creation of a normal socket, and will use the same "
"options for creation.  Refer to the :mod:`socket` documentation for "
"information on creating sockets."
msgstr ""
"To jest identyczne z utworzeniem normalnego gniazda, i będzie używało tych "
"samych opcji dla tworzenia. Zajrzyj do dokumentacji do :mod:`socket` po "
"więcej informacji o tworzeniu gniazd."

#: ../../library/asyncore.rst:205
msgid "*family* and *type* arguments can be omitted."
msgstr "Аргументи *сімейство* і *тип* можна опустити."

#: ../../library/asyncore.rst:211
msgid ""
"As with the normal socket object, *address* is a tuple with the first "
"element the host to connect to, and the second the port number."
msgstr ""
"Tak jak z normalnymi przedmiotami gniazd, *adres* - z ang. - *address* jest "
"krotką z pierwszym elementem hosta do którego się podłącza, i drugim numerem "
"portu."

#: ../../library/asyncore.rst:217
msgid "Send *data* to the remote end-point of the socket."
msgstr ""
"Prześlij *dane* - z ang. - *data* do odległego punktu końcowego gniazda."

#: ../../library/asyncore.rst:222
msgid ""
"Read at most *buffer_size* bytes from the socket's remote end-point.  An "
"empty bytes object implies that the channel has been closed from the other "
"end."
msgstr ""
"Читати щонайбільше *buffer_size* байтів із віддаленої кінцевої точки сокета. "
"Порожній об’єкт bytes означає, що канал закрито з іншого боку."

#: ../../library/asyncore.rst:226
msgid ""
"Note that :meth:`recv` may raise :exc:`BlockingIOError` , even though :func:"
"`select.select` or :func:`select.poll` has reported the socket ready for "
"reading."
msgstr ""
"Зверніть увагу, що :meth:`recv` може викликати :exc:`BlockingIOError`, "
"навіть якщо :func:`select.select` або :func:`select.poll` повідомили, що "
"сокет готовий для читання."

#: ../../library/asyncore.rst:233
msgid ""
"Listen for connections made to the socket.  The *backlog* argument specifies "
"the maximum number of queued connections and should be at least 1; the "
"maximum value is system-dependent (usually 5)."
msgstr ""
"Nasłuchuj połączeń wykonywanych do gniazda. Parametr *wstecznego logu* - z "
"ang. - *backlog* określa maksymalną liczbę kolejkowanych połączeń i powinien "
"być równy przynajmniej 1; Wartość maksymalna jest zależna od systemu (zwykle "
"jest równa 5)."

#: ../../library/asyncore.rst:240
msgid ""
"Bind the socket to *address*.  The socket must not already be bound.  (The "
"format of *address* depends on the address family --- refer to the :mod:"
"`socket` documentation for more information.)  To mark the socket as re-"
"usable (setting the :const:`SO_REUSEADDR` option), call the :class:"
"`dispatcher` object's :meth:`set_reuse_addr` method."
msgstr ""
"Połącz gniazdo z *adresem*. Gniazdo nie może być już połączone z adresem. "
"(Format *adresu* zależy od rodziny adresów --- zajrzyj do dokumentacji :mod:"
"`socket` po więcej informacji.) Aby oznaczyć gniazdo jako możliwe do "
"ponownego użycia - z ang. - re-usable (ustawiając opcję :const:"
"`SO_REUSEADDR`), wywołaj sposób postępowania :meth:`set_reuse_addr` obiektu :"
"class:`dispatcher`."

#: ../../library/asyncore.rst:249
msgid ""
"Accept a connection.  The socket must be bound to an address and listening "
"for connections.  The return value can be either ``None`` or a pair ``(conn, "
"address)`` where *conn* is a *new* socket object usable to send and receive "
"data on the connection, and *address* is the address bound to the socket on "
"the other end of the connection. When ``None`` is returned it means the "
"connection didn't take place, in which case the server should just ignore "
"this event and keep listening for further incoming connections."
msgstr ""
"Прийняти підключення. Сокет має бути прив’язаний до адреси та прослуховувати "
"підключення. Поверненим значенням може бути ``None`` або пара ``(conn, "
"address)``, де *conn* — це *новий* об’єкт сокета, який можна використовувати "
"для надсилання та отримання даних під час з’єднання, а *address* — це "
"адресу, прив’язану до сокета на іншому кінці з’єднання. Коли повертається "
"\"None\", це означає, що з’єднання не відбулося, і в цьому випадку сервер "
"повинен просто проігнорувати цю подію та продовжувати прослуховувати "
"подальші вхідні з’єднання."

#: ../../library/asyncore.rst:261
msgid ""
"Close the socket.  All future operations on the socket object will fail. The "
"remote end-point will receive no more data (after queued data is flushed).  "
"Sockets are automatically closed when they are garbage-collected."
msgstr ""
"Zamknij gniazdo. Wszystkie przyszłe operacje na gnieździe zawiodą. Odległy "
"koniec nie dostanie więcej danych (po tym jak zakolejkowane dane zostaną "
"przesłane). Gniazda są automatycznie zamykane gdy są poddawane zbieraniu "
"śmieci."

#: ../../library/asyncore.rst:269
msgid ""
"A :class:`dispatcher` subclass which adds simple buffered output capability, "
"useful for simple clients. For more sophisticated usage use :class:`asynchat."
"async_chat`."
msgstr ""
"Підклас :class:`dispatcher`, який додає просту можливість буферизованого "
"виведення, корисну для простих клієнтів. Для більш складного використання "
"використовуйте :class:`asynchat.async_chat`."

#: ../../library/asyncore.rst:275
msgid ""
"A file_dispatcher takes a file descriptor or :term:`file object` along with "
"an optional map argument and wraps it for use with the :c:func:`poll` or :c:"
"func:`loop` functions.  If provided a file object or anything with a :c:func:"
"`fileno` method, that method will be called and passed to the :class:"
"`file_wrapper` constructor."
msgstr ""
"File_dispatcher приймає дескриптор файлу або :term:`file object` разом із "
"необов’язковим аргументом карти та обгортає його для використання з "
"функціями :c:func:`poll` або :c:func:`loop`. Якщо надати файловий об’єкт або "
"щось із методом :c:func:`fileno`, цей метод буде викликано та передано "
"конструктору :class:`file_wrapper`."

#: ../../library/asyncore.rst:281 ../../library/asyncore.rst:290
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`Availability <availability>`: Unix."

#: ../../library/asyncore.rst:285
msgid ""
"A file_wrapper takes an integer file descriptor and calls :func:`os.dup` to "
"duplicate the handle so that the original handle may be closed independently "
"of the file_wrapper.  This class implements sufficient methods to emulate a "
"socket for use by the :class:`file_dispatcher` class."
msgstr ""
"File_wrapper приймає цілочисельний файловий дескриптор і викликає :func:`os."
"dup`, щоб дублювати дескриптор, щоб вихідний дескриптор можна було закрити "
"незалежно від file_wrapper. Цей клас реалізує достатньо методів для емуляції "
"сокета для використання класом :class:`file_dispatcher`."

#: ../../library/asyncore.rst:296
msgid "asyncore Example basic HTTP client"
msgstr "Podstawowy klient HTTP Przykładu asyncore"

#: ../../library/asyncore.rst:298
msgid ""
"Here is a very basic HTTP client that uses the :class:`dispatcher` class to "
"implement its socket handling::"
msgstr ""
"Tu jest bardzo podstawowy klient HTTP który używa uogólnienia :class:"
"`dispatcher` do wypełnienia jego obsługi gniazda::"

#: ../../library/asyncore.rst:335
msgid "asyncore Example basic echo server"
msgstr "asyncore Приклад базового сервера відлуння"

#: ../../library/asyncore.rst:337
msgid ""
"Here is a basic echo server that uses the :class:`dispatcher` class to "
"accept connections and dispatches the incoming connections to a handler::"
msgstr ""
"Ось базовий ехо-сервер, який використовує клас :class:`dispatcher` для "
"прийняття з’єднань і відправляє вхідні з’єднання до обробника::"

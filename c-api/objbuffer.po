# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 16:41+0000\n"
"PO-Revision-Date: 2023-05-24 02:09+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../c-api/objbuffer.rst:4
msgid "Old Buffer Protocol"
msgstr "Старий буферний протокол"

#: ../../c-api/objbuffer.rst:8
msgid ""
"These functions were part of the \"old buffer protocol\" API in Python 2. In "
"Python 3, this protocol doesn't exist anymore but the functions are still "
"exposed to ease porting 2.x code.  They act as a compatibility wrapper "
"around the :ref:`new buffer protocol <bufferobjects>`, but they don't give "
"you control over the lifetime of the resources acquired when a buffer is "
"exported."
msgstr ""
"Ці функції були частиною API \"старого буферного протоколу\" в Python 2. У "
"Python 3 цей протокол більше не існує, але функції все ще доступні для "
"полегшення перенесення коду 2.x. Вони діють як обгортка сумісності навколо :"
"ref:`нового протоколу буфера <bufferobjects>`, але вони не дають вам "
"контролю над часом життя ресурсів, отриманих під час експорту буфера."

#: ../../c-api/objbuffer.rst:15
msgid ""
"Therefore, it is recommended that you call :c:func:`PyObject_GetBuffer` (or "
"the ``y*`` or ``w*`` :ref:`format codes <arg-parsing>` with the :c:func:"
"`PyArg_ParseTuple` family of functions) to get a buffer view over an object, "
"and :c:func:`PyBuffer_Release` when the buffer view can be released."
msgstr ""
"Тому рекомендується викликати :c:func:`PyObject_GetBuffer` (або ``y*`` чи "
"``w*`` :ref:`коди формату <arg-parsing>` з :c:func:`PyArg_ParseTuple` "
"сімейство функцій), щоб отримати перегляд буфера над об’єктом, і :c:func:"
"`PyBuffer_Release`, коли перегляд буфера може бути звільнений."

#: ../../c-api/objbuffer.rst:23
msgid ""
"Returns a pointer to a read-only memory location usable as character-based "
"input.  The *obj* argument must support the single-segment character buffer "
"interface.  On success, returns ``0``, sets *buffer* to the memory location "
"and *buffer_len* to the buffer length.  Returns ``-1`` and sets a :exc:"
"`TypeError` on error."
msgstr ""
"Повертає вказівник на місце пам’яті лише для читання, яке можна "
"використовувати як символьне введення. Аргумент *obj* повинен підтримувати "
"інтерфейс односегментного символьного буфера. У разі успіху повертає ``0``, "
"встановлює *buffer* у розташування пам’яті та *buffer_len* у значення "
"довжини буфера. Повертає ``-1`` і встановлює :exc:`TypeError` у разі помилки."

#: ../../c-api/objbuffer.rst:32
msgid ""
"Returns a pointer to a read-only memory location containing arbitrary data. "
"The *obj* argument must support the single-segment readable buffer "
"interface.  On success, returns ``0``, sets *buffer* to the memory location "
"and *buffer_len* to the buffer length.  Returns ``-1`` and sets a :exc:"
"`TypeError` on error."
msgstr ""
"Повертає вказівник на область пам’яті лише для читання, що містить довільні "
"дані. Аргумент *obj* повинен підтримувати односегментний читабельний "
"інтерфейс буфера. У разі успіху повертає ``0``, встановлює *buffer* у "
"розташування пам’яті та *buffer_len* у значення довжини буфера. Повертає "
"``-1`` і встановлює :exc:`TypeError` у разі помилки."

#: ../../c-api/objbuffer.rst:41
msgid ""
"Returns ``1`` if *o* supports the single-segment readable buffer interface. "
"Otherwise returns ``0``.  This function always succeeds."
msgstr ""
"Повертає ``1``, якщо *o* підтримує односегментний читабельний інтерфейс "
"буфера. Інакше повертає ``0``. Ця функція завжди успішна."

#: ../../c-api/objbuffer.rst:44
msgid ""
"Note that this function tries to get and release a buffer, and exceptions "
"which occur while calling corresponding functions will get suppressed. To "
"get error reporting use :c:func:`PyObject_GetBuffer()` instead."
msgstr ""
"Зверніть увагу, що ця функція намагається отримати та звільнити буфер, а "
"винятки, які виникають під час виклику відповідних функцій, будуть "
"придушені. Щоб отримати звіт про помилку, замість цього використовуйте :c:"
"func:`PyObject_GetBuffer()`."

#: ../../c-api/objbuffer.rst:51
msgid ""
"Returns a pointer to a writable memory location.  The *obj* argument must "
"support the single-segment, character buffer interface.  On success, returns "
"``0``, sets *buffer* to the memory location and *buffer_len* to the buffer "
"length.  Returns ``-1`` and sets a :exc:`TypeError` on error."
msgstr ""
"Повертає вказівник на область пам’яті, доступну для запису. Аргумент *obj* "
"повинен підтримувати односегментний інтерфейс символьного буфера. У разі "
"успіху повертає ``0``, встановлює *buffer* у розташування пам’яті та "
"*buffer_len* у значення довжини буфера. Повертає ``-1`` і встановлює :exc:"
"`TypeError` у разі помилки."

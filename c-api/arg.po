# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../c-api/arg.rst:6
msgid "Parsing arguments and building values"
msgstr "Análise de argumentos e construção de valores"

#: ../../c-api/arg.rst:8
msgid ""
"These functions are useful when creating your own extension functions and "
"methods.  Additional information and examples are available in :ref:"
"`extending-index`."
msgstr ""
"Essas funções são úteis ao criar suas próprias funções e métodos de "
"extensão. Informações adicionais e exemplos estão disponíveis em :ref:"
"`extending-index`."

#: ../../c-api/arg.rst:12
msgid ""
"The first three of these functions described, :c:func:`PyArg_ParseTuple`, :c:"
"func:`PyArg_ParseTupleAndKeywords`, and :c:func:`PyArg_Parse`, all use "
"*format strings* which are used to tell the function about the expected "
"arguments.  The format strings use the same syntax for each of these "
"functions."
msgstr ""
"As três primeiras funções descritas, :c:func:`PyArg_ParseTuple`, :c:func:"
"`PyArg_ParseTupleAndKeywords`, e :c:func:`PyArg_Parse`, todas usam a *string "
"de formatação* que informam à função sobre os argumentos esperados. As "
"strings de formato usam a mesma sintaxe para cada uma dessas funções."

#: ../../c-api/arg.rst:19
msgid "Parsing arguments"
msgstr "Análise de argumentos"

#: ../../c-api/arg.rst:21
msgid ""
"A format string consists of zero or more \"format units.\"  A format unit "
"describes one Python object; it is usually a single character or a "
"parenthesized sequence of format units.  With a few exceptions, a format "
"unit that is not a parenthesized sequence normally corresponds to a single "
"address argument to these functions.  In the following description, the "
"quoted form is the format unit; the entry in (round) parentheses is the "
"Python object type that matches the format unit; and the entry in [square] "
"brackets is the type of the C variable(s) whose address should be passed."
msgstr ""
"Uma string de formato consiste em zero ou mais \"unidades de formato\". Uma "
"unidade de formato descreve um objeto Python; geralmente é um único "
"caractere ou uma sequência entre parênteses de unidades de formato. Com "
"algumas poucas exceções, uma unidade de formato que não é uma sequência "
"entre parênteses normalmente corresponde a um único argumento de endereço "
"para essas funções. Na descrição a seguir, a forma citada é a unidade de "
"formato; a entrada em parênteses ( ) é o tipo de objeto Python que "
"corresponde à unidade de formato; e a entrada em colchetes [ ] é o tipo da "
"variável(s) C cujo endereço deve ser passado."

#: ../../c-api/arg.rst:33
msgid "Strings and buffers"
msgstr "Strings e buffers"

#: ../../c-api/arg.rst:37
msgid ""
"On Python 3.12 and older, the macro :c:macro:`!PY_SSIZE_T_CLEAN` must be "
"defined before including :file:`Python.h` to use all ``#`` variants of "
"formats (``s#``, ``y#``, etc.) explained below. This is not necessary on "
"Python 3.13 and later."
msgstr ""
"No Python 3.12 e anteriores, a macro :c:macro:`!PY_SSIZE_T_CLEAN` deve ser "
"definida antes da inclusão de :file:`Python.h` para usar todas as variantes "
"no formato ``#`` (``s#``, ``y#``, etc.) explicadas abaixo. Isso não é "
"necessário no Python 3.13 e posteriores."

#: ../../c-api/arg.rst:42
msgid ""
"These formats allow accessing an object as a contiguous chunk of memory. You "
"don't have to provide raw storage for the returned unicode or bytes area."
msgstr ""
"Esses formatos permitem acessar um objeto como um pedaço contíguo de "
"memória. Você não precisa fornecer armazenamento bruto para a área de "
"unicode ou bytes retornada."

#: ../../c-api/arg.rst:46
msgid "Unless otherwise stated, buffers are not NUL-terminated."
msgstr "Salvo indicação em contrário, os buffers não são terminados em NUL."

#: ../../c-api/arg.rst:48
msgid "There are three ways strings and buffers can be converted to C:"
msgstr ""
"Existem três maneiras pelas quais strings e buffers podem ser convertidos em "
"C:"

#: ../../c-api/arg.rst:50
msgid ""
"Formats such as ``y*`` and ``s*`` fill a :c:type:`Py_buffer` structure. This "
"locks the underlying buffer so that the caller can subsequently use the "
"buffer even inside a :c:type:`Py_BEGIN_ALLOW_THREADS` block without the risk "
"of mutable data being resized or destroyed. As a result, **you have to "
"call** :c:func:`PyBuffer_Release` after you have finished processing the "
"data (or in any early abort case)."
msgstr ""
"Formatos como ``y*`` e ``s*`` estão dentro de uma estrutura :c:type:"
"`Py_buffer`.  Isso bloqueia o buffer  subjacente para que o chamador  possa "
"posteriormente usar o buffer, mesmo dentro de um bloco :c:type:"
"`Py_BEGIN_ALLOW_THREADS` sem que haja o risco de que dados mutáveis sejam "
"redimensionados ou destruídos. Dessa forma, **você precisa chamar** :c:func:"
"`PyBuffer_Release` depois de ter concluído o processamento de dados (ou em "
"qualquer caso de interrupção precoce)."

#: ../../c-api/arg.rst:57
msgid ""
"The ``es``, ``es#``, ``et`` and ``et#`` formats allocate the result buffer. "
"**You have to call** :c:func:`PyMem_Free` after you have finished processing "
"the data (or in any early abort case)."
msgstr ""
"Os formatos ``es``, ``es#``, ``et`` e ``et#`` alocam o buffer resultante. "
"**Você precisa chamar** :c:func:`PyMem_Free` depois de ter concluído o "
"processamento de dados (ou em qualquer caso de interrupção precoce)."

#: ../../c-api/arg.rst:63
msgid ""
"Other formats take a :class:`str` or a read-only :term:`bytes-like object`, "
"such as :class:`bytes`, and provide a ``const char *`` pointer to its "
"buffer. In this case the buffer is \"borrowed\": it is managed by the "
"corresponding Python object, and shares the lifetime of this object. You "
"won't have to release any memory yourself."
msgstr ""
"Outros formatos usam um :class:`str` ou um :term:`objeto bytes ou similar` "
"somente leitura, como :class:`bytes`, e fornecem um ponteiro ``const char "
"*`` para seu buffer. Nesse caso, o buffer é \"emprestado\": ele é gerenciado "
"pelo objeto Python correspondente e compartilha o tempo de vida desse "
"objeto. Você mesmo não precisará liberar nenhuma memória."

#: ../../c-api/arg.rst:70
msgid ""
"To ensure that the underlying buffer may be safely borrowed, the object's :c:"
"member:`PyBufferProcs.bf_releasebuffer` field must be ``NULL``. This "
"disallows common mutable objects such as :class:`bytearray`, but also some "
"read-only objects such as :class:`memoryview` of :class:`bytes`."
msgstr ""
"Para garantir que o buffer subjacente possa ser emprestado com segurança, o "
"campo :c:member:`PyBufferProcs.bf_releasebuffer` do objeto deve ser "
"``NULL``. Isso não permite objetos mutáveis comuns, como :class:`bytearray`, "
"mas também alguns objetos somente leitura, como :class:`memoryview` ou :"
"class:`bytes`."

#: ../../c-api/arg.rst:76
msgid ""
"Besides this ``bf_releasebuffer`` requirement, there is no check to verify "
"whether the input object is immutable (e.g. whether it would honor a request "
"for a writable buffer, or whether another thread can mutate the data)."
msgstr ""
"Além desse requisito ``bf_releasebuffer``, não há nenhuma verificação para "
"saber se o objeto de entrada é imutável (por exemplo, se ele atenderia a uma "
"solicitação de um buffer gravável ou se outro thread pode alterar os dados)."

#: ../../c-api/arg.rst:80
msgid "``s`` (:class:`str`) [const char \\*]"
msgstr "``s`` (:class:`str`) [const char \\*]"

#: ../../c-api/arg.rst:81
msgid ""
"Convert a Unicode object to a C pointer to a character string. A pointer to "
"an existing string is stored in the character pointer variable whose address "
"you pass.  The C string is NUL-terminated. The Python string must not "
"contain embedded null code points; if it does, a :exc:`ValueError` exception "
"is raised. Unicode objects are converted to C strings using ``'utf-8'`` "
"encoding. If this conversion fails, a :exc:`UnicodeError` is raised."
msgstr ""
"Converte um objeto Unicode para um ponteiro em C para uma string. Um "
"ponteiro para uma string existente é armazenado na variável do ponteiro do "
"caractere cujo o endereço que você está passando. A string em C é terminada "
"em NULO. A string no Python não deve conter pontos de código nulo embutidos; "
"se isso acontecer, uma exceção :exc:`ValueError` é levantada. Objetos "
"Unicode são convertidos para strings em C usando a codificação ``'utf-8'``. "
"Se essa conversão falhar, uma exceção :exc:`UnicodeError` é levantada."

#: ../../c-api/arg.rst:90
msgid ""
"This format does not accept :term:`bytes-like objects <bytes-like object>`.  "
"If you want to accept filesystem paths and convert them to C character "
"strings, it is preferable to use the ``O&`` format with :c:func:"
"`PyUnicode_FSConverter` as *converter*."
msgstr ""
"Esse formato não aceita :term:`objetos bytes ou similares <bytes-like "
"object>`. Se você quer aceitar caminhos de sistema de arquivos e convertê-"
"los para strings de caracteres em C, é preferível que use o formato ``O&`` "
"com :c:func:`PyUnicode_FSConverter` como *conversor*."

#: ../../c-api/arg.rst:96
msgid ""
"Previously, :exc:`TypeError` was raised when embedded null code points were "
"encountered in the Python string."
msgstr ""
"Anteriormente, a exceção :exc:`TypeError` era levantada quando pontos de "
"código nulo embutidos em string Python eram encontrados."

#: ../../c-api/arg.rst:100
msgid "``s*`` (:class:`str` or :term:`bytes-like object`) [Py_buffer]"
msgstr "``s*`` (:class:`str` ou :term:`objeto bytes ou similar`) [Py_buffer]"

#: ../../c-api/arg.rst:101
msgid ""
"This format accepts Unicode objects as well as bytes-like objects. It fills "
"a :c:type:`Py_buffer` structure provided by the caller. In this case the "
"resulting C string may contain embedded NUL bytes. Unicode objects are "
"converted to C strings using ``'utf-8'`` encoding."
msgstr ""
"Esse formato aceita tanto objetos Unicode quanto objetos bytes ou similares. "
"Preenche uma estrutura :c:type:`Py_buffer` fornecida pelo chamador. Nesse "
"caso, a string em C resultante pode conter bytes NUL embutidos. Objetos "
"Unicode são convertidos para strings em C usando codificação ``'utf-8'``."

#: ../../c-api/arg.rst:106
msgid ""
"``s#`` (:class:`str`, read-only :term:`bytes-like object`) [const char \\*, :"
"c:type:`Py_ssize_t`]"
msgstr ""
"``s#`` (:class:`str`, :term:`objeto bytes ou similar <bytes-like object>` "
"somente leitura) [const char \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:107
msgid ""
"Like ``s*``, except that it provides a :ref:`borrowed buffer <c-arg-borrowed-"
"buffer>`. The result is stored into two C variables, the first one a pointer "
"to a C string, the second one its length. The string may contain embedded "
"null bytes. Unicode objects are converted to C strings using ``'utf-8'`` "
"encoding."
msgstr ""
"Como ``s*``, exceto que não fornece um :ref:`buffer emprestado <c-arg-"
"borrowed-buffer>`. O resultado é armazenado em duas variáveis em C, a "
"primeira é um ponteiro para uma string em C, a segunda é o tamanho. A string "
"pode conter bytes nulos embutidos. Objetos Unicode são convertidos para "
"strings em C usando codificação ``'utf-8'``."

#: ../../c-api/arg.rst:113 ../../c-api/arg.rst:614
msgid "``z`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``z`` (:class:`str` ou ``None``) [const char \\*]"

#: ../../c-api/arg.rst:114
msgid ""
"Like ``s``, but the Python object may also be ``None``, in which case the C "
"pointer is set to ``NULL``."
msgstr ""

#: ../../c-api/arg.rst:117
msgid ""
"``z*`` (:class:`str`, :term:`bytes-like object` or ``None``) [Py_buffer]"
msgstr ""
"``z*`` (:class:`str`, :term:`objeto bytes ou similar` ou ``None``) "
"[Py_buffer]"

#: ../../c-api/arg.rst:118
msgid ""
"Like ``s*``, but the Python object may also be ``None``, in which case the "
"``buf`` member of the :c:type:`Py_buffer` structure is set to ``NULL``."
msgstr ""

#: ../../c-api/arg.rst:121
msgid ""
"``z#`` (:class:`str`, read-only :term:`bytes-like object` or ``None``) "
"[const char \\*, :c:type:`Py_ssize_t`]"
msgstr ""
"``z#`` (:class:`str`, :term:`objeto bytes ou similar` somente leitura ou "
"``None``) [const char \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:122
msgid ""
"Like ``s#``, but the Python object may also be ``None``, in which case the C "
"pointer is set to ``NULL``."
msgstr ""

#: ../../c-api/arg.rst:125
msgid "``y`` (read-only :term:`bytes-like object`) [const char \\*]"
msgstr ""
"``y`` (:term:`objeto bytes ou similar` somente leitura) [const char \\*]"

#: ../../c-api/arg.rst:126
msgid ""
"This format converts a bytes-like object to a C pointer to a :ref:`borrowed "
"<c-arg-borrowed-buffer>` character string; it does not accept Unicode "
"objects.  The bytes buffer must not contain embedded null bytes; if it does, "
"a :exc:`ValueError` exception is raised."
msgstr ""
"Este formato converte um objeto bytes ou similar para um ponteiro C para uma "
"string de caracteres :ref:`emprestada <c-arg-borrowed-buffer>`; não aceita "
"objetos Unicode. O buffer de bytes não pode conter bytes nulos embutidos; se "
"isso ocorrer uma exceção :exc:`ValueError` será levantada."

#: ../../c-api/arg.rst:132
msgid ""
"Previously, :exc:`TypeError` was raised when embedded null bytes were "
"encountered in the bytes buffer."
msgstr ""
"Anteriormente, a exceção :exc:`TypeError` era levantada quando pontos de "
"código nulo embutidos em string Python eram encontrados no buffer de bytes."

#: ../../c-api/arg.rst:136
msgid "``y*`` (:term:`bytes-like object`) [Py_buffer]"
msgstr "``y*`` (:term:`objeto bytes ou similar`) [Py_buffer]"

#: ../../c-api/arg.rst:137
msgid ""
"This variant on ``s*`` doesn't accept Unicode objects, only bytes-like "
"objects.  **This is the recommended way to accept binary data.**"
msgstr ""
"Esta variante em ``s*`` não aceita objetos unicode, apenas objetos bytes ou "
"similares. **Esta é a maneira recomendada para aceitar dados binários.**"

#: ../../c-api/arg.rst:141
msgid ""
"``y#`` (read-only :term:`bytes-like object`) [const char \\*, :c:type:"
"`Py_ssize_t`]"
msgstr ""
"``y#`` (:term:`objeto bytes ou similar` somente leitura) [const char \\*, :c:"
"type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:142
msgid ""
"This variant on ``s#`` doesn't accept Unicode objects, only bytes-like "
"objects."
msgstr ""
"Esta variação de ``s#`` não aceita objetos Unicode, apenas objetos bytes ou "
"similares."

#: ../../c-api/arg.rst:145
msgid "``S`` (:class:`bytes`) [PyBytesObject \\*]"
msgstr "``S`` (:class:`bytes`) [PyBytesObject \\*]"

#: ../../c-api/arg.rst:146
msgid ""
"Requires that the Python object is a :class:`bytes` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a "
"bytes object.  The C variable may also be declared as :c:expr:`PyObject*`."
msgstr ""
"Exige que o objeto Python seja um objeto :class:`bytes`, sem tentar nenhuma "
"conversão. Levanta :exc:`TypeError` se o objeto não for um objeto byte. A "
"variável C pode ser declarada como :c:expr:`PyObject*`."

#: ../../c-api/arg.rst:150
msgid "``Y`` (:class:`bytearray`) [PyByteArrayObject \\*]"
msgstr "``Y`` (:class:`bytearray`) [PyByteArrayObject \\*]"

#: ../../c-api/arg.rst:151
msgid ""
"Requires that the Python object is a :class:`bytearray` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a :"
"class:`bytearray` object. The C variable may also be declared as :c:expr:"
"`PyObject*`."
msgstr ""
"Exige que o objeto Python seja um objeto :class:`bytearray`, sem aceitar "
"qualquer conversão.  Levanta :exc:`TypeError` se o objeto não é um objeto :"
"class:`bytearray`. A variável C apenas pode ser declarada como :c:expr:"
"`PyObject*`."

#: ../../c-api/arg.rst:155
msgid "``U`` (:class:`str`) [PyObject \\*]"
msgstr "``U`` (:class:`str`) [PyObject \\*]"

#: ../../c-api/arg.rst:156
msgid ""
"Requires that the Python object is a Unicode object, without attempting any "
"conversion.  Raises :exc:`TypeError` if the object is not a Unicode object.  "
"The C variable may also be declared as :c:expr:`PyObject*`."
msgstr ""
"Exige que o objeto python seja um objeto Unicode, sem tentar alguma "
"conversão. Levanta :exc:`TypeError` se o objeto não for um objeto Unicode. A "
"variável C deve ser declarada como :c:expr:`PyObject*`."

#: ../../c-api/arg.rst:160
msgid "``w*`` (read-write :term:`bytes-like object`) [Py_buffer]"
msgstr ""
"``w*`` (:term:`objeto bytes ou similar` de leitura e escrita) [Py_buffer]"

#: ../../c-api/arg.rst:161
msgid ""
"This format accepts any object which implements the read-write buffer "
"interface. It fills a :c:type:`Py_buffer` structure provided by the caller. "
"The buffer may contain embedded null bytes. The caller have to call :c:func:"
"`PyBuffer_Release` when it is done with the buffer."
msgstr ""
"Este formato aceita qualquer objeto que implemente a interface do buffer de "
"leitura e escrita. Ele preenche uma estrutura :c:type:`Py_buffer` fornecida "
"pelo chamador. O buffer pode conter bytes nulos incorporados. O chamador "
"deve chamar :c:func:`PyBuffer_Release` quando isso for feito com o buffer."

#: ../../c-api/arg.rst:166
msgid "``es`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer]"
msgstr "``es`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer]"

#: ../../c-api/arg.rst:167
msgid ""
"This variant on ``s`` is used for encoding Unicode into a character buffer. "
"It only works for encoded data without embedded NUL bytes."
msgstr ""
"Esta variante em ``s`` é utilizada para codificação do Unicode em um buffer "
"de caracteres. Ele só funciona para dados codificados sem NUL bytes "
"incorporados."

#: ../../c-api/arg.rst:170
msgid ""
"This format requires two arguments.  The first is only used as input, and "
"must be a :c:expr:`const char*` which points to the name of an encoding as a "
"NUL-terminated string, or ``NULL``, in which case ``'utf-8'`` encoding is "
"used. An exception is raised if the named encoding is not known to Python.  "
"The second argument must be a :c:expr:`char**`; the value of the pointer it "
"references will be set to a buffer with the contents of the argument text. "
"The text will be encoded in the encoding specified by the first argument."
msgstr ""
"Este formato exige dois argumentos. O primeiro é usado apenas como entrada e "
"deve ser a :c:expr:`const char*` que aponta para o nome de uma codificação "
"como uma string terminada em NUL ou ``NULL``, nesse caso a codificação "
"``'utf-8'`` é usada. Uma exceção é levantada se a codificação nomeada não "
"for conhecida pelo Python. O segundo argumento deve ser um :c:expr:`char**`; "
"o valor do ponteiro a que ele faz referência será definido como um buffer "
"com o conteúdo do texto do argumento. O texto será codificado na codificação "
"especificada pelo primeiro argumento."

#: ../../c-api/arg.rst:178
msgid ""
":c:func:`PyArg_ParseTuple` will allocate a buffer of the needed size, copy "
"the encoded data into this buffer and adjust *\\*buffer* to reference the "
"newly allocated storage.  The caller is responsible for calling :c:func:"
"`PyMem_Free` to free the allocated buffer after use."
msgstr ""
":c:func:`PyArg_ParseTuple` alocará um buffer do tamanho necessário, copiará "
"os dados codificados nesse buffer e ajustará *\\*buffer* para referenciar o "
"armazenamento recém-alocado. O chamador é responsável por chamar :c:func:"
"`PyMem_Free` para liberar o buffer alocado após o uso."

#: ../../c-api/arg.rst:183
msgid ""
"``et`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer]"
msgstr ""
"``et`` (:class:`str`, :class:`bytes` ou :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer]"

#: ../../c-api/arg.rst:184
msgid ""
"Same as ``es`` except that byte string objects are passed through without "
"recoding them.  Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr ""
"O mesmo que ``es``, exceto que os objetos strings de bytes são passados sem "
"os recodificar. Em vez disso, a implementação presume que o objeto string de "
"bytes usa a codificação passada como parâmetro."

#: ../../c-api/arg.rst:188
msgid ""
"``es#`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer, :c:type:"
"`Py_ssize_t` \\*buffer_length]"
msgstr ""
"``es#`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer, :c:type:"
"`Py_ssize_t` \\*buffer_length]"

#: ../../c-api/arg.rst:189
msgid ""
"This variant on ``s#`` is used for encoding Unicode into a character buffer. "
"Unlike the ``es`` format, this variant allows input data which contains NUL "
"characters."
msgstr ""
"Essa variante em ``s#`` é usada para codificar Unicode em um buffer de "
"caracteres. Diferente do formato ``es``, essa variante permite a entrada de "
"dados que contêm caracteres NUL."

#: ../../c-api/arg.rst:193
msgid ""
"It requires three arguments.  The first is only used as input, and must be "
"a :c:expr:`const char*` which points to the name of an encoding as a NUL-"
"terminated string, or ``NULL``, in which case ``'utf-8'`` encoding is used. "
"An exception is raised if the named encoding is not known to Python.  The "
"second argument must be a :c:expr:`char**`; the value of the pointer it "
"references will be set to a buffer with the contents of the argument text. "
"The text will be encoded in the encoding specified by the first argument. "
"The third argument must be a pointer to an integer; the referenced integer "
"will be set to the number of bytes in the output buffer."
msgstr ""
"Exige três argumentos. O primeiro é usado apenas como entrada e deve ser a :"
"c:expr:`const char*` que aponta para o nome de uma codificação como uma "
"string terminada em NUL ou ``NULL``, nesse caso a codificação ``'utf-8'`` é "
"usada. Uma exceção será gerada se a codificação nomeada não for conhecida "
"pelo Python. O segundo argumento deve ser um :c:expr:`char**`; o valor do "
"ponteiro a que ele faz referência será definido como um buffer com o "
"conteúdo do texto do argumento. O texto será codificado na codificação "
"especificada pelo primeiro argumento. O terceiro argumento deve ser um "
"ponteiro para um número inteiro; o número inteiro referenciado será definido "
"como o número de bytes no buffer de saída."

#: ../../c-api/arg.rst:203
msgid "There are two modes of operation:"
msgstr "Há dois modos de operação:"

#: ../../c-api/arg.rst:205
msgid ""
"If *\\*buffer* points a ``NULL`` pointer, the function will allocate a "
"buffer of the needed size, copy the encoded data into this buffer and set "
"*\\*buffer* to reference the newly allocated storage.  The caller is "
"responsible for calling :c:func:`PyMem_Free` to free the allocated buffer "
"after usage."
msgstr ""
"Se *\\*buffer* apontar um ponteiro ``NULL``, a função irá alocar um buffer "
"do tamanho necessário, copiar os dados codificados para dentro desse buffer "
"e configurar *\\*buffer* para referenciar o novo armazenamento alocado. O "
"chamador é responsável por chamar :c:func:`PyMem_Free` para liberar o buffer "
"alocado após o uso."

#: ../../c-api/arg.rst:210
msgid ""
"If *\\*buffer* points to a non-``NULL`` pointer (an already allocated "
"buffer), :c:func:`PyArg_ParseTuple` will use this location as the buffer and "
"interpret the initial value of *\\*buffer_length* as the buffer size.  It "
"will then copy the encoded data into the buffer and NUL-terminate it.  If "
"the buffer is not large enough, a :exc:`ValueError` will be set."
msgstr ""
"Se *\\*buffer* apontar para um ponteiro que não seja ``NULL`` (um buffer já "
"alocado), :c:func:`PyArg_ParseTuple` irá usar essa localização como buffer e "
"interpretar o valor inicial de *\\*buffer_length* como sendo o tamanho do "
"buffer. Depois ela vai copiar os dados codificados para dentro do buffer e "
"terminá-lo com NUL. Se o buffer não for suficientemente grande, um :exc:"
"`ValueError` será definido."

#: ../../c-api/arg.rst:216
msgid ""
"In both cases, *\\*buffer_length* is set to the length of the encoded data "
"without the trailing NUL byte."
msgstr ""
"Em ambos os casos, o *\\*buffer_length* é definido como o comprimento dos "
"dados codificados sem o byte NUL à direita."

#: ../../c-api/arg.rst:219
msgid ""
"``et#`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer, :c:type:`Py_ssize_t` \\*buffer_length]"
msgstr ""
"``et#`` (:class:`str`, :class:`bytes` ou :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer, :c:type:`Py_ssize_t` \\*buffer_length]"

#: ../../c-api/arg.rst:220
msgid ""
"Same as ``es#`` except that byte string objects are passed through without "
"recoding them. Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr ""
"O mesmo que ``es#``, exceto que os objetos strings de bytes são passados sem "
"que sejam recodificados. Em vez disso, a implementação presume que o objeto "
"string de bytes usa a codificação passada como parâmetro."

#: ../../c-api/arg.rst:224
msgid ""
"``u``, ``u#``, ``Z``, and ``Z#`` are removed because they used a legacy "
"``Py_UNICODE*`` representation."
msgstr ""
"``u``, ``u#``, ``Z`` e ``Z#`` foram removidos porque usavam uma "
"representação herdada de ``Py_UNICODE*``."

#: ../../c-api/arg.rst:230
msgid "Numbers"
msgstr "Números"

#: ../../c-api/arg.rst:232
msgid ""
"These formats allow representing Python numbers or single characters as C "
"numbers. Formats that require :class:`int`, :class:`float` or :class:"
"`complex` can also use the corresponding special methods :meth:`~object."
"__index__`, :meth:`~object.__float__` or :meth:`~object.__complex__` to "
"convert the Python object to the required type."
msgstr ""
"Esses formatos permitem representar números Python ou caracteres únicos como "
"números C. Formatos que exigem :class:`int`, :class:`float` ou :class:"
"`complex` também podem usar os métodos especiais correspondentes :meth:"
"`~object.__index__`, :meth:`~object.__float__` ou :meth:`~object."
"__complex__` para converter o objeto Python para o tipo necessário."

#: ../../c-api/arg.rst:238
msgid ""
"For signed integer formats, :exc:`OverflowError` is raised if the value is "
"out of range for the C type. For unsigned integer formats, no range checking "
"is done --- the most significant bits are silently truncated when the "
"receiving field is too small to receive the value."
msgstr ""
"Para formatos inteiros com sinal, :exc:`OverflowError` é levantada se o "
"valor estiver fora do intervalo para o tipo C. Para formatos inteiros não "
"assinados, nenhuma verificação de intervalo é feita --- os bits mais "
"significativos são silenciosamente truncados quando o campo de recebimento é "
"muito pequeno para receber o valor."

#: ../../c-api/arg.rst:244
msgid "``b`` (:class:`int`) [unsigned char]"
msgstr "``b`` (:class:`int`) [unsigned char]"

#: ../../c-api/arg.rst:245
msgid ""
"Convert a nonnegative Python integer to an unsigned tiny integer, stored in "
"a C :c:expr:`unsigned char`."
msgstr ""
"Converte um inteiro Python não negativo em um inteiro pequeno sem sinal "
"(unsigned tiny integer), armazenado em um :c:expr:`unsigned char` do C."

#: ../../c-api/arg.rst:248 ../../c-api/arg.rst:648
msgid "``B`` (:class:`int`) [unsigned char]"
msgstr "``B`` (:class:`int`) [unsigned char]"

#: ../../c-api/arg.rst:249
msgid ""
"Convert a Python integer to a tiny integer without overflow checking, stored "
"in a C :c:expr:`unsigned char`."
msgstr ""
"Converte um inteiro Python para um inteiro pequeno (tiny integer) sem "
"verificação de estouro, armazenado em um :c:expr:`unsigned char` do C."

#: ../../c-api/arg.rst:252 ../../c-api/arg.rst:642
msgid "``h`` (:class:`int`) [short int]"
msgstr "``h`` (:class:`int`) [short int]"

#: ../../c-api/arg.rst:253
msgid "Convert a Python integer to a C :c:expr:`short int`."
msgstr "Converte um inteiro Python para um :c:expr:`short int` do C."

#: ../../c-api/arg.rst:255 ../../c-api/arg.rst:651
msgid "``H`` (:class:`int`) [unsigned short int]"
msgstr "``H`` (:class:`int`) [unsigned short int]"

#: ../../c-api/arg.rst:256
msgid ""
"Convert a Python integer to a C :c:expr:`unsigned short int`, without "
"overflow checking."
msgstr ""
"Converte um inteiro Python para um :c:expr:`unsigned short int` do C, sem "
"verificação de estouro."

#: ../../c-api/arg.rst:259 ../../c-api/arg.rst:636
msgid "``i`` (:class:`int`) [int]"
msgstr "``i`` (:class:`int`) [int]"

#: ../../c-api/arg.rst:260
msgid "Convert a Python integer to a plain C :c:expr:`int`."
msgstr "Converte um inteiro Python para um :c:expr:`int` simples do C."

#: ../../c-api/arg.rst:262 ../../c-api/arg.rst:654
msgid "``I`` (:class:`int`) [unsigned int]"
msgstr "``I`` (:class:`int`) [unsigned int]"

#: ../../c-api/arg.rst:263
msgid ""
"Convert a Python integer to a C :c:expr:`unsigned int`, without overflow "
"checking."
msgstr ""
"Converte um inteiro Python para um :c:expr:`unsigned int` do C, sem "
"verificação de estouro."

#: ../../c-api/arg.rst:266 ../../c-api/arg.rst:645
msgid "``l`` (:class:`int`) [long int]"
msgstr "``l`` (:class:`int`) [long int]"

#: ../../c-api/arg.rst:267
msgid "Convert a Python integer to a C :c:expr:`long int`."
msgstr "Converte um inteiro Python para um :c:expr:`long int` do C."

#: ../../c-api/arg.rst:269 ../../c-api/arg.rst:657
msgid "``k`` (:class:`int`) [unsigned long]"
msgstr "``k`` (:class:`int`) [unsigned long]"

#: ../../c-api/arg.rst:270
msgid ""
"Convert a Python integer to a C :c:expr:`unsigned long` without overflow "
"checking."
msgstr ""
"Converte um inteiro Python para um :c:expr:`unsigned long` do C sem "
"verificação de estouro."

#: ../../c-api/arg.rst:273 ../../c-api/arg.rst:283
msgid "Use :meth:`~object.__index__` if available."
msgstr "Usa :meth:`~object.__index__`, se disponível."

#: ../../c-api/arg.rst:276 ../../c-api/arg.rst:660
msgid "``L`` (:class:`int`) [long long]"
msgstr "``L`` (:class:`int`) [longo longo]"

#: ../../c-api/arg.rst:277
msgid "Convert a Python integer to a C :c:expr:`long long`."
msgstr "Converte um inteiro Python para um :c:expr:`long long` do C."

#: ../../c-api/arg.rst:279 ../../c-api/arg.rst:665
msgid "``K`` (:class:`int`) [unsigned long long]"
msgstr "``K`` (:class:`int`) [unsigned long long]"

#: ../../c-api/arg.rst:280
msgid ""
"Convert a Python integer to a C :c:expr:`unsigned long long` without "
"overflow checking."
msgstr ""
"Converte um inteiro Python para um :c:expr:`unsigned long long` do C sem "
"verificação de estouro."

#: ../../c-api/arg.rst:286 ../../c-api/arg.rst:668
msgid "``n`` (:class:`int`) [:c:type:`Py_ssize_t`]"
msgstr "``n`` (:class:`int`) [:c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:287
msgid "Convert a Python integer to a C :c:type:`Py_ssize_t`."
msgstr "Converte um inteiro Python para um :c:type:`Py_ssize_t` do C."

#: ../../c-api/arg.rst:289
msgid "``c`` (:class:`bytes` or :class:`bytearray` of length 1) [char]"
msgstr "``c`` (:class:`bytes` ou :class:`bytearray` de comprimento 1) [char]"

#: ../../c-api/arg.rst:290
msgid ""
"Convert a Python byte, represented as a :class:`bytes` or :class:`bytearray` "
"object of length 1, to a C :c:expr:`char`."
msgstr ""
"Converte um byte Python, representado com um objeto :class:`byte` ou :class:"
"`bytearray` de comprimento 1, para um :c:expr:`char` do C."

#: ../../c-api/arg.rst:293
msgid "Allow :class:`bytearray` objects."
msgstr "Permite objetos :class:`bytearray`."

#: ../../c-api/arg.rst:296 ../../c-api/arg.rst:686
msgid "``C`` (:class:`str` of length 1) [int]"
msgstr "``C`` (:class:`str` de comprimento 1) [int]"

#: ../../c-api/arg.rst:297
msgid ""
"Convert a Python character, represented as a :class:`str` object of length "
"1, to a C :c:expr:`int`."
msgstr ""
"Converte um caractere Python, representado como uma :class:`str` objeto de "
"comprimento 1, para um :c:expr:`int` do C"

#: ../../c-api/arg.rst:300 ../../c-api/arg.rst:693
msgid "``f`` (:class:`float`) [float]"
msgstr "``f``` (:class:`float`) [float]"

#: ../../c-api/arg.rst:301
msgid "Convert a Python floating-point number to a C :c:expr:`float`."
msgstr ""
"Converte um número de ponto flutuante Python para um :c:expr:`float` do C."

#: ../../c-api/arg.rst:303 ../../c-api/arg.rst:690
msgid "``d`` (:class:`float`) [double]"
msgstr "``d`` (:class:`float`) [double]"

#: ../../c-api/arg.rst:304
msgid "Convert a Python floating-point number to a C :c:expr:`double`."
msgstr ""
"Converte um número de ponto flutuante Python para um :c:expr:`double` do C."

#: ../../c-api/arg.rst:306
msgid "``D`` (:class:`complex`) [Py_complex]"
msgstr "``D`` (:class:`complex`) [Py_complex]"

#: ../../c-api/arg.rst:307
msgid "Convert a Python complex number to a C :c:type:`Py_complex` structure."
msgstr ""
"Converte um número complexo Python para uma estrutura C :c:type:`Py_complex`"

#: ../../c-api/arg.rst:310
msgid "Other objects"
msgstr "Outros objetos"

#: ../../c-api/arg.rst:312 ../../c-api/arg.rst:699
msgid "``O`` (object) [PyObject \\*]"
msgstr "``O`` (objeto) [PyObject\\*]"

#: ../../c-api/arg.rst:313
msgid ""
"Store a Python object (without any conversion) in a C object pointer.  The C "
"program thus receives the actual object that was passed.  A new :term:"
"`strong reference` to the object is not created (i.e. its reference count is "
"not increased). The pointer stored is not ``NULL``."
msgstr ""
"Armazena um objeto Python (sem qualquer conversão) em um ponteiro de objeto "
"C. O programa C então recebe o objeto real que foi passado. Uma nova :term:"
"`referência forte` ao objeto não é criado (isto é sua contagem de "
"referências não é aumentada). O ponteiro armazenado não é ``NULL``."

#: ../../c-api/arg.rst:319
msgid "``O!`` (object) [*typeobject*, PyObject \\*]"
msgstr "``O!`` (objeto) [*typeobject*, PyObject \\*]"

#: ../../c-api/arg.rst:320
msgid ""
"Store a Python object in a C object pointer.  This is similar to ``O``, but "
"takes two C arguments: the first is the address of a Python type object, the "
"second is the address of the C variable (of type :c:expr:`PyObject*`) into "
"which the object pointer is stored.  If the Python object does not have the "
"required type, :exc:`TypeError` is raised."
msgstr ""
"Armazena um objeto Python em um ponteiro de objeto C. Isso é similar a "
"``O``, mas usa dois argumentos C: o primeiro é o endereço de um objeto do "
"tipo Python, o segundo é um endereço da variável C (de tipo :c:expr:"
"`PyObject*`) no qual o ponteiro do objeto está armazenado. Se o objeto "
"Python não tiver o tipo necessário, :exc:`TypeError` é levantada."

#: ../../c-api/arg.rst:328
msgid "``O&`` (object) [*converter*, *address*]"
msgstr "``O&`` (objeto) [*converter*, *address*]"

#: ../../c-api/arg.rst:329
msgid ""
"Convert a Python object to a C variable through a *converter* function.  "
"This takes two arguments: the first is a function, the second is the address "
"of a C variable (of arbitrary type), converted to :c:expr:`void *`.  The "
"*converter* function in turn is called as follows::"
msgstr ""
"Converte um objeto Python em uma variável C através de uma função "
"*converter*. Isso leva dois argumentos: o primeiro é a função, o segundo é o "
"endereço da variável C (de tipo arbitrário), convertendo para :c:expr:"
"`void*`. A função *converter* por sua vez,  é chamada da seguinte maneira::"

#: ../../c-api/arg.rst:334
msgid "status = converter(object, address);"
msgstr "status = converter(object, address);"

#: ../../c-api/arg.rst:336
msgid ""
"where *object* is the Python object to be converted and *address* is the :c:"
"expr:`void*` argument that was passed to the ``PyArg_Parse*`` function. The "
"returned *status* should be ``1`` for a successful conversion and ``0`` if "
"the conversion has failed.  When the conversion fails, the *converter* "
"function should raise an exception and leave the content of *address* "
"unmodified."
msgstr ""
"onde *object* é o objeto Python a ser convertido e *address* é o argumento :"
"c:expr:`void*` que foi passado para a função ``PyArg_Parse*``. O *status* "
"retornado deve ser ``1`` para uma conversão bem-sucedida e ``0`` se a "
"conversão falhar. Quando a conversão falha, a função *converter* deve "
"levantar uma exceção e deixar o conteúdo de *address* inalterado."

#: ../../c-api/arg.rst:345
msgid ""
"If the *converter* returns :c:macro:`!Py_CLEANUP_SUPPORTED`, it may get "
"called a second time if the argument parsing eventually fails, giving the "
"converter a chance to release any memory that it had already allocated. In "
"this second call, the *object* parameter will be ``NULL``; *address* will "
"have the same value as in the original call."
msgstr ""
"Se o *converter* retornar :c:macro:`!Py_CLEANUP_SUPPORTED`, ele poderá ser "
"chamado uma segunda vez se a análise do argumento eventualmente falhar, "
"dando ao conversor a chance de liberar qualquer memória que já havia "
"alocado. Nesta segunda chamada, o parâmetro *object* será ``NULL``; "
"*address* terá o mesmo valor que na chamada original."

#: ../../c-api/arg.rst:351
msgid ""
"Examples of converters: :c:func:`PyUnicode_FSConverter` and :c:func:"
"`PyUnicode_FSDecoder`."
msgstr ""
"Exemplos de conversores: :c:func:`PyUnicode_FSConverter` e :c:func:"
"`PyUnicode_FSDecoder`."

#: ../../c-api/arg.rst:354
msgid ":c:macro:`!Py_CLEANUP_SUPPORTED` was added."
msgstr ":c:macro:`!Py_CLEANUP_SUPPORTED` foi adicionado."

#: ../../c-api/arg.rst:357 ../../c-api/arg.rst:671
msgid "``p`` (:class:`bool`) [int]"
msgstr "``p`` (:class:`bool`) [int]"

#: ../../c-api/arg.rst:358
msgid ""
"Tests the value passed in for truth (a boolean **p**\\ redicate) and "
"converts the result to its equivalent C true/false integer value. Sets the "
"int to ``1`` if the expression was true and ``0`` if it was false. This "
"accepts any valid Python value.  See :ref:`truth` for more information about "
"how Python tests values for truth."
msgstr ""
"Testa o valor transmitido para a verdade (um booleano **p**\\ redicado) e "
"converte o resultado em seu valor inteiro C verdadeiro/falso equivalente. "
"Define o int como ``1`` se a expressão for verdadeira e ``0`` se for falsa. "
"Isso aceita qualquer valor válido do Python. Veja :ref:`truth` para obter "
"mais informações sobre como o Python testa valores para a verdade."

#: ../../c-api/arg.rst:366
msgid "``(items)`` (sequence) [*matching-items*]"
msgstr "``(items)`` (sequência) [*itens-correspondentes*]"

#: ../../c-api/arg.rst:367
msgid ""
"The object must be a Python sequence (except :class:`str`, :class:`bytes` "
"or :class:`bytearray`) whose length is the number of format units in "
"*items*.  The C arguments must correspond to the individual format units in "
"*items*.  Format units for sequences may be nested."
msgstr ""
"O objeto deve ser uma sequência Python (exceto :class:`str`, :class:`bytes` "
"ou :class:`bytearray`) cujo comprimento é o número de unidades de formato em "
"*itens*. Os argumentos C devem corresponder às unidades de formato "
"individuais em *itens*. As unidades de formato para sequências podem ser "
"aninhadas."

#: ../../c-api/arg.rst:372
msgid ""
"If *items* contains format units which store a :ref:`borrowed buffer <c-arg-"
"borrowed-buffer>` (``s``, ``s#``, ``z``, ``z#``, ``y``, or ``y#``) or a :"
"term:`borrowed reference` (``S``, ``Y``, ``U``, ``O``, or ``O!``), the "
"object must be a Python tuple. The *converter* for the ``O&`` format unit in "
"*items* must not store a borrowed buffer or a borrowed reference."
msgstr ""
"Se *items* contiver unidades de formato que armazenam um :ref:`buffer "
"emprestado <c-arg-borrowed-buffer>` (``s``, ``s#``, ``z``, ``z#``, ``y`` ou "
"``y#``) ou uma :term:`referência emprestada` (``S``, ``Y``, ``U``, ``O`` ou "
"``O!``), o objeto deve ser uma tupla Python. O *conversor* para a unidade de "
"formato ``O&`` em *items* não deve armazenar um buffer emprestado ou uma "
"referência emprestada."

#: ../../c-api/arg.rst:379
msgid ""
":class:`str` and :class:`bytearray` objects no longer accepted as a sequence."
msgstr ""
"Objetos :class:`str` e :class:`bytearray` não são mais aceitos como "
"sequência."

#: ../../c-api/arg.rst:382
msgid ""
"Non-tuple sequences are deprecated if *items* contains format units which "
"store a borrowed buffer or a borrowed reference."
msgstr ""
"Sequências não-tuplas serão descontinuadas se *items* contiver unidades de "
"formato que armazenem um buffer emprestado ou uma referência emprestada."

#: ../../c-api/arg.rst:386
msgid ""
"A few other characters have a meaning in a format string.  These may not "
"occur inside nested parentheses.  They are:"
msgstr ""
"Alguns outros caracteres possuem significados na string de formatação. Isso "
"pode não ocorrer dentro de parênteses aninhados. Eles são:"

#: ../../c-api/arg.rst:389
msgid "``|``"
msgstr "``|``"

#: ../../c-api/arg.rst:390
msgid ""
"Indicates that the remaining arguments in the Python argument list are "
"optional. The C variables corresponding to optional arguments should be "
"initialized to their default value --- when an optional argument is not "
"specified, :c:func:`PyArg_ParseTuple` does not touch the contents of the "
"corresponding C variable(s)."
msgstr ""
"Indica que os argumentos restantes na lista de argumentos do Python são "
"opcionais. As variáveis C correspondentes a argumentos opcionais devem ser "
"inicializadas para seus valores padrão --- quando um argumento opcional não "
"é especificado, :c:func:`PyArg_ParseTuple` não toca no conteúdo da(s) "
"variável(eis) C correspondente(s)."

#: ../../c-api/arg.rst:396
msgid "``$``"
msgstr "``$``"

#: ../../c-api/arg.rst:397
msgid ""
":c:func:`PyArg_ParseTupleAndKeywords` only: Indicates that the remaining "
"arguments in the Python argument list are keyword-only.  Currently, all "
"keyword-only arguments must also be optional arguments, so ``|`` must always "
"be specified before ``$`` in the format string."
msgstr ""
":c:func:`PyArg_ParseTupleAndKeywords` apenas: Indica que os argumentos "
"restantes na lista de argumentos do Python são somente-nomeados. Atualmente, "
"todos os argumentos somente-nomeados devem ser também argumentos opcionais, "
"então ``|`` deve sempre ser especificado antes de ``$`` na string de "
"formatação."

#: ../../c-api/arg.rst:405
msgid "``:``"
msgstr "``:``"

#: ../../c-api/arg.rst:406
msgid ""
"The list of format units ends here; the string after the colon is used as "
"the function name in error messages (the \"associated value\" of the "
"exception that :c:func:`PyArg_ParseTuple` raises)."
msgstr ""
"A lista de unidades de formatação acaba aqui; a string após os dois pontos é "
"usada como o nome da função nas mensagens de erro (o \"valor associado\" da "
"exceção que :c:func:`PyArg_ParseTuple` levanta)."

#: ../../c-api/arg.rst:410
msgid "``;``"
msgstr "``;``"

#: ../../c-api/arg.rst:411
msgid ""
"The list of format units ends here; the string after the semicolon is used "
"as the error message *instead* of the default error message.  ``:`` and ``;"
"`` mutually exclude each other."
msgstr ""
"A lista de unidades de formatação acaba aqui; a string após o ponto e "
"vírgula é usada como a mensagem de erro *ao invés* da mensagem de erro "
"padrão. ``:`` e ``;`` se excluem mutuamente."

#: ../../c-api/arg.rst:415
msgid ""
"Note that any Python object references which are provided to the caller are "
"*borrowed* references; do not release them (i.e. do not decrement their "
"reference count)!"
msgstr ""
"Note que quaisquer referências a objeto Python que são fornecidas ao "
"chamador são referências *emprestadas*; não libera-as (isto é, não "
"decremente a contagem de referências delas)!"

#: ../../c-api/arg.rst:419
msgid ""
"Additional arguments passed to these functions must be addresses of "
"variables whose type is determined by the format string; these are used to "
"store values from the input tuple.  There are a few cases, as described in "
"the list of format units above, where these parameters are used as input "
"values; they should match what is specified for the corresponding format "
"unit in that case."
msgstr ""
"Argumentos adicionais passados para essas funções devem ser endereços de "
"variáveis cujo tipo é determinado pela string de formatação; estes são "
"usados para armazenar valores vindos da tupla de entrada. Existem alguns "
"casos, como descrito na lista de unidades de formatação acima, onde esses "
"parâmetros são usados como valores de entrada; eles devem concordar com o "
"que é especificado para a unidade de formatação correspondente nesse caso."

#: ../../c-api/arg.rst:425
msgid ""
"For the conversion to succeed, the *arg* object must match the format and "
"the format must be exhausted.  On success, the ``PyArg_Parse*`` functions "
"return true, otherwise they return false and raise an appropriate exception. "
"When the ``PyArg_Parse*`` functions fail due to conversion failure in one of "
"the format units, the variables at the addresses corresponding to that and "
"the following format units are left untouched."
msgstr ""
"Para a conversão funcionar, o objeto *arg* deve corresponder ao formato e o "
"formato deve estar completo. Em caso de sucesso, as funções ``PyArg_Parse*`` "
"retornam verdadeiro, caso contrário retornam falso e levantam uma exceção "
"apropriada. Quando as funções ``PyArg_Parse*`` falham devido a uma falha de "
"conversão em uma das unidades de formatação, as variáveis nos endereços "
"correspondentes àquela unidade e às unidades de formatação seguintes são "
"deixadas intocadas."

#: ../../c-api/arg.rst:434
msgid "API Functions"
msgstr "Funções da API"

#: ../../c-api/arg.rst:438
msgid ""
"Parse the parameters of a function that takes only positional parameters "
"into local variables.  Returns true on success; on failure, it returns false "
"and raises the appropriate exception."
msgstr ""
"Analisa os parâmetros de uma função que recebe apenas parâmetros posicionais "
"em variáveis locais. Retorna verdadeiro em caso de sucesso; em caso de "
"falha, retorna falso e levanta a exceção apropriada."

#: ../../c-api/arg.rst:445
msgid ""
"Identical to :c:func:`PyArg_ParseTuple`, except that it accepts a va_list "
"rather than a variable number of arguments."
msgstr ""
"Idêntico a :c:func:`PyArg_ParseTuple`, exceto que aceita uma va_list ao "
"invés de um número variável de argumentos."

#: ../../c-api/arg.rst:451
msgid ""
"Parse the parameters of a function that takes both positional and keyword "
"parameters into local variables. The *keywords* argument is a ``NULL``-"
"terminated array of keyword parameter names specified as null-terminated "
"ASCII or UTF-8 encoded C strings. Empty names denote :ref:`positional-only "
"parameters <positional-only_parameter>`. Returns true on success; on "
"failure, it returns false and raises the appropriate exception."
msgstr ""
"Analisa os parâmetros de uma função que aceita tanto parâmetros posicionais "
"quando parâmetros nomeados e os converte em variáveis locais. O argumento "
"*keywords* é um array terminado em ``NULL`` de nomes de parâmetros nomeados "
"especificados como strings C codificadas em ASCII ou UTF-8 e terminadas com "
"nulo. Nomes vazios representam :ref:`parâmetros somente-posicional "
"<positional-only_parameter>`. Retorna verdadeiro em caso de sucesso; em caso "
"de falha, retorna falso e levanta a exceção apropriada."

#: ../../c-api/arg.rst:462
msgid ""
"The *keywords* parameter declaration is :c:expr:`char * const *` in C and :c:"
"expr:`const char * const *` in C++. This can be overridden with the :c:macro:"
"`PY_CXX_CONST` macro."
msgstr ""
"A declaração do parâmetro *keywords* é :c:expr:`char * const *` em C e :c:"
"expr:`const char * const *` em C++. Isso pode ser substituído com a macro  :"
"c:macro:`PY_CXX_CONST`."

#: ../../c-api/arg.rst:466
msgid ""
"Added support for :ref:`positional-only parameters <positional-"
"only_parameter>`."
msgstr ""
"Adicionado suporte para :ref:`positional-only parameters <positional-"
"only_parameter>`."

#: ../../c-api/arg.rst:470
msgid ""
"The *keywords* parameter has now type :c:expr:`char * const *` in C and :c:"
"expr:`const char * const *` in C++, instead of :c:expr:`char **`. Added "
"support for non-ASCII keyword parameter names."
msgstr ""
"O parâmetro *keywords* é agora do tipo :c:expr:`char * const *` em C e :c:"
"expr:`const char * const *` em C++, no lugar de :c:expr:`char **`. "
"Adicionado suporte para nomes de parâmetros nomeados não-ASCII."

#: ../../c-api/arg.rst:479
msgid ""
"Identical to :c:func:`PyArg_ParseTupleAndKeywords`, except that it accepts a "
"va_list rather than a variable number of arguments."
msgstr ""
"Idêntico a :c:func:`PyArg_ParseTupleAndKeywords`, exceto que aceita uma "
"va_list ao invés de um número variável de argumentos."

#: ../../c-api/arg.rst:485
msgid ""
"Ensure that the keys in the keywords argument dictionary are strings.  This "
"is only needed if :c:func:`PyArg_ParseTupleAndKeywords` is not used, since "
"the latter already does this check."
msgstr ""
"Garante que as chaves no dicionário de argumento de palavras reservadas são "
"strings. Isso só é necessário se :c:func:`PyArg_ParseTupleAndKeywords` não é "
"usado, já que o último já faz essa checagem."

#: ../../c-api/arg.rst:494
msgid ""
"Parse the parameter of a function that takes a single positional parameter "
"into a local variable.  Returns true on success; on failure, it returns "
"false and raises the appropriate exception."
msgstr ""
"Analisa o parâmetro de uma função que recebe um único parâmetro posicional e "
"o converte em uma variável local. Retorna verdadeiro em caso de sucesso; em "
"caso de falha, retorna falso e levanta a exceção apropriada."

#: ../../c-api/arg.rst:498
msgid "Example::"
msgstr "Exemplo::"

#: ../../c-api/arg.rst:500
msgid ""
"// Function using METH_O calling convention\n"
"static PyObject*\n"
"my_function(PyObject *module, PyObject *arg)\n"
"{\n"
"    int value;\n"
"    if (!PyArg_Parse(arg, \"i:my_function\", &value)) {\n"
"        return NULL;\n"
"    }\n"
"    // ... use value ...\n"
"}"
msgstr ""
"// Função usando a convenção de chamada ao método METH_O\n"
"static PyObject*\n"
"my_function(PyObject *module, PyObject *arg)\n"
"{\n"
"    int value;\n"
"    if (!PyArg_Parse(arg, \"i:my_function\", &value)) {\n"
"        return NULL;\n"
"    }\n"
"    // ... usar valor ...\n"
"}"

#: ../../c-api/arg.rst:514
msgid ""
"A simpler form of parameter retrieval which does not use a format string to "
"specify the types of the arguments.  Functions which use this method to "
"retrieve their parameters should be declared as :c:macro:`METH_VARARGS` in "
"function or method tables.  The tuple containing the actual parameters "
"should be passed as *args*; it must actually be a tuple.  The length of the "
"tuple must be at least *min* and no more than *max*; *min* and *max* may be "
"equal.  Additional arguments must be passed to the function, each of which "
"should be a pointer to a :c:expr:`PyObject*` variable; these will be filled "
"in with the values from *args*; they will contain :term:`borrowed references "
"<borrowed reference>`. The variables which correspond to optional parameters "
"not given by *args* will not be filled in; these should be initialized by "
"the caller. This function returns true on success and false if *args* is not "
"a tuple or contains the wrong number of elements; an exception will be set "
"if there was a failure."
msgstr ""
"Uma forma mais simples de recuperação de parâmetro que não usa uma string de "
"formato para especificar os tipos de argumentos. Funções que usam este "
"método para recuperar seus parâmetros devem ser declaradas como :c:macro:"
"`METH_VARARGS` em tabelas de função ou método. A tupla contendo os "
"parâmetros reais deve ser passada como *args*; deve realmente ser uma tupla. "
"O comprimento da tupla deve ser de pelo menos *min* e não mais do que *max*; "
"*min* e *max* podem ser iguais. Argumentos adicionais devem ser passados "
"para a função, cada um dos quais deve ser um ponteiro para uma variável :c:"
"expr:`PyObject*`; eles serão preenchidos com os valores de *args*; eles "
"conterão :term:`referências emprestadas <borrowed reference>`. As variáveis "
"que correspondem a parâmetros opcionais não fornecidos por *args* não serão "
"preenchidas; estes devem ser inicializados pelo chamador. Esta função "
"retorna verdadeiro em caso de sucesso e falso se *args* não for uma tupla ou "
"contiver o número incorreto de elementos; uma exceção será definida se "
"houver uma falha."

#: ../../c-api/arg.rst:529
msgid ""
"This is an example of the use of this function, taken from the sources for "
"the :mod:`!_weakref` helper module for weak references::"
msgstr ""
"Este é um exemplo do uso dessa função, tirado das fontes do módulo auxiliar "
"para referências fracas :mod:`!_weakref`::"

#: ../../c-api/arg.rst:532
msgid ""
"static PyObject *\n"
"weakref_ref(PyObject *self, PyObject *args)\n"
"{\n"
"    PyObject *object;\n"
"    PyObject *callback = NULL;\n"
"    PyObject *result = NULL;\n"
"\n"
"    if (PyArg_UnpackTuple(args, \"ref\", 1, 2, &object, &callback)) {\n"
"        result = PyWeakref_NewRef(object, callback);\n"
"    }\n"
"    return result;\n"
"}"
msgstr ""
"static PyObject *\n"
"weakref_ref(PyObject *self, PyObject *args)\n"
"{\n"
"    PyObject *object;\n"
"    PyObject *callback = NULL;\n"
"    PyObject *result = NULL;\n"
"\n"
"    if (PyArg_UnpackTuple(args, \"ref\", 1, 2, &object, &callback)) {\n"
"        result = PyWeakref_NewRef(object, callback);\n"
"    }\n"
"    return result;\n"
"}"

#: ../../c-api/arg.rst:545
msgid ""
"The call to :c:func:`PyArg_UnpackTuple` in this example is entirely "
"equivalent to this call to :c:func:`PyArg_ParseTuple`::"
msgstr ""
"A chamada à :c:func:`PyArg_UnpackTuple` neste exemplo é inteiramente "
"equivalente à chamada para :c:func:`PyArg_ParseTuple`::"

#: ../../c-api/arg.rst:548
msgid "PyArg_ParseTuple(args, \"O|O:ref\", &object, &callback)"
msgstr "PyArg_ParseTuple(args, \"O|O:ref\", &object, &callback)"

#: ../../c-api/arg.rst:552
msgid ""
"The value to be inserted, if any, before :c:expr:`char * const *` in the "
"*keywords* parameter declaration of :c:func:`PyArg_ParseTupleAndKeywords` "
"and :c:func:`PyArg_VaParseTupleAndKeywords`. Default empty for C and "
"``const`` for C++ (:c:expr:`const char * const *`). To override, define it "
"to the desired value before including :file:`Python.h`."
msgstr ""
"O valor para ser inserido, se houver, antes de :c:expr:`char * const *` na "
"declaração do parâmetro *keywords* das funções  :c:func:"
"`PyArg_ParseTupleAndKeywords` e :c:func:`PyArg_VaParseTupleAndKeywords`. Por "
"padrão, é vazio para C e ``const`` for C++ (:c:expr:`const char * const *`). "
"Para substituir, defina o valor desejado antes de incluir :file:`Python.h`."

#: ../../c-api/arg.rst:566
msgid "Building values"
msgstr "Construindo valores"

#: ../../c-api/arg.rst:570
msgid ""
"Create a new value based on a format string similar to those accepted by the "
"``PyArg_Parse*`` family of functions and a sequence of values.  Returns the "
"value or ``NULL`` in the case of an error; an exception will be raised if "
"``NULL`` is returned."
msgstr ""
"Cria um novo valor baseado em uma string de formatação similar àquelas "
"aceitas pela família de funções ``PyArg_Parse*`` e uma sequência de valores. "
"Retorna o valor ou ``NULL`` em caso de erro; uma exceção será levantada se "
"``NULL`` for retornado."

#: ../../c-api/arg.rst:575
msgid ""
":c:func:`Py_BuildValue` does not always build a tuple.  It builds a tuple "
"only if its format string contains two or more format units.  If the format "
"string is empty, it returns ``None``; if it contains exactly one format "
"unit, it returns whatever object is described by that format unit.  To force "
"it to return a tuple of size 0 or one, parenthesize the format string."
msgstr ""
":c:func:`Py_BuildValue` não constrói sempre uma tupla. Ela constrói uma "
"tupla apenas se a sua string de formatação contém duas ou mais unidades de "
"formatação. Se a string de formatação estiver vazia, ela retorna ``None``; "
"se ela contém exatamente uma unidade de formatação, ela retorna qualquer que "
"seja o objeto que for descrito pela unidade de formatação. Para forçar ela a "
"retornar uma tupla de tamanho 0 ou um, use parênteses na string de "
"formatação."

#: ../../c-api/arg.rst:581
msgid ""
"When memory buffers are passed as parameters to supply data to build "
"objects, as for the ``s`` and ``s#`` formats, the required data is copied.  "
"Buffers provided by the caller are never referenced by the objects created "
"by :c:func:`Py_BuildValue`.  In other words, if your code invokes :c:func:"
"`malloc` and passes the allocated memory to :c:func:`Py_BuildValue`, your "
"code is responsible for calling :c:func:`free` for that memory once :c:func:"
"`Py_BuildValue` returns."
msgstr ""
"Quando buffers de memória são passados como parâmetros para fornecer dados "
"para construir objetos, como nos formatos ``s`` e ``s#``, os dados "
"necessários são copiados. Buffers fornecidos pelo chamador nunca são "
"referenciados pelos objetos criados por :c:func:`Py_BuildValue`. Em outras "
"palavras, se o seu código invoca :c:func:`malloc` e passa a memória alocada "
"para :c:func:`Py_BuildValue`, seu código é responsável por chamar :c:func:"
"`free` para aquela memória uma vez que :c:func:`Py_BuildValue` tiver "
"retornado."

#: ../../c-api/arg.rst:589
msgid ""
"In the following description, the quoted form is the format unit; the entry "
"in (round) parentheses is the Python object type that the format unit will "
"return; and the entry in [square] brackets is the type of the C value(s) to "
"be passed."
msgstr ""
"Na descrição a seguir, a forma entre aspas é a unidade de formatação; a "
"entrada em parênteses (arredondado) é o tipo do objeto Python que a unidade "
"de formatação irá retornar; e a entrada em colchetes [quadrado] é o tipo "
"do(s) valor(es) C a ser(em) passado(s)."

#: ../../c-api/arg.rst:593
msgid ""
"The characters space, tab, colon and comma are ignored in format strings "
"(but not within format units such as ``s#``).  This can be used to make long "
"format strings a tad more readable."
msgstr ""
"Os caracteres de espaço, tab, dois pontos e vírgula são ignorados em strings "
"de formatação (mas não dentro de unidades de formatação como ``s#``). Isso "
"pode ser usado para tornar strings de formatação longas um pouco mais "
"legíveis."

#: ../../c-api/arg.rst:597
msgid "``s`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``s`` (:class:`str` ou ``None``) [const char \\*]"

#: ../../c-api/arg.rst:598
msgid ""
"Convert a null-terminated C string to a Python :class:`str` object using "
"``'utf-8'`` encoding. If the C string pointer is ``NULL``, ``None`` is used."
msgstr ""
"Converte uma string C terminada em NULL em um objeto Python :class:`str` "
"usando codificação ``'utf-8'``. Se o ponteiro da string C é ``NULL``, "
"``None`` é usado."

#: ../../c-api/arg.rst:601
msgid ""
"``s#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr ""
"``s#`` (:class:`str` ou ``None``) [const char \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:602
msgid ""
"Convert a C string and its length to a Python :class:`str` object using "
"``'utf-8'`` encoding. If the C string pointer is ``NULL``, the length is "
"ignored and ``None`` is returned."
msgstr ""
"Converte uma string C e seu comprimento em um objeto Python :class:`str` "
"usando a codificação ``'utf-8'``. Se o ponteiro da string C é ``NULL``, o "
"comprimento é ignorado e ``None`` é retornado."

#: ../../c-api/arg.rst:606
msgid "``y`` (:class:`bytes`) [const char \\*]"
msgstr "``y`` (:class:`bytes`) [const char \\*]"

#: ../../c-api/arg.rst:607
msgid ""
"This converts a C string to a Python :class:`bytes` object.  If the C string "
"pointer is ``NULL``, ``None`` is returned."
msgstr ""
"Isso converte uma string C para um objeto Python :class:`bytes`. Se o "
"ponteiro da string C é ``NULL``, ``None`` é retornado."

#: ../../c-api/arg.rst:610
msgid "``y#`` (:class:`bytes`) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr "``y#`` (:class:`bytes`) [const char \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:611
msgid ""
"This converts a C string and its lengths to a Python object.  If the C "
"string pointer is ``NULL``, ``None`` is returned."
msgstr ""
"Isso converte uma string C e seu comprimento para um objeto Python. Se o "
"ponteiro da string C é ``NULL``, ``None`` é retornado."

#: ../../c-api/arg.rst:615 ../../c-api/arg.rst:631
msgid "Same as ``s``."
msgstr "O mesmo de ``s``."

#: ../../c-api/arg.rst:617
msgid ""
"``z#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr ""
"``z#`` (:class:`str` ou ``None``) [const char \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:618 ../../c-api/arg.rst:634
msgid "Same as ``s#``."
msgstr "O mesmo de ``s#``."

#: ../../c-api/arg.rst:620
msgid "``u`` (:class:`str`) [const wchar_t \\*]"
msgstr "``u`` (:class:`str`) [const wchar_t \\*]"

#: ../../c-api/arg.rst:621
msgid ""
"Convert a null-terminated :c:type:`wchar_t` buffer of Unicode (UTF-16 or "
"UCS-4) data to a Python Unicode object.  If the Unicode buffer pointer is "
"``NULL``, ``None`` is returned."
msgstr ""
"Converte um buffer terminado por null :c:type:`wchar_t` de dados Unicode "
"(UTF-16 ou UCS-4) para um objeto Python Unicode. Se o ponteiro do buffer "
"Unicode é ``NULL``, ``None`` é retornado."

#: ../../c-api/arg.rst:625
msgid "``u#`` (:class:`str`) [const wchar_t \\*, :c:type:`Py_ssize_t`]"
msgstr "``u#`` (:class:`str`) [const wchar_t \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:626
msgid ""
"Convert a Unicode (UTF-16 or UCS-4) data buffer and its length to a Python "
"Unicode object.   If the Unicode buffer pointer is ``NULL``, the length is "
"ignored and ``None`` is returned."
msgstr ""
"Converte um buffer de dados Unicode (UTF-17 ou UCS-4) e seu comprimento em "
"um objeto Python Unicode. Se o ponteiro do buffer Unicode é ``NULL``, o "
"comprimento é ignorado e ``None`` é retornado."

#: ../../c-api/arg.rst:630
msgid "``U`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``U`` (:class:`str` ou ``None``) [const char \\*]"

#: ../../c-api/arg.rst:633
msgid ""
"``U#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr ""
"``U#`` (:class:`str` ou ``None``) [const char \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:637
msgid "Convert a plain C :c:expr:`int` to a Python integer object."
msgstr "Converte um simples :c:expr:`int` do C em um objeto inteiro do Python."

#: ../../c-api/arg.rst:639
msgid "``b`` (:class:`int`) [char]"
msgstr "``b`` (:class:`int`) [char]"

#: ../../c-api/arg.rst:640
msgid "Convert a plain C :c:expr:`char` to a Python integer object."
msgstr ""
"Converte um simples :c:expr:`char` do C em um objeto inteiro do Python."

#: ../../c-api/arg.rst:643
msgid "Convert a plain C :c:expr:`short int` to a Python integer object."
msgstr ""
"Converte um simples :c:expr:`short int` do C em um objeto inteiro do Python."

#: ../../c-api/arg.rst:646
msgid "Convert a C :c:expr:`long int` to a Python integer object."
msgstr "Converte um :c:expr:`long int` do C em um objeto inteiro do Python."

#: ../../c-api/arg.rst:649
msgid "Convert a C :c:expr:`unsigned char` to a Python integer object."
msgstr ""
"Converte um :c:expr:`unsigned char` do C em um objeto inteiro do Python."

#: ../../c-api/arg.rst:652
msgid "Convert a C :c:expr:`unsigned short int` to a Python integer object."
msgstr ""
"Converte um :c:expr:`unsigned short int` do C em um objeto inteiro do Python."

#: ../../c-api/arg.rst:655
msgid "Convert a C :c:expr:`unsigned int` to a Python integer object."
msgstr ""
"Converte um :c:expr:`unsigned int` do C em um objeto inteiro do Python."

#: ../../c-api/arg.rst:658
msgid "Convert a C :c:expr:`unsigned long` to a Python integer object."
msgstr ""
"Converte um :c:expr:`unsigned long` do C em um objeto inteiro do Python."

#: ../../c-api/arg.rst:661
msgid "Convert a C :c:expr:`long long` to a Python integer object."
msgstr "Converte um :c:expr:`long long` do C em um objeto inteiro do Python."

#: ../../c-api/arg.rst:666
msgid "Convert a C :c:expr:`unsigned long long` to a Python integer object."
msgstr ""
"Converte um :c:expr:`unsigned long long` do C em um objeto inteiro do Python."

#: ../../c-api/arg.rst:669
msgid "Convert a C :c:type:`Py_ssize_t` to a Python integer."
msgstr "Converte um :c:type:`Py_ssize_t` do C em um objeto inteiro do Python."

#: ../../c-api/arg.rst:672
msgid "Convert a C :c:expr:`int` to a Python :class:`bool` object."
msgstr "Converte um :c:expr:`int` C para um objeto :class:`bool` Python."

#: ../../c-api/arg.rst:674
msgid ""
"Be aware that this format requires an ``int`` argument. Unlike most other "
"contexts in C, variadic arguments are not coerced to a suitable type "
"automatically. You can convert another type (for example, a pointer or a "
"float) to a suitable ``int`` value using ``(x) ? 1 : 0`` or ``!!x``."
msgstr ""
"Esteja ciente de que este formato requer um argumento ``int``. Ao contrário "
"da maioria dos outros contextos em C, argumentos variádicos não são "
"convertidos automaticamente para um tipo adequado. Você pode converter outro "
"tipo (por exemplo, um ponteiro ou um float) para um valor ``int`` adequado "
"usando ``(x) ? 1 : 0`` ou ``!!x``."

#: ../../c-api/arg.rst:682
msgid "``c`` (:class:`bytes` of length 1) [char]"
msgstr "``c`` (:class:`bytes` de comprimento 1) [char]"

#: ../../c-api/arg.rst:683
msgid ""
"Convert a C :c:expr:`int` representing a byte to a Python :class:`bytes` "
"object of length 1."
msgstr ""
"Converte um :c:expr:`int` representando um byte do C em um objeto :class:"
"`bytes` de comprimento 1 do Python."

#: ../../c-api/arg.rst:687
msgid ""
"Convert a C :c:expr:`int` representing a character to Python :class:`str` "
"object of length 1."
msgstr ""
"Converte um :c:expr:`int` representando um caractere do C em um objeto :"
"class:`str` de comprimento 1 do Python."

#: ../../c-api/arg.rst:691
msgid "Convert a C :c:expr:`double` to a Python floating-point number."
msgstr ""
"Converte um :c:expr:`double` do C em um número ponto flutuante do Python."

#: ../../c-api/arg.rst:694
msgid "Convert a C :c:expr:`float` to a Python floating-point number."
msgstr ""
"Converte um :c:expr:`float` do C em um número ponto flutuante do Python."

#: ../../c-api/arg.rst:696
msgid "``D`` (:class:`complex`) [Py_complex \\*]"
msgstr "``D`` (:class:`complex`) [Py_complex \\*]"

#: ../../c-api/arg.rst:697
msgid "Convert a C :c:type:`Py_complex` structure to a Python complex number."
msgstr ""
"Converte uma estrutura :c:type:`Py_complex` do C em um número complexo do "
"Python."

#: ../../c-api/arg.rst:700
msgid ""
"Pass a Python object untouched but create a new :term:`strong reference` to "
"it (i.e. its reference count is incremented by one). If the object passed in "
"is a ``NULL`` pointer, it is assumed that this was caused because the call "
"producing the argument found an error and set an exception. Therefore, :c:"
"func:`Py_BuildValue` will return ``NULL`` but won't raise an exception.  If "
"no exception has been raised yet, :exc:`SystemError` is set."
msgstr ""
"Passa um objeto Python intocado, mas cria uma nova :term:`referência forte` "
"a ele (isto é, sua contagem de referências é incrementada por um). Se o "
"objeto passado é um ponteiro ``NULL``, presume-se que isso foi causado "
"porque a chamada que produziu o argumento encontrou um erro e definiu uma "
"exceção. Portanto, :c:func:`Py_BuildValue` irá retornar ``NULL`` mas não irá "
"levantar uma exceção. Se nenhuma exceção foi levantada ainda, :exc:"
"`SystemError` é definida."

#: ../../c-api/arg.rst:709
msgid "``S`` (object) [PyObject \\*]"
msgstr "``S`` (objeto) [PyObject \\*]"

#: ../../c-api/arg.rst:710
msgid "Same as ``O``."
msgstr "O mesmo que ``O``."

#: ../../c-api/arg.rst:712
msgid "``N`` (object) [PyObject \\*]"
msgstr "``N`` (objeto) [PyObject \\*]"

#: ../../c-api/arg.rst:713
msgid ""
"Same as ``O``, except it doesn't create a new :term:`strong reference`. "
"Useful when the object is created by a call to an object constructor in the "
"argument list."
msgstr ""
"O mesmo que ``O``, exceto que não cria uma nova :term:`referência forte`. "
"Útil quando o objeto é criado por uma chamada a um construtor de objeto na "
"lista de argumento."

#: ../../c-api/arg.rst:717
msgid "``O&`` (object) [*converter*, *anything*]"
msgstr "``O&`` (objeto) [*converter*, *anything*]"

#: ../../c-api/arg.rst:718
msgid ""
"Convert *anything* to a Python object through a *converter* function.  The "
"function is called with *anything* (which should be compatible with :c:expr:"
"`void*`) as its argument and should return a \"new\" Python object, or "
"``NULL`` if an error occurred."
msgstr ""
"Converte *anything* para um objeto Python através de uma função *converter*. "
"A função é chamada com *anything* (que deve ser compatível com o :c:expr:"
"`void*`) como argumento e deve retornar um \"novo\" objeto Python, ou "
"``NULL`` se um erro ocorreu."

#: ../../c-api/arg.rst:723
msgid "``(items)`` (:class:`tuple`) [*matching-items*]"
msgstr "``(items)`` (:class:`tuple`) [*matching-items*]"

#: ../../c-api/arg.rst:724
msgid ""
"Convert a sequence of C values to a Python tuple with the same number of "
"items."
msgstr ""
"Converte uma sequência de valores C para uma tupla Python com o mesmo número "
"de itens."

#: ../../c-api/arg.rst:726
msgid "``[items]`` (:class:`list`) [*matching-items*]"
msgstr "``[items]`` (:class:`list`) [*matching-items*]"

#: ../../c-api/arg.rst:727
msgid ""
"Convert a sequence of C values to a Python list with the same number of "
"items."
msgstr ""
"Converte uma sequência de valores C para uma lista Python com o mesmo número "
"de itens."

#: ../../c-api/arg.rst:729
msgid "``{items}`` (:class:`dict`) [*matching-items*]"
msgstr "``{items}`` (:class:`dict`) [*matching-items*]"

#: ../../c-api/arg.rst:730
msgid ""
"Convert a sequence of C values to a Python dictionary.  Each pair of "
"consecutive C values adds one item to the dictionary, serving as key and "
"value, respectively."
msgstr ""
"Converte uma sequência de valores C para um dicionário Python. Cada par de "
"valores consecutivos do C adiciona um item ao dicionário, servindo como "
"chave e valor, respectivamente."

#: ../../c-api/arg.rst:734
msgid ""
"If there is an error in the format string, the :exc:`SystemError` exception "
"is set and ``NULL`` returned."
msgstr ""
"Se existir um erro na string de formatação, a exceção :exc:`SystemError` é "
"definida e ``NULL`` é retornado."

#: ../../c-api/arg.rst:739
msgid ""
"Identical to :c:func:`Py_BuildValue`, except that it accepts a va_list "
"rather than a variable number of arguments."
msgstr ""
"Idêntico a :c:func:`Py_BuildValue`, exceto que aceita uma va_list ao invés "
"de um número variável de argumentos."

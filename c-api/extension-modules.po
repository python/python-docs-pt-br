# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-08 14:49-0300\n"
"PO-Revision-Date: 2025-08-15 18:59+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../c-api/extension-modules.rst:6
msgid "Defining extension modules"
msgstr "Definindo módulos de extensão"

#: ../../c-api/extension-modules.rst:8
msgid ""
"A C extension for CPython is a shared library (for example, a ``.so`` file "
"on Linux, ``.pyd`` DLL on Windows), which is loadable into the Python "
"process (for example, it is compiled with compatible compiler settings), and "
"which exports an :ref:`initialization function <extension-export-hook>`."
msgstr ""
"Uma extensão C para CPython é uma biblioteca compartilhada (por exemplo, um "
"arquivo ``.so`` no Linux, uma DLL ``.pyd`` no Windows), que pode ser "
"carregada no processo Python (por exemplo, ela é compilada com configurações "
"de compilador compatíveis) e que exporta uma :ref:`função de inicialização "
"<extension-export-hook>`."

#: ../../c-api/extension-modules.rst:13
msgid ""
"To be importable by default (that is, by :py:class:`importlib.machinery."
"ExtensionFileLoader`), the shared library must be available on :py:attr:`sys."
"path`, and must be named after the module name plus an extension listed in :"
"py:attr:`importlib.machinery.EXTENSION_SUFFIXES`."
msgstr ""
"Para ser importável por padrão (ou seja, por :py:class:`importlib.machinery."
"ExtensionFileLoader`), a biblioteca compartilhada deve estar disponível em :"
"py:attr:`sys.path` e deve ser nomeada após o nome do módulo mais uma "
"extensão listada em :py:attr:`importlib.machinery.EXTENSION_SUFFIXES`."

#: ../../c-api/extension-modules.rst:21
msgid ""
"Building, packaging and distributing extension modules is best done with "
"third-party tools, and is out of scope of this document. One suitable tool "
"is Setuptools, whose documentation can be found at https://setuptools.pypa."
"io/en/latest/setuptools.html."
msgstr ""
"A construção, o empacotamento e a distribuição de módulos de extensão são "
"melhor realizados com ferramentas de terceiros e estão fora do escopo deste "
"documento. Uma ferramenta adequada é o Setuptools, cuja documentação pode "
"ser encontrada em https://setuptools.pypa.io/en/latest/setuptools.html."

#: ../../c-api/extension-modules.rst:26
msgid ""
"Normally, the initialization function returns a module definition "
"initialized using :c:func:`PyModuleDef_Init`. This allows splitting the "
"creation process into several phases:"
msgstr ""
"Normalmente, a função de inicialização retorna uma definição de módulo "
"inicializada usando :c:func:`PyModuleDef_Init`. Isso permite dividir o "
"processo de criação em várias fases:"

#: ../../c-api/extension-modules.rst:30
msgid ""
"Before any substantial code is executed, Python can determine which "
"capabilities the module supports, and it can adjust the environment or "
"refuse loading an incompatible extension."
msgstr ""
"Antes que qualquer código substancial seja executado, o Python pode "
"determinar quais recursos o módulo oferece suporte e pode ajustar o ambiente "
"ou se recusar a carregar uma extensão incompatível."

#: ../../c-api/extension-modules.rst:33
msgid ""
"By default, Python itself creates the module object -- that is, it does the "
"equivalent of :py:meth:`object.__new__` for classes. It also sets initial "
"attributes like :attr:`~module.__package__` and :attr:`~module.__loader__`."
msgstr ""
"Por padrão, o próprio Python cria o objeto módulo — ou seja, faz o "
"equivalente a :py:meth:`object.__new__` para classes. Ele também define "
"atributos iniciais como :attr:`~module.__package__` e :attr:`~module."
"__loader__`."

#: ../../c-api/extension-modules.rst:37
msgid ""
"Afterwards, the module object is initialized using extension-specific code "
"-- the equivalent of :py:meth:`~object.__init__` on classes."
msgstr ""
"Depois, o objeto do módulo é inicializado usando código específico da "
"extensão — o equivalente a :py:meth:`~object.__init__` em classes."

#: ../../c-api/extension-modules.rst:40
msgid ""
"This is called *multi-phase initialization* to distinguish it from the "
"legacy (but still supported) *single-phase initialization* scheme, where the "
"initialization function returns a fully constructed module. See the :ref:"
"`single-phase-initialization section below <single-phase-initialization>` "
"for details."
msgstr ""
"Isso é chamado de *inicialização multifásica* para diferenciá-lo do esquema "
"legado (mas ainda suportado) de *inicialização monofásica*, em que a função "
"de inicialização retorna um módulo totalmente construído. Consulte a seção :"
"ref:`inicialização monofásica abaixo <single-phase-initialization>` para "
"obter detalhes."

#: ../../c-api/extension-modules.rst:48
msgid "Added support for multi-phase initialization (:pep:`489`)."
msgstr "Adicionado suporte para inicialização multifásica (:pep:`489`)."

#: ../../c-api/extension-modules.rst:52
msgid "Multiple module instances"
msgstr "Várias instâncias de módulo"

#: ../../c-api/extension-modules.rst:54
msgid ""
"By default, extension modules are not singletons. For example, if the :py:"
"attr:`sys.modules` entry is removed and the module is re-imported, a new "
"module object is created, and typically populated with fresh method and type "
"objects. The old module is subject to normal garbage collection. This "
"mirrors the behavior of pure-Python modules."
msgstr ""
"Por padrão, módulos de extensão não são singletons. Por exemplo, se a "
"entrada :py:attr:`sys.modules` for removida e o módulo for reimportado, um "
"novo objeto de módulo será criado e normalmente preenchido com novos métodos "
"e tipos de objetos. O módulo antigo está sujeito à coleta de lixo normal. "
"Isso reflete o comportamento dos módulos Python puros."

#: ../../c-api/extension-modules.rst:61
msgid ""
"Additional module instances may be created in :ref:`sub-interpreters <sub-"
"interpreter-support>` or after Python runtime reinitialization (:c:func:"
"`Py_Finalize` and :c:func:`Py_Initialize`). In these cases, sharing Python "
"objects between module instances would likely cause crashes or undefined "
"behavior."
msgstr ""
"Instâncias adicionais do módulo podem ser criadas em :ref:"
"`subinterpretadores <sub-interpreter-support>` ou após a reinicialização do "
"tempo de execução do Python (:c:func:`Py_Finalize` e :c:func:"
"`Py_Initialize`). Nesses casos, compartilhar objetos Python entre instâncias "
"do módulo provavelmente causaria travamentos ou comportamento indefinido."

#: ../../c-api/extension-modules.rst:68
msgid ""
"To avoid such issues, each instance of an extension module should be "
"*isolated*: changes to one instance should not implicitly affect the others, "
"and all state owned by the module, including references to Python objects, "
"should be specific to a particular module instance. See :ref:`isolating-"
"extensions-howto` for more details and a practical guide."
msgstr ""
"Para evitar tais problemas, cada instância de um módulo de extensão deve ser "
"*isolada*: alterações em uma instância não devem afetar implicitamente as "
"outras, e todos os estados pertencentes ao módulo, incluindo referências a "
"objetos Python, devem ser específicos de uma instância específica do módulo. "
"Consulte :ref:`isolating-extensions-howto` para obter mais detalhes e um "
"guia prático."

#: ../../c-api/extension-modules.rst:74
msgid ""
"A simpler way to avoid these issues is :ref:`raising an error on repeated "
"initialization <isolating-extensions-optout>`."
msgstr ""
"Uma maneira mais simples de evitar esses problemas é :ref:`levantar um erro "
"na inicialização repetida <isolating-extensions-optout>`."

#: ../../c-api/extension-modules.rst:77
msgid ""
"All modules are expected to support :ref:`sub-interpreters <sub-interpreter-"
"support>`, or otherwise explicitly signal a lack of support. This is usually "
"achieved by isolation or blocking repeated initialization, as above. A "
"module may also be limited to the main interpreter using the :c:data:"
"`Py_mod_multiple_interpreters` slot."
msgstr ""
"Espera-se que todos os módulos ofereçam suporte a :ref:`subinterpretador "
"<sub-interpreter-support>`, ou então sinalizem explicitamente a falta de "
"suporte. Isso geralmente é obtido por isolamento ou bloqueio de "
"inicializações repetidas, como acima. Um módulo também pode ser limitado ao "
"interpretador principal usando o slot :c:data:`Py_mod_multiple_interpreters`."

#: ../../c-api/extension-modules.rst:89
msgid "Initialization function"
msgstr "Função de inicialização"

#: ../../c-api/extension-modules.rst:91
msgid ""
"The initialization function defined by an extension module has the following "
"signature:"
msgstr ""
"A função de inicialização definida por um módulo de extensão tem a seguinte "
"assinatura:"

#: ../../c-api/extension-modules.rst:96
msgid ""
"Its name should be :samp:`PyInit_{<name>}`, with ``<name>`` replaced by the "
"name of the module."
msgstr ""
"Seu nome deve ser :samp:`PyInit_{<nome>}`, com ``<nome>`` substituído pelo "
"nome do módulo."

#: ../../c-api/extension-modules.rst:99
msgid ""
"For modules with ASCII-only names, the function must instead be named :samp:"
"`PyInit_{<name>}`, with ``<name>`` replaced by the name of the module. When "
"using :ref:`multi-phase-initialization`, non-ASCII module names are allowed. "
"In this case, the initialization function name is :samp:`PyInitU_{<name>}`, "
"with ``<name>`` encoded using Python's *punycode* encoding with hyphens "
"replaced by underscores. In Python:"
msgstr ""
"Para módulos com nomes com somente ASCII, a função deve ser nomeada :samp:"
"`PyInit_{<nome>}`, com ``<nome>`` substituído pelo nome do módulo. Ao usar :"
"ref:`multi-phase-initialization`, nomes de módulos não ASCII são permitidos. "
"Neste caso, o nome da função de inicialização é :samp:`PyInitU_{<nome>}`, "
"com ``<nome>`` codificado usando a codificação *punycode* do Python com "
"hífenes substituídos por sublinhados. Em Python::"

#: ../../c-api/extension-modules.rst:106
msgid ""
"def initfunc_name(name):\n"
"    try:\n"
"        suffix = b'_' + name.encode('ascii')\n"
"    except UnicodeEncodeError:\n"
"        suffix = b'U_' + name.encode('punycode').replace(b'-', b'_')\n"
"    return b'PyInit' + suffix"
msgstr ""
"def nome_func_iniciadora(nome):\n"
"    try:\n"
"        sufixo = b'_' + nome.encode('ascii')\n"
"    except UnicodeEncodeError:\n"
"        sufixo = b'U_' + nome.encode('punycode').replace(b'-', b'_')\n"
"    return b'PyInit' + sufixo"

#: ../../c-api/extension-modules.rst:115
msgid ""
"It is recommended to define the initialization function using a helper macro:"
msgstr ""
"É recomendável definir a função de inicialização usando uma macro auxiliar:"

#: ../../c-api/extension-modules.rst:119
msgid "Declare an extension module initialization function. This macro:"
msgstr "Declara uma função de inicialização do módulo de extensão. Esta macro:"

#: ../../c-api/extension-modules.rst:122
msgid "specifies the :c:expr:`PyObject*` return type,"
msgstr "especifica o tipo de retorno :c:expr:`PyObject*`,"

#: ../../c-api/extension-modules.rst:123
msgid "adds any special linkage declarations required by the platform, and"
msgstr ""
"adiciona quaisquer declarações de vinculação especiais exigidas pela "
"plataforma e"

#: ../../c-api/extension-modules.rst:124
msgid "for C++, declares the function as ``extern \"C\"``."
msgstr "para C++, declara a função como ``extern \"C\"``."

#: ../../c-api/extension-modules.rst:126
msgid "For example, a module called ``spam`` would be defined like this::"
msgstr "Por exemplo, um módulo chamado ``spam`` seria definido assim::"

#: ../../c-api/extension-modules.rst:128
msgid ""
"static struct PyModuleDef spam_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"spam\",\n"
"    ...\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    return PyModuleDef_Init(&spam_module);\n"
"}"
msgstr ""
"static struct PyModuleDef spam_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"spam\",\n"
"    ...\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    return PyModuleDef_Init(&spam_module);\n"
"}"

#: ../../c-api/extension-modules.rst:140
msgid ""
"It is possible to export multiple modules from a single shared library by "
"defining multiple initialization functions. However, importing them requires "
"using symbolic links or a custom importer, because by default only the "
"function corresponding to the filename is found. See the `Multiple modules "
"in one library <https://peps.python.org/pep-0489/#multiple-modules-in-one-"
"library>`__ section in :pep:`489` for details."
msgstr ""
"É possível exportar vários módulos de uma única biblioteca compartilhada, "
"definindo várias funções de inicialização. No entanto, importá-los requer o "
"uso de links simbólicos ou um importador personalizado, porque por padrão "
"apenas a função correspondente ao nome do arquivo é encontrada. Veja a seção "
"`Multiple modules in one library <https://peps.python.org/pep-0489/#multiple-"
"modules-in-one-library>`__ na :pep:`489` para detalhes."

#: ../../c-api/extension-modules.rst:147
msgid ""
"The initialization function is typically the only non-\\ ``static`` item "
"defined in the module's C source."
msgstr ""
"A função de inicialização normalmente é o único item não ``static`` definido "
"no código-fonte C do módulo."

#: ../../c-api/extension-modules.rst:154
msgid "Multi-phase initialization"
msgstr "Inicialização multifásica"

#: ../../c-api/extension-modules.rst:156
msgid ""
"Normally, the :ref:`initialization function <extension-export-hook>` "
"(``PyInit_modulename``) returns a :c:type:`PyModuleDef` instance with non-"
"``NULL`` :c:member:`~PyModuleDef.m_slots`. Before it is returned, the "
"``PyModuleDef`` instance must be initialized using the following function:"
msgstr ""
"Normalmente, a :ref:`função de inicialização <extension-export-hook>` "
"(``PyInit_modulename``) retorna uma instância de :c:type:`PyModuleDef` com :"
"c:member:`~PyModuleDef.m_slots` não ``NULL``. Antes de ser retornada, a "
"instância ``PyModuleDef`` deve ser inicializada usando a seguinte função:"

#: ../../c-api/extension-modules.rst:165
msgid ""
"Ensure a module definition is a properly initialized Python object that "
"correctly reports its type and a reference count."
msgstr ""
"Garante que uma definição de módulo é um objeto Python devidamente "
"inicializado que reporta corretamente seu tipo e uma contagem de referências."

#: ../../c-api/extension-modules.rst:168
msgid "Return *def* cast to ``PyObject*``, or ``NULL`` if an error occurred."
msgstr ""
"Retorna *def* convertido para ``PyObject*``, ou ``NULL`` se ocorrer um erro."

#: ../../c-api/extension-modules.rst:170
msgid ""
"Calling this function is required for :ref:`multi-phase-initialization`. It "
"should not be used in other contexts."
msgstr ""
"A chamada desta função é necessária para :ref:`multi-phase-initialization`. "
"Ela não deve ser usada em outros contextos."

#: ../../c-api/extension-modules.rst:173
msgid ""
"Note that Python assumes that ``PyModuleDef`` structures are statically "
"allocated. This function may return either a new reference or a borrowed "
"one; this reference must not be released."
msgstr ""
"Observe que o Python assume que as estruturas ``PyModuleDef`` são alocadas "
"estaticamente. Esta função pode retornar uma nova referência ou uma "
"referência emprestada; esta referência não deve ser liberada."

#: ../../c-api/extension-modules.rst:184
msgid "Legacy single-phase initialization"
msgstr "Inicialização monofásica legada"

#: ../../c-api/extension-modules.rst:187
msgid ""
"Single-phase initialization is a legacy mechanism to initialize extension "
"modules, with known drawbacks and design flaws. Extension module authors are "
"encouraged to use multi-phase initialization instead."
msgstr ""
"A inicialização monofásica é um mecanismo legado para inicializar módulos de "
"extensão, com desvantagens e falhas de projeto conhecidas. Os autores de "
"módulos de extensão são incentivados a utilizar a inicialização multifásica."

#: ../../c-api/extension-modules.rst:191
msgid ""
"In single-phase initialization, the :ref:`initialization function <extension-"
"export-hook>` (``PyInit_modulename``) should create, populate and return a "
"module object. This is typically done using :c:func:`PyModule_Create` and "
"functions like :c:func:`PyModule_AddObjectRef`."
msgstr ""
"Na inicialização monofásica, a :ref:`função de inicialização <extension-"
"export-hook>` (``PyInit_modulename``) deve criar, preencher e retornar um "
"objeto de módulo. Isso normalmente é feito usando :c:func:`PyModule_Create` "
"e funções como :c:func:`PyModule_AddObjectRef`."

#: ../../c-api/extension-modules.rst:197
msgid ""
"Single-phase initialization differs from the :ref:`default <multi-phase-"
"initialization>` in the following ways:"
msgstr ""
"A inicialização monofásica difere do :ref:`padrão <multi-phase-"
"initialization>` nas seguintes maneiras:"

#: ../../c-api/extension-modules.rst:200
msgid "Single-phase modules are, or rather *contain*, “singletons”."
msgstr "Módulos monofásicos são, ou melhor, *contêm*, “singletons”."

#: ../../c-api/extension-modules.rst:202
msgid ""
"When the module is first initialized, Python saves the contents of the "
"module's ``__dict__`` (that is, typically, the module's functions and types)."
msgstr ""
"Quando o módulo é inicializado pela primeira vez, o Python salva o conteúdo "
"do ``__dict__`` do módulo (ou seja, normalmente, as funções e os tipos do "
"módulo)."

#: ../../c-api/extension-modules.rst:206
msgid ""
"For subsequent imports, Python does not call the initialization function "
"again. Instead, it creates a new module object with a new ``__dict__``, and "
"copies the saved contents to it. For example, given a single-phase module "
"``_testsinglephase`` [#testsinglephase]_ that defines a function ``sum`` and "
"an exception class ``error``:"
msgstr ""
"Para importações subsequentes, o Python não chama a função de inicialização "
"novamente. Em vez disso, ele cria um novo objeto de módulo com um novo "
"``__dict__`` e copia o conteúdo salvo para ele. Por exemplo, dado um módulo "
"monofásico ``_testsinglephase`` [#testsinglephase]_ que define uma função "
"``sum`` e uma classe de exceção ``error``:"

#: ../../c-api/extension-modules.rst:214
msgid ""
">>> import sys\n"
">>> import _testsinglephase as one\n"
">>> del sys.modules['_testsinglephase']\n"
">>> import _testsinglephase as two\n"
">>> one is two\n"
"False\n"
">>> one.__dict__ is two.__dict__\n"
"False\n"
">>> one.sum is two.sum\n"
"True\n"
">>> one.error is two.error\n"
"True"
msgstr ""
">>> import sys\n"
">>> import _testsinglephase as one\n"
">>> del sys.modules['_testsinglephase']\n"
">>> import _testsinglephase as two\n"
">>> one is two\n"
"False\n"
">>> one.__dict__ is two.__dict__\n"
"False\n"
">>> one.sum is two.sum\n"
"True\n"
">>> one.error is two.error\n"
"True"

#: ../../c-api/extension-modules.rst:229
msgid ""
"The exact behavior should be considered a CPython implementation detail."
msgstr ""
"O comportamento exato deve ser considerado um detalhe da implementação do "
"CPython."

#: ../../c-api/extension-modules.rst:231
msgid ""
"To work around the fact that ``PyInit_modulename`` does not take a *spec* "
"argument, some state of the import machinery is saved and applied to the "
"first suitable module created during the ``PyInit_modulename`` call. "
"Specifically, when a sub-module is imported, this mechanism prepends the "
"parent package name to the name of the module."
msgstr ""
"Para contornar o fato de que ``PyInit_modulename`` não aceita um argumento "
"*spec*, parte do estado do mecanismo de importação é salvo e aplicado ao "
"primeiro módulo adequado criado durante a chamada ``PyInit_modulename``. "
"Especificamente, quando um submódulo é importado, esse mecanismo adiciona o "
"nome do pacote pai ao nome do módulo."

#: ../../c-api/extension-modules.rst:237
msgid ""
"A single-phase ``PyInit_modulename`` function should create “its” module "
"object as soon as possible, before any other module objects can be created."
msgstr ""
"Uma função monofásica ``PyInit_modulename`` deve criar “seu” objeto de "
"módulo o mais rápido possível, antes que qualquer outro objeto de módulo "
"possa ser criado."

#: ../../c-api/extension-modules.rst:240
msgid "Non-ASCII module names (``PyInitU_modulename``) are not supported."
msgstr ""
"Nomes de módulos não ASCII (``PyInitU_modulename``) não são suportados."

#: ../../c-api/extension-modules.rst:242
msgid ""
"Single-phase modules support module lookup functions like :c:func:"
"`PyState_FindModule`."
msgstr ""
"Módulos monofásicos oferecem suporte a funções de pesquisa de módulos como :"
"c:func:`PyState_FindModule`."

#: ../../c-api/extension-modules.rst:245
msgid ""
"``_testsinglephase`` is an internal module used in CPython's self-test "
"suite; your installation may or may not include it."
msgstr ""
"``_testsinglephase`` é um módulo interno usado no conjunto de autotestes do "
"CPython; sua instalação pode ou não incluí-lo."

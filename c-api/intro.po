# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-21 14:14+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../c-api/intro.rst:8
msgid "Introduction"
msgstr "Introdução"

#: ../../c-api/intro.rst:10
msgid ""
"The Application Programmer's Interface to Python gives C and C++ programmers "
"access to the Python interpreter at a variety of levels.  The API is equally "
"usable from C++, but for brevity it is generally referred to as the Python/C "
"API.  There are two fundamentally different reasons for using the Python/C "
"API. The first reason is to write *extension modules* for specific purposes; "
"these are C modules that extend the Python interpreter.  This is probably "
"the most common use.  The second reason is to use Python as a component in a "
"larger application; this technique is generally referred to as :dfn:"
"`embedding` Python in an application."
msgstr ""
"A Interface de Programação de Aplicações (API) para Python fornece aos "
"programadores C e C++ acesso ao interpretador Python em uma variedade de "
"níveis. A API pode ser usada igualmente em C++, mas, para abreviar, "
"geralmente é chamada de API Python/C. Existem dois motivos fundamentalmente "
"diferentes para usar a API Python/C. A primeira razão é escrever *módulos de "
"extensão* para propósitos específicos; esses são módulos C que estendem o "
"interpretador Python. Este é provavelmente o uso mais comum. O segundo "
"motivo é usar Python como um componente em uma aplicação maior; esta técnica "
"é geralmente referida como :dfn:`incorporação` Python em uma aplicação."

#: ../../c-api/intro.rst:20
msgid ""
"Writing an extension module is a relatively well-understood process, where a "
"\"cookbook\" approach works well.  There are several tools that automate the "
"process to some extent.  While people have embedded Python in other "
"applications since its early existence, the process of embedding Python is "
"less straightforward than writing an extension."
msgstr ""
"Escrever um módulo de extensão é um processo relativamente bem compreendido, "
"no qual uma abordagem de \"livro de receitas\" funciona bem. Existem várias "
"ferramentas que automatizam o processo até certo ponto. Embora as pessoas "
"tenham incorporado o Python em outras aplicações desde sua existência "
"inicial, o processo de incorporação do Python é menos direto do que escrever "
"uma extensão."

#: ../../c-api/intro.rst:26
msgid ""
"Many API functions are useful independent of whether you're embedding  or "
"extending Python; moreover, most applications that embed Python  will need "
"to provide a custom extension as well, so it's probably a  good idea to "
"become familiar with writing an extension before  attempting to embed Python "
"in a real application."
msgstr ""
"Muitas funções da API são úteis independentemente de você estar incorporando "
"ou estendendo o Python; além disso, a maioria das aplicações que incorporam "
"Python também precisará fornecer uma extensão customizada, portanto, é "
"provavelmente uma boa ideia se familiarizar com a escrita de uma extensão "
"antes de tentar incorporar Python em uma aplicação real."

#: ../../c-api/intro.rst:34
msgid "Language version compatibility"
msgstr "Compatibilidade com a versão da linguagem"

#: ../../c-api/intro.rst:36
msgid "Python's C API is compatible with C11 and C++11 versions of C and C++."
msgstr "A API C do Python é compatível com as versões C11 e C++11 do C e C++."

#: ../../c-api/intro.rst:38
msgid ""
"This is a lower limit: the C API does not require features from later C/C++ "
"versions. You do *not* need to enable your compiler's \"c11 mode\"."
msgstr ""
"Este é um limite inferior: a API C não requer recursos de versões "
"posteriores de C/C++. Você *não* precisa habilitar o \"modo c11\" do seu "
"compilador."

#: ../../c-api/intro.rst:44
msgid "Coding standards"
msgstr "Padrões de codificação"

#: ../../c-api/intro.rst:46
msgid ""
"If you're writing C code for inclusion in CPython, you **must** follow the "
"guidelines and standards defined in :PEP:`7`.  These guidelines apply "
"regardless of the version of Python you are contributing to.  Following "
"these conventions is not necessary for your own third party extension "
"modules, unless you eventually expect to contribute them to Python."
msgstr ""
"Se você estiver escrevendo código C para inclusão no CPython, **deve** "
"seguir as diretrizes e padrões definidos na :PEP:`7`. Essas diretrizes se "
"aplicam independentemente da versão do Python com a qual você está "
"contribuindo. Seguir essas convenções não é necessário para seus próprios "
"módulos de extensão de terceiros, a menos que você eventualmente espere "
"contribuí-los para o Python."

#: ../../c-api/intro.rst:56
msgid "Include Files"
msgstr "Arquivos de inclusão"

#: ../../c-api/intro.rst:58
msgid ""
"All function, type and macro definitions needed to use the Python/C API are "
"included in your code by the following line::"
msgstr ""
"Todas as definições de função, tipo e macro necessárias para usar a API "
"Python/C estão incluídas em seu código pela seguinte linha::"

#: ../../c-api/intro.rst:61
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>"

#: ../../c-api/intro.rst:64
msgid ""
"This implies inclusion of the following standard headers: ``<stdio.h>``, "
"``<string.h>``, ``<errno.h>``, ``<limits.h>``, ``<assert.h>`` and ``<stdlib."
"h>`` (if available)."
msgstr ""
"Isso implica a inclusão dos seguintes cabeçalhos padrão: ``<stdio.h>``, "
"``<string.h>``, ``<errno.h>``, ``<limits.h>``, ``<assert.h>`` e ``<stdlib."
"h>`` (se disponível)."

#: ../../c-api/intro.rst:70
msgid ""
"Since Python may define some pre-processor definitions which affect the "
"standard headers on some systems, you *must* include :file:`Python.h` before "
"any standard headers are included."
msgstr ""
"Uma vez que Python pode definir algumas definições de pré-processador que "
"afetam os cabeçalhos padrão em alguns sistemas, você *deve* incluir :file:"
"`Python.h` antes de quaisquer cabeçalhos padrão serem incluídos."

#: ../../c-api/intro.rst:74
msgid ""
"It is recommended to always define ``PY_SSIZE_T_CLEAN`` before including "
"``Python.h``.  See :ref:`arg-parsing` for a description of this macro."
msgstr ""
"É recomendável sempre definir ``PY_SSIZE_T_CLEAN`` antes de incluir ``Python."
"h``. Veja :ref:`arg-parsing` para uma descrição desta macro."

#: ../../c-api/intro.rst:77
msgid ""
"All user visible names defined by Python.h (except those defined by the "
"included standard headers) have one of the prefixes ``Py`` or ``_Py``.  "
"Names beginning with ``_Py`` are for internal use by the Python "
"implementation and should not be used by extension writers. Structure member "
"names do not have a reserved prefix."
msgstr ""
"Todos os nomes visíveis ao usuário definidos por Python.h (exceto aqueles "
"definidos pelos cabeçalhos padrão incluídos) têm um dos prefixos ``Py`` ou "
"``_Py``. Nomes começando com ``_Py`` são para uso interno pela implementação "
"Python e não devem ser usados por escritores de extensão. Os nomes dos "
"membros da estrutura não têm um prefixo reservado."

#: ../../c-api/intro.rst:84
msgid ""
"User code should never define names that begin with ``Py`` or ``_Py``. This "
"confuses the reader, and jeopardizes the portability of the user code to "
"future Python versions, which may define additional names beginning with one "
"of these prefixes."
msgstr ""
"O código do usuário nunca deve definir nomes que começam com ``Py`` ou "
"``_Py``. Isso confunde o leitor e coloca em risco a portabilidade do código "
"do usuário para versões futuras do Python, que podem definir nomes "
"adicionais começando com um desses prefixos."

#: ../../c-api/intro.rst:89
msgid ""
"The header files are typically installed with Python.  On Unix, these  are "
"located in the directories :file:`{prefix}/include/pythonversion/` and :file:"
"`{exec_prefix}/include/pythonversion/`, where :option:`prefix <--prefix>` "
"and :option:`exec_prefix <--exec-prefix>` are defined by the corresponding "
"parameters to Python's :program:`configure` script and *version* is ``'%d."
"%d' % sys.version_info[:2]``.  On Windows, the headers are installed in :"
"file:`{prefix}/include`, where ``prefix`` is the installation directory "
"specified to the installer."
msgstr ""
"Os arquivos de cabeçalho são normalmente instalados com Python. No Unix, "
"eles estão localizados nos diretórios :file:`{prefix}/include/pythonversion/"
"` e :file:`{exec_prefix}/include/pythonversion/`, onde :option:`prefix <--"
"prefix>` e :option:`exec_prefix <--exec-prefix>` são definidos pelos "
"parâmetros correspondentes ao script :program:`configure` e *version* do "
"Python é ``'%d.%d' % sys.version_info[:2]``. No Windows, os cabeçalhos são "
"instalados em :file:`{prefix}/include`, onde ``prefix`` é o diretório de "
"instalação especificado para o instalador."

#: ../../c-api/intro.rst:98
msgid ""
"To include the headers, place both directories (if different) on your "
"compiler's search path for includes.  Do *not* place the parent directories "
"on the search path and then use ``#include <pythonX.Y/Python.h>``; this will "
"break on multi-platform builds since the platform independent headers under :"
"option:`prefix <--prefix>` include the platform specific headers from :"
"option:`exec_prefix <--exec-prefix>`."
msgstr ""
"Para incluir os cabeçalhos, coloque os dois diretórios (se diferentes) no "
"caminho de pesquisa do compilador para as inclusões. *Não* coloque os "
"diretórios pais no caminho de busca e então use ``#include <pythonX.Y/Python."
"h>``; isto irá quebrar em compilações multiplataforma, uma vez que os "
"cabeçalhos independentes da plataforma em :option:`prefix <--prefix>` "
"incluem os cabeçalhos específicos da plataforma de :option:`exec_prefix <--"
"exec-prefix>`."

#: ../../c-api/intro.rst:105
msgid ""
"C++ users should note that although the API is defined entirely using C, the "
"header files properly declare the entry points to be ``extern \"C\"``. As a "
"result, there is no need to do anything special to use the API from C++."
msgstr ""
"Os usuários de C++ devem notar que embora a API seja definida inteiramente "
"usando C, os arquivos de cabeçalho declaram apropriadamente os pontos de "
"entrada como ``extern \"C\"``. Como resultado, não há necessidade de fazer "
"nada especial para usar a API do C++."

#: ../../c-api/intro.rst:111
msgid "Useful macros"
msgstr "Macros úteis"

#: ../../c-api/intro.rst:113
msgid ""
"Several useful macros are defined in the Python header files.  Many are "
"defined closer to where they are useful (for example, :c:macro:"
"`Py_RETURN_NONE`, :c:macro:`PyMODINIT_FUNC`). Others of a more general "
"utility are defined here.  This is not necessarily a complete listing."
msgstr ""
"Diversas macros úteis são definidas nos arquivos de cabeçalho do Python. "
"Muitas são definidas mais próximas de onde são úteis (por exemplo, :c:macro:"
"`Py_RETURN_NONE`, :c:macro:`PyMODINIT_FUNC`). Outras de utilidade mais geral "
"são definidas aqui. Esta não é necessariamente uma lista completa."

#: ../../c-api/intro.rst:122
msgid "Return the absolute value of ``x``."
msgstr "Retorna o valor absoluto de ``x``."

#: ../../c-api/intro.rst:124
msgid ""
"If the result cannot be represented (for example, if ``x`` has :c:macro:`!"
"INT_MIN` value for :c:expr:`int` type), the behavior is undefined."
msgstr ""
"Se o resultado não puder ser representado (por exemplo, se ``x`` tiver o "
"valor :c:macro:`!INT_MIN` para o tipo :c:expr:`int`), o comportamento é "
"indefinido."

#: ../../c-api/intro.rst:132
msgid ""
"Ask the compiler to always inline a static inline function. The compiler can "
"ignore it and decide to not inline the function."
msgstr ""
"Pede ao compilador para sempre embutir uma função em linha estática. O "
"compilador pode ignorá-lo e decide não inserir a função."

#: ../../c-api/intro.rst:135
msgid ""
"It can be used to inline performance critical static inline functions when "
"building Python in debug mode with function inlining disabled. For example, "
"MSC disables function inlining when building in debug mode."
msgstr ""
"Ele pode ser usado para inserir funções em linha estáticas críticas de "
"desempenho ao compilar Python no modo de depuração com função de inserir em "
"linha desabilitada. Por exemplo, o MSC desabilita a função de inserir em "
"linha ao compilar no modo de depuração."

#: ../../c-api/intro.rst:139
msgid ""
"Marking blindly a static inline function with Py_ALWAYS_INLINE can result in "
"worse performances (due to increased code size for example). The compiler is "
"usually smarter than the developer for the cost/benefit analysis."
msgstr ""
"Marcar cegamente uma função em linha estática com Py_ALWAYS_INLINE pode "
"resultar em desempenhos piores (devido ao aumento do tamanho do código, por "
"exemplo). O compilador geralmente é mais inteligente que o desenvolvedor "
"para a análise de custo/benefício."

#: ../../c-api/intro.rst:143
msgid ""
"If Python is :ref:`built in debug mode <debug-build>` (if the :c:macro:"
"`Py_DEBUG` macro is defined), the :c:macro:`Py_ALWAYS_INLINE` macro does "
"nothing."
msgstr ""
"Se o Python tiver sido :ref:`compilado em modo de depuração <debug-build>` "
"(se a macro :c:macro:`Py_DEBUG` estiver definida), a macro :c:macro:"
"`Py_ALWAYS_INLINE` não fará nada."

#: ../../c-api/intro.rst:146
msgid "It must be specified before the function return type. Usage::"
msgstr "Deve ser especificado antes do tipo de retorno da função. Uso::"

#: ../../c-api/intro.rst:148
msgid "static inline Py_ALWAYS_INLINE int random(void) { return 4; }"
msgstr "static inline Py_ALWAYS_INLINE int random(void) { return 4; }"

#: ../../c-api/intro.rst:154
msgid ""
"Argument must be a character or an integer in the range [-128, 127] or [0, "
"255].  This macro returns ``c`` cast to an ``unsigned char``."
msgstr ""
"O argumento deve ser um caractere ou um número inteiro no intervalo [-128, "
"127] ou [0, 255]. Esta macro retorna ``c`` convertido em um ``unsigned "
"char``."

#: ../../c-api/intro.rst:159
msgid ""
"Use this for deprecated declarations.  The macro must be placed before the "
"symbol name."
msgstr ""
"Use isso para declarações descontinuadas. A macro deve ser colocada antes do "
"nome do símbolo."

#: ../../c-api/intro.rst:162 ../../c-api/intro.rst:290
#: ../../c-api/intro.rst:308
msgid "Example::"
msgstr "Exemplo::"

#: ../../c-api/intro.rst:164
msgid "Py_DEPRECATED(3.8) PyAPI_FUNC(int) Py_OldFunction(void);"
msgstr "Py_DEPRECATED(3.8) PyAPI_FUNC(int) Py_OldFunction(void);"

#: ../../c-api/intro.rst:166
msgid "MSVC support was added."
msgstr "Suporte a MSVC foi adicionado."

#: ../../c-api/intro.rst:171
msgid ""
"Like ``getenv(s)``, but returns ``NULL`` if :option:`-E` was passed on the "
"command line (see :c:member:`PyConfig.use_environment`)."
msgstr ""
"Como ``getenv(s)``, mas retorna ``NULL`` se a opção :option:`-E` foi passada "
"na linha de comando (veja :c:member:`PyConfig.use_environment`)."

#: ../../c-api/intro.rst:176
msgid ""
"Declare a function returning the specified *type* using a fast-calling "
"qualifier for functions that are local to the current file. Semantically, "
"this is equivalent to ``static type``."
msgstr ""
"Declara uma função que retorne o *type* especificado usando um qualificador "
"de chamada rápida para funções locais ao arquivo atual. Semanticamente, isso "
"equivale a ``static type``."

#: ../../c-api/intro.rst:182
msgid ""
"Equivalent to :c:macro:`Py_LOCAL` but additionally requests the function be "
"inlined."
msgstr ""
"Equivalente a :c:macro:`Py_LOCAL`, mas que também exige que a função seja "
"inserida localmente."

#: ../../c-api/intro.rst:187
msgid "Return the maximum value between ``x`` and ``y``."
msgstr "Retorna o valor máximo entre ``x`` e ``y``."

#: ../../c-api/intro.rst:193
msgid "Return the size of a structure (``type``) ``member`` in bytes."
msgstr "Retorna o tamanho do ``member`` de uma estrutura (``type``) em bytes."

#: ../../c-api/intro.rst:199
msgid ""
"This is a :term:`soft deprecated` alias to :c:func:`!memcpy`. Use :c:func:`!"
"memcpy` directly instead."
msgstr ""
"Este é um apelido :term:`suavemente descontinuado` para :c:func:`!memcpy`. "
"Usa :c:func:`!memcpy` diretamente."

#: ../../c-api/intro.rst:202
msgid "The macro is :term:`soft deprecated`."
msgstr ""
"A macro está :term:`suavemente descontinuada <suavemente descontinuado>`."

#: ../../c-api/intro.rst:207
msgid "Return the minimum value between ``x`` and ``y``."
msgstr "Retorna o valor mínimo entre ``x`` e ``y``."

#: ../../c-api/intro.rst:213
msgid ""
"Disable inlining on a function. For example, it reduces the C stack "
"consumption: useful on LTO+PGO builds which heavily inline code (see :issue:"
"`33720`)."
msgstr ""
"Desabilita a inserção em linha em uma função. Por exemplo, isso reduz o "
"consumo da pilha C: útil em compilações LTO+PGO que faz uso intenso de "
"inserção em linha de código (veja :issue:`33720`)."

#: ../../c-api/intro.rst:217
msgid "Usage::"
msgstr "Uso::"

#: ../../c-api/intro.rst:219
msgid "Py_NO_INLINE static int random(void) { return 4; }"
msgstr "Py_NO_INLINE static int random(void) { return 4; }"

#: ../../c-api/intro.rst:225
msgid ""
"Convert ``x`` to a C string.  E.g. ``Py_STRINGIFY(123)`` returns ``\"123\"``."
msgstr ""
"Converte ``x`` para uma string C. Por exemplo, ``Py_STRINGIFY(123)`` retorna "
"``\"123\"``."

#: ../../c-api/intro.rst:232
msgid ""
"Use this when you have a code path that cannot be reached by design. For "
"example, in the ``default:`` clause in a ``switch`` statement for which all "
"possible values are covered in ``case`` statements.  Use this in places "
"where you might be tempted to put an ``assert(0)`` or ``abort()`` call."
msgstr ""
"Use isso quando você tiver um caminho de código que não pode ser alcançado "
"por design. Por exemplo, na cláusula ``default:`` em uma instrução "
"``switch`` para a qual todos os valores possíveis são incluídos nas "
"instruções ``case``. Use isto em lugares onde você pode ficar tentado a "
"colocar uma chamada ``assert(0)`` ou ``abort()``."

#: ../../c-api/intro.rst:237
msgid ""
"In release mode, the macro helps the compiler to optimize the code, and "
"avoids a warning about unreachable code.  For example, the macro is "
"implemented with ``__builtin_unreachable()`` on GCC in release mode."
msgstr ""
"No modo de lançamento, a macro ajuda o compilador a otimizar o código e "
"evita um aviso sobre código inacessível. Por exemplo, a macro é implementada "
"com ``__builtin_unreachable()`` no GCC em modo de lançamento."

#: ../../c-api/intro.rst:241
msgid ""
"A use for ``Py_UNREACHABLE()`` is following a call a function that never "
"returns but that is not declared :c:macro:`_Py_NO_RETURN`."
msgstr ""
"Um uso para ``Py_UNREACHABLE()`` é seguir uma chamada de uma função que "
"nunca retorna, mas que não é declarada com :c:macro:`_Py_NO_RETURN`."

#: ../../c-api/intro.rst:244
msgid ""
"If a code path is very unlikely code but can be reached under exceptional "
"case, this macro must not be used.  For example, under low memory condition "
"or if a system call returns a value out of the expected range.  In this "
"case, it's better to report the error to the caller.  If the error cannot be "
"reported to caller, :c:func:`Py_FatalError` can be used."
msgstr ""
"Se um caminho de código for um código muito improvável, mas puder ser "
"alcançado em casos excepcionais, esta macro não deve ser usada. Por exemplo, "
"sob condição de pouca memória ou se uma chamada de sistema retornar um valor "
"fora do intervalo esperado. Nesse caso, é melhor relatar o erro ao chamador. "
"Se o erro não puder ser reportado ao chamador, :c:func:`Py_FatalError` pode "
"ser usada."

#: ../../c-api/intro.rst:254
msgid ""
"Use this for unused arguments in a function definition to silence compiler "
"warnings. Example: ``int func(int a, int Py_UNUSED(b)) { return a; }``."
msgstr ""
"Use isso para argumentos não usados em uma definição de função para "
"silenciar avisos do compilador. Exemplo: ``int func(int a, int Py_UNUSED(b)) "
"{ return a; }``."

#: ../../c-api/intro.rst:261
msgid ""
"Asserts a compile-time condition *cond*, as a statement. The build will fail "
"if the condition is false or cannot be evaluated at compile time."
msgstr ""
"Realiza asserção de uma condição de tempo de compilação *cond*, como uma "
"instrução. A construção falhará se a condição for falsa ou não puder ser "
"avaliada em tempo de compilação."

#: ../../c-api/intro.rst:264 ../../c-api/intro.rst:275
#: ../../c-api/intro.rst:320
msgid "For example::"
msgstr "Por exemplo::"

#: ../../c-api/intro.rst:266
msgid "Py_BUILD_ASSERT(sizeof(PyTime_t) == sizeof(int64_t));"
msgstr "Py_BUILD_ASSERT(sizeof(PyTime_t) == sizeof(int64_t));"

#: ../../c-api/intro.rst:272
msgid ""
"Asserts a compile-time condition *cond*, as an expression that evaluates to "
"``0``. The build will fail if the condition is false or cannot be evaluated "
"at compile time."
msgstr ""
"Realiza asserção de uma condição de tempo de compilação *cond*, como uma "
"expressão que é avaliada com ``0``. A construção falhará se a condição for "
"falsa ou não puder ser avaliada em tempo de compilação."

#: ../../c-api/intro.rst:277
msgid ""
"#define foo_to_char(foo) \\\n"
"    ((char *)(foo) + Py_BUILD_ASSERT_EXPR(offsetof(struct foo, string) == 0))"
msgstr ""
"#define foo_to_char(foo) \\\n"
"    ((char *)(foo) + Py_BUILD_ASSERT_EXPR(offsetof(struct foo, string) == 0))"

#: ../../c-api/intro.rst:284
msgid ""
"Creates a variable with name *name* that can be used in docstrings. If "
"Python is built without docstrings, the value will be empty."
msgstr ""
"Cria uma variável com o nome *name* que pode ser usada em docstrings. Se o "
"Python for construído sem docstrings, o valor estará vazio."

#: ../../c-api/intro.rst:287
msgid ""
"Use :c:macro:`PyDoc_STRVAR` for docstrings to support building Python "
"without docstrings, as specified in :pep:`7`."
msgstr ""
"Use :c:macro:`PyDoc_STRVAR` para docstrings para ter suporte à compilação do "
"Python sem docstrings, conforme especificado em :pep:`7`."

#: ../../c-api/intro.rst:292
msgid ""
"PyDoc_STRVAR(pop_doc, \"Remove and return the rightmost element.\");\n"
"\n"
"static PyMethodDef deque_methods[] = {\n"
"    // ...\n"
"    {\"pop\", (PyCFunction)deque_pop, METH_NOARGS, pop_doc},\n"
"    // ...\n"
"}"
msgstr ""
"PyDoc_STRVAR(pop_doc, \"Remove e retorna o elemento mais à direita.\");\n"
"\n"
"static PyMethodDef deque_methods[] = {\n"
"    // ...\n"
"    {\"pop\", (PyCFunction)deque_pop, METH_NOARGS, pop_doc},\n"
"    // ...\n"
"}"

#: ../../c-api/intro.rst:302
msgid ""
"Creates a docstring for the given input string or an empty string if "
"docstrings are disabled."
msgstr ""
"Cria uma docstring para a string de entrada fornecida ou uma string vazia se "
"docstrings estiverem desabilitadas."

#: ../../c-api/intro.rst:305
msgid ""
"Use :c:macro:`PyDoc_STR` in specifying docstrings to support building Python "
"without docstrings, as specified in :pep:`7`."
msgstr ""
"Use :c:macro:`PyDoc_STR` ao especificar docstrings para ter suporte à "
"compilação do Python sem docstrings, conforme especificado em :pep:`7`."

#: ../../c-api/intro.rst:310
msgid ""
"static PyMethodDef pysqlite_row_methods[] = {\n"
"    {\"keys\", (PyCFunction)pysqlite_row_keys, METH_NOARGS,\n"
"        PyDoc_STR(\"Returns the keys of the row.\")},\n"
"    {NULL, NULL}\n"
"};"
msgstr ""
"static PyMethodDef pysqlite_row_methods[] = {\n"
"    {\"keys\", (PyCFunction)pysqlite_row_keys, METH_NOARGS,\n"
"        PyDoc_STR(\"Retorna as chaves da linha.\")},\n"
"    {NULL, NULL}\n"
"};"

#: ../../c-api/intro.rst:318
msgid "Declares a static character array variable with the given name *name*."
msgstr ""
"Declara uma variável estática de vetor de caracteres com o nome fornecido "
"*name*."

#: ../../c-api/intro.rst:322
msgid ""
"PyDoc_VAR(python_doc) = PyDoc_STR(\"A genus of constricting snakes in the "
"Pythonidae family native \"\n"
"                                  \"to the tropics and subtropics of the "
"Eastern Hemisphere.\");"
msgstr ""
"PyDoc_VAR(python_doc) = PyDoc_STR(\"A genus of constricting snakes in the "
"Pythonidae family native \"\n"
"                                  \"to the tropics and subtropics of the "
"Eastern Hemisphere.\");"

#: ../../c-api/intro.rst:329
msgid "Objects, Types and Reference Counts"
msgstr "Objetos, tipos e contagens de referências"

#: ../../c-api/intro.rst:333
msgid ""
"Most Python/C API functions have one or more arguments as well as a return "
"value of type :c:expr:`PyObject*`.  This type is a pointer to an opaque data "
"type representing an arbitrary Python object.  Since all Python object types "
"are treated the same way by the Python language in most situations (e.g., "
"assignments, scope rules, and argument passing), it is only fitting that "
"they should be represented by a single C type.  Almost all Python objects "
"live on the heap: you never declare an automatic or static variable of type :"
"c:type:`PyObject`, only pointer variables of type :c:expr:`PyObject*` can  "
"be declared.  The sole exception are the type objects; since these must "
"never be deallocated, they are typically static :c:type:`PyTypeObject` "
"objects."
msgstr ""
"A maioria das funções da API Python/C tem um ou mais argumentos, bem como um "
"valor de retorno do tipo :c:expr:`PyObject*`. Este tipo é um ponteiro para "
"um tipo de dados opaco que representa um objeto Python arbitrário. Como "
"todos os tipos de objeto Python são tratados da mesma maneira pela linguagem "
"Python na maioria das situações (por exemplo, atribuições, regras de escopo "
"e passagem de argumento), é adequado que eles sejam representados por um "
"único tipo C. Quase todos os objetos Python vivem na pilha: você nunca "
"declara uma variável automática ou estática do tipo :c:type:`PyObject`, "
"variáveis de apenas ponteiro do tipo :c:expr:`PyObject*` podem ser "
"declaradas. A única exceção são os objetos de tipo; uma vez que estes nunca "
"devem ser desalocados, eles são normalmente objetos estáticos :c:type:"
"`PyTypeObject`."

#: ../../c-api/intro.rst:344
msgid ""
"All Python objects (even Python integers) have a :dfn:`type` and a :dfn:"
"`reference count`.  An object's type determines what kind of object it is (e."
"g., an integer, a list, or a user-defined function; there are many more as "
"explained in :ref:`types`).  For each of the well-known types there is a "
"macro to check whether an object is of that type; for instance, "
"``PyList_Check(a)`` is true if (and only if) the object pointed to by *a* is "
"a Python list."
msgstr ""
"Todos os objetos Python (mesmo inteiros Python) têm um :dfn:`tipo` e uma :"
"dfn:`contagem de referências`. O tipo de um objeto determina que tipo de "
"objeto ele é (por exemplo, um número inteiro, uma lista ou uma função "
"definida pelo usuário; existem muitos mais, conforme explicado em :ref:"
"`types`). Para cada um dos tipos conhecidos, há uma macro para verificar se "
"um objeto é desse tipo; por exemplo, ``PyList_Check(a)`` é verdadeiro se (e "
"somente se) o objeto apontado por *a* for uma lista Python."

#: ../../c-api/intro.rst:355
msgid "Reference Counts"
msgstr "Contagens de referências"

#: ../../c-api/intro.rst:357
msgid ""
"The reference count is important because today's computers have a  finite "
"(and often severely limited) memory size; it counts how many different "
"places there are that have a :term:`strong reference` to an object. Such a "
"place could be another object, or a global (or static) C variable, or a "
"local variable in some C function. When the last :term:`strong reference` to "
"an object is released (i.e. its reference count becomes zero), the object is "
"deallocated. If it contains references to other objects, those references "
"are released. Those other objects may be deallocated in turn, if there are "
"no more references to them, and so on.  (There's an obvious problem  with "
"objects that reference each other here; for now, the solution is \"don't do "
"that.\")"
msgstr ""
"A contagem de referências é importante porque os computadores atuais têm um "
"tamanho de memória finito (e frequentemente severamente limitado); ela conta "
"quantos lugares diferentes existem que possuem uma :term:`referência forte` "
"a um objeto. Tal lugar pode ser outro objeto, ou uma variável C global (ou "
"estática), ou uma variável local em alguma função C. Quando a última :term:"
"`referência forte` a um objeto é liberada (ou seja, sua contagem de "
"referências se torna zero), o objeto é desalocado. Se ele contiver "
"referências a outros objetos, essas referências são liberadas. Esses outros "
"objetos podem ser desalocados por sua vez, se não houver mais referências a "
"eles, e assim por diante. (Há um problema óbvio com objetos que referenciam "
"uns aos outros aqui; por enquanto, a solução é \"não faça isso\".)"

#: ../../c-api/intro.rst:374
msgid ""
"Reference counts are always manipulated explicitly.  The normal way is to "
"use the macro :c:func:`Py_INCREF` to take a new reference to an object (i.e. "
"increment its reference count by one), and :c:func:`Py_DECREF` to release "
"that reference (i.e. decrement the reference count by one).  The :c:func:"
"`Py_DECREF` macro is considerably more complex than the incref one, since it "
"must check whether the reference count becomes zero and then cause the "
"object's deallocator to be called.  The deallocator is a function pointer "
"contained in the object's type structure.  The type-specific deallocator "
"takes care of releasing references for other objects contained in the object "
"if this is a compound object type, such as a list, as well as performing any "
"additional finalization that's needed.  There's no chance that the reference "
"count can overflow; at least as many bits are used to hold the reference "
"count as there are distinct memory locations in virtual memory (assuming "
"``sizeof(Py_ssize_t) >= sizeof(void*)``). Thus, the reference count "
"increment is a simple operation."
msgstr ""
"Contagens de referências são sempre manipuladas explicitamente. A maneira "
"normal é usar a macro :c:func:`Py_INCREF` para obter uma nova referência a "
"um objeto (ou seja, incrementar sua contagem de referências em um), e :c:"
"func:`Py_DECREF` para liberar essa referência (ou seja, decrementar a "
"contagem de referências em um). A macro :c:func:`Py_DECREF` é "
"consideravelmente mais complexa do que a incref, pois deve verificar se a "
"contagem de referências se torna zero e, em seguida, fazer com que o "
"desalocador do objeto seja chamado. O desalocador é um ponteiro para função "
"contido na estrutura de tipo do objeto. O desalocador específico do tipo "
"cuida da liberação de referências para outros objetos contidos no objeto se "
"este for um tipo de objeto composto, como uma lista, bem como de executar "
"qualquer finalização adicional necessária. Não há chance de a contagem de "
"referências transbordar; pelo menos tantos bits são usados para armazenar a "
"contagem de referência quantos forem os locais de memória distintos na "
"memória virtual (presumindo ``sizeof(Py_ssize_t) >= sizeof(void*)``). "
"Portanto, o incremento da contagem de referências é uma operação simples."

#: ../../c-api/intro.rst:390
msgid ""
"It is not necessary to hold a :term:`strong reference` (i.e. increment the "
"reference count) for every local variable that contains a pointer to an "
"object.  In theory, the  object's reference count goes up by one when the "
"variable is made to  point to it and it goes down by one when the variable "
"goes out of  scope.  However, these two cancel each other out, so at the end "
"the  reference count hasn't changed.  The only real reason to use the  "
"reference count is to prevent the object from being deallocated as  long as "
"our variable is pointing to it.  If we know that there is at  least one "
"other reference to the object that lives at least as long as our variable, "
"there is no need to take a new :term:`strong reference` (i.e. increment the "
"reference count) temporarily. An important situation where this arises is in "
"objects  that are passed as arguments to C functions in an extension module  "
"that are called from Python; the call mechanism guarantees to hold a  "
"reference to every argument for the duration of the call."
msgstr ""
"Não é necessário manter uma :term:`referência forte` (ou seja, incrementar a "
"contagem de referências) para cada variável local que contém um ponteiro "
"para um objeto. Em teoria, a contagem de referências do objeto aumenta em um "
"quando a variável é feita para apontar para ele e diminui em um quando a "
"variável sai do escopo. No entanto, esses dois se cancelam, portanto, no "
"final, a contagem de referências não mudou. A única razão real para usar a "
"contagem de referências é evitar que o objeto seja desalocado enquanto nossa "
"variável estiver apontando para ele. Se sabemos que existe pelo menos uma "
"outra referência ao objeto que vive pelo menos tanto quanto nossa variável, "
"não há necessidade de tomar uma nova :term:`referência forte` (ou seja, "
"incrementar a contagem de referências) temporariamente. Uma situação "
"importante em que isso ocorre é em objetos que são passados como argumentos "
"para funções C em um módulo de extensão que são chamados de Python; o "
"mecanismo de chamada garante manter uma referência a todos os argumentos "
"durante a chamada."

#: ../../c-api/intro.rst:406
msgid ""
"However, a common pitfall is to extract an object from a list and hold on to "
"it for a while without taking a new reference.  Some other operation might "
"conceivably remove the object from the list, releasing that reference, and "
"possibly deallocating it. The real danger is that innocent-looking "
"operations may invoke arbitrary Python code which could do this; there is a "
"code path which allows control to flow back to the user from a :c:func:"
"`Py_DECREF`, so almost any operation is potentially dangerous."
msgstr ""
"No entanto, uma armadilha comum é extrair um objeto de uma lista e mantê-lo "
"por um tempo, sem tomar uma nova referência. Alguma outra operação poderia "
"remover o objeto da lista, liberando essa referência e possivelmente "
"desalocando-o. O perigo real é que operações aparentemente inocentes podem "
"invocar código Python arbitrário que poderia fazer isso; existe um caminho "
"de código que permite que o controle flua de volta para o usuário a partir "
"de um :c:func:`Py_DECREF`, então quase qualquer operação é potencialmente "
"perigosa."

#: ../../c-api/intro.rst:414
msgid ""
"A safe approach is to always use the generic operations (functions  whose "
"name begins with ``PyObject_``, ``PyNumber_``, ``PySequence_`` or "
"``PyMapping_``). These operations always create a new :term:`strong "
"reference` (i.e. increment the reference count) of the object they return. "
"This leaves the caller with the responsibility to call :c:func:`Py_DECREF` "
"when they are done with the result; this soon becomes second nature."
msgstr ""
"Uma abordagem segura é sempre usar as operações genéricas (funções cujo nome "
"começa com ``PyObject_``, ``PyNumber_``, ``PySequence_`` ou ``PyMapping_``). "
"Essas operações sempre criam uma nova :term:`referência forte` (ou seja, "
"incrementam a contagem de referências) do objeto que retornam. Isso deixa o "
"chamador com a responsabilidade de chamar :c:func:`Py_DECREF` quando "
"terminar com o resultado; isso logo se torna uma segunda natureza."

#: ../../c-api/intro.rst:425
msgid "Reference Count Details"
msgstr "Detalhes da contagem de referências"

#: ../../c-api/intro.rst:427
msgid ""
"The reference count behavior of functions in the Python/C API is best  "
"explained in terms of *ownership of references*.  Ownership pertains to "
"references, never to objects (objects are not owned: they are always "
"shared).  \"Owning a reference\" means being responsible for calling "
"Py_DECREF on it when the reference is no longer needed.  Ownership can also "
"be transferred, meaning that the code that receives ownership of the "
"reference then becomes responsible for eventually releasing it by calling :c:"
"func:`Py_DECREF` or :c:func:`Py_XDECREF` when it's no longer needed---or "
"passing on this responsibility (usually to its caller). When a function "
"passes ownership of a reference on to its caller, the caller is said to "
"receive a *new* reference.  When no ownership is transferred, the caller is "
"said to *borrow* the reference. Nothing needs to be done for a :term:"
"`borrowed reference`."
msgstr ""
"O comportamento da contagem de referências de funções na API C/Python é "
"melhor explicado em termos de *propriedade de referências*. A propriedade "
"pertence às referências, nunca aos objetos (os objetos não são possuídos: "
"eles são sempre compartilhados). \"Possuir uma referência\" significa ser "
"responsável por chamar Py_DECREF nela quando a referência não for mais "
"necessária. A propriedade também pode ser transferida, o que significa que o "
"código que recebe a propriedade da referência torna-se responsável por "
"eventualmente efetuar um liberando ela chamando :c:func:`Py_DECREF` ou :c:"
"func:`Py_XDECREF` quando não é mais necessário -- ou passando essa "
"responsabilidade (geralmente para o responsável pela chamada). Quando uma "
"função passa a propriedade de uma referência para seu chamador, diz-se que o "
"chamador recebe uma *nova* referência. Quando nenhuma propriedade é "
"transferida, diz-se que o chamador *toma emprestado* a referência. Nada "
"precisa ser feito para uma :term:`referência emprestada`."

#: ../../c-api/intro.rst:440
msgid ""
"Conversely, when a calling function passes in a reference to an  object, "
"there are two possibilities: the function *steals* a  reference to the "
"object, or it does not.  *Stealing a reference* means that when you pass a "
"reference to a function, that function assumes that it now owns that "
"reference, and you are not responsible for it any longer."
msgstr ""
"Por outro lado, quando uma função de chamada passa uma referência a um "
"objeto, há duas possibilidades: a função *rouba* uma referência ao objeto, "
"ou não. *Roubar uma referência* significa que quando você passa uma "
"referência para uma função, essa função presume que agora ela possui essa "
"referência e você não é mais responsável por ela."

#: ../../c-api/intro.rst:450
msgid ""
"Few functions steal references; the two notable exceptions are :c:func:"
"`PyList_SetItem` and :c:func:`PyTuple_SetItem`, which  steal a reference to "
"the item (but not to the tuple or list into which the item is put!).  These "
"functions were designed to steal a reference because of a common idiom for "
"populating a tuple or list with newly created objects; for example, the code "
"to create the tuple ``(1, 2, \"three\")`` could look like this (forgetting "
"about error handling for the moment; a better way to code this is shown "
"below)::"
msgstr ""
"Poucas funções roubam referências; as duas exceções notáveis são :c:func:"
"`PyList_SetItem` e :c:func:`PyTuple_SetItem`, que roubam uma referência para "
"o item (mas não para a tupla ou lista na qual o item é colocado!). Essas "
"funções foram projetadas para roubar uma referência devido a um idioma comum "
"para preencher uma tupla ou lista com objetos recém-criados; por exemplo, o "
"código para criar a tupla ``(1, 2, \"three\")`` pode ser parecido com isto "
"(esquecendo o tratamento de erros por enquanto; uma maneira melhor de "
"codificar isso é mostrada abaixo)::"

#: ../../c-api/intro.rst:458
msgid ""
"PyObject *t;\n"
"\n"
"t = PyTuple_New(3);\n"
"PyTuple_SetItem(t, 0, PyLong_FromLong(1L));\n"
"PyTuple_SetItem(t, 1, PyLong_FromLong(2L));\n"
"PyTuple_SetItem(t, 2, PyUnicode_FromString(\"three\"));"
msgstr ""
"PyObject *t;\n"
"\n"
"t = PyTuple_New(3);\n"
"PyTuple_SetItem(t, 0, PyLong_FromLong(1L));\n"
"PyTuple_SetItem(t, 1, PyLong_FromLong(2L));\n"
"PyTuple_SetItem(t, 2, PyUnicode_FromString(\"três\"));"

#: ../../c-api/intro.rst:465
msgid ""
"Here, :c:func:`PyLong_FromLong` returns a new reference which is immediately "
"stolen by :c:func:`PyTuple_SetItem`.  When you want to keep using an object "
"although the reference to it will be stolen, use :c:func:`Py_INCREF` to grab "
"another reference before calling the reference-stealing function."
msgstr ""
"Aqui, :c:func:`PyLong_FromLong` retorna uma nova referência que é "
"imediatamente roubada por :c:func:`PyTuple_SetItem`. Quando você quiser "
"continuar usando um objeto, embora a referência a ele seja roubada, use :c:"
"func:`Py_INCREF` para obter outra referência antes de chamar a função de "
"roubo de referência."

#: ../../c-api/intro.rst:470
msgid ""
"Incidentally, :c:func:`PyTuple_SetItem` is the *only* way to set tuple "
"items; :c:func:`PySequence_SetItem` and :c:func:`PyObject_SetItem` refuse to "
"do this since tuples are an immutable data type.  You should only use :c:"
"func:`PyTuple_SetItem` for tuples that you are creating yourself."
msgstr ""
"A propósito, :c:func:`PyTuple_SetItem` é a *única* maneira de definir itens "
"de tupla; :c:func:`PySequence_SetItem` e :c:func:`PyObject_SetItem` se "
"recusam a fazer isso, pois tuplas são um tipo de dados imutável. Você só "
"deve usar :c:func:`PyTuple_SetItem` para tuplas que você mesmo está criando."

#: ../../c-api/intro.rst:475
msgid ""
"Equivalent code for populating a list can be written using :c:func:"
"`PyList_New` and :c:func:`PyList_SetItem`."
msgstr ""
"O código equivalente para preencher uma lista pode ser escrita usando :c:"
"func:`PyList_New` e :c:func:`PyList_SetItem`."

#: ../../c-api/intro.rst:478
msgid ""
"However, in practice, you will rarely use these ways of creating and "
"populating a tuple or list.  There's a generic function, :c:func:"
"`Py_BuildValue`, that can create most common objects from C values, directed "
"by a :dfn:`format string`. For example, the above two blocks of code could "
"be replaced by the following (which also takes care of the error checking)::"
msgstr ""
"No entanto, na prática, você raramente usará essas maneiras de criar e "
"preencher uma tupla ou lista. Existe uma função genérica, :c:func:"
"`Py_BuildValue`, que pode criar objetos mais comuns a partir de valores C, "
"dirigidos por uma :dfn:`string de formato`. Por exemplo, os dois blocos de "
"código acima podem ser substituídos pelos seguintes (que também cuidam da "
"verificação de erros)::"

#: ../../c-api/intro.rst:484
msgid ""
"PyObject *tuple, *list;\n"
"\n"
"tuple = Py_BuildValue(\"(iis)\", 1, 2, \"three\");\n"
"list = Py_BuildValue(\"[iis]\", 1, 2, \"three\");"
msgstr ""
"PyObject *tuple, *list;\n"
"\n"
"tuple = Py_BuildValue(\"(iis)\", 1, 2, \"três\");\n"
"list = Py_BuildValue(\"[iis]\", 1, 2, \"três\");"

#: ../../c-api/intro.rst:489
msgid ""
"It is much more common to use :c:func:`PyObject_SetItem` and friends with "
"items whose references you are only borrowing, like arguments that were "
"passed in to the function you are writing.  In that case, their behaviour "
"regarding references is much saner, since you don't have to take a new "
"reference just so you can give that reference away (\"have it be stolen\").  "
"For example, this function sets all items of a list (actually, any mutable "
"sequence) to a given item::"
msgstr ""
"É muito mais comum usar :c:func:`PyObject_SetItem` e amigos com itens cujas "
"referências você está apenas pegando emprestado, como argumentos que foram "
"passados para a função que você está escrevendo. Nesse caso, o comportamento "
"deles em relação às referências é muito mais são, já que você não precisa "
"tomar uma nova referência só para poder doá-la (\"mande-a ser roubada\"). "
"Por exemplo, esta função define todos os itens de uma lista (na verdade, "
"qualquer sequência mutável) para um determinado item::"

#: ../../c-api/intro.rst:496
msgid ""
"int\n"
"set_all(PyObject *target, PyObject *item)\n"
"{\n"
"    Py_ssize_t i, n;\n"
"\n"
"    n = PyObject_Length(target);\n"
"    if (n < 0)\n"
"        return -1;\n"
"    for (i = 0; i < n; i++) {\n"
"        PyObject *index = PyLong_FromSsize_t(i);\n"
"        if (!index)\n"
"            return -1;\n"
"        if (PyObject_SetItem(target, index, item) < 0) {\n"
"            Py_DECREF(index);\n"
"            return -1;\n"
"        }\n"
"        Py_DECREF(index);\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""
"int\n"
"set_all(PyObject *target, PyObject *item)\n"
"{\n"
"    Py_ssize_t i, n;\n"
"\n"
"    n = PyObject_Length(target);\n"
"    if (n < 0)\n"
"        return -1;\n"
"    for (i = 0; i < n; i++) {\n"
"        PyObject *index = PyLong_FromSsize_t(i);\n"
"        if (!index)\n"
"            return -1;\n"
"        if (PyObject_SetItem(target, index, item) < 0) {\n"
"            Py_DECREF(index);\n"
"            return -1;\n"
"        }\n"
"        Py_DECREF(index);\n"
"    }\n"
"    return 0;\n"
"}"

#: ../../c-api/intro.rst:519
msgid ""
"The situation is slightly different for function return values.   While "
"passing a reference to most functions does not change your  ownership "
"responsibilities for that reference, many functions that  return a reference "
"to an object give you ownership of the reference. The reason is simple: in "
"many cases, the returned object is created  on the fly, and the reference "
"you get is the only reference to the  object.  Therefore, the generic "
"functions that return object references, like :c:func:`PyObject_GetItem` "
"and  :c:func:`PySequence_GetItem`, always return a new reference (the caller "
"becomes the owner of the reference)."
msgstr ""
"A situação é ligeiramente diferente para os valores de retorno da função. "
"Embora passar uma referência para a maioria das funções não altere suas "
"responsabilidades de propriedade para aquela referência, muitas funções que "
"retornam uma referência a um objeto fornecem a propriedade da referência. O "
"motivo é simples: em muitos casos, o objeto retornado é criado "
"instantaneamente e a referência que você obtém é a única referência ao "
"objeto. Portanto, as funções genéricas que retornam referências a objetos, "
"como :c:func:`PyObject_GetItem` e :c:func:`PySequence_GetItem`, sempre "
"retornam uma nova referência (o chamador torna-se o dono da referência)."

#: ../../c-api/intro.rst:528
msgid ""
"It is important to realize that whether you own a reference returned  by a "
"function depends on which function you call only --- *the plumage* (the type "
"of the object passed as an argument to the function) *doesn't enter into it!"
"* Thus, if you  extract an item from a list using :c:func:`PyList_GetItem`, "
"you don't own the reference --- but if you obtain the same item from the "
"same list using :c:func:`PySequence_GetItem` (which happens to take exactly "
"the same arguments), you do own a reference to the returned object."
msgstr ""
"É importante perceber que se você possui uma referência retornada por uma "
"função depende de qual função você chama apenas --- *a plumagem* (o tipo do "
"objeto passado como um argumento para a função) *não entra nela!* Assim, se "
"você extrair um item de uma lista usando :c:func:`PyList_GetItem`, você não "
"possui a referência --- mas se obtiver o mesmo item da mesma lista usando :c:"
"func:`PySequence_GetItem` (que leva exatamente os mesmos argumentos), você "
"possui uma referência ao objeto retornado."

#: ../../c-api/intro.rst:540
msgid ""
"Here is an example of how you could write a function that computes the sum "
"of the items in a list of integers; once using  :c:func:`PyList_GetItem`, "
"and once using :c:func:`PySequence_GetItem`. ::"
msgstr ""
"Aqui está um exemplo de como você poderia escrever uma função que calcula a "
"soma dos itens em uma lista de inteiros; uma vez usando :c:func:"
"`PyList_GetItem`, e uma vez usando :c:func:`PySequence_GetItem`. ::"

#: ../../c-api/intro.rst:544
msgid ""
"long\n"
"sum_list(PyObject *list)\n"
"{\n"
"    Py_ssize_t i, n;\n"
"    long total = 0, value;\n"
"    PyObject *item;\n"
"\n"
"    n = PyList_Size(list);\n"
"    if (n < 0)\n"
"        return -1; /* Not a list */\n"
"    for (i = 0; i < n; i++) {\n"
"        item = PyList_GetItem(list, i); /* Can't fail */\n"
"        if (!PyLong_Check(item)) continue; /* Skip non-integers */\n"
"        value = PyLong_AsLong(item);\n"
"        if (value == -1 && PyErr_Occurred())\n"
"            /* Integer too big to fit in a C long, bail out */\n"
"            return -1;\n"
"        total += value;\n"
"    }\n"
"    return total;\n"
"}"
msgstr ""
"long\n"
"sum_list(PyObject *list)\n"
"{\n"
"    Py_ssize_t i, n;\n"
"    long total = 0, value;\n"
"    PyObject *item;\n"
"\n"
"    n = PyList_Size(list);\n"
"    if (n < 0)\n"
"        return -1; /* Não é uma lista */\n"
"    for (i = 0; i < n; i++) {\n"
"        item = PyList_GetItem(list, i); /* Não pode falhar */\n"
"        if (!PyLong_Check(item)) continue; /* Ignora não-inteiros */\n"
"        value = PyLong_AsLong(item);\n"
"        if (value == -1 && PyErr_Occurred())\n"
"            /* Inteiro muito grande para caber em um C longo, sai */\n"
"            return -1;\n"
"        total += value;\n"
"    }\n"
"    return total;\n"
"}"

#: ../../c-api/intro.rst:570
msgid ""
"long\n"
"sum_sequence(PyObject *sequence)\n"
"{\n"
"    Py_ssize_t i, n;\n"
"    long total = 0, value;\n"
"    PyObject *item;\n"
"    n = PySequence_Length(sequence);\n"
"    if (n < 0)\n"
"        return -1; /* Has no length */\n"
"    for (i = 0; i < n; i++) {\n"
"        item = PySequence_GetItem(sequence, i);\n"
"        if (item == NULL)\n"
"            return -1; /* Not a sequence, or other failure */\n"
"        if (PyLong_Check(item)) {\n"
"            value = PyLong_AsLong(item);\n"
"            Py_DECREF(item);\n"
"            if (value == -1 && PyErr_Occurred())\n"
"                /* Integer too big to fit in a C long, bail out */\n"
"                return -1;\n"
"            total += value;\n"
"        }\n"
"        else {\n"
"            Py_DECREF(item); /* Discard reference ownership */\n"
"        }\n"
"    }\n"
"    return total;\n"
"}"
msgstr ""
"long\n"
"sum_sequence(PyObject *sequence)\n"
"{\n"
"    Py_ssize_t i, n;\n"
"    long total = 0, value;\n"
"    PyObject *item;\n"
"    n = PySequence_Length(sequence);\n"
"    if (n < 0)\n"
"        return -1; /* Não tem comprimento */\n"
"    for (i = 0; i < n; i++) {\n"
"        item = PySequence_GetItem(sequence, i);\n"
"        if (item == NULL)\n"
"            return -1; /* Não é uma sequência ou outra falha */\n"
"        if (PyLong_Check(item)) {\n"
"            value = PyLong_AsLong(item);\n"
"            Py_DECREF(item);\n"
"            if (value == -1 && PyErr_Occurred())\n"
"                /* Inteiro muito grande para caber em um C longo, sai */\n"
"                return -1;\n"
"            total += value;\n"
"        }\n"
"        else {\n"
"            Py_DECREF(item); /* Descartar propriedade de referência */\n"
"        }\n"
"    }\n"
"    return total;\n"
"}"

#: ../../c-api/intro.rst:604
msgid "Types"
msgstr "Tipos"

#: ../../c-api/intro.rst:606
msgid ""
"There are few other data types that play a significant role in  the Python/C "
"API; most are simple C types such as :c:expr:`int`,  :c:expr:`long`, :c:expr:"
"`double` and :c:expr:`char*`.  A few structure types  are used to describe "
"static tables used to list the functions exported  by a module or the data "
"attributes of a new object type, and another is used to describe the value "
"of a complex number.  These will  be discussed together with the functions "
"that use them."
msgstr ""
"Existem alguns outros tipos de dados que desempenham um papel significativo "
"na API Python/C; a maioria são tipos C simples, como :c:expr:`int`, :c:expr:"
"`long`, :c:expr:`double` e :c:expr:`char*`. Alguns tipos de estrutura são "
"usados para descrever tabelas estáticas usadas para listar as funções "
"exportadas por um módulo ou os atributos de dados de um novo tipo de objeto, "
"e outro é usado para descrever o valor de um número complexo. Eles serão "
"discutidos junto com as funções que os utilizam."

#: ../../c-api/intro.rst:616
msgid ""
"A signed integral type such that ``sizeof(Py_ssize_t) == sizeof(size_t)``. "
"C99 doesn't define such a thing directly (size_t is an unsigned integral "
"type). See :pep:`353` for details. ``PY_SSIZE_T_MAX`` is the largest "
"positive value of type :c:type:`Py_ssize_t`."
msgstr ""
"Um tipo integral assinado tal que ``sizeof(Py_ssize_t) == sizeof(size_t)``. "
"C99 não define tal coisa diretamente (size_t é um tipo integral não "
"assinado). Veja :pep:`353` para mais detalhes. ``PY_SSIZE_T_MAX`` é o maior "
"valor positivo do tipo :c:type:`Py_ssize_t`."

#: ../../c-api/intro.rst:625
msgid "Exceptions"
msgstr "Exceções"

#: ../../c-api/intro.rst:627
msgid ""
"The Python programmer only needs to deal with exceptions if specific  error "
"handling is required; unhandled exceptions are automatically  propagated to "
"the caller, then to the caller's caller, and so on, until they reach the top-"
"level interpreter, where they are reported to the  user accompanied by a "
"stack traceback."
msgstr ""
"O programador Python só precisa lidar com exceções se o tratamento de erros "
"específico for necessário; as exceções não tratadas são propagadas "
"automaticamente para o chamador, depois para o chamador e assim por diante, "
"até chegarem ao interpretador de nível superior, onde são relatadas ao "
"usuário acompanhadas por um traceback (situação da pilha de execução)."

#: ../../c-api/intro.rst:635
msgid ""
"For C programmers, however, error checking always has to be explicit.  All "
"functions in the Python/C API can raise exceptions, unless an explicit claim "
"is made otherwise in a function's documentation.  In general, when a "
"function encounters an error, it sets an exception, discards any object "
"references that it owns, and returns an error indicator.  If not documented "
"otherwise, this indicator is either ``NULL`` or ``-1``, depending on the "
"function's return type. A few functions return a Boolean true/false result, "
"with false indicating an error.  Very few functions return no explicit error "
"indicator or have an ambiguous return value, and require explicit testing "
"for errors with :c:func:`PyErr_Occurred`.  These exceptions are always "
"explicitly documented."
msgstr ""
"Para programadores C, entretanto, a verificação de erros sempre deve ser "
"explícita. Todas as funções na API Python/C podem levantar exceções, a menos "
"que uma declaração explícita seja feita de outra forma na documentação de "
"uma função. Em geral, quando uma função encontra um erro, ela define uma "
"exceção, descarta todas as referências de objeto de sua propriedade e "
"retorna um indicador de erro. Se não for documentado de outra forma, este "
"indicador é ``NULL`` ou ``-1``, dependendo do tipo de retorno da função. "
"Algumas funções retornam um resultado booleano verdadeiro/falso, com falso "
"indicando um erro. Muito poucas funções não retornam nenhum indicador de "
"erro explícito ou têm um valor de retorno ambíguo e requerem teste explícito "
"para erros com :c:func:`PyErr_Occurred`. Essas exceções são sempre "
"documentadas explicitamente."

#: ../../c-api/intro.rst:650
msgid ""
"Exception state is maintained in per-thread storage (this is  equivalent to "
"using global storage in an unthreaded application).  A  thread can be in one "
"of two states: an exception has occurred, or not. The function :c:func:"
"`PyErr_Occurred` can be used to check for this: it returns a borrowed "
"reference to the exception type object when an exception has occurred, and "
"``NULL`` otherwise.  There are a number of functions to set the exception "
"state: :c:func:`PyErr_SetString` is the most common (though not the most "
"general) function to set the exception state, and :c:func:`PyErr_Clear` "
"clears the exception state."
msgstr ""
"O estado de exceção é mantido no armazenamento por thread (isso é "
"equivalente a usar o armazenamento global em uma aplicação sem thread). Uma "
"thread pode estar em um de dois estados: ocorreu uma exceção ou não. A "
"função :c:func:`PyErr_Occurred` pode ser usada para verificar isso: ela "
"retorna uma referência emprestada ao objeto do tipo de exceção quando uma "
"exceção ocorreu, e ``NULL`` caso contrário. Existem várias funções para "
"definir o estado de exceção: :c:func:`PyErr_SetString` é a função mais comum "
"(embora não a mais geral) para definir o estado de exceção, e :c:func:"
"`PyErr_Clear` limpa o estado da exceção."

#: ../../c-api/intro.rst:660
msgid ""
"The full exception state consists of three objects (all of which can  be "
"``NULL``): the exception type, the corresponding exception  value, and the "
"traceback.  These have the same meanings as the Python result of ``sys."
"exc_info()``; however, they are not the same: the Python objects represent "
"the last exception being handled by a Python  :keyword:`try` ... :keyword:"
"`except` statement, while the C level exception state only exists while an "
"exception is being passed on between C functions until it reaches the Python "
"bytecode interpreter's  main loop, which takes care of transferring it to "
"``sys.exc_info()`` and friends."
msgstr ""
"O estado de exceção completo consiste em três objetos (todos os quais podem "
"ser ``NULL``): o tipo de exceção, o valor de exceção correspondente e o "
"traceback. Eles têm os mesmos significados que o resultado no Python de "
"``sys.exc_info()``; no entanto, eles não são os mesmos: os objetos Python "
"representam a última exceção sendo tratada por uma instrução Python :keyword:"
"`try` ... :keyword:`except`, enquanto o estado de exceção de nível C só "
"existe enquanto uma exceção está sendo transmitido entre funções C até "
"atingir o laço de repetição principal do interpretador de bytecode Python, "
"que se encarrega de transferi-lo para ``sys.exc_info()`` e amigos."

#: ../../c-api/intro.rst:672
msgid ""
"Note that starting with Python 1.5, the preferred, thread-safe way to access "
"the exception state from Python code is to call the function :func:`sys."
"exc_info`, which returns the per-thread exception state for Python code.  "
"Also, the semantics of both ways to access the exception state have changed "
"so that a function which catches an exception will save and restore its "
"thread's exception state so as to preserve the exception state of its "
"caller.  This prevents common bugs in exception handling code caused by an "
"innocent-looking function overwriting the exception being handled; it also "
"reduces the often unwanted lifetime extension for objects that are "
"referenced by the stack frames in the traceback."
msgstr ""
"Observe que a partir do Python 1.5, a maneira preferida e segura para thread "
"para acessar o estado de exceção do código Python é chamar a função :func:"
"`sys.exc_info`, que retorna o estado de exceção por thread para o código "
"Python. Além disso, a semântica de ambas as maneiras de acessar o estado de "
"exceção mudou, de modo que uma função que captura uma exceção salvará e "
"restaurará o estado de exceção de seu segmento de modo a preservar o estado "
"de exceção de seu chamador. Isso evita bugs comuns no código de tratamento "
"de exceções causados por uma função aparentemente inocente sobrescrevendo a "
"exceção sendo tratada; também reduz a extensão da vida útil frequentemente "
"indesejada para objetos que são referenciados pelos quadros de pilha no "
"traceback."

#: ../../c-api/intro.rst:683
msgid ""
"As a general principle, a function that calls another function to  perform "
"some task should check whether the called function raised an  exception, and "
"if so, pass the exception state on to its caller.  It  should discard any "
"object references that it owns, and return an  error indicator, but it "
"should *not* set another exception --- that would overwrite the exception "
"that was just raised, and lose important information about the exact cause "
"of the error."
msgstr ""
"Como princípio geral, uma função que chama outra função para realizar alguma "
"tarefa deve verificar se a função chamada levantou uma exceção e, em caso "
"afirmativo, passar o estado da exceção para seu chamador. Ele deve descartar "
"todas as referências de objeto que possui e retornar um indicador de erro, "
"mas *não* deve definir outra exceção --- que sobrescreveria a exceção que "
"acabou de ser gerada e perderia informações importantes sobre a causa exata "
"do erro."

#: ../../c-api/intro.rst:692
msgid ""
"A simple example of detecting exceptions and passing them on is shown in "
"the :c:func:`!sum_sequence` example above.  It so happens that this example "
"doesn't need to clean up any owned references when it detects an error.  The "
"following example function shows some error cleanup.  First, to remind you "
"why you like Python, we show the equivalent Python code::"
msgstr ""
"Um exemplo simples de detecção de exceções e transmiti-las é mostrado no "
"exemplo :c:func:`!sum_sequence` acima. Acontece que este exemplo não precisa "
"limpar nenhuma referência de propriedade quando detecta um erro. A função de "
"exemplo a seguir mostra alguma limpeza de erro. Primeiro, para lembrar por "
"que você gosta de Python, mostramos o código Python equivalente::"

#: ../../c-api/intro.rst:698
msgid ""
"def incr_item(dict, key):\n"
"    try:\n"
"        item = dict[key]\n"
"    except KeyError:\n"
"        item = 0\n"
"    dict[key] = item + 1"
msgstr ""
"def incr_item(dict, key):\n"
"    try:\n"
"        item = dict[key]\n"
"    except KeyError:\n"
"        item = 0\n"
"    dict[key] = item + 1"

#: ../../c-api/intro.rst:707
msgid "Here is the corresponding C code, in all its glory::"
msgstr "Aqui está o código C correspondente, em toda sua glória::"

#: ../../c-api/intro.rst:709
msgid ""
"int\n"
"incr_item(PyObject *dict, PyObject *key)\n"
"{\n"
"    /* Objects all initialized to NULL for Py_XDECREF */\n"
"    PyObject *item = NULL, *const_one = NULL, *incremented_item = NULL;\n"
"    int rv = -1; /* Return value initialized to -1 (failure) */\n"
"\n"
"    item = PyObject_GetItem(dict, key);\n"
"    if (item == NULL) {\n"
"        /* Handle KeyError only: */\n"
"        if (!PyErr_ExceptionMatches(PyExc_KeyError))\n"
"            goto error;\n"
"\n"
"        /* Clear the error and use zero: */\n"
"        PyErr_Clear();\n"
"        item = PyLong_FromLong(0L);\n"
"        if (item == NULL)\n"
"            goto error;\n"
"    }\n"
"    const_one = PyLong_FromLong(1L);\n"
"    if (const_one == NULL)\n"
"        goto error;\n"
"\n"
"    incremented_item = PyNumber_Add(item, const_one);\n"
"    if (incremented_item == NULL)\n"
"        goto error;\n"
"\n"
"    if (PyObject_SetItem(dict, key, incremented_item) < 0)\n"
"        goto error;\n"
"    rv = 0; /* Success */\n"
"    /* Continue with cleanup code */\n"
"\n"
" error:\n"
"    /* Cleanup code, shared by success and failure path */\n"
"\n"
"    /* Use Py_XDECREF() to ignore NULL references */\n"
"    Py_XDECREF(item);\n"
"    Py_XDECREF(const_one);\n"
"    Py_XDECREF(incremented_item);\n"
"\n"
"    return rv; /* -1 for error, 0 for success */\n"
"}"
msgstr ""
"int\n"
"incr_item(PyObject *dict, PyObject *key)\n"
"{\n"
"    /* Objetos todos inicializados para NULL para Py_XDECREF */\n"
"    PyObject *item = NULL, *const_one = NULL, *incremented_item = NULL;\n"
"    int rv = -1; /* Retorna valor inicializado para -1 (falha) */\n"
"\n"
"    item = PyObject_GetItem(dict, key);\n"
"    if (item == NULL) {\n"
"        /* Trata de KeyError apenas: */\n"
"        if (!PyErr_ExceptionMatches(PyExc_KeyError))\n"
"            goto error;\n"
"\n"
"        /* Limpa o erro e usa zero: */\n"
"        PyErr_Clear();\n"
"        item = PyLong_FromLong(0L);\n"
"        if (item == NULL)\n"
"            goto error;\n"
"    }\n"
"    const_one = PyLong_FromLong(1L);\n"
"    if (const_one == NULL)\n"
"        goto error;\n"
"\n"
"    incremented_item = PyNumber_Add(item, const_one);\n"
"    if (incremented_item == NULL)\n"
"        goto error;\n"
"\n"
"    if (PyObject_SetItem(dict, key, incremented_item) < 0)\n"
"        goto error;\n"
"    rv = 0; /* Success */\n"
"    /* Continua com o código de limpeza */\n"
"\n"
" error:\n"
"    /* Código de limpeza, compartilhado pelo caminho sucesso e falha */\n"
"\n"
"    /* Usa Py_XDECREF() para ignorar referências NULL */\n"
"    Py_XDECREF(item);\n"
"    Py_XDECREF(const_one);\n"
"    Py_XDECREF(incremented_item);\n"
"\n"
"    return rv; /* -1 para erro, 0 para sucesso */\n"
"}"

#: ../../c-api/intro.rst:759
msgid ""
"This example represents an endorsed use of the ``goto`` statement  in C! It "
"illustrates the use of :c:func:`PyErr_ExceptionMatches` and :c:func:"
"`PyErr_Clear` to handle specific exceptions, and the use of :c:func:"
"`Py_XDECREF` to dispose of owned references that may be ``NULL`` (note the "
"``'X'`` in the name; :c:func:`Py_DECREF` would crash when confronted with a "
"``NULL`` reference).  It is important that the variables used to hold owned "
"references are initialized to ``NULL`` for this to work; likewise, the "
"proposed return value is initialized to ``-1`` (failure) and only set to "
"success after the final call made is successful."
msgstr ""
"Este exemplo representa um uso endossado da instrução ``goto`` em C! Ele "
"ilustra o uso de :c:func:`PyErr_ExceptionMatches` e :c:func:`PyErr_Clear` "
"para lidar com exceções específicas, e o uso de :c:func:`Py_XDECREF` para "
"descartar referências de propriedade que podem ser ``NULL`` (observe o "
"``'X'`` no nome; :c:func:`Py_DECREF` travaria quando confrontado com uma "
"referência ``NULL``). É importante que as variáveis usadas para manter as "
"referências de propriedade sejam inicializadas com ``NULL`` para que isso "
"funcione; da mesma forma, o valor de retorno proposto é inicializado para "
"``-1`` (falha) e apenas definido para sucesso após a chamada final feita ser "
"bem sucedida."

#: ../../c-api/intro.rst:773
msgid "Embedding Python"
msgstr "Incorporando Python"

#: ../../c-api/intro.rst:775
msgid ""
"The one important task that only embedders (as opposed to extension writers) "
"of the Python interpreter have to worry about is the initialization, and "
"possibly the finalization, of the Python interpreter.  Most functionality of "
"the interpreter can only be used after the interpreter has been initialized."
msgstr ""
"A única tarefa importante com a qual apenas os incorporadores (em oposição "
"aos escritores de extensão) do interpretador Python precisam se preocupar é "
"a inicialização e, possivelmente, a finalização do interpretador Python. A "
"maior parte da funcionalidade do interpretador só pode ser usada após a "
"inicialização do interpretador."

#: ../../c-api/intro.rst:788
msgid ""
"The basic initialization function is :c:func:`Py_Initialize`. This "
"initializes the table of loaded modules, and creates the fundamental "
"modules :mod:`builtins`, :mod:`__main__`, and :mod:`sys`.  It also "
"initializes the module search path (``sys.path``)."
msgstr ""
"A função de inicialização básica é :c:func:`Py_Initialize`. Isso inicializa "
"a tabela de módulos carregados e cria os módulos fundamentais :mod:"
"`builtins`, :mod:`__main__` e :mod:`sys`. Ela também inicializa o caminho de "
"pesquisa de módulos (``sys.path``)."

#: ../../c-api/intro.rst:793
msgid ""
":c:func:`Py_Initialize` does not set the \"script argument list\"  (``sys."
"argv``). If this variable is needed by Python code that will be executed "
"later, setting :c:member:`PyConfig.argv` and :c:member:`PyConfig.parse_argv` "
"must be set: see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
":c:func:`Py_Initialize` não define a \"lista de argumentos de "
"script\" (``sys.argv``). Se esta variável for necessária para o código "
"Python que será executado posteriormente, :c:member:`PyConfig.argv` e :c:"
"member:`PyConfig.parse_argv` devem estar definidas; veja :ref:`Configuração "
"de inicialização do Python <init-config>`."

#: ../../c-api/intro.rst:798
msgid ""
"On most systems (in particular, on Unix and Windows, although the details "
"are slightly different), :c:func:`Py_Initialize` calculates the module "
"search path based upon its best guess for the location of the standard "
"Python interpreter executable, assuming that the Python library is found in "
"a fixed location relative to the Python interpreter executable.  In "
"particular, it looks for a directory named :file:`lib/python{X.Y}` relative "
"to the parent directory where the executable named :file:`python` is found "
"on the shell command search path (the environment variable :envvar:`PATH`)."
msgstr ""
"Na maioria dos sistemas (em particular, no Unix e no Windows, embora os "
"detalhes sejam ligeiramente diferentes), :c:func:`Py_Initialize` calcula o "
"caminho de pesquisa de módulos com base em sua melhor estimativa para a "
"localização do executável do interpretador Python padrão, presumindo que a "
"biblioteca Python é encontrada em um local fixo em relação ao executável do "
"interpretador Python. Em particular, ele procura por um diretório chamado :"
"file:`lib/python{X.Y}` relativo ao diretório pai onde o executável chamado :"
"file:`python` é encontrado no caminho de pesquisa de comandos do shell (a "
"variável de ambiente :envvar:`PATH`)."

#: ../../c-api/intro.rst:807
msgid ""
"For instance, if the Python executable is found in :file:`/usr/local/bin/"
"python`, it will assume that the libraries are in :file:`/usr/local/lib/"
"python{X.Y}`.  (In fact, this particular path is also the \"fallback\" "
"location, used when no executable file named :file:`python` is found along :"
"envvar:`PATH`.)  The user can override this behavior by setting the "
"environment variable :envvar:`PYTHONHOME`, or insert additional directories "
"in front of the standard path by setting :envvar:`PYTHONPATH`."
msgstr ""
"Por exemplo, se o executável Python for encontrado em :file:`/usr/local/bin/"
"python`, ele presumirá que as bibliotecas estão em :file:`/usr/local/lib/"
"python{X.Y}`. (Na verdade, este caminho particular também é o local reserva, "
"usado quando nenhum arquivo executável chamado :file:`python` é encontrado "
"ao longo de :envvar:`PATH`.) O usuário pode substituir este comportamento "
"definindo a variável de ambiente :envvar:`PYTHONHOME`, ou insira diretórios "
"adicionais na frente do caminho padrão definindo :envvar:`PYTHONPATH`."

#: ../../c-api/intro.rst:821
msgid ""
"The embedding application can steer the search by setting :c:member:"
"`PyConfig.program_name` *before* calling :c:func:`Py_InitializeFromConfig`. "
"Note that :envvar:`PYTHONHOME` still overrides this and :envvar:`PYTHONPATH` "
"is still inserted in front of the standard path.  An application that "
"requires total control has to provide its own implementation of :c:func:"
"`Py_GetPath`, :c:func:`Py_GetPrefix`, :c:func:`Py_GetExecPrefix`, and :c:"
"func:`Py_GetProgramFullPath` (all defined in :file:`Modules/getpath.c`)."
msgstr ""
"A aplicação de incorporação pode orientar a pesquisa definindo :c:member:"
"`PyConfig.program_name` *antes* de chamar :c:func:`Py_InitializeFromConfig`. "
"Observe que :envvar:`PYTHONHOME` ainda substitui isso e :envvar:`PYTHONPATH` "
"ainda é inserido na frente do caminho padrão. Uma aplicação que requer "
"controle total deve fornecer sua própria implementação de :c:func:"
"`Py_GetPath`, :c:func:`Py_GetPrefix`, :c:func:`Py_GetExecPrefix` e :c:func:"
"`Py_GetProgramFullPath` (todas definidas em :file:`Modules/getpath.c`)."

#: ../../c-api/intro.rst:832
msgid ""
"Sometimes, it is desirable to \"uninitialize\" Python.  For instance,  the "
"application may want to start over (make another call to :c:func:"
"`Py_Initialize`) or the application is simply done with its  use of Python "
"and wants to free memory allocated by Python.  This can be accomplished by "
"calling :c:func:`Py_FinalizeEx`.  The function :c:func:`Py_IsInitialized` "
"returns true if Python is currently in the initialized state.  More "
"information about these functions is given in a later chapter. Notice that :"
"c:func:`Py_FinalizeEx` does *not* free all memory allocated by the Python "
"interpreter, e.g. memory allocated by extension modules currently cannot be "
"released."
msgstr ""
"Às vezes, é desejável \"desinicializar\" o Python. Por exemplo, a aplicação "
"pode querer iniciar novamente (fazer outra chamada para :c:func:"
"`Py_Initialize`) ou a aplicação simplesmente termina com o uso de Python e "
"deseja liberar memória alocada pelo Python. Isso pode ser feito chamando :c:"
"func:`Py_FinalizeEx`. A função :c:func:`Py_IsInitialized` retorna verdadeiro "
"se o Python está atualmente no estado inicializado. Mais informações sobre "
"essas funções são fornecidas em um capítulo posterior. Observe que :c:func:"
"`Py_FinalizeEx` *não* libera toda a memória alocada pelo interpretador "
"Python, por exemplo, a memória alocada por módulos de extensão atualmente "
"não pode ser liberada."

#: ../../c-api/intro.rst:846
msgid "Debugging Builds"
msgstr "Compilações de depuração"

#: ../../c-api/intro.rst:848
msgid ""
"Python can be built with several macros to enable extra checks of the "
"interpreter and extension modules.  These checks tend to add a large amount "
"of overhead to the runtime so they are not enabled by default."
msgstr ""
"Python pode ser compilado com várias macros para permitir verificações "
"extras do interpretador e módulos de extensão. Essas verificações tendem a "
"adicionar uma grande quantidade de sobrecarga ao tempo de execução, "
"portanto, não são habilitadas por padrão."

#: ../../c-api/intro.rst:852
msgid ""
"A full list of the various types of debugging builds is in the file :file:"
"`Misc/SpecialBuilds.txt` in the Python source distribution. Builds are "
"available that support tracing of reference counts, debugging the memory "
"allocator, or low-level profiling of the main interpreter loop.  Only the "
"most frequently used builds will be described in the remainder of this "
"section."
msgstr ""
"Uma lista completa dos vários tipos de compilações de depuração está no "
"arquivo :file:`Misc/SpecialBuilds.txt` na distribuição do código-fonte do "
"Python. Estão disponíveis compilações que oferecem suporte ao rastreamento "
"de contagens de referências, depuração do alocador de memória ou criação de "
"perfil de baixo nível do laço do interpretador principal. Apenas as "
"compilações usadas com mais frequência serão descritas no restante desta "
"seção."

#: ../../c-api/intro.rst:860
msgid ""
"Compiling the interpreter with the :c:macro:`!Py_DEBUG` macro defined "
"produces what is generally meant by :ref:`a debug build of Python <debug-"
"build>`. :c:macro:`!Py_DEBUG` is enabled in the Unix build by adding :option:"
"`--with-pydebug` to the :file:`./configure` command. It is also implied by "
"the presence of the not-Python-specific :c:macro:`!_DEBUG` macro.  When :c:"
"macro:`!Py_DEBUG` is enabled in the Unix build, compiler optimization is "
"disabled."
msgstr ""
"Compilar o interpretador com a macro :c:macro:`!Py_DEBUG` definida produz o "
"que geralmente se entende por :ref:`uma construção de depuração do Python "
"<debug-build>`. :c:macro:`!Py_DEBUG` é habilitada na construção Unix "
"adicionando :option:`--with-pydebug` ao comando :file:`./configure`. Também "
"está implícito na presença da macro não específica do Python :c:macro:`!"
"_DEBUG`. Quando :c:macro:`!Py_DEBUG` está habilitado na construção do Unix, "
"a otimização do compilador é desabilitada."

#: ../../c-api/intro.rst:868
msgid ""
"In addition to the reference count debugging described below, extra checks "
"are performed, see :ref:`Python Debug Build <debug-build>`."
msgstr ""
"Além da depuração de contagem de referências descrita abaixo, verificações "
"extras são realizadas, consulte :ref:`Compilação de Depuração do Python "
"<debug-build>`."

#: ../../c-api/intro.rst:871
msgid ""
"Defining :c:macro:`Py_TRACE_REFS` enables reference tracing (see the :option:"
"`configure --with-trace-refs option <--with-trace-refs>`). When defined, a "
"circular doubly linked list of active objects is maintained by adding two "
"extra fields to every :c:type:`PyObject`.  Total allocations are tracked as "
"well.  Upon exit, all existing references are printed.  (In interactive mode "
"this happens after every statement run by the interpreter.)"
msgstr ""
"Definir :c:macro:`Py_TRACE_REFS` habilita o rastreamento de referência (veja "
"a opção :option:`opção --with-trace-refs de configure <--with-trace-refs>`). "
"Quando definida, uma lista circular duplamente vinculada de objetos ativos é "
"mantida adicionando dois campos extras a cada :c:type:`PyObject`. As "
"alocações totais também são rastreadas. Ao sair, todas as referências "
"existentes são impressas. (No modo interativo, isso acontece após cada "
"instrução executada pelo interpretador.)"

#: ../../c-api/intro.rst:878
msgid ""
"Please refer to :file:`Misc/SpecialBuilds.txt` in the Python source "
"distribution for more detailed information."
msgstr ""
"Consulte :file:`Misc/SpecialBuilds.txt` na distribuição do código-fonte "
"Python para informações mais detalhadas."

#: ../../c-api/intro.rst:885
msgid "Recommended third party tools"
msgstr "Ferramentas de terceiros recomendadas"

#: ../../c-api/intro.rst:887
msgid ""
"The following third party tools offer both simpler and more sophisticated "
"approaches to creating C, C++ and Rust extensions for Python:"
msgstr ""
"As seguintes ferramentas de terceiros oferecem abordagens mais simples e "
"mais sofisticadas para criar extensões C, C++ e Rust para Python:"

#: ../../c-api/intro.rst:890
msgid "`Cython <https://cython.org/>`_"
msgstr "`Cython <https://cython.org/>`_"

#: ../../c-api/intro.rst:891
msgid "`cffi <https://cffi.readthedocs.io>`_"
msgstr "`cffi <https://cffi.readthedocs.io>`_"

#: ../../c-api/intro.rst:892
msgid "`HPy <https://hpyproject.org/>`_"
msgstr "`HPy <https://hpyproject.org/>`_"

#: ../../c-api/intro.rst:893
msgid "`nanobind <https://github.com/wjakob/nanobind>`_ (C++)"
msgstr "`nanobind <https://github.com/wjakob/nanobind>`_ (C++)"

#: ../../c-api/intro.rst:894
msgid "`Numba <https://numba.pydata.org/>`_"
msgstr "`Numba <https://numba.pydata.org/>`_"

#: ../../c-api/intro.rst:895
msgid "`pybind11 <https://pybind11.readthedocs.io/>`_ (C++)"
msgstr "`pybind11 <https://pybind11.readthedocs.io/>`_ (C++)"

#: ../../c-api/intro.rst:896
msgid "`PyO3 <https://pyo3.rs/>`_ (Rust)"
msgstr "`PyO3 <https://pyo3.rs/>`_ (Rust)"

#: ../../c-api/intro.rst:897
msgid "`SWIG <https://www.swig.org>`_"
msgstr "`SWIG <https://www.swig.org>`_"

#: ../../c-api/intro.rst:899
msgid ""
"Using tools such as these can help avoid writing code that is tightly bound "
"to a particular version of CPython, avoid reference counting errors, and "
"focus more on your own code than on using the CPython API. In general, new "
"versions of Python can be supported by updating the tool, and your code will "
"often use newer and more efficient APIs automatically. Some tools also "
"support compiling for other implementations of Python from a single set of "
"sources."
msgstr ""
"O uso de ferramentas como essas pode ajudar a evitar a criação de código "
"estritamente vinculado a uma versão específica do CPython, evitar erros de "
"contagem de referências e focar mais no seu próprio código do que em usar a "
"API do CPython. Em geral, novas versões do Python podem ser suportadas "
"atualizando a ferramenta, e seu código frequentemente usará APIs mais novas "
"e eficientes automaticamente. Algumas ferramentas também oferecem suporte à "
"compilação para outras implementações do Python a partir de um único "
"conjunto de fontes."

#: ../../c-api/intro.rst:906
msgid ""
"These projects are not supported by the same people who maintain Python, and "
"issues need to be raised with the projects directly. Remember to check that "
"the project is still maintained and supported, as the list above may become "
"outdated."
msgstr ""
"Esses projetos não são suportados pelas mesmas pessoas que mantêm o Python, "
"e quaisquer problemas precisam ser relatados diretamente aos projetos. "
"Lembre-se de verificar se o projeto ainda é mantido e tem suporte, pois a "
"lista acima pode ficar desatualizada."

#: ../../c-api/intro.rst:913
msgid ""
"`Python Packaging User Guide: Binary Extensions <https://packaging.python."
"org/guides/packaging-binary-extensions/>`_"
msgstr ""
"`Guia do Usuário de Empacotamento do Python: Extensões Binárias <https://"
"packaging.python.org/guides/packaging-binary-extensions/>`_"

#: ../../c-api/intro.rst:914
msgid ""
"The Python Packaging User Guide not only covers several available tools that "
"simplify the creation of binary extensions, but also discusses the various "
"reasons why creating an extension module may be desirable in the first place."
msgstr ""
"O Guia do Usuário de Empacotamento do Python não abrange apenas várias "
"ferramentas disponíveis que simplificam a criação de extensões binárias, mas "
"também discute os vários motivos pelos quais a criação de um módulo de "
"extensão pode ser desejável em primeiro lugar."

#: ../../c-api/intro.rst:331
msgid "object"
msgstr "objeto"

#: ../../c-api/intro.rst:331
msgid "type"
msgstr "tipo"

#: ../../c-api/intro.rst:370
msgid "Py_INCREF (C function)"
msgstr "Py_INCREF (função C)"

#: ../../c-api/intro.rst:370
msgid "Py_DECREF (C function)"
msgstr "Py_DECREF (função C)"

#: ../../c-api/intro.rst:446
msgid "PyList_SetItem (C function)"
msgstr "PyList_SetItem (função C)"

#: ../../c-api/intro.rst:446
msgid "PyTuple_SetItem (C function)"
msgstr "PyTuple_SetItem (função C)"

#: ../../c-api/intro.rst:517
msgid "set_all()"
msgstr "set_all()"

#: ../../c-api/intro.rst:536
msgid "PyList_GetItem (C function)"
msgstr "PyList_GetItem (função C)"

#: ../../c-api/intro.rst:536
msgid "PySequence_GetItem (C function)"
msgstr "PySequence_GetItem (função C)"

#: ../../c-api/intro.rst:566
msgid "sum_list()"
msgstr "sum_list()"

#: ../../c-api/intro.rst:598 ../../c-api/intro.rst:690
msgid "sum_sequence()"
msgstr "sum_sequence()"

#: ../../c-api/intro.rst:633
msgid "PyErr_Occurred (C function)"
msgstr "PyErr_Occurred (função C)"

#: ../../c-api/intro.rst:646
msgid "PyErr_SetString (C function)"
msgstr "PyErr_SetString (função C)"

#: ../../c-api/intro.rst:646 ../../c-api/intro.rst:754
msgid "PyErr_Clear (C function)"
msgstr "PyErr_Clear (função C)"

#: ../../c-api/intro.rst:670
msgid "exc_info (in module sys)"
msgstr "exc_info (no módulo sys)"

#: ../../c-api/intro.rst:705 ../../c-api/intro.rst:752
msgid "incr_item()"
msgstr "incr_item()"

#: ../../c-api/intro.rst:754
msgid "PyErr_ExceptionMatches (C function)"
msgstr "PyErr_ExceptionMatches (função C)"

#: ../../c-api/intro.rst:754
msgid "Py_XDECREF (C function)"
msgstr "Py_XDECREF (função C)"

#: ../../c-api/intro.rst:780
msgid "Py_Initialize (C function)"
msgstr "Py_Initialize (função C)"

#: ../../c-api/intro.rst:780
msgid "module"
msgstr "módulo"

#: ../../c-api/intro.rst:780
msgid "builtins"
msgstr "builtins"

#: ../../c-api/intro.rst:780
msgid "__main__"
msgstr "__main__"

#: ../../c-api/intro.rst:780
msgid "sys"
msgstr "sys"

#: ../../c-api/intro.rst:780
msgid "search"
msgstr "pesquisa"

#: ../../c-api/intro.rst:780
msgid "path"
msgstr "caminho"

#: ../../c-api/intro.rst:780
msgid "path (in module sys)"
msgstr "path (no módulo sys)"

#: ../../c-api/intro.rst:815
msgid "Py_GetPath (C function)"
msgstr "Py_GetPath (função C)"

#: ../../c-api/intro.rst:815
msgid "Py_GetPrefix (C function)"
msgstr "Py_GetPrefix (função C)"

#: ../../c-api/intro.rst:815
msgid "Py_GetExecPrefix (C function)"
msgstr "Py_GetExecPrefix (função C)"

#: ../../c-api/intro.rst:815
msgid "Py_GetProgramFullPath (C function)"
msgstr "Py_GetProgramFullPath (função C)"

#: ../../c-api/intro.rst:830
msgid "Py_IsInitialized (C function)"
msgstr "Py_IsInitialized (função C)"

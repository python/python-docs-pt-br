# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 17:17+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../c-api/module.rst:6
msgid "Module Objects"
msgstr "Objetos do Módulo"

#: ../../c-api/module.rst:15
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python module type.  "
"This is exposed to Python programs as ``types.ModuleType``."
msgstr ""
"Esta instância de :c:type:`PyTypeObject` representa o tipo de módulo Python. "
"Isso é exposto a programas Python como ``types.ModuleType``."

#: ../../c-api/module.rst:21
msgid ""
"Return true if *p* is a module object, or a subtype of a module object. This "
"function always succeeds."
msgstr ""
"Retorna true se *p* for um objeto de módulo ou um subtipo de um objeto de "
"módulo. Esta função sempre é bem-sucedida."

#: ../../c-api/module.rst:27
msgid ""
"Return true if *p* is a module object, but not a subtype of :c:data:"
"`PyModule_Type`.  This function always succeeds."
msgstr ""
"Retorna true se *p* for um objeto de módulo, mas não um subtipo de :c:data:"
"`PyModule_Type`. Essa função é sempre bem-sucedida."

#: ../../c-api/module.rst:40
msgid ""
"Return a new module object with the :attr:`__name__` attribute set to "
"*name*. The module's :attr:`__name__`, :attr:`__doc__`, :attr:`__package__`, "
"and :attr:`__loader__` attributes are filled in (all but :attr:`__name__` "
"are set to ``None``); the caller is responsible for providing a :attr:"
"`__file__` attribute."
msgstr ""
"Retorna um novo objeto de módulo com o atributo :attr:`__name__` definido "
"como *name*. Os atributos de módulo :attr:`__name__`, :attr:`__doc__`, :attr:"
"`__package__` e :attr:`__loader__` são preenchidos (todos exceto :attr:"
"`__name__` são definidos como ``None``); O chamador é responsásvel por "
"providenciar um atributo :attr:`__file__`."

#: ../../c-api/module.rst:48
msgid ":attr:`__package__` and :attr:`__loader__` are set to ``None``."
msgstr ":attr:`__package__` e :attr:`__loader__` são definidos como ``None``."

#: ../../c-api/module.rst:54
msgid ""
"Similar to :c:func:`PyModule_NewObject`, but the name is a UTF-8 encoded "
"string instead of a Unicode object."
msgstr ""
"Semelhante a :c:func:`PyModule_NewObject`, mas o nome é uma string "
"codificada em UTF-8 em vez de um objeto Unicode."

#: ../../c-api/module.rst:62
msgid ""
"Return the dictionary object that implements *module*'s namespace; this "
"object is the same as the :attr:`~object.__dict__` attribute of the module "
"object. If *module* is not a module object (or a subtype of a module "
"object), :exc:`SystemError` is raised and ``NULL`` is returned."
msgstr ""
"Retorna o objeto dicionário que implementa o espaço de nomes de *module*; "
"este objeto é o mesmo que o atributo :attr:`~object.__dict__` do objeto de "
"módulo. Se *module* não for um objeto de módulo (ou um subtipo de um objeto "
"de módulo), :exc:`SystemError` é levantada e ``NULL`` é retornado."

#: ../../c-api/module.rst:67
msgid ""
"It is recommended extensions use other ``PyModule_*`` and ``PyObject_*`` "
"functions rather than directly manipulate a module's :attr:`~object."
"__dict__`."
msgstr ""
"É recomendado que as extensões usem outras funções ``PyModule_*`` e "
"``PyObject_*`` em vez de manipular diretamente o :attr:`~object.__dict__` de "
"um módulo."

#: ../../c-api/module.rst:78
msgid ""
"Return *module*'s :attr:`__name__` value.  If the module does not provide "
"one, or if it is not a string, :exc:`SystemError` is raised and ``NULL`` is "
"returned."
msgstr ""
"Retorna o valor :attr:`__name__` do *módulo*. Se o módulo não fornecer um, "
"ou se não for uma string, :exc:`SystemError` é levantada e ``NULL`` é "
"retornado."

#: ../../c-api/module.rst:86
msgid ""
"Similar to :c:func:`PyModule_GetNameObject` but return the name encoded to "
"``'utf-8'``."
msgstr ""
"Semelhante a :c:func:`PyModule_GetNameObject` mas retorna o nome codificado "
"em ``'utf-8'``"

#: ../../c-api/module.rst:91
msgid ""
"Return the \"state\" of the module, that is, a pointer to the block of "
"memory allocated at module creation time, or ``NULL``.  See :c:member:"
"`PyModuleDef.m_size`."
msgstr ""
"Retorna o \"estado\" do módulo, ou seja, um ponteiro para o bloco de memória "
"alocado no momento de criação do módulo, ou ``NULL``. Ver :c:member:"
"`PyModuleDef.m_size`."

#: ../../c-api/module.rst:98
msgid ""
"Return a pointer to the :c:type:`PyModuleDef` struct from which the module "
"was created, or ``NULL`` if the module wasn't created from a definition."
msgstr ""
"Retorna um ponteiro para a estrutura :c:type:`PyModuleDef` da qual o módulo "
"foi criado, ou ``NULL`` se o módulo não foi criado de uma definição."

#: ../../c-api/module.rst:108
msgid ""
"Return the name of the file from which *module* was loaded using *module*'s :"
"attr:`__file__` attribute.  If this is not defined, or if it is not a "
"unicode string, raise :exc:`SystemError` and return ``NULL``; otherwise "
"return a reference to a Unicode object."
msgstr ""
"Retorna o nome do arquivo do qual o *módulo* foi carregado usando o "
"atributo :attr:`__file__` do *módulo*. Se não estiver definido, ou se não "
"for uma string unicode, levanta :exc:`SystemError` e retorna ``NULL``; Caso "
"contrário, retorna uma referência a um objeto Unicode."

#: ../../c-api/module.rst:118
msgid ""
"Similar to :c:func:`PyModule_GetFilenameObject` but return the filename "
"encoded to 'utf-8'."
msgstr ""
"Semelhante a :c:func:`PyModule_GetFilenameObject` mas retorna o nome do "
"arquivo codificado em 'utf-8'."

#: ../../c-api/module.rst:121
msgid ""
":c:func:`PyModule_GetFilename` raises :c:type:`UnicodeEncodeError` on "
"unencodable filenames, use :c:func:`PyModule_GetFilenameObject` instead."
msgstr ""

#: ../../c-api/module.rst:129
msgid "Initializing C modules"
msgstr "Inicializando módulos C"

#: ../../c-api/module.rst:131
msgid ""
"Modules objects are usually created from extension modules (shared libraries "
"which export an initialization function), or compiled-in modules (where the "
"initialization function is added using :c:func:`PyImport_AppendInittab`). "
"See :ref:`building` or :ref:`extending-with-embedding` for details."
msgstr ""
"Objetos de módulos são geralmente criados a partir de módulos de extensão "
"(bibliotecas compartilhadas que exportam uma função de inicialização), ou "
"módulos compilados (onde a função de inicialização é adicionada usando :c:"
"func:`PyImport_AppendInittab`). Ver :ref:`building` ou :ref:`extending-with-"
"embedding` para mais detalhes."

#: ../../c-api/module.rst:136
msgid ""
"The initialization function can either pass a module definition instance to :"
"c:func:`PyModule_Create`, and return the resulting module object, or request "
"\"multi-phase initialization\" by returning the definition struct itself."
msgstr ""
"A função de inicialização pode passar uma instância de definição de módulo "
"para :c:func:`PyModule_Create` e retornar o objeto de módulo resultante ou "
"solicitar \"inicialização multifásica\" retornando a própria estrutura de "
"definição."

#: ../../c-api/module.rst:142
msgid ""
"The module definition struct, which holds all information needed to create a "
"module object. There is usually only one statically initialized variable of "
"this type for each module."
msgstr ""
"A estrutura de definição de módulo, que contém todas as informações "
"necessária para criar um objeto de módulo. Geralmente, há apenas uma "
"variável inicializada estaticamente desse tipo para cada módulo."

#: ../../c-api/module.rst:148
msgid "Always initialize this member to :const:`PyModuleDef_HEAD_INIT`."
msgstr ""

#: ../../c-api/module.rst:152
msgid "Name for the new module."
msgstr "Nome para o novo módulo."

#: ../../c-api/module.rst:156
msgid ""
"Docstring for the module; usually a docstring variable created with :c:macro:"
"`PyDoc_STRVAR` is used."
msgstr ""
"Docstring para o módulo; geralmente uma variável docstring criada com :c:"
"macro:`PyDoc_STRVAR` é usada."

#: ../../c-api/module.rst:161
msgid ""
"Module state may be kept in a per-module memory area that can be retrieved "
"with :c:func:`PyModule_GetState`, rather than in static globals. This makes "
"modules safe for use in multiple sub-interpreters."
msgstr ""
"O estado do módulo pode ser mantido em uma área de memória por módulo que "
"pode ser recuperada com :c:func:`PyModule_GetState`, em vez de em globais "
"estáticos. Isso torna os módulos seguros para uso em vários "
"subinterpretadores."

#: ../../c-api/module.rst:165
msgid ""
"This memory area is allocated based on *m_size* on module creation, and "
"freed when the module object is deallocated, after the :c:member:`m_free` "
"function has been called, if present."
msgstr ""

#: ../../c-api/module.rst:169
msgid ""
"Setting ``m_size`` to ``-1`` means that the module does not support sub-"
"interpreters, because it has global state."
msgstr ""
"Definir ``m_size`` como ``-1`` significa que o módulo não oferece suporte a "
"subinterpretadores, porque ele tem estado global."

#: ../../c-api/module.rst:172
msgid ""
"Setting it to a non-negative value means that the module can be re-"
"initialized and specifies the additional amount of memory it requires for "
"its state. Non-negative ``m_size`` is required for multi-phase "
"initialization."
msgstr ""
"Defini-lo como um valor não negativo significa que o módulo pode ser "
"reinicializado e especifica a quantidade adicional de memória necessária "
"para seu estado. ``m_size`` não negativo é necessário para inicialização "
"multifásica."

#: ../../c-api/module.rst:177
msgid "See :PEP:`3121` for more details."
msgstr "Ver :PEP:`3121` para mais detalhes."

#: ../../c-api/module.rst:181
msgid ""
"A pointer to a table of module-level functions, described by :c:type:"
"`PyMethodDef` values.  Can be ``NULL`` if no functions are present."
msgstr ""
"Um ponteiro para uma tabela de funções de nível de módulo, descritas por "
"valores :c:type:`PyMethodDef`. Pode ser ``NULL`` se nenhuma função estiver "
"presente."

#: ../../c-api/module.rst:186
msgid ""
"An array of slot definitions for multi-phase initialization, terminated by a "
"``{0, NULL}`` entry. When using single-phase initialization, *m_slots* must "
"be ``NULL``."
msgstr ""
"Uma matriz de definições de slot para inicialização multifásica, terminada "
"por uma entrada ``{0, NULL}``. Ao usar inicialização monofásica, *m_slots* "
"deve ser ``NULL``."

#: ../../c-api/module.rst:192
msgid ""
"Prior to version 3.5, this member was always set to ``NULL``, and was "
"defined as:"
msgstr ""
"Antes da versão 3.5, esse membro era sempre definido como ``NULL`` e era "
"definido como:"

#: ../../c-api/module.rst:199
msgid ""
"A traversal function to call during GC traversal of the module object, or "
"``NULL`` if not needed."
msgstr ""
"Uma função de travessia para chamar durante a travessia do GC do objeto do "
"módulo, ou ``NULL`` se não for necessário."

#: ../../c-api/module.rst:202 ../../c-api/module.rst:217
#: ../../c-api/module.rst:238
msgid ""
"This function is not called if the module state was requested but is not "
"allocated yet. This is the case immediately after the module is created and "
"before the module is executed (:c:data:`Py_mod_exec` function). More "
"precisely, this function is not called if :c:member:`m_size` is greater than "
"0 and the module state (as returned by :c:func:`PyModule_GetState`) is "
"``NULL``."
msgstr ""

#: ../../c-api/module.rst:209 ../../c-api/module.rst:230
#: ../../c-api/module.rst:245
msgid "No longer called before the module state is allocated."
msgstr "Não é mais chamado antes que o estado do módulo seja alocado."

#: ../../c-api/module.rst:214
msgid ""
"A clear function to call during GC clearing of the module object, or "
"``NULL`` if not needed."
msgstr ""
"Uma função de limpeza para chamar durante a limpeza do GC do objeto do "
"módulo, ou ``NULL`` se não for necessário."

#: ../../c-api/module.rst:224
msgid ""
"Like :c:member:`PyTypeObject.tp_clear`, this function is not *always* called "
"before a module is deallocated. For example, when reference counting is "
"enough to determine that an object is no longer used, the cyclic garbage "
"collector is not involved and :c:member:`~PyModuleDef.m_free` is called "
"directly."
msgstr ""
"Assim como :c:member:`PyTypeObject.tp_clear`, esta função não é *sempre* "
"chamada antes de um módulo ser desalocado. Por exemplo, quando a contagem de "
"referências é suficiente para determinar que um objeto não é mais usado, o "
"coletor de lixo cíclico não é envolvido e :c:member:`~PyModuleDef.m_free` é "
"chamado diretamente."

#: ../../c-api/module.rst:235
msgid ""
"A function to call during deallocation of the module object, or ``NULL`` if "
"not needed."
msgstr ""
"Uma função para ser chamada durante a desalocação do objeto do módulo, ou "
"``NULL`` se não for necessário."

#: ../../c-api/module.rst:249
msgid "Single-phase initialization"
msgstr "inicialização de fase única"

#: ../../c-api/module.rst:251
msgid ""
"The module initialization function may create and return the module object "
"directly. This is referred to as \"single-phase initialization\", and uses "
"one of the following two module creation functions:"
msgstr ""
"A função de inicialização do módulo pode criar e retornar o objeto do módulo "
"diretamente. Isso é chamado de \"inicialização de fase única\" e usa uma das "
"duas funções de criação de módulo a seguir:"

#: ../../c-api/module.rst:257
msgid ""
"Create a new module object, given the definition in *def*.  This behaves "
"like :c:func:`PyModule_Create2` with *module_api_version* set to :const:"
"`PYTHON_API_VERSION`."
msgstr ""

#: ../../c-api/module.rst:264
msgid ""
"Create a new module object, given the definition in *def*, assuming the API "
"version *module_api_version*.  If that version does not match the version of "
"the running interpreter, a :exc:`RuntimeWarning` is emitted."
msgstr ""
"Створіть новий об’єкт модуля, враховуючи визначення в *def*, припускаючи "
"версію API *module_api_version*. Якщо ця версія не збігається з версією "
"запущеного інтерпретатора, видається :exc:`RuntimeWarning`."

#: ../../c-api/module.rst:270
msgid ""
"Most uses of this function should be using :c:func:`PyModule_Create` "
"instead; only use this if you are sure you need it."
msgstr ""
"A maioria dos usos dessa função deve ser feita com :c:func:"
"`PyModule_Create`; use-o apenas se tiver certeza de que precisa."

#: ../../c-api/module.rst:273
msgid ""
"Before it is returned from in the initialization function, the resulting "
"module object is typically populated using functions like :c:func:"
"`PyModule_AddObjectRef`."
msgstr ""
"Перед поверненням у функції ініціалізації результуючий об’єкт модуля "
"зазвичай заповнюється за допомогою таких функцій, як :c:func:"
"`PyModule_AddObjectRef`."

#: ../../c-api/module.rst:279
msgid "Multi-phase initialization"
msgstr "Inicialização multifásica"

#: ../../c-api/module.rst:281
msgid ""
"An alternate way to specify extensions is to request \"multi-phase "
"initialization\". Extension modules created this way behave more like Python "
"modules: the initialization is split between the *creation phase*, when the "
"module object is created, and the *execution phase*, when it is populated. "
"The distinction is similar to the :py:meth:`__new__` and :py:meth:`__init__` "
"methods of classes."
msgstr ""

#: ../../c-api/module.rst:288
msgid ""
"Unlike modules created using single-phase initialization, these modules are "
"not singletons: if the *sys.modules* entry is removed and the module is re-"
"imported, a new module object is created, and the old module is subject to "
"normal garbage collection -- as with Python modules. By default, multiple "
"modules created from the same definition should be independent: changes to "
"one should not affect the others. This means that all state should be "
"specific to the module object (using e.g. using :c:func:"
"`PyModule_GetState`), or its contents (such as the module's :attr:`__dict__` "
"or individual classes created with :c:func:`PyType_FromSpec`)."
msgstr ""

#: ../../c-api/module.rst:298
msgid ""
"All modules created using multi-phase initialization are expected to "
"support :ref:`sub-interpreters <sub-interpreter-support>`. Making sure "
"multiple modules are independent is typically enough to achieve this."
msgstr ""
"Очікується, що всі модулі, створені за допомогою багатофазної ініціалізації, "
"підтримуватимуть :ref:`sub-інтерпретатори <sub-interpreter-support>`. "
"Переконавшись, що декілька модулів є незалежними, як правило, достатньо, щоб "
"досягти цього."

#: ../../c-api/module.rst:302
msgid ""
"To request multi-phase initialization, the initialization function "
"(PyInit_modulename) returns a :c:type:`PyModuleDef` instance with non-empty :"
"c:member:`~PyModuleDef.m_slots`. Before it is returned, the ``PyModuleDef`` "
"instance must be initialized with the following function:"
msgstr ""
"Для запиту багатофазної ініціалізації функція ініціалізації "
"(PyInit_modulename) повертає екземпляр :c:type:`PyModuleDef` з непорожнім :c:"
"member:`~PyModuleDef.m_slots`. Перш ніж його буде повернуто, примірник "
"``PyModuleDef`` має бути ініціалізований такою функцією:"

#: ../../c-api/module.rst:309
msgid ""
"Ensures a module definition is a properly initialized Python object that "
"correctly reports its type and reference count."
msgstr ""
"Garante que uma definição de módulo é um objeto Python devidamente "
"inicializado que reporta corretamente seu tipo e contagem de referências."

#: ../../c-api/module.rst:312
msgid "Returns *def* cast to ``PyObject*``, or ``NULL`` if an error occurred."
msgstr ""
"Повертає *def* приведення до ``PyObject*`` або ``NULL``, якщо сталася "
"помилка."

#: ../../c-api/module.rst:316
msgid ""
"The *m_slots* member of the module definition must point to an array of "
"``PyModuleDef_Slot`` structures:"
msgstr ""
"Член *m_slots* у визначенні модуля має вказувати на масив структур "
"``PyModuleDef_Slot``:"

#: ../../c-api/module.rst:323
msgid "A slot ID, chosen from the available values explained below."
msgstr ""
"Um ID de lot, escolhido a partir dos valores disponíveis explicados abaixo."

#: ../../c-api/module.rst:327
msgid "Value of the slot, whose meaning depends on the slot ID."
msgstr "Valor do slot, cujo significado depende do ID do slot."

#: ../../c-api/module.rst:331
msgid "The *m_slots* array must be terminated by a slot with id 0."
msgstr "Масив *m_slots* повинен закінчуватися слотом з ідентифікатором 0."

#: ../../c-api/module.rst:333
msgid "The available slot types are:"
msgstr "Os tipos de slot disponíveis são:"

#: ../../c-api/module.rst:337
msgid ""
"Specifies a function that is called to create the module object itself. The "
"*value* pointer of this slot must point to a function of the signature:"
msgstr ""
"Визначає функцію, яка викликається для створення самого об’єкта модуля. "
"Покажчик *значення* цього слота має вказувати на функцію підпису:"

#: ../../c-api/module.rst:342
msgid ""
"The function receives a :py:class:`~importlib.machinery.ModuleSpec` "
"instance, as defined in :PEP:`451`, and the module definition. It should "
"return a new module object, or set an error and return ``NULL``."
msgstr ""
"Функція отримує екземпляр :py:class:`~importlib.machinery.ModuleSpec`, як "
"визначено в :PEP:`451`, і визначення модуля. Він має повернути новий об’єкт "
"модуля або встановити помилку та повернути ``NULL``."

#: ../../c-api/module.rst:347
msgid ""
"This function should be kept minimal. In particular, it should not call "
"arbitrary Python code, as trying to import the same module again may result "
"in an infinite loop."
msgstr ""
"Ця функція повинна бути мінімальною. Зокрема, він не повинен викликати "
"довільний код Python, оскільки повторна спроба імпортувати той самий модуль "
"може призвести до нескінченного циклу."

#: ../../c-api/module.rst:351
msgid ""
"Multiple ``Py_mod_create`` slots may not be specified in one module "
"definition."
msgstr ""
"Múltiplos slots ``Py_mod_create`` podem não estar especificados em uma "
"definição de módulo."

#: ../../c-api/module.rst:354
msgid ""
"If ``Py_mod_create`` is not specified, the import machinery will create a "
"normal module object using :c:func:`PyModule_New`. The name is taken from "
"*spec*, not the definition, to allow extension modules to dynamically adjust "
"to their place in the module hierarchy and be imported under different names "
"through symlinks, all while sharing a single module definition."
msgstr ""
"Якщо ``Py_mod_create`` не вказано, механізм імпорту створить звичайний "
"об’єкт модуля за допомогою :c:func:`PyModule_New`. Ім’я взято з *spec*, а не "
"з визначення, щоб дозволити модулям розширення динамічно адаптуватися до "
"свого місця в ієрархії модулів і імпортуватися під різними іменами за "
"допомогою символічних посилань, водночас користуючись єдиним визначенням "
"модуля."

#: ../../c-api/module.rst:360
msgid ""
"There is no requirement for the returned object to be an instance of :c:type:"
"`PyModule_Type`. Any type can be used, as long as it supports setting and "
"getting import-related attributes. However, only ``PyModule_Type`` instances "
"may be returned if the ``PyModuleDef`` has non-``NULL`` ``m_traverse``, "
"``m_clear``, ``m_free``; non-zero ``m_size``; or slots other than "
"``Py_mod_create``."
msgstr ""
"Немає вимоги, щоб повернутий об’єкт був екземпляром :c:type:`PyModule_Type`. "
"Можна використовувати будь-який тип, якщо він підтримує встановлення та "
"отримання пов’язаних з імпортом атрибутів. Однак лише екземпляри "
"``PyModule_Type`` можуть повертатися, якщо ``PyModuleDef`` має не-``NULL`` "
"``m_traverse``, ``m_clear``, ``m_free``; ненульовий ``m_size``; або слоти, "
"відмінні від ``Py_mod_create``."

#: ../../c-api/module.rst:369
msgid ""
"Specifies a function that is called to *execute* the module. This is "
"equivalent to executing the code of a Python module: typically, this "
"function adds classes and constants to the module. The signature of the "
"function is:"
msgstr ""
"Визначає функцію, яка викликається для *виконання* модуля. Це еквівалентно "
"виконанню коду модуля Python: зазвичай ця функція додає класи та константи "
"до модуля. Сигнатура функції:"

#: ../../c-api/module.rst:376
msgid ""
"If multiple ``Py_mod_exec`` slots are specified, they are processed in the "
"order they appear in the *m_slots* array."
msgstr ""
"Se vários slots ``Py_mod_exec`` forem especificados, eles serão processados "
"na ordem em que aparecem no vetor *m_slots*."

#: ../../c-api/module.rst:379
msgid "See :PEP:`489` for more details on multi-phase initialization."
msgstr ""
"Ver :PEP:`489` para obter mais detalhes sobre a inicialização multifásica."

#: ../../c-api/module.rst:382
msgid "Low-level module creation functions"
msgstr "Funções de criação de módulo de baixo nível"

#: ../../c-api/module.rst:384
msgid ""
"The following functions are called under the hood when using multi-phase "
"initialization. They can be used directly, for example when creating module "
"objects dynamically. Note that both ``PyModule_FromDefAndSpec`` and "
"``PyModule_ExecDef`` must be called to fully initialize a module."
msgstr ""
"Наступні функції викликаються під капотом під час використання багатофазної "
"ініціалізації. Їх можна використовувати безпосередньо, наприклад, при "
"динамічному створенні об’єктів модуля. Зауважте, що для повної ініціалізації "
"модуля необхідно викликати як ``PyModule_FromDefAndSpec``, так і "
"``PyModule_ExecDef``."

#: ../../c-api/module.rst:391
msgid ""
"Create a new module object, given the definition in *def* and the ModuleSpec "
"*spec*.  This behaves like :c:func:`PyModule_FromDefAndSpec2` with "
"*module_api_version* set to :const:`PYTHON_API_VERSION`."
msgstr ""

#: ../../c-api/module.rst:399
msgid ""
"Create a new module object, given the definition in *def* and the ModuleSpec "
"*spec*, assuming the API version *module_api_version*. If that version does "
"not match the version of the running interpreter, a :exc:`RuntimeWarning` is "
"emitted."
msgstr ""
"Создайте новый объект модуля, учитывая определение в *def* и ModuleSpec "
"*spec*, предполагая версию API *module_api_version*. Если эта версия не "
"соответствует версии работающего интерпретатора, выдается :exc:"
"`RuntimeWarning`."

#: ../../c-api/module.rst:406
msgid ""
"Most uses of this function should be using :c:func:`PyModule_FromDefAndSpec` "
"instead; only use this if you are sure you need it."
msgstr ""
"У більшості випадків використання цієї функції має використовувати :c:func:"
"`PyModule_FromDefAndSpec`; використовуйте це, лише якщо ви впевнені, що це "
"вам потрібно."

#: ../../c-api/module.rst:413
msgid "Process any execution slots (:c:data:`Py_mod_exec`) given in *def*."
msgstr ""
"Обробити будь-які слоти виконання (:c:data:`Py_mod_exec`), указані в *def*."

#: ../../c-api/module.rst:419
msgid ""
"Set the docstring for *module* to *docstring*. This function is called "
"automatically when creating a module from ``PyModuleDef``, using either "
"``PyModule_Create`` or ``PyModule_FromDefAndSpec``."
msgstr ""
"Встановіть рядок документації для *module* на *string*. Ця функція "
"викликається автоматично під час створення модуля з ``PyModuleDef`` за "
"допомогою ``PyModule_Create`` або ``PyModule_FromDefAndSpec``."

#: ../../c-api/module.rst:428
msgid ""
"Add the functions from the ``NULL`` terminated *functions* array to "
"*module*. Refer to the :c:type:`PyMethodDef` documentation for details on "
"individual entries (due to the lack of a shared module namespace, module "
"level \"functions\" implemented in C typically receive the module as their "
"first parameter, making them similar to instance methods on Python classes). "
"This function is called automatically when creating a module from "
"``PyModuleDef``, using either ``PyModule_Create`` or "
"``PyModule_FromDefAndSpec``."
msgstr ""
"Додайте функції з масиву *functions* із закінченням ``NULL`` до *module*. "
"Зверніться до документації :c:type:`PyMethodDef`, щоб дізнатися більше про "
"окремі записи (через відсутність спільного простору імен модуля \"функції\" "
"рівня модуля, реалізовані в C, зазвичай отримують модуль як свій перший "
"параметр, що робить їх схожими на екземпляр методи на класах Python). Ця "
"функція викликається автоматично під час створення модуля з ``PyModuleDef`` "
"за допомогою ``PyModule_Create`` або ``PyModule_FromDefAndSpec``."

#: ../../c-api/module.rst:440
msgid "Support functions"
msgstr "Допоміжні функції"

#: ../../c-api/module.rst:442
msgid ""
"The module initialization function (if using single phase initialization) or "
"a function called from a module execution slot (if using multi-phase "
"initialization), can use the following functions to help initialize the "
"module state:"
msgstr ""
"Функція ініціалізації модуля (якщо використовується однофазна ініціалізація) "
"або функція, що викликається зі слота виконання модуля (якщо "
"використовується багатофазова ініціалізація), може використовувати такі "
"функції, щоб допомогти ініціалізувати стан модуля:"

#: ../../c-api/module.rst:449
msgid ""
"Add an object to *module* as *name*.  This is a convenience function which "
"can be used from the module's initialization function."
msgstr ""
"Додайте об’єкт до *модуля* як *ім’я*. Це зручна функція, яку можна "
"використовувати з функції ініціалізації модуля."

#: ../../c-api/module.rst:452
msgid ""
"On success, return ``0``. On error, raise an exception and return ``-1``."
msgstr ""
"У разі успіху поверніть ``0``. У разі помилки викликає виняток і повертає "
"``-1``."

#: ../../c-api/module.rst:454
msgid ""
"Return ``NULL`` if *value* is ``NULL``. It must be called with an exception "
"raised in this case."
msgstr ""
"Повертає ``NULL``, якщо *значення* дорівнює ``NULL``. У цьому випадку його "
"потрібно викликати з винятком."

#: ../../c-api/module.rst:457 ../../c-api/module.rst:506
msgid "Example usage::"
msgstr "Exemplo de uso::"

#: ../../c-api/module.rst:471 ../../c-api/module.rst:524
msgid ""
"The example can also be written without checking explicitly if *obj* is "
"``NULL``::"
msgstr ""
"O exemplo também pode ser escrito sem verificar explicitamente se *obj* é "
"``NULL``::"

#: ../../c-api/module.rst:483 ../../c-api/module.rst:540
msgid ""
"Note that ``Py_XDECREF()`` should be used instead of ``Py_DECREF()`` in this "
"case, since *obj* can be ``NULL``."
msgstr ""
"Зверніть увагу, що в цьому випадку слід використовувати ``Py_XDECREF()`` "
"замість ``Py_DECREF()``, оскільки *obj* може бути ``NULL``."

#: ../../c-api/module.rst:491
msgid ""
"Similar to :c:func:`PyModule_AddObjectRef`, but steals a reference to "
"*value* on success (if it returns ``0``)."
msgstr ""
"Подібно до :c:func:`PyModule_AddObjectRef`, але в разі успіху викрадає "
"посилання на *value* (якщо повертає ``0``)."

#: ../../c-api/module.rst:494
msgid ""
"The new :c:func:`PyModule_AddObjectRef` function is recommended, since it is "
"easy to introduce reference leaks by misusing the :c:func:"
"`PyModule_AddObject` function."
msgstr ""
"Рекомендовано використовувати нову функцію :c:func:`PyModule_AddObjectRef`, "
"оскільки внаслідок неправильного використання функції :c:func:"
"`PyModule_AddObject` легко створити витоки посилань."

#: ../../c-api/module.rst:500
msgid ""
"Unlike other functions that steal references, ``PyModule_AddObject()`` only "
"releases the reference to *value* **on success**."
msgstr ""
"В отличие от других функций, которые крадут ссылки, PyModule_AddObject() "
"освобождает ссылку на *value* только **в случае успеха**."

#: ../../c-api/module.rst:503
msgid ""
"This means that its return value must be checked, and calling code must :c:"
"func:`Py_DECREF` *value* manually on error."
msgstr ""
"Це означає, що його повертане значення має бути перевірено, а код виклику "
"повинен :c:func:`Py_DECREF` *значення* вручну у разі помилки."

#: ../../c-api/module.rst:546
msgid ""
"Add an integer constant to *module* as *name*.  This convenience function "
"can be used from the module's initialization function. Return ``-1`` on "
"error, ``0`` on success."
msgstr ""
"Додайте цілу константу до *module* як *name*. Цю зручну функцію можна "
"використовувати з функції ініціалізації модуля. Повертає ``-1`` у разі "
"помилки, ``0`` у разі успіху."

#: ../../c-api/module.rst:553
msgid ""
"Add a string constant to *module* as *name*.  This convenience function can "
"be used from the module's initialization function.  The string *value* must "
"be ``NULL``-terminated.  Return ``-1`` on error, ``0`` on success."
msgstr ""
"Додайте рядкову константу до *module* як *name*. Цю зручну функцію можна "
"використовувати з функції ініціалізації модуля. Рядок *значення* має "
"завершуватися ``NULL``. Повертає ``-1`` у разі помилки, ``0`` у разі успіху."

#: ../../c-api/module.rst:560
msgid ""
"Add an int constant to *module*. The name and the value are taken from "
"*macro*. For example ``PyModule_AddIntMacro(module, AF_INET)`` adds the int "
"constant *AF_INET* with the value of *AF_INET* to *module*. Return ``-1`` on "
"error, ``0`` on success."
msgstr ""
"Додайте константу int до *module*. Ім'я та значення взято з *макросу*. "
"Наприклад, ``PyModule_AddIntMacro(module, AF_INET)`` додає константу int "
"*AF_INET* зі значенням *AF_INET* до *module*. Повертає ``-1`` у разі "
"помилки, ``0`` у разі успіху."

#: ../../c-api/module.rst:568
msgid "Add a string constant to *module*."
msgstr "Додайте рядкову константу до *module*."

#: ../../c-api/module.rst:572
msgid ""
"Add a type object to *module*. The type object is finalized by calling "
"internally :c:func:`PyType_Ready`. The name of the type object is taken from "
"the last component of :c:member:`~PyTypeObject.tp_name` after dot. Return "
"``-1`` on error, ``0`` on success."
msgstr ""
"Додайте об’єкт типу до *module*. Об’єкт типу завершується внутрішнім "
"викликом :c:func:`PyType_Ready`. Ім’я об’єкта типу береться з останнього "
"компонента :c:member:`~PyTypeObject.tp_name` після крапки. Повертає ``-1`` у "
"разі помилки, ``0`` у разі успіху."

#: ../../c-api/module.rst:582
msgid "Module lookup"
msgstr "Pesquisa por módulos"

#: ../../c-api/module.rst:584
msgid ""
"Single-phase initialization creates singleton modules that can be looked up "
"in the context of the current interpreter. This allows the module object to "
"be retrieved later with only a reference to the module definition."
msgstr ""
"Однофазова ініціалізація створює однотонні модулі, які можна шукати в "
"контексті поточного інтерпретатора. Це дозволяє пізніше отримати об’єкт "
"модуля лише з посиланням на визначення модуля."

#: ../../c-api/module.rst:588
msgid ""
"These functions will not work on modules created using multi-phase "
"initialization, since multiple such modules can be created from a single "
"definition."
msgstr ""
"Ці функції не працюватимуть на модулях, створених за допомогою багатофазної "
"ініціалізації, оскільки кілька таких модулів можна створити з одного "
"визначення."

#: ../../c-api/module.rst:593
msgid ""
"Returns the module object that was created from *def* for the current "
"interpreter. This method requires that the module object has been attached "
"to the interpreter state with :c:func:`PyState_AddModule` beforehand. In "
"case the corresponding module object is not found or has not been attached "
"to the interpreter state yet, it returns ``NULL``."
msgstr ""
"Повертає об’єкт модуля, який було створено з *def* для поточного "
"інтерпретатора. Цей метод вимагає, щоб об’єкт модуля був прикріплений до "
"стану інтерпретатора за допомогою :c:func:`PyState_AddModule` заздалегідь. "
"Якщо відповідний об’єкт модуля не знайдено або ще не приєднано до стану "
"інтерпретатора, він повертає ``NULL``."

#: ../../c-api/module.rst:600
msgid ""
"Attaches the module object passed to the function to the interpreter state. "
"This allows the module object to be accessible via :c:func:"
"`PyState_FindModule`."
msgstr ""
"Приєднує об’єкт модуля, переданий у функцію, до стану інтерпретатора. Це "
"дозволяє об’єкту модуля бути доступним через :c:func:`PyState_FindModule`."

#: ../../c-api/module.rst:603
msgid "Only effective on modules created using single-phase initialization."
msgstr "Діє лише для модулів, створених за допомогою однофазної ініціалізації."

#: ../../c-api/module.rst:605
msgid ""
"Python calls ``PyState_AddModule`` automatically after importing a module, "
"so it is unnecessary (but harmless) to call it from module initialization "
"code. An explicit call is needed only if the module's own init code "
"subsequently calls ``PyState_FindModule``. The function is mainly intended "
"for implementing alternative import mechanisms (either by calling it "
"directly, or by referring to its implementation for details of the required "
"state updates)."
msgstr ""
"Python автоматично викликає ``PyState_AddModule`` після імпортування модуля, "
"тому непотрібно (але нешкідливо) викликати його з коду ініціалізації модуля. "
"Явний виклик потрібен, лише якщо власний код ініціалізації модуля згодом "
"викликає ``PyState_FindModule``. Ця функція в основному призначена для "
"впровадження альтернативних механізмів імпорту (або через її прямий виклик, "
"або шляхом посилання на її реалізацію для отримання деталей необхідних "
"оновлень стану)."

#: ../../c-api/module.rst:613 ../../c-api/module.rst:624
msgid "The caller must hold the GIL."
msgstr "Абонент повинен тримати GIL."

#: ../../c-api/module.rst:615
msgid "Return 0 on success or -1 on failure."
msgstr "Повертає 0 у разі успіху або -1 у разі невдачі."

#: ../../c-api/module.rst:621
msgid ""
"Removes the module object created from *def* from the interpreter state. "
"Return 0 on success or -1 on failure."
msgstr ""
"Видаляє об’єкт модуля, створений з *def*, зі стану інтерпретатора. Повертає "
"0 у разі успіху або -1 у разі невдачі."

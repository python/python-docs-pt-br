# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-23 14:12+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../c-api/sys.rst:6
msgid "Operating System Utilities"
msgstr "Utilitários do sistema operacional"

#: ../../c-api/sys.rst:11
msgid ""
"Return the file system representation for *path*. If the object is a :class:"
"`str` or :class:`bytes` object, then a new :term:`strong reference` is "
"returned. If the object implements the :class:`os.PathLike` interface, then :"
"meth:`~os.PathLike.__fspath__` is returned as long as it is a :class:`str` "
"or :class:`bytes` object. Otherwise :exc:`TypeError` is raised and ``NULL`` "
"is returned."
msgstr ""
"Retorna a representação do sistema de arquivos para *path*. Se o objeto for "
"um objeto :class:`str` ou :class:`bytes`, então uma nova :term:`referência "
"forte` é retornada. Se o objeto implementa a interface :class:`os.PathLike`, "
"então :meth:`~os.PathLike.__fspath__` é retornado desde que seja um objeto :"
"class:`str` ou :class:`bytes`. Caso contrário, :exc:`TypeError` é levantada "
"e ``NULL`` é retornado."

#: ../../c-api/sys.rst:24
msgid ""
"Return true (nonzero) if the standard I/O file *fp* with name *filename* is "
"deemed interactive.  This is the case for files for which "
"``isatty(fileno(fp))`` is true.  If the :c:member:`PyConfig.interactive` is "
"non-zero, this function also returns true if the *filename* pointer is "
"``NULL`` or if the name is equal to one of the strings ``'<stdin>'`` or "
"``'???'``."
msgstr ""
"Retorna verdadeiro (não zero) se o arquivo padrão de E/S *fp* com o nome "
"*filename* for considerado interativo. Este é o caso dos arquivos para os "
"quais ``isatty(fileno(fp))`` é verdade. Se :c:member:`PyConfig.interactive` "
"for não zero, esta função também retorna true se o ponteiro *filename* for "
"``NULL`` ou se o nome for igual a uma das strings ``'<stdin>'`` ou ``'???'``."

#: ../../c-api/sys.rst:30
msgid "This function must not be called before Python is initialized."
msgstr "Esta função não deve ser chamada antes da inicialização do Python."

#: ../../c-api/sys.rst:35
msgid ""
"Function to prepare some internal state before a process fork.  This should "
"be called before calling :c:func:`fork` or any similar function that clones "
"the current process. Only available on systems where :c:func:`fork` is "
"defined."
msgstr ""
"Função para preparar algum estado interno antes de ser feito um fork do "
"processo. Isso deve ser chamado antes de chamar :c:func:`fork` ou qualquer "
"função semelhante que clone o processo atual. Disponível apenas em sistemas "
"onde :c:func:`fork` é definido."

#: ../../c-api/sys.rst:41
msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread "
"<fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_BeforeFork()``."
msgstr ""
"A chamada C :c:func:`fork` só deve ser feita a partir da :ref:`thread "
"\"main\" <fork-and-threads>` (do :ref:`interpretador \"main\" <sub-"
"interpreter-support>`). O mesmo vale para ``PyOS_BeforeFork()``."

#: ../../c-api/sys.rst:51
msgid ""
"Function to update some internal state after a process fork.  This should be "
"called from the parent process after calling :c:func:`fork` or any similar "
"function that clones the current process, regardless of whether process "
"cloning was successful. Only available on systems where :c:func:`fork` is "
"defined."
msgstr ""
"Função para atualizar algum estado interno depois de ser feito um fork do "
"processo. Isso deve ser chamado a partir do processo pai depois de chamar :c:"
"func:`fork` ou qualquer função semelhante que clone o processo atual, "
"independentemente da clonagem do processo ter sido bem-sucedida ou não. "
"Disponível apenas em sistemas onde :c:func:`fork` é definido."

#: ../../c-api/sys.rst:58
msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread "
"<fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_AfterFork_Parent()``."
msgstr ""
"A chamada C :c:func:`fork` só deve ser feita a partir da :ref:`thread "
"\"main\" <fork-and-threads>` (do :ref:`interpretador \"main\" <sub-"
"interpreter-support>`). O mesmo vale para ``PyOS_AfterFork_Parent()``."

#: ../../c-api/sys.rst:68
msgid ""
"Function to update internal interpreter state after a process fork. This "
"must be called from the child process after calling :c:func:`fork`, or any "
"similar function that clones the current process, if there is any chance the "
"process will call back into the Python interpreter. Only available on "
"systems where :c:func:`fork` is defined."
msgstr ""
"Função para atualizar o estado interno do interpretador depois de ser feito "
"um fork do processo. Isso deve ser chamado a partir do processo filho depois "
"de chamar :c:func:`fork` ou qualquer função semelhante que clone o processo "
"atual, se houver alguma chance do processo ter uma chamada de retorno para o "
"interpretador Python. Disponível apenas em sistemas onde :c:func:`fork` é "
"definido."

#: ../../c-api/sys.rst:75
msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread "
"<fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_AfterFork_Child()``."
msgstr ""
"A chamada C :c:func:`fork` só deve ser feita a partir da :ref:`thread "
"\"main\" <fork-and-threads>` (do :ref:`interpretador \"main\" <sub-"
"interpreter-support>`). O mesmo vale para ``PyOS_AfterFork_Child()``."

#: ../../c-api/sys.rst:83
msgid ""
":func:`os.register_at_fork` allows registering custom Python functions to be "
"called by :c:func:`PyOS_BeforeFork()`, :c:func:`PyOS_AfterFork_Parent` and  :"
"c:func:`PyOS_AfterFork_Child`."
msgstr ""
":func:`os.register_at_fork` permite registrar funções personalizadas do "
"Python para serem chamadas por :c:func:`PyOS_BeforeFork()`, :c:func:"
"`PyOS_AfterFork_Parent` e  :c:func:`PyOS_AfterFork_Child`."

#: ../../c-api/sys.rst:90
msgid ""
"Function to update some internal state after a process fork; this should be "
"called in the new process if the Python interpreter will continue to be "
"used. If a new executable is loaded into the new process, this function does "
"not need to be called."
msgstr ""
"Função para atualizar algum estado interno após ser feito um fork de "
"processo; isso deve ser chamado no novo processo se o interpretador do "
"Python continuar a ser usado. Se um novo executável é carregado no novo "
"processo, esta função não precisa ser chamada."

#: ../../c-api/sys.rst:95
msgid "This function is superseded by :c:func:`PyOS_AfterFork_Child()`."
msgstr "Esta função foi sucedida por :c:func:`PyOS_AfterFork_Child()`."

#: ../../c-api/sys.rst:103
msgid ""
"Return true when the interpreter runs out of stack space.  This is a "
"reliable check, but is only available when :c:macro:`!USE_STACKCHECK` is "
"defined (currently on certain versions of Windows using the Microsoft Visual "
"C++ compiler). :c:macro:`!USE_STACKCHECK` will be defined automatically; you "
"should never change the definition in your own code."
msgstr ""
"Retorna verdadeiro quando o interpretador fica sem espaço na pilha. Esta é "
"uma verificação confiável, mas só está disponível quando :c:macro:`!"
"USE_STACKCHECK` é definido (atualmente em certas versões do Windows usando o "
"compilador Microsoft Visual C++). :c:macro:`!USE_STACKCHECK` será definido "
"automaticamente; você nunca deve alterar a definição em seu próprio código."

#: ../../c-api/sys.rst:115
msgid ""
"Return the current signal handler for signal *i*.  This is a thin wrapper "
"around either :c:func:`!sigaction` or :c:func:`!signal`.  Do not call those "
"functions directly!"
msgstr ""
"Retorna o manipulador de sinal atual para o sinal *i*. Este é um invólucro "
"fino em torno de :c:func:`!sigaction` ou :c:func:`!signal`. Não chame essas "
"funções diretamente!"

#: ../../c-api/sys.rst:122
msgid ""
"Set the signal handler for signal *i* to be *h*; return the old signal "
"handler. This is a thin wrapper around either :c:func:`!sigaction` or :c:"
"func:`!signal`.  Do not call those functions directly!"
msgstr ""
"Define o manipulador de sinal para o sinal *i* como *h*; retornar o "
"manipulador de sinal antigo. Este é um invólucro fino em torno de :c:func:`!"
"sigaction` ou :c:func:`!signal`. Não chame essas funções diretamente!"

#: ../../c-api/sys.rst:129
msgid "Check if a :c:macro:`!SIGINT` signal has been received."
msgstr "Verifica se um sinal :c:macro:`!SIGINT` foi recebido."

#: ../../c-api/sys.rst:131
msgid ""
"Returns ``1`` if a :c:macro:`!SIGINT` has occurred and clears the signal "
"flag, or ``0`` otherwise."
msgstr ""
"Retorna ``1`` se um :c:macro:`!SIGINT` ocorreu e limpa o sinalizador de "
"sinal, ou ``0`` caso contrário."

#: ../../c-api/sys.rst:134
msgid ""
"In most cases, you should prefer :c:func:`PyErr_CheckSignals` over this "
"function. :c:func:`!PyErr_CheckSignals` invokes the appropriate signal "
"handlers for all pending signals, allowing Python code to handle the signal "
"properly. This function only detects :c:macro:`!SIGINT` and does not invoke "
"any Python signal handlers."
msgstr ""
"Na maioria dos casos, você deve preferir :c:func:`PyErr_CheckSignals` em vez "
"desta função. :c:func:`!PyErr_CheckSignals` invoca os manipuladores de sinal "
"apropriados para todos os sinais pendentes, permitindo que o código Python "
"lide com o sinal corretamente. Esta função detecta apenas :c:macro:`!SIGINT` "
"e não invoca nenhum manipulador de sinal do Python."

#: ../../c-api/sys.rst:140
msgid ""
"This function is async-signal-safe and this function cannot fail. The caller "
"must hold an :term:`attached thread state`."
msgstr ""
"Esta função é segura para sinais de async e não pode falhar. O chamador deve "
"manter um :term:`estado de thread anexado`."

#: ../../c-api/sys.rst:147
msgid ""
"This function should not be called directly: use the :c:type:`PyConfig` API "
"with the :c:func:`PyConfig_SetBytesString` function which ensures that :ref:"
"`Python is preinitialized <c-preinit>`."
msgstr ""
"Esta função não deve ser chamada diretamente: use a API :c:type:`PyConfig` "
"com a função :c:func:`PyConfig_SetBytesString` que garante que :ref:`Python "
"esteja pré-inicializado <c-preinit>`."

#: ../../c-api/sys.rst:151 ../../c-api/sys.rst:218
msgid ""
"This function must not be called before :ref:`Python is preinitialized <c-"
"preinit>` and so that the LC_CTYPE locale is properly configured: see the :c:"
"func:`Py_PreInitialize` function."
msgstr ""
"Esta função não deve ser chamada antes de :ref:`Python estar pré-"
"inicializado <c-preinit>` e para que a localidade LC_CTYPE seja configurada "
"corretamente: consulte a função :c:func:`Py_PreInitialize`."

#: ../../c-api/sys.rst:155
msgid ""
"Decode a byte string from the :term:`filesystem encoding and error handler`. "
"If the error handler is :ref:`surrogateescape error handler "
"<surrogateescape>`, undecodable bytes are decoded as characters in range "
"U+DC80..U+DCFF; and if a byte sequence can be decoded as a surrogate "
"character, the bytes are escaped using the surrogateescape error handler "
"instead of decoding them."
msgstr ""
"Decodifica uma string de bytes do :term:`tratador de erros e codificação do "
"sistema de arquivos`. Se o tratador de erros for o :ref:`tratador de errors "
"surrogateescape <surrogateescape>`, bytes não decodificáveis são "
"decodificados como caracteres no intervalo U+DC80..U+DCFF; e se uma string "
"de bytes puder ser decodificada como um caractere substituto, os bytes são "
"escapados usando o tratador de erros surrogateescape em vez de decodificá-"
"los."

#: ../../c-api/sys.rst:162
msgid ""
"Return a pointer to a newly allocated wide character string, use :c:func:"
"`PyMem_RawFree` to free the memory. If size is not ``NULL``, write the "
"number of wide characters excluding the null character into ``*size``"
msgstr ""
"Retorna um ponteiro para uma string de caracteres largos recém-alocada, usa :"
"c:func:`PyMem_RawFree` para liberar a memória. Se o tamanho não for "
"``NULL``, escreve o número de caracteres largos excluindo o caractere nulo "
"em ``*size``"

#: ../../c-api/sys.rst:166
msgid ""
"Return ``NULL`` on decoding error or memory allocation error. If *size* is "
"not ``NULL``, ``*size`` is set to ``(size_t)-1`` on memory error or set to "
"``(size_t)-2`` on decoding error."
msgstr ""
"Retorna ``NULL`` em erro de decodificação ou erro de alocação de memória. Se "
"*size* não for ``NULL``, ``*size`` é definido como ``(size_t)-1`` em erro de "
"memória ou definido como ``(size_t)-2`` em erro de decodificação."

#: ../../c-api/sys.rst:170 ../../c-api/sys.rst:210
msgid ""
"The :term:`filesystem encoding and error handler` are selected by :c:func:"
"`PyConfig_Read`: see :c:member:`~PyConfig.filesystem_encoding` and :c:member:"
"`~PyConfig.filesystem_errors` members of :c:type:`PyConfig`."
msgstr ""
":term:`tratador de erros e codificação do sistema de arquivos` são "
"selecionados por :c:func:`PyConfig_Read`: veja os membros :c:member:"
"`~PyConfig.filesystem_encoding` e :c:member:`~PyConfig.filesystem_errors` "
"de :c:type:`PyConfig`."

#: ../../c-api/sys.rst:174
msgid ""
"Decoding errors should never happen, unless there is a bug in the C library."
msgstr ""
"Erros de decodificação nunca devem acontecer, a menos que haja um bug na "
"biblioteca C."

#: ../../c-api/sys.rst:177
msgid ""
"Use the :c:func:`Py_EncodeLocale` function to encode the character string "
"back to a byte string."
msgstr ""
"Use a função :c:func:`Py_EncodeLocale` para codificar a string de caracteres "
"de volta para uma string de bytes."

#: ../../c-api/sys.rst:182
msgid ""
"The :c:func:`PyUnicode_DecodeFSDefaultAndSize` and :c:func:"
"`PyUnicode_DecodeLocaleAndSize` functions."
msgstr ""
"As funções :c:func:`PyUnicode_DecodeFSDefaultAndSize` e :c:func:"
"`PyUnicode_DecodeLocaleAndSize`."

#: ../../c-api/sys.rst:187 ../../c-api/sys.rst:229
msgid ""
"The function now uses the UTF-8 encoding in the :ref:`Python UTF-8 Mode "
"<utf8-mode>`."
msgstr ""
"A função agora usa a codificação UTF-8 no :ref:`Modo UTF-8 do Python <utf8-"
"mode>`."

#: ../../c-api/sys.rst:191
msgid ""
"The function now uses the UTF-8 encoding on Windows if :c:member:"
"`PyPreConfig.legacy_windows_fs_encoding` is zero;"
msgstr ""
"A função agora usa a codificação UTF-8 no Windows se :c:member:`PyPreConfig."
"legacy_windows_fs_encoding` for zero;"

#: ../../c-api/sys.rst:198
msgid ""
"Encode a wide character string to the :term:`filesystem encoding and error "
"handler`. If the error handler is :ref:`surrogateescape error handler "
"<surrogateescape>`, surrogate characters in the range U+DC80..U+DCFF are "
"converted to bytes 0x80..0xFF."
msgstr ""
"Codifica uma string de caracteres largos para o :term:`tratador de erros e "
"codificação do sistema de arquivos`. Se o tratador de erros for um :ref:"
"`tratador de erros substituto <surrogateescape>`, os caracteres substitutos "
"no intervalo U+DC80..U+DCFF são convertidos em bytes 0x80..0xFF."

#: ../../c-api/sys.rst:203
msgid ""
"Return a pointer to a newly allocated byte string, use :c:func:`PyMem_Free` "
"to free the memory. Return ``NULL`` on encoding error or memory allocation "
"error."
msgstr ""
"Retorna um ponteiro para uma string de bytes recém-alocada; use :c:func:"
"`PyMem_Free` para liberar a memória. Retorna ``NULL`` em caso de erro de "
"codificação ou de erro de alocação de memória."

#: ../../c-api/sys.rst:207
msgid ""
"If error_pos is not ``NULL``, ``*error_pos`` is set to ``(size_t)-1`` on "
"success,  or set to the index of the invalid character on encoding error."
msgstr ""
"Se error_pos não for ``NULL``, ``*error_pos`` será definido como "
"``(size_t)-1`` em caso de sucesso, ou definido como o índice do caractere "
"inválido em caso de erro de codificação."

#: ../../c-api/sys.rst:214
msgid ""
"Use the :c:func:`Py_DecodeLocale` function to decode the bytes string back "
"to a wide character string."
msgstr ""
"Use a função :c:func:`Py_DecodeLocale` para decodificar a string de bytes de "
"volta para uma string de caracteres largos."

#: ../../c-api/sys.rst:224
msgid ""
"The :c:func:`PyUnicode_EncodeFSDefault` and :c:func:`PyUnicode_EncodeLocale` "
"functions."
msgstr ""
"As funções :c:func:`PyUnicode_EncodeFSDefault` e :c:func:"
"`PyUnicode_EncodeLocale`."

#: ../../c-api/sys.rst:233
msgid ""
"The function now uses the UTF-8 encoding on Windows if :c:member:"
"`PyPreConfig.legacy_windows_fs_encoding` is zero."
msgstr ""
"A função agora usa a codificação UTF-8 no Windows se :c:member:`PyPreConfig."
"legacy_windows_fs_encoding` for zero."

#: ../../c-api/sys.rst:239
msgid ""
"Similar to :c:func:`!fopen`, but *path* is a Python object and an exception "
"is set on error."
msgstr ""
"Semelhante a :c:func:`!fopen`, mas *path* é um objeto Python e uma exceção é "
"definida em caso de erro."

#: ../../c-api/sys.rst:242
msgid ""
"*path* must be a :class:`str` object, a :class:`bytes` object, or a :term:"
"`path-like object`."
msgstr ""
"*path* deve ser um objeto :class:`str`, um objeto :class:`bytes` ou um :term:"
"`objeto caminho ou similar`."

#: ../../c-api/sys.rst:245
msgid ""
"On success, return the new file pointer. On error, set an exception and "
"return ``NULL``."
msgstr ""
"Em caso de sucesso, retorna um novo ponteiro para arquivo. Em caso de erro, "
"define uma exceção e retorna ``NULL``."

#: ../../c-api/sys.rst:248
msgid ""
"The file must be closed by :c:func:`Py_fclose` rather than calling directly :"
"c:func:`!fclose`."
msgstr ""
"O arquivo deve ser fechado por :c:func:`Py_fclose` em vez de chamar "
"diretamente :c:func:`!fclose`."

#: ../../c-api/sys.rst:251
msgid "The file descriptor is created non-inheritable (:pep:`446`)."
msgstr "O descritor de arquivo é criado não herdável (:pep:`446`)."

#: ../../c-api/sys.rst:253
msgid "The caller must have an :term:`attached thread state`."
msgstr "O chamador deve ter um :term:`estado de thread anexado`."

#: ../../c-api/sys.rst:260
msgid "Close a file that was opened by :c:func:`Py_fopen`."
msgstr "Feche um arquivo que foi aberto por :c:func:`Py_fopen`."

#: ../../c-api/sys.rst:262
msgid ""
"On success, return ``0``. On error, return ``EOF`` and ``errno`` is set to "
"indicate the error. In either case, any further access (including another "
"call to :c:func:`Py_fclose`) to the stream results in undefined behavior."
msgstr ""
"Em caso de sucesso, retorna ``0``. Em caso de erro, retorna ``EOF`` e "
"``errno`` é definido para indicar o erro. Em ambos os casos, qualquer acesso "
"subsequente (incluindo outra chamada a :c:func:`Py_fclose`) ao fluxo resulta "
"em comportamento indefinido."

#: ../../c-api/sys.rst:273
msgid "System Functions"
msgstr "Funções de sistema"

#: ../../c-api/sys.rst:275
msgid ""
"These are utility functions that make functionality from the :mod:`sys` "
"module accessible to C code.  They all work with the current interpreter "
"thread's :mod:`sys` module's dict, which is contained in the internal thread "
"state structure."
msgstr ""
"Essas são funções utilitárias que tornam a funcionalidade do módulo :mod:"
"`sys` acessível ao código C. Todas elas funcionam com o dicionário do "
"módulo :mod:`sys` da thread do interpretador atual, que está contido na "
"estrutura interna do estado de thread."

#: ../../c-api/sys.rst:281
msgid ""
"Return the object *name* from the :mod:`sys` module or ``NULL`` if it does "
"not exist, without setting an exception."
msgstr ""
"Retorna o objeto *name* do módulo :mod:`sys` ou ``NULL`` se ele não existir, "
"sem lançar uma exceção."

#: ../../c-api/sys.rst:286
msgid ""
"Set *name* in the :mod:`sys` module to *v* unless *v* is ``NULL``, in which "
"case *name* is deleted from the sys module. Returns ``0`` on success, ``-1`` "
"on error."
msgstr ""
"Define *name* no módulo :mod:`sys` como *v*, a menos que *v* seja ``NULL``, "
"caso em que *name* é excluído do módulo sys. Retorna ``0`` em caso de "
"sucesso e ``-1`` em caso de erro."

#: ../../c-api/sys.rst:292
msgid ""
"Reset :data:`sys.warnoptions` to an empty list. This function may be called "
"prior to :c:func:`Py_Initialize`."
msgstr ""
"Redefine :data:`sys.warnoptions` para uma lista vazia. Esta função pode ser "
"chamada antes de :c:func:`Py_Initialize`."

#: ../../c-api/sys.rst:295
msgid "Clear :data:`sys.warnoptions` and :data:`!warnings.filters` instead."
msgstr ""
"Limpe :data:`sys.warnoptions` e :data:`!warnings.filters` em vez disso."

#: ../../c-api/sys.rst:300
msgid ""
"Write the output string described by *format* to :data:`sys.stdout`.  No "
"exceptions are raised, even if truncation occurs (see below)."
msgstr ""
"Escreve a string de saída descrita por *format* em :data:`sys.stdout`. "
"Nenhuma exceção será levantada, mesmo que ocorra truncamento (veja abaixo)."

#: ../../c-api/sys.rst:303
msgid ""
"*format* should limit the total size of the formatted output string to 1000 "
"bytes or less -- after 1000 bytes, the output string is truncated. In "
"particular, this means that no unrestricted \"%s\" formats should occur; "
"these should be limited using \"%.<N>s\" where <N> is a decimal number "
"calculated so that <N> plus the maximum size of other formatted text does "
"not exceed 1000 bytes.  Also watch out for \"%f\", which can print hundreds "
"of digits for very large numbers."
msgstr ""
"*format* deve limitar o tamanho total da string de saída formatada a 1000 "
"bytes ou menos -- após 1000 bytes, a string de saída é truncada. Em "
"particular, isso significa que não devem ocorrer formatos \"%s\" "
"irrestritos; estes devem ser limitados usando \"%.1s\", onde 2 é um número "
"decimal calculado de forma que 3 mais o tamanho máximo de outros textos "
"formatados não exceda 1000 bytes. Também fique atento a \"%f\", que pode "
"exibir centenas de dígitos para números muito grandes."

#: ../../c-api/sys.rst:311
msgid ""
"If a problem occurs, or :data:`sys.stdout` is unset, the formatted message "
"is written to the real (C level) *stdout*."
msgstr ""
"Se ocorrer um problema, ou se :data:`sys.stdout` não estiver definido, a "
"mensagem formatada será escrita na saída padrão (nível C) *stdout*."

#: ../../c-api/sys.rst:316
msgid ""
"As :c:func:`PySys_WriteStdout`, but write to :data:`sys.stderr` or *stderr* "
"instead."
msgstr ""
"Como :c:func:`PySys_WriteStdout`, mas escreve em :data:`sys.stderr` ou "
"*stderr* em vez disso."

#: ../../c-api/sys.rst:321
msgid ""
"Function similar to PySys_WriteStdout() but format the message using :c:func:"
"`PyUnicode_FromFormatV` and don't truncate the message to an arbitrary "
"length."
msgstr ""
"Função semelhante a PySys_WriteStdout(), mas formata a mensagem usando :c:"
"func:`PyUnicode_FromFormatV` e não trunca a mensagem para um comprimento "
"arbitrário."

#: ../../c-api/sys.rst:329
msgid ""
"As :c:func:`PySys_FormatStdout`, but write to :data:`sys.stderr` or *stderr* "
"instead."
msgstr ""
"Como :c:func:`PySys_FormatStdout`, mas escreve em :data:`sys.stderr` ou "
"*stderr* em vez disso."

#: ../../c-api/sys.rst:336
msgid ""
"Return the current dictionary of :option:`-X` options, similarly to :data:"
"`sys._xoptions`.  On error, ``NULL`` is returned and an exception is set."
msgstr ""
"Retorna o dicionário atual de opções :option:`-X`, de forma semelhante a :"
"data:`sys._xoptions`. Em caso de erro, retorna ``NULL`` e uma exceção é "
"definida."

#: ../../c-api/sys.rst:345
msgid ""
"Raise an auditing event with any active hooks. Return zero for success and "
"non-zero with an exception set on failure."
msgstr ""
"Levanta um evento de auditoria com todos os ganchos ativos. Retorna zero em "
"caso de sucesso e um valor diferente de zero com uma exceção definida em "
"caso de falha."

#: ../../c-api/sys.rst:348
msgid "The *event* string argument must not be *NULL*."
msgstr "O argumento de string *event* não pode ser *NULL*."

#: ../../c-api/sys.rst:350
msgid ""
"If any hooks have been added, *format* and other arguments will be used to "
"construct a tuple to pass. Apart from ``N``, the same format characters as "
"used in :c:func:`Py_BuildValue` are available. If the built value is not a "
"tuple, it will be added into a single-element tuple."
msgstr ""
"Se algum gancho tiver sido adicionado, o argumento *format* e outros serão "
"usados para construir uma tupla a ser passada. Além de ``N``, os mesmos "
"caracteres de formatação usados  em :c:func:`Py_BuildValue` estão "
"disponíveis. Se o valor construído não for uma tupla, ele será adicionado a "
"uma tupla de um único elemento."

#: ../../c-api/sys.rst:355
msgid ""
"The ``N`` format option must not be used. It consumes a reference, but since "
"there is no way to know whether arguments to this function will be consumed, "
"using it may cause reference leaks."
msgstr ""
"A opção de formato ``N`` não deve ser usada. Ela consome uma referência, mas "
"como não há como saber se os argumentos dessa função serão consumidos, usá-"
"la pode causar vazamentos de referência."

#: ../../c-api/sys.rst:359
msgid ""
"Note that ``#`` format characters should always be treated as :c:type:"
"`Py_ssize_t`, regardless of whether ``PY_SSIZE_T_CLEAN`` was defined."
msgstr ""
"Observe que os caracteres de formato ``#`` devem sempre ser tratados como :c:"
"type:`Py_ssize_t`, independentemente de ``PY_SSIZE_T_CLEAN`` ter sido "
"definido."

#: ../../c-api/sys.rst:362
msgid ":func:`sys.audit` performs the same function from Python code."
msgstr ":func:`sys.audit` executa a mesma função a partir do código Python."

#: ../../c-api/sys.rst:364
msgid "See also :c:func:`PySys_AuditTuple`."
msgstr "Veja também :c:func:`PySys_AuditTuple`."

#: ../../c-api/sys.rst:370
msgid ""
"Require :c:type:`Py_ssize_t` for ``#`` format characters. Previously, an "
"unavoidable deprecation warning was raised."
msgstr ""
"É necessário o tipo :c:type:`Py_ssize_t` para caracteres de formato ``#``. "
"Anteriormente, um aviso de descontinuação era levantado."

#: ../../c-api/sys.rst:376
msgid ""
"Similar to :c:func:`PySys_Audit`, but pass arguments as a Python object. "
"*args* must be a :class:`tuple`. To pass no arguments, *args* can be *NULL*."
msgstr ""
"Semelhante a :c:func:`PySys_Audit`, mas passa argumentos como um objeto "
"Python. *args* deve ser uma :class:`tuple`. Para não passar argumentos, "
"*args* pode ser *NULL*."

#: ../../c-api/sys.rst:384
msgid ""
"Append the callable *hook* to the list of active auditing hooks. Return zero "
"on success and non-zero on failure. If the runtime has been initialized, "
"also set an error on failure. Hooks added through this API are called for "
"all interpreters created by the runtime."
msgstr ""
"Adiciona o *gancho* chamável à lista de ganchos de auditoria ativos. Retorna "
"zero em caso de sucesso e um valor diferente de zero em caso de falha. Se o "
"ambiente de execução já tiver sido inicializado, também define um erro em "
"caso de falha. Os ganchos adicionados por meio desta API são chamados para "
"todos os interpretadores criados pelo ambiente de execução."

#: ../../c-api/sys.rst:390
msgid ""
"The *userData* pointer is passed into the hook function. Since hook "
"functions may be called from different runtimes, this pointer should not "
"refer directly to Python state."
msgstr ""
"O ponteiro *userData* é passado para a função de gancho. Como as funções de "
"gancho podem ser chamadas de diferentes tempos de execução, esse ponteiro "
"não deve se referir diretamente ao estado do Python."

#: ../../c-api/sys.rst:394
msgid ""
"This function is safe to call before :c:func:`Py_Initialize`. When called "
"after runtime initialization, existing audit hooks are notified and may "
"silently abort the operation by raising an error subclassed from :class:"
"`Exception` (other errors will not be silenced)."
msgstr ""
"Esta função pode ser chamada com segurança antes de :c:func:`Py_Initialize`. "
"Quando chamada após a inicialização em tempo de execução, os ganchos de "
"auditoria existentes são notificados e podem abortar silenciosamente a "
"operação, levantando um erro da classe :class:`Exception` (outros erros não "
"serão silenciados)."

#: ../../c-api/sys.rst:399
msgid ""
"The hook function is always called with an :term:`attached thread state` by "
"the Python interpreter that raised the event."
msgstr ""
"A função de gancho é sempre chamada com um :term:`estado de thread anexado` "
"pelo interpretador Python que levantou o evento."

#: ../../c-api/sys.rst:402
msgid ""
"See :pep:`578` for a detailed description of auditing.  Functions in the "
"runtime and standard library that raise events are listed in the :ref:`audit "
"events table <audit-events>`. Details are in each function's documentation."
msgstr ""
"Consulte a :pep:`578` para uma descrição detalhada da auditoria. As funções "
"no ambiente de execução e na biblioteca padrão que levantam eventos estão "
"listadas na :ref:`tabela de eventos de auditoria <audit-events>`. Os "
"detalhes estão na documentação de cada função."

#: ../../c-api/sys.rst:407 ../../c-api/sys.rst:409
msgid ""
"If the interpreter is initialized, this function raises an auditing event "
"``sys.addaudithook`` with no arguments. If any existing hooks raise an "
"exception derived from :class:`Exception`, the new hook will not be added "
"and the exception is cleared. As a result, callers cannot assume that their "
"hook has been added unless they control all existing hooks."
msgstr ""
"Se o interpretador estiver inicializado, esta função levanta um evento de "
"auditoria ``sys.addaudithook`` sem argumentos. Se algum gancho existente "
"levantar uma exceção derivada de :class:`Exception`, o novo gancho não será "
"adicionado e a exceção será tratada. Consequentemente, os chamadores não "
"podem presumir que seu gancho foi adicionado, a menos que controlem todos os "
"ganchos existentes."

#: ../../c-api/sys.rst:418
msgid ""
"The type of the hook function. *event* is the C string event argument passed "
"to :c:func:`PySys_Audit` or :c:func:`PySys_AuditTuple`. *args* is guaranteed "
"to be a :c:type:`PyTupleObject`. *userData* is the argument passed to "
"PySys_AddAuditHook()."
msgstr ""
"O tipo da função de gancho. *event* é o argumento de evento em string C "
"passado para :c:func:`PySys_Audit` ou :c:func:`PySys_AuditTuple`. *args* tem "
"a garantia de ser um :c:type:`PyTupleObject`. *userData* é o argumento "
"passado para PySys_AddAuditHook()."

#: ../../c-api/sys.rst:430
msgid "Process Control"
msgstr "Controle de processos"

#: ../../c-api/sys.rst:437
msgid ""
"Print a fatal error message and kill the process.  No cleanup is performed. "
"This function should only be invoked when a condition is detected that would "
"make it dangerous to continue using the Python interpreter; e.g., when the "
"object administration appears to be corrupted.  On Unix, the standard C "
"library function :c:func:`!abort` is called which will attempt to produce a :"
"file:`core` file."
msgstr ""
"Exibe uma mensagem de erro fatal e encerra forçadamente o processo. Nenhuma "
"limpeza é realizada. Esta função só deve ser invocada quando uma condição "
"for detectada que torne perigoso continuar usando o interpretador Python; "
"por exemplo, quando a administração de objetos parecer estar corrompida. No "
"Unix, a função da biblioteca padrão C :c:func:`!abort` é chamada, que "
"tentará produzir um arquivo :file:`core`."

#: ../../c-api/sys.rst:444
msgid ""
"The ``Py_FatalError()`` function is replaced with a macro which logs "
"automatically the name of the current function, unless the "
"``Py_LIMITED_API`` macro is defined."
msgstr ""
"A função ``Py_FatalError()`` é substituída por uma macro que registra "
"automaticamente o nome da função atual, a menos que a macro "
"``Py_LIMITED_API`` esteja definida."

#: ../../c-api/sys.rst:448
msgid "Log the function name automatically."
msgstr "Registra o nome da função automaticamente."

#: ../../c-api/sys.rst:458
msgid ""
"Exit the current process.  This calls :c:func:`Py_FinalizeEx` and then calls "
"the standard C library function ``exit(status)``.  If :c:func:"
"`Py_FinalizeEx` indicates an error, the exit status is set to 120."
msgstr ""
"Encerra o processo atual. Isso chama :c:func:`Py_FinalizeEx` e, em seguida, "
"chama a função da biblioteca padrão C ``exit(status)``. Se :c:func:"
"`Py_FinalizeEx` indicar um erro, o código de status de saída será definido "
"como 120."

#: ../../c-api/sys.rst:462
msgid "Errors from finalization no longer ignored."
msgstr "Erros da finalização não são mais ignorados."

#: ../../c-api/sys.rst:472
msgid ""
"Register a cleanup function to be called by :c:func:`Py_FinalizeEx`.  The "
"cleanup function will be called with no arguments and should return no "
"value.  At most 32 cleanup functions can be registered.  When the "
"registration is successful, :c:func:`Py_AtExit` returns ``0``; on failure, "
"it returns ``-1``.  The cleanup function registered last is called first. "
"Each cleanup function will be called at most once.  Since Python's internal "
"finalization will have completed before the cleanup function, no Python APIs "
"should be called by *func*."
msgstr ""
"Registra uma função de limpeza para ser chamada por :c:func:`Py_FinalizeEx`. "
"A função de limpeza será chamada sem argumentos e não deve retornar nenhum "
"valor. No máximo 32 funções de limpeza podem ser registradas. Quando o "
"registro for bem-sucedido, :c:func:`Py_AtExit` retorna ``0``; em caso de "
"falha, retorna ``-1``. A última função de limpeza registrada é chamada "
"primeiro. Cada função de limpeza será chamada no máximo uma vez. Como a "
"finalização interna do Python terá sido concluída antes da função de "
"limpeza, nenhuma API do Python deve ser chamada por *func*."

#: ../../c-api/sys.rst:482
msgid ":c:func:`PyUnstable_AtExit` for passing a ``void *data`` argument."
msgstr ":c:func:`PyUnstable_AtExit` para passar um argumento ``void *data``."

#: ../../c-api/sys.rst:101
msgid "USE_STACKCHECK (C macro)"
msgstr "USE_STACKCHECK (macro C)"

#: ../../c-api/sys.rst:435
msgid "abort (C function)"
msgstr "abort (função C)"

#: ../../c-api/sys.rst:454 ../../c-api/sys.rst:468
msgid "Py_FinalizeEx (C function)"
msgstr "Py_FinalizeEx (função C)"

#: ../../c-api/sys.rst:454
msgid "exit (C function)"
msgstr "exit (função C)"

#: ../../c-api/sys.rst:468
msgid "cleanup functions"
msgstr "funções de limpeza"

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# (Douglas da Silva) <dementikovalev@yandex.ru>, 2017
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2019
# Marco Rougeth <marco@rougeth.com>, 2020
# Vitor Buxbaum Orlandi, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 17:51+0000\n"
"PO-Revision-Date: 2017-02-16 17:39+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../c-api/typeobj.rst:6
msgid "Type Objects"
msgstr "Objetos tipo"

#: ../../c-api/typeobj.rst:8
msgid ""
"Perhaps one of the most important structures of the Python object system is "
"the structure that defines a new type: the :c:type:`PyTypeObject` "
"structure.  Type objects can be handled using any of the :c:func:"
"`PyObject_\\*` or :c:func:`PyType_\\*` functions, but do not offer much "
"that's interesting to most Python applications. These objects are "
"fundamental to how objects behave, so they are very important to the "
"interpreter itself and to any extension module that implements new types."
msgstr ""
"Talvez uma das estruturas mais importantes do sistema de objetos Python seja "
"a estrutura que define um novo tipo: a estrutura :c:type:`PyTypeObject`. "
"Objetos de tipo podem ser manipulados usando qualquer uma das funções :c:"
"func:`PyObject_\\*` ou :c:func:`PyType_\\*`, mas não oferecem muita coisa "
"interessante para a maioria dos aplicativos Python. Esses objetos são "
"fundamentais para o comportamento dos objetos, portanto, são muito "
"importantes para o próprio interpretador e para qualquer módulo de extensão "
"que implemente novos tipos."

#: ../../c-api/typeobj.rst:16
msgid ""
"Type objects are fairly large compared to most of the standard types. The "
"reason for the size is that each type object stores a large number of "
"values, mostly C function pointers, each of which implements a small part of "
"the type's functionality.  The fields of the type object are examined in "
"detail in this section.  The fields will be described in the order in which "
"they occur in the structure."
msgstr ""
"Os objetos de tipo são bastante grandes em comparação com a maioria dos "
"tipos padrão. A razão para o tamanho é que cada objeto de tipo armazena um "
"grande número de valores, principalmente indicadores de função C, cada um "
"dos quais implementa uma pequena parte da funcionalidade do tipo. Os campos "
"do objeto de tipo são examinados em detalhes nesta seção. Os campos serão "
"descritos na ordem em que ocorrem na estrutura."

#: ../../c-api/typeobj.rst:23
msgid ""
"In addition to the following quick reference, the :ref:`typedef-examples` "
"section provides at-a-glance insight into the meaning and use of :c:type:"
"`PyTypeObject`."
msgstr ""
"Além da referência rápida a seguir, a seção :ref:`typedef-examples` fornece "
"uma visão geral do significado e uso de :c:type:`PyTypeObject`."

#: ../../c-api/typeobj.rst:29
msgid "Quick Reference"
msgstr "Referências rápidas"

#: ../../c-api/typeobj.rst:34
msgid "\"tp slots\""
msgstr "\"slots tp\""

#: ../../c-api/typeobj.rst:40
msgid "PyTypeObject Slot [#slots]_"
msgstr "Slot de PyTypeObject [#slots]_"

#: ../../c-api/typeobj.rst:40 ../../c-api/typeobj.rst:193
msgid ":ref:`Type <slot-typedefs-table>`"
msgstr ":ref:`Tipo <slot-typedefs-table>`"

#: ../../c-api/typeobj.rst:40
msgid "special methods/attrs"
msgstr "métodos/atributos especiais"

#: ../../c-api/typeobj.rst:40
msgid "Info [#cols]_"
msgstr "Info [#cols]_"

#: ../../c-api/typeobj.rst:42
msgid "O"
msgstr "O"

#: ../../c-api/typeobj.rst:42
msgid "T"
msgstr "T"

#: ../../c-api/typeobj.rst:42
msgid "D"
msgstr "D"

#: ../../c-api/typeobj.rst:42
msgid "I"
msgstr "I"

#: ../../c-api/typeobj.rst:44
msgid "<R> :c:member:`~PyTypeObject.tp_name`"
msgstr "<R> :c:member:`~PyTypeObject.tp_name`"

#: ../../c-api/typeobj.rst:44 ../../c-api/typeobj.rst:86
#: ../../c-api/typeobj.rst:0
msgid "const char *"
msgstr "const char *"

#: ../../c-api/typeobj.rst:44
msgid "__name__"
msgstr "__name__"

#: ../../c-api/typeobj.rst:44 ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:50
#: ../../c-api/typeobj.rst:52 ../../c-api/typeobj.rst:62
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:72
#: ../../c-api/typeobj.rst:74 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:84
#: ../../c-api/typeobj.rst:86 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
#: ../../c-api/typeobj.rst:99 ../../c-api/typeobj.rst:101
#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:105
#: ../../c-api/typeobj.rst:107 ../../c-api/typeobj.rst:109
#: ../../c-api/typeobj.rst:111 ../../c-api/typeobj.rst:115
#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:124
#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:128
#: ../../c-api/typeobj.rst:130 ../../c-api/typeobj.rst:146
msgid "X"
msgstr "X"

#: ../../c-api/typeobj.rst:46
msgid ":c:member:`~PyTypeObject.tp_basicsize`"
msgstr ":c:member:`~PyTypeObject.tp_basicsize`"

#: ../../c-api/typeobj.rst:46 ../../c-api/typeobj.rst:48
#: ../../c-api/typeobj.rst:52 ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:120 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:406
msgid ":c:type:`Py_ssize_t`"
msgstr ":c:type:`Py_ssize_t`"

#: ../../c-api/typeobj.rst:48
msgid ":c:member:`~PyTypeObject.tp_itemsize`"
msgstr ":c:member:`~PyTypeObject.tp_itemsize`"

#: ../../c-api/typeobj.rst:50
msgid ":c:member:`~PyTypeObject.tp_dealloc`"
msgstr ":c:member:`~PyTypeObject.tp_dealloc`"

#: ../../c-api/typeobj.rst:50 ../../c-api/typeobj.rst:142
#: ../../c-api/typeobj.rst:146 ../../c-api/typeobj.rst:336
msgid ":c:type:`destructor`"
msgstr ":c:type:`destructor`"

#: ../../c-api/typeobj.rst:52
msgid ":c:member:`~PyTypeObject.tp_vectorcall_offset`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall_offset`"

#: ../../c-api/typeobj.rst:54
msgid "(:c:member:`~PyTypeObject.tp_getattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_getattr`)"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:360
msgid ":c:type:`getattrfunc`"
msgstr ":c:type:`getattrfunc`"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:76
msgid "__getattribute__, __getattr__"
msgstr "__getattribute__, __getattr__"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:57
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
msgid "G"
msgstr "G"

#: ../../c-api/typeobj.rst:57
msgid "(:c:member:`~PyTypeObject.tp_setattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_setattr`)"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:365
msgid ":c:type:`setattrfunc`"
msgstr ":c:type:`setattrfunc`"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:79
msgid "__setattr__, __delattr__"
msgstr "__setattr__, __delattr__"

#: ../../c-api/typeobj.rst:60
msgid ":c:member:`~PyTypeObject.tp_as_async`"
msgstr ":c:member:`~PyTypeObject.tp_as_async`"

#: ../../c-api/typeobj.rst:60
msgid ":c:type:`PyAsyncMethods` *"
msgstr ":c:type:`PyAsyncMethods` *"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
msgid ":ref:`sub-slots`"
msgstr ":ref:`sub-slots`"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
#: ../../c-api/typeobj.rst:82
msgid "%"
msgstr "%"

#: ../../c-api/typeobj.rst:62
msgid ":c:member:`~PyTypeObject.tp_repr`"
msgstr ":c:member:`~PyTypeObject.tp_repr`"

#: ../../c-api/typeobj.rst:62 ../../c-api/typeobj.rst:74
#: ../../c-api/typeobj.rst:358
msgid ":c:type:`reprfunc`"
msgstr ":c:type:`reprfunc`"

#: ../../c-api/typeobj.rst:62
msgid "__repr__"
msgstr "__repr__"

#: ../../c-api/typeobj.rst:64
msgid ":c:member:`~PyTypeObject.tp_as_number`"
msgstr ":c:member:`~PyTypeObject.tp_as_number`"

#: ../../c-api/typeobj.rst:64
msgid ":c:type:`PyNumberMethods` *"
msgstr ":c:type:`PyNumberMethods` *"

#: ../../c-api/typeobj.rst:66
msgid ":c:member:`~PyTypeObject.tp_as_sequence`"
msgstr ":c:member:`~PyTypeObject.tp_as_sequence`"

#: ../../c-api/typeobj.rst:66
msgid ":c:type:`PySequenceMethods` *"
msgstr ":c:type:`PySequenceMethods` *"

#: ../../c-api/typeobj.rst:68
msgid ":c:member:`~PyTypeObject.tp_as_mapping`"
msgstr ":c:member:`~PyTypeObject.tp_as_mapping`"

#: ../../c-api/typeobj.rst:68
msgid ":c:type:`PyMappingMethods` *"
msgstr ":c:type:`PyMappingMethods` *"

#: ../../c-api/typeobj.rst:70
msgid ":c:member:`~PyTypeObject.tp_hash`"
msgstr ":c:member:`~PyTypeObject.tp_hash`"

#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:394
msgid ":c:type:`hashfunc`"
msgstr ":c:type:`hashfunc`"

#: ../../c-api/typeobj.rst:70
msgid "__hash__"
msgstr "__hash__"

#: ../../c-api/typeobj.rst:72
msgid ":c:member:`~PyTypeObject.tp_call`"
msgstr ":c:member:`~PyTypeObject.tp_call`"

#: ../../c-api/typeobj.rst:72 ../../c-api/typeobj.rst:227
#: ../../c-api/typeobj.rst:230 ../../c-api/typeobj.rst:430
msgid ":c:type:`ternaryfunc`"
msgstr ":c:type:`ternaryfunc`"

#: ../../c-api/typeobj.rst:72
msgid "__call__"
msgstr "__call__"

#: ../../c-api/typeobj.rst:74
msgid ":c:member:`~PyTypeObject.tp_str`"
msgstr ":c:member:`~PyTypeObject.tp_str`"

#: ../../c-api/typeobj.rst:74
msgid "__str__"
msgstr "__str__"

#: ../../c-api/typeobj.rst:76
msgid ":c:member:`~PyTypeObject.tp_getattro`"
msgstr ":c:member:`~PyTypeObject.tp_getattro`"

#: ../../c-api/typeobj.rst:76 ../../c-api/typeobj.rst:371
msgid ":c:type:`getattrofunc`"
msgstr ":c:type:`getattrofunc`"

#: ../../c-api/typeobj.rst:79
msgid ":c:member:`~PyTypeObject.tp_setattro`"
msgstr ":c:member:`~PyTypeObject.tp_setattro`"

#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:376
msgid ":c:type:`setattrofunc`"
msgstr ":c:type:`setattrofunc`"

#: ../../c-api/typeobj.rst:82
msgid ":c:member:`~PyTypeObject.tp_as_buffer`"
msgstr ":c:member:`~PyTypeObject.tp_as_buffer`"

#: ../../c-api/typeobj.rst:82
msgid ":c:type:`PyBufferProcs` *"
msgstr ":c:type:`PyBufferProcs` *"

#: ../../c-api/typeobj.rst:84
msgid ":c:member:`~PyTypeObject.tp_flags`"
msgstr ":c:member:`~PyTypeObject.tp_flags`"

#: ../../c-api/typeobj.rst:84
msgid "unsigned long"
msgstr "unsigned long"

#: ../../c-api/typeobj.rst:84 ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:113 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:126
#: ../../c-api/typeobj.rst:128
msgid "?"
msgstr "?"

#: ../../c-api/typeobj.rst:86
msgid ":c:member:`~PyTypeObject.tp_doc`"
msgstr ":c:member:`~PyTypeObject.tp_doc`"

#: ../../c-api/typeobj.rst:86
msgid "__doc__"
msgstr "__doc__"

#: ../../c-api/typeobj.rst:88
msgid ":c:member:`~PyTypeObject.tp_traverse`"
msgstr ":c:member:`~PyTypeObject.tp_traverse`"

#: ../../c-api/typeobj.rst:88 ../../c-api/typeobj.rst:340
msgid ":c:type:`traverseproc`"
msgstr ":c:type:`traverseproc`"

#: ../../c-api/typeobj.rst:90
msgid ":c:member:`~PyTypeObject.tp_clear`"
msgstr ":c:member:`~PyTypeObject.tp_clear`"

#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:130
#: ../../c-api/typeobj.rst:238 ../../c-api/typeobj.rst:419
msgid ":c:type:`inquiry`"
msgstr ":c:type:`inquiry`"

#: ../../c-api/typeobj.rst:92
msgid ":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ":c:member:`~PyTypeObject.tp_richcompare`"

#: ../../c-api/typeobj.rst:92 ../../c-api/typeobj.rst:396
msgid ":c:type:`richcmpfunc`"
msgstr ":c:type:`richcmpfunc`"

#: ../../c-api/typeobj.rst:92
msgid "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"
msgstr "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"

#: ../../c-api/typeobj.rst:99
msgid ":c:member:`~PyTypeObject.tp_weaklistoffset`"
msgstr ":c:member:`~PyTypeObject.tp_weaklistoffset`"

#: ../../c-api/typeobj.rst:101
msgid ":c:member:`~PyTypeObject.tp_iter`"
msgstr ":c:member:`~PyTypeObject.tp_iter`"

#: ../../c-api/typeobj.rst:101 ../../c-api/typeobj.rst:402
msgid ":c:type:`getiterfunc`"
msgstr ":c:type:`getiterfunc`"

#: ../../c-api/typeobj.rst:101
msgid "__iter__"
msgstr "__iter__"

#: ../../c-api/typeobj.rst:103
msgid ":c:member:`~PyTypeObject.tp_iternext`"
msgstr ":c:member:`~PyTypeObject.tp_iternext`"

#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:404
msgid ":c:type:`iternextfunc`"
msgstr ":c:type:`iternextfunc`"

#: ../../c-api/typeobj.rst:103
msgid "__next__"
msgstr "__next__"

#: ../../c-api/typeobj.rst:105
msgid ":c:member:`~PyTypeObject.tp_methods`"
msgstr ":c:member:`~PyTypeObject.tp_methods`"

#: ../../c-api/typeobj.rst:105
msgid ":c:type:`PyMethodDef` []"
msgstr ":c:type:`PyMethodDef` []"

#: ../../c-api/typeobj.rst:107
msgid ":c:member:`~PyTypeObject.tp_members`"
msgstr ":c:member:`~PyTypeObject.tp_members`"

#: ../../c-api/typeobj.rst:107
msgid ":c:type:`PyMemberDef` []"
msgstr ":c:type:`PyMemberDef` []"

#: ../../c-api/typeobj.rst:109
msgid ":c:member:`~PyTypeObject.tp_getset`"
msgstr ":c:member:`~PyTypeObject.tp_getset`"

#: ../../c-api/typeobj.rst:109
msgid ":c:type:`PyGetSetDef` []"
msgstr ":c:type:`PyGetSetDef` []"

#: ../../c-api/typeobj.rst:111
msgid ":c:member:`~PyTypeObject.tp_base`"
msgstr ":c:member:`~PyTypeObject.tp_base`"

#: ../../c-api/typeobj.rst:111 ../../c-api/typeobj.rst:0
msgid ":c:type:`PyTypeObject` *"
msgstr ":c:type:`PyTypeObject` *"

#: ../../c-api/typeobj.rst:111
msgid "__base__"
msgstr "__base__"

#: ../../c-api/typeobj.rst:113
msgid ":c:member:`~PyTypeObject.tp_dict`"
msgstr ":c:member:`~PyTypeObject.tp_dict`"

#: ../../c-api/typeobj.rst:113 ../../c-api/typeobj.rst:132
#: ../../c-api/typeobj.rst:134 ../../c-api/typeobj.rst:136
#: ../../c-api/typeobj.rst:138 ../../c-api/typeobj.rst:140
#: ../../c-api/typeobj.rst:331 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:346 ../../c-api/typeobj.rst:358
#: ../../c-api/typeobj.rst:360 ../../c-api/typeobj.rst:371
#: ../../c-api/typeobj.rst:382 ../../c-api/typeobj.rst:394
#: ../../c-api/typeobj.rst:396 ../../c-api/typeobj.rst:402
#: ../../c-api/typeobj.rst:404 ../../c-api/typeobj.rst:406
#: ../../c-api/typeobj.rst:421 ../../c-api/typeobj.rst:425
#: ../../c-api/typeobj.rst:430 ../../c-api/typeobj.rst:436
msgid ":c:type:`PyObject` *"
msgstr ":c:type:`PyObject` *"

#: ../../c-api/typeobj.rst:113
msgid "__dict__"
msgstr "__dict__"

#: ../../c-api/typeobj.rst:115
msgid ":c:member:`~PyTypeObject.tp_descr_get`"
msgstr ":c:member:`~PyTypeObject.tp_descr_get`"

#: ../../c-api/typeobj.rst:115 ../../c-api/typeobj.rst:382
msgid ":c:type:`descrgetfunc`"
msgstr ":c:type:`descrgetfunc`"

#: ../../c-api/typeobj.rst:115
msgid "__get__"
msgstr "__get__"

#: ../../c-api/typeobj.rst:117
msgid ":c:member:`~PyTypeObject.tp_descr_set`"
msgstr ":c:member:`~PyTypeObject.tp_descr_set`"

#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:388
msgid ":c:type:`descrsetfunc`"
msgstr ":c:type:`descrsetfunc`"

#: ../../c-api/typeobj.rst:117
msgid "__set__, __delete__"
msgstr "__set__, __delete__"

#: ../../c-api/typeobj.rst:120
msgid ":c:member:`~PyTypeObject.tp_dictoffset`"
msgstr ":c:member:`~PyTypeObject.tp_dictoffset`"

#: ../../c-api/typeobj.rst:122
msgid ":c:member:`~PyTypeObject.tp_init`"
msgstr ":c:member:`~PyTypeObject.tp_init`"

#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:352
msgid ":c:type:`initproc`"
msgstr ":c:type:`initproc`"

#: ../../c-api/typeobj.rst:122
msgid "__init__"
msgstr "__init__"

#: ../../c-api/typeobj.rst:124
msgid ":c:member:`~PyTypeObject.tp_alloc`"
msgstr ":c:member:`~PyTypeObject.tp_alloc`"

#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:331
msgid ":c:type:`allocfunc`"
msgstr ":c:type:`allocfunc`"

#: ../../c-api/typeobj.rst:126
msgid ":c:member:`~PyTypeObject.tp_new`"
msgstr ":c:member:`~PyTypeObject.tp_new`"

#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:346
msgid ":c:type:`newfunc`"
msgstr ":c:type:`newfunc`"

#: ../../c-api/typeobj.rst:126
msgid "__new__"
msgstr "__new__"

#: ../../c-api/typeobj.rst:128
msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ":c:member:`~PyTypeObject.tp_free`"

#: ../../c-api/typeobj.rst:128 ../../c-api/typeobj.rst:338
msgid ":c:type:`freefunc`"
msgstr ":c:type:`freefunc`"

#: ../../c-api/typeobj.rst:130
msgid ":c:member:`~PyTypeObject.tp_is_gc`"
msgstr ":c:member:`~PyTypeObject.tp_is_gc`"

#: ../../c-api/typeobj.rst:132
msgid "<:c:member:`~PyTypeObject.tp_bases`>"
msgstr "<:c:member:`~PyTypeObject.tp_bases`>"

#: ../../c-api/typeobj.rst:132
msgid "__bases__"
msgstr "__bases__"

#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
msgid "~"
msgstr "~"

#: ../../c-api/typeobj.rst:134
msgid "<:c:member:`~PyTypeObject.tp_mro`>"
msgstr "<:c:member:`~PyTypeObject.tp_mro`>"

#: ../../c-api/typeobj.rst:134
msgid "__mro__"
msgstr "__mro__"

#: ../../c-api/typeobj.rst:136
msgid "[:c:member:`~PyTypeObject.tp_cache`]"
msgstr "[:c:member:`~PyTypeObject.tp_cache`]"

#: ../../c-api/typeobj.rst:138
msgid "[:c:member:`~PyTypeObject.tp_subclasses`]"
msgstr "[:c:member:`~PyTypeObject.tp_subclasses`]"

#: ../../c-api/typeobj.rst:138
msgid "__subclasses__"
msgstr "__subclasses__"

#: ../../c-api/typeobj.rst:140
msgid "[:c:member:`~PyTypeObject.tp_weaklist`]"
msgstr "[:c:member:`~PyTypeObject.tp_weaklist`]"

#: ../../c-api/typeobj.rst:142
msgid "(:c:member:`~PyTypeObject.tp_del`)"
msgstr "(:c:member:`~PyTypeObject.tp_del`)"

#: ../../c-api/typeobj.rst:144
msgid "[:c:member:`~PyTypeObject.tp_version_tag`]"
msgstr "[:c:member:`~PyTypeObject.tp_version_tag`]"

#: ../../c-api/typeobj.rst:144
msgid "unsigned int"
msgstr "unsigned int"

#: ../../c-api/typeobj.rst:146
msgid ":c:member:`~PyTypeObject.tp_finalize`"
msgstr ":c:member:`~PyTypeObject.tp_finalize`"

#: ../../c-api/typeobj.rst:146
msgid "__del__"
msgstr "__del__"

#: ../../c-api/typeobj.rst:148
msgid ":c:member:`~PyTypeObject.tp_vectorcall`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall`"

#: ../../c-api/typeobj.rst:148
msgid ":c:type:`vectorcallfunc`"
msgstr ":c:type:`vectorcallfunc`"

#: ../../c-api/typeobj.rst:152
msgid ""
"A slot name in parentheses indicates it is (effectively) deprecated. Names "
"in angle brackets should be treated as read-only. Names in square brackets "
"are for internal use only. \"<R>\" (as a prefix) means the field is required "
"(must be non-``NULL``)."
msgstr ""

#: ../../c-api/typeobj.rst:156
msgid "Columns:"
msgstr "Стовпці:"

#: ../../c-api/typeobj.rst:158
msgid "**\"O\"**:  set on :c:type:`PyBaseObject_Type`"
msgstr "**\"O\"**: встановлено на :c:type:`PyBaseObject_Type`"

#: ../../c-api/typeobj.rst:160
msgid "**\"T\"**:  set on :c:type:`PyType_Type`"
msgstr "**\"T\"**: встановлено на :c:type:`PyType_Type`"

#: ../../c-api/typeobj.rst:162
msgid "**\"D\"**:  default (if slot is set to ``NULL``)"
msgstr ""
"**\"D\"**: за умовчанням (якщо для слота встановлено значення ``NULL``)"

#: ../../c-api/typeobj.rst:172
msgid "**\"I\"**:  inheritance"
msgstr "**\"I\"**: наслідування"

#: ../../c-api/typeobj.rst:181
msgid ""
"Note that some slots are effectively inherited through the normal attribute "
"lookup chain."
msgstr ""
"Зверніть увагу, що деякі слоти фактично успадковуються через звичайний "
"ланцюжок пошуку атрибутів."

#: ../../c-api/typeobj.rst:187
msgid "sub-slots"
msgstr "sub-slots"

#: ../../c-api/typeobj.rst:193
msgid "Slot"
msgstr "Слот"

#: ../../c-api/typeobj.rst:193
msgid "special methods"
msgstr "спеціальні методи"

#: ../../c-api/typeobj.rst:196
msgid ":c:member:`~PyAsyncMethods.am_await`"
msgstr ":c:member:`~PyAsyncMethods.am_await`"

#: ../../c-api/typeobj.rst:196 ../../c-api/typeobj.rst:198
#: ../../c-api/typeobj.rst:200 ../../c-api/typeobj.rst:232
#: ../../c-api/typeobj.rst:234 ../../c-api/typeobj.rst:236
#: ../../c-api/typeobj.rst:240 ../../c-api/typeobj.rst:267
#: ../../c-api/typeobj.rst:271 ../../c-api/typeobj.rst:281
#: ../../c-api/typeobj.rst:421
msgid ":c:type:`unaryfunc`"
msgstr ":c:type:`unaryfunc`"

#: ../../c-api/typeobj.rst:196
msgid "__await__"
msgstr "__await__"

#: ../../c-api/typeobj.rst:198
msgid ":c:member:`~PyAsyncMethods.am_aiter`"
msgstr ":c:member:`~PyAsyncMethods.am_aiter`"

#: ../../c-api/typeobj.rst:198
msgid "__aiter__"
msgstr "__aiter__"

#: ../../c-api/typeobj.rst:200
msgid ":c:member:`~PyAsyncMethods.am_anext`"
msgstr ":c:member:`~PyAsyncMethods.am_anext`"

#: ../../c-api/typeobj.rst:200
msgid "__anext__"
msgstr "__anext__"

#: ../../c-api/typeobj.rst:204
msgid ":c:member:`~PyNumberMethods.nb_add`"
msgstr ":c:member:`~PyNumberMethods.nb_add`"

#: ../../c-api/typeobj.rst:204 ../../c-api/typeobj.rst:207
#: ../../c-api/typeobj.rst:209 ../../c-api/typeobj.rst:212
#: ../../c-api/typeobj.rst:214 ../../c-api/typeobj.rst:217
#: ../../c-api/typeobj.rst:219 ../../c-api/typeobj.rst:222
#: ../../c-api/typeobj.rst:224 ../../c-api/typeobj.rst:242
#: ../../c-api/typeobj.rst:245 ../../c-api/typeobj.rst:247
#: ../../c-api/typeobj.rst:250 ../../c-api/typeobj.rst:252
#: ../../c-api/typeobj.rst:255 ../../c-api/typeobj.rst:257
#: ../../c-api/typeobj.rst:260 ../../c-api/typeobj.rst:262
#: ../../c-api/typeobj.rst:265 ../../c-api/typeobj.rst:273
#: ../../c-api/typeobj.rst:275 ../../c-api/typeobj.rst:277
#: ../../c-api/typeobj.rst:279 ../../c-api/typeobj.rst:283
#: ../../c-api/typeobj.rst:286 ../../c-api/typeobj.rst:292
#: ../../c-api/typeobj.rst:301 ../../c-api/typeobj.rst:312
#: ../../c-api/typeobj.rst:425
msgid ":c:type:`binaryfunc`"
msgstr ":c:type:`binaryfunc`"

#: ../../c-api/typeobj.rst:204
msgid "__add__ __radd__"
msgstr "__add__ __radd__"

#: ../../c-api/typeobj.rst:207
msgid ":c:member:`~PyNumberMethods.nb_inplace_add`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_add`"

#: ../../c-api/typeobj.rst:207 ../../c-api/typeobj.rst:312
msgid "__iadd__"
msgstr "__iadd__"

#: ../../c-api/typeobj.rst:209
msgid ":c:member:`~PyNumberMethods.nb_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_subtract`"

#: ../../c-api/typeobj.rst:209
msgid "__sub__ __rsub__"
msgstr "__sub__ __rsub__"

#: ../../c-api/typeobj.rst:212
msgid ":c:member:`~PyNumberMethods.nb_inplace_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_subtract`"

#: ../../c-api/typeobj.rst:212
msgid "__isub__"
msgstr "__isub__"

#: ../../c-api/typeobj.rst:214
msgid ":c:member:`~PyNumberMethods.nb_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_multiply`"

#: ../../c-api/typeobj.rst:214
msgid "__mul__ __rmul__"
msgstr "__mul__ __rmul__"

#: ../../c-api/typeobj.rst:217
msgid ":c:member:`~PyNumberMethods.nb_inplace_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_multiply`"

#: ../../c-api/typeobj.rst:217 ../../c-api/typeobj.rst:314
msgid "__imul__"
msgstr "__imul__"

#: ../../c-api/typeobj.rst:219
msgid ":c:member:`~PyNumberMethods.nb_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_remainder`"

#: ../../c-api/typeobj.rst:219
msgid "__mod__ __rmod__"
msgstr "__mod__ __rmod__"

#: ../../c-api/typeobj.rst:222
msgid ":c:member:`~PyNumberMethods.nb_inplace_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_remainder`"

#: ../../c-api/typeobj.rst:222
msgid "__imod__"
msgstr "__imod__"

#: ../../c-api/typeobj.rst:224
msgid ":c:member:`~PyNumberMethods.nb_divmod`"
msgstr ":c:member:`~PyNumberMethods.nb_divmod`"

#: ../../c-api/typeobj.rst:224
msgid "__divmod__ __rdivmod__"
msgstr "__divmod__ __rdivmod__"

#: ../../c-api/typeobj.rst:227
msgid ":c:member:`~PyNumberMethods.nb_power`"
msgstr ":c:member:`~PyNumberMethods.nb_power`"

#: ../../c-api/typeobj.rst:227
msgid "__pow__ __rpow__"
msgstr "__pow__ __rpow__"

#: ../../c-api/typeobj.rst:230
msgid ":c:member:`~PyNumberMethods.nb_inplace_power`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_power`"

#: ../../c-api/typeobj.rst:230
msgid "__ipow__"
msgstr "__ipow__"

#: ../../c-api/typeobj.rst:232
msgid ":c:member:`~PyNumberMethods.nb_negative`"
msgstr ":c:member:`~PyNumberMethods.nb_negative`"

#: ../../c-api/typeobj.rst:232
msgid "__neg__"
msgstr "__neg__"

#: ../../c-api/typeobj.rst:234
msgid ":c:member:`~PyNumberMethods.nb_positive`"
msgstr ":c:member:`~PyNumberMethods.nb_positive`"

#: ../../c-api/typeobj.rst:234
msgid "__pos__"
msgstr "__pos__"

#: ../../c-api/typeobj.rst:236
msgid ":c:member:`~PyNumberMethods.nb_absolute`"
msgstr ":c:member:`~PyNumberMethods.nb_absolute`"

#: ../../c-api/typeobj.rst:236
msgid "__abs__"
msgstr "__abs__"

#: ../../c-api/typeobj.rst:238
msgid ":c:member:`~PyNumberMethods.nb_bool`"
msgstr ":c:member:`~PyNumberMethods.nb_bool`"

#: ../../c-api/typeobj.rst:238
msgid "__bool__"
msgstr "__bool__"

#: ../../c-api/typeobj.rst:240
msgid ":c:member:`~PyNumberMethods.nb_invert`"
msgstr ":c:member:`~PyNumberMethods.nb_invert`"

#: ../../c-api/typeobj.rst:240
msgid "__invert__"
msgstr "__invert__"

#: ../../c-api/typeobj.rst:242
msgid ":c:member:`~PyNumberMethods.nb_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_lshift`"

#: ../../c-api/typeobj.rst:242
msgid "__lshift__ __rlshift__"
msgstr "__lshift__ __rlshift__"

#: ../../c-api/typeobj.rst:245
msgid ":c:member:`~PyNumberMethods.nb_inplace_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_lshift`"

#: ../../c-api/typeobj.rst:245
msgid "__ilshift__"
msgstr "__ilshift__"

#: ../../c-api/typeobj.rst:247
msgid ":c:member:`~PyNumberMethods.nb_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_rshift`"

#: ../../c-api/typeobj.rst:247
msgid "__rshift__ __rrshift__"
msgstr "__rshift__ __rrshift__"

#: ../../c-api/typeobj.rst:250
msgid ":c:member:`~PyNumberMethods.nb_inplace_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_rshift`"

#: ../../c-api/typeobj.rst:250
msgid "__irshift__"
msgstr "__irshift__"

#: ../../c-api/typeobj.rst:252
msgid ":c:member:`~PyNumberMethods.nb_and`"
msgstr ":c:member:`~PyNumberMethods.nb_and`"

#: ../../c-api/typeobj.rst:252
msgid "__and__ __rand__"
msgstr "__and__ __rand__"

#: ../../c-api/typeobj.rst:255
msgid ":c:member:`~PyNumberMethods.nb_inplace_and`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_and`"

#: ../../c-api/typeobj.rst:255
msgid "__iand__"
msgstr "__iand__"

#: ../../c-api/typeobj.rst:257
msgid ":c:member:`~PyNumberMethods.nb_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_xor`"

#: ../../c-api/typeobj.rst:257
msgid "__xor__ __rxor__"
msgstr "__xor__ __rxor__"

#: ../../c-api/typeobj.rst:260
msgid ":c:member:`~PyNumberMethods.nb_inplace_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_xor`"

#: ../../c-api/typeobj.rst:260
msgid "__ixor__"
msgstr "__ixor__"

#: ../../c-api/typeobj.rst:262
msgid ":c:member:`~PyNumberMethods.nb_or`"
msgstr ":c:member:`~PyNumberMethods.nb_or`"

#: ../../c-api/typeobj.rst:262
msgid "__or__ __ror__"
msgstr "__or__ __ror__"

#: ../../c-api/typeobj.rst:265
msgid ":c:member:`~PyNumberMethods.nb_inplace_or`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_or`"

#: ../../c-api/typeobj.rst:265
msgid "__ior__"
msgstr "__ior__"

#: ../../c-api/typeobj.rst:267
msgid ":c:member:`~PyNumberMethods.nb_int`"
msgstr ":c:member:`~PyNumberMethods.nb_int`"

#: ../../c-api/typeobj.rst:267
msgid "__int__"
msgstr "__int__"

#: ../../c-api/typeobj.rst:269
msgid ":c:member:`~PyNumberMethods.nb_reserved`"
msgstr ":c:member:`~PyNumberMethods.nb_reserved`"

#: ../../c-api/typeobj.rst:269 ../../c-api/typeobj.rst:336
#: ../../c-api/typeobj.rst:338 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:419
msgid "void *"
msgstr "void *"

#: ../../c-api/typeobj.rst:271
msgid ":c:member:`~PyNumberMethods.nb_float`"
msgstr ":c:member:`~PyNumberMethods.nb_float`"

#: ../../c-api/typeobj.rst:271
msgid "__float__"
msgstr "__float__"

#: ../../c-api/typeobj.rst:273
msgid ":c:member:`~PyNumberMethods.nb_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_floor_divide`"

#: ../../c-api/typeobj.rst:273
msgid "__floordiv__"
msgstr "__floordiv__"

#: ../../c-api/typeobj.rst:275
msgid ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"

#: ../../c-api/typeobj.rst:275
msgid "__ifloordiv__"
msgstr "__ifloordiv__"

#: ../../c-api/typeobj.rst:277
msgid ":c:member:`~PyNumberMethods.nb_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_true_divide`"

#: ../../c-api/typeobj.rst:277
msgid "__truediv__"
msgstr "__truediv__"

#: ../../c-api/typeobj.rst:279
msgid ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"

#: ../../c-api/typeobj.rst:279
msgid "__itruediv__"
msgstr "__itruediv__"

#: ../../c-api/typeobj.rst:281
msgid ":c:member:`~PyNumberMethods.nb_index`"
msgstr ":c:member:`~PyNumberMethods.nb_index`"

#: ../../c-api/typeobj.rst:281
msgid "__index__"
msgstr "__index__"

#: ../../c-api/typeobj.rst:283
msgid ":c:member:`~PyNumberMethods.nb_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_matrix_multiply`"

#: ../../c-api/typeobj.rst:283
msgid "__matmul__ __rmatmul__"
msgstr "__matmul__ __rmatmul__"

#: ../../c-api/typeobj.rst:286
msgid ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"

#: ../../c-api/typeobj.rst:286
msgid "__imatmul__"
msgstr "__imatmul__"

#: ../../c-api/typeobj.rst:290
msgid ":c:member:`~PyMappingMethods.mp_length`"
msgstr ":c:member:`~PyMappingMethods.mp_length`"

#: ../../c-api/typeobj.rst:290 ../../c-api/typeobj.rst:299
#: ../../c-api/typeobj.rst:406
msgid ":c:type:`lenfunc`"
msgstr ":c:type:`lenfunc`"

#: ../../c-api/typeobj.rst:290 ../../c-api/typeobj.rst:299
msgid "__len__"
msgstr "__len__"

#: ../../c-api/typeobj.rst:292
msgid ":c:member:`~PyMappingMethods.mp_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_subscript`"

#: ../../c-api/typeobj.rst:292 ../../c-api/typeobj.rst:305
msgid "__getitem__"
msgstr "__getitem__"

#: ../../c-api/typeobj.rst:294
msgid ":c:member:`~PyMappingMethods.mp_ass_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_ass_subscript`"

#: ../../c-api/typeobj.rst:294 ../../c-api/typeobj.rst:451
msgid ":c:type:`objobjargproc`"
msgstr ":c:type:`objobjargproc`"

#: ../../c-api/typeobj.rst:294
msgid "__setitem__, __delitem__"
msgstr "__setitem__, __delitem__"

#: ../../c-api/typeobj.rst:299
msgid ":c:member:`~PySequenceMethods.sq_length`"
msgstr ":c:member:`~PySequenceMethods.sq_length`"

#: ../../c-api/typeobj.rst:301
msgid ":c:member:`~PySequenceMethods.sq_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_concat`"

#: ../../c-api/typeobj.rst:301
msgid "__add__"
msgstr "__add__"

#: ../../c-api/typeobj.rst:303
msgid ":c:member:`~PySequenceMethods.sq_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_repeat`"

#: ../../c-api/typeobj.rst:303 ../../c-api/typeobj.rst:305
#: ../../c-api/typeobj.rst:314 ../../c-api/typeobj.rst:436
msgid ":c:type:`ssizeargfunc`"
msgstr ":c:type:`ssizeargfunc`"

#: ../../c-api/typeobj.rst:303
msgid "__mul__"
msgstr "__mul__"

#: ../../c-api/typeobj.rst:305
msgid ":c:member:`~PySequenceMethods.sq_item`"
msgstr ":c:member:`~PySequenceMethods.sq_item`"

#: ../../c-api/typeobj.rst:307
msgid ":c:member:`~PySequenceMethods.sq_ass_item`"
msgstr ":c:member:`~PySequenceMethods.sq_ass_item`"

#: ../../c-api/typeobj.rst:307 ../../c-api/typeobj.rst:441
msgid ":c:type:`ssizeobjargproc`"
msgstr ":c:type:`ssizeobjargproc`"

#: ../../c-api/typeobj.rst:307
msgid "__setitem__ __delitem__"
msgstr "__setitem__ __delitem__"

#: ../../c-api/typeobj.rst:310
msgid ":c:member:`~PySequenceMethods.sq_contains`"
msgstr ":c:member:`~PySequenceMethods.sq_contains`"

#: ../../c-api/typeobj.rst:310 ../../c-api/typeobj.rst:446
msgid ":c:type:`objobjproc`"
msgstr ":c:type:`objobjproc`"

#: ../../c-api/typeobj.rst:310
msgid "__contains__"
msgstr "__contains__"

#: ../../c-api/typeobj.rst:312
msgid ":c:member:`~PySequenceMethods.sq_inplace_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_concat`"

#: ../../c-api/typeobj.rst:314
msgid ":c:member:`~PySequenceMethods.sq_inplace_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_repeat`"

#: ../../c-api/typeobj.rst:318
msgid ":c:member:`~PyBufferProcs.bf_getbuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_getbuffer`"

#: ../../c-api/typeobj.rst:318
msgid ":c:func:`getbufferproc`"
msgstr ":c:func:`getbufferproc`"

#: ../../c-api/typeobj.rst:320
msgid ":c:member:`~PyBufferProcs.bf_releasebuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_releasebuffer`"

#: ../../c-api/typeobj.rst:320
msgid ":c:func:`releasebufferproc`"
msgstr ":c:func:`releasebufferproc`"

#: ../../c-api/typeobj.rst:326
msgid "slot typedefs"
msgstr "типи слотів"

#: ../../c-api/typeobj.rst:329
msgid "typedef"
msgstr "typedef"

#: ../../c-api/typeobj.rst:329
msgid "Parameter Types"
msgstr "Типи параметрів"

#: ../../c-api/typeobj.rst:329
msgid "Return Type"
msgstr "Тип повернення"

#: ../../c-api/typeobj.rst:336 ../../c-api/typeobj.rst:338
#: ../../c-api/typeobj.rst:414
msgid "void"
msgstr "void"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`visitproc`"
msgstr ":c:type:`visitproc`"

#: ../../c-api/typeobj.rst:340 ../../c-api/typeobj.rst:352
#: ../../c-api/typeobj.rst:365 ../../c-api/typeobj.rst:376
#: ../../c-api/typeobj.rst:388 ../../c-api/typeobj.rst:0
#: ../../c-api/typeobj.rst:408 ../../c-api/typeobj.rst:419
#: ../../c-api/typeobj.rst:441 ../../c-api/typeobj.rst:446
#: ../../c-api/typeobj.rst:451
msgid "int"
msgstr "int"

#: ../../c-api/typeobj.rst:394
msgid "Py_hash_t"
msgstr "Py_hash_t"

#: ../../c-api/typeobj.rst:408
msgid ":c:type:`getbufferproc`"
msgstr ":c:type:`getbufferproc`"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`Py_buffer` *"
msgstr ":c:type:`Py_buffer` *"

#: ../../c-api/typeobj.rst:414
msgid ":c:type:`releasebufferproc`"
msgstr ":c:type:`releasebufferproc`"

#: ../../c-api/typeobj.rst:458
msgid "See :ref:`slot-typedefs` below for more detail."
msgstr "Дивіться :ref:`slot-typedefs` нижче, щоб дізнатися більше."

#: ../../c-api/typeobj.rst:462
msgid "PyTypeObject Definition"
msgstr "Визначення PyTypeObject"

#: ../../c-api/typeobj.rst:464
msgid ""
"The structure definition for :c:type:`PyTypeObject` can be found in :file:"
"`Include/object.h`.  For convenience of reference, this repeats the "
"definition found there:"
msgstr ""
"Визначення структури для :c:type:`PyTypeObject` можна знайти в :file:"
"`Include/object.h`. Для зручності посилання повторює наведене там визначення:"

#: ../../c-api/typeobj.rst:474
msgid "PyObject Slots"
msgstr "Слоти PyObject"

#: ../../c-api/typeobj.rst:476
msgid ""
"The type object structure extends the :c:type:`PyVarObject` structure. The :"
"attr:`ob_size` field is used for dynamic types (created by :func:`type_new`, "
"usually called from a class statement). Note that :c:data:`PyType_Type` (the "
"metatype) initializes :c:member:`~PyTypeObject.tp_itemsize`, which means "
"that its instances (i.e. type objects) *must* have the :attr:`ob_size` field."
msgstr ""
"Структура об’єкта типу розширює структуру :c:type:`PyVarObject`. Поле :attr:"
"`ob_size` використовується для динамічних типів (створених :func:`type_new`, "
"які зазвичай викликаються з оператора класу). Зауважте, що :c:data:"
"`PyType_Type` (метатип) ініціалізує :c:member:`~PyTypeObject.tp_itemsize`, "
"що означає, що його екземпляри (тобто об’єкти типу) *мають* мати поле :attr:"
"`ob_size`."

#: ../../c-api/typeobj.rst:486
msgid ""
"These fields are only present when the macro ``Py_TRACE_REFS`` is defined. "
"Their initialization to ``NULL`` is taken care of by the "
"``PyObject_HEAD_INIT`` macro.  For statically allocated objects, these "
"fields always remain ``NULL``. For dynamically allocated objects, these two "
"fields are used to link the object into a doubly-linked list of *all* live "
"objects on the heap.  This could be used for various debugging purposes; "
"currently the only use is to print the objects that are still alive at the "
"end of a run when the environment variable :envvar:`PYTHONDUMPREFS` is set."
msgstr ""

#: ../../c-api/typeobj.rst:495 ../../c-api/typeobj.rst:508
#: ../../c-api/typeobj.rst:531 ../../c-api/typeobj.rst:544
#: ../../c-api/typeobj.rst:586 ../../c-api/typeobj.rst:629
#: ../../c-api/typeobj.rst:687 ../../c-api/typeobj.rst:731
#: ../../c-api/typeobj.rst:750 ../../c-api/typeobj.rst:767
#: ../../c-api/typeobj.rst:785 ../../c-api/typeobj.rst:809
#: ../../c-api/typeobj.rst:826 ../../c-api/typeobj.rst:838
#: ../../c-api/typeobj.rst:850 ../../c-api/typeobj.rst:883
#: ../../c-api/typeobj.rst:901 ../../c-api/typeobj.rst:921
#: ../../c-api/typeobj.rst:942 ../../c-api/typeobj.rst:968
#: ../../c-api/typeobj.rst:987 ../../c-api/typeobj.rst:1003
#: ../../c-api/typeobj.rst:1040 ../../c-api/typeobj.rst:1051
#: ../../c-api/typeobj.rst:1061 ../../c-api/typeobj.rst:1071
#: ../../c-api/typeobj.rst:1085 ../../c-api/typeobj.rst:1104
#: ../../c-api/typeobj.rst:1127 ../../c-api/typeobj.rst:1174
#: ../../c-api/typeobj.rst:1189 ../../c-api/typeobj.rst:1257
#: ../../c-api/typeobj.rst:1324 ../../c-api/typeobj.rst:1383
#: ../../c-api/typeobj.rst:1413 ../../c-api/typeobj.rst:1445
#: ../../c-api/typeobj.rst:1468 ../../c-api/typeobj.rst:1481
#: ../../c-api/typeobj.rst:1496 ../../c-api/typeobj.rst:1510
#: ../../c-api/typeobj.rst:1540 ../../c-api/typeobj.rst:1560
#: ../../c-api/typeobj.rst:1586 ../../c-api/typeobj.rst:1604
#: ../../c-api/typeobj.rst:1644 ../../c-api/typeobj.rst:1695
#: ../../c-api/typeobj.rst:1712 ../../c-api/typeobj.rst:1750
#: ../../c-api/typeobj.rst:1771 ../../c-api/typeobj.rst:1803
#: ../../c-api/typeobj.rst:1820 ../../c-api/typeobj.rst:1831
#: ../../c-api/typeobj.rst:1841 ../../c-api/typeobj.rst:1850
#: ../../c-api/typeobj.rst:1860 ../../c-api/typeobj.rst:1874
#: ../../c-api/typeobj.rst:1923 ../../c-api/typeobj.rst:1940
msgid "**Inheritance:**"
msgstr "**Pewarisan:**"

#: ../../c-api/typeobj.rst:497
msgid "These fields are not inherited by subtypes."
msgstr "Ці поля не успадковуються підтипами."

#: ../../c-api/typeobj.rst:502
msgid ""
"This is the type object's reference count, initialized to ``1`` by the "
"``PyObject_HEAD_INIT`` macro.  Note that for statically allocated type "
"objects, the type's instances (objects whose :attr:`ob_type` points back to "
"the type) do *not* count as references.  But for dynamically allocated type "
"objects, the instances *do* count as references."
msgstr ""

#: ../../c-api/typeobj.rst:510 ../../c-api/typeobj.rst:546
#: ../../c-api/typeobj.rst:588
msgid "This field is not inherited by subtypes."
msgstr "*field* ini tidak diwariskan oleh subtipe."

#: ../../c-api/typeobj.rst:515
msgid ""
"This is the type's type, in other words its metatype.  It is initialized by "
"the argument to the ``PyObject_HEAD_INIT`` macro, and its value should "
"normally be ``&PyType_Type``.  However, for dynamically loadable extension "
"modules that must be usable on Windows (at least), the compiler complains "
"that this is not a valid initializer.  Therefore, the convention is to pass "
"``NULL`` to the ``PyObject_HEAD_INIT`` macro and to initialize this field "
"explicitly at the start of the module's initialization function, before "
"doing anything else.  This is typically done like this::"
msgstr ""
"Це тип типу, іншими словами його метатип. Він ініціалізується аргументом "
"макросу ``PyObject_HEAD_INIT``, і його значення зазвичай має бути "
"``&PyType_Type``. Однак для динамічно завантажуваних модулів розширення, які "
"повинні використовуватися в Windows (принаймні), компілятор скаржиться, що "
"це недійсний ініціалізатор. Таким чином, прийнято передавати ``NULL`` в "
"макрос ``PyObject_HEAD_INIT`` і ініціалізувати це поле явно на початку "
"функції ініціалізації модуля, перш ніж робити будь-що інше. Зазвичай це "
"робиться так:"

#: ../../c-api/typeobj.rst:526
msgid ""
"This should be done before any instances of the type are created. :c:func:"
"`PyType_Ready` checks if :attr:`ob_type` is ``NULL``, and if so, initializes "
"it to the :attr:`ob_type` field of the base class. :c:func:`PyType_Ready` "
"will not change this field if it is non-zero."
msgstr ""
"Це слід зробити до того, як будуть створені будь-які екземпляри типу. :c:"
"func:`PyType_Ready` перевіряє, чи :attr:`ob_type` має значення ``NULL``, і "
"якщо так, ініціалізує його полем :attr:`ob_type` базового класу. :c:func:"
"`PyType_Ready` не змінить це поле, якщо воно відмінне від нуля."

#: ../../c-api/typeobj.rst:533 ../../c-api/typeobj.rst:689
#: ../../c-api/typeobj.rst:811 ../../c-api/typeobj.rst:903
#: ../../c-api/typeobj.rst:923 ../../c-api/typeobj.rst:1447
#: ../../c-api/typeobj.rst:1470 ../../c-api/typeobj.rst:1588
#: ../../c-api/typeobj.rst:1606 ../../c-api/typeobj.rst:1697
#: ../../c-api/typeobj.rst:1805 ../../c-api/typeobj.rst:1925
msgid "This field is inherited by subtypes."
msgstr "*field* ini diwariskan oleh subtipe."

#: ../../c-api/typeobj.rst:537
msgid "PyVarObject Slots"
msgstr "Слоти PyVarObject"

#: ../../c-api/typeobj.rst:541
msgid ""
"For statically allocated type objects, this should be initialized to zero.  "
"For dynamically allocated type objects, this field has a special internal "
"meaning."
msgstr ""

#: ../../c-api/typeobj.rst:550
msgid "PyTypeObject Slots"
msgstr "Слоти PyTypeObject"

#: ../../c-api/typeobj.rst:552
msgid ""
"Each slot has a section describing inheritance.  If :c:func:`PyType_Ready` "
"may set a value when the field is set to ``NULL`` then there will also be a "
"\"Default\" section.  (Note that many fields set on :c:type:"
"`PyBaseObject_Type` and :c:type:`PyType_Type` effectively act as defaults.)"
msgstr ""
"Кожен слот має розділ, що описує успадкування. Якщо :c:func:`PyType_Ready` "
"може встановити значення, коли для поля встановлено значення ``NULL``, тоді "
"також буде розділ \"За замовчуванням\". (Зверніть увагу, що багато полів, "
"установлених у :c:type:`PyBaseObject_Type` і :c:type:`PyType_Type`, фактично "
"діють як значення за замовчуванням.)"

#: ../../c-api/typeobj.rst:559
msgid ""
"Pointer to a NUL-terminated string containing the name of the type. For "
"types that are accessible as module globals, the string should be the full "
"module name, followed by a dot, followed by the type name; for built-in "
"types, it should be just the type name.  If the module is a submodule of a "
"package, the full package name is part of the full module name.  For "
"example, a type named :class:`T` defined in module :mod:`M` in subpackage :"
"mod:`Q` in package :mod:`P` should have the :c:member:`~PyTypeObject."
"tp_name` initializer ``\"P.Q.M.T\"``."
msgstr ""
"Покажчик на рядок із закінченням NUL, що містить назву типу. Для типів, які "
"доступні як глобальні модулі, рядок має бути повним ім’ям модуля, за яким "
"слідує крапка та ім’я типу; для вбудованих типів це має бути лише назва "
"типу. Якщо модуль є підмодулем пакета, повна назва пакета є частиною повної "
"назви модуля. Наприклад, тип із назвою :class:`T`, визначений у модулі :mod:"
"`M` у вкладеному пакеті :mod:`Q` у пакеті :mod:`P`, повинен мати :c:member:"
"`~PyTypeObject.tp_name` ініціалізатор ``\"P.Q.M.T\"``."

#: ../../c-api/typeobj.rst:567
msgid ""
"For dynamically allocated type objects, this should just be the type name, "
"and the module name explicitly stored in the type dict as the value for key "
"``'__module__'``."
msgstr ""

#: ../../c-api/typeobj.rst:571
msgid ""
"For statically allocated type objects, the tp_name field should contain a "
"dot. Everything before the last dot is made accessible as the :attr:"
"`__module__` attribute, and everything after the last dot is made accessible "
"as the :attr:`~definition.__name__` attribute."
msgstr ""

#: ../../c-api/typeobj.rst:576
msgid ""
"If no dot is present, the entire :c:member:`~PyTypeObject.tp_name` field is "
"made accessible as the :attr:`~definition.__name__` attribute, and the :attr:"
"`__module__` attribute is undefined (unless explicitly set in the "
"dictionary, as explained above).  This means your type will be impossible to "
"pickle.  Additionally, it will not be listed in module documentations "
"created with pydoc."
msgstr ""
"Якщо крапка відсутня, усе поле :c:member:`~PyTypeObject.tp_name` стає "
"доступним як атрибут :attr:`~definition.__name__`, а атрибут :attr:"
"`__module__` не визначено (якщо це не зазначено явно). набір у словнику, як "
"пояснено вище). Це означає, що ваш тип буде неможливо замаринувати. Крім "
"того, він не буде вказаний у документації модуля, створеній за допомогою "
"pydoc."

#: ../../c-api/typeobj.rst:582
msgid ""
"This field must not be ``NULL``.  It is the only required field in :c:func:"
"`PyTypeObject` (other than potentially :c:member:`~PyTypeObject."
"tp_itemsize`)."
msgstr ""
"Це поле не має бути ``NULL``. Це єдине обов’язкове поле в :c:func:"
"`PyTypeObject` (окрім потенційно :c:member:`~PyTypeObject.tp_itemsize`)."

#: ../../c-api/typeobj.rst:594
msgid ""
"These fields allow calculating the size in bytes of instances of the type."
msgstr "Ці поля дозволяють обчислити розмір екземплярів типу в байтах."

#: ../../c-api/typeobj.rst:596
msgid ""
"There are two kinds of types: types with fixed-length instances have a zero :"
"c:member:`~PyTypeObject.tp_itemsize` field, types with variable-length "
"instances have a non-zero :c:member:`~PyTypeObject.tp_itemsize` field.  For "
"a type with fixed-length instances, all instances have the same size, given "
"in :c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"Існує два види типів: типи з екземплярами фіксованої довжини мають нульове "
"поле :c:member:`~PyTypeObject.tp_itemsize`, типи з екземплярами змінної "
"довжини мають ненульове поле :c:member:`~PyTypeObject.tp_itemsize` поле. Для "
"типу з екземплярами фіксованої довжини всі екземпляри мають однаковий "
"розмір, указаний у :c:member:`~PyTypeObject.tp_basicsize`."

#: ../../c-api/typeobj.rst:601
msgid ""
"For a type with variable-length instances, the instances must have an :attr:"
"`ob_size` field, and the instance size is :c:member:`~PyTypeObject."
"tp_basicsize` plus N times :c:member:`~PyTypeObject.tp_itemsize`, where N is "
"the \"length\" of the object.  The value of N is typically stored in the "
"instance's :attr:`ob_size` field.  There are exceptions:  for example, ints "
"use a negative :attr:`ob_size` to indicate a negative number, and N is "
"``abs(ob_size)`` there.  Also, the presence of an :attr:`ob_size` field in "
"the instance layout doesn't mean that the instance structure is variable-"
"length (for example, the structure for the list type has fixed-length "
"instances, yet those instances have a meaningful :attr:`ob_size` field)."
msgstr ""
"Для типу з примірниками змінної довжини примірники повинні мати поле :attr:"
"`ob_size`, а розмір примірника становить :c:member:`~PyTypeObject."
"tp_basicsize` плюс N разів :c:member:`~PyTypeObject. tp_itemsize`, де N — "
"\"довжина\" об’єкта. Значення N зазвичай зберігається в полі екземпляра :"
"attr:`ob_size`. Бувають винятки: наприклад, int використовує від'ємний :attr:"
"`ob_size` для позначення від’ємного числа, а N є ``abs(ob_size)``. Крім "
"того, наявність поля :attr:`ob_size` у макеті екземпляра не означає, що "
"структура екземпляра має змінну довжину (наприклад, структура для типу "
"списку має екземпляри фіксованої довжини, але ці екземпляри мають значуще "
"поле :attr:`ob_size`)."

#: ../../c-api/typeobj.rst:612
msgid ""
"The basic size includes the fields in the instance declared by the macro :c:"
"macro:`PyObject_HEAD` or :c:macro:`PyObject_VAR_HEAD` (whichever is used to "
"declare the instance struct) and this in turn includes the :attr:`_ob_prev` "
"and :attr:`_ob_next` fields if they are present.  This means that the only "
"correct way to get an initializer for the :c:member:`~PyTypeObject."
"tp_basicsize` is to use the ``sizeof`` operator on the struct used to "
"declare the instance layout. The basic size does not include the GC header "
"size."
msgstr ""
"Базовий розмір включає поля в екземплярі, оголошеному макросом :c:macro:"
"`PyObject_HEAD` або :c:macro:`PyObject_VAR_HEAD` (залежно від того, який "
"використовується для оголошення структури екземпляра), а це, у свою чергу, "
"включає :attr:`Поля _ob_prev` і :attr:`_ob_next`, якщо вони присутні. Це "
"означає, що єдиний правильний спосіб отримати ініціалізатор для :c:member:"
"`~PyTypeObject.tp_basicsize` — це використання оператора ``sizeof`` у "
"структурі, яка використовується для оголошення макета екземпляра. Базовий "
"розмір не включає розмір заголовка GC."

#: ../../c-api/typeobj.rst:620
msgid ""
"A note about alignment: if the variable items require a particular "
"alignment, this should be taken care of by the value of :c:member:"
"`~PyTypeObject.tp_basicsize`.  Example: suppose a type implements an array "
"of ``double``. :c:member:`~PyTypeObject.tp_itemsize` is ``sizeof(double)``. "
"It is the programmer's responsibility that :c:member:`~PyTypeObject."
"tp_basicsize` is a multiple of ``sizeof(double)`` (assuming this is the "
"alignment requirement for ``double``)."
msgstr ""
"Примітка щодо вирівнювання: якщо елементи змінної потребують особливого "
"вирівнювання, про це слід подбати за допомогою значення :c:member:"
"`~PyTypeObject.tp_basicsize`. Приклад: припустимо, що тип реалізує масив "
"``double``. :c:member:`~PyTypeObject.tp_itemsize` — це ``sizeof(double)``. "
"Програміст відповідає за те, щоб :c:member:`~PyTypeObject.tp_basicsize` був "
"кратним ``sizeof(double)`` (припускаючи, що це вимога вирівнювання для "
"``double``)."

#: ../../c-api/typeobj.rst:627
msgid ""
"For any type with variable-length instances, this field must not be ``NULL``."
msgstr ""
"Для будь-якого типу з екземплярами змінної довжини це поле не має бути "
"``NULL``."

#: ../../c-api/typeobj.rst:631
msgid ""
"These fields are inherited separately by subtypes.  If the base type has a "
"non-zero :c:member:`~PyTypeObject.tp_itemsize`, it is generally not safe to "
"set :c:member:`~PyTypeObject.tp_itemsize` to a different non-zero value in a "
"subtype (though this depends on the implementation of the base type)."
msgstr ""
"Ці поля успадковуються окремо за підтипами. Якщо базовий тип має ненульовий :"
"c:member:`~PyTypeObject.tp_itemsize`, зазвичай небезпечно встановлювати :c:"
"member:`~PyTypeObject.tp_itemsize` інше ненульове значення в підтипі ( хоча "
"це залежить від реалізації базового типу)."

#: ../../c-api/typeobj.rst:639
msgid ""
"A pointer to the instance destructor function.  This function must be "
"defined unless the type guarantees that its instances will never be "
"deallocated (as is the case for the singletons ``None`` and ``Ellipsis``).  "
"The function signature is::"
msgstr ""
"Покажчик на функцію деструктора екземпляра. Ця функція має бути визначена, "
"якщо тип не гарантує, що її екземпляри ніколи не будуть звільнені (як у "
"випадку сінгтонів ``None`` і ``Ellipsis``). Сигнатура функції:"

#: ../../c-api/typeobj.rst:645
msgid ""
"The destructor function is called by the :c:func:`Py_DECREF` and :c:func:"
"`Py_XDECREF` macros when the new reference count is zero.  At this point, "
"the instance is still in existence, but there are no references to it.  The "
"destructor function should free all references which the instance owns, free "
"all memory buffers owned by the instance (using the freeing function "
"corresponding to the allocation function used to allocate the buffer), and "
"call the type's :c:member:`~PyTypeObject.tp_free` function.  If the type is "
"not subtypable (doesn't have the :const:`Py_TPFLAGS_BASETYPE` flag bit set), "
"it is permissible to call the object deallocator directly instead of via :c:"
"member:`~PyTypeObject.tp_free`.  The object deallocator should be the one "
"used to allocate the instance; this is normally :c:func:`PyObject_Del` if "
"the instance was allocated using :c:func:`PyObject_New` or :c:func:"
"`PyObject_VarNew`, or :c:func:`PyObject_GC_Del` if the instance was "
"allocated using :c:func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar`."
msgstr ""
"Функція деструктора викликається макросами :c:func:`Py_DECREF` і :c:func:"
"`Py_XDECREF`, коли кількість нових посилань дорівнює нулю. На даний момент "
"екземпляр все ще існує, але на нього немає посилань. Функція деструктора "
"повинна звільнити всі посилання, якими володіє екземпляр, звільнити всі "
"буфери пам’яті, якими володіє екземпляр (за допомогою функції звільнення, що "
"відповідає функції розподілу, що використовується для виділення буфера), і "
"викликати тип :c:member:`~PyTypeObject.tp_free`. Якщо тип не можна "
"підтипувати (не має встановленого біта прапора :const:"
"`Py_TPFLAGS_BASETYPE`), дозволено викликати засіб усунення об’єктів "
"безпосередньо, а не через :c:member:`~PyTypeObject.tp_free`. Розділювач "
"об’єктів має бути тим, який використовується для виділення примірника; "
"зазвичай це :c:func:`PyObject_Del`, якщо екземпляр було виділено за "
"допомогою :c:func:`PyObject_New` або :c:func:`PyObject_VarNew`, або :c:func:"
"`PyObject_GC_Del`, якщо екземпляр було виділено за допомогою :c:func:"
"`PyObject_GC_New` або :c:func:`PyObject_GC_NewVar`."

#: ../../c-api/typeobj.rst:660
msgid ""
"If the type supports garbage collection (has the :const:`Py_TPFLAGS_HAVE_GC` "
"flag bit set), the destructor should call :c:func:`PyObject_GC_UnTrack` "
"before clearing any member fields."
msgstr ""
"Якщо тип підтримує збирання сміття (має встановлений біт прапора :const:"
"`Py_TPFLAGS_HAVE_GC`), деструктор повинен викликати :c:func:"
"`PyObject_GC_UnTrack` перед очищенням будь-яких полів-членів."

#: ../../c-api/typeobj.rst:672
msgid ""
"Finally, if the type is heap allocated (:const:`Py_TPFLAGS_HEAPTYPE`), the "
"deallocator should decrement the reference count for its type object after "
"calling the type deallocator. In order to avoid dangling pointers, the "
"recommended way to achieve this is:"
msgstr ""

#: ../../c-api/typeobj.rst:694
msgid ""
"An optional offset to a per-instance function that implements calling the "
"object using the :ref:`vectorcall protocol <vectorcall>`, a more efficient "
"alternative of the simpler :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"Необов’язкове зміщення функції для кожного екземпляра, яка реалізує виклик "
"об’єкта за допомогою :ref:`vectorcall протоколу <vectorcall>`, більш "
"ефективної альтернативи простішого :c:member:`~PyTypeObject.tp_call`."

#: ../../c-api/typeobj.rst:699
msgid ""
"This field is only used if the flag :const:`Py_TPFLAGS_HAVE_VECTORCALL` is "
"set. If so, this must be a positive integer containing the offset in the "
"instance of a :c:type:`vectorcallfunc` pointer."
msgstr ""
"Це поле використовується, лише якщо встановлено прапорець :const:"
"`Py_TPFLAGS_HAVE_VECTORCALL`. Якщо так, це має бути додатне ціле число, що "
"містить зміщення в екземплярі покажчика :c:type:`vectorcallfunc`."

#: ../../c-api/typeobj.rst:703
msgid ""
"The *vectorcallfunc* pointer may be ``NULL``, in which case the instance "
"behaves as if :const:`Py_TPFLAGS_HAVE_VECTORCALL` was not set: calling the "
"instance falls back to :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"Покажчик *vectorcallfunc* може бути ``NULL``, у цьому випадку примірник "
"поводиться так, ніби :const:`Py_TPFLAGS_HAVE_VECTORCALL` не було "
"встановлено: виклик примірника повертається до :c:member:`~PyTypeObject."
"tp_call`."

#: ../../c-api/typeobj.rst:707
msgid ""
"Any class that sets ``Py_TPFLAGS_HAVE_VECTORCALL`` must also set :c:member:"
"`~PyTypeObject.tp_call` and make sure its behaviour is consistent with the "
"*vectorcallfunc* function. This can be done by setting *tp_call* to :c:func:"
"`PyVectorcall_Call`."
msgstr ""
"Будь-який клас, який встановлює ``Py_TPFLAGS_HAVE_VECTORCALL``, також "
"повинен встановити :c:member:`~PyTypeObject.tp_call` і переконатися, що його "
"поведінка узгоджується з функцією *vectorcallfunc*. Це можна зробити, "
"встановивши *tp_call* на :c:func:`PyVectorcall_Call`."

#: ../../c-api/typeobj.rst:714
msgid ""
"It is not recommended for :ref:`heap types <heap-types>` to implement the "
"vectorcall protocol. When a user sets :attr:`__call__` in Python code, only "
"*tp_call* is updated, likely making it inconsistent with the vectorcall "
"function."
msgstr ""
"No se recomienda que :ref:`heap types <heap-types>` implemente el protocolo "
"vectorcall. Cuando un usuario establece :attr:`__call__` en código Python, "
"sólo se actualiza *tp_call*, lo que probablemente lo hace inconsistente con "
"la función vectorcall."

#: ../../c-api/typeobj.rst:721
msgid ""
"The semantics of the ``tp_vectorcall_offset`` slot are provisional and "
"expected to be finalized in Python 3.9. If you use vectorcall, plan for "
"updating your code for Python 3.9."
msgstr ""

#: ../../c-api/typeobj.rst:727
msgid ""
"Before version 3.8, this slot was named ``tp_print``. In Python 2.x, it was "
"used for printing to a file. In Python 3.0 to 3.7, it was unused."
msgstr ""
"До версії 3.8 цей слот мав назву ``tp_print``. У Python 2.x він "
"використовувався для друку у файл. У Python від 3.0 до 3.7 він не "
"використовувався."

#: ../../c-api/typeobj.rst:733
msgid ""
"This field is always inherited. However, the :const:"
"`Py_TPFLAGS_HAVE_VECTORCALL` flag is not always inherited. If it's not, then "
"the subclass won't use :ref:`vectorcall <vectorcall>`, except when :c:func:"
"`PyVectorcall_Call` is explicitly called. This is in particular the case for "
"`heap types`_ (including subclasses defined in Python)."
msgstr ""

#: ../../c-api/typeobj.rst:744
msgid "An optional pointer to the get-attribute-string function."
msgstr "Додатковий покажчик на функцію get-attribute-string."

#: ../../c-api/typeobj.rst:746
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_getattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Це поле застаріло. Коли його визначено, він має вказувати на функцію, яка "
"діє так само, як функція :c:member:`~PyTypeObject.tp_getattro`, але "
"використовує рядок C замість рядкового об’єкта Python, щоб надати назву "
"атрибуту."

#: ../../c-api/typeobj.rst:752 ../../c-api/typeobj.rst:944
msgid "Group: :attr:`tp_getattr`, :attr:`tp_getattro`"
msgstr "Група: :attr:`tp_getattr`, :attr:`tp_getattro`"

#: ../../c-api/typeobj.rst:754
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"Це поле успадковується підтипами разом із :c:member:`~PyTypeObject."
"tp_getattro`: підтип успадковує і :c:member:`~PyTypeObject.tp_getattr`, і :c:"
"member:`~PyTypeObject.tp_getattro` від своєї основи типу, коли підтипи :c:"
"member:`~PyTypeObject.tp_getattr` і :c:member:`~PyTypeObject.tp_getattro` "
"мають значення ``NULL``."

#: ../../c-api/typeobj.rst:761 ../../c-api/typeobj.rst:957
msgid ""
"An optional pointer to the function for setting and deleting attributes."
msgstr ""
"Додатковий вказівник на функцію для налаштування та видалення атрибутів."

#: ../../c-api/typeobj.rst:763
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_setattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Це поле застаріло. Коли його визначено, він має вказувати на функцію, яка "
"діє так само, як функція :c:member:`~PyTypeObject.tp_setattro`, але "
"використовує рядок C замість рядкового об’єкта Python, щоб надати назву "
"атрибуту."

#: ../../c-api/typeobj.rst:769 ../../c-api/typeobj.rst:970
msgid "Group: :attr:`tp_setattr`, :attr:`tp_setattro`"
msgstr "Група: :attr:`tp_setattr`, :attr:`tp_setattro`"

#: ../../c-api/typeobj.rst:771
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"Це поле успадковується підтипами разом із :c:member:`~PyTypeObject."
"tp_setattro`: підтип успадковує і :c:member:`~PyTypeObject.tp_setattr`, і :c:"
"member:`~PyTypeObject.tp_setattro` від своєї основи типу, коли підтипи :c:"
"member:`~PyTypeObject.tp_setattr` і :c:member:`~PyTypeObject.tp_setattro` "
"мають значення ``NULL``."

#: ../../c-api/typeobj.rst:778
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement :term:`awaitable` and :term:`asynchronous iterator` "
"protocols at the C-level.  See :ref:`async-structs` for details."
msgstr ""
"Покажчик на додаткову структуру, яка містить поля, що стосуються лише "
"об’єктів, які реалізують протоколи :term:`awaitable` і :term:`asynchronous "
"iterator` на рівні C. Дивіться :ref:`async-structs` для деталей."

#: ../../c-api/typeobj.rst:782
msgid "Formerly known as ``tp_compare`` and ``tp_reserved``."
msgstr "Раніше відомий як ``tp_compare`` і ``tp_reserved``."

#: ../../c-api/typeobj.rst:787
msgid ""
"The :c:member:`~PyTypeObject.tp_as_async` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Поле :c:member:`~PyTypeObject.tp_as_async` не успадковується, але поля, що "
"містяться, успадковуються окремо."

#: ../../c-api/typeobj.rst:795
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`repr`."
msgstr ""
"Додатковий покажчик на функцію, яка реалізує вбудовану функцію :func:`repr`."

#: ../../c-api/typeobj.rst:798
msgid "The signature is the same as for :c:func:`PyObject_Repr`::"
msgstr "Підпис такий самий, як і для :c:func:`PyObject_Repr`::"

#: ../../c-api/typeobj.rst:802
msgid ""
"The function must return a string or a Unicode object.  Ideally, this "
"function should return a string that, when passed to :func:`eval`, given a "
"suitable environment, returns an object with the same value.  If this is not "
"feasible, it should return a string starting with ``'<'`` and ending with "
"``'>'`` from which both the type and the value of the object can be deduced."
msgstr ""
"Функція має повертати рядок або об’єкт Unicode. В ідеалі ця функція має "
"повертати рядок, який, переданий до :func:`eval`, за відповідного середовища "
"повертає об’єкт із тим самим значенням. Якщо це неможливо, він повинен "
"повертати рядок, що починається з ``'<'`` та закінчується на ``'>'``, з "
"якого можна вивести як тип, так і значення об’єкта."

#: ../../c-api/typeobj.rst:813 ../../c-api/typeobj.rst:925
#: ../../c-api/typeobj.rst:950 ../../c-api/typeobj.rst:976
#: ../../c-api/typeobj.rst:1018 ../../c-api/typeobj.rst:1392
#: ../../c-api/typeobj.rst:1544 ../../c-api/typeobj.rst:1565
#: ../../c-api/typeobj.rst:1663 ../../c-api/typeobj.rst:1699
#: ../../c-api/typeobj.rst:1717 ../../c-api/typeobj.rst:1755
#: ../../c-api/typeobj.rst:1776 ../../c-api/typeobj.rst:1807
msgid "**Default:**"
msgstr "**Padrão:**"

#: ../../c-api/typeobj.rst:815
msgid ""
"When this field is not set, a string of the form ``<%s object at %p>`` is "
"returned, where ``%s`` is replaced by the type name, and ``%p`` by the "
"object's memory address."
msgstr ""
"Якщо це поле не встановлено, повертається рядок у формі ``<%s object at "
"%p>``, де ``%s`` замінюється назвою типу, а ``%p`` адресою пам'яті об'єкта."

#: ../../c-api/typeobj.rst:822
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the number protocol.  These fields are documented "
"in :ref:`number-structs`."
msgstr ""
"Покажчик на додаткову структуру, яка містить поля, що стосуються лише "
"об’єктів, які реалізують протокол номерів. Ці поля задокументовані в :ref:"
"`number-structs`."

#: ../../c-api/typeobj.rst:828
msgid ""
"The :c:member:`~PyTypeObject.tp_as_number` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Поле :c:member:`~PyTypeObject.tp_as_number` не успадковується, але поля, що "
"містяться, успадковуються окремо."

#: ../../c-api/typeobj.rst:834
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the sequence protocol.  These fields are documented "
"in :ref:`sequence-structs`."
msgstr ""
"Покажчик на додаткову структуру, яка містить поля, що стосуються лише "
"об’єктів, які реалізують протокол послідовності. Ці поля задокументовані в :"
"ref:`sequence-structs`."

#: ../../c-api/typeobj.rst:840
msgid ""
"The :c:member:`~PyTypeObject.tp_as_sequence` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Поле :c:member:`~PyTypeObject.tp_as_sequence` не успадковується, але поля, "
"що містяться, успадковуються окремо."

#: ../../c-api/typeobj.rst:846
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the mapping protocol.  These fields are documented "
"in :ref:`mapping-structs`."
msgstr ""
"Покажчик на додаткову структуру, яка містить поля, що стосуються лише "
"об’єктів, які реалізують протокол відображення. Ці поля задокументовані в :"
"ref:`mapping-structs`."

#: ../../c-api/typeobj.rst:852
msgid ""
"The :c:member:`~PyTypeObject.tp_as_mapping` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Поле :c:member:`~PyTypeObject.tp_as_mapping` не успадковується, але поля, що "
"містяться, успадковуються окремо."

#: ../../c-api/typeobj.rst:860
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`hash`."
msgstr ""
"Додатковий покажчик на функцію, яка реалізує вбудовану функцію :func:`hash`."

#: ../../c-api/typeobj.rst:863
msgid "The signature is the same as for :c:func:`PyObject_Hash`::"
msgstr "Підпис такий самий, як і для :c:func:`PyObject_Hash`::"

#: ../../c-api/typeobj.rst:867
msgid ""
"The value ``-1`` should not be returned as a normal return value; when an "
"error occurs during the computation of the hash value, the function should "
"set an exception and return ``-1``."
msgstr ""
"Значення ``-1`` не повинно повертатися як звичайне значення, що "
"повертається; якщо під час обчислення хеш-значення виникає помилка, функція "
"повинна встановити виняток і повернути ``-1``."

#: ../../c-api/typeobj.rst:871
msgid ""
"When this field is not set (*and* :attr:`tp_richcompare` is not set), an "
"attempt to take the hash of the object raises :exc:`TypeError`. This is the "
"same as setting it to :c:func:`PyObject_HashNotImplemented`."
msgstr ""
"Якщо це поле не встановлено (*і* :attr:`tp_richcompare` не встановлено), "
"спроба отримати хеш об’єкта викликає :exc:`TypeError`. Це те саме, що "
"встановити значення :c:func:`PyObject_HashNotImplemented`."

#: ../../c-api/typeobj.rst:875
msgid ""
"This field can be set explicitly to :c:func:`PyObject_HashNotImplemented` to "
"block inheritance of the hash method from a parent type. This is interpreted "
"as the equivalent of ``__hash__ = None`` at the Python level, causing "
"``isinstance(o, collections.Hashable)`` to correctly return ``False``. Note "
"that the converse is also true - setting ``__hash__ = None`` on a class at "
"the Python level will result in the ``tp_hash`` slot being set to :c:func:"
"`PyObject_HashNotImplemented`."
msgstr ""
"У цьому полі можна явно встановити значення :c:func:"
"`PyObject_HashNotImplemented`, щоб заблокувати успадкування геш-методу від "
"батьківського типу. Це інтерпретується як еквівалент ``__hash__ = None`` на "
"рівні Python, змушуючи ``isinstance(o, collections.Hashable)`` правильно "
"повертати ``False``. Зауважте, що зворотне також вірно – встановлення "
"``__hash__ = None`` для класу на рівні Python призведе до того, що слот "
"``tp_hash`` буде встановлено на :c:func:`PyObject_HashNotImplemented`."

#: ../../c-api/typeobj.rst:885 ../../c-api/typeobj.rst:1385
msgid "Group: :attr:`tp_hash`, :attr:`tp_richcompare`"
msgstr "Група: :attr:`tp_hash`, :attr:`tp_richcompare`"

#: ../../c-api/typeobj.rst:887
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_richcompare`: a subtype inherits both of :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash`, when the subtype's :c:"
"member:`~PyTypeObject.tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` "
"are both ``NULL``."
msgstr ""
"Це поле успадковується підтипами разом із :c:member:`~PyTypeObject."
"tp_richcompare`: підтип успадковує як :c:member:`~PyTypeObject."
"tp_richcompare`, так і :c:member:`~PyTypeObject.tp_hash`, коли підтипи :c:"
"member:`~PyTypeObject.tp_richcompare` і :c:member:`~PyTypeObject.tp_hash` "
"мають значення ``NULL``."

#: ../../c-api/typeobj.rst:895
msgid ""
"An optional pointer to a function that implements calling the object.  This "
"should be ``NULL`` if the object is not callable.  The signature is the same "
"as for :c:func:`PyObject_Call`::"
msgstr ""
"Додатковий покажчик на функцію, яка реалізує виклик об’єкта. Це має бути "
"``NULL``, якщо об’єкт не можна викликати. Підпис такий самий, як і для :c:"
"func:`PyObject_Call`::"

#: ../../c-api/typeobj.rst:908
msgid ""
"An optional pointer to a function that implements the built-in operation :"
"func:`str`.  (Note that :class:`str` is a type now, and :func:`str` calls "
"the constructor for that type.  This constructor calls :c:func:"
"`PyObject_Str` to do the actual work, and :c:func:`PyObject_Str` will call "
"this handler.)"
msgstr ""
"Додатковий покажчик на функцію, яка реалізує вбудовану операцію :func:`str`. "
"(Зауважте, що :class:`str` тепер є типом, а :func:`str` викликає конструктор "
"для цього типу. Цей конструктор викликає :c:func:`PyObject_Str` для "
"виконання фактичної роботи, а :c:func:`PyObject_Str` викличе цей обробник.)"

#: ../../c-api/typeobj.rst:913
msgid "The signature is the same as for :c:func:`PyObject_Str`::"
msgstr "Підпис такий самий, як і для :c:func:`PyObject_Str`::"

#: ../../c-api/typeobj.rst:917
msgid ""
"The function must return a string or a Unicode object.  It should be a "
"\"friendly\" string representation of the object, as this is the "
"representation that will be used, among other things, by the :func:`print` "
"function."
msgstr ""
"Функція має повертати рядок або об’єкт Unicode. Це має бути \"дружнє\" "
"рядкове представлення об’єкта, оскільки це представлення буде "
"використовуватися, серед іншого, функцією :func:`print`."

#: ../../c-api/typeobj.rst:927
msgid ""
"When this field is not set, :c:func:`PyObject_Repr` is called to return a "
"string representation."
msgstr ""
"Якщо це поле не встановлено, :c:func:`PyObject_Repr` викликається для "
"повернення рядкового представлення."

#: ../../c-api/typeobj.rst:933
msgid "An optional pointer to the get-attribute function."
msgstr "Додатковий покажчик на функцію get-attribute."

#: ../../c-api/typeobj.rst:935
msgid "The signature is the same as for :c:func:`PyObject_GetAttr`::"
msgstr "Підпис такий самий, як і для :c:func:`PyObject_GetAttr`::"

#: ../../c-api/typeobj.rst:939
msgid ""
"It is usually convenient to set this field to :c:func:"
"`PyObject_GenericGetAttr`, which implements the normal way of looking for "
"object attributes."
msgstr ""
"Зазвичай зручно встановити для цього поля значення :c:func:"
"`PyObject_GenericGetAttr`, що реалізує звичайний спосіб пошуку атрибутів "
"об’єкта."

#: ../../c-api/typeobj.rst:946
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"Це поле успадковується підтипами разом із :c:member:`~PyTypeObject."
"tp_getattr`: підтип успадковує і :c:member:`~PyTypeObject.tp_getattr`, і :c:"
"member:`~PyTypeObject.tp_getattro` від своєї основи типу, коли підтипи :c:"
"member:`~PyTypeObject.tp_getattr` і :c:member:`~PyTypeObject.tp_getattro` "
"мають значення ``NULL``."

#: ../../c-api/typeobj.rst:952
msgid ":c:type:`PyBaseObject_Type` uses :c:func:`PyObject_GenericGetAttr`."
msgstr ""
":c:type:`PyBaseObject_Type` використовує :c:func:`PyObject_GenericGetAttr`."

#: ../../c-api/typeobj.rst:959
msgid "The signature is the same as for :c:func:`PyObject_SetAttr`::"
msgstr "Підпис такий самий, як і для :c:func:`PyObject_SetAttr`::"

#: ../../c-api/typeobj.rst:963
msgid ""
"In addition, setting *value* to ``NULL`` to delete an attribute must be "
"supported.  It is usually convenient to set this field to :c:func:"
"`PyObject_GenericSetAttr`, which implements the normal way of setting object "
"attributes."
msgstr ""
"Крім того, для видалення атрибута має підтримуватися встановлення *значення* "
"на ``NULL``. Зазвичай зручно встановити для цього поля значення :c:func:"
"`PyObject_GenericSetAttr`, що реалізує звичайний спосіб встановлення "
"атрибутів об’єкта."

#: ../../c-api/typeobj.rst:972
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"Це поле успадковується підтипами разом із :c:member:`~PyTypeObject."
"tp_setattr`: підтип успадковує і :c:member:`~PyTypeObject.tp_setattr`, і :c:"
"member:`~PyTypeObject.tp_setattro` від своєї основи типу, коли підтипи :c:"
"member:`~PyTypeObject.tp_setattr` і :c:member:`~PyTypeObject.tp_setattro` "
"мають значення ``NULL``."

#: ../../c-api/typeobj.rst:978
msgid ":c:type:`PyBaseObject_Type` uses :c:func:`PyObject_GenericSetAttr`."
msgstr ""
":c:type:`PyBaseObject_Type` використовує :c:func:`PyObject_GenericSetAttr`."

#: ../../c-api/typeobj.rst:983
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the buffer interface.  These fields are documented "
"in :ref:`buffer-structs`."
msgstr ""
"Покажчик на додаткову структуру, яка містить поля, що стосуються лише "
"об’єктів, які реалізують інтерфейс буфера. Ці поля задокументовані в :ref:"
"`buffer-structs`."

#: ../../c-api/typeobj.rst:989
msgid ""
"The :c:member:`~PyTypeObject.tp_as_buffer` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Поле :c:member:`~PyTypeObject.tp_as_buffer` не успадковується, але поля, що "
"містяться, успадковуються окремо."

#: ../../c-api/typeobj.rst:995
msgid ""
"This field is a bit mask of various flags.  Some flags indicate variant "
"semantics for certain situations; others are used to indicate that certain "
"fields in the type object (or in the extension structures referenced via :c:"
"member:`~PyTypeObject.tp_as_number`, :c:member:`~PyTypeObject."
"tp_as_sequence`, :c:member:`~PyTypeObject.tp_as_mapping`, and :c:member:"
"`~PyTypeObject.tp_as_buffer`) that were historically not always present are "
"valid; if such a flag bit is clear, the type fields it guards must not be "
"accessed and must be considered to have a zero or ``NULL`` value instead."
msgstr ""
"Це поле є бітовою маскою різних прапорів. Деякі прапорці вказують на "
"варіантну семантику для певних ситуацій; інші використовуються для вказівки, "
"що певні поля в об’єкті типу (або в структурах розширення, на які "
"посилаються через :c:member:`~PyTypeObject.tp_as_number`, :c:member:"
"`~PyTypeObject.tp_as_sequence`, :c:member:`~PyTypeObject.tp_as_mapping` і :c:"
"member:`~PyTypeObject.tp_as_buffer`), які історично не завжди були присутні, "
"є дійсними; якщо такий біт прапора очищений, до полів типу, які він "
"охороняє, не можна звертатися, і вони повинні вважатися такими, що мають "
"нульове або ``NULL`` значення."

#: ../../c-api/typeobj.rst:1005
msgid ""
"Inheritance of this field is complicated.  Most flag bits are inherited "
"individually, i.e. if the base type has a flag bit set, the subtype inherits "
"this flag bit.  The flag bits that pertain to extension structures are "
"strictly inherited if the extension structure is inherited, i.e. the base "
"type's value of the flag bit is copied into the subtype together with a "
"pointer to the extension structure.  The :const:`Py_TPFLAGS_HAVE_GC` flag "
"bit is inherited together with the :c:member:`~PyTypeObject.tp_traverse` "
"and :c:member:`~PyTypeObject.tp_clear` fields, i.e. if the :const:"
"`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :c:member:"
"`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` fields in "
"the subtype exist and have ``NULL`` values."
msgstr ""
"Успадкування цього поля складне. Більшість бітів прапора успадковуються "
"індивідуально, тобто якщо базовий тип має встановлений біт прапора, підтип "
"успадковує цей біт прапора. Біти прапорів, які відносяться до структур "
"розширення, суворо успадковуються, якщо успадковується структура розширення, "
"тобто значення біта прапора базового типу копіюється в підтип разом із "
"покажчиком на структуру розширення. Біт прапора :const:`Py_TPFLAGS_HAVE_GC` "
"успадковується разом із полями :c:member:`~PyTypeObject.tp_traverse` і :c:"
"member:`~PyTypeObject.tp_clear`, тобто якщо біт прапора :const:"
"`Py_TPFLAGS_HAVE_GC` є чистим у підтипі, а поля :c:member:`~PyTypeObject."
"tp_traverse` і :c:member:`~PyTypeObject.tp_clear` у підтипі існують і мають "
"значення ``NULL``."

#: ../../c-api/typeobj.rst:1020
msgid ""
":c:type:`PyBaseObject_Type` uses ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."
msgstr ""
":c:type:`PyBaseObject_Type` використовує ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."

#: ../../c-api/typeobj.rst:1023
msgid "**Bit Masks:**"
msgstr "**Bit Masks:**"

#: ../../c-api/typeobj.rst:1025
msgid ""
"The following bit masks are currently defined; these can be ORed together "
"using the ``|`` operator to form the value of the :c:member:`~PyTypeObject."
"tp_flags` field.  The macro :c:func:`PyType_HasFeature` takes a type and a "
"flags value, *tp* and *f*, and checks whether ``tp->tp_flags & f`` is non-"
"zero."
msgstr ""
"Наразі визначено такі бітові маски; їх можна об’єднати АБО за допомогою "
"оператора ``|``, щоб сформувати значення поля :c:member:`~PyTypeObject."
"tp_flags`. Макрос :c:func:`PyType_HasFeature` приймає тип і значення "
"прапорців, *tp* і *f*, і перевіряє, чи ``tp->tp_flags & f`` є відмінним від "
"нуля."

#: ../../c-api/typeobj.rst:1032
msgid ""
"This bit is set when the type object itself is allocated on the heap, for "
"example, types created dynamically using :c:func:`PyType_FromSpec`.  In this "
"case, the :attr:`ob_type` field of its instances is considered a reference "
"to the type, and the type object is INCREF'ed when a new instance is "
"created, and DECREF'ed when an instance is destroyed (this does not apply to "
"instances of subtypes; only the type referenced by the instance's ob_type "
"gets INCREF'ed or DECREF'ed)."
msgstr ""
"Цей біт встановлюється, коли сам об’єкт типу розміщується в купі, наприклад, "
"типи, створені динамічно за допомогою :c:func:`PyType_FromSpec`. У цьому "
"випадку поле :attr:`ob_type` його екземплярів вважається посиланням на тип, "
"а для об’єкта типу INCREF під час створення нового екземпляра та DECREF під "
"час знищення екземпляра (це робить не застосовуються до екземплярів "
"підтипів; лише тип, на який посилається ob_type екземпляра, отримує INCREF "
"або DECREF)."

#: ../../c-api/typeobj.rst:1042 ../../c-api/typeobj.rst:1053
#: ../../c-api/typeobj.rst:1063 ../../c-api/typeobj.rst:1073
#: ../../c-api/typeobj.rst:1106
msgid "???"
msgstr "???"

#: ../../c-api/typeobj.rst:1047
msgid ""
"This bit is set when the type can be used as the base type of another type.  "
"If this bit is clear, the type cannot be subtyped (similar to a \"final\" "
"class in Java)."
msgstr ""
"Цей біт встановлюється, коли тип можна використовувати як базовий тип іншого "
"типу. Якщо цей біт ясний, тип не може бути підтиповим (подібно до "
"\"фінального\" класу в Java)."

#: ../../c-api/typeobj.rst:1058
msgid ""
"This bit is set when the type object has been fully initialized by :c:func:"
"`PyType_Ready`."
msgstr ""
"Цей біт встановлюється, коли об’єкт типу повністю ініціалізовано :c:func:"
"`PyType_Ready`."

#: ../../c-api/typeobj.rst:1068
msgid ""
"This bit is set while :c:func:`PyType_Ready` is in the process of "
"initializing the type object."
msgstr ""
"Цей біт встановлюється, коли :c:func:`PyType_Ready` знаходиться в процесі "
"ініціалізації об’єкта типу."

#: ../../c-api/typeobj.rst:1078
msgid ""
"This bit is set when the object supports garbage collection.  If this bit is "
"set, instances must be created using :c:func:`PyObject_GC_New` and destroyed "
"using :c:func:`PyObject_GC_Del`.  More information in section :ref:"
"`supporting-cycle-detection`.  This bit also implies that the GC-related "
"fields :c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject."
"tp_clear` are present in the type object."
msgstr ""
"Цей біт встановлюється, якщо об’єкт підтримує збирання сміття. Якщо цей біт "
"установлено, екземпляри мають бути створені за допомогою :c:func:"
"`PyObject_GC_New` і знищені за допомогою :c:func:`PyObject_GC_Del`. Більше "
"інформації в розділі :ref:`supporting-cycle-detection`. Цей біт також "
"означає, що пов’язані з GC поля :c:member:`~PyTypeObject.tp_traverse` і :c:"
"member:`~PyTypeObject.tp_clear` присутні в об’єкті типу."

#: ../../c-api/typeobj.rst:1087 ../../c-api/typeobj.rst:1259
#: ../../c-api/typeobj.rst:1326
msgid ""
"Group: :const:`Py_TPFLAGS_HAVE_GC`, :attr:`tp_traverse`, :attr:`tp_clear`"
msgstr ""
"Група: :const:`Py_TPFLAGS_HAVE_GC`, :attr:`tp_traverse`, :attr:`tp_clear`"

#: ../../c-api/typeobj.rst:1089
msgid ""
"The :const:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the :"
"attr:`tp_traverse` and :attr:`tp_clear` fields, i.e.  if the :const:"
"`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :attr:"
"`tp_traverse` and :attr:`tp_clear` fields in the subtype exist and have "
"``NULL`` values."
msgstr ""
"Біт прапора :const:`Py_TPFLAGS_HAVE_GC` успадковується разом із полями :attr:"
"`tp_traverse` і :attr:`tp_clear`, тобто якщо біт прапора :const:"
"`Py_TPFLAGS_HAVE_GC` очищений у підтипі, а Поля :attr:`tp_traverse` і :attr:"
"`tp_clear` у підтипі існують і мають значення ``NULL``."

#: ../../c-api/typeobj.rst:1099
msgid ""
"This is a bitmask of all the bits that pertain to the existence of certain "
"fields in the type object and its extension structures. Currently, it "
"includes the following bits: :const:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`, :"
"const:`Py_TPFLAGS_HAVE_VERSION_TAG`."
msgstr ""

#: ../../c-api/typeobj.rst:1111
msgid "This bit indicates that objects behave like unbound methods."
msgstr "Цей біт вказує, що об’єкти поводяться як незв’язані методи."

#: ../../c-api/typeobj.rst:1113
msgid "If this flag is set for ``type(meth)``, then:"
msgstr "Якщо цей прапор встановлено для ``type(meth)``, тоді:"

#: ../../c-api/typeobj.rst:1115
msgid ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (with ``obj`` not None) must be "
"equivalent to ``meth(obj, *args, **kwds)``."
msgstr ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (з ``obj`` не None) має бути "
"еквівалентним ``meth(obj, *args, **kwds)``."

#: ../../c-api/typeobj.rst:1118
msgid ""
"``meth.__get__(None, cls)(*args, **kwds)`` must be equivalent to "
"``meth(*args, **kwds)``."
msgstr ""
"``meth.__get__(None, cls)(*args, **kwds)`` має бути еквівалентним "
"``meth(*args, **kwds)``."

#: ../../c-api/typeobj.rst:1121
msgid ""
"This flag enables an optimization for typical method calls like ``obj."
"meth()``: it avoids creating a temporary \"bound method\" object for ``obj."
"meth``."
msgstr ""
"Цей прапорець дає змогу оптимізувати типові виклики методів, як-от ``obj."
"meth()``: він уникає створення тимчасового об’єкта \"зв’язаного методу\" для "
"``obj.meth``."

#: ../../c-api/typeobj.rst:1129
msgid ""
"This flag is never inherited by heap types. For extension types, it is "
"inherited whenever :c:member:`~PyTypeObject.tp_descr_get` is inherited."
msgstr ""

#: ../../c-api/typeobj.rst:1146
msgid ""
"These flags are used by functions such as :c:func:`PyLong_Check` to quickly "
"determine if a type is a subclass of a built-in type; such specific checks "
"are faster than a generic check, like :c:func:`PyObject_IsInstance`. Custom "
"types that inherit from built-ins should have their :c:member:`~PyTypeObject."
"tp_flags` set appropriately, or the code that interacts with such types will "
"behave differently depending on what kind of check is used."
msgstr ""
"Ці позначки використовуються такими функціями, як :c:func:`PyLong_Check`, "
"щоб швидко визначити, чи є тип підкласом вбудованого типу; такі спеціальні "
"перевірки є швидшими, ніж загальні перевірки, наприклад :c:func:"
"`PyObject_IsInstance`. Користувальницькі типи, які успадковуються від "
"вбудованих, повинні мати належним чином встановлені :c:member:`~PyTypeObject."
"tp_flags`, інакше код, який взаємодіє з такими типами, поводитиметься по-"
"різному залежно від типу перевірки, що використовується."

#: ../../c-api/typeobj.rst:1157
msgid ""
"This bit is set when the :c:member:`~PyTypeObject.tp_finalize` slot is "
"present in the type structure."
msgstr ""
"Цей біт встановлюється, коли слот :c:member:`~PyTypeObject.tp_finalize` "
"присутній у структурі типу."

#: ../../c-api/typeobj.rst:1162
msgid ""
"This flag isn't necessary anymore, as the interpreter assumes the :c:member:"
"`~PyTypeObject.tp_finalize` slot is always present in the type structure."
msgstr ""
"Цей прапорець більше не потрібен, оскільки інтерпретатор припускає, що слот :"
"c:member:`~PyTypeObject.tp_finalize` завжди присутній у структурі типу."

#: ../../c-api/typeobj.rst:1170
msgid ""
"This bit is set when the class implements the :ref:`vectorcall protocol "
"<vectorcall>`. See :c:member:`~PyTypeObject.tp_vectorcall_offset` for "
"details."
msgstr ""
"Цей біт встановлюється, коли клас реалізує :ref:`vectorcall протокол "
"<vectorcall>`. Перегляньте :c:member:`~PyTypeObject.tp_vectorcall_offset` "
"для деталей."

#: ../../c-api/typeobj.rst:1176
msgid ""
"This bit is inherited for *static* subtypes if :c:member:`~PyTypeObject."
"tp_call` is also inherited. `Heap types`_ do not inherit "
"``Py_TPFLAGS_HAVE_VECTORCALL``."
msgstr ""

#: ../../c-api/typeobj.rst:1185
msgid ""
"An optional pointer to a NUL-terminated C string giving the docstring for "
"this type object.  This is exposed as the :attr:`__doc__` attribute on the "
"type and instances of the type."
msgstr ""
"Додатковий вказівник на рядок C із закінченням NUL, що дає рядок "
"документації для об’єкта цього типу. Це відображається як атрибут :attr:"
"`__doc__` для типу та екземплярів типу."

#: ../../c-api/typeobj.rst:1191
msgid "This field is *not* inherited by subtypes."
msgstr "*field* ini *tidak* diwariskan oleh subtipe."

#: ../../c-api/typeobj.rst:1196
msgid ""
"An optional pointer to a traversal function for the garbage collector.  This "
"is only used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""
"Додатковий покажчик на функцію обходу для збирача сміття. Це "
"використовується, лише якщо встановлено біт прапора :const:"
"`Py_TPFLAGS_HAVE_GC`. Підпис::"

#: ../../c-api/typeobj.rst:1201 ../../c-api/typeobj.rst:1321
msgid ""
"More information about Python's garbage collection scheme can be found in "
"section :ref:`supporting-cycle-detection`."
msgstr ""
"Більше інформації про схему збирання сміття Python можна знайти в розділі :"
"ref:`supporting-cycle-detection`."

#: ../../c-api/typeobj.rst:1204
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` pointer is used by the garbage "
"collector to detect reference cycles. A typical implementation of a :c:"
"member:`~PyTypeObject.tp_traverse` function simply calls :c:func:`Py_VISIT` "
"on each of the instance's members that are Python objects that the instance "
"owns. For example, this is function :c:func:`local_traverse` from the :mod:"
"`_thread` extension module::"
msgstr ""
"Покажчик :c:member:`~PyTypeObject.tp_traverse` використовується збирачем "
"сміття для виявлення опорних циклів. Типова реалізація функції :c:member:"
"`~PyTypeObject.tp_traverse` просто викликає :c:func:`Py_VISIT` для кожного з "
"членів примірника, які є об’єктами Python, якими володіє примірник. "
"Наприклад, це функція :c:func:`local_traverse` з модуля розширення :mod:"
"`_thread`::"

#: ../../c-api/typeobj.rst:1219
msgid ""
"Note that :c:func:`Py_VISIT` is called only on those members that can "
"participate in reference cycles.  Although there is also a ``self->key`` "
"member, it can only be ``NULL`` or a Python string and therefore cannot be "
"part of a reference cycle."
msgstr ""
"Зауважте, що :c:func:`Py_VISIT` викликається лише для тих членів, які можуть "
"брати участь у еталонних циклах. Хоча також є член ``self->key``, він може "
"бути лише ``NULL`` або рядком Python і тому не може бути частиною еталонного "
"циклу."

#: ../../c-api/typeobj.rst:1223
msgid ""
"On the other hand, even if you know a member can never be part of a cycle, "
"as a debugging aid you may want to visit it anyway just so the :mod:`gc` "
"module's :func:`~gc.get_referents` function will include it."
msgstr ""
"З іншого боку, навіть якщо ви знаєте, що член ніколи не може бути частиною "
"циклу, як допомога в налагодженні, ви можете все одно відвідати його, щоб "
"скористатися функцією :func:`~gc.get_referents` модуля :mod:`gc` буде "
"включати його."

#: ../../c-api/typeobj.rst:1228
msgid ""
"When implementing :c:member:`~PyTypeObject.tp_traverse`, only the members "
"that the instance *owns* (by having strong references to them) must be "
"visited. For instance, if an object supports weak references via the :c:"
"member:`~PyTypeObject.tp_weaklist` slot, the pointer supporting the linked "
"list (what *tp_weaklist* points to) must **not** be visited as the instance "
"does not directly own the weak references to itself (the weakreference list "
"is there to support the weak reference machinery, but the instance has no "
"strong reference to the elements inside it, as they are allowed to be "
"removed even if the instance is still alive)."
msgstr ""

#: ../../c-api/typeobj.rst:1238
msgid ""
"Note that :c:func:`Py_VISIT` requires the *visit* and *arg* parameters to :c:"
"func:`local_traverse` to have these specific names; don't name them just "
"anything."
msgstr ""
"Зауважте, що :c:func:`Py_VISIT` вимагає параметрів *visit* і *arg*, щоб :c:"
"func:`local_traverse` мав ці конкретні імена; не називай їх як завгодно."

#: ../../c-api/typeobj.rst:1242
msgid ""
"Heap-allocated types (:const:`Py_TPFLAGS_HEAPTYPE`, such as those created "
"with :c:func:`PyType_FromSpec` and similar APIs) hold a reference to their "
"type. Their traversal function must therefore either visit :c:func:"
"`Py_TYPE(self) <Py_TYPE>`, or delegate this responsibility by calling "
"``tp_traverse`` of another heap-allocated type (such as a heap-allocated "
"superclass). If they do not, the type object may not be garbage-collected."
msgstr ""

#: ../../c-api/typeobj.rst:1252
msgid ""
"Heap-allocated types are expected to visit ``Py_TYPE(self)`` in "
"``tp_traverse``.  In earlier versions of Python, due to `bug 40217 <https://"
"bugs.python.org/issue40217>`_, doing this may lead to crashes in subclasses."
msgstr ""
"Очікується, що типи, виділені в купі, відвідуватимуть ``Py_TYPE(self)`` у "
"``tp_traverse``. У попередніх версіях Python, через `помилку 40217 <https://"
"bugs.python.org/issue40217>`_, це може призвести до збоїв у підкласах."

#: ../../c-api/typeobj.rst:1261
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_clear` and the :const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:"
"member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"Це поле успадковується підтипами разом із :c:member:`~PyTypeObject.tp_clear` "
"і бітом прапора :const:`Py_TPFLAGS_HAVE_GC`: біт прапора, :c:member:"
"`~PyTypeObject.tp_traverse` і :c:member:`~PyTypeObject.tp_clear` "
"успадковуються від базового типу, якщо всі вони дорівнюють нулю в підтипі."

#: ../../c-api/typeobj.rst:1269
msgid ""
"An optional pointer to a clear function for the garbage collector. This is "
"only used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The signature "
"is::"
msgstr ""
"Додатковий покажчик на зрозумілу функцію для збирача сміття. Це "
"використовується, лише якщо встановлено біт прапора :const:"
"`Py_TPFLAGS_HAVE_GC`. Підпис::"

#: ../../c-api/typeobj.rst:1274
msgid ""
"The :c:member:`~PyTypeObject.tp_clear` member function is used to break "
"reference cycles in cyclic garbage detected by the garbage collector.  Taken "
"together, all :c:member:`~PyTypeObject.tp_clear` functions in the system "
"must combine to break all reference cycles.  This is subtle, and if in any "
"doubt supply a :c:member:`~PyTypeObject.tp_clear` function.  For example, "
"the tuple type does not implement a :c:member:`~PyTypeObject.tp_clear` "
"function, because it's possible to prove that no reference cycle can be "
"composed entirely of tuples. Therefore the :c:member:`~PyTypeObject."
"tp_clear` functions of other types must be sufficient to break any cycle "
"containing a tuple.  This isn't immediately obvious, and there's rarely a "
"good reason to avoid implementing :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"Функція-член :c:member:`~PyTypeObject.tp_clear` використовується для розриву "
"еталонних циклів у циклічному смітті, виявленому збирачем сміття. Взяті "
"разом, усі функції :c:member:`~PyTypeObject.tp_clear` у системі мають "
"поєднуватися, щоб розірвати всі цикли посилань. Це непомітно, і якщо є "
"сумніви, додайте функцію :c:member:`~PyTypeObject.tp_clear`. Наприклад, тип "
"кортежу не реалізує функцію :c:member:`~PyTypeObject.tp_clear`, тому що "
"можна довести, що жоден еталонний цикл не може повністю складатися з "
"кортежів. Тому функції :c:member:`~PyTypeObject.tp_clear` інших типів мають "
"бути достатніми, щоб розірвати будь-який цикл, що містить кортеж. Це не "
"відразу очевидно, і рідко є вагомі причини уникати реалізації :c:member:"
"`~PyTypeObject.tp_clear`."

#: ../../c-api/typeobj.rst:1284
msgid ""
"Implementations of :c:member:`~PyTypeObject.tp_clear` should drop the "
"instance's references to those of its members that may be Python objects, "
"and set its pointers to those members to ``NULL``, as in the following "
"example::"
msgstr ""
"Реалізації :c:member:`~PyTypeObject.tp_clear` мають видаляти посилання "
"екземпляра на ті з його членів, які можуть бути об’єктами Python, і "
"встановлювати його покажчики на ці члени на ``NULL``, як у наступному "
"прикладі::"

#: ../../c-api/typeobj.rst:1298
msgid ""
"The :c:func:`Py_CLEAR` macro should be used, because clearing references is "
"delicate:  the reference to the contained object must not be decremented "
"until after the pointer to the contained object is set to ``NULL``.  This is "
"because decrementing the reference count may cause the contained object to "
"become trash, triggering a chain of reclamation activity that may include "
"invoking arbitrary Python code (due to finalizers, or weakref callbacks, "
"associated with the contained object). If it's possible for such code to "
"reference *self* again, it's important that the pointer to the contained "
"object be ``NULL`` at that time, so that *self* knows the contained object "
"can no longer be used.  The :c:func:`Py_CLEAR` macro performs the operations "
"in a safe order."
msgstr ""

#: ../../c-api/typeobj.rst:1309
msgid ""
"Note that :c:member:`~PyTypeObject.tp_clear` is not *always* called before "
"an instance is deallocated. For example, when reference counting is enough "
"to determine that an object is no longer used, the cyclic garbage collector "
"is not involved and :c:member:`~PyTypeObject.tp_dealloc` is called directly."
msgstr ""
"Зауважте, що :c:member:`~PyTypeObject.tp_clear` не *завжди* викликається до "
"того, як екземпляр буде звільнено. Наприклад, коли підрахунку посилань "
"достатньо, щоб визначити, що об’єкт більше не використовується, циклічний "
"збирач сміття не залучається, і безпосередньо викликається :c:member:"
"`~PyTypeObject.tp_dealloc`."

#: ../../c-api/typeobj.rst:1315
msgid ""
"Because the goal of :c:member:`~PyTypeObject.tp_clear` functions is to break "
"reference cycles, it's not necessary to clear contained objects like Python "
"strings or Python integers, which can't participate in reference cycles. On "
"the other hand, it may be convenient to clear all contained Python objects, "
"and write the type's :c:member:`~PyTypeObject.tp_dealloc` function to "
"invoke :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"Оскільки мета функцій :c:member:`~PyTypeObject.tp_clear` — розірвати цикли "
"посилань, немає необхідності очищати об’єкти, що містяться, як-от рядки "
"Python або цілі числа Python, які не можуть брати участь у циклах посилань. "
"З іншого боку, може бути зручно очистити всі об’єкти Python і написати "
"функцію типу :c:member:`~PyTypeObject.tp_dealloc` для виклику :c:member:"
"`~PyTypeObject.tp_clear`."

#: ../../c-api/typeobj.rst:1328
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_traverse` and the :const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:"
"member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"Це поле успадковується підтипами разом із :c:member:`~PyTypeObject."
"tp_traverse` і :const:`Py_TPFLAGS_HAVE_GC` біт прапора: біт прапора, :c:"
"member:`~PyTypeObject.tp_traverse` і :c:member:`~PyTypeObject.tp_clear` "
"успадковуються від базового типу, якщо всі вони дорівнюють нулю в підтипі."

#: ../../c-api/typeobj.rst:1336
msgid ""
"An optional pointer to the rich comparison function, whose signature is::"
msgstr ""
"Додатковий вказівник на функцію розширеного порівняння, сигнатура якої::"

#: ../../c-api/typeobj.rst:1340
msgid ""
"The first parameter is guaranteed to be an instance of the type that is "
"defined by :c:type:`PyTypeObject`."
msgstr ""
"Перший параметр гарантовано є екземпляром типу, визначеного :c:type:"
"`PyTypeObject`."

#: ../../c-api/typeobj.rst:1343
msgid ""
"The function should return the result of the comparison (usually ``Py_True`` "
"or ``Py_False``).  If the comparison is undefined, it must return "
"``Py_NotImplemented``, if another error occurred it must return ``NULL`` and "
"set an exception condition."
msgstr ""
"Функція має повертати результат порівняння (зазвичай ``Py_True`` або "
"``Py_False``). Якщо порівняння не визначено, воно має повернути "
"``Py_NotImplemented``, якщо сталася інша помилка, воно має повернути "
"``NULL`` і встановити умову винятку."

#: ../../c-api/typeobj.rst:1348
msgid ""
"The following constants are defined to be used as the third argument for :c:"
"member:`~PyTypeObject.tp_richcompare` and for :c:func:`PyObject_RichCompare`:"
msgstr ""
"Наступні константи визначено для використання як третій аргумент для :c:"
"member:`~PyTypeObject.tp_richcompare` і для :c:func:`PyObject_RichCompare`:"

#: ../../c-api/typeobj.rst:1352
msgid "Constant"
msgstr "Constante"

#: ../../c-api/typeobj.rst:1352
msgid "Comparison"
msgstr "Comparação"

#: ../../c-api/typeobj.rst:1354
msgid ":const:`Py_LT`"
msgstr ":const:`Py_LT`"

#: ../../c-api/typeobj.rst:1354
msgid "``<``"
msgstr "``<``"

#: ../../c-api/typeobj.rst:1356
msgid ":const:`Py_LE`"
msgstr ":const:`Py_LE`"

#: ../../c-api/typeobj.rst:1356
msgid "``<=``"
msgstr "``<=``"

#: ../../c-api/typeobj.rst:1358
msgid ":const:`Py_EQ`"
msgstr ":const:`Py_EQ`"

#: ../../c-api/typeobj.rst:1358
msgid "``==``"
msgstr "``==``"

#: ../../c-api/typeobj.rst:1360
msgid ":const:`Py_NE`"
msgstr ":const:`Py_NE`"

#: ../../c-api/typeobj.rst:1360
msgid "``!=``"
msgstr "``!=``"

#: ../../c-api/typeobj.rst:1362
msgid ":const:`Py_GT`"
msgstr ":const:`Py_GT`"

#: ../../c-api/typeobj.rst:1362
msgid "``>``"
msgstr "``>``"

#: ../../c-api/typeobj.rst:1364
msgid ":const:`Py_GE`"
msgstr ":const:`Py_GE`"

#: ../../c-api/typeobj.rst:1364
msgid "``>=``"
msgstr "``>=``"

#: ../../c-api/typeobj.rst:1367
msgid ""
"The following macro is defined to ease writing rich comparison functions:"
msgstr ""
"Наступний макрос визначено для полегшення написання розширених функцій "
"порівняння:"

#: ../../c-api/typeobj.rst:1371
msgid ""
"Return ``Py_True`` or ``Py_False`` from the function, depending on the "
"result of a comparison. VAL_A and VAL_B must be orderable by C comparison "
"operators (for example, they may be C ints or floats). The third argument "
"specifies the requested operation, as for :c:func:`PyObject_RichCompare`."
msgstr ""
"Повертає з функції ``Py_True`` або ``Py_False``, залежно від результату "
"порівняння. VAL_A і VAL_B повинні бути впорядковані операторами порівняння C "
"(наприклад, вони можуть бути C int або float). Третій аргумент визначає "
"необхідну операцію, як для :c:func:`PyObject_RichCompare`."

#: ../../c-api/typeobj.rst:1377
msgid "The return value's reference count is properly incremented."
msgstr ""

#: ../../c-api/typeobj.rst:1379
msgid "On error, sets an exception and returns ``NULL`` from the function."
msgstr "У разі помилки встановлює виняток і повертає ``NULL`` із функції."

#: ../../c-api/typeobj.rst:1387
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_hash`: a subtype inherits :c:member:`~PyTypeObject.tp_richcompare` and :c:"
"member:`~PyTypeObject.tp_hash` when the subtype's :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""
"Це поле успадковується підтипами разом із :c:member:`~PyTypeObject.tp_hash`: "
"підтип успадковує :c:member:`~PyTypeObject.tp_richcompare` і :c:member:"
"`~PyTypeObject.tp_hash`, коли підтип :c:member:`~PyTypeObject."
"tp_richcompare` і :c:member:`~PyTypeObject.tp_hash` мають значення ``NULL``."

#: ../../c-api/typeobj.rst:1394
msgid ""
":c:type:`PyBaseObject_Type` provides a :attr:`tp_richcompare` "
"implementation, which may be inherited.  However, if only :attr:`tp_hash` is "
"defined, not even the inherited function is used and instances of the type "
"will not be able to participate in any comparisons."
msgstr ""
":c:type:`PyBaseObject_Type` забезпечує реалізацію :attr:`tp_richcompare`, "
"яка може бути успадкована. Однак, якщо визначено лише :attr:`tp_hash`, "
"навіть успадкована функція не використовується, і екземпляри типу не зможуть "
"брати участь у жодних порівняннях."

#: ../../c-api/typeobj.rst:1403
msgid ""
"If the instances of this type are weakly referenceable, this field is "
"greater than zero and contains the offset in the instance structure of the "
"weak reference list head (ignoring the GC header, if present); this offset "
"is used by :c:func:`PyObject_ClearWeakRefs` and the :c:func:`PyWeakref_\\*` "
"functions.  The instance structure needs to include a field of type :c:type:"
"`PyObject*` which is initialized to ``NULL``."
msgstr ""

#: ../../c-api/typeobj.rst:1410
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_weaklist`; that "
"is the list head for weak references to the type object itself."
msgstr ""
"Не плутайте це поле з :c:member:`~PyTypeObject.tp_weaklist`; це заголовок "
"списку для слабких посилань на сам об’єкт типу."

#: ../../c-api/typeobj.rst:1415
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype uses a "
"different weak reference list head than the base type.  Since the list head "
"is always found via :c:member:`~PyTypeObject.tp_weaklistoffset`, this should "
"not be a problem."
msgstr ""
"Це поле успадковується підтипами, але перегляньте наведені нижче правила. "
"Підтип може замінити це зміщення; це означає, що підтип використовує інший "
"слабкий заголовок списку посилань, ніж базовий тип. Оскільки заголовок "
"списку завжди можна знайти через :c:member:`~PyTypeObject."
"tp_weaklistoffset`, це не повинно бути проблемою."

#: ../../c-api/typeobj.rst:1420
msgid ""
"When a type defined by a class statement has no :attr:`~object.__slots__` "
"declaration, and none of its base types are weakly referenceable, the type "
"is made weakly referenceable by adding a weak reference list head slot to "
"the instance layout and setting the :c:member:`~PyTypeObject."
"tp_weaklistoffset` of that slot's offset."
msgstr ""
"Якщо тип, визначений оператором класу, не має оголошення :attr:`~object."
"__slots__`, і жоден із його базових типів не має слабких посилань, тип стає "
"слабко посилальним шляхом додавання слота заголовка списку слабких посилань "
"до макета екземпляра та встановлення :c:member:`~PyTypeObject."
"tp_weaklistoffset` зміщення цього слота."

#: ../../c-api/typeobj.rst:1425
msgid ""
"When a type's :attr:`__slots__` declaration contains a slot named :attr:"
"`__weakref__`, that slot becomes the weak reference list head for instances "
"of the type, and the slot's offset is stored in the type's :c:member:"
"`~PyTypeObject.tp_weaklistoffset`."
msgstr ""
"Коли оголошення типу :attr:`__slots__` містить слот під назвою :attr:"
"`__weakref__`, цей слот стає заголовком списку слабких посилань для "
"екземплярів типу, а зсув слота зберігається в :c:member:`~PyTypeObject."
"tp_weaklistoffset` типу."

#: ../../c-api/typeobj.rst:1430
msgid ""
"When a type's :attr:`__slots__` declaration does not contain a slot named :"
"attr:`__weakref__`, the type inherits its :c:member:`~PyTypeObject."
"tp_weaklistoffset` from its base type."
msgstr ""
"Якщо оголошення типу :attr:`__slots__` не містить слота з назвою :attr:"
"`__weakref__`, тип успадковує свій :c:member:`~PyTypeObject."
"tp_weaklistoffset` від свого базового типу."

#: ../../c-api/typeobj.rst:1437
msgid ""
"An optional pointer to a function that returns an iterator for the object.  "
"Its presence normally signals that the instances of this type are iterable "
"(although sequences may be iterable without this function)."
msgstr ""

#: ../../c-api/typeobj.rst:1441
msgid "This function has the same signature as :c:func:`PyObject_GetIter`::"
msgstr "Ця функція має той самий підпис, що й :c:func:`PyObject_GetIter`::"

#: ../../c-api/typeobj.rst:1452
msgid ""
"An optional pointer to a function that returns the next item in an iterator. "
"The signature is::"
msgstr ""

#: ../../c-api/typeobj.rst:1457
msgid ""
"When the iterator is exhausted, it must return ``NULL``; a :exc:"
"`StopIteration` exception may or may not be set.  When another error occurs, "
"it must return ``NULL`` too.  Its presence signals that the instances of "
"this type are iterators."
msgstr ""
"Коли ітератор вичерпано, він повинен повернути ``NULL``; Виняток :exc:"
"`StopIteration` може бути встановлений або не встановлений. Коли виникає "
"інша помилка, вона також має повернути ``NULL``. Його наявність сигналізує "
"про те, що екземпляри цього типу є ітераторами."

#: ../../c-api/typeobj.rst:1462
msgid ""
"Iterator types should also define the :c:member:`~PyTypeObject.tp_iter` "
"function, and that function should return the iterator instance itself (not "
"a new iterator instance)."
msgstr ""
"Типи ітераторів також повинні визначати функцію :c:member:`~PyTypeObject."
"tp_iter`, і ця функція має повертати сам екземпляр ітератора (а не новий "
"екземпляр ітератора)."

#: ../../c-api/typeobj.rst:1466
msgid "This function has the same signature as :c:func:`PyIter_Next`."
msgstr "Ця функція має той самий підпис, що й :c:func:`PyIter_Next`."

#: ../../c-api/typeobj.rst:1475
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMethodDef` structures, declaring regular methods of this type."
msgstr ""
"Необов’язковий вказівник на статичний масив структур :c:type:`PyMethodDef` "
"із закінченням ``NULL``, що оголошує регулярні методи цього типу."

#: ../../c-api/typeobj.rst:1478
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a method descriptor."
msgstr ""
"Для кожного запису в масиві до словника типу (див. :c:member:`~PyTypeObject."
"tp_dict` нижче) додається запис, що містить дескриптор методу."

#: ../../c-api/typeobj.rst:1483
msgid ""
"This field is not inherited by subtypes (methods are inherited through a "
"different mechanism)."
msgstr ""
"Це поле не успадковується підтипами (методи успадковуються через інший "
"механізм)."

#: ../../c-api/typeobj.rst:1489
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMemberDef` structures, declaring regular data members (fields or slots) "
"of instances of this type."
msgstr ""
"Необов’язковий вказівник на статичний масив структур :c:type:`PyMemberDef` "
"із закінченням ``NULL``, що оголошує регулярні члени даних (поля або слоти) "
"екземплярів цього типу."

#: ../../c-api/typeobj.rst:1493
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a member descriptor."
msgstr ""
"Для кожного запису в масиві до словника типу (див. :c:member:`~PyTypeObject."
"tp_dict` нижче) додається запис, що містить дескриптор члена."

#: ../../c-api/typeobj.rst:1498
msgid ""
"This field is not inherited by subtypes (members are inherited through a "
"different mechanism)."
msgstr ""
"Це поле не успадковується підтипами (члени успадковуються через інший "
"механізм)."

#: ../../c-api/typeobj.rst:1504
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyGetSetDef` structures, declaring computed attributes of instances of this "
"type."
msgstr ""
"Додатковий вказівник на статичний масив структур :c:type:`PyGetSetDef` із "
"закінченням ``NULL``, що оголошує обчислені атрибути екземплярів цього типу."

#: ../../c-api/typeobj.rst:1507
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a getset descriptor."
msgstr ""
"Для кожного запису в масиві до словника типу (див. :c:member:`~PyTypeObject."
"tp_dict` нижче) додається запис, що містить дескриптор getset."

#: ../../c-api/typeobj.rst:1512
msgid ""
"This field is not inherited by subtypes (computed attributes are inherited "
"through a different mechanism)."
msgstr ""
"Це поле не успадковується підтипами (обчислені атрибути успадковуються за "
"допомогою іншого механізму)."

#: ../../c-api/typeobj.rst:1518
msgid ""
"An optional pointer to a base type from which type properties are "
"inherited.  At this level, only single inheritance is supported; multiple "
"inheritance require dynamically creating a type object by calling the "
"metatype."
msgstr ""
"Додатковий покажчик на базовий тип, властивості якого успадковуються. На "
"цьому рівні підтримується лише одиночне успадкування; множинне успадкування "
"вимагає динамічного створення об’єкта типу шляхом виклику метатипу."

#: ../../c-api/typeobj.rst:1526
msgid ""
"Slot initialization is subject to the rules of initializing globals. C99 "
"requires the initializers to be \"address constants\".  Function designators "
"like :c:func:`PyType_GenericNew`, with implicit conversion to a pointer, are "
"valid C99 address constants."
msgstr ""
"Ініціалізація слота підпорядковується правилам ініціалізації глобалів. C99 "
"вимагає, щоб ініціалізатори були \"константами адреси\". Позначення функцій, "
"такі як :c:func:`PyType_GenericNew`, з неявним перетворенням на вказівник, є "
"дійсними константами адрес C99."

#: ../../c-api/typeobj.rst:1531
msgid ""
"However, the unary '&' operator applied to a non-static variable like :c:"
"func:`PyBaseObject_Type` is not required to produce an address constant.  "
"Compilers may support this (gcc does), MSVC does not. Both compilers are "
"strictly standard conforming in this particular behavior."
msgstr ""
"Однак унарний оператор \"&\", застосований до нестатичної змінної, "
"наприклад :c:func:`PyBaseObject_Type`, не потрібен для створення константи "
"адреси. Компілятори можуть це підтримувати (gcc підтримує), а MSVC — ні. "
"Обидва компілятори суворо відповідають стандартам у цій конкретній поведінці."

#: ../../c-api/typeobj.rst:1537
msgid ""
"Consequently, :c:member:`~PyTypeObject.tp_base` should be set in the "
"extension module's init function."
msgstr ""
"Отже, :c:member:`~PyTypeObject.tp_base` має бути встановлено у функції "
"ініціалізації модуля розширення."

#: ../../c-api/typeobj.rst:1542
msgid "This field is not inherited by subtypes (obviously)."
msgstr "Це поле не успадковується підтипами (очевидно)."

#: ../../c-api/typeobj.rst:1546
msgid ""
"This field defaults to ``&PyBaseObject_Type`` (which to Python programmers "
"is known as the type :class:`object`)."
msgstr ""
"У цьому полі за замовчуванням встановлено ``&PyBaseObject_Type`` (що "
"програмістам на Python відоме як тип :class:`object`)."

#: ../../c-api/typeobj.rst:1552
msgid "The type's dictionary is stored here by :c:func:`PyType_Ready`."
msgstr "Словник типу зберігається тут у :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:1554
msgid ""
"This field should normally be initialized to ``NULL`` before PyType_Ready is "
"called; it may also be initialized to a dictionary containing initial "
"attributes for the type.  Once :c:func:`PyType_Ready` has initialized the "
"type, extra attributes for the type may be added to this dictionary only if "
"they don't correspond to overloaded operations (like :meth:`__add__`)."
msgstr ""
"Перед викликом PyType_Ready це поле має бути ініціалізовано як ``NULL``; він "
"також може бути ініціалізований словником, що містить початкові атрибути для "
"типу. Після того, як :c:func:`PyType_Ready` ініціалізує тип, додаткові "
"атрибути для типу можуть бути додані до цього словника, лише якщо вони не "
"відповідають перевантаженим операціям (наприклад, :meth:`__add__`)."

#: ../../c-api/typeobj.rst:1562
msgid ""
"This field is not inherited by subtypes (though the attributes defined in "
"here are inherited through a different mechanism)."
msgstr ""
"Це поле не успадковується підтипами (хоча атрибути, визначені тут, "
"успадковуються за допомогою іншого механізму)."

#: ../../c-api/typeobj.rst:1567
msgid ""
"If this field is ``NULL``, :c:func:`PyType_Ready` will assign a new "
"dictionary to it."
msgstr ""
"Якщо це поле має значення ``NULL``, :c:func:`PyType_Ready` призначить йому "
"новий словник."

#: ../../c-api/typeobj.rst:1572
msgid ""
"It is not safe to use :c:func:`PyDict_SetItem` on or otherwise modify :c:"
"member:`~PyTypeObject.tp_dict` with the dictionary C-API."
msgstr ""
"Небезпечно використовувати :c:func:`PyDict_SetItem` або іншим чином "
"змінювати :c:member:`~PyTypeObject.tp_dict` за допомогою словника C-API."

#: ../../c-api/typeobj.rst:1578
msgid "An optional pointer to a \"descriptor get\" function."
msgstr "Додатковий вказівник на функцію \"отримання дескриптора\"."

#: ../../c-api/typeobj.rst:1580 ../../c-api/typeobj.rst:1596
#: ../../c-api/typeobj.rst:1678 ../../c-api/typeobj.rst:1708
#: ../../c-api/typeobj.rst:1732
msgid "The function signature is::"
msgstr "A assinatura da função é::"

#: ../../c-api/typeobj.rst:1593
msgid ""
"An optional pointer to a function for setting and deleting a descriptor's "
"value."
msgstr ""
"Додатковий покажчик на функцію для встановлення та видалення значення "
"дескриптора."

#: ../../c-api/typeobj.rst:1600
msgid "The *value* argument is set to ``NULL`` to delete the value."
msgstr "Аргумент *value* має значення ``NULL``, щоб видалити значення."

#: ../../c-api/typeobj.rst:1611
msgid ""
"If the instances of this type have a dictionary containing instance "
"variables, this field is non-zero and contains the offset in the instances "
"of the type of the instance variable dictionary; this offset is used by :c:"
"func:`PyObject_GenericGetAttr`."
msgstr ""
"Якщо екземпляри цього типу мають словник, що містить змінні екземпляра, це "
"поле ненульове та містить зміщення в екземплярах типу словника змінних "
"екземплярів; це зміщення використовується :c:func:`PyObject_GenericGetAttr`."

#: ../../c-api/typeobj.rst:1616
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_dict`; that is "
"the dictionary for attributes of the type object itself."
msgstr ""
"Не плутайте це поле з :c:member:`~PyTypeObject.tp_dict`; це словник для "
"атрибутів самого об’єкта типу."

#: ../../c-api/typeobj.rst:1619
msgid ""
"If the value of this field is greater than zero, it specifies the offset "
"from the start of the instance structure.  If the value is less than zero, "
"it specifies the offset from the *end* of the instance structure.  A "
"negative offset is more expensive to use, and should only be used when the "
"instance structure contains a variable-length part.  This is used for "
"example to add an instance variable dictionary to subtypes of :class:`str` "
"or :class:`tuple`. Note that the :c:member:`~PyTypeObject.tp_basicsize` "
"field should account for the dictionary added to the end in that case, even "
"though the dictionary is not included in the basic object layout.  On a "
"system with a pointer size of 4 bytes, :c:member:`~PyTypeObject."
"tp_dictoffset` should be set to ``-4`` to indicate that the dictionary is at "
"the very end of the structure."
msgstr ""
"Якщо значення цього поля більше нуля, воно визначає зміщення від початку "
"структури екземпляра. Якщо значення менше нуля, воно визначає зміщення від "
"*кінця* структури екземпляра. Від’ємне зміщення є дорожчим у використанні, і "
"його слід використовувати лише тоді, коли структура екземпляра містить "
"частину змінної довжини. Це використовується, наприклад, для додавання "
"словника змінних примірників до підтипів :class:`str` або :class:`tuple`. "
"Зауважте, що в цьому випадку поле :c:member:`~PyTypeObject.tp_basicsize` має "
"враховувати словник, доданий у кінець, навіть якщо словник не включено до "
"основного макета об’єкта. У системі з розміром покажчика 4 байти :c:member:"
"`~PyTypeObject.tp_dictoffset` має бути встановлено на ``-4``, щоб вказати, "
"що словник знаходиться в самому кінці структури."

#: ../../c-api/typeobj.rst:1631
msgid ""
"The real dictionary offset in an instance can be computed from a negative :c:"
"member:`~PyTypeObject.tp_dictoffset` as follows::"
msgstr ""
"Справжнє зміщення словника в екземплярі можна обчислити з негативного :c:"
"member:`~PyTypeObject.tp_dictoffset` наступним чином::"

#: ../../c-api/typeobj.rst:1638
msgid ""
"where :c:member:`~PyTypeObject.tp_basicsize`, :c:member:`~PyTypeObject."
"tp_itemsize` and :c:member:`~PyTypeObject.tp_dictoffset` are taken from the "
"type object, and :attr:`ob_size` is taken from the instance.  The absolute "
"value is taken because ints use the sign of :attr:`ob_size` to store the "
"sign of the number.  (There's never a need to do this calculation yourself; "
"it is done for you by :c:func:`_PyObject_GetDictPtr`.)"
msgstr ""
"де :c:member:`~PyTypeObject.tp_basicsize`, :c:member:`~PyTypeObject."
"tp_itemsize` і :c:member:`~PyTypeObject.tp_dictoffset` беруться з об’єкта "
"типу, а :attr:`ob_size` береться з примірника. Береться абсолютне значення, "
"тому що int використовує знак :attr:`ob_size` для зберігання знака числа. "
"(Ніколи не потрібно робити це обчислення самостійно; це робить за вас :c:"
"func:`_PyObject_GetDictPtr`.)"

#: ../../c-api/typeobj.rst:1646
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype instances "
"store the dictionary at a difference offset than the base type.  Since the "
"dictionary is always found via :c:member:`~PyTypeObject.tp_dictoffset`, this "
"should not be a problem."
msgstr ""
"Це поле успадковується підтипами, але перегляньте наведені нижче правила. "
"Підтип може замінити це зміщення; це означає, що екземпляри підтипу "
"зберігають словник зі зміщенням різниці, ніж базовий тип. Оскільки словник "
"завжди можна знайти через :c:member:`~PyTypeObject.tp_dictoffset`, це не "
"повинно бути проблемою."

#: ../../c-api/typeobj.rst:1651
msgid ""
"When a type defined by a class statement has no :attr:`~object.__slots__` "
"declaration, and none of its base types has an instance variable dictionary, "
"a dictionary slot is added to the instance layout and the :c:member:"
"`~PyTypeObject.tp_dictoffset` is set to that slot's offset."
msgstr ""
"Якщо тип, визначений оператором класу, не має оголошення :attr:`~object."
"__slots__`, і жоден із його базових типів не має словника змінної "
"екземпляра, слот словника додається до макета екземпляра та :c:member:"
"`~PyTypeObject.tp_dictoffset` встановлено на зміщення цього слота."

#: ../../c-api/typeobj.rst:1656
msgid ""
"When a type defined by a class statement has a :attr:`__slots__` "
"declaration, the type inherits its :c:member:`~PyTypeObject.tp_dictoffset` "
"from its base type."
msgstr ""
"Коли тип, визначений оператором класу, має оголошення :attr:`__slots__`, тип "
"успадковує свій :c:member:`~PyTypeObject.tp_dictoffset` від свого базового "
"типу."

#: ../../c-api/typeobj.rst:1659
msgid ""
"(Adding a slot named :attr:`~object.__dict__` to the :attr:`__slots__` "
"declaration does not have the expected effect, it just causes confusion.  "
"Maybe this should be added as a feature just like :attr:`__weakref__` "
"though.)"
msgstr ""
"(Додавання слота з іменем :attr:`~object.__dict__` до оголошення :attr:"
"`__slots__` не має очікуваного ефекту, це лише викликає плутанину. Можливо, "
"це слід додати як функцію, як :attr:`__weakref__` хоча.)"

#: ../../c-api/typeobj.rst:1665
msgid ""
"This slot has no default.  For static types, if the field is ``NULL`` then "
"no :attr:`__dict__` gets created for instances."
msgstr ""

#: ../../c-api/typeobj.rst:1671
msgid "An optional pointer to an instance initialization function."
msgstr "Додатковий покажчик на функцію ініціалізації екземпляра."

#: ../../c-api/typeobj.rst:1673
msgid ""
"This function corresponds to the :meth:`__init__` method of classes.  Like :"
"meth:`__init__`, it is possible to create an instance without calling :meth:"
"`__init__`, and it is possible to reinitialize an instance by calling its :"
"meth:`__init__` method again."
msgstr ""
"Ця функція відповідає методу класів :meth:`__init__`. Подібно до :meth:"
"`__init__`, екземпляр можна створити без виклику :meth:`__init__`, а "
"екземпляр можна повторно ініціалізувати, викликавши його метод :meth:"
"`__init__` знову."

#: ../../c-api/typeobj.rst:1682
msgid ""
"The self argument is the instance to be initialized; the *args* and *kwds* "
"arguments represent positional and keyword arguments of the call to :meth:"
"`__init__`."
msgstr ""
"Аргумент self - це екземпляр, який потрібно ініціалізувати; аргументи *args* "
"і *kwds* представляють позиційні та ключові аргументи виклику :meth:"
"`__init__`."

#: ../../c-api/typeobj.rst:1686
msgid ""
"The :c:member:`~PyTypeObject.tp_init` function, if not ``NULL``, is called "
"when an instance is created normally by calling its type, after the type's :"
"c:member:`~PyTypeObject.tp_new` function has returned an instance of the "
"type.  If the :c:member:`~PyTypeObject.tp_new` function returns an instance "
"of some other type that is not a subtype of the original type, no :c:member:"
"`~PyTypeObject.tp_init` function is called; if :c:member:`~PyTypeObject."
"tp_new` returns an instance of a subtype of the original type, the "
"subtype's :c:member:`~PyTypeObject.tp_init` is called."
msgstr ""
"Функція :c:member:`~PyTypeObject.tp_init`, якщо вона не ``NULL``, "
"викликається, коли екземпляр створюється звичайним викликом його типу, після "
"функції :c:member:`~PyTypeObject.tp_new` типу. повернув екземпляр типу. Якщо "
"функція :c:member:`~PyTypeObject.tp_new` повертає екземпляр якогось іншого "
"типу, який не є підтипом вихідного типу, функція :c:member:`~PyTypeObject."
"tp_init` не викликається; якщо :c:member:`~PyTypeObject.tp_new` повертає "
"екземпляр підтипу вихідного типу, викликається :c:member:`~PyTypeObject."
"tp_init` підтипу."

#: ../../c-api/typeobj.rst:1693
msgid "Returns ``0`` on success, ``-1`` and sets an exception on error."
msgstr ""
"У разі успіху повертає ``0``, ``-1`` і встановлює виняток у випадку помилки."

#: ../../c-api/typeobj.rst:1701
msgid "For static types this field does not have a default."
msgstr ""

#: ../../c-api/typeobj.rst:1706
msgid "An optional pointer to an instance allocation function."
msgstr "Додатковий покажчик на функцію виділення екземпляра."

#: ../../c-api/typeobj.rst:1714
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)."
msgstr ""
"Це поле успадковується статичними підтипами, але не динамічними підтипами "
"(підтипами, створеними оператором класу)."

#: ../../c-api/typeobj.rst:1719
msgid ""
"For dynamic subtypes, this field is always set to :c:func:"
"`PyType_GenericAlloc`, to force a standard heap allocation strategy."
msgstr ""
"Для динамічних підтипів це поле завжди має значення :c:func:"
"`PyType_GenericAlloc`, щоб примусово використовувати стандартну стратегію "
"розподілу купи."

#: ../../c-api/typeobj.rst:1723
msgid ""
"For static subtypes, :c:type:`PyBaseObject_Type` uses :c:func:"
"`PyType_GenericAlloc`.  That is the recommended value for all statically "
"defined types."
msgstr ""
"Для статичних підтипів :c:type:`PyBaseObject_Type` використовує :c:func:"
"`PyType_GenericAlloc`. Це рекомендоване значення для всіх статично "
"визначених типів."

#: ../../c-api/typeobj.rst:1730
msgid "An optional pointer to an instance creation function."
msgstr "Додатковий покажчик на функцію створення екземпляра."

#: ../../c-api/typeobj.rst:1736
msgid ""
"The *subtype* argument is the type of the object being created; the *args* "
"and *kwds* arguments represent positional and keyword arguments of the call "
"to the type.  Note that *subtype* doesn't have to equal the type whose :c:"
"member:`~PyTypeObject.tp_new` function is called; it may be a subtype of "
"that type (but not an unrelated type)."
msgstr ""
"Аргумент *subtype* — це тип об’єкта, що створюється; аргументи *args* і "
"*kwds* представляють позиційні та ключові аргументи виклику типу. Зауважте, "
"що *subtype* не обов’язково дорівнює типу, чия функція :c:member:"
"`~PyTypeObject.tp_new` викликається; це може бути підтип цього типу (але не "
"непов’язаний тип)."

#: ../../c-api/typeobj.rst:1742
msgid ""
"The :c:member:`~PyTypeObject.tp_new` function should call ``subtype-"
">tp_alloc(subtype, nitems)`` to allocate space for the object, and then do "
"only as much further initialization as is absolutely necessary.  "
"Initialization that can safely be ignored or repeated should be placed in "
"the :c:member:`~PyTypeObject.tp_init` handler.  A good rule of thumb is that "
"for immutable types, all initialization should take place in :c:member:"
"`~PyTypeObject.tp_new`, while for mutable types, most initialization should "
"be deferred to :c:member:`~PyTypeObject.tp_init`."
msgstr ""
"Функція :c:member:`~PyTypeObject.tp_new` має викликати ``subtype-"
">tp_alloc(subtype, nitems)``, щоб виділити простір для об’єкта, а потім "
"виконувати подальшу ініціалізацію лише стільки, скільки це абсолютно "
"необхідно. Ініціалізацію, яку можна безпечно проігнорувати або повторити, "
"слід розмістити в обробнику :c:member:`~PyTypeObject.tp_init`. Хорошим "
"емпіричним правилом є те, що для незмінних типів уся ініціалізація має "
"відбуватися в :c:member:`~PyTypeObject.tp_new`, тоді як для змінних типів "
"більшість ініціалізацій має бути відкладено до :c:member:`~PyTypeObject."
"tp_init`."

#: ../../c-api/typeobj.rst:1752
msgid ""
"This field is inherited by subtypes, except it is not inherited by static "
"types whose :c:member:`~PyTypeObject.tp_base` is ``NULL`` or "
"``&PyBaseObject_Type``."
msgstr ""

#: ../../c-api/typeobj.rst:1757
msgid ""
"For static types this field has no default.  This means if the slot is "
"defined as ``NULL``, the type cannot be called to create new instances; "
"presumably there is some other way to create instances, like a factory "
"function."
msgstr ""

#: ../../c-api/typeobj.rst:1765
msgid ""
"An optional pointer to an instance deallocation function.  Its signature is::"
msgstr "Додатковий покажчик на функцію звільнення екземпляра. Його підпис::"

#: ../../c-api/typeobj.rst:1769
msgid ""
"An initializer that is compatible with this signature is :c:func:"
"`PyObject_Free`."
msgstr "Ініціалізатор, сумісний із цим підписом, це :c:func:`PyObject_Free`."

#: ../../c-api/typeobj.rst:1773
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)"
msgstr ""
"Це поле успадковується статичними підтипами, але не динамічними підтипами "
"(підтипами, створеними оператором класу)"

#: ../../c-api/typeobj.rst:1778
msgid ""
"In dynamic subtypes, this field is set to a deallocator suitable to match :c:"
"func:`PyType_GenericAlloc` and the value of the :const:`Py_TPFLAGS_HAVE_GC` "
"flag bit."
msgstr ""
"У динамічних підтипах це поле встановлюється на засіб розблокування, який "
"відповідає :c:func:`PyType_GenericAlloc` і значенню біта прапора :const:"
"`Py_TPFLAGS_HAVE_GC`."

#: ../../c-api/typeobj.rst:1782
msgid "For static subtypes, :c:type:`PyBaseObject_Type` uses PyObject_Del."
msgstr ""
"Для статичних підтипів :c:type:`PyBaseObject_Type` використовує PyObject_Del."

#: ../../c-api/typeobj.rst:1787
msgid "An optional pointer to a function called by the garbage collector."
msgstr "Додатковий покажчик на функцію, яка викликається збирачем сміття."

#: ../../c-api/typeobj.rst:1789
msgid ""
"The garbage collector needs to know whether a particular object is "
"collectible or not.  Normally, it is sufficient to look at the object's "
"type's :c:member:`~PyTypeObject.tp_flags` field, and check the :const:"
"`Py_TPFLAGS_HAVE_GC` flag bit.  But some types have a mixture of statically "
"and dynamically allocated instances, and the statically allocated instances "
"are not collectible.  Such types should define this function; it should "
"return ``1`` for a collectible instance, and ``0`` for a non-collectible "
"instance. The signature is::"
msgstr ""
"Збирач сміття повинен знати, чи є певний об'єкт предметом колекціонування чи "
"ні. Зазвичай достатньо подивитися на поле типу об’єкта :c:member:"
"`~PyTypeObject.tp_flags` і перевірити біт прапора :const:"
"`Py_TPFLAGS_HAVE_GC`. Але деякі типи мають поєднання статично та динамічно "
"виділених екземплярів, і статично виділені екземпляри неможливо зібрати. "
"Такі типи повинні визначати цю функцію; він має повертати ``1`` для "
"екземпляра, який можна колекціонувати, і ``0`` для екземпляра, який не "
"підлягає колекціонуванню. Підпис::"

#: ../../c-api/typeobj.rst:1799
msgid ""
"(The only example of this are types themselves.  The metatype, :c:data:"
"`PyType_Type`, defines this function to distinguish between statically and "
"dynamically allocated types.)"
msgstr ""

#: ../../c-api/typeobj.rst:1809
msgid ""
"This slot has no default.  If this field is ``NULL``, :const:"
"`Py_TPFLAGS_HAVE_GC` is used as the functional equivalent."
msgstr ""
"Цей слот не має умовчання. Якщо це поле має значення ``NULL``, :const:"
"`Py_TPFLAGS_HAVE_GC` використовується як функціональний еквівалент."

#: ../../c-api/typeobj.rst:1815
msgid "Tuple of base types."
msgstr "Кортеж базових типів."

#: ../../c-api/typeobj.rst:1817
msgid ""
"This is set for types created by a class statement.  It should be ``NULL`` "
"for statically defined types."
msgstr ""

#: ../../c-api/typeobj.rst:1822 ../../c-api/typeobj.rst:1843
#: ../../c-api/typeobj.rst:1852 ../../c-api/typeobj.rst:1862
#: ../../c-api/typeobj.rst:1876
msgid "This field is not inherited."
msgstr "Це поле не успадковується."

#: ../../c-api/typeobj.rst:1827
msgid ""
"Tuple containing the expanded set of base types, starting with the type "
"itself and ending with :class:`object`, in Method Resolution Order."
msgstr ""
"Кортеж, що містить розширений набір базових типів, починаючи з самого типу "
"та закінчуючи :class:`object`, у порядку вирішення методів."

#: ../../c-api/typeobj.rst:1833
msgid ""
"This field is not inherited; it is calculated fresh by :c:func:"
"`PyType_Ready`."
msgstr ""
"Це поле не успадковується; він обчислюється за допомогою :c:func:"
"`PyType_Ready`."

#: ../../c-api/typeobj.rst:1839
msgid "Unused.  Internal use only."
msgstr "Невикористаний. Тільки для внутрішнього використання."

#: ../../c-api/typeobj.rst:1848
msgid "List of weak references to subclasses.  Internal use only."
msgstr ""
"Список слабких посилань на підкласи. Тільки для внутрішнього використання."

#: ../../c-api/typeobj.rst:1857
msgid ""
"Weak reference list head, for weak references to this type object.  Not "
"inherited.  Internal use only."
msgstr ""
"Голова списку слабких посилань для слабких посилань на об’єкт цього типу. Не "
"передається у спадок. Тільки для внутрішнього використання."

#: ../../c-api/typeobj.rst:1867
msgid ""
"This field is deprecated.  Use :c:member:`~PyTypeObject.tp_finalize` instead."
msgstr ""
"Це поле застаріло. Натомість використовуйте :c:member:`~PyTypeObject."
"tp_finalize`."

#: ../../c-api/typeobj.rst:1872
msgid "Used to index into the method cache.  Internal use only."
msgstr ""
"Використовується для індексування в кеш методів. Тільки для внутрішнього "
"використання."

#: ../../c-api/typeobj.rst:1881
msgid ""
"An optional pointer to an instance finalization function.  Its signature is::"
msgstr "Додатковий покажчик на функцію завершення екземпляра. Його підпис::"

#: ../../c-api/typeobj.rst:1885
msgid ""
"If :c:member:`~PyTypeObject.tp_finalize` is set, the interpreter calls it "
"once when finalizing an instance.  It is called either from the garbage "
"collector (if the instance is part of an isolated reference cycle) or just "
"before the object is deallocated.  Either way, it is guaranteed to be called "
"before attempting to break reference cycles, ensuring that it finds the "
"object in a sane state."
msgstr ""
"Якщо встановлено :c:member:`~PyTypeObject.tp_finalize`, інтерпретатор "
"викликає його один раз під час завершення екземпляра. Він викликається або "
"зі збирача сміття (якщо екземпляр є частиною ізольованого еталонного циклу), "
"або безпосередньо перед звільненням об’єкта. У будь-якому випадку, він "
"гарантовано буде викликаний перед спробою розірвати еталонні цикли, "
"гарантуючи, що він знайде об’єкт у нормальному стані."

#: ../../c-api/typeobj.rst:1892
msgid ""
":c:member:`~PyTypeObject.tp_finalize` should not mutate the current "
"exception status; therefore, a recommended way to write a non-trivial "
"finalizer is::"
msgstr ""
":c:member:`~PyTypeObject.tp_finalize` не повинен змінювати поточний статус "
"винятку; отже, рекомендований спосіб написання нетривіального фіналізатора:"

#: ../../c-api/typeobj.rst:1909
msgid ""
"For this field to be taken into account (even through inheritance), you must "
"also set the :const:`Py_TPFLAGS_HAVE_FINALIZE` flags bit."
msgstr ""

#: ../../c-api/typeobj.rst:1912
msgid ""
"Also, note that, in a garbage collected Python, :c:member:`~PyTypeObject."
"tp_dealloc` may be called from any Python thread, not just the thread which "
"created the object (if the object becomes part of a refcount cycle, that "
"cycle might be collected by a garbage collection on any thread).  This is "
"not a problem for Python API calls, since the thread on which tp_dealloc is "
"called will own the Global Interpreter Lock (GIL). However, if the object "
"being destroyed in turn destroys objects from some other C or C++ library, "
"care should be taken to ensure that destroying those objects on the thread "
"which called tp_dealloc will not violate any assumptions of the library."
msgstr ""
"Також зауважте, що в Python зі збиранням сміття :c:member:`~PyTypeObject."
"tp_dealloc` можна викликати з будь-якого потоку Python, а не лише з потоку, "
"який створив об’єкт (якщо об’єкт стає частиною циклу підрахунку посилань, це "
"цикл може бути зібраний за допомогою збирання сміття в будь-якому потоці). "
"Це не проблема для викликів Python API, оскільки потік, у якому викликається "
"tp_dealloc, буде володіти глобальним блокуванням інтерпретатора (GIL). "
"Проте, якщо об’єкт, який знищується, у свою чергу знищує об’єкти з якоїсь "
"іншої бібліотеки C або C++, слід подбати про те, щоб знищення цих об’єктів у "
"потоці, яка викликала tp_dealloc, не порушувало жодних припущень бібліотеки."

#: ../../c-api/typeobj.rst:1929
msgid "\"Safe object finalization\" (:pep:`442`)"
msgstr "\"Finalização segura de objetos\" (:pep:`442`)"

#: ../../c-api/typeobj.rst:1934
msgid ""
"Vectorcall function to use for calls of this type object. In other words, it "
"is used to implement :ref:`vectorcall <vectorcall>` for ``type.__call__``. "
"If ``tp_vectorcall`` is ``NULL``, the default call implementation using :"
"attr:`__new__` and :attr:`__init__` is used."
msgstr ""
"Функція Vectorcall для викликів об’єкта цього типу. Іншими словами, він "
"використовується для реалізації :ref:`vectorcall <vectorcall>` для ``type."
"__call__``. Якщо ``tp_vectorcall`` має значення ``NULL``, використовується "
"реалізація виклику за замовчуванням за допомогою :attr:`__new__` і :attr:"
"`__init__`."

#: ../../c-api/typeobj.rst:1942
msgid "This field is never inherited."
msgstr "Це поле ніколи не успадковується."

#: ../../c-api/typeobj.rst:1944
msgid "(the field exists since 3.8 but it's only used since 3.9)"
msgstr "(поле існує з 3.8, але використовується лише з 3.9)"

#: ../../c-api/typeobj.rst:1950
msgid "Heap Types"
msgstr "Tipos no heap"

#: ../../c-api/typeobj.rst:1952
msgid ""
"Traditionally, types defined in C code are *static*, that is, a static :c:"
"type:`PyTypeObject` structure is defined directly in code and initialized "
"using :c:func:`PyType_Ready`."
msgstr ""
"Традиційно типи, визначені в коді C, є *статичними*, тобто статична "
"структура :c:type:`PyTypeObject` визначається безпосередньо в коді та "
"ініціалізується за допомогою :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:1956
msgid ""
"This results in types that are limited relative to types defined in Python:"
msgstr ""
"Це призводить до типів, які обмежені відносно типів, визначених у Python:"

#: ../../c-api/typeobj.rst:1958
msgid ""
"Static types are limited to one base, i.e. they cannot use multiple "
"inheritance."
msgstr ""
"Статичні типи обмежені однією базою, тобто вони не можуть використовувати "
"множинне успадкування."

#: ../../c-api/typeobj.rst:1960
msgid ""
"Static type objects (but not necessarily their instances) are immutable. It "
"is not possible to add or modify the type object's attributes from Python."
msgstr ""
"Об’єкти статичного типу (але не обов’язково їх екземпляри) незмінні. "
"Неможливо додати або змінити атрибути об’єкта типу з Python."

#: ../../c-api/typeobj.rst:1962
msgid ""
"Static type objects are shared across :ref:`sub-interpreters <sub-"
"interpreter-support>`, so they should not include any subinterpreter-"
"specific state."
msgstr ""
"Об’єкти статичного типу є спільними для :ref:`суб-інтерпретаторів <sub-"
"interpreter-support>`, тому вони не повинні включати будь-який стан, "
"специфічний для субінтерпретатора."

#: ../../c-api/typeobj.rst:1966
msgid ""
"Also, since :c:type:`PyTypeObject` is not part of the :ref:`stable ABI "
"<stable>`, any extension modules using static types must be compiled for a "
"specific Python minor version."
msgstr ""

#: ../../c-api/typeobj.rst:1970
msgid ""
"An alternative to static types is *heap-allocated types*, or *heap types* "
"for short, which correspond closely to classes created by Python's ``class`` "
"statement."
msgstr ""

#: ../../c-api/typeobj.rst:1974
msgid ""
"This is done by filling a :c:type:`PyType_Spec` structure and calling :c:"
"func:`PyType_FromSpecWithBases`."
msgstr ""

#: ../../c-api/typeobj.rst:1981
msgid "Number Object Structures"
msgstr "Числові об’єктні структури"

#: ../../c-api/typeobj.rst:1988
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the number protocol.  Each function is used by the function of "
"similar name documented in the :ref:`number` section."
msgstr ""
"Ця структура містить покажчики на функції, які об’єкт використовує для "
"реалізації протоколу чисел. Кожна функція використовується функцією з "
"подібною назвою, задокументованою в розділі :ref:`number`."

#: ../../c-api/typeobj.rst:1994 ../../c-api/typeobj.rst:2318
msgid "Here is the structure definition::"
msgstr "Ось визначення структури::"

#: ../../c-api/typeobj.rst:2041
msgid ""
"Binary and ternary functions must check the type of all their operands, and "
"implement the necessary conversions (at least one of the operands is an "
"instance of the defined type).  If the operation is not defined for the "
"given operands, binary and ternary functions must return "
"``Py_NotImplemented``, if another error occurred they must return ``NULL`` "
"and set an exception."
msgstr ""
"Двійкові та потрійні функції повинні перевіряти тип усіх своїх операндів і "
"здійснювати необхідні перетворення (принаймні один із операндів є "
"екземпляром визначеного типу). Якщо операція не визначена для заданих "
"операндів, двійкові та тернарні функції повинні повернути "
"``Py_NotImplemented``, якщо сталася інша помилка, вони повинні повернути "
"``NULL`` і встановити виняток."

#: ../../c-api/typeobj.rst:2050
msgid ""
"The :c:data:`nb_reserved` field should always be ``NULL``.  It was "
"previously called :c:data:`nb_long`, and was renamed in Python 3.0.1."
msgstr ""
"Поле :c:data:`nb_reserved` має завжди мати значення ``NULL``. Раніше він "
"називався :c:data:`nb_long` і був перейменований у Python 3.0.1."

#: ../../c-api/typeobj.rst:2095
msgid "Mapping Object Structures"
msgstr "Відображення структур об’єктів"

#: ../../c-api/typeobj.rst:2102
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the mapping protocol.  It has three members:"
msgstr ""
"Ця структура містить покажчики на функції, які об’єкт використовує для "
"реалізації протоколу відображення. Він складається з трьох членів:"

#: ../../c-api/typeobj.rst:2107
msgid ""
"This function is used by :c:func:`PyMapping_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  This slot may be set to "
"``NULL`` if the object has no defined length."
msgstr ""
"Ця функція використовується :c:func:`PyMapping_Size` і :c:func:"
"`PyObject_Size` і має однакову сигнатуру. Цей слот може бути встановлений на "
"``NULL``, якщо об’єкт не має визначеної довжини."

#: ../../c-api/typeobj.rst:2113
msgid ""
"This function is used by :c:func:`PyObject_GetItem` and :c:func:"
"`PySequence_GetSlice`, and has the same signature as :c:func:`!"
"PyObject_GetItem`.  This slot must be filled for the :c:func:"
"`PyMapping_Check` function to return ``1``, it can be ``NULL`` otherwise."
msgstr ""
"Ця функція використовується :c:func:`PyObject_GetItem` і :c:func:"
"`PySequence_GetSlice`, і має такий же підпис, як :c:func:`!"
"PyObject_GetItem`. Цей слот має бути заповнений, щоб функція :c:func:"
"`PyMapping_Check` повернула ``1``, інакше вона може бути ``NULL``."

#: ../../c-api/typeobj.rst:2121
msgid ""
"This function is used by :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PyObject_SetSlice` and :c:func:"
"`PyObject_DelSlice`.  It has the same signature as :c:func:`!"
"PyObject_SetItem`, but *v* can also be set to ``NULL`` to delete an item.  "
"If this slot is ``NULL``, the object does not support item assignment and "
"deletion."
msgstr ""
"Цю функцію використовують :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PyObject_SetSlice` і :c:func:"
"`PyObject_DelSlice`. Він має той самий підпис, що й :c:func:`!"
"PyObject_SetItem`, але *v* також можна встановити на ``NULL``, щоб видалити "
"елемент. Якщо цей слот має значення ``NULL``, об’єкт не підтримує "
"призначення та видалення елементів."

#: ../../c-api/typeobj.rst:2132
msgid "Sequence Object Structures"
msgstr "Структури об’єктів послідовності"

#: ../../c-api/typeobj.rst:2139
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the sequence protocol."
msgstr ""
"Ця структура містить покажчики на функції, які об’єкт використовує для "
"реалізації протоколу послідовності."

#: ../../c-api/typeobj.rst:2144
msgid ""
"This function is used by :c:func:`PySequence_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  It is also used for handling "
"negative indices via the :c:member:`~PySequenceMethods.sq_item` and the :c:"
"member:`~PySequenceMethods.sq_ass_item` slots."
msgstr ""
"Ця функція використовується :c:func:`PySequence_Size` і :c:func:"
"`PyObject_Size` і має однакову сигнатуру. Він також використовується для "
"обробки негативних індексів через слоти :c:member:`~PySequenceMethods."
"sq_item` і :c:member:`~PySequenceMethods.sq_ass_item`."

#: ../../c-api/typeobj.rst:2151
msgid ""
"This function is used by :c:func:`PySequence_Concat` and has the same "
"signature.  It is also used by the ``+`` operator, after trying the numeric "
"addition via the :c:member:`~PyNumberMethods.nb_add` slot."
msgstr ""
"Ця функція використовується :c:func:`PySequence_Concat` і має такий самий "
"підпис. Він також використовується оператором ``+`` після спроби додавання "
"чисел через слот :c:member:`~PyNumberMethods.nb_add`."

#: ../../c-api/typeobj.rst:2157
msgid ""
"This function is used by :c:func:`PySequence_Repeat` and has the same "
"signature.  It is also used by the ``*`` operator, after trying numeric "
"multiplication via the :c:member:`~PyNumberMethods.nb_multiply` slot."
msgstr ""
"Ця функція використовується :c:func:`PySequence_Repeat` і має такий самий "
"підпис. Він також використовується оператором ``*`` після спроби числового "
"множення через слот :c:member:`~PyNumberMethods.nb_multiply`."

#: ../../c-api/typeobj.rst:2163
msgid ""
"This function is used by :c:func:`PySequence_GetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_GetItem`, after trying the "
"subscription via the :c:member:`~PyMappingMethods.mp_subscript` slot. This "
"slot must be filled for the :c:func:`PySequence_Check` function to return "
"``1``, it can be ``NULL`` otherwise."
msgstr ""
"Ця функція використовується :c:func:`PySequence_GetItem` і має такий самий "
"підпис. Він також використовується :c:func:`PyObject_GetItem` після спроби "
"підписки через слот :c:member:`~PyMappingMethods.mp_subscript`. Цей слот має "
"бути заповнений, щоб функція :c:func:`PySequence_Check` повертала ``1``, "
"інакше вона може бути ``NULL``."

#: ../../c-api/typeobj.rst:2169
msgid ""
"Negative indexes are handled as follows: if the :attr:`sq_length` slot is "
"filled, it is called and the sequence length is used to compute a positive "
"index which is passed to :attr:`sq_item`.  If :attr:`sq_length` is ``NULL``, "
"the index is passed as is to the function."
msgstr ""
"Негативні індекси обробляються таким чином: якщо слот :attr:`sq_length` "
"заповнений, він викликається, і довжина послідовності використовується для "
"обчислення позитивного індексу, який передається в :attr:`sq_item`. Якщо :"
"attr:`sq_length` дорівнює ``NULL``, індекс передається до функції як є."

#: ../../c-api/typeobj.rst:2176
msgid ""
"This function is used by :c:func:`PySequence_SetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_SetItem` and :c:func:"
"`PyObject_DelItem`, after trying the item assignment and deletion via the :c:"
"member:`~PyMappingMethods.mp_ass_subscript` slot. This slot may be left to "
"``NULL`` if the object does not support item assignment and deletion."
msgstr ""
"Ця функція використовується :c:func:`PySequence_SetItem` і має такий самий "
"підпис. Він також використовується :c:func:`PyObject_SetItem` і :c:func:"
"`PyObject_DelItem` після спроби призначення та видалення елемента через "
"слот :c:member:`~PyMappingMethods.mp_ass_subscript`. Цей слот можна залишити "
"``NULL``, якщо об’єкт не підтримує призначення та видалення елементів."

#: ../../c-api/typeobj.rst:2185
msgid ""
"This function may be used by :c:func:`PySequence_Contains` and has the same "
"signature.  This slot may be left to ``NULL``, in this case :c:func:`!"
"PySequence_Contains` simply traverses the sequence until it finds a match."
msgstr ""
"Ця функція може використовуватися :c:func:`PySequence_Contains` і має такий "
"самий підпис. Цей слот можна залишити ``NULL``, у цьому випадку :c:func:`!"
"PySequence_Contains` просто обходить послідовність, поки не знайде збіг."

#: ../../c-api/typeobj.rst:2192
msgid ""
"This function is used by :c:func:`PySequence_InPlaceConcat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceConcat` "
"will fall back to :c:func:`PySequence_Concat`.  It is also used by the "
"augmented assignment ``+=``, after trying numeric in-place addition via the :"
"c:member:`~PyNumberMethods.nb_inplace_add` slot."
msgstr ""
"Ця функція використовується :c:func:`PySequence_InPlaceConcat` і має такий "
"самий підпис. Він повинен змінити свій перший операнд і повернути його. Цей "
"слот можна залишити ``NULL``, у цьому випадку :c:func:`!"
"PySequence_InPlaceConcat` повернеться до :c:func:`PySequence_Concat`. Він "
"також використовується розширеним призначенням ``+=`` після спроби додавання "
"чисел на місці через слот :c:member:`~PyNumberMethods.nb_inplace_add`."

#: ../../c-api/typeobj.rst:2201
msgid ""
"This function is used by :c:func:`PySequence_InPlaceRepeat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceRepeat` "
"will fall back to :c:func:`PySequence_Repeat`.  It is also used by the "
"augmented assignment ``*=``, after trying numeric in-place multiplication "
"via the :c:member:`~PyNumberMethods.nb_inplace_multiply` slot."
msgstr ""
"Ця функція використовується :c:func:`PySequence_InPlaceRepeat` і має такий "
"самий підпис. Він повинен змінити свій перший операнд і повернути його. Цей "
"слот можна залишити ``NULL``, у цьому випадку :c:func:`!"
"PySequence_InPlaceRepeat` повернеться до :c:func:`PySequence_Repeat`. Він "
"також використовується розширеним призначенням ``*=`` після спроби числового "
"множення на місці через слот :c:member:`~PyNumberMethods."
"nb_inplace_multiply`."

#: ../../c-api/typeobj.rst:2212
msgid "Buffer Object Structures"
msgstr "Буферні об'єктні структури"

#: ../../c-api/typeobj.rst:2220
msgid ""
"This structure holds pointers to the functions required by the :ref:`Buffer "
"protocol <bufferobjects>`. The protocol defines how an exporter object can "
"expose its internal data to consumer objects."
msgstr ""
"Ця структура містить покажчики на функції, необхідні для :ref:`протоколу "
"буфера <bufferobjects>`. Протокол визначає, як об’єкт-експортер може "
"надавати свої внутрішні дані об’єктам-споживачам."

#: ../../c-api/typeobj.rst:2226 ../../c-api/typeobj.rst:2275
#: ../../c-api/typeobj.rst:2328 ../../c-api/typeobj.rst:2339
#: ../../c-api/typeobj.rst:2351
msgid "The signature of this function is::"
msgstr "Сигнатура цієї функції:"

#: ../../c-api/typeobj.rst:2230
msgid ""
"Handle a request to *exporter* to fill in *view* as specified by *flags*. "
"Except for point (3), an implementation of this function MUST take these "
"steps:"
msgstr ""
"Обробляти запит до *exporter* для заповнення *view*, як зазначено *flags*. "
"За винятком пункту (3), реалізація цієї функції ПОВИННА виконувати такі дії:"

#: ../../c-api/typeobj.rst:2234
msgid ""
"Check if the request can be met. If not, raise :c:data:`PyExc_BufferError`, "
"set :c:data:`view->obj` to ``NULL`` and return ``-1``."
msgstr ""

#: ../../c-api/typeobj.rst:2237
msgid "Fill in the requested fields."
msgstr "Заповніть необхідні поля."

#: ../../c-api/typeobj.rst:2239
msgid "Increment an internal counter for the number of exports."
msgstr "Збільшити внутрішній лічильник для кількості експортів."

#: ../../c-api/typeobj.rst:2241
msgid ""
"Set :c:data:`view->obj` to *exporter* and increment :c:data:`view->obj`."
msgstr ""

#: ../../c-api/typeobj.rst:2243
msgid "Return ``0``."
msgstr "Retorna ``0``."

#: ../../c-api/typeobj.rst:2245
msgid ""
"If *exporter* is part of a chain or tree of buffer providers, two main "
"schemes can be used:"
msgstr ""
"Якщо *експортер* є частиною ланцюжка або дерева постачальників буферів, "
"можна використовувати дві основні схеми:"

#: ../../c-api/typeobj.rst:2248
msgid ""
"Re-export: Each member of the tree acts as the exporting object and sets :c:"
"data:`view->obj` to a new reference to itself."
msgstr ""

#: ../../c-api/typeobj.rst:2251
msgid ""
"Redirect: The buffer request is redirected to the root object of the tree. "
"Here, :c:data:`view->obj` will be a new reference to the root object."
msgstr ""

#: ../../c-api/typeobj.rst:2255
msgid ""
"The individual fields of *view* are described in section :ref:`Buffer "
"structure <buffer-structure>`, the rules how an exporter must react to "
"specific requests are in section :ref:`Buffer request types <buffer-request-"
"types>`."
msgstr ""
"Окремі поля *view* описані в розділі :ref:`Структура буфера <buffer-"
"structure>`, правила, як експортер повинен реагувати на конкретні запити, "
"знаходяться в розділі :ref:`Типи запитів буфера <buffer-request-types>`."

#: ../../c-api/typeobj.rst:2260
msgid ""
"All memory pointed to in the :c:type:`Py_buffer` structure belongs to the "
"exporter and must remain valid until there are no consumers left. :c:member:"
"`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer."
"strides`, :c:member:`~Py_buffer.suboffsets` and :c:member:`~Py_buffer."
"internal` are read-only for the consumer."
msgstr ""
"Уся пам’ять, на яку вказує структура :c:type:`Py_buffer`, належить "
"експортеру та має залишатися чинною, доки не залишиться споживачів. :c:"
"member:`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:"
"`~Py_buffer.strides`, :c:member:`~Py_buffer.suboffsets` та :c:member:"
"`~Py_buffer.internal` доступні лише для читання для споживача."

#: ../../c-api/typeobj.rst:2267
msgid ""
":c:func:`PyBuffer_FillInfo` provides an easy way of exposing a simple bytes "
"buffer while dealing correctly with all request types."
msgstr ""
":c:func:`PyBuffer_FillInfo` забезпечує простий спосіб відкрити простий буфер "
"байтів, правильно обробляючи всі типи запитів."

#: ../../c-api/typeobj.rst:2270
msgid ""
":c:func:`PyObject_GetBuffer` is the interface for the consumer that wraps "
"this function."
msgstr ""
":c:func:`PyObject_GetBuffer` — це інтерфейс для споживача, який обертає цю "
"функцію."

#: ../../c-api/typeobj.rst:2279
msgid ""
"Handle a request to release the resources of the buffer. If no resources "
"need to be released, :c:member:`PyBufferProcs.bf_releasebuffer` may be "
"``NULL``. Otherwise, a standard implementation of this function will take "
"these optional steps:"
msgstr ""
"Обробляти запит на звільнення ресурсів буфера. Якщо не потрібно звільняти "
"ресурси, :c:member:`PyBufferProcs.bf_releasebuffer` може мати значення "
"``NULL``. В іншому випадку стандартна реалізація цієї функції виконає "
"наступні додаткові дії:"

#: ../../c-api/typeobj.rst:2284
msgid "Decrement an internal counter for the number of exports."
msgstr "Зменшити внутрішній лічильник для кількості експортів."

#: ../../c-api/typeobj.rst:2286
msgid "If the counter is ``0``, free all memory associated with *view*."
msgstr "Якщо лічильник ``0``, звільнити всю пам'ять, пов'язану з *view*."

#: ../../c-api/typeobj.rst:2288
msgid ""
"The exporter MUST use the :c:member:`~Py_buffer.internal` field to keep "
"track of buffer-specific resources. This field is guaranteed to remain "
"constant, while a consumer MAY pass a copy of the original buffer as the "
"*view* argument."
msgstr ""
"Експортер ПОВИНЕН використовувати поле :c:member:`~Py_buffer.internal`, щоб "
"відстежувати ресурси, пов’язані з буфером. Це поле гарантовано залишається "
"постійним, тоді як споживач МОЖЕ передати копію вихідного буфера як аргумент "
"*view*."

#: ../../c-api/typeobj.rst:2294
msgid ""
"This function MUST NOT decrement :c:data:`view->obj`, since that is done "
"automatically in :c:func:`PyBuffer_Release` (this scheme is useful for "
"breaking reference cycles)."
msgstr ""

#: ../../c-api/typeobj.rst:2299
msgid ""
":c:func:`PyBuffer_Release` is the interface for the consumer that wraps this "
"function."
msgstr ""
":c:func:`PyBuffer_Release` — це інтерфейс для споживача, який обертає цю "
"функцію."

#: ../../c-api/typeobj.rst:2307
msgid "Async Object Structures"
msgstr "Асинхронні об'єктні структури"

#: ../../c-api/typeobj.rst:2315
msgid ""
"This structure holds pointers to the functions required to implement :term:"
"`awaitable` and :term:`asynchronous iterator` objects."
msgstr ""
"Ця структура містить покажчики на функції, необхідні для реалізації "
"об’єктів :term:`awaitable` і :term:`asynchronous iterator`."

#: ../../c-api/typeobj.rst:2332
msgid ""
"The returned object must be an iterator, i.e. :c:func:`PyIter_Check` must "
"return ``1`` for it."
msgstr ""

#: ../../c-api/typeobj.rst:2335
msgid ""
"This slot may be set to ``NULL`` if an object is not an :term:`awaitable`."
msgstr ""
"Цей слот може мати значення ``NULL``, якщо об’єкт не є :term:`awaitable`."

#: ../../c-api/typeobj.rst:2343
msgid ""
"Must return an :term:`asynchronous iterator` object. See :meth:`__anext__` "
"for details."
msgstr ""
"Має повертати об’єкт :term:`asynchronous iterator`. Докладніше див. :meth:"
"`__anext__`."

#: ../../c-api/typeobj.rst:2346
msgid ""
"This slot may be set to ``NULL`` if an object does not implement "
"asynchronous iteration protocol."
msgstr ""
"Цей слот може мати значення ``NULL``, якщо об’єкт не реалізує протокол "
"асинхронної ітерації."

#: ../../c-api/typeobj.rst:2355
msgid ""
"Must return an :term:`awaitable` object.  See :meth:`__anext__` for details. "
"This slot may be set to ``NULL``."
msgstr ""
"Має повертати об’єкт :term:`awaitable`. Докладніше див. :meth:`__anext__`. "
"Цей слот може мати значення ``NULL``."

#: ../../c-api/typeobj.rst:2362
msgid "Slot Type typedefs"
msgstr "Типи слотів"

#: ../../c-api/typeobj.rst:2366
msgid ""
"The purpose of this function is to separate memory allocation from memory "
"initialization.  It should return a pointer to a block of memory of adequate "
"length for the instance, suitably aligned, and initialized to zeros, but "
"with :attr:`ob_refcnt` set to ``1`` and :attr:`ob_type` set to the type "
"argument.  If the type's :c:member:`~PyTypeObject.tp_itemsize` is non-zero, "
"the object's :attr:`ob_size` field should be initialized to *nitems* and the "
"length of the allocated memory block should be ``tp_basicsize + "
"nitems*tp_itemsize``, rounded up to a multiple of ``sizeof(void*)``; "
"otherwise, *nitems* is not used and the length of the block should be :c:"
"member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"Метою цієї функції є відокремлення виділення пам’яті від ініціалізації "
"пам’яті. Він має повертати вказівник на блок пам’яті адекватної довжини для "
"екземпляра, відповідним чином вирівняний та ініціалізований нулями, але з :"
"attr:`ob_refcnt`, встановленим на ``1``, і :attr:`ob_type`, встановленим на "
"аргумент типу. Якщо тип :c:member:`~PyTypeObject.tp_itemsize` відмінний від "
"нуля, поле :attr:`ob_size` об’єкта має бути ініціалізовано *nitems*, а "
"довжина виділеного блоку пам’яті має бути ``tp_basicsize + nitems "
"*tp_itemsize``, округлений до кратного ``sizeof(void*)``; інакше *nitems* не "
"використовується, а довжина блоку має бути :c:member:`~PyTypeObject."
"tp_basicsize`."

#: ../../c-api/typeobj.rst:2376
msgid ""
"This function should not do any other instance initialization, not even to "
"allocate additional memory; that should be done by :c:member:`~PyTypeObject."
"tp_new`."
msgstr ""
"Ця функція не повинна виконувати будь-яку іншу ініціалізацію екземпляра, "
"навіть не для виділення додаткової пам’яті; це має зробити :c:member:"
"`~PyTypeObject.tp_new`."

#: ../../c-api/typeobj.rst:2383
msgid "See :c:member:`~PyTypeObject.tp_free`."
msgstr "Lihat :c:member:`~PyTypeObject.tp_free`."

#: ../../c-api/typeobj.rst:2387
msgid "See :c:member:`~PyTypeObject.tp_new`."
msgstr "Lihat :c:member:`~PyTypeObject.tp_new`."

#: ../../c-api/typeobj.rst:2391
msgid "See :c:member:`~PyTypeObject.tp_init`."
msgstr "Lihat :c:member:`~PyTypeObject.tp_init`."

#: ../../c-api/typeobj.rst:2395
msgid "See :c:member:`~PyTypeObject.tp_repr`."
msgstr "Lihat :c:member:`~PyTypeObject.tp_repr`."

#: ../../c-api/typeobj.rst:2399 ../../c-api/typeobj.rst:2408
msgid "Return the value of the named attribute for the object."
msgstr "Повертає значення названого атрибута для об’єкта."

#: ../../c-api/typeobj.rst:2403 ../../c-api/typeobj.rst:2414
msgid ""
"Set the value of the named attribute for the object. The value argument is "
"set to ``NULL`` to delete the attribute."
msgstr ""
"Установіть для об’єкта значення іменованого атрибута. Аргумент значення має "
"значення ``NULL``, щоб видалити атрибут."

#: ../../c-api/typeobj.rst:2410
msgid "See :c:member:`~PyTypeObject.tp_getattro`."
msgstr "Lihat :c:member:`~PyTypeObject.tp_getattro`."

#: ../../c-api/typeobj.rst:2417
msgid "See :c:member:`~PyTypeObject.tp_setattro`."
msgstr "Lihat :c:member:`~PyTypeObject.tp_setattro`."

#: ../../c-api/typeobj.rst:2421
msgid "See :c:member:`~PyTypeObject.tp_descrget`."
msgstr ""

#: ../../c-api/typeobj.rst:2425
msgid "See :c:member:`~PyTypeObject.tp_descrset`."
msgstr ""

#: ../../c-api/typeobj.rst:2429
msgid "See :c:member:`~PyTypeObject.tp_hash`."
msgstr "Lihat :c:member:`~PyTypeObject.tp_hash`."

#: ../../c-api/typeobj.rst:2433
msgid "See :c:member:`~PyTypeObject.tp_richcompare`."
msgstr "Lihat :c:member:`~PyTypeObject.tp_richcompare`."

#: ../../c-api/typeobj.rst:2437
msgid "See :c:member:`~PyTypeObject.tp_iter`."
msgstr "Lihat :c:member:`~PyTypeObject.tp_iter`."

#: ../../c-api/typeobj.rst:2441
msgid "See :c:member:`~PyTypeObject.tp_iternext`."
msgstr "Lihat :c:member:`~PyTypeObject.tp_iternext`."

#: ../../c-api/typeobj.rst:2467
msgid "Examples"
msgstr "Exemplos"

#: ../../c-api/typeobj.rst:2469
msgid ""
"The following are simple examples of Python type definitions.  They include "
"common usage you may encounter.  Some demonstrate tricky corner cases.  For "
"more examples, practical info, and a tutorial, see :ref:`defining-new-types` "
"and :ref:`new-types-topics`."
msgstr ""
"Нижче наведено прості приклади визначень типів Python. Вони включають "
"загальне використання, з яким ви можете зіткнутися. Деякі демонструють хитрі "
"кутові випадки. Більше прикладів, практичної інформації та підручника див. :"
"ref:`defining-new-types` і :ref:`new-types-topics`."

#: ../../c-api/typeobj.rst:2474
msgid "A basic static type::"
msgstr ""

#: ../../c-api/typeobj.rst:2491
msgid ""
"You may also find older code (especially in the CPython code base) with a "
"more verbose initializer::"
msgstr ""
"Ви також можете знайти старіший код (особливо в кодовій базі CPython) із "
"більш детальним ініціалізатором:"

#: ../../c-api/typeobj.rst:2535
msgid "A type that supports weakrefs, instance dicts, and hashing::"
msgstr "Тип, який підтримує слабкі посилання, екземпляри dicts і хешування::"

#: ../../c-api/typeobj.rst:2562
msgid ""
"A str subclass that cannot be subclassed and cannot be called to create "
"instances (e.g. uses a separate factory func)::"
msgstr ""

#: ../../c-api/typeobj.rst:2581
msgid "The simplest static type (with fixed-length instances)::"
msgstr ""

#: ../../c-api/typeobj.rst:2592
msgid "The simplest static type (with variable-length instances)::"
msgstr ""

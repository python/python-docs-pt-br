# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-30 16:53+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../howto/urllib2.rst:5
msgid "HOWTO Fetch Internet Resources Using The urllib Package"
msgstr "Como buscar recursos da Internet usando o pacote urllib"

#: ../../howto/urllib2.rst:0
msgid "Author"
msgstr "Autor"

#: ../../howto/urllib2.rst:7
msgid "`Michael Foord <https://agileabstractions.com/>`_"
msgstr "`Michael Foord <https://agileabstractions.com/>`_"

#: ../../howto/urllib2.rst:11
msgid ""
"There is a French translation of an earlier revision of this HOWTO, "
"available at `urllib2 - Le Manuel manquant <https://web.archive.org/"
"web/20200910051922/http://www.voidspace.org.uk/python/articles/"
"urllib2_francais.shtml>`_."
msgstr ""

#: ../../howto/urllib2.rst:18
msgid "Introduction"
msgstr "Introdução"

#: ../../howto/urllib2.rst:22
msgid ""
"You may also find useful the following article on fetching web resources "
"with Python:"
msgstr ""
"Você também pode achar útil o seguinte artigo na busca de recursos da web "
"com Python:"

#: ../../howto/urllib2.rst:25
msgid ""
"`Basic Authentication <https://web.archive.org/web/20201215133350/http://www."
"voidspace.org.uk/python/articles/authentication.shtml>`_"
msgstr ""
"`Autenticação Básica <https://web.archive.org/web/20201215133350/http://www."
"voidspace.org.uk/python/articles/authentication.shtml>`_"

#: ../../howto/urllib2.rst:27
msgid "A tutorial on *Basic Authentication*, with examples in Python."
msgstr "Um tutorial sobre *Autenticação Básica*, com exemplos em Python."

#: ../../howto/urllib2.rst:29
msgid ""
"**urllib.request** is a Python module for fetching URLs (Uniform Resource "
"Locators). It offers a very simple interface, in the form of the *urlopen* "
"function. This is capable of fetching URLs using a variety of different "
"protocols. It also offers a slightly more complex interface for handling "
"common situations - like basic authentication, cookies, proxies and so on. "
"These are provided by objects called handlers and openers."
msgstr ""
"**urllib.request** é um modulo Python para buscar URLs (Uniform Resource "
"Locators). Ele oferece uma interface muito simples, na forma da função "
"*urlopen*. Este é capaz de buscar URLs usando uma variedade de diferentes "
"protocolos. Ele também oferece uma interface um pouco mais complexa para "
"lidar com situações comuns - como autenticação básica, cookies, proxies e "
"assim por diante. Estes são fornecidos por objetos chamados handlers "
"(manipuladores) e openers (abridores)."

#: ../../howto/urllib2.rst:36
msgid ""
"urllib.request supports fetching URLs for many \"URL schemes\" (identified "
"by the string before the ``\":\"`` in URL - for example ``\"ftp\"`` is the "
"URL scheme of ``\"ftp://python.org/\"``) using their associated network "
"protocols (e.g. FTP, HTTP). This tutorial focuses on the most common case, "
"HTTP."
msgstr ""
"urllib.request suporta o acesso a URLs por meio de vários \"esquemas de "
"URL\" (identificados pela string antes de ``\":\"`` na URL - por exemplo "
"``\"ftp\"`` é o esquema de URL em ``\"ftp://python.org/\"``) usando o "
"protocolo de rede associado a ele (como FTP e HTTP). Este tutorial foca no "
"caso mais comum, HTTP."

#: ../../howto/urllib2.rst:41
msgid ""
"For straightforward situations *urlopen* is very easy to use. But as soon as "
"you encounter errors or non-trivial cases when opening HTTP URLs, you will "
"need some understanding of the HyperText Transfer Protocol. The most "
"comprehensive and authoritative reference to HTTP is :rfc:`2616`. This is a "
"technical document and not intended to be easy to read. This HOWTO aims to "
"illustrate using *urllib*, with enough detail about HTTP to help you "
"through. It is not intended to replace the :mod:`urllib.request` docs, but "
"is supplementary to them."
msgstr ""
"Para situações simples \"urlopen\" é muito fácil de usar. Mas assim que você "
"se depara com erros ou casos não triviais ao abrir URLs HTTP, você vai "
"precisar entender um pouco mais do HyperText Transfer Protocol. A literatura "
"de referência mais reconhecida e compreensível para o HTTP é :rfc:`2616`. "
"Ela é um documento técnico e não foi feita para ser fácil de ler. Este "
"documento busca ilustrar o uso de *urllib* com detalhes suficientes sobre "
"HTTP para te permitir seguir adiante. Ele não tem a intenção de substituir a "
"documentação do :mod:`urllib.request`, mas é suplementar a ela."

#: ../../howto/urllib2.rst:51
msgid "Fetching URLs"
msgstr "Acessando URLs"

#: ../../howto/urllib2.rst:53
msgid "The simplest way to use urllib.request is as follows::"
msgstr "O modo mais simples de usar urllib.request é o seguinte::"

#: ../../howto/urllib2.rst:59
msgid ""
"If you wish to retrieve a resource via URL and store it in a temporary "
"location, you can do so via the :func:`shutil.copyfileobj` and :func:"
"`tempfile.NamedTemporaryFile` functions::"
msgstr ""
"Se você deseja obter um recurso via URL e guardá-lo em uma localização "
"temporária, você pode fazê-lo com as funções :func:`shutil.copyfileobj` e :"
"func:`tempfile.NamedTemporaryFile`::"

#: ../../howto/urllib2.rst:74
msgid ""
"Many uses of urllib will be that simple (note that instead of an 'http:' URL "
"we could have used a URL starting with 'ftp:', 'file:', etc.).  However, "
"it's the purpose of this tutorial to explain the more complicated cases, "
"concentrating on HTTP."
msgstr ""
"Muitos usos de urllib são simples assim (repare que ao invés de uma URL "
"'http:' nós poderíamos ter usado uma string URL começando com 'ftp:', "
"'file:', etc.).. No entanto, o propósito deste tutorial é explicar casos "
"mais complicados, concentrando em HTTP."

#: ../../howto/urllib2.rst:79
msgid ""
"HTTP is based on requests and responses - the client makes requests and "
"servers send responses. urllib.request mirrors this with a ``Request`` "
"object which represents the HTTP request you are making. In its simplest "
"form you create a Request object that specifies the URL you want to fetch. "
"Calling ``urlopen`` with this Request object returns a response object for "
"the URL requested. This response is a file-like object, which means you can "
"for example call ``.read()`` on the response::"
msgstr ""
"HTTP é baseado em solicitações (requests) e respostas (responses) - o "
"cliente faz solicitações e os servidores mandam respostas. urllib.request "
"espelha isto com um objeto ``Request`` que representa a solicitação HTTP que "
"você está fazendo. Na sua forma mais simples, você cria um objeto Request "
"que especifica a URL que você quer acessar. Chamar ``urlopen`` com este "
"objeto Request retorna um objeto de resposta para a URL solicitada. Essa "
"resposta é um objeto arquivo ou similar, o que significa que você pode, por "
"exemplo, chamar ``.read()`` na resposta::"

#: ../../howto/urllib2.rst:93
msgid ""
"Note that urllib.request makes use of the same Request interface to handle "
"all URL schemes.  For example, you can make an FTP request like so::"
msgstr ""
"Note que urllib.request usa a mesma interface Request para tratar todos os "
"esquemas URL. Por exemplo, você pode fazer uma solicitação FTP da seguinte "
"forma::"

#: ../../howto/urllib2.rst:98
msgid ""
"In the case of HTTP, there are two extra things that Request objects allow "
"you to do: First, you can pass data to be sent to the server.  Second, you "
"can pass extra information (\"metadata\") *about* the data or about the "
"request itself, to the server - this information is sent as HTTP "
"\"headers\".  Let's look at each of these in turn."
msgstr ""
"No caso do HTTP, há duas coisas extras que os objetos Request permitem que "
"você faça: primeiro, você pode passar dados a serem enviados ao servidor. "
"Segundo, você pode passar informações extras (\"metadados\") *sobre* os "
"dados ou sobre a própria solicitação para o servidor — essas informações são "
"enviadas como \"cabeçalhos\" HTTP. Vamos analisar cada um deles "
"separadamente."

#: ../../howto/urllib2.rst:105
msgid "Data"
msgstr "Dados"

#: ../../howto/urllib2.rst:107
msgid ""
"Sometimes you want to send data to a URL (often the URL will refer to a CGI "
"(Common Gateway Interface) script or other web application). With HTTP, this "
"is often done using what's known as a **POST** request. This is often what "
"your browser does when you submit a HTML form that you filled in on the web. "
"Not all POSTs have to come from forms: you can use a POST to transmit "
"arbitrary data to your own application. In the common case of HTML forms, "
"the data needs to be encoded in a standard way, and then passed to the "
"Request object as the ``data`` argument. The encoding is done using a "
"function from the :mod:`urllib.parse` library. ::"
msgstr ""
"Às vezes, você deseja enviar dados para uma URL (geralmente a URL se refere "
"a um script CGI (Common Gateway Interface) ou outra aplicação web). Com "
"HTTP, isso geralmente é feito usando o que é conhecido como uma solicitação "
"**POST**. Isso geralmente é o que seu navegador faz quando você envia um "
"formulário HTML preenchido na web. Nem todos os POSTs precisam vir de "
"formulários: você pode usar um POST para transmitir dados arbitrários para "
"sua própria aplicação. No caso comum de formulários HTML, os dados precisam "
"ser codificados de forma padrão e, em seguida, passados ​​para o objeto "
"Request como o argumento ``data``. A codificação é feita usando uma função "
"da biblioteca :mod:`urllib.parse`. ::"

#: ../../howto/urllib2.rst:131
msgid ""
"Note that other encodings are sometimes required (e.g. for file upload from "
"HTML forms - see `HTML Specification, Form Submission <https://www.w3.org/TR/"
"REC-html40/interact/forms.html#h-17.13>`_ for more details)."
msgstr ""
"Observe que outras codificações às vezes são necessárias (por exemplo, para "
"envio de arquivos de formulários HTML - consulte `HTML Specification, Form "
"Submission <https://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13>`_ "
"para mais detalhes)."

#: ../../howto/urllib2.rst:136
msgid ""
"If you do not pass the ``data`` argument, urllib uses a **GET** request. One "
"way in which GET and POST requests differ is that POST requests often have "
"\"side-effects\": they change the state of the system in some way (for "
"example by placing an order with the website for a hundredweight of tinned "
"spam to be delivered to your door).  Though the HTTP standard makes it clear "
"that POSTs are intended to *always* cause side-effects, and GET requests "
"*never* to cause side-effects, nothing prevents a GET request from having "
"side-effects, nor a POST requests from having no side-effects. Data can also "
"be passed in an HTTP GET request by encoding it in the URL itself."
msgstr ""
"Se você não passar o argumento ``data``, o urllib usará uma requisição "
"**GET**. Uma diferença entre requisições GET e POST é que as requisições "
"POST frequentemente têm \"efeitos colaterais\": elas alteram o estado do "
"sistema de alguma forma (por exemplo, ao fazer um pedido ao site para que "
"cem libras de spam enlatado sejam entregues em sua porta). Embora o padrão "
"HTTP deixe claro que os POSTs devem *sempre* causar efeitos colaterais, e as "
"requisições GET *nunca* causar efeitos colaterais, nada impede que uma "
"requisição GET tenha efeitos colaterais, nem que uma requisição POST não "
"tenha efeitos colaterais. Dados também podem ser passados ​​em uma requisição "
"HTTP GET codificando-os na própria URL."

#: ../../howto/urllib2.rst:146
msgid "This is done as follows::"
msgstr "Isso é feito como abaixo::"

#: ../../howto/urllib2.rst:161
msgid ""
"Notice that the full URL is created by adding a ``?`` to the URL, followed "
"by the encoded values."
msgstr ""
"Observe que o URL completo é criado adicionando um ``?`` ao URL, seguido "
"pelos valores codificados."

#: ../../howto/urllib2.rst:165
msgid "Headers"
msgstr "Cabeçalhos"

#: ../../howto/urllib2.rst:167
msgid ""
"We'll discuss here one particular HTTP header, to illustrate how to add "
"headers to your HTTP request."
msgstr ""
"Discutiremos aqui um cabeçalho HTTP específico para ilustrar como adicionar "
"cabeçalhos à sua solicitação HTTP."

#: ../../howto/urllib2.rst:170
msgid ""
"Some websites [#]_ dislike being browsed by programs, or send different "
"versions to different browsers [#]_. By default urllib identifies itself as "
"``Python-urllib/x.y`` (where ``x`` and ``y`` are the major and minor version "
"numbers of the Python release, e.g. ``Python-urllib/2.5``), which may "
"confuse the site, or just plain not work. The way a browser identifies "
"itself is through the ``User-Agent`` header [#]_. When you create a Request "
"object you can pass a dictionary of headers in. The following example makes "
"the same request as above, but identifies itself as a version of Internet "
"Explorer [#]_. ::"
msgstr ""
"Alguns sites [#]_ não gostam de ser navegados por programas ou enviam "
"versões diferentes para navegadores diferentes [#]_. Por padrão, urllib se "
"identifica como ``Python-urllib/x.y`` (onde ``x`` e ``y`` são os números de "
"versão principal e secundária da versão do Python, por exemplo, ``Python-"
"urllib/2.5``), o que pode confundir o site ou simplesmente não funcionar. A "
"forma como um navegador se identifica é através do cabeçalho ``User-Agent`` "
"[#]_. Ao criar um objeto Request, você pode passar um dicionário de "
"cabeçalhos. O exemplo a seguir faz a mesma solicitação acima, mas se "
"identifica como uma versão do Internet Explorer [#]_. ::"

#: ../../howto/urllib2.rst:197
msgid ""
"The response also has two useful methods. See the section on `info and "
"geturl`_ which comes after we have a look at what happens when things go "
"wrong."
msgstr ""
"A resposta também possui dois métodos úteis. Veja a seção sobre `info e "
"geturl`_, que vem depois de analisarmos o que acontece quando as coisas dão "
"errado."

#: ../../howto/urllib2.rst:202
msgid "Handling Exceptions"
msgstr "Tratamento de exceções"

#: ../../howto/urllib2.rst:204
msgid ""
"*urlopen* raises :exc:`URLError` when it cannot handle a response (though as "
"usual with Python APIs, built-in exceptions such as :exc:`ValueError`, :exc:"
"`TypeError` etc. may also be raised)."
msgstr ""

#: ../../howto/urllib2.rst:208
msgid ""
":exc:`HTTPError` is the subclass of :exc:`URLError` raised in the specific "
"case of HTTP URLs."
msgstr ""

#: ../../howto/urllib2.rst:211
msgid "The exception classes are exported from the :mod:`urllib.error` module."
msgstr "As classes de exceção são exportadas do módulo :mod:`urllib.error`."

#: ../../howto/urllib2.rst:214
msgid "URLError"
msgstr "URLError"

#: ../../howto/urllib2.rst:216
msgid ""
"Often, URLError is raised because there is no network connection (no route "
"to the specified server), or the specified server doesn't exist.  In this "
"case, the exception raised will have a 'reason' attribute, which is a tuple "
"containing an error code and a text error message."
msgstr ""
"Frequentemente, URLError é levantada porque não há conexão de rede (nenhuma "
"rota para o servidor especificado) ou o servidor especificado não existe. "
"Nesse caso, a exceção gerada terá um atributo \"reason\", que é uma tupla "
"contendo um código de erro e uma mensagem de erro em texto."

#: ../../howto/urllib2.rst:221
msgid "e.g. ::"
msgstr "Por exemplo ::"

#: ../../howto/urllib2.rst:232
msgid "HTTPError"
msgstr "HTTPError"

#: ../../howto/urllib2.rst:234
msgid ""
"Every HTTP response from the server contains a numeric \"status code\". "
"Sometimes the status code indicates that the server is unable to fulfil the "
"request. The default handlers will handle some of these responses for you "
"(for example, if the response is a \"redirection\" that requests the client "
"fetch the document from a different URL, urllib will handle that for you). "
"For those it can't handle, urlopen will raise an :exc:`HTTPError`. Typical "
"errors include '404' (page not found), '403' (request forbidden), and "
"'401' (authentication required)."
msgstr ""

#: ../../howto/urllib2.rst:242
msgid ""
"See section 10 of :rfc:`2616` for a reference on all the HTTP error codes."
msgstr ""
"Veja a seção 10 de :rfc:`2616` para uma referência sobre todos os códigos de "
"erro HTTP."

#: ../../howto/urllib2.rst:244
msgid ""
"The :exc:`HTTPError` instance raised will have an integer 'code' attribute, "
"which corresponds to the error sent by the server."
msgstr ""

#: ../../howto/urllib2.rst:248
msgid "Error Codes"
msgstr "Códigos de erro"

#: ../../howto/urllib2.rst:250
msgid ""
"Because the default handlers handle redirects (codes in the 300 range), and "
"codes in the 100--299 range indicate success, you will usually only see "
"error codes in the 400--599 range."
msgstr ""
"Como os tratadores padrão controlam redirecionamentos (códigos no intervalo "
"300) e códigos no intervalo 100-299 indicam sucesso, normalmente você verá "
"apenas códigos de erro no intervalo 400-599."

#: ../../howto/urllib2.rst:254
msgid ""
":attr:`http.server.BaseHTTPRequestHandler.responses` is a useful dictionary "
"of response codes in that shows all the response codes used by :rfc:`2616`. "
"The dictionary is reproduced here for convenience ::"
msgstr ""

#: ../../howto/urllib2.rst:326
msgid ""
"When an error is raised the server responds by returning an HTTP error code "
"*and* an error page. You can use the :exc:`HTTPError` instance as a response "
"on the page returned. This means that as well as the code attribute, it also "
"has read, geturl, and info, methods as returned by the ``urllib.response`` "
"module::"
msgstr ""

#: ../../howto/urllib2.rst:346
msgid "Wrapping it Up"
msgstr "Resumindo"

#: ../../howto/urllib2.rst:348
msgid ""
"So if you want to be prepared for :exc:`HTTPError` *or* :exc:`URLError` "
"there are two basic approaches. I prefer the second approach."
msgstr ""

#: ../../howto/urllib2.rst:352
msgid "Number 1"
msgstr "Número 1"

#: ../../howto/urllib2.rst:374
msgid ""
"The ``except HTTPError`` *must* come first, otherwise ``except URLError`` "
"will *also* catch an :exc:`HTTPError`."
msgstr ""

#: ../../howto/urllib2.rst:378
msgid "Number 2"
msgstr "Número 2"

#: ../../howto/urllib2.rst:399
msgid "info and geturl"
msgstr "info e geturl"

#: ../../howto/urllib2.rst:401
msgid ""
"The response returned by urlopen (or the :exc:`HTTPError` instance) has two "
"useful methods :meth:`info` and :meth:`geturl` and is defined in the module :"
"mod:`urllib.response`.."
msgstr ""

#: ../../howto/urllib2.rst:405
msgid ""
"**geturl** - this returns the real URL of the page fetched. This is useful "
"because ``urlopen`` (or the opener object used) may have followed a "
"redirect. The URL of the page fetched may not be the same as the URL "
"requested."
msgstr ""
"**geturl** - Isso retorna a URL real da página recuperada. Isso é útil "
"porque ``urlopen`` (ou o objeto de abertura utilizado) pode ter seguido um "
"redirecionamento. A URL da página recuperada pode não ser a mesma que a URL "
"solicitada."

#: ../../howto/urllib2.rst:409
msgid ""
"**info** - this returns a dictionary-like object that describes the page "
"fetched, particularly the headers sent by the server. It is currently an :"
"class:`http.client.HTTPMessage` instance."
msgstr ""
"**info** - Isso retorna um objeto semelhante a um dicionário que descreve a "
"página recuperada, particularmente os cabeçalhos enviados pelo servidor. "
"Atualmente, é uma instância de :class:`http.client.HTTPMessage`."

#: ../../howto/urllib2.rst:413
msgid ""
"Typical headers include 'Content-length', 'Content-type', and so on. See the "
"`Quick Reference to HTTP Headers <https://jkorpela.fi/http.html>`_ for a "
"useful listing of HTTP headers with brief explanations of their meaning and "
"use."
msgstr ""
"Cabeçalhos típicos incluem 'Content-length', 'Content-type' e assim por "
"diante. Consulte a \"Referência rápida para cabeçalhos HTTP <https://"
"jkorpela.fi/http.html>\" para obter uma lista útil de cabeçalhos HTTP com "
"breves explicações sobre seu significado e uso."

#: ../../howto/urllib2.rst:420
msgid "Openers and Handlers"
msgstr "Abridores e tratadores"

#: ../../howto/urllib2.rst:422
msgid ""
"When you fetch a URL you use an opener (an instance of the perhaps "
"confusingly named :class:`urllib.request.OpenerDirector`). Normally we have "
"been using the default opener - via ``urlopen`` - but you can create custom "
"openers. Openers use handlers. All the \"heavy lifting\" is done by the "
"handlers. Each handler knows how to open URLs for a particular URL scheme "
"(http, ftp, etc.), or how to handle an aspect of URL opening, for example "
"HTTP redirections or HTTP cookies."
msgstr ""
"Ao buscar uma URL, você usa um abridor (uma instância do talvez confuso "
"nome :class:`urllib.request.OpenerDirector`). Normalmente, usamos o abridor "
"padrão - via ``urlopen`` -, mas você pode criar abridores personalizados. Os "
"abridores usam manipuladores. Todo o \"trabalho pesado\" é feito pelos "
"manipuladores. Cada manipulador sabe como abrir URLs para um esquema de URL "
"específico (http, ftp, etc.) ou como lidar com um aspecto da abertura de "
"URL, por exemplo, redirecionamentos HTTP ou cookies HTTP."

#: ../../howto/urllib2.rst:430
msgid ""
"You will want to create openers if you want to fetch URLs with specific "
"handlers installed, for example to get an opener that handles cookies, or to "
"get an opener that does not handle redirections."
msgstr ""
"Você vai querer criar abridores se quiser buscar URLs com manipuladores "
"específicos instalados, por exemplo, para obter um abridor que manipule "
"cookies ou para obter um abridor que não manipule redirecionamentos."

#: ../../howto/urllib2.rst:434
msgid ""
"To create an opener, instantiate an ``OpenerDirector``, and then call ``."
"add_handler(some_handler_instance)`` repeatedly."
msgstr ""
"Para criar um abridor, instancie um ``OpenerDirector`` e então chame ``."
"add_handler(some_handler_instance)`` repetidamente."

#: ../../howto/urllib2.rst:437
msgid ""
"Alternatively, you can use ``build_opener``, which is a convenience function "
"for creating opener objects with a single function call.  ``build_opener`` "
"adds several handlers by default, but provides a quick way to add more and/"
"or override the default handlers."
msgstr ""
"Como alternativa, você pode usar ``build_opener``, que é uma função "
"conveniente para criar objetos de abertura com uma única chamada de função. "
"``build_opener`` adiciona vários tratadores por padrão, mas fornece uma "
"maneira rápida de adicionar mais e/ou substituir os tratadores padrão."

#: ../../howto/urllib2.rst:442
msgid ""
"Other sorts of handlers you might want to can handle proxies, "
"authentication, and other common but slightly specialised situations."
msgstr ""
"Outros tipos de manipuladores que você pode querer podem lidar com proxies, "
"autenticação e outras situações comuns, mas um pouco especializadas."

#: ../../howto/urllib2.rst:445
msgid ""
"``install_opener`` can be used to make an ``opener`` object the (global) "
"default opener. This means that calls to ``urlopen`` will use the opener you "
"have installed."
msgstr ""
"``install_opener`` pode ser usado para tornar um objeto ``opener`` o abridor "
"padrão (global). Isso significa que chamadas para ``urlopen`` usarão o "
"abridor que você instalou."

#: ../../howto/urllib2.rst:449
msgid ""
"Opener objects have an ``open`` method, which can be called directly to "
"fetch urls in the same way as the ``urlopen`` function: there's no need to "
"call ``install_opener``, except as a convenience."
msgstr ""
"Objetos abridores têm um método ``open``, que pode ser chamado diretamente "
"para buscar URLs da mesma forma que a função ``urlopen``: não há necessidade "
"de chamar ``install_opener``, exceto por conveniência."

#: ../../howto/urllib2.rst:455
msgid "Basic Authentication"
msgstr "Autenticação básica"

#: ../../howto/urllib2.rst:457
msgid ""
"To illustrate creating and installing a handler we will use the "
"``HTTPBasicAuthHandler``. For a more detailed discussion of this subject -- "
"including an explanation of how Basic Authentication works - see the `Basic "
"Authentication Tutorial <http://www.voidspace.org.uk/python/articles/"
"authentication.shtml>`_."
msgstr ""

#: ../../howto/urllib2.rst:463
msgid ""
"When authentication is required, the server sends a header (as well as the "
"401 error code) requesting authentication.  This specifies the "
"authentication scheme and a 'realm'. The header looks like: ``WWW-"
"Authenticate: SCHEME realm=\"REALM\"``."
msgstr ""
"Quando a autenticação é necessária, o servidor envia um cabeçalho (e o "
"código de erro 401) solicitando autenticação. Isso especifica o esquema de "
"autenticação e um \"domínio\". O cabeçalho se parece com: ``WWW-"
"Authenticate: SCHEME realm=\"REALM\"``."

#: ../../howto/urllib2.rst:468
msgid "e.g."
msgstr "Por exemplo:"

#: ../../howto/urllib2.rst:475
msgid ""
"The client should then retry the request with the appropriate name and "
"password for the realm included as a header in the request. This is 'basic "
"authentication'. In order to simplify this process we can create an instance "
"of ``HTTPBasicAuthHandler`` and an opener to use this handler."
msgstr ""
"O cliente deve então tentar a solicitação novamente com o nome e a senha "
"apropriados para o domínio incluídos como cabeçalho na solicitação. Isso é "
"\"autenticação básica\". Para simplificar esse processo, podemos criar uma "
"instância de ``HTTPBasicAuthHandler`` e um opener para usar esse manipulador."

#: ../../howto/urllib2.rst:480
msgid ""
"The ``HTTPBasicAuthHandler`` uses an object called a password manager to "
"handle the mapping of URLs and realms to passwords and usernames. If you "
"know what the realm is (from the authentication header sent by the server), "
"then you can use a ``HTTPPasswordMgr``. Frequently one doesn't care what the "
"realm is. In that case, it is convenient to use "
"``HTTPPasswordMgrWithDefaultRealm``. This allows you to specify a default "
"username and password for a URL. This will be supplied in the absence of you "
"providing an alternative combination for a specific realm. We indicate this "
"by providing ``None`` as the realm argument to the ``add_password`` method."
msgstr ""
"O ``HTTPBasicAuthHandler`` usa um objeto chamado gerenciador de senhas para "
"manipular o mapeamento de URLs e domínios para senhas e nomes de usuário. Se "
"você souber qual é o domínio (a partir do cabeçalho de autenticação enviado "
"pelo servidor), poderá usar um ``HTTPPasswordMgr``. Frequentemente, não "
"importa qual seja o domínio. Nesse caso, é conveniente usar "
"``HTTPPasswordMgrWithDefaultRealm``. Isso permite que você especifique um "
"nome de usuário e uma senha padrão para uma URL. Isso será fornecido caso "
"você não forneça uma combinação alternativa para um domínio específico. "
"Indicamos isso fornecendo ``None`` como argumento de domínio para o método "
"``add_password``."

#: ../../howto/urllib2.rst:490
msgid ""
"The top-level URL is the first URL that requires authentication. URLs "
"\"deeper\" than the URL you pass to .add_password() will also match. ::"
msgstr ""
"A URL de nível superior é a primeira URL que requer autenticação. URLs "
"\"mais profundas\" que a URL que você passa para .add_password() também "
"corresponderão. ::"

#: ../../howto/urllib2.rst:515
msgid ""
"In the above example we only supplied our ``HTTPBasicAuthHandler`` to "
"``build_opener``. By default openers have the handlers for normal situations "
"-- ``ProxyHandler`` (if a proxy setting such as an :envvar:`http_proxy` "
"environment variable is set), ``UnknownHandler``, ``HTTPHandler``, "
"``HTTPDefaultErrorHandler``, ``HTTPRedirectHandler``, ``FTPHandler``, "
"``FileHandler``, ``DataHandler``, ``HTTPErrorProcessor``."
msgstr ""

#: ../../howto/urllib2.rst:522
msgid ""
"``top_level_url`` is in fact *either* a full URL (including the 'http:' "
"scheme component and the hostname and optionally the port number) e.g. "
"``\"http://example.com/\"`` *or* an \"authority\" (i.e. the hostname, "
"optionally including the port number) e.g. ``\"example.com\"`` or "
"``\"example.com:8080\"`` (the latter example includes a port number).  The "
"authority, if present, must NOT contain the \"userinfo\" component - for "
"example ``\"joe:password@example.com\"`` is not correct."
msgstr ""
"``top_level_url`` é, na verdade, *ou* uma URL completa (incluindo o "
"componente do esquema 'http:', o nome do host e, opcionalmente, o número da "
"porta), por exemplo, ``\"http://example.com/\"``, *ou* uma "
"\"autoridade\" (ou seja, o nome do host, incluindo, opcionalmente, o número "
"da porta), por exemplo, ``\"example.com\"`` ou ``\"example.com:8080\"`` "
"(este último exemplo inclui um número de porta). A autoridade, se presente, "
"NÃO deve conter o componente \"userinfo\" - por exemplo, ``\"joe:"
"senha@example.com\"`` não está correto."

#: ../../howto/urllib2.rst:532
msgid "Proxies"
msgstr "Proxies"

#: ../../howto/urllib2.rst:534
msgid ""
"**urllib** will auto-detect your proxy settings and use those. This is "
"through the ``ProxyHandler``, which is part of the normal handler chain when "
"a proxy setting is detected.  Normally that's a good thing, but there are "
"occasions when it may not be helpful [#]_. One way to do this is to setup "
"our own ``ProxyHandler``, with no proxies defined. This is done using "
"similar steps to setting up a `Basic Authentication`_ handler: ::"
msgstr ""
"**urllib** detectará automaticamente suas configurações de proxy e as "
"utilizará. Isso ocorre por meio do ``ProxyHandler``, que faz parte da cadeia "
"de manipuladores normal quando uma configuração de proxy é detectada. "
"Normalmente, isso é bom, mas há ocasiões em que pode não ser útil [#]_. Uma "
"maneira de fazer isso é configurar nosso próprio ``ProxyHandler``, sem "
"proxies definidos. Isso é feito seguindo etapas semelhantes à configuração "
"de um manipulador de `autenticação básica`_: ::"

#: ../../howto/urllib2.rst:547
msgid ""
"Currently ``urllib.request`` *does not* support fetching of ``https`` "
"locations through a proxy.  However, this can be enabled by extending urllib."
"request as shown in the recipe [#]_."
msgstr ""
"Atualmente, ``urllib.request`` *não* oferece suporte à busca de locais "
"``https`` por meio de um proxy. No entanto, isso pode ser habilitado "
"estendendo urllib.request, conforme mostrado na receita [#]_."

#: ../../howto/urllib2.rst:553
msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; see "
"the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"``HTTP_PROXY`` será ignorado se uma variável ``REQUEST_METHOD`` estiver "
"definida; veja a documentação em :func:`~urllib.request.getproxies`."

#: ../../howto/urllib2.rst:558
msgid "Sockets and Layers"
msgstr "Socekts e camadas"

#: ../../howto/urllib2.rst:560
msgid ""
"The Python support for fetching resources from the web is layered.  urllib "
"uses the :mod:`http.client` library, which in turn uses the socket library."
msgstr ""
"O suporte do Python para buscar recursos web é em camadas. urllib usa a "
"biblioteca :mod:`http.client`, que por sua vez usa a biblioteca de sockets."

#: ../../howto/urllib2.rst:563
msgid ""
"As of Python 2.3 you can specify how long a socket should wait for a "
"response before timing out. This can be useful in applications which have to "
"fetch web pages. By default the socket module has *no timeout* and can hang. "
"Currently, the socket timeout is not exposed at the http.client or urllib."
"request levels. However, you can set the default timeout globally for all "
"sockets using ::"
msgstr ""
"A partir do Python 2.3, você pode especificar quanto tempo um soquete deve "
"aguardar por uma resposta antes de atingir o tempo limite. Isso pode ser "
"útil em aplicações que precisam buscar páginas web. Por padrão, o módulo "
"socket *não tem tempo limite* e pode travar. Atualmente, o tempo limite do "
"soquete não é exposto nos níveis http.client ou urllib.request. No entanto, "
"você pode definir o tempo limite padrão globalmente para todos os soquetes "
"usando ::"

#: ../../howto/urllib2.rst:586
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../howto/urllib2.rst:588
msgid "This document was reviewed and revised by John Lee."
msgstr "Este documento foi revisado e revisado por John Lee."

#: ../../howto/urllib2.rst:590
msgid "Google for example."
msgstr "Google, por exemplo."

#: ../../howto/urllib2.rst:591
msgid ""
"Browser sniffing is a very bad practice for website design - building sites "
"using web standards is much more sensible. Unfortunately a lot of sites "
"still send different versions to different browsers."
msgstr ""
"A detecção de navegadores é uma prática muito ruim para o design de sites; "
"construir sites usando padrões web é muito mais sensato. Infelizmente, "
"muitos sites ainda enviam versões diferentes para navegadores diferentes."

#: ../../howto/urllib2.rst:594
msgid ""
"The user agent for MSIE 6 is *'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT "
"5.1; SV1; .NET CLR 1.1.4322)'*"
msgstr ""
"O user agent para MSIE 6 é *'Mozilla/4.0 (compatível; MSIE 6.0; Windows NT "
"5.1; SV1; .NET CLR 1.1.4322)'*"

#: ../../howto/urllib2.rst:596
msgid ""
"For details of more HTTP request headers, see `Quick Reference to HTTP "
"Headers`_."
msgstr ""
"Para obter detalhes sobre mais cabeçalhos de solicitação HTTP, consulte "
"`Referência rápida para cabeçalhos HTTP`_."

#: ../../howto/urllib2.rst:598
msgid ""
"In my case I have to use a proxy to access the internet at work. If you "
"attempt to fetch *localhost* URLs through this proxy it blocks them. IE is "
"set to use the proxy, which urllib picks up on. In order to test scripts "
"with a localhost server, I have to prevent urllib from using the proxy."
msgstr ""
"No meu caso, preciso usar um proxy para acessar a internet no trabalho. Se "
"você tentar buscar URLs *localhost* por meio desse proxy, ele as bloqueia. O "
"IE está configurado para usar o proxy, que o urllib detecta. Para testar "
"scripts com um servidor localhost, preciso impedir que o urllib use o proxy."

#: ../../howto/urllib2.rst:603
msgid ""
"urllib opener for SSL proxy (CONNECT method): `ASPN Cookbook Recipe <https://"
"code.activestate.com/recipes/456195/>`_."
msgstr ""

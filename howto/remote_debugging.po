# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-11 14:18+0000\n"
"PO-Revision-Date: 2025-08-15 19:00+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../howto/remote_debugging.rst:4
msgid "Remote debugging attachment protocol"
msgstr "Protocolo de anexação de depuração remota"

#: ../../howto/remote_debugging.rst:6
msgid ""
"This section describes the low-level protocol that enables external tools to "
"inject and execute a Python script within a running CPython process."
msgstr ""
"Esta seção descreve o protocolo de baixo nível que permite que ferramentas "
"externas injetem e executem um script Python dentro de um processo CPython "
"em execução."

#: ../../howto/remote_debugging.rst:9
msgid ""
"This mechanism forms the basis of the :func:`sys.remote_exec` function, "
"which instructs a remote Python process to execute a ``.py`` file. However, "
"this section does not document the usage of that function. Instead, it "
"provides a detailed explanation of the underlying protocol, which takes as "
"input the ``pid`` of a target Python process and the path to a Python source "
"file to be executed. This information supports independent reimplementation "
"of the protocol, regardless of programming language."
msgstr ""
"Este mecanismo forma a base da função :func:`sys.remote_exec`, que instrui "
"um processo Python remoto a executar um arquivo ``.py``. No entanto, esta "
"seção não documenta o uso dessa função. Em vez disso, fornece uma explicação "
"detalhada do protocolo subjacente, que recebe como entrada o ``pid`` de um "
"processo Python de destino e o caminho para um arquivo-fonte Python a ser "
"executado. Essas informações permitem a reimplementação independente do "
"protocolo, independentemente da linguagem de programação."

#: ../../howto/remote_debugging.rst:19
msgid ""
"The execution of the injected script depends on the interpreter reaching a "
"safe evaluation point. As a result, execution may be delayed depending on "
"the runtime state of the target process."
msgstr ""
"A execução do script injetado depende de o interpretador atingir um ponto de "
"avaliação seguro. Como resultado, a execução pode ser atrasada dependendo do "
"estado de execução do processo de destino."

#: ../../howto/remote_debugging.rst:23
msgid ""
"Once injected, the script is executed by the interpreter within the target "
"process the next time a safe evaluation point is reached. This approach "
"enables remote execution capabilities without modifying the behavior or "
"structure of the running Python application."
msgstr ""
"Uma vez injetado, o script é executado pelo interpretador dentro do processo "
"de destino na próxima vez que um ponto de avaliação seguro for atingido. "
"Essa abordagem permite recursos de execução remota sem modificar o "
"comportamento ou a estrutura da aplicação Python em execução."

#: ../../howto/remote_debugging.rst:28
msgid ""
"Subsequent sections provide a step-by-step description of the protocol, "
"including techniques for locating interpreter structures in memory, safely "
"accessing internal fields, and triggering code execution. Platform-specific "
"variations are noted where applicable, and example implementations are "
"included to clarify each operation."
msgstr ""
"As seções subsequentes fornecem uma descrição passo a passo do protocolo, "
"incluindo técnicas para localizar estruturas do interpretador na memória, "
"acessar campos internos com segurança e disparar a execução de código. "
"Variações específicas da plataforma são indicadas quando aplicável, e "
"exemplos de implementação são incluídos para esclarecer cada operação."

#: ../../howto/remote_debugging.rst:35
msgid "Locating the PyRuntime structure"
msgstr "Localizando a estrutura de PyRuntime"

#: ../../howto/remote_debugging.rst:37
msgid ""
"CPython places the ``PyRuntime`` structure in a dedicated binary section to "
"help external tools find it at runtime. The name and format of this section "
"vary by platform. For example, ``.PyRuntime`` is used on ELF systems, and "
"``__DATA,__PyRuntime`` is used on macOS. Tools can find the offset of this "
"structure by examining the binary on disk."
msgstr ""
"O CPython coloca a estrutura ``PyRuntime`` em uma seção binária dedicada "
"para ajudar ferramentas externas a encontrá-la em tempo de execução. O nome "
"e o formato desta seção variam de acordo com a plataforma. Por exemplo, ``."
"PyRuntime`` é usado em sistemas ELF, e ``__DATA,__PyRuntime`` é usado no "
"macOS. As ferramentas podem encontrar o deslocamento desta estrutura "
"examinando o binário no disco."

#: ../../howto/remote_debugging.rst:43
msgid ""
"The ``PyRuntime`` structure contains CPython’s global interpreter state and "
"provides access to other internal data, including the list of interpreters, "
"thread states, and debugger support fields."
msgstr ""
"A estrutura ``PyRuntime`` contém o estado global do interpretador do CPython "
"e fornece acesso a outros dados internos, incluindo a lista de "
"interpretadores, estados de thread e campos de suporte do depurador."

#: ../../howto/remote_debugging.rst:47
msgid ""
"To work with a remote Python process, a debugger must first find the memory "
"address of the ``PyRuntime`` structure in the target process. This address "
"can’t be hardcoded or calculated from a symbol name, because it depends on "
"where the operating system loaded the binary."
msgstr ""
"Para trabalhar com um processo Python remoto, um depurador precisa primeiro "
"encontrar o endereço de memória da estrutura ``PyRuntime`` no processo de "
"destino. Este endereço não pode ser codificado ou calculado a partir de um "
"nome de símbolo, pois depende de onde o sistema operacional carregou o "
"binário."

#: ../../howto/remote_debugging.rst:52
msgid ""
"The method for finding ``PyRuntime`` depends on the platform, but the steps "
"are the same in general:"
msgstr ""
"O método para encontrar ``PyRuntime`` depende da plataforma, mas os passos "
"são os mesmos em geral:"

#: ../../howto/remote_debugging.rst:55
msgid ""
"Find the base address where the Python binary or shared library was loaded "
"in the target process."
msgstr ""
"Encontrar o endereço base onde o binário Python ou a biblioteca "
"compartilhada foi carregada no processo de destino."

#: ../../howto/remote_debugging.rst:57
msgid ""
"Use the on-disk binary to locate the offset of the ``.PyRuntime`` section."
msgstr ""
"Usar o binário no disco para localizar o deslocamento da seção ``."
"PyRuntime``."

#: ../../howto/remote_debugging.rst:58
msgid ""
"Add the section offset to the base address to compute the address in memory."
msgstr ""
"Adicionar o deslocamento da seção ao endereço base para calcular o endereço "
"na memória."

#: ../../howto/remote_debugging.rst:60
msgid ""
"The sections below explain how to do this on each supported platform and "
"include example code."
msgstr ""
"As seções abaixo explicam como fazer isso em cada plataforma suportada e "
"incluem código de exemplo."

#: ../../howto/remote_debugging.rst:64
msgid "Linux (ELF)"
msgstr "Linux (ELF)"

#: ../../howto/remote_debugging.rst:65
msgid "To find the ``PyRuntime`` structure on Linux:"
msgstr "Para encontrar a estrutura de ``PyRuntime`` no Linux:"

#: ../../howto/remote_debugging.rst:67
msgid ""
"Read the process’s memory map (for example, ``/proc/<pid>/maps``) to find "
"the address where the Python executable or ``libpython`` was loaded."
msgstr ""
"Lê o mapa de memória do processo (por exemplo, ``/proc/<pid>/maps``) para "
"encontrar o endereço onde o executável Python ou ``libpython`` foi carregado."

#: ../../howto/remote_debugging.rst:69
msgid ""
"Parse the ELF section headers in the binary to get the offset of the ``."
"PyRuntime`` section."
msgstr ""
"Analise os cabeçalhos da seção ELF no binário para obter o deslocamento da "
"seção ``.PyRuntime``."

#: ../../howto/remote_debugging.rst:71
msgid ""
"Add that offset to the base address from step 1 to get the memory address of "
"``PyRuntime``."
msgstr ""
"Adicione esse deslocamento ao endereço base da etapa 1 para obter o endereço "
"de memória de ``PyRuntime``."

#: ../../howto/remote_debugging.rst:74 ../../howto/remote_debugging.rst:136
#: ../../howto/remote_debugging.rst:206 ../../howto/remote_debugging.rst:475
msgid "The following is an example implementation::"
msgstr "A seguir está um exemplo de implementação::"

#: ../../howto/remote_debugging.rst:76
msgid ""
"def find_py_runtime_linux(pid: int) -> int:\n"
"    # Step 1: Try to find the Python executable in memory\n"
"    binary_path, base_address = find_mapped_binary(\n"
"        pid, name_contains=\"python\"\n"
"    )\n"
"\n"
"    # Step 2: Fallback to shared library if executable is not found\n"
"    if binary_path is None:\n"
"        binary_path, base_address = find_mapped_binary(\n"
"            pid, name_contains=\"libpython\"\n"
"        )\n"
"\n"
"    # Step 3: Parse ELF headers to get .PyRuntime section offset\n"
"    section_offset = parse_elf_section_offset(\n"
"        binary_path, \".PyRuntime\"\n"
"    )\n"
"\n"
"    # Step 4: Compute PyRuntime address in memory\n"
"    return base_address + section_offset"
msgstr ""
"def find_py_runtime_linux(pid: int) -> int:\n"
"    # Etapa 1: tenta encontrar o executável Python na memória\n"
"    binary_path, base_address = find_mapped_binary(\n"
"        pid, name_contains=\"python\"\n"
"    )\n"
"\n"
"    # Etapa 2: recorre à biblioteca compartilhada se não encontrar o "
"executável\n"
"    if binary_path is None:\n"
"        binary_path, base_address = find_mapped_binary(\n"
"            pid, name_contains=\"libpython\"\n"
"        )\n"
"\n"
"    # Etapa 3: analisa os cabeçalhos ELF para obter o deslocamento da seção ."
"PyRuntime\n"
"    section_offset = parse_elf_section_offset(\n"
"        binary_path, \".PyRuntime\"\n"
"    )\n"
"\n"
"    # Etapa 4: calcula o endereço de PyRuntime na memória\n"
"    return base_address + section_offset"

#: ../../howto/remote_debugging.rst:97
msgid ""
"On Linux systems, there are two main approaches to read memory from another "
"process. The first is through the ``/proc`` filesystem, specifically by "
"reading from ``/proc/[pid]/mem`` which provides direct access to the "
"process's memory. This requires appropriate permissions - either being the "
"same user as the target process or having root access. The second approach "
"is using the ``process_vm_readv()`` system call which provides a more "
"efficient way to copy memory between processes. While ptrace's "
"``PTRACE_PEEKTEXT`` operation can also be used to read memory, it is "
"significantly slower as it only reads one word at a time and requires "
"multiple context switches between the tracer and tracee processes."
msgstr ""
"Em sistemas Linux, existem duas abordagens principais para ler memória de "
"outro processo. A primeira é através do sistema de arquivos ``/proc``, "
"especificamente lendo de ``/proc/[pid]/mem``, que fornece acesso direto à "
"memória do processo. Isso requer permissões apropriadas – seja o mesmo "
"usuário do processo alvo ou ter acesso root. A segunda abordagem é usar a "
"chamada de sistema ``process_vm_readv()``, que fornece uma maneira mais "
"eficiente de copiar memória entre processos. Embora a operação "
"``PTRACE_PEEKTEXT`` do ptrace também possa ser usada para ler memória, ela é "
"significativamente mais lenta, pois lê apenas uma palavra por vez e requer "
"múltiplas trocas de contexto entre os processos rastreador e rastreado."

#: ../../howto/remote_debugging.rst:108
msgid ""
"For parsing ELF sections, the process involves reading and interpreting the "
"ELF file format structures from the binary file on disk. The ELF header "
"contains a pointer to the section header table. Each section header contains "
"metadata about a section including its name (stored in a separate string "
"table), offset, and size. To find a specific section like .PyRuntime, you "
"need to walk through these headers and match the section name. The section "
"header then provides the offset where that section exists in the file, which "
"can be used to calculate its runtime address when the binary is loaded into "
"memory."
msgstr ""
"Para analisar seções ELF, o processo envolve a leitura e a interpretação das "
"estruturas do formato de arquivo ELF do arquivo binário em disco. O "
"cabeçalho ELF contém um ponteiro para a tabela de cabeçalhos de seção. Cada "
"cabeçalho de seção contém metadados sobre uma seção, incluindo seu nome "
"(armazenado em uma tabela de strings separada), deslocamento e tamanho. Para "
"encontrar uma seção específica, como .PyRuntime, você precisa percorrer "
"esses cabeçalhos e encontrar o nome da seção. O cabeçalho de seção então "
"fornece o deslocamento onde essa seção existe no arquivo, que pode ser usado "
"para calcular seu endereço de tempo de execução quando o binário é carregado "
"na memória."

#: ../../howto/remote_debugging.rst:117
msgid ""
"You can read more about the ELF file format in the `ELF specification "
"<https://en.wikipedia.org/wiki/Executable_and_Linkable_Format>`_."
msgstr ""
"Você pode ler mais sobre o formato de arquivo ELF na `especificação do ELF "
"<https://en.wikipedia.org/wiki/Executable_and_Linkable_Format>`_."

#: ../../howto/remote_debugging.rst:122
msgid "macOS (Mach-O)"
msgstr "macOS (Mach-O)"

#: ../../howto/remote_debugging.rst:123
msgid "To find the ``PyRuntime`` structure on macOS:"
msgstr "Para encontrar a estrutura de ``PyRuntime`` no macOS:"

#: ../../howto/remote_debugging.rst:125
msgid ""
"Call ``task_for_pid()`` to get the ``mach_port_t`` task port for the target "
"process. This handle is needed to read memory using APIs like "
"``mach_vm_read_overwrite`` and ``mach_vm_region``."
msgstr ""
"Chame ``task_for_pid()`` para obter a porta da tarefa ``mach_port_t`` para o "
"processo de destino. Este identificador é necessário para ler memória usando "
"APIs como ``mach_vm_read_overwrite`` e ``mach_vm_region``."

#: ../../howto/remote_debugging.rst:128
msgid ""
"Scan the memory regions to find the one containing the Python executable or "
"``libpython``."
msgstr ""
"Examine as regiões da memória para encontrar aquela que contém o executável "
"Python ou ``libpython``."

#: ../../howto/remote_debugging.rst:130
msgid ""
"Load the binary file from disk and parse the Mach-O headers to find the "
"section named ``PyRuntime`` in the ``__DATA`` segment.  On macOS, symbol "
"names are automatically prefixed with an underscore, so the ``PyRuntime`` "
"symbol appears as ``_PyRuntime`` in the symbol table, but the section name "
"is not affected."
msgstr ""
"Carregue o arquivo binário do disco e analise os cabeçalhos do Mach-O para "
"encontrar a seção chamada ``PyRuntime`` no segmento ``__DATA``. No macOS, os "
"nomes dos símbolos são prefixados automaticamente com um sublinhado, de modo "
"que o símbolo ``PyRuntime`` aparece como ``_PyRuntime`` na tabela de "
"símbolos, mas o nome da seção não é afetado."

#: ../../howto/remote_debugging.rst:138
msgid ""
"def find_py_runtime_macos(pid: int) -> int:\n"
"    # Step 1: Get access to the process's memory\n"
"    handle = get_memory_access_handle(pid)\n"
"\n"
"    # Step 2: Try to find the Python executable in memory\n"
"    binary_path, base_address = find_mapped_binary(\n"
"        handle, name_contains=\"python\"\n"
"    )\n"
"\n"
"    # Step 3: Fallback to libpython if the executable is not found\n"
"    if binary_path is None:\n"
"        binary_path, base_address = find_mapped_binary(\n"
"            handle, name_contains=\"libpython\"\n"
"        )\n"
"\n"
"    # Step 4: Parse Mach-O headers to get __DATA,__PyRuntime section offset\n"
"    section_offset = parse_macho_section_offset(\n"
"        binary_path, \"__DATA\", \"__PyRuntime\"\n"
"    )\n"
"\n"
"    # Step 5: Compute the PyRuntime address in memory\n"
"    return base_address + section_offset"
msgstr ""
"def find_py_runtime_macos(pid: int) -> int:\n"
"    # Etapa 1: obtém acesso à memória do processo\n"
"    handle = get_memory_access_handle(pid)\n"
"\n"
"    # Etapa 2: tenta encontrar o executável Python na memória\n"
"    binary_path, base_address = find_mapped_binary(\n"
"        handle, name_contains=\"python\"\n"
"    )\n"
"\n"
"    # Etapa 2: recorre à biblioteca compartilhada se não encontrar o "
"executável\n"
"    if binary_path is None:\n"
"        binary_path, base_address = find_mapped_binary(\n"
"            handle, name_contains=\"libpython\"\n"
"        )\n"
"\n"
"    # Etapa 4: analisa os cabeçalhos Mach-O para obter o deslocamento da "
"seção __DATA,__PyRuntime\n"
"    section_offset = parse_macho_section_offset(\n"
"        binary_path, \"__DATA\", \"__PyRuntime\"\n"
"    )\n"
"\n"
"    # Etapa 5: calcula o endereço de PyRuntime na memória\n"
"    return base_address + section_offset"

#: ../../howto/remote_debugging.rst:161
msgid ""
"On macOS, accessing another process's memory requires using Mach-O specific "
"APIs and file formats. The first step is obtaining a ``task_port`` handle "
"via ``task_for_pid()``, which provides access to the target process's memory "
"space. This handle enables memory operations through APIs like "
"``mach_vm_read_overwrite()``."
msgstr ""
"No macOS, acessar a memória de outro processo requer o uso de APIs e "
"formatos de arquivo específicos do Mach-O. O primeiro passo é obter um "
"identificador ``task_port`` via ``task_for_pid()``, que fornece acesso ao "
"espaço de memória do processo de destino. Esse identificador permite "
"operações de memória por meio de APIs como ``mach_vm_read_overwrite()``."

#: ../../howto/remote_debugging.rst:167
msgid ""
"The process memory can be examined using ``mach_vm_region()`` to scan "
"through the virtual memory space, while ``proc_regionfilename()`` helps "
"identify which binary files are loaded at each memory region. When the "
"Python binary or library is found, its Mach-O headers need to be parsed to "
"locate the ``PyRuntime`` structure."
msgstr ""
"A memória do processo pode ser examinada usando ``mach_vm_region()`` para "
"varrer o espaço da memória virtual, enquanto ``proc_regionfilename()`` ajuda "
"a identificar quais arquivos binários são carregados em cada região da "
"memória. Quando o binário ou biblioteca Python é encontrado, seus cabeçalhos "
"Mach-O precisam ser analisados para localizar a estrutura ``PyRuntime``."

#: ../../howto/remote_debugging.rst:172
msgid ""
"The Mach-O format organizes code and data into segments and sections. The "
"``PyRuntime`` structure lives in a section named ``__PyRuntime`` within the "
"``__DATA`` segment. The actual runtime address calculation involves finding "
"the ``__TEXT`` segment which serves as the binary's base address, then "
"locating the ``__DATA`` segment containing our target section. The final "
"address is computed by combining the base address with the appropriate "
"section offsets from the Mach-O headers."
msgstr ""
"O formato Mach-O organiza código e dados em segmentos e seções. A estrutura "
"``PyRuntime`` reside em uma seção chamada ``__PyRuntime`` dentro do segmento "
"``__DATA``. O cálculo do endereço de tempo de execução envolve encontrar o "
"segmento ``__TEXT``, que serve como endereço base do binário, e então "
"localizar o segmento ``__DATA`` que contém nossa seção de destino. O "
"endereço final é calculado combinando o endereço base com os deslocamentos "
"de seção apropriados dos cabeçalhos do Mach-O."

#: ../../howto/remote_debugging.rst:180
msgid ""
"Note that accessing another process's memory on macOS typically requires "
"elevated privileges - either root access or special security entitlements "
"granted to the debugging process."
msgstr ""
"Observe que acessar a memória de outro processo no macOS normalmente requer "
"privilégios elevados — acesso root ou direitos de segurança especiais "
"concedidos ao processo de depuração."

#: ../../howto/remote_debugging.rst:186
msgid "Windows (PE)"
msgstr "Windows (PE)"

#: ../../howto/remote_debugging.rst:187
msgid "To find the ``PyRuntime`` structure on Windows:"
msgstr "Para encontrar a estrutura de ``PyRuntime`` no Windows:"

#: ../../howto/remote_debugging.rst:189
msgid ""
"Use the ToolHelp API to enumerate all modules loaded in the target process. "
"This is done using functions such as `CreateToolhelp32Snapshot <https://"
"learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-"
"createtoolhelp32snapshot>`_, `Module32First <https://learn.microsoft.com/en-"
"us/windows/win32/api/tlhelp32/nf-tlhelp32-module32first>`_, and "
"`Module32Next <https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/"
"nf-tlhelp32-module32next>`_."
msgstr ""
"Use a API ToolHelp para enumerar todos os módulos carregados no processo de "
"destino. Isso é feito usando funções como `CreateToolhelp32Snapshot <https://"
"learn.microsoft.com/pt-br/windows/win32/api/tlhelp32/nf-tlhelp32-"
"createtoolhelp32snapshot>`_, `Module32First <https://learn.microsoft.com/pt-"
"br/windows/win32/api/tlhelp32/nf-tlhelp32-module32first>`_ e `Module32Next "
"<https://learn.microsoft.com/pt-br/windows/win32/api/tlhelp32/nf-tlhelp32-"
"module32next>`_."

#: ../../howto/remote_debugging.rst:196
msgid ""
"Identify the module corresponding to :file:`python.exe` or :file:`python{XY}."
"dll`, where ``X`` and ``Y`` are the major and minor version numbers of the "
"Python version, and record its base address."
msgstr ""
"Identifique o módulo correspondente a :file:`python.exe` ou :file:"
"`python{XY}.dll`, onde ``X`` e ``Y`` são os números de versão principal e "
"secundária do Python, e registre seu endereço base."

#: ../../howto/remote_debugging.rst:199
msgid ""
"Locate the ``PyRuntim`` section. Due to the PE format's 8-character limit on "
"section names (defined as ``IMAGE_SIZEOF_SHORT_NAME``), the original name "
"``PyRuntime`` is truncated. This section contains the ``PyRuntime`` "
"structure."
msgstr ""
"Localize a seção ``PyRuntim``. Devido ao limite de 8 caracteres do formato "
"PE para nomes de seção (definido como ``IMAGE_SIZEOF_SHORT_NAME``), o nome "
"original ``PyRuntime`` está truncado. Esta seção contém a estrutura "
"``PyRuntime``."

#: ../../howto/remote_debugging.rst:203
msgid ""
"Retrieve the section’s relative virtual address (RVA) and add it to the base "
"address of the module."
msgstr ""
"Recupere o endereço virtual relativo (RVA) da seção e adicione-o ao endereço "
"base do módulo."

#: ../../howto/remote_debugging.rst:208
msgid ""
"def find_py_runtime_windows(pid: int) -> int:\n"
"    # Step 1: Try to find the Python executable in memory\n"
"    binary_path, base_address = find_loaded_module(\n"
"        pid, name_contains=\"python\"\n"
"    )\n"
"\n"
"    # Step 2: Fallback to shared pythonXY.dll if the executable is not\n"
"    # found\n"
"    if binary_path is None:\n"
"        binary_path, base_address = find_loaded_module(\n"
"            pid, name_contains=\"python3\"\n"
"        )\n"
"\n"
"    # Step 3: Parse PE section headers to get the RVA of the PyRuntime\n"
"    # section. The section name appears as \"PyRuntim\" due to the\n"
"    # 8-character limit defined by the PE format (IMAGE_SIZEOF_SHORT_NAME).\n"
"    section_rva = parse_pe_section_offset(binary_path, \"PyRuntim\")\n"
"\n"
"    # Step 4: Compute PyRuntime address in memory\n"
"    return base_address + section_rva"
msgstr ""
"def find_py_runtime_windows(pid: int) -> int:\n"
"    # Etapa 1: tenta encontrar o executável Python na memória\n"
"    binary_path, base_address = find_loaded_module(\n"
"        pid, name_contains=\"python\"\n"
"    )\n"
"\n"
"    # Etapa 2: recorre à pythonXY.dll compartilhada se não encontrar\n"
"    # o executável\n"
"    if binary_path is None:\n"
"        binary_path, base_address = find_loaded_module(\n"
"            pid, name_contains=\"python3\"\n"
"        )\n"
"\n"
"    # Etapa 3: analisa os cabeçalhos da seção PE para obter o RVA\n"
"    # da seção .PyRuntime. O nome da seção aparece como \"PyRuntim\"\n"
"    # devido ao limite de 8 caracteres definido pelo formato PE\n"
"    # (IMAGE_SIZEOF_SHORT_NAME).\n"
"    section_rva = parse_pe_section_offset(binary_path, \"PyRuntim\")\n"
"\n"
"    # Etapa 4: calcula o endereço de PyRuntime na memória\n"
"    return base_address + section_rva"

#: ../../howto/remote_debugging.rst:230
msgid ""
"On Windows, accessing another process's memory requires using the Windows "
"API functions like ``CreateToolhelp32Snapshot()`` and ``Module32First()/"
"Module32Next()`` to enumerate loaded modules. The ``OpenProcess()`` function "
"provides a handle to access the target process's memory space, enabling "
"memory operations through ``ReadProcessMemory()``."
msgstr ""
"No Windows, acessar a memória de outro processo requer o uso de funções da "
"API do Windows, como ``CreateToolhelp32Snapshot()`` e ``Module32First()/"
"Module32Next()``, para enumerar os módulos carregados. A função "
"``OpenProcess()`` fornece um identificador para acessar o espaço de memória "
"do processo de destino, permitindo operações de memória por meio de "
"``ReadProcessMemory()``."

#: ../../howto/remote_debugging.rst:236
msgid ""
"The process memory can be examined by enumerating loaded modules to find the "
"Python binary or DLL. When found, its PE headers need to be parsed to locate "
"the ``PyRuntime`` structure."
msgstr ""
"A memória do processo pode ser examinada enumerando os módulos carregados "
"para encontrar o binário ou DLL Python. Quando encontrados, seus cabeçalhos "
"PE precisam ser analisados para localizar a estrutura ``PyRuntime``."

#: ../../howto/remote_debugging.rst:240
msgid ""
"The PE format organizes code and data into sections. The ``PyRuntime`` "
"structure lives in a section named \"PyRuntim\" (truncated from "
"\"PyRuntime\" due to PE's 8-character name limit). The actual runtime "
"address calculation involves finding the module's base address from the "
"module entry, then locating our target section in the PE headers. The final "
"address is computed by combining the base address with the section's virtual "
"address from the PE section headers."
msgstr ""
"O formato PE organiza código e dados em seções. A estrutura de ``PyRuntime`` "
"reside em uma seção chamada \"PyRuntim\" (truncado de \"PyRuntime\" devido "
"ao limite de 8 caracteres para nomes do PE). O cálculo do endereço de tempo "
"de execução envolve encontrar o endereço base do módulo a partir da entrada "
"do módulo e, em seguida, localizar nossa seção de destino nos cabeçalhos do "
"PE. O endereço final é calculado combinando o endereço base com o endereço "
"virtual da seção, a partir dos cabeçalhos da seção do PE."

#: ../../howto/remote_debugging.rst:247
msgid ""
"Note that accessing another process's memory on Windows typically requires "
"appropriate privileges - either administrative access or the "
"``SeDebugPrivilege`` privilege granted to the debugging process."
msgstr ""
"Observe que acessar a memória de outro processo no Windows normalmente "
"requer privilégios apropriados — acesso administrativo ou o privilégio de "
"``SeDebugPrivilege`` concedidos ao processo de depuração."

#: ../../howto/remote_debugging.rst:253
msgid "Reading _Py_DebugOffsets"
msgstr "Lendo _Py_DebugOffsets"

#: ../../howto/remote_debugging.rst:255
msgid ""
"Once the address of the ``PyRuntime`` structure has been determined, the "
"next step is to read the ``_Py_DebugOffsets`` structure located at the "
"beginning of the ``PyRuntime`` block."
msgstr ""
"Depois que o endereço da estrutura ``PyRuntime`` for determinado, o próximo "
"passo é ler a estrutura ``_Py_DebugOffsets`` localizada no início do bloco "
"``PyRuntime``."

#: ../../howto/remote_debugging.rst:259
msgid ""
"This structure provides version-specific field offsets that are needed to "
"safely read interpreter and thread state memory. These offsets vary between "
"CPython versions and must be checked before use to ensure they are "
"compatible."
msgstr ""
"Esta estrutura fornece deslocamentos de campo específicos da versão, "
"necessários para ler com segurança a memória de estado de thread e do "
"interpretador. Esses deslocamentos variam entre as versões do CPython e "
"devem ser verificados antes do uso para garantir sua compatibilidade."

#: ../../howto/remote_debugging.rst:263
msgid "To read and check the debug offsets, follow these steps:"
msgstr "Para ler e verificar os deslocamentos de depuração, siga estas etapas:"

#: ../../howto/remote_debugging.rst:265
msgid ""
"Read memory from the target process starting at the ``PyRuntime`` address, "
"covering the same number of bytes as the ``_Py_DebugOffsets`` structure. "
"This structure is located at the very start of the ``PyRuntime`` memory "
"block. Its layout is defined in CPython’s internal headers and stays the "
"same within a given minor version, but may change in major versions."
msgstr ""
"Lê a memória do processo de destino, começando no endereço ``PyRuntime``, "
"cobrindo o mesmo número de bytes que a estrutura ``_Py_DebugOffsets``. Essa "
"estrutura está localizada no início do bloco de memória ``PyRuntime``. Seu "
"layout é definido nos cabeçalhos internos do CPython e permanece o mesmo em "
"uma determinada versão secundária, mas pode mudar em versões principais."

#: ../../howto/remote_debugging.rst:271
msgid "Check that the structure contains valid data:"
msgstr "Verifica se a estrutura contém dados válidos:"

#: ../../howto/remote_debugging.rst:273
msgid "The ``cookie`` field must match the expected debug marker."
msgstr ""
"O campo ``cookie`` deve corresponder ao marcador de depuração esperado."

#: ../../howto/remote_debugging.rst:274
msgid ""
"The ``version`` field must match the version of the Python interpreter used "
"by the debugger."
msgstr ""
"O campo ``version`` deve corresponder à versão do interpretador Python usado "
"pelo depurador."

#: ../../howto/remote_debugging.rst:276
msgid ""
"If either the debugger or the target process is using a pre-release version "
"(for example, an alpha, beta, or release candidate), the versions must match "
"exactly."
msgstr ""
"Se o depurador ou o processo de destino estiver usando uma versão de pré-"
"lançamento (por exemplo, uma versão alfa, beta ou candidata a lançamento), "
"as versões deverão corresponder exatamente."

#: ../../howto/remote_debugging.rst:279
msgid ""
"The ``free_threaded`` field must have the same value in both the debugger "
"and the target process."
msgstr ""
"O campo ``free_threaded`` deve ter o mesmo valor no depurador e no processo "
"de destino."

#: ../../howto/remote_debugging.rst:282
msgid ""
"If the structure is valid, the offsets it contains can be used to locate "
"fields in memory. If any check fails, the debugger should stop the operation "
"to avoid reading memory in the wrong format."
msgstr ""
"Se a estrutura for válida, os deslocamentos que ela contém podem ser usados "
"para localizar campos na memória. Se alguma verificação falhar, o depurador "
"deve interromper a operação para evitar a leitura da memória no formato "
"errado."

#: ../../howto/remote_debugging.rst:286
msgid ""
"The following is an example implementation that reads and checks "
"``_Py_DebugOffsets``::"
msgstr ""
"A seguir está um exemplo de implementação que lê e verifica "
"``_Py_DebugOffsets``::"

#: ../../howto/remote_debugging.rst:289
msgid ""
"def read_debug_offsets(pid: int, py_runtime_addr: int) -> DebugOffsets:\n"
"    # Step 1: Read memory from the target process at the PyRuntime address\n"
"    data = read_process_memory(\n"
"        pid, address=py_runtime_addr, size=DEBUG_OFFSETS_SIZE\n"
"    )\n"
"\n"
"    # Step 2: Deserialize the raw bytes into a _Py_DebugOffsets structure\n"
"    debug_offsets = parse_debug_offsets(data)\n"
"\n"
"    # Step 3: Validate the contents of the structure\n"
"    if debug_offsets.cookie != EXPECTED_COOKIE:\n"
"        raise RuntimeError(\"Invalid or missing debug cookie\")\n"
"    if debug_offsets.version != LOCAL_PYTHON_VERSION:\n"
"        raise RuntimeError(\n"
"            \"Mismatch between caller and target Python versions\"\n"
"        )\n"
"    if debug_offsets.free_threaded != LOCAL_FREE_THREADED:\n"
"        raise RuntimeError(\"Mismatch in free-threaded configuration\")\n"
"\n"
"    return debug_offsets"
msgstr ""
"def read_debug_offsets(pid: int, py_runtime_addr: int) -> DebugOffsets:\n"
"    # Etapa 1: lê a memória do processo de destino no endereço PyRuntime\n"
"    data = read_process_memory(\n"
"        pid, address=py_runtime_addr, size=DEBUG_OFFSETS_SIZE\n"
"    )\n"
"\n"
"    # Etapa 2: desserializa os bytes brutos em uma estrutura "
"_Py_DebugOffsets\n"
"    debug_offsets = parse_debug_offsets(data)\n"
"\n"
"    # Etapa 3: valida o conteúdo da estrutura\n"
"    if debug_offsets.cookie != EXPECTED_COOKIE:\n"
"        raise RuntimeError(\"Invalid or missing debug cookie\")\n"
"    if debug_offsets.version != LOCAL_PYTHON_VERSION:\n"
"        raise RuntimeError(\n"
"            \"Mismatch between caller and target Python versions\"\n"
"        )\n"
"    if debug_offsets.free_threaded != LOCAL_FREE_THREADED:\n"
"        raise RuntimeError(\"Mismatch in free-threaded configuration\")\n"
"\n"
"    return debug_offsets"

#: ../../howto/remote_debugging.rst:314
msgid "**Process suspension recommended**"
msgstr "**Suspensão de processo recomendada**"

#: ../../howto/remote_debugging.rst:316
msgid ""
"To avoid race conditions and ensure memory consistency, it is strongly "
"recommended that the target process be suspended before performing any "
"operations that read or write internal interpreter state. The Python runtime "
"may concurrently mutate interpreter data structures—such as creating or "
"destroying threads—during normal execution. This can result in invalid "
"memory reads or writes."
msgstr ""
"Para evitar condições de corrida e garantir a consistência da memória, é "
"altamente recomendável suspender o processo de destino antes de executar "
"qualquer operação que leia ou grave o estado interno do interpretador. O "
"tempo de execução do Python pode, simultaneamente, alterar as estruturas de "
"dados do interpretador — como criar ou destruir threads — durante a execução "
"normal. Isso pode resultar em leituras ou gravações de memória inválidas."

#: ../../howto/remote_debugging.rst:323
msgid ""
"A debugger may suspend execution by attaching to the process with ``ptrace`` "
"or by sending a ``SIGSTOP`` signal. Execution should only be resumed after "
"debugger-side memory operations are complete."
msgstr ""
"Um depurador pode suspender a execução anexando-se ao processo com "
"``ptrace`` ou enviando um sinal ``SIGSTOP``. A execução só deve ser retomada "
"após a conclusão das operações de memória do lado do depurador."

#: ../../howto/remote_debugging.rst:329
msgid ""
"Some tools, such as profilers or sampling-based debuggers, may operate on a "
"running process without suspension. In such cases, tools must be explicitly "
"designed to handle partially updated or inconsistent memory. For most "
"debugger implementations, suspending the process remains the safest and most "
"robust approach."
msgstr ""
"Algumas ferramentas, como perfiladores ou depuradores baseados em "
"amostragem, podem operar em um processo em execução sem suspensão. Nesses "
"casos, as ferramentas devem ser explicitamente projetadas para lidar com "
"memória parcialmente atualizada ou inconsistente. Para a maioria das "
"implementações de depuradores, suspender o processo continua sendo a "
"abordagem mais segura e robusta."

#: ../../howto/remote_debugging.rst:337
msgid "Locating the interpreter and thread state"
msgstr "Localizando o estado de thread e do interpretador"

#: ../../howto/remote_debugging.rst:339
msgid ""
"Before code can be injected and executed in a remote Python process, the "
"debugger must choose a thread in which to schedule execution. This is "
"necessary because the control fields used to perform remote code injection "
"are located in the ``_PyRemoteDebuggerSupport`` structure, which is embedded "
"in a ``PyThreadState`` object. These fields are modified by the debugger to "
"request execution of injected scripts."
msgstr ""
"Antes que o código possa ser injetado e executado em um processo Python "
"remoto, o depurador deve escolher uma thread para agendar a execução. Isso é "
"necessário porque os campos de controle usados para realizar a injeção "
"remota de código estão localizados na estrutura "
"``_PyRemoteDebuggerSupport``, que está incorporada em um objeto "
"``PyThreadState``. Esses campos são modificados pelo depurador para "
"solicitar a execução dos scripts injetados."

#: ../../howto/remote_debugging.rst:346
msgid ""
"The ``PyThreadState`` structure represents a thread running inside a Python "
"interpreter.  It maintains the thread’s evaluation context and contains the "
"fields required for debugger coordination.  Locating a valid "
"``PyThreadState`` is therefore a key prerequisite for triggering execution "
"remotely."
msgstr ""
"A estrutura ``PyThreadState`` representa uma thread em execução dentro de um "
"interpretador Python. Ela mantém o contexto de avaliação da thread e contém "
"os campos necessários para a coordenação do depurador. Localizar um "
"``PyThreadState`` válido é, portanto, um pré-requisito essencial para "
"acionar a execução remotamente."

#: ../../howto/remote_debugging.rst:351
msgid ""
"A thread is typically selected based on its role or ID. In most cases, the "
"main thread is used, but some tools may target a specific thread by its "
"native thread ID. Once the target thread is chosen, the debugger must locate "
"both the interpreter and the associated thread state structures in memory."
msgstr ""
"Uma thread é normalmente selecionada com base em sua função ou ID. Na "
"maioria dos casos, a thread principal é usada, mas algumas ferramentas podem "
"direcionar uma thread específica por seu ID nativo. Uma vez escolhida a "
"thread de destino, o depurador deve localizar o interpretador e as "
"estruturas de estado de thread associadas na memória."

#: ../../howto/remote_debugging.rst:356
msgid "The relevant internal structures are defined as follows:"
msgstr "As estruturas internas relevantes são definidas da seguinte forma:"

#: ../../howto/remote_debugging.rst:358
msgid ""
"``PyInterpreterState`` represents an isolated Python interpreter instance. "
"Each interpreter maintains its own set of imported modules, built-in state, "
"and thread state list. Although most Python applications use a single "
"interpreter, CPython supports multiple interpreters in the same process."
msgstr ""
"``PyInterpreterState`` representa uma instância isolada de um interpretador "
"Python. Cada interpretador mantém seu próprio conjunto de módulos "
"importados, estado embutido e lista de estados de thread. Embora a maioria "
"das aplicações Python use um único interpretador, o CPython oferece suporte "
"a múltiplos interpretadores no mesmo processo."

#: ../../howto/remote_debugging.rst:363
msgid ""
"``PyThreadState`` represents a thread running within an interpreter. It "
"contains execution state and the control fields used by the debugger."
msgstr ""
"``PyThreadState`` representa uma thread em execução dentro de um "
"interpretador. Ele contém o estado de execução e os campos de controle "
"usados pelo depurador."

#: ../../howto/remote_debugging.rst:366
msgid "To locate a thread:"
msgstr "Para localizar uma thread:"

#: ../../howto/remote_debugging.rst:368
msgid ""
"Use the offset ``runtime_state.interpreters_head`` to obtain the address of "
"the first interpreter in the ``PyRuntime`` structure. This is the entry "
"point to the linked list of active interpreters."
msgstr ""
"Use o offset ``runtime_state.interpreters_head`` para obter o endereço do "
"primeiro interpretador na estrutura ``PyRuntime``. Este é o ponto de entrada "
"para a lista vinculada de interpretadores ativos."

#: ../../howto/remote_debugging.rst:372
msgid ""
"Use the offset ``interpreter_state.threads_main`` to access the main thread "
"state associated with the selected interpreter. This is typically the most "
"reliable thread to target."
msgstr ""
"Use o deslocamento ``interpreter_state.threads_main`` para acessar o estado "
"da thread principal associada ao interpretador selecionado. Normalmente, "
"esta é a thread mais confiável para ser alvo."

#: ../../howto/remote_debugging.rst:376
msgid ""
"Optionally, use the offset ``interpreter_state.threads_head`` to iterate "
"through the linked list of all thread states. Each ``PyThreadState`` "
"structure contains a ``native_thread_id`` field, which may be compared to a "
"target thread ID to find a specific thread."
msgstr ""

#: ../../howto/remote_debugging.rst:381
msgid ""
"Once a valid ``PyThreadState`` has been found, its address can be used in "
"later steps of the protocol, such as writing debugger control fields and "
"scheduling execution."
msgstr ""

#: ../../howto/remote_debugging.rst:385
msgid ""
"The following is an example implementation that locates the main thread "
"state::"
msgstr ""
"A seguir está um exemplo de implementação que localiza o estado da thread "
"principal:"

#: ../../howto/remote_debugging.rst:387
msgid ""
"def find_main_thread_state(\n"
"    pid: int, py_runtime_addr: int, debug_offsets: DebugOffsets,\n"
") -> int:\n"
"    # Step 1: Read interpreters_head from PyRuntime\n"
"    interp_head_ptr = (\n"
"        py_runtime_addr + debug_offsets.runtime_state.interpreters_head\n"
"    )\n"
"    interp_addr = read_pointer(pid, interp_head_ptr)\n"
"    if interp_addr == 0:\n"
"        raise RuntimeError(\"No interpreter found in the target process\")\n"
"\n"
"    # Step 2: Read the threads_main pointer from the interpreter\n"
"    threads_main_ptr = (\n"
"        interp_addr + debug_offsets.interpreter_state.threads_main\n"
"    )\n"
"    thread_state_addr = read_pointer(pid, threads_main_ptr)\n"
"    if thread_state_addr == 0:\n"
"        raise RuntimeError(\"Main thread state is not available\")\n"
"\n"
"    return thread_state_addr"
msgstr ""
"def find_main_thread_state(\n"
"    pid: int, py_runtime_addr: int, debug_offsets: DebugOffsets,\n"
") -> int:\n"
"    # Etapa 1: lê interpreters_head do PyRuntime\n"
"    interp_head_ptr = (\n"
"        py_runtime_addr + debug_offsets.runtime_state.interpreters_head\n"
"    )\n"
"    interp_addr = read_pointer(pid, interp_head_ptr)\n"
"    if interp_addr == 0:\n"
"        raise RuntimeError(\"No interpreter found in the target process\")\n"
"\n"
"    # Etapa 2: lê o ponteiro threads_main do interpretador\n"
"    threads_main_ptr = (\n"
"        interp_addr + debug_offsets.interpreter_state.threads_main\n"
"    )\n"
"    thread_state_addr = read_pointer(pid, threads_main_ptr)\n"
"    if thread_state_addr == 0:\n"
"        raise RuntimeError(\"Main thread state is not available\")\n"
"\n"
"    return thread_state_addr"

#: ../../howto/remote_debugging.rst:408
msgid ""
"The following example demonstrates how to locate a thread by its native "
"thread ID::"
msgstr ""
"O exemplo a seguir demonstra como localizar uma thread pelo seu ID de thread "
"nativo:"

#: ../../howto/remote_debugging.rst:411
msgid ""
"def find_thread_by_id(\n"
"    pid: int,\n"
"    interp_addr: int,\n"
"    debug_offsets: DebugOffsets,\n"
"    target_tid: int,\n"
") -> int:\n"
"    # Start at threads_head and walk the linked list\n"
"    thread_ptr = read_pointer(\n"
"        pid,\n"
"        interp_addr + debug_offsets.interpreter_state.threads_head\n"
"    )\n"
"\n"
"    while thread_ptr:\n"
"        native_tid_ptr = (\n"
"            thread_ptr + debug_offsets.thread_state.native_thread_id\n"
"        )\n"
"        native_tid = read_int(pid, native_tid_ptr)\n"
"        if native_tid == target_tid:\n"
"            return thread_ptr\n"
"        thread_ptr = read_pointer(\n"
"            pid,\n"
"            thread_ptr + debug_offsets.thread_state.next\n"
"        )\n"
"\n"
"    raise RuntimeError(\"Thread with the given ID was not found\")"
msgstr ""
"def find_thread_by_id(\n"
"    pid: int,\n"
"    interp_addr: int,\n"
"    debug_offsets: DebugOffsets,\n"
"    target_tid: int,\n"
") -> int:\n"
"    # Começa em threads_head e percorre a lista vinculada\n"
"    thread_ptr = read_pointer(\n"
"        pid,\n"
"        interp_addr + debug_offsets.interpreter_state.threads_head\n"
"    )\n"
"\n"
"    while thread_ptr:\n"
"        native_tid_ptr = (\n"
"            thread_ptr + debug_offsets.thread_state.native_thread_id\n"
"        )\n"
"        native_tid = read_int(pid, native_tid_ptr)\n"
"        if native_tid == target_tid:\n"
"            return thread_ptr\n"
"        thread_ptr = read_pointer(\n"
"            pid,\n"
"            thread_ptr + debug_offsets.thread_state.next\n"
"        )\n"
"\n"
"    raise RuntimeError(\"Thread with the given ID was not found\")"

#: ../../howto/remote_debugging.rst:438
msgid ""
"Once a valid thread state has been located, the debugger can proceed with "
"modifying its control fields and scheduling execution, as described in the "
"next section."
msgstr ""
"Depois que um estado de thread válido for localizado, o depurador pode "
"prosseguir com a modificação de seus campos de controle e agendar a "
"execução, conforme descrito na próxima seção."

#: ../../howto/remote_debugging.rst:443
msgid "Writing control information"
msgstr "Escrevendo informações de controle"

#: ../../howto/remote_debugging.rst:445
msgid ""
"Once a valid ``PyThreadState`` structure has been identified, the debugger "
"may modify control fields within it to schedule the execution of a specified "
"Python script. These control fields are checked periodically by the "
"interpreter, and when set correctly, they trigger the execution of remote "
"code at a safe point in the evaluation loop."
msgstr ""
"Uma vez identificada uma estrutura ``PyThreadState`` válida, o depurador "
"pode modificar campos de controle dentro dela para agendar a execução de um "
"script Python especificado. Esses campos de controle são verificados "
"periodicamente pelo interpretador e, quando definidos corretamente, acionam "
"a execução do código remoto em um ponto seguro no laço de avaliação."

#: ../../howto/remote_debugging.rst:451
msgid ""
"Each ``PyThreadState`` contains a ``_PyRemoteDebuggerSupport`` structure "
"used for communication between the debugger and the interpreter. The "
"locations of its fields are defined by the ``_Py_DebugOffsets`` structure "
"and include the following:"
msgstr ""
"Cada ``PyThreadState`` contém uma estrutura ``_PyRemoteDebuggerSupport`` "
"usada para comunicação entre o depurador e o interpretador. As localizações "
"de seus campos são definidas pela estrutura ``_Py_DebugOffsets`` e incluem o "
"seguinte:"

#: ../../howto/remote_debugging.rst:456
msgid ""
"``debugger_script_path``: A fixed-size buffer that holds the full path to a "
"Python source file (``.py``).  This file must be accessible and readable by "
"the target process when execution is triggered."
msgstr ""

#: ../../howto/remote_debugging.rst:460
msgid ""
"``debugger_pending_call``: An integer flag. Setting this to ``1`` tells the "
"interpreter that a script is ready to be executed."
msgstr ""

#: ../../howto/remote_debugging.rst:463
msgid ""
"``eval_breaker``: A field checked by the interpreter during execution. "
"Setting bit 5 (``_PY_EVAL_PLEASE_STOP_BIT``, value ``1U << 5``) in this "
"field causes the interpreter to pause and check for debugger activity."
msgstr ""

#: ../../howto/remote_debugging.rst:467
msgid ""
"To complete the injection, the debugger must perform the following steps:"
msgstr ""
"Para concluir a injeção, o depurador deve executar as seguintes etapas:"

#: ../../howto/remote_debugging.rst:469
msgid "Write the full script path into the ``debugger_script_path`` buffer."
msgstr ""
"Escreve o caminho completo do script no buffer ``debugger_script_path``."

#: ../../howto/remote_debugging.rst:470
msgid "Set ``debugger_pending_call`` to ``1``."
msgstr "Define ``debugger_pending_call`` com ``1``."

#: ../../howto/remote_debugging.rst:471
msgid ""
"Read the current value of ``eval_breaker``, set bit 5 "
"(``_PY_EVAL_PLEASE_STOP_BIT``), and write the updated value back. This "
"signals the interpreter to check for debugger activity."
msgstr ""
"Lê o valor atual de ``eval_breaker``, define o bit 5 "
"(``_PY_EVAL_PLEASE_STOP_BIT``) e grava o valor atualizado de volta. Isso "
"sinaliza ao interpretador para verificar a atividade do depurador."

#: ../../howto/remote_debugging.rst:477
msgid ""
"def inject_script(\n"
"    pid: int,\n"
"    thread_state_addr: int,\n"
"    debug_offsets: DebugOffsets,\n"
"    script_path: str\n"
") -> None:\n"
"    # Compute the base offset of _PyRemoteDebuggerSupport\n"
"    support_base = (\n"
"        thread_state_addr +\n"
"        debug_offsets.debugger_support.remote_debugger_support\n"
"    )\n"
"\n"
"    # Step 1: Write the script path into debugger_script_path\n"
"    script_path_ptr = (\n"
"        support_base +\n"
"        debug_offsets.debugger_support.debugger_script_path\n"
"    )\n"
"    write_string(pid, script_path_ptr, script_path)\n"
"\n"
"    # Step 2: Set debugger_pending_call to 1\n"
"    pending_ptr = (\n"
"        support_base +\n"
"        debug_offsets.debugger_support.debugger_pending_call\n"
"    )\n"
"    write_int(pid, pending_ptr, 1)\n"
"\n"
"    # Step 3: Set _PY_EVAL_PLEASE_STOP_BIT (bit 5, value 1 << 5) in\n"
"    # eval_breaker\n"
"    eval_breaker_ptr = (\n"
"        thread_state_addr +\n"
"        debug_offsets.debugger_support.eval_breaker\n"
"    )\n"
"    breaker = read_int(pid, eval_breaker_ptr)\n"
"    breaker |= (1 << 5)\n"
"    write_int(pid, eval_breaker_ptr, breaker)"
msgstr ""
"def inject_script(\n"
"    pid: int,\n"
"    thread_state_addr: int,\n"
"    debug_offsets: DebugOffsets,\n"
"    script_path: str\n"
") -> None:\n"
"    # Calcula o deslocamento base de _PyRemoteDebuggerSupport\n"
"    support_base = (\n"
"        thread_state_addr +\n"
"        debug_offsets.debugger_support.remote_debugger_support\n"
"    )\n"
"\n"
"    # Etapa 1: Escreve o caminho do script em debugger_script_path\n"
"    script_path_ptr = (\n"
"        support_base +\n"
"        debug_offsets.debugger_support.debugger_script_path\n"
"    )\n"
"    write_string(pid, script_path_ptr, script_path)\n"
"\n"
"    # Etapa 2: Define debugger_pending_call com 1\n"
"    pending_ptr = (\n"
"        support_base +\n"
"        debug_offsets.debugger_support.debugger_pending_call\n"
"    )\n"
"    write_int(pid, pending_ptr, 1)\n"
"\n"
"    # Etapa 3: Define _PY_EVAL_PLEASE_STOP_BIT (bit 5, valor 1 << 5)\n"
"    # em eval_breaker\n"
"    eval_breaker_ptr = (\n"
"        thread_state_addr +\n"
"        debug_offsets.debugger_support.eval_breaker\n"
"    )\n"
"    breaker = read_int(pid, eval_breaker_ptr)\n"
"    breaker |= (1 << 5)\n"
"    write_int(pid, eval_breaker_ptr, breaker)"

#: ../../howto/remote_debugging.rst:514
msgid ""
"Once these fields are set, the debugger may resume the process (if it was "
"suspended).  The interpreter will process the request at the next safe "
"evaluation point, load the script from disk, and execute it."
msgstr ""
"Após a configuração desses campos, o depurador pode retomar o processo (caso "
"tenha sido suspenso). O interpretador processará a solicitação no próximo "
"ponto de avaliação seguro, carregará o script do disco e o executará."

#: ../../howto/remote_debugging.rst:518
msgid ""
"It is the responsibility of the debugger to ensure that the script file "
"remains present and accessible to the target process during execution."
msgstr ""
"É responsabilidade do depurador garantir que o arquivo de script permaneça "
"presente e acessível ao processo de destino durante a execução."

#: ../../howto/remote_debugging.rst:523
msgid ""
"Script execution is asynchronous. The script file cannot be deleted "
"immediately after injection. The debugger should wait until the injected "
"script has produced an observable effect before removing the file. This "
"effect depends on what the script is designed to do. For example, a debugger "
"might wait until the remote process connects back to a socket before "
"removing the script. Once such an effect is observed, it is safe to assume "
"the file is no longer needed."
msgstr ""
"A execução do script é assíncrona. O arquivo de script não pode ser excluído "
"imediatamente após a injeção. O depurador deve aguardar até que o script "
"injetado produza um efeito observável antes de remover o arquivo. Esse "
"efeito depende do objetivo do script. Por exemplo, um depurador pode "
"aguardar até que o processo remoto se conecte novamente a um soquete antes "
"de remover o script. Uma vez observado esse efeito, é seguro presumir que o "
"arquivo não é mais necessário."

#: ../../howto/remote_debugging.rst:532
msgid "Summary"
msgstr "Resumo"

#: ../../howto/remote_debugging.rst:534
msgid "To inject and execute a Python script in a remote process:"
msgstr "Para injetar e executar um script Python em um processo remoto:"

#: ../../howto/remote_debugging.rst:536
msgid "Locate the ``PyRuntime`` structure in the target process’s memory."
msgstr "Localize a estrutura ``PyRuntime`` na memória do processo de destino."

#: ../../howto/remote_debugging.rst:537
msgid ""
"Read and validate the ``_Py_DebugOffsets`` structure at the beginning of "
"``PyRuntime``."
msgstr ""
"Lê e valida a estrutura ``_Py_DebugOffsets`` no início de ``PyRuntime``."

#: ../../howto/remote_debugging.rst:539
msgid "Use the offsets to locate a valid ``PyThreadState``."
msgstr "Usa os deslocamentos para localizar um ``PyThreadState`` válido."

#: ../../howto/remote_debugging.rst:540
msgid "Write the path to a Python script into ``debugger_script_path``."
msgstr "Escreve o caminho para um script Python em ``debugger_script_path``."

#: ../../howto/remote_debugging.rst:541
msgid "Set the ``debugger_pending_call`` flag to ``1``."
msgstr "Define o sinalizador ``debugger_pending_call`` com ``1``."

#: ../../howto/remote_debugging.rst:542
msgid "Set ``_PY_EVAL_PLEASE_STOP_BIT`` in the ``eval_breaker`` field."
msgstr "Define ``_PY_EVAL_PLEASE_STOP_BIT`` no campo ``eval_breaker``."

#: ../../howto/remote_debugging.rst:543
msgid ""
"Resume the process (if suspended). The script will execute at the next safe "
"evaluation point."
msgstr ""
"Retoma o processo (se suspenso). O script será executado no próximo ponto de "
"avaliação seguro."

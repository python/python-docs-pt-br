# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 16:41+0000\n"
"PO-Revision-Date: 2023-05-24 02:11+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../howto/logging-cookbook.rst:5
msgid "Logging Cookbook"
msgstr "Livro de receitas do logging"

#: ../../howto/logging-cookbook.rst:0
msgid "Author"
msgstr "Autor"

#: ../../howto/logging-cookbook.rst:7
msgid "Vinay Sajip <vinay_sajip at red-dove dot com>"
msgstr "Vinay Sajip <vinay_sajip at red-dove dot com>"

#: ../../howto/logging-cookbook.rst:9
msgid ""
"This page contains a number of recipes related to logging, which have been "
"found useful in the past. For links to tutorial and reference information, "
"please see :ref:`cookbook-ref-links`."
msgstr ""
"Esta página contém uma série de receitas relacionadas ao registro de "
"eventos, que foram considerados úteis no passado. Para obter links para "
"tutoriais e outras referências, veja :ref:`cookbook-ref-links`"

#: ../../howto/logging-cookbook.rst:16
msgid "Using logging in multiple modules"
msgstr "Usando logging em vários módulos"

#: ../../howto/logging-cookbook.rst:18
msgid ""
"Multiple calls to ``logging.getLogger('someLogger')`` return a reference to "
"the same logger object.  This is true not only within the same module, but "
"also across modules as long as it is in the same Python interpreter "
"process.  It is true for references to the same object; additionally, "
"application code can define and configure a parent logger in one module and "
"create (but not configure) a child logger in a separate module, and all "
"logger calls to the child will pass up to the parent.  Here is a main "
"module::"
msgstr ""
"Várias chamadas para ``logging.getLogger('someLogger')`` retorna a "
"referência para o mesmo objeto logger.  Isso é verdadeiro não apenas dentro "
"do mesmo módulo, mas também entre módulo, desde que esteja no mesmo processo "
"do interpretador Python. Isso é verdadeiro para referências do mesmo objeto; "
"além disso, o código da aplicação pode definir e configurar um logger pai em "
"um módulo e criar (mas não configurar) um logger filho em um módulo "
"separado, e todas as chamadas de logger para o filho passarão para o pai.  "
"Aqui está um módulo principal::"

#: ../../howto/logging-cookbook.rst:56
msgid "Here is the auxiliary module::"
msgstr "Aqui está o módulo auxiliar::"

#: ../../howto/logging-cookbook.rst:76
msgid "The output looks like this:"
msgstr "O resultado deve ser algo assim:"

#: ../../howto/logging-cookbook.rst:102
msgid "Logging from multiple threads"
msgstr "Registro de eventos de várias threads"

#: ../../howto/logging-cookbook.rst:104
msgid ""
"Logging from multiple threads requires no special effort. The following "
"example shows logging from the main (initial) thread and another thread::"
msgstr ""
"O registro de eventos de várias threads não requer nenhum esforço especial. "
"O exemplo a seguir mostra o registro de eventos da thread principal "
"(inicial) thread e de outra thread::"

#: ../../howto/logging-cookbook.rst:133
msgid "When run, the script should print something like the following:"
msgstr "Quando executado, o script deve exibir algo como o seguinte:"

#: ../../howto/logging-cookbook.rst:155
msgid ""
"This shows the logging output interspersed as one might expect. This "
"approach works for more threads than shown here, of course."
msgstr ""
"Isso mostra a saída de registro intercalada, como seria de se esperar. Essa "
"abordagem funciona para mais thread do que o mostrado aqui, é claro."

#: ../../howto/logging-cookbook.rst:159
msgid "Multiple handlers and formatters"
msgstr "Múltiplos manipuladores e formatadores"

#: ../../howto/logging-cookbook.rst:161
msgid ""
"Loggers are plain Python objects.  The :meth:`~Logger.addHandler` method has "
"no minimum or maximum quota for the number of handlers you may add.  "
"Sometimes it will be beneficial for an application to log all messages of "
"all severities to a text file while simultaneously logging errors or above "
"to the console.  To set this up, simply configure the appropriate handlers.  "
"The logging calls in the application code will remain unchanged.  Here is a "
"slight modification to the previous simple module-based configuration "
"example::"
msgstr ""
"Registradores (loggers) são objetos Python simples.  O método :meth:`~Logger."
"addHandler` não tem cota mínima ou máxima para o número de manipuladores que "
"podem ser adicionados.  Às vezes, é vantajoso para um aplicação registrar "
"todas as mensagens de todas as gravidades em um arquivo texto e, ao mesmo "
"tempo, registrar erro ou superior no console.  Para definir isso, basta "
"configurar os manipuladores apropriados.  As chamadas de registro no código "
"da aplicação permanecerão inalteradas.  Aqui está uma pequena modificação no "
"exemplo anterior de configuração simples baseada em módulo::"

#: ../../howto/logging-cookbook.rst:194
msgid ""
"Notice that the 'application' code does not care about multiple handlers.  "
"All that changed was the addition and configuration of a new handler named "
"*fh*."
msgstr ""
"Observe que o código da 'aplicação' não se preocupa com vários "
"manipuladores.  Tudo o que mudou foi a adição e a configuração de um novo "
"manipulador nomeado *fh*."

#: ../../howto/logging-cookbook.rst:197
msgid ""
"The ability to create new handlers with higher- or lower-severity filters "
"can be very helpful when writing and testing an application.  Instead of "
"using many ``print`` statements for debugging, use ``logger.debug``: Unlike "
"the print statements, which you will have to delete or comment out later, "
"the logger.debug statements can remain intact in the source code and remain "
"dormant until you need them again.  At that time, the only change that needs "
"to happen is to modify the severity level of the logger and/or handler to "
"debug."
msgstr ""
"A capacidade de criar novos manipuladores com filtros de severidade "
"superiores ou inferiores pode ser muito útil ao escrever e testar um "
"aplicação. Em vez de usar muitas instruções   instrução para depuração, use "
"``logger.debug``: diferentemente da instrução print, que você terá de "
"excluir ou comentar posteriormente, a instrução  logger.debug pode "
"permanecer intacta no código-fonte e ficar inativo até que você precise dela "
"novamente. Nesse momento, a única alteração que precisa ser feita é "
"modificar o nível de severidade do registrador e/ou manipulador para "
"depuração."

#: ../../howto/logging-cookbook.rst:208
msgid "Logging to multiple destinations"
msgstr "Реєстрація в кількох пунктах призначення"

#: ../../howto/logging-cookbook.rst:210
msgid ""
"Let's say you want to log to console and file with different message formats "
"and in differing circumstances. Say you want to log messages with levels of "
"DEBUG and higher to file, and those messages at level INFO and higher to the "
"console. Let's also assume that the file should contain timestamps, but the "
"console messages should not. Here's how you can achieve this::"
msgstr ""
"Припустімо, ви хочете увійти в консоль і файл із різними форматами "
"повідомлень і за різних обставин. Скажімо, ви хочете реєструвати "
"повідомлення з рівнями DEBUG і вище у файл, а ці повідомлення рівня INFO і "
"вище — на консоль. Давайте також припустимо, що файл повинен містити мітки "
"часу, але повідомлення консолі не повинні. Ось як ви можете цього досягти:"

#: ../../howto/logging-cookbook.rst:248
msgid "When you run this, on the console you will see"
msgstr "Коли ви запустите це, на консолі ви побачите"

#: ../../howto/logging-cookbook.rst:257
msgid "and in the file you will see something like"
msgstr "і у файлі ви побачите щось на зразок"

#: ../../howto/logging-cookbook.rst:267
msgid ""
"As you can see, the DEBUG message only shows up in the file. The other "
"messages are sent to both destinations."
msgstr ""
"Як бачите, повідомлення DEBUG відображається лише у файлі. Інші повідомлення "
"надсилаються в обидва адресати."

#: ../../howto/logging-cookbook.rst:270
msgid ""
"This example uses console and file handlers, but you can use any number and "
"combination of handlers you choose."
msgstr ""
"У цьому прикладі використовуються обробники консолі та файлів, але ви можете "
"використовувати будь-яку кількість і комбінацію обробників на свій вибір."

#: ../../howto/logging-cookbook.rst:273
msgid ""
"Note that the above choice of log filename ``/tmp/myapp.log`` implies use of "
"a standard location for temporary files on POSIX systems. On Windows, you "
"may need to choose a different directory name for the log - just ensure that "
"the directory exists and that you have the permissions to create and update "
"files in it."
msgstr ""
"Обратите внимание, что приведенный выше выбор имени файла журнала ``/tmp/"
"myapp.log`` подразумевает использование стандартного местоположения для "
"временных файлов в системах POSIX. В Windows вам может потребоваться выбрать "
"другое имя каталога для журнала — просто убедитесь, что каталог существует и "
"что у вас есть разрешения на создание и обновление файлов в нем."

#: ../../howto/logging-cookbook.rst:282
msgid "Custom handling of levels"
msgstr "Пользовательская обработка уровней"

#: ../../howto/logging-cookbook.rst:284
msgid ""
"Sometimes, you might want to do something slightly different from the "
"standard handling of levels in handlers, where all levels above a threshold "
"get processed by a handler. To do this, you need to use filters. Let's look "
"at a scenario where you want to arrange things as follows:"
msgstr ""
"Иногда вам может потребоваться сделать что-то немного отличное от "
"стандартной обработки уровней в обработчиках, где все уровни выше порогового "
"значения обрабатываются обработчиком. Для этого нужно использовать фильтры. "
"Давайте рассмотрим сценарий, в котором вы хотите организовать все следующим "
"образом:"

#: ../../howto/logging-cookbook.rst:289
msgid "Send messages of severity ``INFO`` and ``WARNING`` to ``sys.stdout``"
msgstr ""
"Отправлять сообщения серьезности ``INFO`` и ``WARNING`` в ``sys.stdout``."

#: ../../howto/logging-cookbook.rst:290
msgid "Send messages of severity ``ERROR`` and above to ``sys.stderr``"
msgstr ""
"Отправлять сообщения уровня серьезности ``ERROR`` и выше в ``sys.stderr``."

#: ../../howto/logging-cookbook.rst:291
msgid "Send messages of severity ``DEBUG`` and above to file ``app.log``"
msgstr ""
"Отправлять сообщения уровня серьезности ``DEBUG`` и выше в файл ``app.log``."

#: ../../howto/logging-cookbook.rst:293
msgid "Suppose you configure logging with the following JSON:"
msgstr ""
"Предположим, вы настраиваете ведение журнала с помощью следующего JSON:"

#: ../../howto/logging-cookbook.rst:335
msgid ""
"This configuration does *almost* what we want, except that ``sys.stdout`` "
"would show messages of severity ``ERROR`` and above as well as ``INFO`` and "
"``WARNING`` messages. To prevent this, we can set up a filter which excludes "
"those messages and add it to the relevant handler. This can be configured by "
"adding a ``filters`` section parallel to ``formatters`` and ``handlers``:"
msgstr ""
"Эта конфигурация делает *почти* то, что мы хотим, за исключением того, что "
"``sys.stdout`` будет отображать сообщения уровня ``ERROR`` и выше, а также "
"сообщения ``INFO`` и ``WARNING``. Чтобы предотвратить это, мы можем "
"настроить фильтр, исключающий эти сообщения, и добавить его в "
"соответствующий обработчик. Это можно настроить, добавив раздел ``filters`` "
"параллельно с ``formatters`` и ``handlers``:"

#: ../../howto/logging-cookbook.rst:352
msgid "and changing the section on the ``stdout`` handler to add it:"
msgstr "и изменив раздел обработчика ``stdout``, чтобы добавить его:"

#: ../../howto/logging-cookbook.rst:366
msgid ""
"A filter is just a function, so we can define the ``filter_maker`` (a "
"factory function) as follows:"
msgstr ""
"Фильтр — это просто функция, поэтому мы можем определить "
"«filter_maker» (фабричную функцию) следующим образом:"

#: ../../howto/logging-cookbook.rst:379
msgid ""
"This converts the string argument passed in to a numeric level, and returns "
"a function which only returns ``True`` if the level of the passed in record "
"is at or below the specified level. Note that in this example I have defined "
"the ``filter_maker`` in a test script ``main.py`` that I run from the "
"command line, so its module will be ``__main__`` - hence the ``__main__."
"filter_maker`` in the filter configuration. You will need to change that if "
"you define it in a different module."
msgstr ""
"Это преобразует переданный строковый аргумент в числовой уровень и "
"возвращает функцию, которая возвращает ``True`` только в том случае, если "
"уровень переданной записи находится на указанном уровне или ниже. Обратите "
"внимание, что в этом примере я определил ``filter_maker`` в тестовом скрипте "
"``main.py``, который запускаю из командной строки, поэтому его модулем будет "
"``__main__`` - отсюда и ``__main__\". filter_maker`` в конфигурации фильтра. "
"Вам нужно будет изменить это, если вы определите его в другом модуле."

#: ../../howto/logging-cookbook.rst:387
msgid "With the filter added, we can run ``main.py``, which in full is:"
msgstr ""
"Добавив фильтр, мы можем запустить ``main.py``, который полностью будет "
"выглядеть так:"

#: ../../howto/logging-cookbook.rst:457
msgid "And after running it like this:"
msgstr "И после запуска вот так:"

#: ../../howto/logging-cookbook.rst:463
msgid "We can see the results are as expected:"
msgstr "Мы видим, что результаты соответствуют ожиданиям:"

#: ../../howto/logging-cookbook.rst:489
msgid "Configuration server example"
msgstr "Приклад конфігурації сервера"

#: ../../howto/logging-cookbook.rst:491
msgid "Here is an example of a module using the logging configuration server::"
msgstr "Ось приклад модуля, який використовує сервер конфігурації журналу:"

#: ../../howto/logging-cookbook.rst:522
msgid ""
"And here is a script that takes a filename and sends that file to the "
"server, properly preceded with the binary-encoded length, as the new logging "
"configuration::"
msgstr ""
"А ось сценарій, який приймає ім’я файлу та надсилає цей файл на сервер, "
"належним чином передуючи довжиною у двійковому кодуванні, як нову "
"конфігурацію журналювання::"

#: ../../howto/logging-cookbook.rst:547
msgid "Dealing with handlers that block"
msgstr "Робота з обробниками, які блокують"

#: ../../howto/logging-cookbook.rst:551
msgid ""
"Sometimes you have to get your logging handlers to do their work without "
"blocking the thread you're logging from. This is common in web applications, "
"though of course it also occurs in other scenarios."
msgstr ""
"Іноді вам потрібно змусити обробників журналу виконувати свою роботу, не "
"блокуючи потік, з якого ви входите. Це поширене явище у веб-додатках, хоча, "
"звичайно, трапляється й в інших сценаріях."

#: ../../howto/logging-cookbook.rst:555
msgid ""
"A common culprit which demonstrates sluggish behaviour is the :class:"
"`SMTPHandler`: sending emails can take a long time, for a number of reasons "
"outside the developer's control (for example, a poorly performing mail or "
"network infrastructure). But almost any network-based handler can block: "
"Even a :class:`SocketHandler` operation may do a DNS query under the hood "
"which is too slow (and this query can be deep in the socket library code, "
"below the Python layer, and outside your control)."
msgstr ""
"Поширеним винуватцем млявої поведінки є :class:`SMTPHandler`: надсилання "
"електронних листів може тривати багато часу через ряд причин, які не "
"залежать від розробника (наприклад, погана робота пошти чи мережевої "
"інфраструктури). Але майже будь-який мережевий обробник може заблокувати: "
"навіть операція :class:`SocketHandler` може виконати DNS-запит під капотом, "
"який надто повільний (і цей запит може бути глибоко в коді бібліотеки "
"сокетів, нижче рівня Python, і поза вашим контролем)."

#: ../../howto/logging-cookbook.rst:563
msgid ""
"One solution is to use a two-part approach. For the first part, attach only "
"a :class:`QueueHandler` to those loggers which are accessed from performance-"
"critical threads. They simply write to their queue, which can be sized to a "
"large enough capacity or initialized with no upper bound to their size. The "
"write to the queue will typically be accepted quickly, though you will "
"probably need to catch the :exc:`queue.Full` exception as a precaution in "
"your code. If you are a library developer who has performance-critical "
"threads in their code, be sure to document this (together with a suggestion "
"to attach only ``QueueHandlers`` to your loggers) for the benefit of other "
"developers who will use your code."
msgstr ""
"Одним із рішень є використання підходу з двох частин. Для першої частини "
"додайте лише :class:`QueueHandler` до тих реєстраторів, доступ до яких "
"здійснюється з критичних для продуктивності потоків. Вони просто записують у "
"свою чергу, розмір якої може бути достатньо великим або ініціалізований без "
"верхньої межі їхнього розміру. Запис до черги, як правило, швидко "
"приймається, хоча вам, ймовірно, потрібно буде перехопити виняток :exc:"
"`queue.Full` як запобіжний захід у вашому коді. Якщо ви розробник "
"бібліотеки, у коді якого є критично важливі для продуктивності потоки, "
"обов’язково задокументуйте це (разом із пропозицією приєднати лише "
"``QueueHandlers`` до ваших реєстраторів) на користь інших розробників, які "
"використовуватимуть ваш код."

#: ../../howto/logging-cookbook.rst:574
msgid ""
"The second part of the solution is :class:`QueueListener`, which has been "
"designed as the counterpart to :class:`QueueHandler`.  A :class:"
"`QueueListener` is very simple: it's passed a queue and some handlers, and "
"it fires up an internal thread which listens to its queue for LogRecords "
"sent from ``QueueHandlers`` (or any other source of ``LogRecords``, for that "
"matter). The ``LogRecords`` are removed from the queue and passed to the "
"handlers for processing."
msgstr ""
"Другою частиною рішення є :class:`QueueListener`, який був розроблений як "
"відповідник :class:`QueueHandler`. :class:`QueueListener` дуже простий: він "
"передає чергу та деякі обробники, і запускає внутрішній потік, який "
"прослуховує свою чергу для LogRecords, надісланих з ``QueueHandlers`` (або "
"будь-якого іншого джерела ``LogRecords``, як на те пішло). ``LogRecords`` "
"видаляються з черги та передаються обробникам для обробки."

#: ../../howto/logging-cookbook.rst:582
msgid ""
"The advantage of having a separate :class:`QueueListener` class is that you "
"can use the same instance to service multiple ``QueueHandlers``. This is "
"more resource-friendly than, say, having threaded versions of the existing "
"handler classes, which would eat up one thread per handler for no particular "
"benefit."
msgstr ""
"Перевага наявності окремого класу :class:`QueueListener` полягає в тому, що "
"ви можете використовувати один екземпляр для обслуговування кількох "
"``QueueHandler``. Це більш дружньо до ресурсів, ніж, скажімо, мати "
"багатопотокові версії існуючих класів обробників, які з’їдають один потік на "
"обробник без особливої користі."

#: ../../howto/logging-cookbook.rst:587
msgid "An example of using these two classes follows (imports omitted)::"
msgstr "Нижче наведено приклад використання цих двох класів (імпорт опущено):"

#: ../../howto/logging-cookbook.rst:605
msgid "which, when run, will produce:"
msgstr "який під час запуску вироблятиме:"

#: ../../howto/logging-cookbook.rst:611
msgid ""
"Although the earlier discussion wasn't specifically talking about async "
"code, but rather about slow logging handlers, it should be noted that when "
"logging from async code, network and even file handlers could lead to "
"problems (blocking the event loop) because some logging is done from :mod:"
"`asyncio` internals. It might be best, if any async code is used in an "
"application, to use the above approach for logging, so that any blocking "
"code runs only in the ``QueueListener`` thread."
msgstr ""
"Хотя в предыдущем обсуждении конкретно говорилось не об асинхронном коде, а "
"скорее об обработчиках медленного журналирования, следует отметить, что при "
"журналировании из асинхронного кода сетевые и даже файловые обработчики "
"могут привести к проблемам (блокировке цикла событий), поскольку некоторые "
"журналы сделано из внутренних компонентов :mod:`asyncio`. Если в приложении "
"используется какой-либо асинхронный код, возможно, лучше всего использовать "
"описанный выше подход для журналирования, чтобы любой код блокировки "
"выполнялся только в потоке QueueListener."

#: ../../howto/logging-cookbook.rst:619
msgid ""
"Prior to Python 3.5, the :class:`QueueListener` always passed every message "
"received from the queue to every handler it was initialized with. (This was "
"because it was assumed that level filtering was all done on the other side, "
"where the queue is filled.) From 3.5 onwards, this behaviour can be changed "
"by passing a keyword argument ``respect_handler_level=True`` to the "
"listener's constructor. When this is done, the listener compares the level "
"of each message with the handler's level, and only passes a message to a "
"handler if it's appropriate to do so."
msgstr ""
"До Python 3.5 :class:`QueueListener` завжди передавав кожне повідомлення, "
"отримане з черги, кожному обробнику, яким він був ініціалізований. (Це "
"сталося тому, що передбачалося, що фільтрація рівня виконується з іншого "
"боку, де заповнюється черга.) Починаючи з версії 3.5 і далі цю поведінку "
"можна змінити, передавши аргумент ключового слова "
"``respect_handler_level=True`` конструктору слухача . Коли це зроблено, "
"слухач порівнює рівень кожного повідомлення з рівнем обробника та передає "
"повідомлення обробнику, лише якщо це доречно."

#: ../../howto/logging-cookbook.rst:632
msgid "Sending and receiving logging events across a network"
msgstr "Надсилання та отримання журнальних подій через мережу"

#: ../../howto/logging-cookbook.rst:634
msgid ""
"Let's say you want to send logging events across a network, and handle them "
"at the receiving end. A simple way of doing this is attaching a :class:"
"`SocketHandler` instance to the root logger at the sending end::"
msgstr ""
"Припустімо, ви хочете надіслати події журналювання через мережу та обробити "
"їх на приймаючому кінці. Простий спосіб зробити це — приєднати екземпляр :"
"class:`SocketHandler` до кореневого реєстратора на стороні надсилання::"

#: ../../howto/logging-cookbook.rst:662
msgid ""
"At the receiving end, you can set up a receiver using the :mod:"
"`socketserver` module. Here is a basic working example::"
msgstr ""
"На стороні приймача ви можете налаштувати приймача за допомогою модуля :mod:"
"`socketserver`. Ось базовий робочий приклад:"

#: ../../howto/logging-cookbook.rst:750
msgid ""
"First run the server, and then the client. On the client side, nothing is "
"printed on the console; on the server side, you should see something like:"
msgstr ""
"Спочатку запустіть сервер, а потім клієнт. На стороні клієнта на консолі "
"нічого не друкується; на стороні сервера ви повинні побачити щось на кшталт:"

#: ../../howto/logging-cookbook.rst:762
msgid ""
"Note that there are some security issues with pickle in some scenarios. If "
"these affect you, you can use an alternative serialization scheme by "
"overriding the :meth:`~SocketHandler.makePickle` method and implementing "
"your alternative there, as well as adapting the above script to use your "
"alternative serialization."
msgstr ""
"Обратите внимание, что в некоторых сценариях при использовании Pickle "
"возникают некоторые проблемы с безопасностью. Если это вас затрагивает, вы "
"можете использовать альтернативную схему сериализации, переопределив метод :"
"meth:`~SocketHandler.makePickle` и реализовав там свою альтернативу, а также "
"адаптировав приведенный выше сценарий для использования вашей альтернативной "
"сериализации."

#: ../../howto/logging-cookbook.rst:770
msgid "Running a logging socket listener in production"
msgstr "Запуск прослуховувача сокетів журналювання у виробництві"

#: ../../howto/logging-cookbook.rst:774
msgid ""
"To run a logging listener in production, you may need to use a process-"
"management tool such as `Supervisor <http://supervisord.org/>`_. `Here is a "
"Gist <socket-listener-gist_>`__ which provides the bare-bones files to run "
"the above functionality using Supervisor. It consists of the following files:"
msgstr ""
"Чтобы запустить прослушиватель журналов в рабочей среде, вам может "
"потребоваться использовать инструмент управления процессами, например "
"`Supervisor <http://supervisord.org/>`_. `Вот Gist <socket-listener-"
"gist_>`__, который предоставляет базовые файлы для запуска вышеуказанных "
"функций с помощью Supervisor. Он состоит из следующих файлов:"

#: ../../howto/logging-cookbook.rst:781
msgid "File"
msgstr "Arquivo"

#: ../../howto/logging-cookbook.rst:781
msgid "Purpose"
msgstr "Propósito"

#: ../../howto/logging-cookbook.rst:783
msgid ":file:`prepare.sh`"
msgstr ":file:`prepare.sh`"

#: ../../howto/logging-cookbook.rst:783
msgid "A Bash script to prepare the environment for testing"
msgstr "Скрипт Bash для подготовки среды к тестированию."

#: ../../howto/logging-cookbook.rst:786
msgid ":file:`supervisor.conf`"
msgstr ":file:`supervisor.conf`"

#: ../../howto/logging-cookbook.rst:786
msgid ""
"The Supervisor configuration file, which has entries for the listener and a "
"multi-process web application"
msgstr ""
"Файл конфигурации Supervisor, содержащий записи для прослушивателя и "
"многопроцессного веб-приложения."

#: ../../howto/logging-cookbook.rst:790
msgid ":file:`ensure_app.sh`"
msgstr ":file:`ensure_app.sh`"

#: ../../howto/logging-cookbook.rst:790
msgid ""
"A Bash script to ensure that Supervisor is running with the above "
"configuration"
msgstr ""
"Сценарий Bash, гарантирующий, что Supervisor работает с указанной выше "
"конфигурацией."

#: ../../howto/logging-cookbook.rst:793
msgid ":file:`log_listener.py`"
msgstr ":file:`log_listener.py`"

#: ../../howto/logging-cookbook.rst:793
msgid ""
"The socket listener program which receives log events and records them to a "
"file"
msgstr ""
"Программа-прослушиватель сокетов, которая получает события журнала и "
"записывает их в файл."

#: ../../howto/logging-cookbook.rst:796
msgid ":file:`main.py`"
msgstr ":file:`main.py`"

#: ../../howto/logging-cookbook.rst:796
msgid ""
"A simple web application which performs logging via a socket connected to "
"the listener"
msgstr ""
"Простое веб-приложение, которое выполняет журналирование через сокет, "
"подключенный к прослушивателю."

#: ../../howto/logging-cookbook.rst:799
msgid ":file:`webapp.json`"
msgstr ":file:`webapp.json`"

#: ../../howto/logging-cookbook.rst:799
msgid "A JSON configuration file for the web application"
msgstr "Файл конфигурации JSON для веб-приложения."

#: ../../howto/logging-cookbook.rst:801
msgid ":file:`client.py`"
msgstr ":file:`client.py`"

#: ../../howto/logging-cookbook.rst:801
msgid "A Python script to exercise the web application"
msgstr "Скрипт Python для работы с веб-приложением."

#: ../../howto/logging-cookbook.rst:804
msgid ""
"The web application uses `Gunicorn <https://gunicorn.org/>`_, which is a "
"popular web application server that starts multiple worker processes to "
"handle requests. This example setup shows how the workers can write to the "
"same log file without conflicting with one another --- they all go through "
"the socket listener."
msgstr ""
"Веб-приложение использует `Gunicorn <https://gunicorn.org/>`_, популярный "
"сервер веб-приложений, который запускает несколько рабочих процессов для "
"обработки запросов. В этом примере настройки показано, как рабочие могут "
"писать в один и тот же файл журнала, не конфликтуя друг с другом — все они "
"проходят через прослушиватель сокетов."

#: ../../howto/logging-cookbook.rst:809
msgid "To test these files, do the following in a POSIX environment:"
msgstr ""
"Чтобы протестировать эти файлы, выполните следующие действия в среде POSIX:"

#: ../../howto/logging-cookbook.rst:811
msgid ""
"Download `the Gist <socket-listener-gist_>`__ as a ZIP archive using the :"
"guilabel:`Download ZIP` button."
msgstr ""
"Загрузите `the Gist <socket-listener-gist_>`__ в виде ZIP-архива, используя "
"кнопку :guilabel:`Загрузить ZIP`."

#: ../../howto/logging-cookbook.rst:814
msgid "Unzip the above files from the archive into a scratch directory."
msgstr "Разархивируйте указанные выше файлы из архива в временный каталог."

#: ../../howto/logging-cookbook.rst:816
msgid ""
"In the scratch directory, run ``bash prepare.sh`` to get things ready. This "
"creates a :file:`run` subdirectory to contain Supervisor-related and log "
"files, and a :file:`venv` subdirectory to contain a virtual environment into "
"which ``bottle``, ``gunicorn`` and ``supervisor`` are installed."
msgstr ""
"В рабочем каталоге запустите bashprepree.sh, чтобы все было готово. При этом "
"создается подкаталог :file:`run` для хранения файлов журналов и файлов, "
"связанных с Supervisor, а также подкаталог :file:`venv` для хранения "
"виртуальной среды, в которой находятся ``bottle``, ``gunicorn`` и "
"``supervisor'. `` установлены."

#: ../../howto/logging-cookbook.rst:821
msgid ""
"Run ``bash ensure_app.sh`` to ensure that Supervisor is running with the "
"above configuration."
msgstr ""
"Запустите bash Sure_app.sh, чтобы убедиться, что Supervisor работает с "
"указанной выше конфигурацией."

#: ../../howto/logging-cookbook.rst:824
msgid ""
"Run ``venv/bin/python client.py`` to exercise the web application, which "
"will lead to records being written to the log."
msgstr ""
"Запустите ``venv/bin/python client.py``, чтобы протестировать веб-"
"приложение, что приведет к записи записей в журнал."

#: ../../howto/logging-cookbook.rst:827
msgid ""
"Inspect the log files in the :file:`run` subdirectory. You should see the "
"most recent log lines in files matching the pattern :file:`app.log*`. They "
"won't be in any particular order, since they have been handled concurrently "
"by different worker processes in a non-deterministic way."
msgstr ""
"Проверьте файлы журналов в подкаталоге :file:`run`. Вы должны увидеть самые "
"последние строки журнала в файлах, соответствующих шаблону :file:`app.log*`. "
"Они не будут располагаться в каком-то определенном порядке, поскольку они "
"обрабатывались одновременно разными рабочими процессами недетерминированным "
"образом."

#: ../../howto/logging-cookbook.rst:832
msgid ""
"You can shut down the listener and the web application by running ``venv/bin/"
"supervisorctl -c supervisor.conf shutdown``."
msgstr ""
"Вы можете закрыть прослушиватель и веб-приложение, запустив ``venv/bin/"
"supervisorctl -c Supervisor.conf Shutdown``."

#: ../../howto/logging-cookbook.rst:835
msgid ""
"You may need to tweak the configuration files in the unlikely event that the "
"configured ports clash with something else in your test environment."
msgstr ""
"Возможно, вам придется настроить файлы конфигурации в том маловероятном "
"случае, если настроенные порты будут конфликтовать с чем-то еще в вашей "
"тестовой среде."

#: ../../howto/logging-cookbook.rst:843
msgid "Adding contextual information to your logging output"
msgstr "Додавання контекстної інформації до вихідних даних журналу"

#: ../../howto/logging-cookbook.rst:845
msgid ""
"Sometimes you want logging output to contain contextual information in "
"addition to the parameters passed to the logging call. For example, in a "
"networked application, it may be desirable to log client-specific "
"information in the log (e.g. remote client's username, or IP address). "
"Although you could use the *extra* parameter to achieve this, it's not "
"always convenient to pass the information in this way. While it might be "
"tempting to create :class:`Logger` instances on a per-connection basis, this "
"is not a good idea because these instances are not garbage collected. While "
"this is not a problem in practice, when the number of :class:`Logger` "
"instances is dependent on the level of granularity you want to use in "
"logging an application, it could be hard to manage if the number of :class:"
"`Logger` instances becomes effectively unbounded."
msgstr ""
"Іноді потрібно, щоб вихід журналу містив контекстну інформацію на додаток до "
"параметрів, переданих до виклику журналу. Наприклад, у мережевій програмі "
"може бути бажаним реєструвати інформацію про клієнта в журналі (наприклад, "
"ім’я користувача віддаленого клієнта або IP-адресу). Хоча для цього можна "
"використовувати параметр *extra*, не завжди зручно передавати інформацію "
"таким чином. Хоча може виникнути спокуса створити екземпляри :class:`Logger` "
"для кожного з’єднання, це не дуже гарна ідея, оскільки ці екземпляри не "
"збираються для сміття. Хоча це не є проблемою на практиці, коли кількість "
"екземплярів :class:`Logger` залежить від рівня деталізації, який ви хочете "
"використовувати для реєстрації програми, може бути важко керувати кількістю :"
"class:`Екземпляри Logger` стають фактично необмеженими."

#: ../../howto/logging-cookbook.rst:860
msgid "Using LoggerAdapters to impart contextual information"
msgstr "Використання LoggerAdapters для передачі контекстної інформації"

#: ../../howto/logging-cookbook.rst:862
msgid ""
"An easy way in which you can pass contextual information to be output along "
"with logging event information is to use the :class:`LoggerAdapter` class. "
"This class is designed to look like a :class:`Logger`, so that you can call :"
"meth:`debug`, :meth:`info`, :meth:`warning`, :meth:`error`, :meth:"
"`exception`, :meth:`critical` and :meth:`log`. These methods have the same "
"signatures as their counterparts in :class:`Logger`, so you can use the two "
"types of instances interchangeably."
msgstr ""
"Простий спосіб, за допомогою якого ви можете передати контекстну інформацію "
"для виведення разом із інформацією про подію журналювання, полягає у "
"використанні класу :class:`LoggerAdapter`. Цей клас розроблено так, щоб "
"виглядати як :class:`Logger`, щоб ви могли викликати :meth:`debug`, :meth:"
"`info`, :meth:`warning`, :meth:`error`, :meth:`exception`, :meth:`critical` "
"і :meth:`log`. Ці методи мають ті самі сигнатури, що й їхні аналоги в :class:"
"`Logger`, тому ви можете використовувати обидва типи екземплярів як "
"взаємозамінні."

#: ../../howto/logging-cookbook.rst:870
msgid ""
"When you create an instance of :class:`LoggerAdapter`, you pass it a :class:"
"`Logger` instance and a dict-like object which contains your contextual "
"information. When you call one of the logging methods on an instance of :"
"class:`LoggerAdapter`, it delegates the call to the underlying instance of :"
"class:`Logger` passed to its constructor, and arranges to pass the "
"contextual information in the delegated call. Here's a snippet from the code "
"of :class:`LoggerAdapter`::"
msgstr ""
"Коли ви створюєте екземпляр :class:`LoggerAdapter`, ви передаєте йому "
"екземпляр :class:`Logger` і dict-подібний об’єкт, який містить вашу "
"контекстну інформацію. Коли ви викликаєте один із методів журналювання в "
"екземплярі :class:`LoggerAdapter`, він делегує виклик базовому екземпляру :"
"class:`Logger`, який передається його конструктору, і організовує передачу "
"контекстної інформації в делегованому виклику . Ось фрагмент коду :class:"
"`LoggerAdapter`::"

#: ../../howto/logging-cookbook.rst:886
msgid ""
"The :meth:`~LoggerAdapter.process` method of :class:`LoggerAdapter` is where "
"the contextual information is added to the logging output. It's passed the "
"message and keyword arguments of the logging call, and it passes back "
"(potentially) modified versions of these to use in the call to the "
"underlying logger. The default implementation of this method leaves the "
"message alone, but inserts an 'extra' key in the keyword argument whose "
"value is the dict-like object passed to the constructor. Of course, if you "
"had passed an 'extra' keyword argument in the call to the adapter, it will "
"be silently overwritten."
msgstr ""
"У методі :meth:`~LoggerAdapter.process` :class:`LoggerAdapter` контекстна "
"інформація додається до результатів журналювання. Він передає аргументи "
"повідомлення та ключове слово виклику журналювання, а також повертає "
"(потенційно) модифіковані версії їх для використання у виклику базовому "
"реєстратору. Реалізація цього методу за замовчуванням залишає повідомлення в "
"спокої, але вставляє \"додатковий\" ключ в аргумент ключового слова, "
"значенням якого є dict-подібний об’єкт, переданий конструктору. Звичайно, "
"якщо ви передали \"додатковий\" аргумент ключового слова під час виклику "
"адаптера, він буде мовчки перезаписаний."

#: ../../howto/logging-cookbook.rst:895
msgid ""
"The advantage of using 'extra' is that the values in the dict-like object "
"are merged into the :class:`LogRecord` instance's __dict__, allowing you to "
"use customized strings with your :class:`Formatter` instances which know "
"about the keys of the dict-like object. If you need a different method, e.g. "
"if you want to prepend or append the contextual information to the message "
"string, you just need to subclass :class:`LoggerAdapter` and override :meth:"
"`~LoggerAdapter.process` to do what you need. Here is a simple example::"
msgstr ""
"Перевага використання \"extra\" полягає в тому, що значення в dict-подібному "
"об’єкті об’єднуються в __dict__ екземпляра :class:`LogRecord`, що дозволяє "
"вам використовувати налаштовані рядки з вашими екземплярами :class:"
"`Formatter`, які знають про ключі диктоподібного об’єкта. Якщо вам потрібен "
"інший метод, напр. якщо ви хочете передати або додати контекстну інформацію "
"до рядка повідомлення, вам просто потрібно створити підклас :class:"
"`LoggerAdapter` і перевизначити :meth:`~LoggerAdapter.process`, щоб зробити "
"те, що вам потрібно. Ось простий приклад::"

#: ../../howto/logging-cookbook.rst:911
msgid "which you can use like this::"
msgstr "який можна використовувати таким чином::"

#: ../../howto/logging-cookbook.rst:916
msgid ""
"Then any events that you log to the adapter will have the value of "
"``some_conn_id`` prepended to the log messages."
msgstr ""
"Тоді будь-які події, які ви реєструєте в адаптері, матимуть значення "
"``some_conn_id`` до повідомлень журналу."

#: ../../howto/logging-cookbook.rst:920
msgid "Using objects other than dicts to pass contextual information"
msgstr ""
"Використання об’єктів, відмінних від dicts, для передачі контекстної "
"інформації"

#: ../../howto/logging-cookbook.rst:922
msgid ""
"You don't need to pass an actual dict to a :class:`LoggerAdapter` - you "
"could pass an instance of a class which implements ``__getitem__`` and "
"``__iter__`` so that it looks like a dict to logging. This would be useful "
"if you want to generate values dynamically (whereas the values in a dict "
"would be constant)."
msgstr ""
"Вам не потрібно передавати фактичний dict до :class:`LoggerAdapter` - ви "
"можете передати примірник класу, який реалізує ``__getitem__`` і "
"``__iter__``, щоб він виглядав як dict для журналювання. Це буде корисно, "
"якщо ви хочете генерувати значення динамічно (тоді як значення в dict будуть "
"постійними)."

#: ../../howto/logging-cookbook.rst:931
msgid "Using Filters to impart contextual information"
msgstr "Використання фільтрів для передачі контекстної інформації"

#: ../../howto/logging-cookbook.rst:933
msgid ""
"You can also add contextual information to log output using a user-defined :"
"class:`Filter`. ``Filter`` instances are allowed to modify the "
"``LogRecords`` passed to them, including adding additional attributes which "
"can then be output using a suitable format string, or if needed a custom :"
"class:`Formatter`."
msgstr ""
"Ви також можете додати контекстну інформацію до виведення журналу за "
"допомогою визначеного користувачем :class:`Filter`. Екземплярам ``Filter`` "
"дозволено змінювати ``LogRecords``, передані їм, включаючи додавання "
"додаткових атрибутів, які потім можуть бути виведені за допомогою рядка "
"відповідного формату або, якщо необхідно, спеціального :class:`Formatter`."

#: ../../howto/logging-cookbook.rst:938
msgid ""
"For example in a web application, the request being processed (or at least, "
"the interesting parts of it) can be stored in a threadlocal (:class:"
"`threading.local`) variable, and then accessed from a ``Filter`` to add, "
"say, information from the request - say, the remote IP address and remote "
"user's username - to the ``LogRecord``, using the attribute names 'ip' and "
"'user' as in the ``LoggerAdapter`` example above. In that case, the same "
"format string can be used to get similar output to that shown above. Here's "
"an example script::"
msgstr ""
"Наприклад, у веб-додатку запит, який обробляється (або, принаймні, його "
"цікаві частини) можна зберегти у змінній threadlocal (:class:`threading."
"local`), а потім отримати доступ із ``Фільтра`` щоб додати, скажімо, "
"інформацію із запиту - скажімо, віддалену IP-адресу та ім'я користувача "
"віддаленого користувача - до ``LogRecord``, використовуючи імена атрибутів "
"'ip' і 'user', як у прикладі ``LoggerAdapter`` вище . У цьому випадку можна "
"використати той самий рядок формату, щоб отримати вихід, схожий на показаний "
"вище. Ось приклад сценарію::"

#: ../../howto/logging-cookbook.rst:984
msgid "which, when run, produces something like:"
msgstr "який під час запуску створює щось на зразок:"

#: ../../howto/logging-cookbook.rst:1002
msgid "Use of ``contextvars``"
msgstr "Использование ``contextvars``"

#: ../../howto/logging-cookbook.rst:1004
msgid ""
"Since Python 3.7, the :mod:`contextvars` module has provided context-local "
"storage which works for both :mod:`threading` and :mod:`asyncio` processing "
"needs. This type of storage may thus be generally preferable to thread-"
"locals. The following example shows how, in a multi-threaded environment, "
"logs can populated with contextual information such as, for example, request "
"attributes handled by web applications."
msgstr ""
"Начиная с Python 3.7, модуль :mod:`contextvars` предоставляет контекстно-"
"локальное хранилище, которое подходит как для обработки :mod:`threading`, "
"так и для :mod:`asyncio`. Таким образом, этот тип хранилища может быть "
"предпочтительнее локальных потоков. В следующем примере показано, как в "
"многопоточной среде журналы могут заполняться контекстной информацией, такой "
"как, например, атрибуты запроса, обрабатываемые веб-приложениями."

#: ../../howto/logging-cookbook.rst:1010
msgid ""
"For the purposes of illustration, say that you have different web "
"applications, each independent of the other but running in the same Python "
"process and using a library common to them. How can each of these "
"applications have their own log, where all logging messages from the library "
"(and other request processing code) are directed to the appropriate "
"application's log file, while including in the log additional contextual "
"information such as client IP, HTTP request method and client username?"
msgstr ""
"В качестве иллюстрации предположим, что у вас есть разные веб-приложения, "
"каждое из которых независимо от другого, но выполняются в одном и том же "
"процессе Python и используют общую для них библиотеку. Как каждое из этих "
"приложений может иметь свой собственный журнал, где все сообщения журнала из "
"библиотеки (и другой код обработки запросов) направляются в файл журнала "
"соответствующего приложения, при этом в журнал включается дополнительная "
"контекстная информация, такая как IP-адрес клиента, метод HTTP-запроса и имя "
"пользователя клиента?"

#: ../../howto/logging-cookbook.rst:1017
msgid "Let's assume that the library can be simulated by the following code:"
msgstr ""
"Предположим, что библиотеку можно смоделировать с помощью следующего кода:"

#: ../../howto/logging-cookbook.rst:1033
msgid ""
"We can simulate the multiple web applications by means of two simple "
"classes, ``Request`` and ``WebApp``. These simulate how real threaded web "
"applications work - each request is handled by a thread:"
msgstr ""
"Мы можем моделировать несколько веб-приложений с помощью двух простых "
"классов: Request и WebApp. Они имитируют работу реальных многопоточных веб-"
"приложений — каждый запрос обрабатывается потоком:"

#: ../../howto/logging-cookbook.rst:1177
msgid ""
"If you run the above, you should find that roughly half the requests go "
"into :file:`app1.log` and the rest into :file:`app2.log`, and the all the "
"requests are logged to :file:`app.log`. Each webapp-specific log will "
"contain only log entries for only that webapp, and the request information "
"will be displayed consistently in the log (i.e. the information in each "
"dummy request will always appear together in a log line). This is "
"illustrated by the following shell output:"
msgstr ""
"Если вы запустите вышеописанное, вы обнаружите, что примерно половина "
"запросов поступает в :file:`app1.log`, а остальные - в :file:`app2.log`, и "
"все запросы записываются в :file:`app .log`. Каждый журнал конкретного веб-"
"приложения будет содержать только записи журнала только для этого веб-"
"приложения, а информация о запросе будет последовательно отображаться в "
"журнале (т. е. информация в каждом фиктивном запросе всегда будет "
"отображаться вместе в строке журнала). Это иллюстрируется следующим выводом "
"оболочки:"

#: ../../howto/logging-cookbook.rst:1224
msgid "Imparting contextual information in handlers"
msgstr "Передача контекстной информации в обработчики"

#: ../../howto/logging-cookbook.rst:1226
msgid ""
"Each :class:`~Handler` has its own chain of filters. If you want to add "
"contextual information to a :class:`LogRecord` without leaking it to other "
"handlers, you can use a filter that returns a new :class:`~LogRecord` "
"instead of modifying it in-place, as shown in the following script::"
msgstr ""
"Каждый :class:`~Handler` имеет свою собственную цепочку фильтров. Если вы "
"хотите добавить контекстную информацию в :class:`LogRecord`, не передавая ее "
"другим обработчикам, вы можете использовать фильтр, который возвращает "
"новый :class:`~LogRecord` вместо его модификации на месте, как показано на "
"рисунке следующий скрипт::"

#: ../../howto/logging-cookbook.rst:1253
msgid "Logging to a single file from multiple processes"
msgstr "Реєстрація в один файл з кількох процесів"

#: ../../howto/logging-cookbook.rst:1255
msgid ""
"Although logging is thread-safe, and logging to a single file from multiple "
"threads in a single process *is* supported, logging to a single file from "
"*multiple processes* is *not* supported, because there is no standard way to "
"serialize access to a single file across multiple processes in Python. If "
"you need to log to a single file from multiple processes, one way of doing "
"this is to have all the processes log to a :class:`~handlers.SocketHandler`, "
"and have a separate process which implements a socket server which reads "
"from the socket and logs to file. (If you prefer, you can dedicate one "
"thread in one of the existing processes to perform this function.) :ref:"
"`This section <network-logging>` documents this approach in more detail and "
"includes a working socket receiver which can be used as a starting point for "
"you to adapt in your own applications."
msgstr ""
"Хоча ведення журналу є потокобезпечним і *підтримується* журналювання в один "
"файл із кількох потоків в одному процесі, журналювання в один файл із "
"*кількох процесів *не* підтримується, оскільки немає стандартного способу "
"серіалізації доступу в один файл через кілька процесів у Python. Якщо вам "
"потрібно ввійти до одного файлу з кількох процесів, один із способів зробити "
"це — зареєструвати всі процеси в :class:`~handlers.SocketHandler` і мати "
"окремий процес, який реалізує сервер сокетів, який читає з сокет і журнали в "
"файл. (Якщо ви віддаєте перевагу, ви можете виділити один потік в одному з "
"існуючих процесів для виконання цієї функції.) :ref:`Цей розділ <network-"
"logging>` документує цей підхід більш детально та містить робочий приймач "
"сокетів, який можна використовувати як відправну точку для адаптації у "
"власних програмах."

#: ../../howto/logging-cookbook.rst:1268
msgid ""
"You could also write your own handler which uses the :class:"
"`~multiprocessing.Lock` class from the :mod:`multiprocessing` module to "
"serialize access to the file from your processes. The existing :class:"
"`FileHandler` and subclasses do not make use of :mod:`multiprocessing` at "
"present, though they may do so in the future. Note that at present, the :mod:"
"`multiprocessing` module does not provide working lock functionality on all "
"platforms (see https://bugs.python.org/issue3770)."
msgstr ""
"Ви також можете написати власний обробник, який використовує клас :class:"
"`~multiprocessing.Lock` з модуля :mod:`multiprocessing` для серіалізації "
"доступу до файлу з ваших процесів. Існуючий :class:`FileHandler` і підкласи "
"не використовують :mod:`multiprocessing` наразі, хоча вони можуть "
"використовувати це в майбутньому. Зауважте, що наразі модуль :mod:"
"`multiprocessing` не забезпечує робочу функцію блокування на всіх платформах "
"(див. https://bugs.python.org/issue3770)."

#: ../../howto/logging-cookbook.rst:1278
msgid ""
"Alternatively, you can use a ``Queue`` and a :class:`QueueHandler` to send "
"all logging events to one of the processes in your multi-process "
"application. The following example script demonstrates how you can do this; "
"in the example a separate listener process listens for events sent by other "
"processes and logs them according to its own logging configuration. Although "
"the example only demonstrates one way of doing it (for example, you may want "
"to use a listener thread rather than a separate listener process -- the "
"implementation would be analogous) it does allow for completely different "
"logging configurations for the listener and the other processes in your "
"application, and can be used as the basis for code meeting your own specific "
"requirements::"
msgstr ""
"Крім того, ви можете використовувати ``Queue`` і :class:`QueueHandler`, щоб "
"надсилати всі події журналювання до одного з процесів у вашій "
"багатопроцесовій програмі. Наступний приклад сценарію демонструє, як це "
"можна зробити; у прикладі окремий процес слухача прослуховує події, "
"надіслані іншими процесами, і реєструє їх відповідно до власної конфігурації "
"журналювання. Хоча приклад демонструє лише один спосіб зробити це "
"(наприклад, ви можете використовувати потік слухача, а не окремий процес "
"слухача — реалізація буде аналогічною), він дозволяє абсолютно різні "
"конфігурації журналювання для слухача та інших процеси у вашій програмі та "
"можуть бути використані як основа для коду, який відповідає вашим власним "
"вимогам:"

#: ../../howto/logging-cookbook.rst:1394
msgid ""
"A variant of the above script keeps the logging in the main process, in a "
"separate thread::"
msgstr ""
"Варіант наведеного вище сценарію зберігає журнали в основному процесі в "
"окремому потоці:"

#: ../../howto/logging-cookbook.rst:1489
msgid ""
"This variant shows how you can e.g. apply configuration for particular "
"loggers - e.g. the ``foo`` logger has a special handler which stores all "
"events in the ``foo`` subsystem in a file ``mplog-foo.log``. This will be "
"used by the logging machinery in the main process (even though the logging "
"events are generated in the worker processes) to direct the messages to the "
"appropriate destinations."
msgstr ""
"Цей варіант показує, як ви можете напр. застосувати конфігурацію для певних "
"реєстраторів - напр. Логер ``foo`` має спеціальний обробник, який зберігає "
"всі події в підсистемі ``foo`` у файлі ``mplog-foo.log``. Це "
"використовуватиметься механізмом реєстрації в основному процесі (навіть якщо "
"події журналювання генеруються в робочих процесах), щоб спрямувати "
"повідомлення до відповідних адресатів."

#: ../../howto/logging-cookbook.rst:1496
msgid "Using concurrent.futures.ProcessPoolExecutor"
msgstr "Використання concurrent.futures.ProcessPoolExecutor"

#: ../../howto/logging-cookbook.rst:1498
msgid ""
"If you want to use :class:`concurrent.futures.ProcessPoolExecutor` to start "
"your worker processes, you need to create the queue slightly differently. "
"Instead of"
msgstr ""
"Якщо ви хочете використовувати :class:`concurrent.futures."
"ProcessPoolExecutor` для запуску ваших робочих процесів, вам потрібно "
"створити чергу трохи інакше. Замість"

#: ../../howto/logging-cookbook.rst:1506
msgid "you should use"
msgstr "ви повинні використовувати"

#: ../../howto/logging-cookbook.rst:1512
msgid "and you can then replace the worker creation from this::"
msgstr "а потім ви можете замінити робоче створення з цього::"

#: ../../howto/logging-cookbook.rst:1523
msgid "to this (remembering to first import :mod:`concurrent.futures`)::"
msgstr "до цього (не забувши спочатку імпортувати :mod:`concurrent.futures`)::"

#: ../../howto/logging-cookbook.rst:1530
msgid "Deploying Web applications using Gunicorn and uWSGI"
msgstr "Розгортання веб-додатків за допомогою Gunicorn і uWSGI"

#: ../../howto/logging-cookbook.rst:1532
msgid ""
"When deploying Web applications using `Gunicorn <https://gunicorn.org/>`_ or "
"`uWSGI <https://uwsgi-docs.readthedocs.io/en/latest/>`_ (or similar), "
"multiple worker processes are created to handle client requests. In such "
"environments, avoid creating file-based handlers directly in your web "
"application. Instead, use a :class:`SocketHandler` to log from the web "
"application to a listener in a separate process. This can be set up using a "
"process management tool such as Supervisor - see `Running a logging socket "
"listener in production`_ for more details."
msgstr ""
"Під час розгортання веб-програм за допомогою `Gunicorn <https://gunicorn.org/"
">`_ або `uWSGI <https://uwsgi-docs.readthedocs.io/en/latest/>`_ (або "
"подібних), для обробки запитів клієнтів створюється кілька робочих процесів. "
"У таких середовищах уникайте створення обробників на основі файлів "
"безпосередньо у вашій веб-програмі. Замість цього використовуйте :class:"
"`SocketHandler`, щоб увійти з веб-програми до слухача в окремому процесі. Це "
"можна налаштувати за допомогою інструменту керування процесами, такого як "
"Supervisor - див. `Running a logging socket listener in production`_ для "
"отримання додаткової інформації."

#: ../../howto/logging-cookbook.rst:1542
msgid "Using file rotation"
msgstr "Використання ротації файлів"

#: ../../howto/logging-cookbook.rst:1547
msgid ""
"Sometimes you want to let a log file grow to a certain size, then open a new "
"file and log to that. You may want to keep a certain number of these files, "
"and when that many files have been created, rotate the files so that the "
"number of files and the size of the files both remain bounded. For this "
"usage pattern, the logging package provides a :class:`RotatingFileHandler`::"
msgstr ""
"Иногда вам нужно позволить файлу журнала вырасти до определенного размера, а "
"затем открыть новый файл и войти в него. Возможно, вы захотите сохранить "
"определенное количество этих файлов, а когда будет создано такое количество "
"файлов, поверните их так, чтобы количество файлов и размер файлов оставались "
"ограниченными. Для этого шаблона использования пакет журналирования "
"предоставляет :class:`RotatingFileHandler`::"

#: ../../howto/logging-cookbook.rst:1579
msgid ""
"The result should be 6 separate files, each with part of the log history for "
"the application:"
msgstr ""
"У результаті повинно вийти 6 окремих файлів, кожен з яких містить частину "
"журналу журналу програми:"

#: ../../howto/logging-cookbook.rst:1591
msgid ""
"The most current file is always :file:`logging_rotatingfile_example.out`, "
"and each time it reaches the size limit it is renamed with the suffix "
"``.1``. Each of the existing backup files is renamed to increment the suffix "
"(``.1`` becomes ``.2``, etc.)  and the ``.6`` file is erased."
msgstr ""
"Найновішим файлом завжди є :file:`logging_rotatingfile_example.out`, і "
"кожного разу, коли він досягає ліміту розміру, він перейменовується з "
"суфіксом ``.1``. Кожен із наявних файлів резервної копії перейменовується, "
"щоб збільшити суфікс (``.1`` стає ``.2`` тощо), а файл ``.6`` видаляється."

#: ../../howto/logging-cookbook.rst:1596
msgid ""
"Obviously this example sets the log length much too small as an extreme "
"example.  You would want to set *maxBytes* to an appropriate value."
msgstr ""
"Очевидно, що цей приклад встановлює занадто малу довжину журналу як "
"екстремальний приклад. Вам потрібно встановити відповідне значення "
"*maxBytes*."

#: ../../howto/logging-cookbook.rst:1604
msgid "Use of alternative formatting styles"
msgstr "Використання альтернативних стилів форматування"

#: ../../howto/logging-cookbook.rst:1606
msgid ""
"When logging was added to the Python standard library, the only way of "
"formatting messages with variable content was to use the %-formatting "
"method. Since then, Python has gained two new formatting approaches: :class:"
"`string.Template` (added in Python 2.4) and :meth:`str.format` (added in "
"Python 2.6)."
msgstr ""
"Коли журналювання було додано до стандартної бібліотеки Python, єдиним "
"способом форматування повідомлень зі змінним вмістом було використання "
"методу %-formatting. Відтоді Python отримав два нові підходи до "
"форматування: :class:`string.Template` (доданий у Python 2.4) і :meth:`str."
"format` (доданий у Python 2.6)."

#: ../../howto/logging-cookbook.rst:1612
msgid ""
"Logging (as of 3.2) provides improved support for these two additional "
"formatting styles. The :class:`Formatter` class been enhanced to take an "
"additional, optional keyword parameter named ``style``. This defaults to "
"``'%'``, but other possible values are ``'{'`` and ``'$'``, which correspond "
"to the other two formatting styles. Backwards compatibility is maintained by "
"default (as you would expect), but by explicitly specifying a style "
"parameter, you get the ability to specify format strings which work with :"
"meth:`str.format` or :class:`string.Template`. Here's an example console "
"session to show the possibilities:"
msgstr ""
"Журналування (станом на 3.2) забезпечує покращену підтримку цих двох "
"додаткових стилів форматування. Клас :class:`Formatter` було вдосконалено, "
"щоб прийняти додатковий необов’язковий параметр ключового слова під назвою "
"``style``. За замовчуванням це ``'%'``, але інші можливі значення ``'{'`` і "
"``'$'``, які відповідають двом іншим стилям форматування. Зворотна "
"сумісність підтримується за замовчуванням (як і слід було очікувати), але, "
"явно вказавши параметр стилю, ви отримуєте можливість вказати рядки формату, "
"які працюють із :meth:`str.format` або :class:`string.Template`. Ось приклад "
"сеансу консолі, щоб показати можливості:"

#: ../../howto/logging-cookbook.rst:1646
msgid ""
"Note that the formatting of logging messages for final output to logs is "
"completely independent of how an individual logging message is constructed. "
"That can still use %-formatting, as shown here::"
msgstr ""
"Зверніть увагу, що форматування повідомлень журналу для остаточного "
"виведення в журнали повністю не залежить від того, як побудовано окреме "
"повідомлення журналу. Це все ще може використовувати %-formatting, як "
"показано тут::"

#: ../../howto/logging-cookbook.rst:1654
msgid ""
"Logging calls (``logger.debug()``, ``logger.info()`` etc.) only take "
"positional parameters for the actual logging message itself, with keyword "
"parameters used only for determining options for how to handle the actual "
"logging call (e.g. the ``exc_info`` keyword parameter to indicate that "
"traceback information should be logged, or the ``extra`` keyword parameter "
"to indicate additional contextual information to be added to the log). So "
"you cannot directly make logging calls using :meth:`str.format` or :class:"
"`string.Template` syntax, because internally the logging package uses %-"
"formatting to merge the format string and the variable arguments. There "
"would be no changing this while preserving backward compatibility, since all "
"logging calls which are out there in existing code will be using %-format "
"strings."
msgstr ""
"Виклики журналювання (``logger.debug()``, ``logger.info()`` тощо) приймають "
"лише позиційні параметри для самого фактичного повідомлення журналу, а "
"параметри ключових слів використовуються лише для визначення варіантів "
"обробки фактичного виклик журналювання (наприклад, параметр ключового слова "
"``exc_info``, щоб вказати, що слід реєструвати інформацію відстеження, або "
"параметр ключового слова ``extra``, щоб вказати додаткову контекстну "
"інформацію, яку потрібно додати до журналу). Таким чином, ви не можете "
"безпосередньо здійснювати виклики журналювання за допомогою синтаксису :meth:"
"`str.format` або :class:`string.Template`, тому що внутрішньо пакет "
"журналювання використовує %-formatting для об’єднання рядка формату та "
"змінних аргументів. Це не змінюватиметься, зберігаючи зворотну сумісність, "
"оскільки всі виклики журналювання, які присутні в існуючому коді, "
"використовуватимуть рядки %-format."

#: ../../howto/logging-cookbook.rst:1667
msgid ""
"There is, however, a way that you can use {}- and $- formatting to construct "
"your individual log messages. Recall that for a message you can use an "
"arbitrary object as a message format string, and that the logging package "
"will call ``str()`` on that object to get the actual format string. Consider "
"the following two classes::"
msgstr ""
"Однак існує спосіб, за допомогою якого ви можете використовувати "
"форматування {}- і $- для створення ваших індивідуальних повідомлень "
"журналу. Згадайте, що для повідомлення ви можете використовувати довільний "
"об’єкт як рядок формату повідомлення, і що пакет журналювання викличе "
"``str()`` для цього об’єкта, щоб отримати фактичний рядок формату. "
"Розглянемо наступні два класи:"

#: ../../howto/logging-cookbook.rst:1691
msgid ""
"Either of these can be used in place of a format string, to allow {}- or $-"
"formatting to be used to build the actual \"message\" part which appears in "
"the formatted log output in place of \"%(message)s\" or \"{message}\" or "
"\"$message\". It's a little unwieldy to use the class names whenever you "
"want to log something, but it's quite palatable if you use an alias such as "
"__ (double underscore --- not to be confused with _, the single underscore "
"used as a synonym/alias for :func:`gettext.gettext` or its brethren)."
msgstr ""
"Будь-який із них можна використовувати замість рядка формату, щоб дозволити "
"використовувати {}- або $-форматування для побудови фактичної частини "
"\"повідомлення\", яка з’являється у відформатованому журналі замість "
"\"%(message)s\" або \"{message\". }\" або \"$message\". Трохи громіздко "
"використовувати назви класів, коли ви хочете щось зареєструвати, але це "
"цілком приємно, якщо ви використовуєте псевдонім, наприклад __ (подвійне "
"підкреслення --- не плутати з _, єдине підкреслення, яке використовується як "
"синонім/псевдонім для :func:`gettext.gettext` або його братів)."

#: ../../howto/logging-cookbook.rst:1699
msgid ""
"The above classes are not included in Python, though they're easy enough to "
"copy and paste into your own code. They can be used as follows (assuming "
"that they're declared in a module called ``wherever``):"
msgstr ""
"Наведені вище класи не включені в Python, хоча їх достатньо легко скопіювати "
"та вставити у свій власний код. Їх можна використовувати наступним чином (за "
"умови, що вони оголошені в модулі під назвою ``wherever``):"

#: ../../howto/logging-cookbook.rst:1721
msgid ""
"While the above examples use ``print()`` to show how the formatting works, "
"you would of course use ``logger.debug()`` or similar to actually log using "
"this approach."
msgstr ""
"У той час як у наведених вище прикладах використовується ``print()``, щоб "
"показати, як працює форматування, ви, звичайно, скористаєтеся ``logger."
"debug()`` або подібним, щоб справді вести журнал за допомогою цього підходу."

#: ../../howto/logging-cookbook.rst:1725
msgid ""
"One thing to note is that you pay no significant performance penalty with "
"this approach: the actual formatting happens not when you make the logging "
"call, but when (and if) the logged message is actually about to be output to "
"a log by a handler. So the only slightly unusual thing which might trip you "
"up is that the parentheses go around the format string and the arguments, "
"not just the format string. That's because the __ notation is just syntax "
"sugar for a constructor call to one of the :samp:`{XXX}Message` classes."
msgstr ""
"Следует отметить одну вещь: при таком подходе вы не платите значительного "
"снижения производительности: фактическое форматирование происходит не тогда, "
"когда вы делаете вызов журнала, а когда (и если) зарегистрированное "
"сообщение действительно собирается быть выведено в журнал обработчиком. "
"Итак, единственная немного необычная вещь, которая может вас сбить с толку, "
"это то, что круглые скобки заключают в себя строку формата и аргументы, а не "
"только строку формата. Это потому, что обозначение __ — это всего лишь "
"синтаксический сахар для вызова конструктора одного из классов :samp:`{XXX}"
"Message`."

#: ../../howto/logging-cookbook.rst:1733
msgid ""
"If you prefer, you can use a :class:`LoggerAdapter` to achieve a similar "
"effect to the above, as in the following example::"
msgstr ""
"Якщо ви віддаєте перевагу, ви можете використовувати :class:`LoggerAdapter`, "
"щоб досягти ефекту, подібного до наведеного вище, як у наступному прикладі::"

#: ../../howto/logging-cookbook.rst:1762
msgid ""
"The above script should log the message ``Hello, world!`` when run with "
"Python 3.8 or later."
msgstr ""
"Приведенный выше сценарий должен регистрировать сообщение «Hello, world!» "
"при запуске с Python 3.8 или более поздней версии."

#: ../../howto/logging-cookbook.rst:1771
msgid "Customizing ``LogRecord``"
msgstr "Personalizando o ``LogRecord``"

#: ../../howto/logging-cookbook.rst:1773
msgid ""
"Every logging event is represented by a :class:`LogRecord` instance. When an "
"event is logged and not filtered out by a logger's level, a :class:"
"`LogRecord` is created, populated with information about the event and then "
"passed to the handlers for that logger (and its ancestors, up to and "
"including the logger where further propagation up the hierarchy is "
"disabled). Before Python 3.2, there were only two places where this creation "
"was done:"
msgstr ""
"Кожна подія журналювання представлена екземпляром :class:`LogRecord`. Коли "
"подія реєструється і не відфільтровується на рівні реєстратора, створюється :"
"class:`LogRecord`, заповнюється інформацією про подію, а потім передається "
"обробникам цього реєстратора (і його предків, аж до реєстратора включно). де "
"подальше поширення вгору по ієрархії вимкнено). До Python 3.2 існувало лише "
"два місця, де це було зроблено:"

#: ../../howto/logging-cookbook.rst:1780
msgid ""
":meth:`Logger.makeRecord`, which is called in the normal process of logging "
"an event. This invoked :class:`LogRecord` directly to create an instance."
msgstr ""
":meth:`Logger.makeRecord`, який викликається в звичайному процесі реєстрації "
"події. Це безпосередньо викликало :class:`LogRecord` для створення "
"екземпляра."

#: ../../howto/logging-cookbook.rst:1783
msgid ""
":func:`makeLogRecord`, which is called with a dictionary containing "
"attributes to be added to the LogRecord. This is typically invoked when a "
"suitable dictionary has been received over the network (e.g. in pickle form "
"via a :class:`~handlers.SocketHandler`, or in JSON form via an :class:"
"`~handlers.HTTPHandler`)."
msgstr ""
":func:`makeLogRecord`, який викликається зі словником, що містить атрибути, "
"які потрібно додати до LogRecord. Це зазвичай викликається, коли через "
"мережу отримано відповідний словник (наприклад, у формі pickle через :class:"
"`~handlers.SocketHandler` або у формі JSON через :class:`~handlers."
"HTTPHandler`)."

#: ../../howto/logging-cookbook.rst:1789
msgid ""
"This has usually meant that if you need to do anything special with a :class:"
"`LogRecord`, you've had to do one of the following."
msgstr ""
"Зазвичай це означало, що якщо вам потрібно зробити щось особливе з :class:"
"`LogRecord`, ви повинні зробити одну з наступних дій."

#: ../../howto/logging-cookbook.rst:1792
msgid ""
"Create your own :class:`Logger` subclass, which overrides :meth:`Logger."
"makeRecord`, and set it using :func:`~logging.setLoggerClass` before any "
"loggers that you care about are instantiated."
msgstr ""
"Створіть свій власний підклас :class:`Logger`, який замінює :meth:`Logger."
"makeRecord`, і встановіть його за допомогою :func:`~logging.setLoggerClass` "
"перед створенням будь-яких реєстраторів, які вас цікавлять."

#: ../../howto/logging-cookbook.rst:1795
msgid ""
"Add a :class:`Filter` to a logger or handler, which does the necessary "
"special manipulation you need when its :meth:`~Filter.filter` method is "
"called."
msgstr ""
"Додайте :class:`Filter` до реєстратора або обробника, який виконує необхідні "
"спеціальні маніпуляції, які вам потрібні, коли викликається його метод :meth:"
"`~Filter.filter`."

#: ../../howto/logging-cookbook.rst:1799
msgid ""
"The first approach would be a little unwieldy in the scenario where (say) "
"several different libraries wanted to do different things. Each would "
"attempt to set its own :class:`Logger` subclass, and the one which did this "
"last would win."
msgstr ""
"Перший підхід був би трохи громіздким у сценарії, коли (скажімо) кілька "
"різних бібліотек хотіли б робити різні речі. Кожен намагатиметься встановити "
"власний підклас :class:`Logger`, і виграє той, хто зробить це останнім."

#: ../../howto/logging-cookbook.rst:1804
msgid ""
"The second approach works reasonably well for many cases, but does not allow "
"you to e.g. use a specialized subclass of :class:`LogRecord`. Library "
"developers can set a suitable filter on their loggers, but they would have "
"to remember to do this every time they introduced a new logger (which they "
"would do simply by adding new packages or modules and doing ::"
msgstr ""
"Другий підхід працює досить добре для багатьох випадків, але не дозволяє "
"вам, наприклад, використовувати спеціалізований підклас :class:`LogRecord`. "
"Розробники бібліотек можуть встановити відповідний фільтр для своїх "
"реєстраторів, але вони повинні пам’ятати про це щоразу, коли вводять новий "
"реєстратор (що вони робили б, просто додаючи нові пакунки чи модулі та "
"виконуючи:"

#: ../../howto/logging-cookbook.rst:1812
msgid ""
"at module level). It's probably one too many things to think about. "
"Developers could also add the filter to a :class:`~logging.NullHandler` "
"attached to their top-level logger, but this would not be invoked if an "
"application developer attached a handler to a lower-level library logger --- "
"so output from that handler would not reflect the intentions of the library "
"developer."
msgstr ""
"на рівні модуля). Ймовірно, це занадто багато речей, про які варто думати. "
"Розробники також можуть додати фільтр до :class:`~logging.NullHandler`, "
"прикріпленого до їхнього реєстратора верхнього рівня, але це не буде "
"викликано, якщо розробник програми приєднає обробник до реєстратора "
"бібліотеки нижчого рівня --- тому виведіть з цього обробника не "
"відображатиме намірів розробника бібліотеки."

#: ../../howto/logging-cookbook.rst:1818
msgid ""
"In Python 3.2 and later, :class:`~logging.LogRecord` creation is done "
"through a factory, which you can specify. The factory is just a callable you "
"can set with :func:`~logging.setLogRecordFactory`, and interrogate with :"
"func:`~logging.getLogRecordFactory`. The factory is invoked with the same "
"signature as the :class:`~logging.LogRecord` constructor, as :class:"
"`LogRecord` is the default setting for the factory."
msgstr ""
"У Python 3.2 і пізніших версіях створення :class:`~logging.LogRecord` "
"здійснюється через фабрику, яку ви можете вказати. Фабрика — це просто "
"виклик, який можна встановити за допомогою :func:`~logging."
"setLogRecordFactory` і запитати за допомогою :func:`~logging."
"getLogRecordFactory`. Фабрика викликається з тим самим підписом, що й "
"конструктор :class:`~logging.LogRecord`, оскільки :class:`LogRecord` є "
"параметром за замовчуванням для фабрики."

#: ../../howto/logging-cookbook.rst:1825
msgid ""
"This approach allows a custom factory to control all aspects of LogRecord "
"creation. For example, you could return a subclass, or just add some "
"additional attributes to the record once created, using a pattern similar to "
"this::"
msgstr ""
"Цей підхід дозволяє спеціальній фабрикі контролювати всі аспекти створення "
"LogRecord. Наприклад, ви можете повернути підклас або просто додати деякі "
"додаткові атрибути до створеного запису, використовуючи шаблон, подібний до "
"цього:"

#: ../../howto/logging-cookbook.rst:1838
msgid ""
"This pattern allows different libraries to chain factories together, and as "
"long as they don't overwrite each other's attributes or unintentionally "
"overwrite the attributes provided as standard, there should be no surprises. "
"However, it should be borne in mind that each link in the chain adds run-"
"time overhead to all logging operations, and the technique should only be "
"used when the use of a :class:`Filter` does not provide the desired result."
msgstr ""
"Цей шаблон дозволяє різним бібліотекам об’єднувати фабрики разом, і якщо "
"вони не перезаписують атрибути одна одної або ненавмисно перезаписують "
"атрибути, надані як стандартні, не повинно бути сюрпризів. Однак слід мати "
"на увазі, що кожна ланка в ланцюжку додає накладні витрати на час виконання "
"для всіх операцій журналювання, і цю техніку слід використовувати лише тоді, "
"коли використання :class:`Filter` не забезпечує бажаного результату."

#: ../../howto/logging-cookbook.rst:1850
msgid "Subclassing QueueHandler and QueueListener- a ZeroMQ example"
msgstr "Создание подклассов QueueHandler и QueueListener — пример ZeroMQ"

#: ../../howto/logging-cookbook.rst:1853 ../../howto/logging-cookbook.rst:1985
msgid "Subclass ``QueueHandler``"
msgstr "Подкласс ``QueueHandler``"

#: ../../howto/logging-cookbook.rst:1855
msgid ""
"You can use a :class:`QueueHandler` subclass to send messages to other kinds "
"of queues, for example a ZeroMQ 'publish' socket. In the example below,the "
"socket is created separately and passed to the handler (as its 'queue')::"
msgstr ""
"Ви можете використовувати підклас :class:`QueueHandler` для надсилання "
"повідомлень в інші типи черг, наприклад, сокет ZeroMQ 'publish'. У "
"наведеному нижче прикладі сокет створюється окремо та передається обробнику "
"(як його \"черга\"):"

#: ../../howto/logging-cookbook.rst:1874
msgid ""
"Of course there are other ways of organizing this, for example passing in "
"the data needed by the handler to create the socket::"
msgstr ""
"Звичайно, існують інші способи організації цього, наприклад, передача даних, "
"необхідних обробнику для створення сокета::"

#: ../../howto/logging-cookbook.rst:1892 ../../howto/logging-cookbook.rst:1922
msgid "Subclass ``QueueListener``"
msgstr "Подкласс ``QueueListener``"

#: ../../howto/logging-cookbook.rst:1894
msgid ""
"You can also subclass :class:`QueueListener` to get messages from other "
"kinds of queues, for example a ZeroMQ 'subscribe' socket. Here's an example::"
msgstr ""
"Ви також можете створити підклас :class:`QueueListener`, щоб отримувати "
"повідомлення з інших типів черг, наприклад, сокет ZeroMQ 'subscribe'. Ось "
"приклад::"

#: ../../howto/logging-cookbook.rst:1912
msgid "Subclassing QueueHandler and QueueListener- a ``pynng`` example"
msgstr "Создание подклассов QueueHandler и QueueListener — пример ``pyng``"

#: ../../howto/logging-cookbook.rst:1914
msgid ""
"In a similar way to the above section, we can implement a listener and "
"handler using `pynng <https://pypi.org/project/pynng/>`_, which is a Python "
"binding to `NNG <https://nng.nanomsg.org/>`_, billed as a spiritual "
"successor to ZeroMQ. The following snippets illustrate -- you can test them "
"in an environment which has ``pynng`` installed. Juat for variety, we "
"present the listener first."
msgstr ""

#: ../../howto/logging-cookbook.rst:2034
msgid "You can run the above two snippets in separate command shells."
msgstr ""

#: ../../howto/logging-cookbook.rst:2038
msgid "An example dictionary-based configuration"
msgstr "Приклад конфігурації на основі словника"

#: ../../howto/logging-cookbook.rst:2040
msgid ""
"Below is an example of a logging configuration dictionary - it's taken from "
"the `documentation on the Django project <https://docs.djangoproject.com/en/"
"stable/topics/logging/#configuring-logging>`_. This dictionary is passed to :"
"func:`~config.dictConfig` to put the configuration into effect::"
msgstr ""
"Нижче наведено приклад словника конфігурації журналювання — його взято з "
"`документації проекту Django <https://docs.djangoproject.com/en/stable/"
"topics/logging/#configuring-logging>`_. Цей словник передається до :func:"
"`~config.dictConfig` для введення в дію конфігурації::"

#: ../../howto/logging-cookbook.rst:2093
msgid ""
"For more information about this configuration, you can see the `relevant "
"section <https://docs.djangoproject.com/en/stable/topics/logging/"
"#configuring-logging>`_ of the Django documentation."
msgstr ""
"Для отримання додаткової інформації про цю конфігурацію ви можете "
"переглянути `відповідний розділ <https://docs.djangoproject.com/en/stable/"
"topics/logging/#configuring-logging>`_ документації Django."

#: ../../howto/logging-cookbook.rst:2100
msgid "Using a rotator and namer to customize log rotation processing"
msgstr ""
"Використання ротатора та іменника для налаштування обробки ротації журналу"

#: ../../howto/logging-cookbook.rst:2102
msgid ""
"An example of how you can define a namer and rotator is given in the "
"following runnable script, which shows gzip compression of the log file::"
msgstr ""
"Пример того, как вы можете определить имя и ротатор, приведен в следующем "
"исполняемом скрипте, который показывает сжатие файла журнала gzip:"

#: ../../howto/logging-cookbook.rst:2133
msgid ""
"After running this, you will see six new files, five of which are compressed:"
msgstr "После запуска вы увидите шесть новых файлов, пять из которых сжаты:"

#: ../../howto/logging-cookbook.rst:2146
msgid "A more elaborate multiprocessing example"
msgstr "Більш складний приклад багатопроцесорної обробки"

#: ../../howto/logging-cookbook.rst:2148
msgid ""
"The following working example shows how logging can be used with "
"multiprocessing using configuration files. The configurations are fairly "
"simple, but serve to illustrate how more complex ones could be implemented "
"in a real multiprocessing scenario."
msgstr ""
"Наступний робочий приклад показує, як журналювання можна використовувати з "
"багатопроцесорною обробкою за допомогою файлів конфігурації. Конфігурації "
"досить прості, але служать для ілюстрації того, як більш складні можуть бути "
"реалізовані в реальному багатопроцесорному сценарії."

#: ../../howto/logging-cookbook.rst:2153
msgid ""
"In the example, the main process spawns a listener process and some worker "
"processes. Each of the main process, the listener and the workers have three "
"separate configurations (the workers all share the same configuration). We "
"can see logging in the main process, how the workers log to a QueueHandler "
"and how the listener implements a QueueListener and a more complex logging "
"configuration, and arranges to dispatch events received via the queue to the "
"handlers specified in the configuration. Note that these configurations are "
"purely illustrative, but you should be able to adapt this example to your "
"own scenario."
msgstr ""
"У прикладі головний процес породжує процес слухача та деякі робочі процеси. "
"Кожен із основного процесу, слухача та робочих має три окремі конфігурації "
"(усі робочі мають однакову конфігурацію). Ми можемо побачити реєстрацію в "
"основному процесі, як працівники входять до QueueHandler і як слухач "
"реалізує QueueListener і більш складну конфігурацію журналювання, а також "
"організовує відправку подій, отриманих через чергу, до обробників, указаних "
"у конфігурації. Зауважте, що ці конфігурації є суто ілюстративними, але ви "
"зможете адаптувати цей приклад до власного сценарію."

#: ../../howto/logging-cookbook.rst:2163
msgid ""
"Here's the script - the docstrings and the comments hopefully explain how it "
"works::"
msgstr ""
"Ось сценарій - рядки документації та коментарі, сподіваюся, пояснюють, як це "
"працює::"

#: ../../howto/logging-cookbook.rst:2375
msgid "Inserting a BOM into messages sent to a SysLogHandler"
msgstr "Вставлення BOM у повідомлення, надіслані до SysLogHandler"

#: ../../howto/logging-cookbook.rst:2377
msgid ""
":rfc:`5424` requires that a Unicode message be sent to a syslog daemon as a "
"set of bytes which have the following structure: an optional pure-ASCII "
"component, followed by a UTF-8 Byte Order Mark (BOM), followed by Unicode "
"encoded using UTF-8. (See the :rfc:`relevant section of the specification "
"<5424#section-6>`.)"
msgstr ""
":rfc:`5424` вимагає, щоб повідомлення Unicode надсилалося до демона "
"системного журналу як набір байтів із такою структурою: необов’язковий "
"чистий ASCII-компонент, за яким слідує UTF-8 Byte Order Mark (BOM), за яким "
"слідує Юнікод, закодований за допомогою UTF-8. (Див. :rfc:`відповідний "
"розділ специфікації <5424#section-6>`.)"

#: ../../howto/logging-cookbook.rst:2383
msgid ""
"In Python 3.1, code was added to :class:`~logging.handlers.SysLogHandler` to "
"insert a BOM into the message, but unfortunately, it was implemented "
"incorrectly, with the BOM appearing at the beginning of the message and "
"hence not allowing any pure-ASCII component to appear before it."
msgstr ""
"У Python 3.1 до :class:`~logging.handlers.SysLogHandler` було додано код для "
"вставлення BOM у повідомлення, але, на жаль, він був реалізований "
"неправильно, оскільки BOM з’являвся на початку повідомлення, а отже, не "
"дозволяв будь-які компонент pure-ASCII, який з’явиться перед ним."

#: ../../howto/logging-cookbook.rst:2389
msgid ""
"As this behaviour is broken, the incorrect BOM insertion code is being "
"removed from Python 3.2.4 and later. However, it is not being replaced, and "
"if you want to produce :rfc:`5424`-compliant messages which include a BOM, "
"an optional pure-ASCII sequence before it and arbitrary Unicode after it, "
"encoded using UTF-8, then you need to do the following:"
msgstr ""
"Оскільки ця поведінка порушена, неправильний код вставки BOM видаляється з "
"Python 3.2.4 і пізніших версій. Однак його не буде замінено, і якщо ви "
"хочете створювати повідомлення, сумісні з :rfc:`5424`, які включають "
"специфікацію матеріалів, необов’язкову чисту послідовність ASCII перед нею "
"та довільний код Unicode після неї, закодований за допомогою UTF-8, тоді ви "
"потрібно зробити наступне:"

#: ../../howto/logging-cookbook.rst:2395
msgid ""
"Attach a :class:`~logging.Formatter` instance to your :class:`~logging."
"handlers.SysLogHandler` instance, with a format string such as::"
msgstr ""
"Приєднайте екземпляр :class:`~logging.Formatter` до вашого екземпляра :class:"
"`~logging.handlers.SysLogHandler` із рядком форматування, наприклад:"

#: ../../howto/logging-cookbook.rst:2401
msgid ""
"The Unicode code point U+FEFF, when encoded using UTF-8, will be encoded as "
"a UTF-8 BOM -- the byte-string ``b'\\xef\\xbb\\xbf'``."
msgstr ""
"Кодова точка Юнікоду U+FEFF, коли вона кодується за допомогою UTF-8, буде "
"закодована як UTF-8 BOM -- рядок байтів ``b'\\xef\\xbb\\xbf``."

#: ../../howto/logging-cookbook.rst:2404
msgid ""
"Replace the ASCII section with whatever placeholders you like, but make sure "
"that the data that appears in there after substitution is always ASCII (that "
"way, it will remain unchanged after UTF-8 encoding)."
msgstr ""
"Замініть розділ ASCII будь-якими заповнювачами, але переконайтеся, що дані, "
"які з’являються в ньому після заміни, завжди мають ASCII (таким чином вони "
"залишаться незмінними після кодування UTF-8)."

#: ../../howto/logging-cookbook.rst:2408
msgid ""
"Replace the Unicode section with whatever placeholders you like; if the data "
"which appears there after substitution contains characters outside the ASCII "
"range, that's fine -- it will be encoded using UTF-8."
msgstr ""
"Замініть розділ Unicode будь-якими заповнювачами; якщо дані, які з’являються "
"там після заміни, містять символи поза діапазоном ASCII, це нормально – вони "
"будуть закодовані за допомогою UTF-8."

#: ../../howto/logging-cookbook.rst:2412
msgid ""
"The formatted message *will* be encoded using UTF-8 encoding by "
"``SysLogHandler``. If you follow the above rules, you should be able to "
"produce :rfc:`5424`-compliant messages. If you don't, logging may not "
"complain, but your messages will not be RFC 5424-compliant, and your syslog "
"daemon may complain."
msgstr ""
"Відформатоване повідомлення *буде* закодовано за допомогою кодування UTF-8 "
"за допомогою ``SysLogHandler``. Якщо ви дотримуєтеся наведених вище правил, "
"ви зможете створювати :rfc:`5424`-сумісні повідомлення. Якщо ви цього не "
"зробите, журналювання може не скаржитися, але ваші повідомлення не будуть "
"сумісними з RFC 5424, і ваш демон системного журналу може скаржитися."

#: ../../howto/logging-cookbook.rst:2419
msgid "Implementing structured logging"
msgstr "Впровадження структурованого журналювання"

#: ../../howto/logging-cookbook.rst:2421
msgid ""
"Although most logging messages are intended for reading by humans, and thus "
"not readily machine-parseable, there might be circumstances where you want "
"to output messages in a structured format which *is* capable of being parsed "
"by a program (without needing complex regular expressions to parse the log "
"message). This is straightforward to achieve using the logging package. "
"There are a number of ways in which this could be achieved, but the "
"following is a simple approach which uses JSON to serialise the event in a "
"machine-parseable manner::"
msgstr ""
"Незважаючи на те, що більшість повідомлень журналу призначені для читання "
"людьми, і тому їх не легко аналізувати машиною, можуть виникнути обставини, "
"коли ви захочете вивести повідомлення у структурованому форматі, який *може* "
"проаналізувати програма (без потреби у складних регулярних виразах). щоб "
"проаналізувати повідомлення журналу). Це легко досягти за допомогою пакета "
"журналювання. Існує кілька способів, за допомогою яких цього можна досягти, "
"але нижче наведено простий підхід, який використовує JSON для серіалізації "
"події машинним способом:"

#: ../../howto/logging-cookbook.rst:2445
msgid "If the above script is run, it prints:"
msgstr "Якщо наведений вище сценарій запущено, він друкує:"

#: ../../howto/logging-cookbook.rst:2451 ../../howto/logging-cookbook.rst:2493
msgid ""
"Note that the order of items might be different according to the version of "
"Python used."
msgstr ""
"Зауважте, що порядок елементів може відрізнятися залежно від версії Python, "
"що використовується."

#: ../../howto/logging-cookbook.rst:2454
msgid ""
"If you need more specialised processing, you can use a custom JSON encoder, "
"as in the following complete example::"
msgstr ""
"Якщо вам потрібна більш спеціалізована обробка, ви можете використовувати "
"спеціальний кодер JSON, як у наступному повному прикладі:"

#: ../../howto/logging-cookbook.rst:2487
msgid "When the above script is run, it prints:"
msgstr "Коли наведений вище сценарій виконується, він друкує:"

#: ../../howto/logging-cookbook.rst:2502
msgid "Customizing handlers with :func:`dictConfig`"
msgstr "Налаштування обробників за допомогою :func:`dictConfig`"

#: ../../howto/logging-cookbook.rst:2504
msgid ""
"There are times when you want to customize logging handlers in particular "
"ways, and if you use :func:`dictConfig` you may be able to do this without "
"subclassing. As an example, consider that you may want to set the ownership "
"of a log file. On POSIX, this is easily done using :func:`shutil.chown`, but "
"the file handlers in the stdlib don't offer built-in support. You can "
"customize handler creation using a plain function such as::"
msgstr ""
"Бувають випадки, коли ви хочете налаштувати обробники журналу певним чином, "
"і якщо ви використовуєте :func:`dictConfig`, ви можете зробити це без "
"підкласів. Як приклад, подумайте, що ви можете встановити право власності на "
"файл журналу. У POSIX це легко зробити за допомогою :func:`shutil.chown`, "
"але обробники файлів у stdlib не пропонують вбудованої підтримки. Ви можете "
"налаштувати створення обробника за допомогою простої функції, такої як:"

#: ../../howto/logging-cookbook.rst:2518
msgid ""
"You can then specify, in a logging configuration passed to :func:"
"`dictConfig`, that a logging handler be created by calling this function::"
msgstr ""
"Потім ви можете вказати в конфігурації журналювання, переданій у :func:"
"`dictConfig`, щоб обробник журналювання було створено шляхом виклику цієї "
"функції::"

#: ../../howto/logging-cookbook.rst:2551
msgid ""
"In this example I am setting the ownership using the ``pulse`` user and "
"group, just for the purposes of illustration. Putting it together into a "
"working script, ``chowntest.py``::"
msgstr ""
"У цьому прикладі я встановлюю право власності за допомогою користувача та "
"групи ``pulse`` лише для ілюстрації. Об’єднавши це в робочий сценарій, "
"``chowntest.py``::"

#: ../../howto/logging-cookbook.rst:2598
msgid "To run this, you will probably need to run as ``root``:"
msgstr "Щоб запустити це, вам, ймовірно, потрібно буде запустити як ``root``:"

#: ../../howto/logging-cookbook.rst:2608
msgid ""
"Note that this example uses Python 3.3 because that's where :func:`shutil."
"chown` makes an appearance. This approach should work with any Python "
"version that supports :func:`dictConfig` - namely, Python 2.7, 3.2 or later. "
"With pre-3.3 versions, you would need to implement the actual ownership "
"change using e.g. :func:`os.chown`."
msgstr ""
"Зверніть увагу, що в цьому прикладі використовується Python 3.3, тому що "
"саме там з’являється :func:`shutil.chown`. Цей підхід має працювати з будь-"
"якою версією Python, яка підтримує :func:`dictConfig`, а саме з Python 2.7, "
"3.2 або новішою. У версіях до 3.3 вам потрібно було б реалізувати фактичну "
"зміну власності, використовуючи, наприклад, :func:`os.chown`."

#: ../../howto/logging-cookbook.rst:2614
msgid ""
"In practice, the handler-creating function may be in a utility module "
"somewhere in your project. Instead of the line in the configuration::"
msgstr ""
"На практиці функція створення обробника може бути десь у службовому модулі "
"вашого проекту. Замість рядка в конфігурації::"

#: ../../howto/logging-cookbook.rst:2619
msgid "you could use e.g.::"
msgstr "ви можете використовувати, наприклад::"

#: ../../howto/logging-cookbook.rst:2623
msgid ""
"where ``project.util`` can be replaced with the actual name of the package "
"where the function resides. In the above working script, using ``'ext://"
"__main__.owned_file_handler'`` should work. Here, the actual callable is "
"resolved by :func:`dictConfig` from the ``ext://`` specification."
msgstr ""
"де ``project.util`` можна замінити фактичною назвою пакета, де знаходиться "
"функція. У наведеному вище робочому сценарії використання ``'ext://__main__."
"owned_file_handler`` має працювати. Тут фактичний виклик визначається за "
"допомогою :func:`dictConfig` із специфікації ``ext://``."

#: ../../howto/logging-cookbook.rst:2628
msgid ""
"This example hopefully also points the way to how you could implement other "
"types of file change - e.g. setting specific POSIX permission bits - in the "
"same way, using :func:`os.chmod`."
msgstr ""
"Сподіваємось, цей приклад також вказує шлях до того, як ви можете "
"реалізувати інші типи змін файлів - наприклад. встановлення певних бітів "
"дозволу POSIX - таким же чином, за допомогою :func:`os.chmod`."

#: ../../howto/logging-cookbook.rst:2632
msgid ""
"Of course, the approach could also be extended to types of handler other "
"than a :class:`~logging.FileHandler` - for example, one of the rotating file "
"handlers, or a different type of handler altogether."
msgstr ""
"Звичайно, цей підхід також можна розширити до типів обробників, відмінних "
"від :class:`~logging.FileHandler` - наприклад, одного з обробників файлів, "
"що обертаються, або зовсім іншого типу обробника."

#: ../../howto/logging-cookbook.rst:2642
msgid "Using particular formatting styles throughout your application"
msgstr "Використання певних стилів форматування у вашій програмі"

#: ../../howto/logging-cookbook.rst:2644
msgid ""
"In Python 3.2, the :class:`~logging.Formatter` gained a ``style`` keyword "
"parameter which, while defaulting to ``%`` for backward compatibility, "
"allowed the specification of ``{`` or ``$`` to support the formatting "
"approaches supported by :meth:`str.format` and :class:`string.Template`. "
"Note that this governs the formatting of logging messages for final output "
"to logs, and is completely orthogonal to how an individual logging message "
"is constructed."
msgstr ""
"У Python 3.2 :class:`~logging.Formatter` отримав параметр ключового слова "
"``style``, який, незважаючи на значення за умовчанням ``%`` для зворотної "
"сумісності, дозволяв специфікацію ``{`` або ``$`` для підтримки підходів до "
"форматування, які підтримуються :meth:`str.format` і :class:`string."
"Template`. Зауважте, що це керує форматуванням повідомлень журналу для "
"остаточного виведення в журнали та повністю ортогонально до того, як "
"будується окреме повідомлення журналу."

#: ../../howto/logging-cookbook.rst:2651
msgid ""
"Logging calls (:meth:`~Logger.debug`, :meth:`~Logger.info` etc.) only take "
"positional parameters for the actual logging message itself, with keyword "
"parameters used only for determining options for how to handle the logging "
"call (e.g. the ``exc_info`` keyword parameter to indicate that traceback "
"information should be logged, or the ``extra`` keyword parameter to indicate "
"additional contextual information to be added to the log). So you cannot "
"directly make logging calls using :meth:`str.format` or :class:`string."
"Template` syntax, because internally the logging package uses %-formatting "
"to merge the format string and the variable arguments. There would be no "
"changing this while preserving backward compatibility, since all logging "
"calls which are out there in existing code will be using %-format strings."
msgstr ""
"Вызовы ведения журнала (:meth:`~Logger.debug`, :meth:`~Logger.info` и т. д.) "
"принимают только позиционные параметры для самого фактического сообщения "
"журнала, а параметры ключевых слов используются только для определения "
"вариантов обработки журнала. вызов (например, параметр ключевого слова "
"``exc_info``, чтобы указать, что информация трассировки должна быть "
"зарегистрирована, или параметр ключевого слова ``extra``, чтобы указать "
"дополнительную контекстную информацию, которая должна быть добавлена ​​в "
"журнал). Таким образом, вы не можете напрямую выполнять вызовы "
"журналирования, используя синтаксис :meth:`str.format` или :class:`string."
"Template`, поскольку внутри пакета журналирования используется %-f "
"форматирование для объединения строки формата и аргументов переменной. Это "
"не будет изменено при сохранении обратной совместимости, поскольку все "
"вызовы журналирования, которые есть в существующем коде, будут использовать "
"%-f форматировать строки."

#: ../../howto/logging-cookbook.rst:2663
msgid ""
"There have been suggestions to associate format styles with specific "
"loggers, but that approach also runs into backward compatibility problems "
"because any existing code could be using a given logger name and using %-"
"formatting."
msgstr ""
"Були пропозиції пов’язати стилі формату з певними реєстраторами, але такий "
"підхід також стикається з проблемами зворотної сумісності, оскільки будь-"
"який існуючий код може використовувати дане ім’я реєстратора та "
"використовувати %-formatting."

#: ../../howto/logging-cookbook.rst:2667
msgid ""
"For logging to work interoperably between any third-party libraries and your "
"code, decisions about formatting need to be made at the level of the "
"individual logging call. This opens up a couple of ways in which alternative "
"formatting styles can be accommodated."
msgstr ""
"Щоб журналювання працювало сумісно між будь-якими сторонніми бібліотеками та "
"вашим кодом, рішення щодо форматування потрібно приймати на рівні окремого "
"виклику журналювання. Це відкриває кілька способів використання "
"альтернативних стилів форматування."

#: ../../howto/logging-cookbook.rst:2674
msgid "Using LogRecord factories"
msgstr "Використання фабрик LogRecord"

#: ../../howto/logging-cookbook.rst:2676
msgid ""
"In Python 3.2, along with the :class:`~logging.Formatter` changes mentioned "
"above, the logging package gained the ability to allow users to set their "
"own :class:`LogRecord` subclasses, using the :func:`setLogRecordFactory` "
"function. You can use this to set your own subclass of :class:`LogRecord`, "
"which does the Right Thing by overriding the :meth:`~LogRecord.getMessage` "
"method. The base class implementation of this method is where the ``msg % "
"args`` formatting happens, and where you can substitute your alternate "
"formatting; however, you should be careful to support all formatting styles "
"and allow %-formatting as the default, to ensure interoperability with other "
"code. Care should also be taken to call ``str(self.msg)``, just as the base "
"implementation does."
msgstr ""
"У Python 3.2 разом зі змінами :class:`~logging.Formatter`, згаданими вище, "
"пакет журналювання отримав можливість дозволяти користувачам встановлювати "
"власні підкласи :class:`LogRecord` за допомогою функції :func:"
"`setLogRecordFactory` . Ви можете використовувати це, щоб установити власний "
"підклас :class:`LogRecord`, який робить правильні речі, замінюючи метод :"
"meth:`~LogRecord.getMessage`. Реалізація базового класу цього методу є "
"місцем, де відбувається форматування ``msg % args``, і де ви можете замінити "
"своє альтернативне форматування; однак ви повинні бути обережними, щоб "
"підтримувати всі стилі форматування та дозволити %-formatting як типовий, "
"щоб забезпечити взаємодію з іншим кодом. Слід також подбати про те, щоб "
"викликати ``str(self.msg)``, як це робить базова реалізація."

#: ../../howto/logging-cookbook.rst:2687
msgid ""
"Refer to the reference documentation on :func:`setLogRecordFactory` and :"
"class:`LogRecord` for more information."
msgstr ""
"Зверніться до довідкової документації щодо :func:`setLogRecordFactory` і :"
"class:`LogRecord` для отримання додаткової інформації."

#: ../../howto/logging-cookbook.rst:2692
msgid "Using custom message objects"
msgstr "Використання настроюваних об’єктів повідомлення"

#: ../../howto/logging-cookbook.rst:2694
msgid ""
"There is another, perhaps simpler way that you can use {}- and $- formatting "
"to construct your individual log messages. You may recall (from :ref:"
"`arbitrary-object-messages`) that when logging you can use an arbitrary "
"object as a message format string, and that the logging package will call :"
"func:`str` on that object to get the actual format string. Consider the "
"following two classes::"
msgstr ""
"Існує інший, можливо, простіший спосіб використання форматування {}- і $- "
"для створення індивідуальних повідомлень журналу. Ви можете пам’ятати (з :"
"ref:`arbitrary-object-messages`), що під час журналювання ви можете "
"використовувати довільний об’єкт як рядок формату повідомлення, і що пакет "
"журналювання викличе :func:`str` для цього об’єкта, щоб отримати рядок "
"фактичного формату. Розглянемо наступні два класи:"

#: ../../howto/logging-cookbook.rst:2719
msgid ""
"Either of these can be used in place of a format string, to allow {}- or $-"
"formatting to be used to build the actual \"message\" part which appears in "
"the formatted log output in place of “%(message)s” or “{message}” or "
"“$message”. If you find it a little unwieldy to use the class names whenever "
"you want to log something, you can make it more palatable if you use an "
"alias such as ``M`` or ``_`` for the message (or perhaps ``__``, if you are "
"using ``_`` for localization)."
msgstr ""
"Будь-яке з них можна використовувати замість рядка формату, щоб дозволити "
"використовувати {}- або $-форматування для створення фактичної частини "
"\"повідомлення\", яка з’являється у відформатованому журналі замість "
"\"%(message)s\" або \"{message\". }\" або \"$message\". Якщо вам здається "
"трохи громіздким використовувати імена класів, коли ви хочете щось "
"зареєструвати, ви можете зробити це більш приємним, якщо використаєте "
"псевдонім, наприклад ``M`` або ``_`` для повідомлення (або, можливо ``__``, "
"якщо ви використовуєте ``_`` для локалізації)."

#: ../../howto/logging-cookbook.rst:2727
msgid ""
"Examples of this approach are given below. Firstly, formatting with :meth:"
"`str.format`::"
msgstr ""
"Приклади цього підходу наведені нижче. По-перше, форматування за допомогою :"
"meth:`str.format`::"

#: ../../howto/logging-cookbook.rst:2741
msgid "Secondly, formatting with :class:`string.Template`::"
msgstr "По-друге, форматування за допомогою :class:`string.Template`::"

#: ../../howto/logging-cookbook.rst:2748
msgid ""
"One thing to note is that you pay no significant performance penalty with "
"this approach: the actual formatting happens not when you make the logging "
"call, but when (and if) the logged message is actually about to be output to "
"a log by a handler. So the only slightly unusual thing which might trip you "
"up is that the parentheses go around the format string and the arguments, "
"not just the format string. That’s because the __ notation is just syntax "
"sugar for a constructor call to one of the :samp:`{XXX}Message` classes "
"shown above."
msgstr ""
"Следует отметить одну вещь: при таком подходе вы не платите значительного "
"снижения производительности: фактическое форматирование происходит не тогда, "
"когда вы делаете вызов журнала, а когда (и если) зарегистрированное "
"сообщение действительно собирается быть выведено в журнал обработчиком. "
"Итак, единственная немного необычная вещь, которая может вас сбить с толку, "
"это то, что круглые скобки заключают в себя строку формата и аргументы, а не "
"только строку формата. Это потому, что нотация __ — это всего лишь "
"синтаксический сахар для вызова конструктора одного из классов :samp:`{XXX}"
"Message`, показанных выше."

#: ../../howto/logging-cookbook.rst:2762
msgid "Configuring filters with :func:`dictConfig`"
msgstr "Налаштування фільтрів за допомогою :func:`dictConfig`"

#: ../../howto/logging-cookbook.rst:2764
msgid ""
"You *can* configure filters using :func:`~logging.config.dictConfig`, though "
"it might not be obvious at first glance how to do it (hence this recipe). "
"Since :class:`~logging.Filter` is the only filter class included in the "
"standard library, and it is unlikely to cater to many requirements (it's "
"only there as a base class), you will typically need to define your own :"
"class:`~logging.Filter` subclass with an overridden :meth:`~logging.Filter."
"filter` method. To do this, specify the ``()`` key in the configuration "
"dictionary for the filter, specifying a callable which will be used to "
"create the filter (a class is the most obvious, but you can provide any "
"callable which returns a :class:`~logging.Filter` instance). Here is a "
"complete example::"
msgstr ""
"Ви *можете* налаштувати фільтри за допомогою :func:`~logging.config."
"dictConfig`, хоча на перший погляд може бути неочевидно, як це зробити (тому "
"цей рецепт). Оскільки :class:`~logging.Filter` є єдиним класом фільтра, "
"включеним у стандартну бібліотеку, і він навряд чи задовольнить багато вимог "
"(він існує лише як базовий клас), вам зазвичай потрібно буде визначити свій "
"власний Підклас :class:`~logging.Filter` із перевизначеним методом :meth:"
"`~logging.Filter.filter`. Для цього вкажіть ключ ``()`` у словнику "
"конфігурації для фільтра, вказавши виклик, який буде використовуватися для "
"створення фільтра (клас є найбільш очевидним, але ви можете надати будь-який "
"виклик, який повертає :class:`~logging.Filter` екземпляр). Ось повний "
"приклад::"

#: ../../howto/logging-cookbook.rst:2817
msgid ""
"This example shows how you can pass configuration data to the callable which "
"constructs the instance, in the form of keyword parameters. When run, the "
"above script will print:"
msgstr ""
"У цьому прикладі показано, як ви можете передати дані конфігурації "
"викликаному, який створює екземпляр, у формі параметрів ключових слів. Під "
"час запуску наведений вище сценарій надрукує:"

#: ../../howto/logging-cookbook.rst:2825
msgid "which shows that the filter is working as configured."
msgstr "який показує, що фільтр працює, як налаштовано."

#: ../../howto/logging-cookbook.rst:2827
msgid "A couple of extra points to note:"
msgstr "Кілька додаткових моментів, на які варто звернути увагу:"

#: ../../howto/logging-cookbook.rst:2829
msgid ""
"If you can't refer to the callable directly in the configuration (e.g. if it "
"lives in a different module, and you can't import it directly where the "
"configuration dictionary is), you can use the form ``ext://...`` as "
"described in :ref:`logging-config-dict-externalobj`. For example, you could "
"have used the text ``'ext://__main__.MyFilter'`` instead of ``MyFilter`` in "
"the above example."
msgstr ""
"Якщо ви не можете звернутися до викликаного безпосередньо в конфігурації "
"(наприклад, якщо він живе в іншому модулі, і ви не можете імпортувати його "
"безпосередньо туди, де знаходиться словник конфігурації), ви можете "
"використовувати форму ``ext://. ..``, як описано в :ref:`logging-config-dict-"
"externalobj`. Наприклад, у наведеному вище прикладі ви могли використати "
"текст ``'ext://__main__.MyFilter`` замість ``MyFilter``."

#: ../../howto/logging-cookbook.rst:2836
msgid ""
"As well as for filters, this technique can also be used to configure custom "
"handlers and formatters. See :ref:`logging-config-dict-userdef` for more "
"information on how logging supports using user-defined objects in its "
"configuration, and see the other cookbook recipe :ref:`custom-handlers` "
"above."
msgstr ""
"Як і для фільтрів, цю техніку також можна використовувати для налаштування "
"нестандартних обробників і форматувальників. Перегляньте :ref:`logging-"
"config-dict-userdef`, щоб дізнатися більше про те, як ведення журналу "
"підтримує використання визначених користувачем об’єктів у своїй "
"конфігурації, і перегляньте інший рецепт кулінарної книги :ref:`custom-"
"handlers` вище."

#: ../../howto/logging-cookbook.rst:2845
msgid "Customized exception formatting"
msgstr "Індивідуальне форматування винятків"

#: ../../howto/logging-cookbook.rst:2847
msgid ""
"There might be times when you want to do customized exception formatting - "
"for argument's sake, let's say you want exactly one line per logged event, "
"even when exception information is present. You can do this with a custom "
"formatter class, as shown in the following example::"
msgstr ""
"Можуть бути випадки, коли ви захочете зробити налаштоване форматування "
"винятків - заради аргументу, припустімо, що вам потрібен рівно один рядок на "
"зареєстровану подію, навіть якщо присутня інформація про винятки. Ви можете "
"зробити це за допомогою спеціального класу форматера, як показано в "
"наступному прикладі:"

#: ../../howto/logging-cookbook.rst:2888
msgid "When run, this produces a file with exactly two lines:"
msgstr "Під час запуску створюється файл із рівно двома рядками:"

#: ../../howto/logging-cookbook.rst:2895
msgid ""
"While the above treatment is simplistic, it points the way to how exception "
"information can be formatted to your liking. The :mod:`traceback` module may "
"be helpful for more specialized needs."
msgstr ""
"Хоча описане вище лікування є спрощеним, воно вказує шлях до того, як "
"інформацію про винятки можна відформатувати на свій смак. Модуль :mod:"
"`traceback` може бути корисним для більш спеціалізованих потреб."

#: ../../howto/logging-cookbook.rst:2902
msgid "Speaking logging messages"
msgstr "Озвучення повідомлень журналу"

#: ../../howto/logging-cookbook.rst:2904
msgid ""
"There might be situations when it is desirable to have logging messages "
"rendered in an audible rather than a visible format. This is easy to do if "
"you have text-to-speech (TTS) functionality available in your system, even "
"if it doesn't have a Python binding. Most TTS systems have a command line "
"program you can run, and this can be invoked from a handler using :mod:"
"`subprocess`. It's assumed here that TTS command line programs won't expect "
"to interact with users or take a long time to complete, and that the "
"frequency of logged messages will be not so high as to swamp the user with "
"messages, and that it's acceptable to have the messages spoken one at a time "
"rather than concurrently, The example implementation below waits for one "
"message to be spoken before the next is processed, and this might cause "
"other handlers to be kept waiting. Here is a short example showing the "
"approach, which assumes that the ``espeak`` TTS package is available::"
msgstr ""
"Можуть бути ситуації, коли бажано, щоб повідомлення журналу відтворювалися в "
"звуковому, а не у видимому форматі. Це легко зробити, якщо у вашій системі "
"доступна функція перетворення тексту в мову (TTS), навіть якщо вона не має "
"прив’язки Python. Більшість систем TTS мають програму командного рядка, яку "
"можна запустити, і її можна викликати з обробника за допомогою :mod:"
"`subprocess`. Тут передбачається, що програми командного рядка TTS не будуть "
"взаємодіяти з користувачами або займати багато часу для виконання, і що "
"частота зареєстрованих повідомлень не буде настільки високою, щоб завалювати "
"користувача повідомленнями, і що прийнятно мати повідомлення промовляються "
"по одному, а не одночасно. Приклад реалізації нижче очікує, поки одне "
"повідомлення буде озвучено перед обробкою наступного, і це може спричинити "
"очікування інших обробників. Ось короткий приклад, який демонструє підхід, "
"який передбачає наявність пакета TTS ``espeak``::"

#: ../../howto/logging-cookbook.rst:2946
msgid ""
"When run, this script should say \"Hello\" and then \"Goodbye\" in a female "
"voice."
msgstr ""
"Під час запуску цей скрипт має сказати \"Привіт\", а потім \"До побачення\" "
"жіночим голосом."

#: ../../howto/logging-cookbook.rst:2948
msgid ""
"The above approach can, of course, be adapted to other TTS systems and even "
"other systems altogether which can process messages via external programs "
"run from a command line."
msgstr ""
"Наведений вище підхід, звичайно, можна адаптувати до інших систем TTS і "
"навіть до інших систем взагалі, які можуть обробляти повідомлення через "
"зовнішні програми, що запускаються з командного рядка."

#: ../../howto/logging-cookbook.rst:2956
msgid "Buffering logging messages and outputting them conditionally"
msgstr "Буферизація повідомлень журналу та їх умовне виведення"

#: ../../howto/logging-cookbook.rst:2958
msgid ""
"There might be situations where you want to log messages in a temporary area "
"and only output them if a certain condition occurs. For example, you may "
"want to start logging debug events in a function, and if the function "
"completes without errors, you don't want to clutter the log with the "
"collected debug information, but if there is an error, you want all the "
"debug information to be output as well as the error."
msgstr ""
"Можуть виникнути ситуації, коли потрібно реєструвати повідомлення у "
"тимчасовій області та виводити їх лише у разі виникнення певної умови. "
"Наприклад, ви можете почати реєструвати події налагодження у функції, і якщо "
"функція завершиться без помилок, ви не хочете захаращувати журнал зібраною "
"інформацією про налагодження, але якщо є помилка, ви хочете, щоб усі "
"налагодження інформацію, яку потрібно вивести, а також помилку."

#: ../../howto/logging-cookbook.rst:2965
msgid ""
"Here is an example which shows how you could do this using a decorator for "
"your functions where you want logging to behave this way. It makes use of "
"the :class:`logging.handlers.MemoryHandler`, which allows buffering of "
"logged events until some condition occurs, at which point the buffered "
"events are ``flushed`` - passed to another handler (the ``target`` handler) "
"for processing. By default, the ``MemoryHandler`` flushed when its buffer "
"gets filled up or an event whose level is greater than or equal to a "
"specified threshold is seen. You can use this recipe with a more specialised "
"subclass of ``MemoryHandler`` if you want custom flushing behavior."
msgstr ""
"Ось приклад, який показує, як ви можете зробити це за допомогою декоратора "
"для ваших функцій, де ви хочете, щоб журналювання поводилося таким чином. "
"Він використовує :class:`logging.handlers.MemoryHandler`, який дозволяє "
"буферизувати зареєстровані події, доки не відбудеться певна умова, після "
"чого буферизовані події ``скидаються`` і передаються іншому обробнику "
"(``ціль`` обробник) для обробки. За замовчуванням ``MemoryHandler`` "
"очищується, коли його буфер заповнюється або спостерігається подія, рівень "
"якої перевищує або дорівнює вказаному порогу. Ви можете використовувати цей "
"рецепт із більш спеціалізованим підкласом ``MemoryHandler``, якщо вам "
"потрібна спеціальна поведінка очищення."

#: ../../howto/logging-cookbook.rst:2975
msgid ""
"The example script has a simple function, ``foo``, which just cycles through "
"all the logging levels, writing to ``sys.stderr`` to say what level it's "
"about to log at, and then actually logging a message at that level. You can "
"pass a parameter to ``foo`` which, if true, will log at ERROR and CRITICAL "
"levels - otherwise, it only logs at DEBUG, INFO and WARNING levels."
msgstr ""
"Приклад сценарію має просту функцію, ``foo``, яка просто циклічно перебирає "
"всі рівні журналювання, записуючи в ``sys.stderr``, щоб сказати, на якому "
"рівні він збирається зареєструватися, а потім фактично записує повідомлення "
"на цьому рівень. Ви можете передати параметр у ``foo``, який, якщо істина, "
"буде реєструватися на рівнях ПОМИЛКА та КРИТИЧНИЙ - інакше він реєструватиме "
"лише на рівнях НАЛАШТУВАННЯ, ІНФОРМАЦІЇ та ПОПЕРЕДЖЕННЯ."

#: ../../howto/logging-cookbook.rst:2981
msgid ""
"The script just arranges to decorate ``foo`` with a decorator which will do "
"the conditional logging that's required. The decorator takes a logger as a "
"parameter and attaches a memory handler for the duration of the call to the "
"decorated function. The decorator can be additionally parameterised using a "
"target handler, a level at which flushing should occur, and a capacity for "
"the buffer (number of records buffered). These default to a :class:`~logging."
"StreamHandler` which writes to ``sys.stderr``, ``logging.ERROR`` and ``100`` "
"respectively."
msgstr ""
"Сценарій лише організовує декорування ``foo`` за допомогою декоратора, який "
"виконуватиме необхідне умовне журналювання. Декоратор приймає реєстратор як "
"параметр і приєднує обробник пам’яті на час виклику декорованої функції. "
"Декоратор може бути додатково параметризований за допомогою цільового "
"обробника, рівня, на якому має відбуватися очищення, і ємності для буфера "
"(кількість записів, буферизованих). За умовчанням це :class:`~logging."
"StreamHandler`, який записує в ``sys.stderr``, ``logging.ERROR`` і ``100`` "
"відповідно."

#: ../../howto/logging-cookbook.rst:2989
msgid "Here's the script::"
msgstr "Ось сценарій::"

#: ../../howto/logging-cookbook.rst:3052
msgid "When this script is run, the following output should be observed:"
msgstr "Під час виконання цього сценарію має спостерігатися такий результат:"

#: ../../howto/logging-cookbook.rst:3082
msgid ""
"As you can see, actual logging output only occurs when an event is logged "
"whose severity is ERROR or greater, but in that case, any previous events at "
"lower severities are also logged."
msgstr ""
"Як ви можете бачити, фактичний вихід журналу відбувається лише тоді, коли "
"реєструється подія, серйозність якої дорівнює ПОМИЛКІ або вище, але в цьому "
"випадку також реєструються будь-які попередні події з нижчим рівнем "
"серйозності."

#: ../../howto/logging-cookbook.rst:3086
msgid "You can of course use the conventional means of decoration::"
msgstr "Ви, звичайно, можете використовувати звичайні засоби декору:"

#: ../../howto/logging-cookbook.rst:3096
msgid "Sending logging messages to email, with buffering"
msgstr "Отправка сообщений журнала на электронную почту с буферизацией"

#: ../../howto/logging-cookbook.rst:3098
msgid ""
"To illustrate how you can send log messages via email, so that a set number "
"of messages are sent per email, you can subclass :class:`~logging.handlers."
"BufferingHandler`. In the following  example, which you can adapt to suit "
"your specific needs, a simple test harness is provided which allows you to "
"run the script with command line arguments specifying what you typically "
"need to send things via SMTP. (Run the downloaded script with the ``-h`` "
"argument to see the required and optional arguments.)"
msgstr ""
"Чтобы проиллюстрировать, как вы можете отправлять сообщения журнала по "
"электронной почте, чтобы определенное количество сообщений отправлялось по "
"электронной почте, вы можете создать подкласс :class:`~logging.handlers."
"BufferingHandler`. В следующем примере, который вы можете адаптировать в "
"соответствии со своими конкретными потребностями, представлена ​​простая "
"тестовая программа, которая позволяет запускать сценарий с аргументами "
"командной строки, определяющими, что вам обычно нужно для отправки данных "
"через SMTP. (Запустите загруженный скрипт с аргументом ``-h``, чтобы увидеть "
"обязательные и необязательные аргументы.)"

#: ../../howto/logging-cookbook.rst:3170
msgid ""
"If you run this script and your SMTP server is correctly set up, you should "
"find that it sends eleven emails to the addressee you specify. The first ten "
"emails will each have ten log messages, and the eleventh will have two "
"messages. That makes up 102 messages as specified in the script."
msgstr ""
"Если вы запустите этот сценарий и ваш SMTP-сервер настроен правильно, вы "
"обнаружите, что он отправляет одиннадцать электронных писем указанному вами "
"адресату. Первые десять электронных писем будут содержать по десять "
"сообщений журнала, а одиннадцатое — по два сообщения. Это составляет 102 "
"сообщения, как указано в сценарии."

#: ../../howto/logging-cookbook.rst:3178
msgid "Formatting times using UTC (GMT) via configuration"
msgstr "Форматування часу за допомогою UTC (GMT) через налаштування"

#: ../../howto/logging-cookbook.rst:3180
msgid ""
"Sometimes you want to format times using UTC, which can be done using a "
"class such as ``UTCFormatter``, shown below::"
msgstr ""
"Иногда вам нужно отформатировать время с использованием UTC, что можно "
"сделать с помощью такого класса, как UTCFormatter, показанного ниже:"

#: ../../howto/logging-cookbook.rst:3189
msgid ""
"and you can then use the ``UTCFormatter`` in your code instead of :class:"
"`~logging.Formatter`. If you want to do that via configuration, you can use "
"the :func:`~logging.config.dictConfig` API with an approach illustrated by "
"the following complete example::"
msgstr ""
"і тоді ви можете використовувати ``UTCFormatter`` у своєму коді замість :"
"class:`~logging.Formatter`. Якщо ви хочете зробити це за допомогою "
"конфігурації, ви можете використовувати :func:`~logging.config.dictConfig` "
"API з підходом, проілюстрованим таким повним прикладом:"

#: ../../howto/logging-cookbook.rst:3232
msgid "When this script is run, it should print something like:"
msgstr "Коли цей сценарій запускається, він має надрукувати щось на кшталт:"

#: ../../howto/logging-cookbook.rst:3239
msgid ""
"showing how the time is formatted both as local time and UTC, one for each "
"handler."
msgstr ""
"показує, як час форматується як місцевий час, так і UTC, по одному для "
"кожного обробника."

#: ../../howto/logging-cookbook.rst:3246
msgid "Using a context manager for selective logging"
msgstr "Використання контекстного менеджера для вибіркового журналювання"

#: ../../howto/logging-cookbook.rst:3248
msgid ""
"There are times when it would be useful to temporarily change the logging "
"configuration and revert it back after doing something. For this, a context "
"manager is the most obvious way of saving and restoring the logging context. "
"Here is a simple example of such a context manager, which allows you to "
"optionally change the logging level and add a logging handler purely in the "
"scope of the context manager::"
msgstr ""
"Бувають випадки, коли було б корисно тимчасово змінити конфігурацію "
"журналювання та повернути її назад після певних дій. Для цього менеджер "
"контексту є найбільш очевидним способом збереження та відновлення контексту "
"журналювання. Ось простий приклад такого менеджера контексту, який дозволяє "
"вам за бажанням змінити рівень журналювання та додати обробник журналювання "
"виключно в межах контекстного менеджера::"

#: ../../howto/logging-cookbook.rst:3281
msgid ""
"If you specify a level value, the logger's level is set to that value in the "
"scope of the with block covered by the context manager. If you specify a "
"handler, it is added to the logger on entry to the block and removed on exit "
"from the block. You can also ask the manager to close the handler for you on "
"block exit - you could do this if you don't need the handler any more."
msgstr ""
"Якщо ви вказуєте значення рівня, рівень реєстратора встановлюється на це "
"значення в області блоку with, охопленого менеджером контексту. Якщо ви "
"вкажете обробник, він додається до реєстратора під час входу до блоку та "
"видаляється під час виходу з блоку. Ви також можете попросити менеджера "
"закрити обробник для вас після виходу з блоку - ви можете зробити це, якщо "
"вам більше не потрібен обробник."

#: ../../howto/logging-cookbook.rst:3287
msgid ""
"To illustrate how it works, we can add the following block of code to the "
"above::"
msgstr ""
"Щоб проілюструвати, як це працює, ми можемо додати наступний блок коду до "
"наведеного вище:"

#: ../../howto/logging-cookbook.rst:3305
msgid ""
"We initially set the logger's level to ``INFO``, so message #1 appears and "
"message #2 doesn't. We then change the level to ``DEBUG`` temporarily in the "
"following ``with`` block, and so message #3 appears. After the block exits, "
"the logger's level is restored to ``INFO`` and so message #4 doesn't appear. "
"In the next ``with`` block, we set the level to ``DEBUG`` again but also add "
"a handler writing to ``sys.stdout``. Thus, message #5 appears twice on the "
"console (once via ``stderr`` and once via ``stdout``). After the ``with`` "
"statement's completion, the status is as it was before so message #6 appears "
"(like message #1) whereas message #7 doesn't (just like message #2)."
msgstr ""
"Спочатку ми встановили рівень реєстратора на ``INFO``, тому повідомлення №1 "
"з’являється, а повідомлення №2 ні. Потім ми тимчасово змінюємо рівень на "
"``DEBUG`` у наступному блоці ``with``, і тому з'являється повідомлення №3. "
"Після виходу з блоку рівень реєстратора відновлюється до ``INFO``, тому "
"повідомлення №4 не з’являється. У наступному блоці ``with`` ми знову "
"встановлюємо рівень ``DEBUG``, але також додаємо запис обробника в ``sys."
"stdout``. Таким чином, повідомлення №5 з’являється двічі на консолі (один "
"раз через ``stderr`` і один раз через ``stdout``). Після завершення "
"оператора ``with`` статус залишається таким же, як і раніше, тому "
"повідомлення №6 з’являється (як повідомлення №1), тоді як повідомлення №7 ні "
"(так само, як повідомлення №2)."

#: ../../howto/logging-cookbook.rst:3315
msgid "If we run the resulting script, the result is as follows:"
msgstr "Якщо ми запустимо отриманий сценарій, результат буде таким:"

#: ../../howto/logging-cookbook.rst:3326
msgid ""
"If we run it again, but pipe ``stderr`` to ``/dev/null``, we see the "
"following, which is the only message written to ``stdout``:"
msgstr ""
"Якщо ми запустимо його знову, але передаємо ``stderr`` до ``/dev/null``, ми "
"побачимо наступне, яке є єдиним повідомленням, яке записується в ``stdout``:"

#: ../../howto/logging-cookbook.rst:3334
msgid "Once again, but piping ``stdout`` to ``/dev/null``, we get:"
msgstr "Ще раз, але передаючи ``stdout`` до ``/dev/null``, ми отримуємо:"

#: ../../howto/logging-cookbook.rst:3344
msgid ""
"In this case, the message #5 printed to ``stdout`` doesn't appear, as "
"expected."
msgstr ""
"У цьому випадку повідомлення №5, надруковане в ``stdout``, не з'являється, "
"як очікувалося."

#: ../../howto/logging-cookbook.rst:3346
msgid ""
"Of course, the approach described here can be generalised, for example to "
"attach logging filters temporarily. Note that the above code works in Python "
"2 as well as Python 3."
msgstr ""
"Звичайно, описаний тут підхід можна узагальнити, наприклад, тимчасово "
"приєднати фільтри журналювання. Зверніть увагу, що наведений вище код працює "
"як у Python 2, так і в Python 3."

#: ../../howto/logging-cookbook.rst:3354
msgid "A CLI application starter template"
msgstr "Початковий шаблон програми CLI"

#: ../../howto/logging-cookbook.rst:3356
msgid "Here's an example which shows how you can:"
msgstr "Ось приклад, який показує, як можна:"

#: ../../howto/logging-cookbook.rst:3358
msgid "Use a logging level based on command-line arguments"
msgstr ""
"Використовуйте рівень журналювання на основі аргументів командного рядка"

#: ../../howto/logging-cookbook.rst:3359
msgid ""
"Dispatch to multiple subcommands in separate files, all logging at the same "
"level in a consistent way"
msgstr ""
"Відправлення до кількох підкоманд в окремих файлах, усі журнали на одному "
"рівні узгоджено"

#: ../../howto/logging-cookbook.rst:3361
msgid "Make use of simple, minimal configuration"
msgstr "Використовуйте просту мінімальну конфігурацію"

#: ../../howto/logging-cookbook.rst:3363
msgid ""
"Suppose we have a command-line application whose job is to stop, start or "
"restart some services. This could be organised for the purposes of "
"illustration as a file ``app.py`` that is the main script for the "
"application, with individual commands implemented in ``start.py``, ``stop."
"py`` and ``restart.py``. Suppose further that we want to control the "
"verbosity of the application via a command-line argument, defaulting to "
"``logging.INFO``. Here's one way that ``app.py`` could be written::"
msgstr ""
"Припустімо, що у нас є програма командного рядка, завданням якої є зупинка, "
"запуск або перезапуск деяких служб. Для ілюстрації це можна організувати як "
"файл ``app.py``, який є основним сценарієм для програми, з окремими "
"командами, реалізованими в ``start.py``, ``stop.py`` і ``restart.py``. "
"Припустимо далі, що ми хочемо контролювати докладність програми за допомогою "
"аргументу командного рядка, за замовчуванням ``logging.INFO``. Ось один із "
"способів написання ``app.py``:"

#: ../../howto/logging-cookbook.rst:3412
msgid ""
"And the ``start``, ``stop`` and ``restart`` commands can be implemented in "
"separate modules, like so for starting::"
msgstr ""
"А команди ``start``, ``stop`` і ``restart`` можна реалізувати в окремих "
"модулях, наприклад, для запуску::"

#: ../../howto/logging-cookbook.rst:3425
msgid "and thus for stopping::"
msgstr "і, таким чином, для зупинки::"

#: ../../howto/logging-cookbook.rst:3446
msgid "and similarly for restarting::"
msgstr "і аналогічно для перезапуску::"

#: ../../howto/logging-cookbook.rst:3467
msgid ""
"If we run this application with the default log level, we get output like "
"this:"
msgstr ""
"Якщо ми запустимо цю програму з рівнем журналу за замовчуванням, ми "
"отримаємо такий результат:"

#: ../../howto/logging-cookbook.rst:3480
msgid ""
"The first word is the logging level, and the second word is the module or "
"package name of the place where the event was logged."
msgstr ""
"Перше слово — це рівень журналювання, а друге — ім’я модуля або пакета "
"місця, де було зареєстровано подію."

#: ../../howto/logging-cookbook.rst:3483
msgid ""
"If we change the logging level, then we can change the information sent to "
"the log. For example, if we want more information:"
msgstr ""
"Якщо ми змінимо рівень журналювання, ми зможемо змінити інформацію, яка "
"надсилається до журналу. Наприклад, якщо нам потрібна додаткова інформація:"

#: ../../howto/logging-cookbook.rst:3500
msgid "And if we want less:"
msgstr "А якщо ми хочемо менше:"

#: ../../howto/logging-cookbook.rst:3508
msgid ""
"In this case, the commands don't print anything to the console, since "
"nothing at ``WARNING`` level or above is logged by them."
msgstr ""
"У цьому випадку команди нічого не друкують на консолі, оскільки вони нічого "
"не реєструють на рівні ``ПОПЕРЕДЖЕННЯ`` або вище."

#: ../../howto/logging-cookbook.rst:3514
msgid "A Qt GUI for logging"
msgstr "Графічний інтерфейс Qt для журналювання"

#: ../../howto/logging-cookbook.rst:3516
msgid ""
"A question that comes up from time to time is about how to log to a GUI "
"application. The `Qt <https://www.qt.io/>`_ framework is a popular cross-"
"platform UI framework with Python bindings using `PySide2 <https://pypi.org/"
"project/PySide2/>`_ or `PyQt5 <https://pypi.org/project/PyQt5/>`_ libraries."
msgstr ""

#: ../../howto/logging-cookbook.rst:3522
msgid ""
"The following example shows how to log to a Qt GUI. This introduces a simple "
"``QtHandler`` class which takes a callable, which should be a slot in the "
"main thread that does GUI updates. A worker thread is also created to show "
"how you can log to the GUI from both the UI itself (via a button for manual "
"logging) as well as a worker thread doing work in the background (here, just "
"logging messages at random levels with random short delays in between)."
msgstr ""
"У наступному прикладі показано, як увійти до Qt GUI. Це представляє простий "
"клас ``QtHandler``, який приймає callable, який має бути слотом у головному "
"потоці, який виконує оновлення GUI. Робочий потік також створюється, щоб "
"показати, як ви можете входити в графічний інтерфейс як з самого інтерфейсу "
"користувача (за допомогою кнопки для ручного журналювання), так і з робочого "
"потоку, який виконує роботу у фоновому режимі (тут просто реєструє "
"повідомлення на випадкових рівнях з довільним короткі затримки між ними)."

#: ../../howto/logging-cookbook.rst:3529
msgid ""
"The worker thread is implemented using Qt's ``QThread`` class rather than "
"the :mod:`threading` module, as there are circumstances where one has to use "
"``QThread``, which offers better integration with other ``Qt`` components."
msgstr ""
"Робочий потік реалізовано за допомогою класу ``QThread`` Qt, а не модуля :"
"mod:`threading`, оскільки є обставини, коли потрібно використовувати "
"``QThread``, який забезпечує кращу інтеграцію з іншим ``Qt`` компоненти."

#: ../../howto/logging-cookbook.rst:3533
msgid ""
"The code should work with recent releases of any of ``PySide6``, ``PyQt6``, "
"``PySide2`` or ``PyQt5``. You should be able to adapt the approach to "
"earlier versions of Qt. Please refer to the comments in the code snippet for "
"more detailed information."
msgstr ""
"Код должен работать с последними выпусками любого из PySide6, PyQt6, PySide2 "
"или PyQt5. Вы сможете адаптировать этот подход к более ранним версиям Qt. "
"Для получения более подробной информации обратитесь к комментариям во "
"фрагменте кода."

#: ../../howto/logging-cookbook.rst:3770
msgid "Logging to syslog with RFC5424 support"
msgstr "Вхід до системного журналу з підтримкою RFC5424"

#: ../../howto/logging-cookbook.rst:3772
msgid ""
"Although :rfc:`5424` dates from 2009, most syslog servers are configured by "
"detault to use the older :rfc:`3164`, which hails from 2001. When "
"``logging`` was added to Python in 2003, it supported the earlier (and only "
"existing) protocol at the time. Since RFC5424 came out, as there has not "
"been widespread deployment of it in syslog servers, the :class:`~logging."
"handlers.SysLogHandler` functionality has not been updated."
msgstr ""

#: ../../howto/logging-cookbook.rst:3779
msgid ""
"RFC 5424 contains some useful features such as support for structured data, "
"and if you need to be able to log to a syslog server with support for it, "
"you can do so with a subclassed handler which looks something like this::"
msgstr ""
"RFC 5424 містить деякі корисні функції, такі як підтримка структурованих "
"даних, і якщо вам потрібно мати можливість увійти на сервер системного "
"журналу з його підтримкою, ви можете зробити це за допомогою обробника "
"підкласів, який виглядає приблизно так:"

#: ../../howto/logging-cookbook.rst:3845
msgid ""
"You'll need to be familiar with RFC 5424 to fully understand the above code, "
"and it may be that you have slightly different needs (e.g. for how you pass "
"structural data to the log). Nevertheless, the above should be adaptable to "
"your speciric needs. With the above handler, you'd pass structured data "
"using something like this::"
msgstr ""
"Вам потрібно буде ознайомитися з RFC 5424, щоб повністю зрозуміти наведений "
"вище код, і можливо, у вас є дещо інші потреби (наприклад, щодо того, як ви "
"передаєте структурні дані в журнал). Тим не менш, наведене вище має "
"адаптуватися до ваших конкретних потреб. За допомогою наведеного вище "
"обробника ви передаєте структуровані дані, використовуючи щось на зразок "
"цього::"

#: ../../howto/logging-cookbook.rst:3859
msgid "How to treat a logger like an output stream"
msgstr "Как относиться к регистратору как к выходному потоку"

#: ../../howto/logging-cookbook.rst:3861
msgid ""
"Sometimes, you need to interface to a third-party API which expects a file-"
"like object to write to, but you want to direct the API's output to a "
"logger. You can do this using a class which wraps a logger with a file-like "
"API. Here's a short script illustrating such a class:"
msgstr ""
"Иногда вам необходимо подключиться к стороннему API, который ожидает записи "
"в файлоподобный объект, но вы хотите направить выходные данные API в "
"регистратор. Вы можете сделать это, используя класс, который обертывает "
"регистратор файловым API. Вот короткий скрипт, иллюстрирующий такой класс:"

#: ../../howto/logging-cookbook.rst:3901
msgid "When this script is run, it prints"
msgstr "Когда этот скрипт запускается, он печатает"

#: ../../howto/logging-cookbook.rst:3908
msgid ""
"You could also use ``LoggerWriter`` to redirect ``sys.stdout`` and ``sys."
"stderr`` by doing something like this:"
msgstr ""
"Вы также можете использовать LoggerWriter для перенаправления sys.stdout и "
"sys.stderr, выполнив что-то вроде этого:"

#: ../../howto/logging-cookbook.rst:3918
msgid ""
"You should do this *after* configuring logging for your needs. In the above "
"example, the :func:`~logging.basicConfig` call does this (using the ``sys."
"stderr`` value *before* it is overwritten by a ``LoggerWriter`` instance). "
"Then, you'd get this kind of result:"
msgstr ""
"Вы должны сделать это *после* настройки ведения журнала для своих нужд. В "
"приведенном выше примере это делает вызов :func:`~logging.basicConfig` "
"(используя значение ``sys.stderr`` *до* того, как оно будет перезаписано "
"экземпляром ``LoggerWriter``). Тогда вы получите такой результат:"

#: ../../howto/logging-cookbook.rst:3931
msgid ""
"Of course, the examples above show output according to the format used by :"
"func:`~logging.basicConfig`, but you can use a different formatter when you "
"configure logging."
msgstr ""
"Конечно, приведенные выше примеры показывают вывод в соответствии с "
"форматом, используемым :func:`~logging.basicConfig`, но при настройке "
"ведения журнала вы можете использовать другой форматтер."

#: ../../howto/logging-cookbook.rst:3935
msgid ""
"Note that with the above scheme, you are somewhat at the mercy of buffering "
"and the sequence of write calls which you are intercepting. For example, "
"with the definition of ``LoggerWriter`` above, if you have the snippet"
msgstr ""
"Обратите внимание, что в приведенной выше схеме вы в некоторой степени "
"зависите от буферизации и последовательности вызовов записи, которые вы "
"перехватываете. Например, с определением ``LoggerWriter`` выше, если у вас "
"есть фрагмент"

#: ../../howto/logging-cookbook.rst:3944
msgid "then running the script results in"
msgstr "затем запуск скрипта приводит к"

#: ../../howto/logging-cookbook.rst:3962
msgid ""
"As you can see, this output isn't ideal. That's because the underlying code "
"which writes to ``sys.stderr`` makes mutiple writes, each of which results "
"in a separate logged line (for example, the last three lines above). To get "
"around this problem, you need to buffer things and only output log lines "
"when newlines are seen. Let's use a slghtly better implementation of "
"``LoggerWriter``:"
msgstr ""

#: ../../howto/logging-cookbook.rst:3987
msgid ""
"This just buffers up stuff until a newline is seen, and then logs complete "
"lines. With this approach, you get better output:"
msgstr ""
"Это просто буферизует данные до тех пор, пока не появится новая строка, а "
"затем записывает полные строки. При таком подходе вы получите лучший "
"результат:"

#: ../../howto/logging-cookbook.rst:4003
msgid "Patterns to avoid"
msgstr "Шаблони, яких слід уникати"

#: ../../howto/logging-cookbook.rst:4005
msgid ""
"Although the preceding sections have described ways of doing things you "
"might need to do or deal with, it is worth mentioning some usage patterns "
"which are *unhelpful*, and which should therefore be avoided in most cases. "
"The following sections are in no particular order."
msgstr ""
"Незважаючи на те, що в попередніх розділах описано способи виконання речей, "
"які вам можуть знадобитися, варто згадати деякі шаблони використання, які є "
"*некорисними* і яких у більшості випадків слід уникати. Наступні розділи не "
"мають певного порядку."

#: ../../howto/logging-cookbook.rst:4011
msgid "Opening the same log file multiple times"
msgstr "Відкриття одного файлу журналу кілька разів"

#: ../../howto/logging-cookbook.rst:4013
msgid ""
"On Windows, you will generally not be able to open the same file multiple "
"times as this will lead to a \"file is in use by another process\" error. "
"However, on POSIX platforms you'll not get any errors if you open the same "
"file multiple times. This could be done accidentally, for example by:"
msgstr ""
"У Windows зазвичай ви не зможете відкрити один і той же файл кілька разів, "
"оскільки це призведе до помилки \"файл використовується іншим процесом\". "
"Однак на платформах POSIX ви не отримаєте жодних помилок, якщо відкриєте той "
"самий файл кілька разів. Це може бути зроблено випадково, наприклад:"

#: ../../howto/logging-cookbook.rst:4018
msgid ""
"Adding a file handler more than once which references the same file (e.g. by "
"a copy/paste/forget-to-change error)."
msgstr ""
"Додавання обробника файлів більше одного разу, який посилається на той самий "
"файл (наприклад, через помилку копіювання/вставлення/забути змінити)."

#: ../../howto/logging-cookbook.rst:4021
msgid ""
"Opening two files that look different, as they have different names, but are "
"the same because one is a symbolic link to the other."
msgstr ""
"Відкриття двох файлів, які виглядають по-різному, оскільки мають різні "
"назви, але однакові, оскільки один є символічним посиланням на інший."

#: ../../howto/logging-cookbook.rst:4024
msgid ""
"Forking a process, following which both parent and child have a reference to "
"the same file. This might be through use of the :mod:`multiprocessing` "
"module, for example."
msgstr ""
"Розгалуження процесу, після якого і батьківський, і дочірній елементи мають "
"посилання на той самий файл. Це може бути, наприклад, через використання "
"модуля :mod:`multiprocessing`."

#: ../../howto/logging-cookbook.rst:4028
msgid ""
"Opening a file multiple times might *appear* to work most of the time, but "
"can lead to a number of problems in practice:"
msgstr ""
"Багаторазове відкриття файлу може *видаватись* більшу частину часу "
"ефективним, але на практиці це може призвести до ряду проблем:"

#: ../../howto/logging-cookbook.rst:4031
msgid ""
"Logging output can be garbled because multiple threads or processes try to "
"write to the same file. Although logging guards against concurrent use of "
"the same handler instance by multiple threads, there is no such protection "
"if concurrent writes are attempted by two different threads using two "
"different handler instances which happen to point to the same file."
msgstr ""
"Вихід журналу може бути спотвореним, оскільки кілька потоків або процесів "
"намагаються записати в той самий файл. Хоча журналювання захищає від "
"одночасного використання одного екземпляра обробника кількома потоками, "
"такого захисту немає, якщо одночасний запис намагаються виконати два різні "
"потоки, використовуючи два різні екземпляри обробника, які випадково "
"вказують на той самий файл."

#: ../../howto/logging-cookbook.rst:4037
msgid ""
"An attempt to delete a file (e.g. during file rotation) silently fails, "
"because there is another reference pointing to it. This can lead to "
"confusion and wasted debugging time - log entries end up in unexpected "
"places, or are lost altogether. Or a file that was supposed to be moved "
"remains in place, and grows in size unexpectedly despite size-based rotation "
"being supposedly in place."
msgstr ""
"Попытка удалить файл (например, во время ротации файла) терпит неудачу, "
"поскольку на него указывает другая ссылка. Это может привести к путанице и "
"потере времени на отладку — записи журнала оказываются в неожиданных местах "
"или вообще теряются. Или файл, который должен был быть перемещен, остается "
"на месте и неожиданно увеличивается в размере, несмотря на предположительное "
"вращение на основе размера."

#: ../../howto/logging-cookbook.rst:4044
msgid ""
"Use the techniques outlined in :ref:`multiple-processes` to circumvent such "
"issues."
msgstr ""
"Використовуйте методи, описані в :ref:`multiple-processes`, щоб уникнути "
"таких проблем."

#: ../../howto/logging-cookbook.rst:4048
msgid "Using loggers as attributes in a class or passing them as parameters"
msgstr ""
"Використання реєстраторів як атрибутів у класі або передача їх як параметрів"

#: ../../howto/logging-cookbook.rst:4050
msgid ""
"While there might be unusual cases where you'll need to do this, in general "
"there is no point because loggers are singletons. Code can always access a "
"given logger instance by name using ``logging.getLogger(name)``, so passing "
"instances around and holding them as instance attributes is pointless. Note "
"that in other languages such as Java and C#, loggers are often static class "
"attributes. However, this pattern doesn't make sense in Python, where the "
"module (and not the class) is the unit of software decomposition."
msgstr ""
"Хоча можуть бути незвичайні випадки, коли вам знадобиться це зробити, "
"загалом це не має сенсу, оскільки реєстратори є одиночними. Код завжди може "
"отримати доступ до певного екземпляра реєстратора за назвою за допомогою "
"``logging.getLogger(name)``, тому передавати екземпляри та зберігати їх як "
"атрибути екземпляра безглуздо. Зверніть увагу, що в інших мовах, таких як "
"Java і C#, реєстратори часто є статичними атрибутами класу. Однак цей шаблон "
"не має сенсу в Python, де модуль (а не клас) є одиницею декомпозиції "
"програмного забезпечення."

#: ../../howto/logging-cookbook.rst:4059
msgid ""
"Adding handlers other than :class:`~logging.NullHandler` to a logger in a "
"library"
msgstr ""
"Добавление обработчиков, отличных от :class:`~logging.NullHandler`, в "
"регистратор в библиотеке."

#: ../../howto/logging-cookbook.rst:4061
msgid ""
"Configuring logging by adding handlers, formatters and filters is the "
"responsibility of the application developer, not the library developer. If "
"you are maintaining a library, ensure that you don't add handlers to any of "
"your loggers other than a :class:`~logging.NullHandler` instance."
msgstr ""
"Налаштування журналювання шляхом додавання обробників, засобів форматування "
"та фільтрів є відповідальністю розробника програми, а не розробника "
"бібліотеки. Якщо ви підтримуєте бібліотеку, переконайтеся, що ви не додаєте "
"обробники до жодного з ваших журналів, крім екземпляра :class:`~logging."
"NullHandler`."

#: ../../howto/logging-cookbook.rst:4067
msgid "Creating a lot of loggers"
msgstr "Створення великої кількості журналів"

#: ../../howto/logging-cookbook.rst:4069
msgid ""
"Loggers are singletons that are never freed during a script execution, and "
"so creating lots of loggers will use up memory which can't then be freed. "
"Rather than create a logger per e.g. file processed or network connection "
"made, use the :ref:`existing mechanisms <context-info>` for passing "
"contextual information into your logs and restrict the loggers created to "
"those describing areas within your application (generally modules, but "
"occasionally slightly more fine-grained than that)."
msgstr ""
"Реєстратори — це одиночні елементи, які ніколи не звільняються під час "
"виконання сценарію, тому створення великої кількості реєстраторів буде "
"використовувати пам’ять, яку потім не можна звільнити. Замість створення "
"реєстратора, наприклад, оброблено файл або встановлено мережеве з’єднання, "
"скористайтеся :ref:`існуючими механізмами <context-info>` для передачі "
"контекстної інформації у ваші журнали та обмежте реєстратори, створені тими, "
"що описують області у вашій програмі (зазвичай модулі, але іноді трохи більш "
"дрібнозернисті, ніж це) ."

#: ../../howto/logging-cookbook.rst:4080
msgid "Other resources"
msgstr "Outros recursos"

#: ../../howto/logging-cookbook.rst:4085
msgid "Module :mod:`logging`"
msgstr "Módulo :mod:`logging`"

#: ../../howto/logging-cookbook.rst:4085
msgid "API reference for the logging module."
msgstr "Referência da API para o módulo de logging."

#: ../../howto/logging-cookbook.rst:4088
msgid "Module :mod:`logging.config`"
msgstr "Módulo :mod:`logging.config`"

#: ../../howto/logging-cookbook.rst:4088
msgid "Configuration API for the logging module."
msgstr "API de configuração para o módulo logging."

#: ../../howto/logging-cookbook.rst:4091
msgid "Module :mod:`logging.handlers`"
msgstr "Módulo :mod:`logging.handlers`"

#: ../../howto/logging-cookbook.rst:4091
msgid "Useful handlers included with the logging module."
msgstr "Tratadores úteis incluídos no módulo logging."

#: ../../howto/logging-cookbook.rst:4093
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Tutorial básico <logging-basic-tutorial>`"

#: ../../howto/logging-cookbook.rst:4095
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Tutorial avançado <logging-advanced-tutorial>`"

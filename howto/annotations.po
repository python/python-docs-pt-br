# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Marco Rougeth <marco@rougeth.com>, 2021
# Flávio Neves, 2022
# Nicolas Evangelista, 2022
# PAULO NASCIMENTO, 2024
# Adorilson Bezerra <adorilson@gmail.com>, 2024
# José Carlos <josecarlosbarbt@gmail.com>, 2024
# elielmartinsbr <elielmartinsbr@gmail.com>, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-08 02:53-0300\n"
"PO-Revision-Date: 2021-06-28 00:52+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../howto/annotations.rst:5
msgid "Annotations Best Practices"
msgstr "Boas práticas para anotações"

#: ../../howto/annotations.rst:0
msgid "author"
msgstr "Autor"

#: ../../howto/annotations.rst:7
msgid "Larry Hastings"
msgstr "Larry Hastings"

#: ../../howto/annotations.rst-1
msgid "Abstract"
msgstr "Resumo"

#: ../../howto/annotations.rst:11
msgid ""
"This document is designed to encapsulate the best practices for working with "
"annotations dicts.  If you write Python code that examines "
"``__annotations__`` on Python objects, we encourage you to follow the "
"guidelines described below."
msgstr ""
"Este documento foi projetado para encapsular as melhores práticas para "
"trabalhar com anotações. Se você escrever um código Python que examina "
"``__annotations__`` nos objetos Python, nós o encorajamos a seguir as "
"diretrizes descritas abaixo."

#: ../../howto/annotations.rst:16
msgid ""
"The document is organized into four sections: best practices for accessing "
"the annotations of an object in Python versions 3.10 and newer, best "
"practices for accessing the annotations of an object in Python versions 3.9 "
"and older, other best practices for ``__annotations__`` that apply to any "
"Python version, and quirks of ``__annotations__``."
msgstr ""
"Este documento está dividido em quatro seções: melhores práticas para "
"acessar as anotações de um objeto no Python  na versão 3.10 e versões mais "
"recente, melhores práticas para acessar as anotações de um objeto no Python "
"na versão 3.9 e versões mais antiga, outras melhores práticas para "
"``__annotations__`` para qualquer versão do Python e peculiaridades do "
"``__annotations__``."

#: ../../howto/annotations.rst:26
msgid ""
"Note that this document is specifically about working with "
"``__annotations__``, not uses *for* annotations. If you're looking for "
"information on how to use \"type hints\" in your code, please see the :mod:"
"`typing` module."
msgstr ""
"Note que este documento é específico sobre trabalhar com "
"``__annotations__``, não para o uso *de* anotações. Se você está procurando "
"por informações sobre como usar \"type hints\" no seu código, por favor veja "
"o módulo :mod:`typing`"

#: ../../howto/annotations.rst:33
msgid "Accessing The Annotations Dict Of An Object In Python 3.10 And Newer"
msgstr ""
"Acessando o dicionário de anotações de um objeto no Python 3.10 e nas "
"versões mais recentes"

#: ../../howto/annotations.rst:35
msgid ""
"Python 3.10 adds a new function to the standard library: :func:`inspect."
"get_annotations`.  In Python versions 3.10 through 3.13, calling this "
"function is the best practice for accessing the annotations dict of any "
"object that supports annotations.  This function can also \"un-stringize\" "
"stringized annotations for you."
msgstr ""

#: ../../howto/annotations.rst:42
msgid ""
"In Python 3.14, there is a new :mod:`annotationlib` module with "
"functionality for working with annotations. This includes a :func:"
"`annotationlib.get_annotations` function, which supersedes :func:`inspect."
"get_annotations`."
msgstr ""

#: ../../howto/annotations.rst:47
msgid ""
"If for some reason :func:`inspect.get_annotations` isn't viable for your use "
"case, you may access the ``__annotations__`` data member manually.  Best "
"practice for this changed in Python 3.10 as well: as of Python 3.10, ``o."
"__annotations__`` is guaranteed to *always* work on Python functions, "
"classes, and modules.  If you're certain the object you're examining is one "
"of these three *specific* objects, you may simply use ``o.__annotations__`` "
"to get at the object's annotations dict."
msgstr ""
"Se por alguma razão :func:`inspect.get_annotations` não for viável para o "
"seu caso de uso, você pode acessar o membro de dados ``__annotations__`` "
"manualmente. As melhores práticas para isto também mudaram no Python 3.10: a "
"partir do Python 3.10, ``o.__annotations__`` é garantido *sempre* funcionar "
"em funções, classes e módulos Python. Se você tem certeza que o objeto que "
"você está examinando é um desses três *exatos* objetos, pode simplesmente "
"usar ``o.__annotations__`` para chegar no dicionário de anotações do objeto."

#: ../../howto/annotations.rst:57
msgid ""
"However, other types of callables--for example, callables created by :func:"
"`functools.partial`--may not have an ``__annotations__`` attribute defined.  "
"When accessing the ``__annotations__`` of a possibly unknown object,  best "
"practice in Python versions 3.10 and newer is to call :func:`getattr` with "
"three arguments, for example ``getattr(o, '__annotations__', None)``."
msgstr ""
"Contudo, outros tipos de chamáveis -- por exemplo, chamáveis criados por :"
"func:`functools.partial` -- podem não ter um atributo ``__annotations__`` "
"definido. Ao acessar o ``__annotations__`` de um objeto possivelmente "
"desconhecido, as melhores práticas nas versões de Python 3.10 e mais novas é "
"chamar :func:`getattr` com três argumentos, por exemplo ``getattr(o, "
"'__annotations__', None)``."

#: ../../howto/annotations.rst:65
msgid ""
"Before Python 3.10, accessing ``__annotations__`` on a class that defines no "
"annotations but that has a parent class with annotations would return the "
"parent's ``__annotations__``. In Python 3.10 and newer, the child class's "
"annotations will be an empty dict instead."
msgstr ""
"Antes de Python 3.10, acessar ``__annotations__`` numa classe que não define "
"anotações mas que possui uma classe base com anotações retorna o "
"``__annotations__`` da classe pai. A partir do Python 3.10, a anotação da "
"classe filha será um dicionário vazio."

#: ../../howto/annotations.rst:73
msgid "Accessing The Annotations Dict Of An Object In Python 3.9 And Older"
msgstr ""
"Acessando o dicionário de anotações de um objeto no Python 3.9 e nas versões "
"mais antigas"

#: ../../howto/annotations.rst:75
msgid ""
"In Python 3.9 and older, accessing the annotations dict of an object is much "
"more complicated than in newer versions. The problem is a design flaw in "
"these older versions of Python, specifically to do with class annotations."
msgstr ""
"Em Python 3.9 e versões mais antigas, acessar o dicionário de anotações de "
"um objeto é muito mais complicado que em versões mais novas. O problema é "
"uma falha de design em versões mais antigas do Python, especificamente a "
"respeito de anotações de classe."

#: ../../howto/annotations.rst:80
msgid ""
"Best practice for accessing the annotations dict of other objects--"
"functions, other callables, and modules--is the same as best practice for "
"3.10, assuming you aren't calling :func:`inspect.get_annotations`: you "
"should use three-argument :func:`getattr` to access the object's "
"``__annotations__`` attribute."
msgstr ""
"As melhores práticas para acessar os dicionários de anotações de outros "
"objetos, funções, outros chamáveis e módulos - são as mesmas melhores "
"práticas para 3.10, supondo que você não esteja chamando :func:`inspect."
"get_annotations`: você deve usar a função :func:`getattr` com três "
"argumentos para acessar os atributos do objeto ``__annotations__``."

#: ../../howto/annotations.rst:87
msgid ""
"Unfortunately, this isn't best practice for classes.  The problem is that, "
"since ``__annotations__`` is optional on classes, and because classes can "
"inherit attributes from their base classes, accessing the "
"``__annotations__`` attribute of a class may inadvertently return the "
"annotations dict of a *base class.* As an example::"
msgstr ""
"Infelizmente, essas não são as melhores práticas para classes. O problema é "
"que, como ``__annotations__`` é opcional nas classes, e posto que classes "
"podem herdar atributos das suas classes base, acessar o atributo "
"``__annotations__`` de uma classe pode inesperadamente retornar o dicionário "
"de anotações de uma *classe base.*  Por exemplo::"

#: ../../howto/annotations.rst:94
msgid ""
"class Base:\n"
"    a: int = 3\n"
"    b: str = 'abc'\n"
"\n"
"class Derived(Base):\n"
"    pass\n"
"\n"
"print(Derived.__annotations__)"
msgstr ""
"class Base:\n"
"    a: int = 3\n"
"    b: str = 'abc'\n"
"\n"
"class Derived(Base):\n"
"    pass\n"
"\n"
"print(Derived.__annotations__)"

#: ../../howto/annotations.rst:103
msgid "This will print the annotations dict from ``Base``, not ``Derived``."
msgstr ""
"Isso mostrará o dicionário de anotações de ``Base``, não de ``Derived``."

#: ../../howto/annotations.rst:106
msgid ""
"Your code will have to have a separate code path if the object you're "
"examining is a class (``isinstance(o, type)``). In that case, best practice "
"relies on an implementation detail of Python 3.9 and before: if a class has "
"annotations defined, they are stored in the class's :attr:`~type.__dict__` "
"dictionary.  Since the class may or may not have annotations defined, best "
"practice is to call the :meth:`~dict.get` method on the class dict."
msgstr ""
"Seu código terá que ter um caminho de código separado se o objeto que você "
"está examinando for uma classe (``isinstance(o, type)``). Nesse caso, a "
"melhor prática depende de um detalhe de implementação do Python 3.9 e "
"anteriores: se uma classe tiver anotações definidas, elas serão armazenadas "
"no dicionário :attr:`~type.__dict__` da classe. Como a classe pode ou não "
"ter anotações definidas, a melhor prática é chamar o método :meth:`~dict."
"get` no dict da classe."

#: ../../howto/annotations.rst:114
msgid ""
"To put it all together, here is some sample code that safely accesses the "
"``__annotations__`` attribute on an arbitrary object in Python 3.9 and "
"before::"
msgstr ""
"Considerando tudo isso, aqui está um exemplo de código que acessa de forma "
"segura o atributo ``__annotations__`` em um objeto arbitrário em Python 3.9 "
"e anteriores::"

#: ../../howto/annotations.rst:118
msgid ""
"if isinstance(o, type):\n"
"    ann = o.__dict__.get('__annotations__', None)\n"
"else:\n"
"    ann = getattr(o, '__annotations__', None)"
msgstr ""
"if isinstance(o, type):\n"
"    ann = o.__dict__.get('__annotations__', None)\n"
"else:\n"
"    ann = getattr(o, '__annotations__', None)"

#: ../../howto/annotations.rst:123
msgid ""
"After running this code, ``ann`` should be either a dictionary or ``None``.  "
"You're encouraged to double-check the type of ``ann`` using :func:"
"`isinstance` before further examination."
msgstr ""
"Após executar este código, ``ann`` deve ser um dicionário ou ``None``. Você "
"é encorajado a fazer uma checagem dupla do tipo de ``ann`` utilizando :func:"
"`isinstance` antes de uma análise mais aprofundada."

#: ../../howto/annotations.rst:128
msgid ""
"Note that some exotic or malformed type objects may not have a :attr:`~type."
"__dict__` attribute, so for extra safety you may also wish to use :func:"
"`getattr` to access :attr:`!__dict__`."
msgstr ""
"Observe que alguns objetos de tipos exóticos ou malformados podem não ter "
"atributo um :attr:`~type.__dict__`, portanto, para maior segurança, talvez "
"você também queira usar :func:`getattr` para acessar :attr:`!__dict__`."

#: ../../howto/annotations.rst:134
msgid "Manually Un-Stringizing Stringized Annotations"
msgstr "Recuperando manualmente anotações transformadas em strings"

#: ../../howto/annotations.rst:136
msgid ""
"In situations where some annotations may be \"stringized\", and you wish to "
"evaluate those strings to produce the Python values they represent, it "
"really is best to call :func:`inspect.get_annotations` to do this work for "
"you."
msgstr ""
"Em situações em que as anotações podem ter sido transformadas em strings, e "
"caso queira avaliar essas strings para produzir os valores de Python que "
"elas representam, é melhor chamar :func:`inspect.get_annotations` para fazer "
"isto por você."

#: ../../howto/annotations.rst:142
msgid ""
"If you're using Python 3.9 or older, or if for some reason you can't use :"
"func:`inspect.get_annotations`, you'll need to duplicate its logic.  You're "
"encouraged to examine the implementation of :func:`inspect.get_annotations` "
"in the current Python version and follow a similar approach."
msgstr ""
"Se estiver usando Python 3.9 ou anterior, ou por algum motivo não puder "
"usar :func:`inspect.get_annotations`, será necessário replicar sua lógica. "
"Considere examinar a implementação de :func:`inspect.get_annotations` na "
"versão de Python atual e seguir uma abordagem similar."

#: ../../howto/annotations.rst:148
msgid ""
"In a nutshell, if you wish to evaluate a stringized annotation on an "
"arbitrary object ``o``:"
msgstr ""
"Resumindo, caso deseje avaliar uma anotação transformada em string em um "
"objeto arbitrário ``o``:"

#: ../../howto/annotations.rst:151
msgid ""
"If ``o`` is a module, use ``o.__dict__`` as the ``globals`` when calling :"
"func:`eval`."
msgstr ""
"Se ``o`` for um módulo, use ``o.__dict__`` como ``globals`` ao chamar :func:"
"`eval`."

#: ../../howto/annotations.rst:153
msgid ""
"If ``o`` is a class, use ``sys.modules[o.__module__].__dict__`` as the "
"``globals``, and ``dict(vars(o))`` as the ``locals``, when calling :func:"
"`eval`."
msgstr ""
"Se ``o`` for uma classe, use ``sys.modules[o.__module__].__dict__`` como "
"``globals``, e ``dict(vars(o))`` como ``locals``, quando chamar :func:`eval`."

#: ../../howto/annotations.rst:156
msgid ""
"If ``o`` is a wrapped callable using :func:`functools.update_wrapper`, :func:"
"`functools.wraps`, or :func:`functools.partial`, iteratively unwrap it by "
"accessing either ``o.__wrapped__`` or ``o.func`` as appropriate, until you "
"have found the root unwrapped function."
msgstr ""
"Se ``o`` for um chamável envolto em um invólucro usando :func:`functools."
"update_wrapper`, :func:`functools.wraps` ou :func:`functools.partial`, "
"desenvolva-o iterativamente acessando ``o.__wrapped__`` ou ``o.func`` "
"conforme apropriado, até encontrar a função raiz."

#: ../../howto/annotations.rst:160
msgid ""
"If ``o`` is a callable (but not a class), use :attr:`o.__globals__ <function."
"__globals__>` as the globals when calling :func:`eval`."
msgstr ""
"Caso ``o`` seja chamável (mas não uma classe), use :attr:`o.__globals__ "
"<function.__globals__>` como globals quando chamar :func:`eval`."

#: ../../howto/annotations.rst:164
msgid ""
"However, not all string values used as annotations can be successfully "
"turned into Python values by :func:`eval`. String values could theoretically "
"contain any valid string, and in practice there are valid use cases for type "
"hints that require annotating with string values that specifically *can't* "
"be evaluated.  For example:"
msgstr ""
"Contudo, nem todas strings usadas como anotações podem ser convertidas em "
"valores de Python utilizando :func:`eval`. Valores de string poderiam "
"teoricamente conter qualquer string válida, e na prática existem casos "
"válidos para dicas de tipo que requerem anotar com valores de strings que "
"*não* podem ser executados. Por exemplo:"

#: ../../howto/annotations.rst:171
msgid ""
":pep:`604` union types using ``|``, before support for this was added to "
"Python 3.10."
msgstr ""
"Tipos de união :pep:`604` usando ``|``, antes do suporte a isso ser "
"adicionado em Python 3.10."

#: ../../howto/annotations.rst:173
msgid ""
"Definitions that aren't needed at runtime, only imported when :const:`typing."
"TYPE_CHECKING` is true."
msgstr ""
"Definições que não são necessárias no ambiente de execução, apenas "
"importadas quando :const:`typing.TYPE_CHECKING` é verdadeiro."

#: ../../howto/annotations.rst:176
msgid ""
"If :func:`eval` attempts to evaluate such values, it will fail and raise an "
"exception.  So, when designing a library API that works with annotations, "
"it's recommended to only attempt to evaluate string values when explicitly "
"requested to by the caller."
msgstr ""
"Caso :func:`eval` tente executar tais valores, levantará uma exceção. Então, "
"quando projetar uma biblioteca API que trabalha com anotações, é recomendado "
"que tente executar os valores das strings apenas quando for solicitado "
"explicitamente."

#: ../../howto/annotations.rst:184
msgid "Best Practices For ``__annotations__`` In Any Python Version"
msgstr "Melhores práticas para ``__annotations__`` em qualquer versão Python"

#: ../../howto/annotations.rst:186
msgid ""
"You should avoid assigning to the ``__annotations__`` member of objects "
"directly.  Let Python manage setting ``__annotations__``."
msgstr ""
"Evite atribuir diretamente ao membro ``__annotations__`` dos objetos. Deixe "
"que Python gerenciar a configuração de ``__annotations__``."

#: ../../howto/annotations.rst:189
msgid ""
"If you do assign directly to the ``__annotations__`` member of an object, "
"you should always set it to a ``dict`` object."
msgstr ""
"Se você atribuir diretamente ao membro ``__annotations__`` do objeto, sempre "
"o defina como um objeto ``dict``."

#: ../../howto/annotations.rst:192
msgid ""
"You should avoid accessing ``__annotations__`` directly on any object. "
"Instead, use :func:`annotationlib.get_annotations` (Python 3.14+) or :func:"
"`inspect.get_annotations` (Python 3.10+)."
msgstr ""

#: ../../howto/annotations.rst:196
msgid ""
"If you do directly access the ``__annotations__`` member of an object, you "
"should ensure that it's a dictionary before attempting to examine its "
"contents."
msgstr ""

#: ../../howto/annotations.rst:200
msgid "You should avoid modifying ``__annotations__`` dicts."
msgstr "Evite modificar o dicionário ``__annotations__``."

#: ../../howto/annotations.rst:202
msgid ""
"You should avoid deleting the ``__annotations__`` attribute of an object."
msgstr "Evite deletar o atributo ``__annotations__`` de um objeto."

#: ../../howto/annotations.rst:207
msgid "``__annotations__`` Quirks"
msgstr "Peculiaridades de ``__annotations__``"

#: ../../howto/annotations.rst:209
msgid ""
"In all versions of Python 3, function objects lazy-create an annotations "
"dict if no annotations are defined on that object.  You can delete the "
"``__annotations__`` attribute using ``del fn.__annotations__``, but if you "
"then access ``fn.__annotations__`` the object will create a new empty dict "
"that it will store and return as its annotations.  Deleting the annotations "
"on a function before it has lazily created its annotations dict will throw "
"an ``AttributeError``; using ``del fn.__annotations__`` twice in a row is "
"guaranteed to always throw an ``AttributeError``."
msgstr ""
"Em todas as versões de Python 3, objetos de função criam preguiçosamente um "
"dicionário de anotações caso nenhuma anotação seja definida nesse objeto. "
"Você pode deletar o atributo ``__annotations__`` utilizando ``del fn."
"__annotations__``, mas ao acessar ``fn.__annotations__`` o objeto criará um "
"novo dicionário vazio que será armazenado e retornado como suas anotações.\n"
"Apagar as anotações de uma função antes que ela tenha criado preguiçosamente "
"seu dicionário de anotações irá produzir um ``AttributeError``; ao utilizar "
"``del fn.__annotations__`` duas vezes em sequência, é garantido que será "
"produzido um ``AttributeError``."

#: ../../howto/annotations.rst:219
msgid ""
"Everything in the above paragraph also applies to class and module objects "
"in Python 3.10 and newer."
msgstr ""
"O citado no parágrafo acima também se aplica para classes e objetos de "
"módulo em Python 3.10 e posteriores."

#: ../../howto/annotations.rst:222
msgid ""
"In all versions of Python 3, you can set ``__annotations__`` on a function "
"object to ``None``.  However, subsequently accessing the annotations on that "
"object using ``fn.__annotations__`` will lazy-create an empty dictionary as "
"per the first paragraph of this section.  This is *not* true of modules and "
"classes, in any Python version; those objects permit setting "
"``__annotations__`` to any Python value, and will retain whatever value is "
"set."
msgstr ""
"Em todas as versões de Python 3, você pode definir ``__annotations__`` como "
"``None`` em um objeto de função. Contudo, acessar em sequência as anotações "
"nesse objeto utilizando ``fn.__annotations__`` irá criar preguiçosamente um "
"dicionário vazio como descrito no primeiro parágrafo dessa seção. Isso *não* "
"é válido para módulos e classes, em qualquer versão de Python; esses objetos "
"permitem atribuir ``__annotations__`` a qualquer valor de Python, e "
"armazenam qualquer valor atribuído."

#: ../../howto/annotations.rst:230
msgid ""
"If Python stringizes your annotations for you (using ``from __future__ "
"import annotations``), and you specify a string as an annotation, the string "
"will itself be quoted.  In effect the annotation is quoted *twice.*  For "
"example::"
msgstr ""
"Se Python transformar sua anotação em string (utilizando ``from __future__ "
"import annotations``), e você especificar uma string como anotação, essa "
"string será posta entre aspas. Na prática a anotação receberá aspas "
"*duplas*. Por exemplo::"

#: ../../howto/annotations.rst:236
msgid ""
"from __future__ import annotations\n"
"def foo(a: \"str\"): pass\n"
"\n"
"print(foo.__annotations__)"
msgstr ""
"from __future__ import annotations\n"
"def foo(a: \"str\"): pass\n"
"\n"
"print(foo.__annotations__)"

#: ../../howto/annotations.rst:241
msgid ""
"This prints ``{'a': \"'str'\"}``.  This shouldn't really be considered a "
"\"quirk\"; it's mentioned here simply because it might be surprising."
msgstr ""
"Isso exibe ``{'a': \"'str'\"}``. Não considere isso como uma "
"\"peculiaridade\"; foi mencionado aqui simplesmente porque pode ser "
"surpreendente."

#: ../../howto/annotations.rst:244
msgid ""
"If you use a class with a custom metaclass and access ``__annotations__`` on "
"the class, you may observe unexpected behavior; see :pep:`749 <749#pep749-"
"metaclasses>` for some examples. You can avoid these quirks by using :func:"
"`annotationlib.get_annotations` on Python 3.14+ or :func:`inspect."
"get_annotations` on Python 3.10+. On earlier versions of Python, you can "
"avoid these bugs by accessing the annotations from the class's :attr:`~type."
"__dict__` (e.g., ``cls.__dict__.get('__annotations__', None)``)."
msgstr ""

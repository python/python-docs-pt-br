# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Marco Rougeth <marco@rougeth.com>, 2021
# Welington Carlos <wcarlos3@gmail.com>, 2021
# Ruan Aragão <ruanaragao2@gmail.com>, 2021
# Leticia Portella <leportella@gmail.com>, 2021
# i17obot <i17obot@rougeth.com>, 2021
# Denis Vicentainer <denisvicentainer@gmail.com>, 2021
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2021
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
# Adorilson Bezerra <adorilson@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-30 14:22+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Adorilson Bezerra <adorilson@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../howto/regex.rst:5
msgid "Regular Expression HOWTO"
msgstr "Expressões Regulares"

#: ../../howto/regex.rst:0
msgid "Author"
msgstr "Autor"

#: ../../howto/regex.rst:7
msgid "A.M. Kuchling <amk@amk.ca>"
msgstr "A.M. Kuchling <amk@amk.ca>"

#: ../../howto/regex.rst-1
msgid "Abstract"
msgstr "Resumo"

#: ../../howto/regex.rst:18
msgid ""
"This document is an introductory tutorial to using regular expressions in "
"Python with the :mod:`re` module.  It provides a gentler introduction than "
"the corresponding section in the Library Reference."
msgstr ""
"Este documento é um tutorial introdutório sobre expressões regulares em "
"Python com o módulo :mod:`re`. Ele provê uma introdução mais tranquila que a "
"seção correspondente à documentação do módulo."

#: ../../howto/regex.rst:24
msgid "Introduction"
msgstr "Introdução"

#: ../../howto/regex.rst:26
msgid ""
"Regular expressions (called REs, or regexes, or regex patterns) are "
"essentially a tiny, highly specialized programming language embedded inside "
"Python and made available through the :mod:`re` module. Using this little "
"language, you specify the rules for the set of possible strings that you "
"want to match; this set might contain English sentences, or e-mail "
"addresses, or TeX commands, or anything you like.  You can then ask "
"questions such as \"Does this string match the pattern?\", or \"Is there a "
"match for the pattern anywhere in this string?\".  You can also use REs to "
"modify a string or to split it apart in various ways."
msgstr ""
"Expressões regulares (chamadas REs, ou regexes ou padrões regex) são "
"essencialmente uma mini linguagem de programação altamente especializada "
"incluída dentro do Python e disponível através do módulo :mod:`re`. Usando "
"esta pequena linguagem, você especifica as regras para o conjunto de strings "
"possíveis que você quer corresponder; esse conjunto pode conter sentenças em "
"português, endereços de e-mail, comandos TeX ou qualquer coisa que você "
"queira. Você poderá então perguntar coisas como \"Essa string se enquadra "
"dentro do padrão?\" ou \"Existe alguma parte da string que se enquadra nesse "
"padrão?\". Você também pode usar as REs para modificar uma string ou dividi-"
"la de diversas formas."

#: ../../howto/regex.rst:35
msgid ""
"Regular expression patterns are compiled into a series of bytecodes which "
"are then executed by a matching engine written in C.  For advanced use, it "
"may be necessary to pay careful attention to how the engine will execute a "
"given RE, and write the RE in a certain way in order to produce bytecode "
"that runs faster. Optimization isn't covered in this document, because it "
"requires that you have a good understanding of the matching engine's "
"internals."
msgstr ""
"Os padrões das expressões regulares são compilados em uma série de bytecodes "
"que são então executadas por um mecanismo de correspondência escrito em C. "
"Para usos avançados, talvez seja necessário prestar atenção em como o "
"mecanismo irá executar uma dada RE, e escrever a RE de forma que os "
"bytecodes executem de forma mais rápida. Otimização é um tema que não será "
"visto neste documento, porque ele requer que você tenha um bom entendimento "
"dos mecanismos de combinação internos."

#: ../../howto/regex.rst:42
msgid ""
"The regular expression language is relatively small and restricted, so not "
"all possible string processing tasks can be done using regular expressions.  "
"There are also tasks that *can* be done with regular expressions, but the "
"expressions turn out to be very complicated.  In these cases, you may be "
"better off writing Python code to do the processing; while Python code will "
"be slower than an elaborate regular expression, it will also probably be "
"more understandable."
msgstr ""
"A linguagem de expressão regular é relativamente pequena e restrita, por "
"isso nem todas as tarefas de processamento de strings possíveis podem ser "
"feitas usando expressões regulares. Existem também tarefas que podem ser "
"feitas com expressões regulares, mas as expressões acabam por se tornarem "
"muito complicadas. Nestes casos, pode ser melhor para você escrever um "
"código Python para fazer o processamento; embora um código Python seja mais "
"lento do que uma expressão regular elaborada, ele provavelmente será mais "
"compreensível."

#: ../../howto/regex.rst:51
msgid "Simple Patterns"
msgstr "Padrões simples"

#: ../../howto/regex.rst:53
msgid ""
"We'll start by learning about the simplest possible regular expressions.  "
"Since regular expressions are used to operate on strings, we'll begin with "
"the most common task: matching characters."
msgstr ""
"Vamos começar por aprender sobre as expressões regulares mais simples "
"possíveis.\n"
"Como as expressões regulares são usadas para operar em strings, vamos "
"começar\n"
"com a tarefa mais comum: correspondência de caracteres."

#: ../../howto/regex.rst:57
msgid ""
"For a detailed explanation of the computer science underlying regular "
"expressions (deterministic and non-deterministic finite automata), you can "
"refer to almost any textbook on writing compilers."
msgstr ""
"Para uma explicação detalhada da ciência da computação referente a "
"expressões\n"
"regulares (autômatos finitos determinísticos e não-determinístico), você "
"pode consultar\n"
"a praticamente qualquer livro sobre a escrita de compiladores."

#: ../../howto/regex.rst:63
msgid "Matching Characters"
msgstr "Correspondendo caracteres"

#: ../../howto/regex.rst:65
msgid ""
"Most letters and characters will simply match themselves.  For example, the "
"regular expression ``test`` will match the string ``test`` exactly.  (You "
"can enable a case-insensitive mode that would let this RE match ``Test`` or "
"``TEST`` as well; more about this later.)"
msgstr ""
"A maioria das letras e caracteres simplesmente irão corresponder entre si. "
"Por exemplo, a expressão regular ``teste`` irá combinar totalmente com a "
"string ``teste``. (Você pode habilitar o modo de maiúsculas e minúsculas que "
"faria a RE corresponder com ``Test`` ou ``TEST`` também; veremos mais sobre "
"isso mais adiante.)"

#: ../../howto/regex.rst:70
msgid ""
"There are exceptions to this rule; some characters are special :dfn:"
"`metacharacters`, and don't match themselves.  Instead, they signal that "
"some out-of-the-ordinary thing should be matched, or they affect other "
"portions of the RE by repeating them or changing their meaning.  Much of "
"this document is devoted to discussing various metacharacters and what they "
"do."
msgstr ""
"Há exceções a essa regra, alguns caracteres são metacaracteres especiais, e "
"não se correspondem. Em vez disso, eles sinalizam que alguma coisa fora do "
"normal deve ser correspondida, ou eles afetam outras partes da RE, repetindo-"
"as ou alterando seus significados. Grande parte deste documento é dedicada à "
"discussão de vários metacaracteres e o que eles fazem."

#: ../../howto/regex.rst:76
msgid ""
"Here's a complete list of the metacharacters; their meanings will be "
"discussed in the rest of this HOWTO."
msgstr ""
"Aqui está a lista completa de metacaracteres; seus significados serão "
"discutidos ao longo deste documento."

#: ../../howto/regex.rst:79
msgid ". ^ $ * + ? { } [ ] \\ | ( )"
msgstr ". ^ $ * + ? { } [ ] \\ | ( )"

#: ../../howto/regex.rst:83
msgid ""
"The first metacharacters we'll look at are ``[`` and ``]``. They're used for "
"specifying a character class, which is a set of characters that you wish to "
"match.  Characters can be listed individually, or a range of characters can "
"be indicated by giving two characters and separating them by a ``'-'``.  For "
"example, ``[abc]`` will match any of the characters ``a``, ``b``, or ``c``; "
"this is the same as ``[a-c]``, which uses a range to express the same set of "
"characters.  If you wanted to match only lowercase letters, your RE would be "
"``[a-z]``."
msgstr ""
"O primeiro metacaractere que vamos estudar é o ``[`` e o ``]``. Eles são "
"usados para especificar uma classe de caracteres, que é um conjunto de "
"caracteres que você deseja combinar. Caracteres podem ser listados "
"individualmente ou um intervalo de caracteres pode ser indicado fornecendo "
"dois caracteres e separando-os por um ``'-'``. Por exemplo, ``[abc]`` irá "
"encontrar qualquer caractere ``a``, ``b``, ou ``c``; isso é o mesmo que "
"escrever ``[a-c]``, que usa um intervalo para expressar o mesmo conjunto de "
"caracteres. Se você deseja encontrar apenas letras minúsculas, sua RE seria "
"``[a-z]``."

#: ../../howto/regex.rst:92
msgid ""
"Metacharacters (except ``\\``) are not active inside classes.  For example, "
"``[akm$]`` will match any of the characters ``'a'``, ``'k'``, ``'m'``, or "
"``'$'``; ``'$'`` is usually a metacharacter, but inside a character class "
"it's stripped of its special nature."
msgstr ""
"Metacaracteres (exceto ``\\``) não são ativos dentro de classes. Por "
"exemplo, ``[akm$]`` irá corresponder com qualquer dos caracteres ``'a'``, "
"``'k'``, ``'m'`` ou ``'$'``; ``'$'`` é normalmente um metacaractere, mas "
"dentro de uma classe de caracteres ele perde sua natureza especial."

#: ../../howto/regex.rst:97
msgid ""
"You can match the characters not listed within the class by :dfn:"
"`complementing` the set.  This is indicated by including a ``'^'`` as the "
"first character of the class. For example, ``[^5]`` will match any character "
"except ``'5'``.  If the caret appears elsewhere in a character class, it "
"does not have special meaning. For example: ``[5^]`` will match either a "
"``'5'`` or a ``'^'``."
msgstr ""
"Você pode combinar os caracteres não listados na classe :dfn:"
"`complementando` o conjunto. Isso é indicado pela inclusão de um ``'^'`` "
"como o primeiro caractere da classe. Por exemplo, ``[^5]`` combinará a "
"qualquer caractere, exceto ``'5'``. Se o sinal de intercalação aparecer em "
"outro lugar da classe de caracteres, ele não terá um significado especial. "
"Por exemplo: ``[5^]`` corresponderá a um ``'5'`` ou a ``'^'``."

#: ../../howto/regex.rst:103
msgid ""
"Perhaps the most important metacharacter is the backslash, ``\\``.   As in "
"Python string literals, the backslash can be followed by various characters "
"to signal various special sequences.  It's also used to escape all the "
"metacharacters so you can still match them in patterns; for example, if you "
"need to match a ``[`` or  ``\\``, you can precede them with a backslash to "
"remove their special meaning: ``\\[`` or ``\\\\``."
msgstr ""
"Talvez o metacaractere mais importante seja a contrabarra, ``\\``. Como as "
"strings literais em Python, a barra invertida pode ser seguida por vários "
"caracteres para sinalizar várias sequências especiais. Ela também é usada "
"para *escapar* todos os metacaracteres, e assim, você poder combiná-los em "
"padrões; por exemplo, se você precisa fazer correspondência a um ``[`` ou "
"``\\``, você pode precedê-los com uma barra invertida para remover seu "
"significado especial: ``\\[`` ou ``\\\\``."

#: ../../howto/regex.rst:110
msgid ""
"Some of the special sequences beginning with ``'\\'`` represent predefined "
"sets of characters that are often useful, such as the set of digits, the set "
"of letters, or the set of anything that isn't whitespace."
msgstr ""
"Algumas das sequências especiais que começam com ``'\\'`` representam "
"conjuntos de caracteres predefinidos que são frequentemente úteis, como o "
"conjunto de dígitos, o conjunto de letras ou o conjunto de qualquer coisa "
"que não seja espaço em branco."

#: ../../howto/regex.rst:115
msgid ""
"Let's take an example: ``\\w`` matches any alphanumeric character.  If the "
"regex pattern is expressed in bytes, this is equivalent to the class ``[a-zA-"
"Z0-9_]``.  If the regex pattern is a string, ``\\w`` will match all the "
"characters marked as letters in the Unicode database provided by the :mod:"
"`unicodedata` module.  You can use the more restricted definition of ``\\w`` "
"in a string pattern by supplying the :const:`re.ASCII` flag when compiling "
"the regular expression."
msgstr ""
"Vejamos um exemplo: ``\\w`` corresponde a qualquer caractere alfanumérico. "
"Se o padrão regex for expresso em bytes, isso é equivalente à classe ``[a-zA-"
"Z0-9_]``. Se o padrão regex for uma string, ``\\w`` combinará todos os "
"caracteres marcados como letras no banco de dados Unicode fornecido pelo "
"módulo :mod:`unicodedata`. Você pode usar a definição mais restrita de "
"``\\w`` em um padrão de string, fornecendo o sinalizador :const:`re.ASCII` "
"ao compilar a expressão regular."

#: ../../howto/regex.rst:123
msgid ""
"The following list of special sequences isn't complete. For a complete list "
"of sequences and expanded class definitions for Unicode string patterns, see "
"the last part of :ref:`Regular Expression Syntax <re-syntax>` in the "
"Standard Library reference.  In general, the Unicode versions match any "
"character that's in the appropriate category in the Unicode database."
msgstr ""
"A lista a seguir de sequências especiais não está completa. Para obter uma "
"lista completa das sequências e definições de classe expandidas para padrões "
"de strings Unicode, veja a última parte de :ref:`Sintaxe de Expressão "
"Regular <re-syntax>` na referência da Biblioteca Padrão. Em geral, as "
"versões Unicode correspondem a qualquer caractere que esteja na categoria "
"apropriada do banco de dados Unicode."

#: ../../howto/regex.rst:130
msgid "``\\d``"
msgstr "``\\d``"

#: ../../howto/regex.rst:131
msgid "Matches any decimal digit; this is equivalent to the class ``[0-9]``."
msgstr ""
"corresponde a qualquer ``dígito decimal``, que é equivalente à classe "
"``[0-9]``."

#: ../../howto/regex.rst:133
msgid "``\\D``"
msgstr "``\\D``"

#: ../../howto/regex.rst:134
msgid ""
"Matches any non-digit character; this is equivalent to the class ``[^0-9]``."
msgstr ""
"corresponde a qualquer caractere ``não-dígito``, o que é equivalente à "
"classe ``[^0-9]``."

#: ../../howto/regex.rst:136
msgid "``\\s``"
msgstr "``\\s``"

#: ../../howto/regex.rst:137
msgid ""
"Matches any whitespace character; this is equivalent to the class "
"``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"corresponde a qualquer caractere ``espaço-em-branco``, o que é equivalente à "
"classe ``[\\t\\n\\r\\f\\v]``."

#: ../../howto/regex.rst:140
msgid "``\\S``"
msgstr "``\\S``"

#: ../../howto/regex.rst:141
msgid ""
"Matches any non-whitespace character; this is equivalent to the class ``[^ "
"\\t\\n\\r\\f\\v]``."
msgstr ""
"corresponde a qualquer caractere ``não-espaço-branco``, o que é equivalente "
"à classe ``[^\\t\\n\\r\\f\\v].``"

#: ../../howto/regex.rst:144
msgid "``\\w``"
msgstr "``\\w``"

#: ../../howto/regex.rst:145
msgid ""
"Matches any alphanumeric character; this is equivalent to the class ``[a-zA-"
"Z0-9_]``."
msgstr ""
"corresponde a qualquer caractere ``alfanumérico``, o que é equivalente à "
"classe ``[azA-Z0-9_]``."

#: ../../howto/regex.rst:148
msgid "``\\W``"
msgstr "``\\W``"

#: ../../howto/regex.rst:149
msgid ""
"Matches any non-alphanumeric character; this is equivalent to the class "
"``[^a-zA-Z0-9_]``."
msgstr ""
"corresponde a qualquer caractere ``não-alfanumérico``, o que é equivalente à "
"classe ``[^a-zA-Z0-9_]``."

#: ../../howto/regex.rst:152
msgid ""
"These sequences can be included inside a character class.  For example, "
"``[\\s,.]`` is a character class that will match any whitespace character, "
"or ``','`` or ``'.'``."
msgstr ""
"Estas sequências podem ser incluídas dentro de uma classe de caractere. Por "
"exemplo, ``[\\s,.]`` É uma classe de caractere que irá corresponder a "
"qualquer caractere ``espaço-em-branco``, ou ``,`` ou ``.``."

#: ../../howto/regex.rst:156
msgid ""
"The final metacharacter in this section is ``.``.  It matches anything "
"except a newline character, and there's an alternate mode (:const:`re."
"DOTALL`) where it will match even a newline.  ``.`` is often used where you "
"want to match \"any character\"."
msgstr ""
"O metacaractere final desta seção é o ``.``. Ele encontra tudo, exceto um "
"caractere de nova linha, e existe um modo alternativo (:const:`re.DOTALL`), "
"onde ele irá corresponder até mesmo a um caractere de nova linha. ``.`` é "
"frequentemente usado quando você quer corresponder com \"qualquer "
"caractere\"."

#: ../../howto/regex.rst:163
msgid "Repeating Things"
msgstr "Repetindo coisas"

#: ../../howto/regex.rst:165
msgid ""
"Being able to match varying sets of characters is the first thing regular "
"expressions can do that isn't already possible with the methods available on "
"strings.  However, if that was the only additional capability of regexes, "
"they wouldn't be much of an advance. Another capability is that you can "
"specify that portions of the RE must be repeated a certain number of times."
msgstr ""
"Ser capaz de corresponder com variados conjuntos de caracteres é a primeira "
"coisa que as expressões regulares podem fazer que ainda não é possível com "
"os métodos disponíveis para strings. No entanto, se essa fosse a única "
"capacidade adicional das expressões regulares, elas não seriam um avanço "
"relevante. Outro recurso que você pode especificar é que partes do RE devem "
"ser repetidas um certo número de vezes."

#: ../../howto/regex.rst:171
msgid ""
"The first metacharacter for repeating things that we'll look at is ``*``.  "
"``*`` doesn't match the literal character ``'*'``; instead, it specifies "
"that the previous character can be matched zero or more times, instead of "
"exactly once."
msgstr ""
"O primeiro metacaractere para repetir coisas que veremos é ``*``. ``*`` não "
"corresponde ao caractere literal ``'*'``; em vez disso, ele especifica que o "
"caractere anterior pode ser correspondido zero ou mais vezes, em vez de "
"exatamente uma vez."

#: ../../howto/regex.rst:175
msgid ""
"For example, ``ca*t`` will match ``'ct'`` (0 ``'a'`` characters), ``'cat'`` "
"(1 ``'a'``), ``'caaat'`` (3 ``'a'`` characters), and so forth."
msgstr ""
"Por exemplo, ``ca*t`` vai corresponder ``'ct'`` (0 caracteres ``'a'``), "
"``'cat'`` (1 ``'a'``), ``'caaat'`` (3 caracteres ``'a'``), e assim por "
"diante."

#: ../../howto/regex.rst:178
msgid ""
"Repetitions such as ``*`` are :dfn:`greedy`; when repeating a RE, the "
"matching engine will try to repeat it as many times as possible. If later "
"portions of the pattern don't match, the matching engine will then back up "
"and try again with fewer repetitions."
msgstr ""
"Repetições tais como ``*`` são gulosas; ao repetir a RE, o motor de "
"correspondência vai tentar repeti-la tantas vezes quanto possível. Se "
"porções posteriores do padrão não corresponderem, o motor de "
"correspondência, em seguida, volta e tenta novamente com menos repetições."

#: ../../howto/regex.rst:183
msgid ""
"A step-by-step example will make this more obvious.  Let's consider the "
"expression ``a[bcd]*b``.  This matches the letter ``'a'``, zero or more "
"letters from the class ``[bcd]``, and finally ends with a ``'b'``.  Now "
"imagine matching this RE against the string ``'abcbd'``."
msgstr ""
"Um exemplo passo a passo fará isso mais óbvio. Vamos considerar a expressão "
"\"a[bcd]*b\". Isto corresponde à letra \"a\", zero ou mais letras da classe "
"\"[bcd]\" e, finalmente, termina com \"b\".  Agora, imagine corresponder "
"este RE com a string \"abcbd\"."

#: ../../howto/regex.rst:189
msgid "Step"
msgstr "Passo"

#: ../../howto/regex.rst:189
msgid "Matched"
msgstr "Correspondência"

#: ../../howto/regex.rst:189
msgid "Explanation"
msgstr "Explicação"

#: ../../howto/regex.rst:191
msgid "1"
msgstr "1"

#: ../../howto/regex.rst:191
msgid "``a``"
msgstr "``a``"

#: ../../howto/regex.rst:191
msgid "The ``a`` in the RE matches."
msgstr "O caractere ``a`` na RE tem correspondência."

#: ../../howto/regex.rst:193
msgid "2"
msgstr "2"

#: ../../howto/regex.rst:193
msgid "``abcbd``"
msgstr "``abcbd``"

#: ../../howto/regex.rst:193
msgid ""
"The engine matches ``[bcd]*``, going as far as it can, which is to the end "
"of the string."
msgstr ""
"O motor corresponde com ``[bcd]*``, indo tão longe quanto possível, que é o "
"fim do string."

#: ../../howto/regex.rst:197
msgid "3"
msgstr "3"

#: ../../howto/regex.rst:197 ../../howto/regex.rst:205
msgid "*Failure*"
msgstr "*Falha*"

#: ../../howto/regex.rst:197
msgid ""
"The engine tries to match ``b``, but the current position is at the end of "
"the string, so it fails."
msgstr ""
"O motor tenta corresponder com ``b``, mas a posição corrente está no final "
"da string, então ele falha."

#: ../../howto/regex.rst:202
msgid "4"
msgstr "4"

#: ../../howto/regex.rst:202 ../../howto/regex.rst:213
msgid "``abcb``"
msgstr "``abcb``"

#: ../../howto/regex.rst:202
msgid "Back up, so that  ``[bcd]*`` matches one less character."
msgstr "Voltando, de modo que ``[bcd]*`` corresponde a um caractere a menos."

#: ../../howto/regex.rst:205
msgid "5"
msgstr "5"

#: ../../howto/regex.rst:205
msgid ""
"Try ``b`` again, but the current position is at the last character, which is "
"a ``'d'``."
msgstr ""
"Tenta ``b`` novamente, mas a posição corrente é a do último caractere, que é "
"um ``'d'``."

#: ../../howto/regex.rst:209 ../../howto/regex.rst:213
msgid "6"
msgstr "6"

#: ../../howto/regex.rst:209
msgid "``abc``"
msgstr "``abc``"

#: ../../howto/regex.rst:209
msgid "Back up again, so that ``[bcd]*`` is only matching ``bc``."
msgstr ""
"Voltando novamente, de modo que ``[bcd]*`` está correspondendo com ``bc`` "
"somente."

#: ../../howto/regex.rst:213
msgid ""
"Try ``b`` again.  This time the character at the current position is "
"``'b'``, so it succeeds."
msgstr ""
"Tenta ``b`` novamente. Desta vez, o caractere na posição corrente é ``'b'``, "
"por isso sucesso."

#: ../../howto/regex.rst:219
msgid ""
"The end of the RE has now been reached, and it has matched ``'abcb'``.  This "
"demonstrates how the matching engine goes as far as it can at first, and if "
"no match is found it will then progressively back up and retry the rest of "
"the RE again and again.  It will back up until it has tried zero matches for "
"``[bcd]*``, and if that subsequently fails, the engine will conclude that "
"the string doesn't match the RE at all."
msgstr ""
"O final da RE foi atingido e correspondeu a ``'abcb'``. Isso demonstra como "
"o mecanismo de correspondência vai tão longe quanto pode no início e, se "
"nenhuma correspondência for encontrada, ele fará a volta progressivamente e "
"tentará novamente o restante da RE. Ele fará voltas até que tenha tentado "
"zero correspondências para ``[bcd]*``, e se isso falhar subsequentemente, o "
"mecanismo concluirá que a string não corresponde a RE de forma alguma."

#: ../../howto/regex.rst:226
msgid ""
"Another repeating metacharacter is ``+``, which matches one or more times.  "
"Pay careful attention to the difference between ``*`` and ``+``; ``*`` "
"matches *zero* or more times, so whatever's being repeated may not be "
"present at all, while ``+`` requires at least *one* occurrence.  To use a "
"similar example, ``ca+t`` will match ``'cat'`` (1 ``'a'``), ``'caaat'`` (3 "
"``'a'``\\ s), but won't match ``'ct'``."
msgstr ""
"Outro metacaractere de repetição é o ``+``, que corresponde a uma ou mais "
"vezes. Preste muita atenção para a diferença entre ``*`` e ``+``; ``*`` "
"corresponde com zero ou mais vezes, assim, o que quer que esteja sendo "
"repetido pode não estar presente, enquanto que ``+`` requer pelo menos uma "
"ocorrência. Para usar um exemplo similar, ``ca+t`` vai corresponder a "
"``'cat'``, (1 ``'a'``), ``'caaat'`` (3 ``'a'``\\ s), mas não corresponde com "
"``'ct'``."

#: ../../howto/regex.rst:233
msgid ""
"There are two more repeating operators or quantifiers.  The question mark "
"character, ``?``, matches either once or zero times; you can think of it as "
"marking something as being optional.  For example, ``home-?brew`` matches "
"either ``'homebrew'`` or ``'home-brew'``."
msgstr ""
"Existem mais dois quantificadores ou operadores de repetição. O caractere de "
"ponto de interrogação, ``?``, corresponde a uma ou zero vez; você pode "
"pensar nisso como a marcação de algo sendo opcional. Por exemplo, ``home-?"
"brew`` corresponde tanto a ``'homebrew'`` quanto a ``'home-brew'``."

#: ../../howto/regex.rst:238
msgid ""
"The most complicated quantifier is ``{m,n}``, where *m* and *n* are decimal "
"integers.  This quantifier means there must be at least *m* repetitions, and "
"at most *n*.  For example, ``a/{1,3}b`` will match ``'a/b'``, ``'a//b'``, "
"and ``'a///b'``.  It won't match ``'ab'``, which has no slashes, or ``'a////"
"b'``, which has four."
msgstr ""
"O qualificador mais complicado é o ``{m,n}``, no qual *m* e *n* são números "
"inteiros decimais. Este qualificador significa que deve haver pelo menos *m* "
"repetições, e no máximo *n*. Por exemplo, ``a/{1,3}b`` irá corresponder a "
"``'a/b'``, ``'a//b'`` e ``'a///b'``. Não vai corresponder a ``'ab'``, que "
"não tem barras ou a ``'a////b'``, que tem quatro."

#: ../../howto/regex.rst:244
msgid ""
"You can omit either *m* or *n*; in that case, a reasonable value is assumed "
"for the missing value.  Omitting *m* is interpreted as a lower limit of 0, "
"while omitting *n* results in an upper bound of infinity."
msgstr ""
"Você pode omitir tanto *m* quanto *n*; nesse caso, um valor razoável é "
"presumido para o valor em falta. A omissão de *m* é interpretada como o "
"limite inferior de 0, enquanto a omissão de *n* resulta como limite superior "
"o infinito."

#: ../../howto/regex.rst:248
msgid ""
"The simplest case ``{m}`` matches the preceding item exactly *m* times. For "
"example, ``a/{2}b`` will only match ``'a//b'``."
msgstr ""
"O caso mais simples ``{m}`` corresponde ao item precedente exatamente *m* "
"vezes. Por exemplo, ``a/{2}b`` corresponderá somente a ``'a//b'``."

#: ../../howto/regex.rst:251
msgid ""
"Readers of a reductionist bent may notice that the three other quantifiers "
"can all be expressed using this notation.  ``{0,}`` is the same as ``*``, "
"``{1,}`` is equivalent to ``+``, and ``{0,1}`` is the same as ``?``.  It's "
"better to use ``*``, ``+``, or ``?`` when you can, simply because they're "
"shorter and easier to read."
msgstr ""
"Os leitores de uma inclinação reducionista podem notar que os três outros "
"quantificadores podem todos serem expressos utilizando esta notação. ``{0,}"
"`` é o mesmo que ``*``, ``{1,}`` é equivalente a ``+``, e ``{0,1}`` é o "
"mesmo que ``?``. É melhor usar ``*``, ``+`` ou ``?`` quando puder, "
"simplesmente porque eles são mais curtos e fáceis de ler."

#: ../../howto/regex.rst:259
msgid "Using Regular Expressions"
msgstr "Usando expressões regulares"

#: ../../howto/regex.rst:261
msgid ""
"Now that we've looked at some simple regular expressions, how do we actually "
"use them in Python?  The :mod:`re` module provides an interface to the "
"regular expression engine, allowing you to compile REs into objects and then "
"perform matches with them."
msgstr ""
"Agora que nós vimos algumas expressões regulares simples, como nós realmente "
"as usamos em Python? O módulo :mod:`re` fornece uma interface para o "
"mecanismo de expressão regular, permitindo compilar REs em objetos e, em "
"seguida, executar comparações com eles."

#: ../../howto/regex.rst:268
msgid "Compiling Regular Expressions"
msgstr "Compilando expressões regulares"

#: ../../howto/regex.rst:270
msgid ""
"Regular expressions are compiled into pattern objects, which have methods "
"for various operations such as searching for pattern matches or performing "
"string substitutions. ::"
msgstr ""
"As expressões regulares são compiladas em objetos padrão, que têm métodos "
"para várias operações, tais como a procura por padrões de correspondência ou "
"realizar substituições de strings. ::"

#: ../../howto/regex.rst:274
msgid ""
">>> import re\n"
">>> p = re.compile('ab*')\n"
">>> p\n"
"re.compile('ab*')"
msgstr ""
">>> import re\n"
">>> p = re.compile('ab*')\n"
">>> p\n"
"re.compile('ab*')"

#: ../../howto/regex.rst:279
msgid ""
":func:`re.compile` also accepts an optional *flags* argument, used to enable "
"various special features and syntax variations.  We'll go over the available "
"settings later, but for now a single example will do::"
msgstr ""
":func:`re.compile` também aceita um argumento opcional *flags*, utilizado "
"para habilitar vários recursos especiais e variações de sintaxe. Nós vamos "
"ver todas as configurações disponíveis mais tarde, mas por agora, um único "
"exemplo vai servir::"

#: ../../howto/regex.rst:283
msgid ">>> p = re.compile('ab*', re.IGNORECASE)"
msgstr ">>> p = re.compile('ab*', re.IGNORECASE)"

#: ../../howto/regex.rst:285
msgid ""
"The RE is passed to :func:`re.compile` as a string.  REs are handled as "
"strings because regular expressions aren't part of the core Python language, "
"and no special syntax was created for expressing them.  (There are "
"applications that don't need REs at all, so there's no need to bloat the "
"language specification by including them.) Instead, the :mod:`re` module is "
"simply a C extension module included with Python, just like the :mod:"
"`socket` or :mod:`zlib` modules."
msgstr ""
"A RE é passada para :func:`re.compile` como uma string. REs são tratadas "
"como strings porque as expressões regulares não são parte do núcleo da "
"linguagem Python, e nenhuma sintaxe especial foi criada para expressá-las. "
"(Existem aplicações que não necessitam de REs nenhuma, por isso não há "
"necessidade de inchar a especificação da linguagem, incluindo-as.) Em vez "
"disso, o módulo :mod:`re` é simplesmente um módulo de extensão C incluído no "
"Python, assim como os módulos de :mod:`socket` ou :mod:`zlib`."

#: ../../howto/regex.rst:292
msgid ""
"Putting REs in strings keeps the Python language simpler, but has one "
"disadvantage which is the topic of the next section."
msgstr ""
"Colocando REs em strings mantém a linguagem Python mais simples, mas tem uma "
"desvantagem, que é o tema da próxima seção."

#: ../../howto/regex.rst:299
msgid "The Backslash Plague"
msgstr "A praga da contrabarra"

#: ../../howto/regex.rst:301
msgid ""
"As stated earlier, regular expressions use the backslash character "
"(``'\\'``) to indicate special forms or to allow special characters to be "
"used without invoking their special meaning. This conflicts with Python's "
"usage of the same character for the same purpose in string literals."
msgstr ""
"Como afirmado anteriormente, expressões regulares usam o caractere de "
"contrabarra (``\\``) para indicar formas especiais ou para permitir que "
"caracteres especiais sejam usados sem invocar o seu significado especial. "
"Isso entra em conflito com o uso pelo Python do mesmo caractere para o mesmo "
"propósito nas strings literais."

#: ../../howto/regex.rst:306
msgid ""
"Let's say you want to write a RE that matches the string ``\\section``, "
"which might be found in a LaTeX file.  To figure out what to write in the "
"program code, start with the desired string to be matched.  Next, you must "
"escape any backslashes and other metacharacters by preceding them with a "
"backslash, resulting in the string ``\\\\section``.  The resulting string "
"that must be passed to :func:`re.compile` must be ``\\\\section``.  However, "
"to express this as a Python string literal, both backslashes must be escaped "
"*again*."
msgstr ""
"Vamos dizer que você quer escrever uma RE que corresponde com a string "
"``\\section``, que pode ser encontrada em um arquivo LaTeX. Para descobrir o "
"que escrever no código do programa, comece com a string que se deseja "
"corresponder. Em seguida, você deve preceder qualquer contrabarra e outros "
"metacaracteres com uma contrabarra, tendo como resultado a string ``\\"
"\\section``. A string resultante que deve ser passada para :func:`re."
"compile` deve ser ``\\\\section``. No entanto, para expressar isso como uma "
"string literal Python, ambas as contrabarras devem ser precedidas com uma "
"contrabarra novamente."

#: ../../howto/regex.rst:315
msgid "Characters"
msgstr "Caracteres"

#: ../../howto/regex.rst:315
msgid "Stage"
msgstr "Etapa"

#: ../../howto/regex.rst:317
msgid "``\\section``"
msgstr "``\\section``"

#: ../../howto/regex.rst:317
msgid "Text string to be matched"
msgstr "String de texto a ser correspondida"

#: ../../howto/regex.rst:319
msgid "``\\\\section``"
msgstr "``\\\\section``"

#: ../../howto/regex.rst:319
msgid "Escaped backslash for :func:`re.compile`"
msgstr "Preceder com contrabarra para :func:`re.compile`"

#: ../../howto/regex.rst:321 ../../howto/regex.rst:348
msgid "``\"\\\\\\\\section\"``"
msgstr "``\"\\\\\\\\section\"``"

#: ../../howto/regex.rst:321
msgid "Escaped backslashes for a string literal"
msgstr "Contrabarras precedidas novamente para uma string literal"

#: ../../howto/regex.rst:324
msgid ""
"In short, to match a literal backslash, one has to write ``'\\\\\\\\'`` as "
"the RE string, because the regular expression must be ``\\\\``, and each "
"backslash must be expressed as ``\\\\`` inside a regular Python string "
"literal.  In REs that feature backslashes repeatedly, this leads to lots of "
"repeated backslashes and makes the resulting strings difficult to understand."
msgstr ""
"Em suma, para corresponder com uma contrabarra literal, tem de se escrever "
"``'\\\\\\\\'`` como a string da RE, porque a expressão regular deve ser ``\\"
"\\``, e cada contrabarra deve ser expressa como ``\\\\`` dentro de uma "
"string literal Python normal. Em REs que apresentam contrabarras repetidas "
"vezes, isso leva a um monte de contrabarras repetidas e faz as strings "
"resultantes difíceis de entender."

#: ../../howto/regex.rst:330
msgid ""
"The solution is to use Python's raw string notation for regular expressions; "
"backslashes are not handled in any special way in a string literal prefixed "
"with ``'r'``, so ``r\"\\n\"`` is a two-character string containing ``'\\'`` "
"and ``'n'``, while ``\"\\n\"`` is a one-character string containing a "
"newline. Regular expressions will often be written in Python code using this "
"raw string notation."
msgstr ""
"A solução é usar a notação de string bruta (raw) do Python para expressões "
"regulares; contrabarras não são tratadas de nenhuma forma especial em uma "
"string literal se prefixada com ``r``, então ``r\"\\n\"`` é uma string de "
"dois caracteres contendo ``\\`` e ``n``, enquanto ``\"\\n\"`` é uma string "
"de um único caractere contendo uma nova linha. As expressões regulares, "
"muitas vezes, são escritas no código Python usando esta notação de string "
"bruta (raw)."

#: ../../howto/regex.rst:336
msgid ""
"In addition, special escape sequences that are valid in regular expressions, "
"but not valid as Python string literals, now result in a :exc:"
"`DeprecationWarning` and will eventually become a :exc:`SyntaxError`, which "
"means the sequences will be invalid if raw string notation or escaping the "
"backslashes isn't used."
msgstr ""
"Além disso, sequências de escape especiais que são válidas em expressões "
"regulares, mas não válidas como literais de string do Python, agora resultam "
"em uma :exc:`DeprecationWarning` e eventualmente se tornarão uma :exc:"
"`SyntaxError`, o que significa que as sequências serão inválidas se a "
"notação de string bruta ou o escape das contrabarras não forem usados."

#: ../../howto/regex.rst:344
msgid "Regular String"
msgstr "String regular"

#: ../../howto/regex.rst:344
msgid "Raw string"
msgstr "**String bruta**"

#: ../../howto/regex.rst:346
msgid "``\"ab*\"``"
msgstr "``\"ab*\"``"

#: ../../howto/regex.rst:346
msgid "``r\"ab*\"``"
msgstr "``r\"ab*\"``"

#: ../../howto/regex.rst:348
msgid "``r\"\\\\section\"``"
msgstr "``r\"\\\\section\"``"

#: ../../howto/regex.rst:350
msgid "``\"\\\\w+\\\\s+\\\\1\"``"
msgstr "``\"\\\\w+\\\\s+\\\\1\"``"

#: ../../howto/regex.rst:350
msgid "``r\"\\w+\\s+\\1\"``"
msgstr "``r\"\\w+\\s+\\1\"``"

#: ../../howto/regex.rst:355
msgid "Performing Matches"
msgstr "Executando correspondências"

#: ../../howto/regex.rst:357
msgid ""
"Once you have an object representing a compiled regular expression, what do "
"you do with it?  Pattern objects have several methods and attributes. Only "
"the most significant ones will be covered here; consult the :mod:`re` docs "
"for a complete listing."
msgstr ""
"Uma vez que você tem um objeto que representa uma expressão regular "
"compilada, o que você faz com ele? Objetos Pattern têm vários métodos e "
"atributos. Apenas os mais significativos serão vistos aqui; consulte a "
"documentação do módulo :mod:`re` para uma lista completa."

#: ../../howto/regex.rst:363 ../../howto/regex.rst:417
#: ../../howto/regex.rst:1068
msgid "Method/Attribute"
msgstr "Método/Atributo"

#: ../../howto/regex.rst:363 ../../howto/regex.rst:417
#: ../../howto/regex.rst:1068
msgid "Purpose"
msgstr "Propósito"

#: ../../howto/regex.rst:365
msgid "``match()``"
msgstr "``match()``"

#: ../../howto/regex.rst:365
msgid "Determine if the RE matches at the beginning of the string."
msgstr "Determina se a RE combina com o início da string."

#: ../../howto/regex.rst:368
msgid "``search()``"
msgstr "``search()``"

#: ../../howto/regex.rst:368
msgid "Scan through a string, looking for any location where this RE matches."
msgstr ""
"Varre toda a string, procurando qualquer local onde esta RE tem "
"correspondência."

#: ../../howto/regex.rst:371
msgid "``findall()``"
msgstr "``findall()``"

#: ../../howto/regex.rst:371
msgid "Find all substrings where the RE matches, and returns them as a list."
msgstr ""
"Encontra todas as substrings onde a RE corresponde, e as retorna como uma "
"lista."

#: ../../howto/regex.rst:374
msgid "``finditer()``"
msgstr "``finditer()``"

#: ../../howto/regex.rst:374
msgid ""
"Find all substrings where the RE matches, and returns them as an :term:"
"`iterator`."
msgstr ""
"Encontra todas as substrings onde a RE corresponde, e as retorna como um :"
"term:`iterador <iterator>`."

#: ../../howto/regex.rst:378
msgid ""
":meth:`~re.Pattern.match` and :meth:`~re.Pattern.search` return ``None`` if "
"no match can be found.  If they're successful, a :ref:`match object <match-"
"objects>` instance is returned, containing information about the match: "
"where it starts and ends, the substring it matched, and more."
msgstr ""
":meth:`~re.Pattern.match` e :meth:`~re.Pattern.search` retornam ``None`` se "
"não existir nenhuma correspondência encontrada. Se tiveram sucesso, uma "
"instância de :ref:`objeto correspondência <match-objects>` é retornada, "
"contendo informações sobre a correspondência: onde ela começa e termina, a "
"substring com a qual ela teve correspondência, e mais."

#: ../../howto/regex.rst:383
msgid ""
"You can learn about this by interactively experimenting with the :mod:`re` "
"module."
msgstr ""
"Você pode aprender mais sobre isso experimentando interativamente com o "
"módulo :mod:`re`."

#: ../../howto/regex.rst:386
msgid ""
"This HOWTO uses the standard Python interpreter for its examples. First, run "
"the Python interpreter, import the :mod:`re` module, and compile a RE::"
msgstr ""
"Este documento usa o interpretador Python padrão para seus exemplos. "
"Primeiro, execute o interpretador Python, importe o módulo :mod:`re`, e "
"compile uma RE::"

#: ../../howto/regex.rst:389
msgid ""
">>> import re\n"
">>> p = re.compile('[a-z]+')\n"
">>> p\n"
"re.compile('[a-z]+')"
msgstr ""
">>> import re\n"
">>> p = re.compile('[a-z]+')\n"
">>> p\n"
"re.compile('[a-z]+')"

#: ../../howto/regex.rst:394
msgid ""
"Now, you can try matching various strings against the RE ``[a-z]+``.  An "
"empty string shouldn't match at all, since ``+`` means 'one or more "
"repetitions'. :meth:`~re.Pattern.match` should return ``None`` in this case, "
"which will cause the interpreter to print no output.  You can explicitly "
"print the result of :meth:`!match` to make this clear. ::"
msgstr ""
"Agora, você pode tentar corresponder várias strings com a RE ``[a-z]+``. Mas "
"uma string vazia não deveria corresponder com nada, uma vez que ``+`` "
"significa 'uma ou mais repetições'. :meth:`~re.Pattern.match` deve retornar "
"``None`` neste caso, o que fará com que o interpretador não imprima nenhuma "
"saída. Você pode imprimir explicitamente o resultado de :meth:`!match` para "
"deixar isso claro."

#: ../../howto/regex.rst:400
msgid ""
">>> p.match(\"\")\n"
">>> print(p.match(\"\"))\n"
"None"
msgstr ""
">>> p.match(\"\")\n"
">>> print(p.match(\"\"))\n"
"None"

#: ../../howto/regex.rst:404
msgid ""
"Now, let's try it on a string that it should match, such as ``tempo``.  In "
"this case, :meth:`~re.Pattern.match` will return a :ref:`match object <match-"
"objects>`, so you should store the result in a variable for later use. ::"
msgstr ""
"Agora, vamos experimentá-la em uma string que ela deve corresponder, como "
"``tempo``. Neste caso, :meth:`~re.Pattern.match` irá retornar um :ref:"
"`objeto correspondência <match-objects>`, assim você deve armazenar o "
"resultado em uma variável para uso posterior."

#: ../../howto/regex.rst:408
msgid ""
">>> m = p.match('tempo')\n"
">>> m\n"
"<re.Match object; span=(0, 5), match='tempo'>"
msgstr ""
">>> m = p.match('tempo')\n"
">>> m\n"
"<re.Match object; span=(0, 5), match='tempo'>"

#: ../../howto/regex.rst:412
msgid ""
"Now you can query the :ref:`match object <match-objects>` for information "
"about the matching string.  Match object instances also have several methods "
"and attributes; the most important ones are:"
msgstr ""
"Agora você pode consultar o :ref:`objeto correspondência <match-objects>` "
"para obter informações sobre a string correspondente. Instâncias do objeto "
"correspondência também tem vários métodos e atributos; os mais importantes "
"são os seguintes:"

#: ../../howto/regex.rst:419
msgid "``group()``"
msgstr "``group()``"

#: ../../howto/regex.rst:419
msgid "Return the string matched by the RE"
msgstr "Retorna a string que corresponde com a RE"

#: ../../howto/regex.rst:421
msgid "``start()``"
msgstr "``start()``"

#: ../../howto/regex.rst:421
msgid "Return the starting position of the match"
msgstr "Retorna a posição inicial da string correspondente"

#: ../../howto/regex.rst:423
msgid "``end()``"
msgstr "``end()``"

#: ../../howto/regex.rst:423
msgid "Return the ending position of the match"
msgstr "Retorna a posição final da string correspondente"

#: ../../howto/regex.rst:425
msgid "``span()``"
msgstr "``span()``"

#: ../../howto/regex.rst:425
msgid "Return a tuple containing the (start, end) positions  of the match"
msgstr ""
"Retorna uma tupla contendo as posições (inicial, final) da string "
"correspondente"

#: ../../howto/regex.rst:429
msgid "Trying these methods will soon clarify their meaning::"
msgstr "Experimentando estes métodos teremos seus significado esclarecidos::"

#: ../../howto/regex.rst:431
msgid ""
">>> m.group()\n"
"'tempo'\n"
">>> m.start(), m.end()\n"
"(0, 5)\n"
">>> m.span()\n"
"(0, 5)"
msgstr ""
">>> m.group()\n"
"'tempo'\n"
">>> m.start(), m.end()\n"
"(0, 5)\n"
">>> m.span()\n"
"(0, 5)"

#: ../../howto/regex.rst:438
msgid ""
":meth:`~re.Match.group` returns the substring that was matched by the RE.  :"
"meth:`~re.Match.start` and :meth:`~re.Match.end` return the starting and "
"ending index of the match. :meth:`~re.Match.span` returns both start and end "
"indexes in a single tuple.  Since the :meth:`~re.Pattern.match` method only "
"checks if the RE matches at the start of a string, :meth:`!start` will "
"always be zero.  However, the :meth:`~re.Pattern.search` method of patterns "
"scans through the string, so  the match may not start at zero in that "
"case. ::"
msgstr ""
":meth:`~re.Match.group` retorna a substring que correspondeu com a RE.  :"
"meth:`~re.Match.start` e :meth:`~re.Match.end` retornam os índices inicial e "
"o final da substring correspondente. :meth:`~re.Match.span` retorna tanto os "
"índices inicial e final em uma única tupla. Como o método :meth:`~re.Pattern."
"match` somente verifica se a RE corresponde ao início de uma string, :meth:`!"
"start` será sempre zero. No entanto, o método :meth:`~re.Pattern.search` dos "
"objetos padrão, varre toda a string, de modo que a substring correspondente "
"pode não iniciar em zero nesse caso."

#: ../../howto/regex.rst:446
msgid ""
">>> print(p.match('::: message'))\n"
"None\n"
">>> m = p.search('::: message'); print(m)\n"
"<re.Match object; span=(4, 11), match='message'>\n"
">>> m.group()\n"
"'message'\n"
">>> m.span()\n"
"(4, 11)"
msgstr ""
">>> print(p.match('::: message'))\n"
"None\n"
">>> m = p.search('::: message'); print(m)\n"
"<re.Match object; span=(4, 11), match='message'>\n"
">>> m.group()\n"
"'message'\n"
">>> m.span()\n"
"(4, 11)"

#: ../../howto/regex.rst:455
msgid ""
"In actual programs, the most common style is to store the :ref:`match object "
"<match-objects>` in a variable, and then check if it was ``None``.  This "
"usually looks like::"
msgstr ""
"Nos programas reais, o estilo mais comum é armazenar o :ref:`objeto "
"correspondência <match-objects>` em uma variável e, em seguida, verificar se "
"ela é ``None``. Isso geralmente se parece com::"

#: ../../howto/regex.rst:459
msgid ""
"p = re.compile( ... )\n"
"m = p.match( 'string goes here' )\n"
"if m:\n"
"    print('Match found: ', m.group())\n"
"else:\n"
"    print('No match')"
msgstr ""
"p = re.compile( ... )\n"
"m = p.match( 'string vai aqui' )\n"
"if m:\n"
"    print('Correspondência encontrada: ', m.group())\n"
"else:\n"
"    print('Sem correspondência')"

#: ../../howto/regex.rst:466
msgid ""
"Two pattern methods return all of the matches for a pattern. :meth:`~re."
"Pattern.findall` returns a list of matching strings::"
msgstr ""
"Dois métodos padrão retornam todas as correspondências de um padrão. :meth:"
"`~re.Pattern.findall` retorna uma lista de strings correspondentes:"

#: ../../howto/regex.rst:469
msgid ""
">>> p = re.compile(r'\\d+')\n"
">>> p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')\n"
"['12', '11', '10']"
msgstr ""
">>> p = re.compile(r'\\d+')\n"
">>> p.findall('12 percussionistas tocando tambores, 11 flautistas tocando "
"flautas, 10  lordes saltando')\n"
"['12', '11', '10']"

#: ../../howto/regex.rst:473
msgid ""
"The ``r`` prefix, making the literal a raw string literal, is needed in this "
"example because escape sequences in a normal \"cooked\" string literal that "
"are not recognized by Python, as opposed to regular expressions, now result "
"in a :exc:`DeprecationWarning` and will eventually become a :exc:"
"`SyntaxError`.  See :ref:`the-backslash-plague`."
msgstr ""
"O prefixo ``r``, tornando literal uma literal de string bruta, é necessário "
"neste exemplo porque sequências de escape em uma literal de string "
"\"cozida\" normal que não são reconhecidas pelo Python, ao contrário de "
"expressões regulares, agora resultam em uma :exc:`DeprecationWarning` e "
"eventualmente se tornarão uma :exc:`SyntaxError`. Veja :ref:`the-backslash-"
"plague`."

#: ../../howto/regex.rst:479
msgid ""
":meth:`~re.Pattern.findall` has to create the entire list before it can be "
"returned as the result.  The :meth:`~re.Pattern.finditer` method returns a "
"sequence of :ref:`match object <match-objects>` instances as an :term:"
"`iterator`::"
msgstr ""
":meth:`~re.Pattern.findall` tem que criar a lista inteira antes de poder "
"devolvê-la como resultado. O método :meth:`~re.Pattern.finditer` retorna uma "
"sequência de instâncias :ref:`objeto correspondência <match-objects>` como "
"um :term:`iterator`::"

#: ../../howto/regex.rst:483
msgid ""
">>> iterator = p.finditer('12 drummers drumming, 11 ... 10 ...')\n"
">>> iterator\n"
"<callable_iterator object at 0x...>\n"
">>> for match in iterator:\n"
"...     print(match.span())\n"
"...\n"
"(0, 2)\n"
"(22, 24)\n"
"(29, 31)"
msgstr ""
">>> iterator = p.finditer('12 percussionistas tocando tambores, 11 ... "
"10 ...')\n"
">>> iterator\n"
"<callable_iterator object at 0x...>\n"
">>> for match in iterator:\n"
"...     print(match.span())\n"
"...\n"
"(0, 2)\n"
"(22, 24)\n"
"(29, 31)"

#: ../../howto/regex.rst:495
msgid "Module-Level Functions"
msgstr "Funções de nível de módulo"

#: ../../howto/regex.rst:497
msgid ""
"You don't have to create a pattern object and call its methods; the :mod:"
"`re` module also provides top-level functions called :func:`~re.match`, :"
"func:`~re.search`, :func:`~re.findall`, :func:`~re.sub`, and so forth.  "
"These functions take the same arguments as the corresponding pattern method "
"with the RE string added as the first argument, and still return either "
"``None`` or a :ref:`match object <match-objects>` instance. ::"
msgstr ""
"Você não tem que criar um objeto padrão e chamar seus métodos; o módulo :mod:"
"`re` também fornece funções de nível superior chamadas :func:`~re.match`, :"
"func:`~re.search`, :func:`~re.findall`, :func:`~re.sub`, e assim por diante. "
"Estas funções recebem os mesmos argumentos que o método correspondente do "
"objeto padrão, com a string RE adicionada como o primeiro argumento, e ainda "
"retornam ``None`` ou uma instância :ref:`objeto correspondência <match-"
"objects>`. ::"

#: ../../howto/regex.rst:504
msgid ""
">>> print(re.match(r'From\\s+', 'Fromage amk'))\n"
"None\n"
">>> re.match(r'From\\s+', 'From amk Thu May 14 19:12:10 1998')\n"
"<re.Match object; span=(0, 5), match='From '>"
msgstr ""
">>> print(re.match(r'From\\s+', 'Fromage amk'))\n"
"None\n"
">>> re.match(r'From\\s+', 'From amk Thu May 14 19:12:10 1998')\n"
"<re.Match object; span=(0, 5), match='From '>"

#: ../../howto/regex.rst:509
msgid ""
"Under the hood, these functions simply create a pattern object for you and "
"call the appropriate method on it.  They also store the compiled object in a "
"cache, so future calls using the same RE won't need to parse the pattern "
"again and again."
msgstr ""
"Sob o capô, estas funções simplesmente criam um objeto padrão para você e "
"chamam o método apropriado para ele. Elas também armazenam o objeto "
"compilado em um cache, para que futuras chamadas usando a mesma RE não "
"precisem analisar o padrão de novo e de novo."

#: ../../howto/regex.rst:514
msgid ""
"Should you use these module-level functions, or should you get the pattern "
"and call its methods yourself?  If you're accessing a regex within a loop, "
"pre-compiling it will save a few function calls. Outside of loops, there's "
"not much difference thanks to the internal cache."
msgstr ""
"Você deve usar essas funções de nível de módulo ou deve obter o padrão e "
"chamar seus métodos você mesmo? Se estiver acessando uma expressão regular "
"dentro de um laço de repetição, pré-compilá-la economizará algumas chamadas "
"de função. Fora dos laços, não há muita diferença graças ao cache interno."

#: ../../howto/regex.rst:522
msgid "Compilation Flags"
msgstr "Sinalizadores de compilação"

#: ../../howto/regex.rst:526
msgid ""
"Compilation flags let you modify some aspects of how regular expressions "
"work. Flags are available in the :mod:`re` module under two names, a long "
"name such as :const:`IGNORECASE` and a short, one-letter form such as :const:"
"`I`.  (If you're familiar with Perl's pattern modifiers, the one-letter "
"forms use the same letters; the short form of :const:`re.VERBOSE` is :const:"
"`re.X`, for example.) Multiple flags can be specified by bitwise OR-ing "
"them; ``re.I | re.M`` sets both the :const:`I` and :const:`M` flags, for "
"example."
msgstr ""
"Sinalizadores de compilação permitem modificar alguns aspectos de como as "
"expressões regulares funcionam. Sinalizadores estão disponíveis no módulo :"
"mod:`re` sob dois nomes, um nome longo, tal como :const:`IGNORECASE` e um "
"curto, na forma de uma letra, como :const:`I`. (Se você estiver "
"familiarizado com o padrão dos modificadores do Perl, o nome curto usa as "
"mesmas letras; o forma abreviada de :const:`re.VERBOSE` é :const:`re.X`, por "
"exemplo). Vários sinalizadores podem ser especificados aplicando um ``OU`` "
"bit a bit nelas; ``re.I | re.M`` define os sinalizadores :const:`I` e :const:"
"`M`, por exemplo."

#: ../../howto/regex.rst:534
msgid ""
"Here's a table of the available flags, followed by a more detailed "
"explanation of each one."
msgstr ""
"Aqui está uma tabela dos sinalizadores disponíveis, seguida por uma "
"explicação mais detalhada de cada um:"

#: ../../howto/regex.rst:538
msgid "Flag"
msgstr "Sinalizador"

#: ../../howto/regex.rst:538
msgid "Meaning"
msgstr "Significado"

#: ../../howto/regex.rst:540
msgid ":const:`ASCII`, :const:`A`"
msgstr ":const:`ASCII`, :const:`A`"

#: ../../howto/regex.rst:540
msgid ""
"Makes several escapes like ``\\w``, ``\\b``, ``\\s`` and ``\\d`` match only "
"on ASCII characters with the respective property."
msgstr ""
"Faz com que vários escapes como ``\\w``, ``\\b``, ``\\s`` e ``\\d`` "
"correspondam apenas a caracteres ASCII com a respectiva propriedade."

#: ../../howto/regex.rst:544
msgid ":const:`DOTALL`, :const:`S`"
msgstr ":const:`DOTALL`, :const:`S`"

#: ../../howto/regex.rst:544
msgid "Make ``.`` match any character, including newlines."
msgstr "Faz o ``.`` corresponder a qualquer caractere, incluindo novas linhas."

#: ../../howto/regex.rst:547
msgid ":const:`IGNORECASE`, :const:`I`"
msgstr ":const:`IGNORECASE`, :const:`I`"

#: ../../howto/regex.rst:547
msgid "Do case-insensitive matches."
msgstr "Faz combinações sem diferenciar maiúsculo de minúsculo."

#: ../../howto/regex.rst:549
msgid ":const:`LOCALE`, :const:`L`"
msgstr ":const:`LOCALE`, :const:`L`"

#: ../../howto/regex.rst:549
msgid "Do a locale-aware match."
msgstr "Faz uma correspondência considerando a localidade."

#: ../../howto/regex.rst:551
msgid ":const:`MULTILINE`, :const:`M`"
msgstr ":const:`MULTILINE`, :const:`M`"

#: ../../howto/regex.rst:551
msgid "Multi-line matching, affecting ``^`` and ``$``."
msgstr "Correspondência multilinha, afetando ``^`` e ``$``."

#: ../../howto/regex.rst:554
msgid ":const:`VERBOSE`, :const:`X` (for 'extended')"
msgstr ":const:`VERBOSE`, :const:`X` (de 'extended'; estendido em inglês)"

#: ../../howto/regex.rst:554
msgid ""
"Enable verbose REs, which can be organized more cleanly and understandably."
msgstr ""
"Habilita REs detalhadas, que podem ser organizadas de forma mais clara e "
"compreensível."

#: ../../howto/regex.rst:563
msgid ""
"Perform case-insensitive matching; character class and literal strings will "
"match letters by ignoring case.  For example, ``[A-Z]`` will match lowercase "
"letters, too. Full Unicode matching also works unless the :const:`ASCII` "
"flag is used to disable non-ASCII matches.  When the Unicode patterns ``[a-"
"z]`` or ``[A-Z]`` are used in combination with the :const:`IGNORECASE` flag, "
"they will match the 52 ASCII letters and 4 additional non-ASCII letters: "
"'İ' (U+0130, Latin capital letter I with dot above), 'ı' (U+0131, Latin "
"small letter dotless i), 'ſ' (U+017F, Latin small letter long s) and "
"'K' (U+212A, Kelvin sign).  ``Spam`` will match ``'Spam'``, ``'spam'``, "
"``'spAM'``, or ``'ſpam'`` (the latter is matched only in Unicode mode). This "
"lowercasing doesn't take the current locale into account; it will if you "
"also set the :const:`LOCALE` flag."
msgstr ""
"Faz correspondência sem distinção entre maiúsculas e minúsculas; a classe de "
"caracteres e as strings literais corresponderão às letras ignorando "
"maiúsculas e minúsculas. Por exemplo, ``[A-Z]`` corresponderá às letras "
"minúsculas também. A correspondência Unicode completa também funciona, a "
"menos que o sinalizador :const:`ASCII` seja usado para desabilitar "
"correspondências não ASCII. Quando os padrões Unicode ``[a-z]`` ou ``[A-Z]`` "
"são usados em combinação com o sinalizador :const:`IGNORECASE`, eles "
"corresponderão às 52 letras ASCII e 4 letras não ASCII adicionais: "
"'İ' (U+0130, letra maiúscula latina I com ponto acima), 'ı' (U+0131, letra "
"minúscula latina i sem ponto), 'ſ' (U+017F, letra minúscula latina s longo) "
"e 'K' (U+212A, sinal Kelvin). ``Spam`` corresponderá a ``'Spam'``, "
"``'spam'``, ``'spAM'`` ou ``'ſpam'`` (o último é correspondido apenas no "
"modo Unicode). Essa capitalização em minúsculas não leva em conta a "
"localidade atual; levará se você também definir o sinalizador :const:"
"`LOCALE`."

#: ../../howto/regex.rst:581
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale instead of the Unicode database."
msgstr ""
"Faz com que ``\\w``, ``\\W``, ``\\b``, ``\\B`` e a correspondência sem "
"diferenciação de maiúsculas e minúsculas dependam da localidade atual em vez "
"do banco de dados Unicode."

#: ../../howto/regex.rst:584
msgid ""
"Locales are a feature of the C library intended to help in writing programs "
"that take account of language differences.  For example, if you're "
"processing encoded French text, you'd want to be able to write ``\\w+`` to "
"match words, but ``\\w`` only matches the character class ``[A-Za-z]`` in "
"bytes patterns; it won't match bytes corresponding to ``é`` or ``ç``. If "
"your system is configured properly and a French locale is selected, certain "
"C functions will tell the program that the byte corresponding to ``é`` "
"should also be considered a letter. Setting the :const:`LOCALE` flag when "
"compiling a regular expression will cause the resulting compiled object to "
"use these C functions for ``\\w``; this is slower, but also enables ``\\w+`` "
"to match French words as you'd expect. The use of this flag is discouraged "
"in Python 3 as the locale mechanism is very unreliable, it only handles one "
"\"culture\" at a time, and it only works with 8-bit locales.  Unicode "
"matching is already enabled by default in Python 3 for Unicode (str) "
"patterns, and it is able to handle different locales/languages."
msgstr ""
"Localidades são um recurso da biblioteca C destinado a ajudar na escrita de "
"programas que levam em conta as diferenças de idioma. Por exemplo, se você "
"estiver processando texto codificado em francês, você gostaria de ser capaz "
"de escrever ``\\w+`` para corresponder a palavras, mas ``\\w`` corresponde "
"apenas à classe de caracteres ``[A-Za-z]`` em padrões de bytes; ele não "
"corresponderá a bytes correspondentes a ``é`` ou ``ç``. Se seu sistema "
"estiver configurado corretamente e uma localidade francesa for selecionada, "
"certas funções C dirão ao programa que o byte correspondente a ``é`` também "
"deve ser considerado uma letra. Definir o sinalizador :const:`LOCALE` ao "
"compilar uma expressão regular fará com que o objeto compilado resultante "
"use essas funções C para ``\\w``; isso é mais lento, mas também permite que "
"``\\w+`` corresponda a palavras francesas como você esperaria. O uso deste "
"sinalizador é desencorajado no Python 3, pois o mecanismo de localidade é "
"muito pouco confiável, ele só manipula uma \"cultura\" por vez e só funciona "
"com localidades de 8 bits. A correspondência Unicode já está habilitada por "
"padrão no Python 3 para padrões Unicode (str), e é capaz de manipular "
"diferentes localidades/idiomas."

#: ../../howto/regex.rst:606
msgid ""
"(``^`` and ``$`` haven't been explained yet;  they'll be introduced in "
"section :ref:`more-metacharacters`.)"
msgstr ""
"(``^`` e ``$`` ainda não foram explicados, eles serão comentados na seção :"
"ref:`more-metacharacters`.)"

#: ../../howto/regex.rst:609
msgid ""
"Usually ``^`` matches only at the beginning of the string, and ``$`` matches "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string. When this flag is specified, ``^`` matches at the "
"beginning of the string and at the beginning of each line within the string, "
"immediately following each newline.  Similarly, the ``$`` metacharacter "
"matches either at the end of the string and at the end of each line "
"(immediately preceding each newline)."
msgstr ""
"Normalmente ``^`` corresponde apenas ao início da string e ``$`` corresponde "
"apenas ao final da string, e imediatamente antes da nova linha (se existir) "
"no final da string. Quando este sinalizador é especificada, o ``^`` "
"corresponde ao início da string e ao início de cada linha dentro da string, "
"imediatamente após cada nova linha. Da mesma forma, o metacaractere ``$`` "
"corresponde tanto ao final da string e ao final de cada linha (imediatamente "
"antes de cada nova linha)."

#: ../../howto/regex.rst:622
msgid ""
"Makes the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr ""
"Faz o caractere especial ``.`` corresponder com qualquer caractere que seja, "
"incluindo uma nova linha; sem este sinalizador, ``.`` irá corresponder a "
"qualquer coisa, exceto uma nova linha."

#: ../../howto/regex.rst:630
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` and ``\\S`` perform ASCII-"
"only matching instead of full Unicode matching. This is only meaningful for "
"Unicode patterns, and is ignored for byte patterns."
msgstr ""
"Faz com que ``\\w``, ``\\W``, ``\\b``, ``\\B``,  ``\\s`` e ``\\S`` executem "
"a correspondência somente ASCII em vez da correspondência Unicode completa. "
"Isso é significativo apenas para padrões Unicode e é ignorado para padrões "
"de bytes."

#: ../../howto/regex.rst:639
msgid ""
"This flag allows you to write regular expressions that are more readable by "
"granting you more flexibility in how you can format them.  When this flag "
"has been specified, whitespace within the RE string is ignored, except when "
"the whitespace is in a character class or preceded by an unescaped "
"backslash; this lets you organize and indent the RE more clearly.  This flag "
"also lets you put comments within a RE that will be ignored by the engine; "
"comments are marked by a ``'#'`` that's neither in a character class or "
"preceded by an unescaped backslash."
msgstr ""
"Este sinalizador permite escrever expressões regulares mais legíveis, "
"permitindo mais flexibilidade na maneira de formatá-la. Quando este "
"sinalizador é especificado, o espaço em branco dentro da string RE é "
"ignorado, exceto quando o espaço em branco está em uma classe de caracteres "
"ou precedido por uma barra invertida não \"escapada\"; isto permite "
"organizar e formatar a RE de maneira mais clara. Este sinalizador também "
"permite que se coloque comentários dentro de uma RE que serão ignorados pelo "
"mecanismo; os comentários são marcados por um \"#\" que não está nem em uma "
"classe de caracteres nem precedido por uma barra invertida não \"escapada\"."

#: ../../howto/regex.rst:648
msgid ""
"For example, here's a RE that uses :const:`re.VERBOSE`; see how much easier "
"it is to read? ::"
msgstr ""
"Por exemplo, aqui está uma RE que usa :const:`re.VERBOSE`; consegue ver o "
"quanto mais fácil de ler é? ::"

#: ../../howto/regex.rst:651
msgid ""
"charref = re.compile(r\"\"\"\n"
" &[#]                # Start of a numeric entity reference\n"
" (\n"
"     0[0-7]+         # Octal form\n"
"   | [0-9]+          # Decimal form\n"
"   | x[0-9a-fA-F]+   # Hexadecimal form\n"
" )\n"
" ;                   # Trailing semicolon\n"
"\"\"\", re.VERBOSE)"
msgstr ""
"charref = re.compile(r\"\"\"\n"
" &[#]                # Início de uma referência à entidade numérica\n"
" (\n"
"     0[0-7]+         # Forma octal\n"
"   | [0-9]+          # Forma decimal\n"
"   | x[0-9a-fA-F]+   # Forma hexadecimal\n"
" )\n"
" ;                   # Ponto e vírgula ao final\n"
"\"\"\", re.VERBOSE)"

#: ../../howto/regex.rst:661
msgid "Without the verbose setting, the RE would look like this::"
msgstr "Sem o \"verbose\" definido, A RE iria se parecer como isto::"

#: ../../howto/regex.rst:663
msgid ""
"charref = re.compile(\"&#(0[0-7]+\"\n"
"                     \"|[0-9]+\"\n"
"                     \"|x[0-9a-fA-F]+);\")"
msgstr ""
"charref = re.compile(\"&#(0[0-7]+\"\n"
"                     \"|[0-9]+\"\n"
"                     \"|x[0-9a-fA-F]+);\")"

#: ../../howto/regex.rst:667
msgid ""
"In the above example, Python's automatic concatenation of string literals "
"has been used to break up the RE into smaller pieces, but it's still more "
"difficult to understand than the version using :const:`re.VERBOSE`."
msgstr ""
"No exemplo acima, a concatenação automática de strings literais em Python "
"foi usada para quebrar a RE em partes menores, mas ainda é mais difícil de "
"entender do que a versão que usa :const:`re.VERBOSE`."

#: ../../howto/regex.rst:673
msgid "More Pattern Power"
msgstr "Mais poder dos padrões"

#: ../../howto/regex.rst:675
msgid ""
"So far we've only covered a part of the features of regular expressions.  In "
"this section, we'll cover some new metacharacters, and how to use groups to "
"retrieve portions of the text that was matched."
msgstr ""
"Até agora, cobrimos apenas uma parte dos recursos das expressões regulares. "
"Nesta seção, vamos abordar alguns metacaracteres novos, e como usar grupos "
"para recuperar partes do texto que teve correspondência."

#: ../../howto/regex.rst:683
msgid "More Metacharacters"
msgstr "Mais metacaracteres"

#: ../../howto/regex.rst:685
msgid ""
"There are some metacharacters that we haven't covered yet.  Most of them "
"will be covered in this section."
msgstr ""
"Existem alguns metacaracteres que nós ainda não vimos. A maioria deles serão "
"referenciados nesta seção."

#: ../../howto/regex.rst:688
msgid ""
"Some of the remaining metacharacters to be discussed are :dfn:`zero-width "
"assertions`.  They don't cause the engine to advance through the string; "
"instead, they consume no characters at all, and simply succeed or fail.  For "
"example, ``\\b`` is an assertion that the current position is located at a "
"word boundary; the position isn't changed by the ``\\b`` at all.  This means "
"that zero-width assertions should never be repeated, because if they match "
"once at a given location, they can obviously be matched an infinite number "
"of times."
msgstr ""
"Alguns dos metacaracteres restantes a serem discutidos são como uma asserção "
"de ``largura zero`` (zero-width assertions). Eles não fazem com que o "
"mecanismo avance pela string; ao contrário, eles não consomem nenhum "
"caractere, e simplesmente tem sucesso ou falha. Por exemplo, ``\\b`` é uma "
"afirmação de que a posição atual está localizada nas bordas de uma palavra; "
"a posição não é alterada de nenhuma maneira por ``\\b``. Isto significa que "
"afirmações de ``largura zero`` nunca devem ser repetidas, porque se elas "
"combinam uma vez em um determinado local, elas podem, obviamente, combinar "
"um número infinito de vezes."

#: ../../howto/regex.rst:696
msgid "``|``"
msgstr "``|``"

#: ../../howto/regex.rst:697
msgid ""
"Alternation, or the \"or\" operator.   If *A* and *B* are regular "
"expressions, ``A|B`` will match any string that matches either *A* or *B*. "
"``|`` has very low precedence in order to make it work reasonably when "
"you're alternating multi-character strings. ``Crow|Servo`` will match either "
"``'Crow'`` or ``'Servo'``, not ``'Cro'``, a ``'w'`` or an ``'S'``, and "
"``'ervo'``."
msgstr ""
"Alternância, ou operador \"or\". Se *A* e *B* são expressões regulares, ``A|"
"B`` irá corresponder com qualquer string que corresponder com *A* ou *B*. ``|"
"`` tem uma prioridade muito baixa, a fim de fazê-lo funcionar razoavelmente "
"quando você está alternando entre strings de vários caracteres. ``Crow|"
"Servo`` irá corresponder tanto com ``'Crow'`` quanto com ``'Servo'``, e não "
"com ``'Cro'``, ``'w'`` ou ``'S'``, e ``'ervo'``."

#: ../../howto/regex.rst:703
msgid ""
"To match a literal ``'|'``, use ``\\|``, or enclose it inside a character "
"class, as in ``[|]``."
msgstr ""
"Para corresponder com um ``'|'`` literal, use ``\\|``, ou coloque ele dentro "
"de uma classe de caracteres, como em ``[|]``."

#: ../../howto/regex.rst:706
msgid "``^``"
msgstr "``^``"

#: ../../howto/regex.rst:707
msgid ""
"Matches at the beginning of lines.  Unless the :const:`MULTILINE` flag has "
"been set, this will only match at the beginning of the string.  In :const:"
"`MULTILINE` mode, this also matches immediately after each newline within "
"the string."
msgstr ""
"Corresponde ao início de linha. A menos que o sinalizador :const:`MULTILINE` "
"tenha sido definido, isso só irá corresponder ao início da string. No modo :"
"const:`MULTILINE`, isso também corresponde imediatamente após cada nova "
"linha de dentro da string."

#: ../../howto/regex.rst:711
msgid ""
"For example, if you wish to match the word ``From`` only at the beginning of "
"a line, the RE to use is ``^From``. ::"
msgstr ""
"Por exemplo, para ter correspondência com a palavra ``From`` apenas no "
"início de uma linha, a RE a ser usada é ``^From``. ::"

#: ../../howto/regex.rst:714
msgid ""
">>> print(re.search('^From', 'From Here to Eternity'))\n"
"<re.Match object; span=(0, 4), match='From'>\n"
">>> print(re.search('^From', 'Reciting From Memory'))\n"
"None"
msgstr ""
">>> print(re.search('^From', 'From Here to Eternity'))\n"
"<re.Match object; span=(0, 4), match='From'>\n"
">>> print(re.search('^From', 'Reciting From Memory'))\n"
"None"

#: ../../howto/regex.rst:719
msgid "To match a literal ``'^'``, use ``\\^``."
msgstr "Para corresponder a um ``'^'`` literal, use ``\\^``."

#: ../../howto/regex.rst:721
msgid "``$``"
msgstr "``$``"

#: ../../howto/regex.rst:722
msgid ""
"Matches at the end of a line, which is defined as either the end of the "
"string, or any location followed by a newline character.     ::"
msgstr ""
"Corresponde ao fim de uma linha, que tanto é definido como o fim de uma "
"string, ou qualquer local seguido por um caractere de nova linha. ::"

#: ../../howto/regex.rst:725
msgid ""
">>> print(re.search('}$', '{block}'))\n"
"<re.Match object; span=(6, 7), match='}'>\n"
">>> print(re.search('}$', '{block} '))\n"
"None\n"
">>> print(re.search('}$', '{block}\\n'))\n"
"<re.Match object; span=(6, 7), match='}'>"
msgstr ""
">>> print(re.search('}$', '{block}'))\n"
"<re.Match object; span=(6, 7), match='}'>\n"
">>> print(re.search('}$', '{block} '))\n"
"None\n"
">>> print(re.search('}$', '{block}\\n'))\n"
"<re.Match object; span=(6, 7), match='}'>"

#: ../../howto/regex.rst:732
msgid ""
"To match a literal ``'$'``, use ``\\$`` or enclose it inside a character "
"class, as in  ``[$]``."
msgstr ""
"Para corresponder com um ``'$'`` literal, use ``\\$`` ou coloque-o dentro de "
"uma classe de caracteres, como em ``[$]``."

#: ../../howto/regex.rst:735
msgid "``\\A``"
msgstr "``\\A``"

#: ../../howto/regex.rst:736
msgid ""
"Matches only at the start of the string.  When not in :const:`MULTILINE` "
"mode, ``\\A`` and ``^`` are effectively the same.  In :const:`MULTILINE` "
"mode, they're different: ``\\A`` still matches only at the beginning of the "
"string, but ``^`` may match at any location inside the string that follows a "
"newline character."
msgstr ""
"Corresponde apenas com o início da string. Quando não estiver em modo :const:"
"`MULTILINE`, ``\\A`` e ``^`` são efetivamente a mesma coisa. No modo :const:"
"`MULTILINE`, eles são diferentes: ``\\A`` continua a corresponder apenas com "
"o início da string, mas ``^`` pode corresponder com qualquer localização de "
"dentro da string, que seja posterior a um caractere nova linha."

#: ../../howto/regex.rst:741
msgid "``\\z``"
msgstr "``\\z``"

#: ../../howto/regex.rst:742
msgid "Matches only at the end of the string."
msgstr "Corresponde apenas ao final da string."

#: ../../howto/regex.rst:744
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../howto/regex.rst:745
msgid "The same as ``\\z``.  For compatibility with old Python versions."
msgstr ""
"O mesmo que ``\\z``. Para compatibilidade com versões mais antigas de Python."

#: ../../howto/regex.rst:747
msgid "``\\b``"
msgstr "``\\b``"

#: ../../howto/regex.rst:748
msgid ""
"Word boundary.  This is a zero-width assertion that matches only at the "
"beginning or end of a word.  A word is defined as a sequence of alphanumeric "
"characters, so the end of a word is indicated by whitespace or a non-"
"alphanumeric character."
msgstr ""
"Borda de palavra. Esta é uma asserção de largura zero que corresponde apenas "
"ao início ou ao fim de uma palavra. Uma palavra é definida como uma "
"sequência de caracteres alfanuméricos, então o fim de uma palavra é indicado "
"por espaço em branco ou um caractere não alfanumérico."

#: ../../howto/regex.rst:753
msgid ""
"The following example matches ``class`` only when it's a complete word; it "
"won't match when it's contained inside another word. ::"
msgstr ""
"O exemplo a seguir corresponde a ``class`` apenas quando é a palavra exata; "
"ele não irá corresponder quando for contido dentro de uma outra palavra. ::"

#: ../../howto/regex.rst:756
msgid ""
">>> p = re.compile(r'\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"<re.Match object; span=(3, 8), match='class'>\n"
">>> print(p.search('the declassified algorithm'))\n"
"None\n"
">>> print(p.search('one subclass is'))\n"
"None"
msgstr ""
">>> p = re.compile(r'\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"<re.Match object; span=(3, 8), match='class'>\n"
">>> print(p.search('the declassified algorithm'))\n"
"None\n"
">>> print(p.search('one subclass is'))\n"
"None"

#: ../../howto/regex.rst:764
msgid ""
"There are two subtleties you should remember when using this special "
"sequence. First, this is the worst collision between Python's string "
"literals and regular expression sequences.  In Python's string literals, "
"``\\b`` is the backspace character, ASCII value 8.  If you're not using raw "
"strings, then Python will convert the ``\\b`` to a backspace, and your RE "
"won't match as you expect it to. The following example looks the same as our "
"previous RE, but omits the ``'r'`` in front of the RE string. ::"
msgstr ""
"Há duas sutilezas que você deve lembrar ao usar essa sequência especial. Em "
"primeiro lugar, esta é a pior colisão entre strings literais do Python e "
"sequências de expressão regular. Nas strings literais do Python, ``\\b`` é o "
"caractere backspace, o valor ASCII 8. Se você não estiver usando strings "
"brutas, então Python irá converter o ``\\b`` em um backspace e sua RE não "
"irá funcionar da maneira que você espera. O exemplo a seguir parece igual a "
"nossa RE anterior, mas omite o ``'r'`` na frente da string RE. ::"

#: ../../howto/regex.rst:772
msgid ""
">>> p = re.compile('\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"None\n"
">>> print(p.search('\\b' + 'class' + '\\b'))\n"
"<re.Match object; span=(0, 7), match='\\x08class\\x08'>"
msgstr ""
">>> p = re.compile('\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"None\n"
">>> print(p.search('\\b' + 'class' + '\\b'))\n"
"<re.Match object; span=(0, 7), match='\\x08class\\x08'>"

#: ../../howto/regex.rst:778
msgid ""
"Second, inside a character class, where there's no use for this assertion, "
"``\\b`` represents the backspace character, for compatibility with Python's "
"string literals."
msgstr ""
"Além disso, dentro de uma classe de caracteres, onde não há nenhum uso para "
"esta asserção, ``\\b`` representa o caractere backspace, para "
"compatibilidade com strings literais do Python"

#: ../../howto/regex.rst:782
msgid "``\\B``"
msgstr "``\\B``"

#: ../../howto/regex.rst:783
msgid ""
"Another zero-width assertion, this is the opposite of ``\\b``, only matching "
"when the current position is not at a word boundary."
msgstr ""
"Outra asserção de largura zero; isto é o oposto de ``\\b``, correspondendo "
"apenas quando a posição corrente não é de uma borda de palavra."

#: ../../howto/regex.rst:788
msgid "Grouping"
msgstr "Agrupamento"

#: ../../howto/regex.rst:790
msgid ""
"Frequently you need to obtain more information than just whether the RE "
"matched or not.  Regular expressions are often used to dissect strings by "
"writing a RE divided into several subgroups which match different components "
"of interest. For example, an RFC-822 header line is divided into a header "
"name and a value, separated by a ``':'``, like this:"
msgstr ""
"Frequentemente é necessário obter mais informações do que apenas se a RE "
"teve correspondência ou não. As expressões regulares são muitas vezes "
"utilizadas para dissecar strings escrevendo uma RE dividida em vários "
"subgrupos que correspondem a diferentes componentes de interesse. Por "
"exemplo, uma linha de cabeçalho RFC-822 é dividida em um nome de cabeçalho e "
"um valor, separados por um ``':'``, como essa:"

#: ../../howto/regex.rst:796
msgid ""
"From: author@example.com\n"
"User-Agent: Thunderbird 1.5.0.9 (X11/20061227)\n"
"MIME-Version: 1.0\n"
"To: editor@example.com"
msgstr ""
"From: author@example.com\n"
"User-Agent: Thunderbird 1.5.0.9 (X11/20061227)\n"
"MIME-Version: 1.0\n"
"To: editor@example.com"

#: ../../howto/regex.rst:803
msgid ""
"This can be handled by writing a regular expression which matches an entire "
"header line, and has one group which matches the header name, and another "
"group which matches the header's value."
msgstr ""
"Isto pode ser tratado escrevendo uma expressão regular que corresponde com "
"uma linha inteira de cabeçalho, e tem um grupo que corresponde ao nome do "
"cabeçalho, e um outro grupo, que corresponde ao valor do cabeçalho."

#: ../../howto/regex.rst:807
msgid ""
"Groups are marked by the ``'('``, ``')'`` metacharacters. ``'('`` and "
"``')'`` have much the same meaning as they do in mathematical expressions; "
"they group together the expressions contained inside them, and you can "
"repeat the contents of a group with a quantifier, such as ``*``, ``+``, ``?"
"``, or ``{m,n}``.  For example, ``(ab)*`` will match zero or more "
"repetitions of ``ab``. ::"
msgstr ""
"Os grupos são marcados pelos metacaracteres ``'('`` e ``')'``. ``'('`` e "
"``')'`` têm muito do mesmo significado que eles têm em expressões "
"matemáticas; eles agrupam as expressões contidas dentro deles, e você pode "
"repetir o conteúdo de um grupo com um qualificador de repetição, como ``*``, "
"``+``, ``?``, ou ``{m,n}``. Por exemplo, ``(ab)*`` irá corresponder a zero "
"ou mais repetições de ``ab``."

#: ../../howto/regex.rst:814
msgid ""
">>> p = re.compile('(ab)*')\n"
">>> print(p.match('ababababab').span())\n"
"(0, 10)"
msgstr ""
">>> p = re.compile('(ab)*')\n"
">>> print(p.match('ababababab').span())\n"
"(0, 10)"

#: ../../howto/regex.rst:818
msgid ""
"Groups indicated with ``'('``, ``')'`` also capture the starting and ending "
"index of the text that they match; this can be retrieved by passing an "
"argument to :meth:`~re.Match.group`, :meth:`~re.Match.start`, :meth:`~re."
"Match.end`, and :meth:`~re.Match.span`.  Groups are numbered starting with "
"0.  Group 0 is always present; it's the whole RE, so :ref:`match object "
"<match-objects>` methods all have group 0 as their default argument.  Later "
"we'll see how to express groups that don't capture the span of text that "
"they match. ::"
msgstr ""
"Grupos indicados com ``'('`` e ``')'`` também capturam o índice inicial e "
"final do texto que eles correspondem; isso pode ser obtido por meio da "
"passagem de um argumento para :meth:`~re.Match.group`, :meth:`~re.Match."
"start`, :meth:`~re.Match.end` e :meth:`~re.Match.span`. Os grupos são "
"numerados começando com 0. O grupo 0 está sempre presente; é toda a RE, de "
"forma que os métodos de :ref:`objeto de correspondência <match-objects>` têm "
"todos o grupo 0 como seu argumento padrão. Mais tarde veremos como expressar "
"grupos que não capturam a extensão de texto com a qual eles correspondem. ::"

#: ../../howto/regex.rst:827
msgid ""
">>> p = re.compile('(a)b')\n"
">>> m = p.match('ab')\n"
">>> m.group()\n"
"'ab'\n"
">>> m.group(0)\n"
"'ab'"
msgstr ""
">>> p = re.compile('(a)b')\n"
">>> m = p.match('ab')\n"
">>> m.group()\n"
"'ab'\n"
">>> m.group(0)\n"
"'ab'"

#: ../../howto/regex.rst:834
msgid ""
"Subgroups are numbered from left to right, from 1 upward.  Groups can be "
"nested; to determine the number, just count the opening parenthesis "
"characters, going from left to right. ::"
msgstr ""
"Subgrupos são numerados a partir da esquerda para a direita, de forma "
"crescente a partir de 1. Os grupos podem ser aninhados; para determinar o "
"número, basta contar os caracteres de abertura de parêntese ``(``, indo da "
"esquerda para a direita. ::"

#: ../../howto/regex.rst:838
msgid ""
">>> p = re.compile('(a(b)c)d')\n"
">>> m = p.match('abcd')\n"
">>> m.group(0)\n"
"'abcd'\n"
">>> m.group(1)\n"
"'abc'\n"
">>> m.group(2)\n"
"'b'"
msgstr ""
">>> p = re.compile('(a(b)c)d')\n"
">>> m = p.match('abcd')\n"
">>> m.group(0)\n"
"'abcd'\n"
">>> m.group(1)\n"
"'abc'\n"
">>> m.group(2)\n"
"'b'"

#: ../../howto/regex.rst:847
msgid ""
":meth:`~re.Match.group` can be passed multiple group numbers at a time, in "
"which case it will return a tuple containing the corresponding values for "
"those groups. ::"
msgstr ""
":meth:`~re.Match.group` pode receber vários números de grupos de uma vez, e "
"nesse caso ele irá retornar uma tupla contendo os valores correspondentes "
"desses grupos. ::"

#: ../../howto/regex.rst:850
msgid ""
">>> m.group(2,1,2)\n"
"('b', 'abc', 'b')"
msgstr ""
">>> m.group(2,1,2)\n"
"('b', 'abc', 'b')"

#: ../../howto/regex.rst:853
msgid ""
"The :meth:`~re.Match.groups` method returns a tuple containing the strings "
"for all the subgroups, from 1 up to however many there are. ::"
msgstr ""
"O método :meth:`~re.Match.groups` retorna uma tupla contendo as strings de "
"todos os subgrupos, de 1 até o último. ::"

#: ../../howto/regex.rst:856
msgid ""
">>> m.groups()\n"
"('abc', 'b')"
msgstr ""
">>> m.groups()\n"
"('abc', 'b')"

#: ../../howto/regex.rst:859
msgid ""
"Backreferences in a pattern allow you to specify that the contents of an "
"earlier capturing group must also be found at the current location in the "
"string.  For example, ``\\1`` will succeed if the exact contents of group 1 "
"can be found at the current position, and fails otherwise.  Remember that "
"Python's string literals also use a backslash followed by numbers to allow "
"including arbitrary characters in a string, so be sure to use a raw string "
"when incorporating backreferences in a RE."
msgstr ""
"Referências anteriores em um padrão permitem que você especifique que o "
"conteúdo de um grupo capturado anteriormente também deve ser encontrado na "
"posição atual na sequência. Por exemplo, ``\\1`` terá sucesso se o conteúdo "
"exato do grupo 1 puder ser encontrado na posição atual, e falha caso "
"contrário. Lembre-se que as strings literais do Python também usam a "
"contrabarra seguida por números para permitir a inclusão de caracteres "
"arbitrários em uma string, por isso certifique-se de usar strings brutas ao "
"incorporar referências anteriores em uma RE."

#: ../../howto/regex.rst:867
msgid "For example, the following RE detects doubled words in a string. ::"
msgstr ""
"Por exemplo, a seguinte RE detecta palavras duplicadas em uma string. ::"

#: ../../howto/regex.rst:869
msgid ""
">>> p = re.compile(r'\\b(\\w+)\\s+\\1\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"
msgstr ""
">>> p = re.compile(r'\\b(\\w+)\\s+\\1\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"

#: ../../howto/regex.rst:873
msgid ""
"Backreferences like this aren't often useful for just searching through a "
"string --- there are few text formats which repeat data in this way --- but "
"you'll soon find out that they're *very* useful when performing string "
"substitutions."
msgstr ""
"Referências anteriores como esta não são, geralmente, muito úteis apenas "
"para fazer pesquisa em uma string --- existem alguns formatos de texto que "
"repetem dados dessa forma --- mas em breve você irá descobrir que elas são "
"muito úteis para realizar substituições de strings."

#: ../../howto/regex.rst:879
msgid "Non-capturing and Named Groups"
msgstr "Não captura e grupos nomeados"

#: ../../howto/regex.rst:881
msgid ""
"Elaborate REs may use many groups, both to capture substrings of interest, "
"and to group and structure the RE itself.  In complex REs, it becomes "
"difficult to keep track of the group numbers.  There are two features which "
"help with this problem.  Both of them use a common syntax for regular "
"expression extensions, so we'll look at that first."
msgstr ""
"REs elaboradas podem usar muitos grupos, tanto para capturar substrings de "
"interesse, quanto para agrupar e estruturar a própria RE. Em REs complexas, "
"torna-se difícil manter o controle dos números dos grupos. Existem dois "
"recursos que ajudam a lidar com esse problema. Ambos usam uma sintaxe comum "
"para extensões de expressão regular, então vamos olhar primeiro para isso."

#: ../../howto/regex.rst:887
msgid ""
"Perl 5 is well known for its powerful additions to standard regular "
"expressions. For these new features the Perl developers couldn't choose new "
"single-keystroke metacharacters or new special sequences beginning with "
"``\\`` without making Perl's regular expressions confusingly different from "
"standard REs.  If they chose ``&`` as a new metacharacter, for example, old "
"expressions would be assuming that ``&`` was a regular character and "
"wouldn't have escaped it by writing ``\\&`` or ``[&]``."
msgstr ""
"O Perl 5 é bem conhecido por suas poderosas adições às expressões regulares "
"padrão. Para esses novos recursos, os desenvolvedores do Perl não podiam "
"escolher novos metacaracteres de um único caractere ou novas sequências "
"especiais começando com ``\\`` sem tornar as expressões regulares do Perl "
"confusamente diferentes das REs padrão. Se eles escolhessem ``&`` como um "
"novo metacaractere, por exemplo, as expressões antigas estariam presumindo "
"que ``&`` era um caractere regular e não teriam escapado dele escrevendo "
"``\\&`` ou ``[&]``."

#: ../../howto/regex.rst:894
msgid ""
"The solution chosen by the Perl developers was to use ``(?...)`` as the "
"extension syntax.  ``?`` immediately after a parenthesis was a syntax error "
"because the ``?`` would have nothing to repeat, so this didn't introduce any "
"compatibility problems.  The characters immediately after the ``?``  "
"indicate what extension is being used, so ``(?=foo)`` is one thing (a "
"positive lookahead assertion) and ``(?:foo)`` is something else (a non-"
"capturing group containing the subexpression ``foo``)."
msgstr ""
"A solução escolhida pelos desenvolvedores do Perl foi usar ``(?...)`` como "
"uma sintaxe de extensão. Um ``?`` imediatamente após um parêntese era um "
"erro de sintaxe porque o ``?`` não teria nada a repetir, de modo que isso "
"não introduz quaisquer problemas de compatibilidade. Os caracteres "
"imediatamente após um ``?`` indicam que a extensão está sendo usada, então "
"``(?=foo)`` é uma coisa (uma asserção ``lookahead`` positiva) e ``(?:foo)`` "
"é outra coisa (um grupo de não-captura contendo a subexpressão ``foo``)."

#: ../../howto/regex.rst:902
msgid ""
"Python supports several of Perl's extensions and adds an extension syntax to "
"Perl's extension syntax.  If the first character after the question mark is "
"a ``P``, you know that it's an extension that's specific to Python."
msgstr ""
"Python oferece suporte a diversas extensões do Perl e adiciona uma sintaxe "
"de extensão à sintaxe de extensão do Perl. Se o primeiro caractere após o "
"ponto de interrogação for um ``P``, você sabe que se trata de uma extensão "
"específica do Python."

#: ../../howto/regex.rst:907
msgid ""
"Now that we've looked at the general extension syntax, we can return to the "
"features that simplify working with groups in complex REs."
msgstr ""
"Agora que vimos a sintaxe geral da extensão, podemos retornar aos recursos "
"que simplificam o trabalho com grupos em REs complexas."

#: ../../howto/regex.rst:910
msgid ""
"Sometimes you'll want to use a group to denote a part of a regular "
"expression, but aren't interested in retrieving the group's contents. You "
"can make this fact explicit by using a non-capturing group: ``(?:...)``, "
"where you can replace the ``...`` with any other regular expression. ::"
msgstr ""
"Às vezes você vai querer usar um grupo para representar uma parte de uma "
"expressão regular, mas não está interessado em recuperar o conteúdo do "
"grupo. Você pode tornar isso explícito usando um grupo de não-captura: "
"``(?:...)``, onde você pode substituir o ``...`` por qualquer outra "
"expressão regular. ::"

#: ../../howto/regex.rst:915
msgid ""
">>> m = re.match(\"([abc])+\", \"abc\")\n"
">>> m.groups()\n"
"('c',)\n"
">>> m = re.match(\"(?:[abc])+\", \"abc\")\n"
">>> m.groups()\n"
"()"
msgstr ""
">>> m = re.match(\"([abc])+\", \"abc\")\n"
">>> m.groups()\n"
"('c',)\n"
">>> m = re.match(\"(?:[abc])+\", \"abc\")\n"
">>> m.groups()\n"
"()"

#: ../../howto/regex.rst:922
msgid ""
"Except for the fact that you can't retrieve the contents of what the group "
"matched, a non-capturing group behaves exactly the same as a capturing "
"group; you can put anything inside it, repeat it with a repetition "
"metacharacter such as ``*``, and nest it within other groups (capturing or "
"non-capturing). ``(?:...)`` is particularly useful when modifying an "
"existing pattern, since you can add new groups without changing how all the "
"other groups are numbered.  It should be mentioned that there's no "
"performance difference in searching between capturing and non-capturing "
"groups; neither form is any faster than the other."
msgstr ""
"Exceto pelo fato de que não é possível recuperar o conteúdo sobre o qual o "
"grupo corresponde, um grupo de não-captura se comporta exatamente da mesma "
"forma que um grupo de captura; você pode colocar qualquer coisa dentro dele, "
"repeti-lo com um metacaractere de repetição, como o ``*``, e aninhá-lo "
"dentro de outros grupos (de captura ou não-captura). ``(?:...)`` é "
"particularmente útil para modificar um padrão existente, já que você pode "
"adicionar novos grupos sem alterar a forma como todos os outros grupos estão "
"numerados. Deve ser mencionado que não há diferença de desempenho na busca "
"entre grupos de captura e grupos de não-captura; uma forma não é mais rápida "
"que outra."

#: ../../howto/regex.rst:931
msgid ""
"A more significant feature is named groups: instead of referring to them by "
"numbers, groups can be referenced by a name."
msgstr ""
"Uma característica mais significativa são os grupos nomeados: em vez de se "
"referir a eles por números, os grupos podem ser referenciados por um nome."

#: ../../howto/regex.rst:934
msgid ""
"The syntax for a named group is one of the Python-specific extensions: ``(?"
"P<name>...)``.  *name* is, obviously, the name of the group.  Named groups "
"behave exactly like capturing groups, and additionally associate a name with "
"a group.  The :ref:`match object <match-objects>` methods that deal with "
"capturing groups all accept either integers that refer to the group by "
"number or strings that contain the desired group's name.  Named groups are "
"still given numbers, so you can retrieve information about a group in two "
"ways::"
msgstr ""
"A sintaxe de um grupo nomeado é uma das extensões específicas do Python: ``(?"
"P<name>...)``. *name* é, obviamente, o nome do grupo. Os grupos nomeados se "
"comportam exatamente como os grupos de captura, e, adicionalmente, associam "
"um nome a um grupo. Todos os métodos de :ref:`objeto correspondência <match-"
"objects>` que lidam com grupos de captura aceitam tanto inteiros que se "
"referem ao grupo por número ou strings que contêm o nome do grupo desejado. "
"Os grupos nomeados ainda recebem números, então você pode recuperar "
"informações sobre um grupo de duas maneiras::"

#: ../../howto/regex.rst:942
msgid ""
">>> p = re.compile(r'(?P<word>\\b\\w+\\b)')\n"
">>> m = p.search( '(((( Lots of punctuation )))' )\n"
">>> m.group('word')\n"
"'Lots'\n"
">>> m.group(1)\n"
"'Lots'"
msgstr ""
">>> p = re.compile(r'(?P<word>\\b\\w+\\b)')\n"
">>> m = p.search( '(((( Lots of punctuation )))' )\n"
">>> m.group('word')\n"
"'Lots'\n"
">>> m.group(1)\n"
"'Lots'"

#: ../../howto/regex.rst:949
msgid ""
"Additionally, you can retrieve named groups as a dictionary with :meth:`~re."
"Match.groupdict`::"
msgstr ""
"Além disso, você pode recuperar grupos nomeados como um dicionário com :meth:"
"`~re.Match.groupdict`::"

#: ../../howto/regex.rst:952
msgid ""
">>> m = re.match(r'(?P<first>\\w+) (?P<last>\\w+)', 'Jane Doe')\n"
">>> m.groupdict()\n"
"{'first': 'Jane', 'last': 'Doe'}"
msgstr ""
">>> m = re.match(r'(?P<first>\\w+) (?P<last>\\w+)', 'Jane Doe')\n"
">>> m.groupdict()\n"
"{'first': 'Jane', 'last': 'Doe'}"

#: ../../howto/regex.rst:956
msgid ""
"Named groups are handy because they let you use easily remembered names, "
"instead of having to remember numbers.  Here's an example RE from the :mod:"
"`imaplib` module::"
msgstr ""
"Os grupos nomeados são úteis porque eles permitem que você use nomes de "
"fácil lembrança, em vez de ter que lembrar de números. Aqui está um exemplo "
"de RE usando o módulo :mod:`imaplib`::"

#: ../../howto/regex.rst:960
msgid ""
"InternalDate = re.compile(r'INTERNALDATE \"'\n"
"        r'(?P<day>[ 123][0-9])-(?P<mon>[A-Z][a-z][a-z])-'\n"
"        r'(?P<year>[0-9][0-9][0-9][0-9])'\n"
"        r' (?P<hour>[0-9][0-9]):(?P<min>[0-9][0-9]):(?P<sec>[0-9][0-9])'\n"
"        r' (?P<zonen>[-+])(?P<zoneh>[0-9][0-9])(?P<zonem>[0-9][0-9])'\n"
"        r'\"')"
msgstr ""
"InternalDate = re.compile(r'INTERNALDATE \"'\n"
"        r'(?P<day>[ 123][0-9])-(?P<mon>[A-Z][a-z][a-z])-'\n"
"        r'(?P<year>[0-9][0-9][0-9][0-9])'\n"
"        r' (?P<hour>[0-9][0-9]):(?P<min>[0-9][0-9]):(?P<sec>[0-9][0-9])'\n"
"        r' (?P<zonen>[-+])(?P<zoneh>[0-9][0-9])(?P<zonem>[0-9][0-9])'\n"
"        r'\"')"

#: ../../howto/regex.rst:967
msgid ""
"It's obviously much easier to retrieve ``m.group('zonem')``, instead of "
"having to remember to retrieve group 9."
msgstr ""
"É obviamente muito mais fácil fazer referência a ``m.group('zonem')``, do "
"que ter que se lembrar de capturar o grupo 9."

#: ../../howto/regex.rst:970
msgid ""
"The syntax for backreferences in an expression such as ``(...)\\1`` refers "
"to the number of the group.  There's naturally a variant that uses the group "
"name instead of the number. This is another Python extension: ``(?P=name)`` "
"indicates that the contents of the group called *name* should again be "
"matched at the current point.  The regular expression for finding doubled "
"words, ``\\b(\\w+)\\s+\\1\\b`` can also be written as ``\\b(?"
"P<word>\\w+)\\s+(?P=word)\\b``::"
msgstr ""
"A sintaxe para referências anteriores em uma expressão, tal como "
"``(...)\\1``, faz referência ao número do grupo. Existe, naturalmente, uma "
"variante que usa o nome do grupo em vez do número. Isto é outra extensão "
"Python: ``(?P=name)`` indica que o conteúdo do grupo chamado *name* deve, "
"novamente, ser correspondido no ponto atual. A expressão regular para "
"encontrar palavras duplicadas, ``(\\b\\w+)\\s+\\1``, também pode ser escrita "
"como ``(?P<word>\\b\\w+)\\s+(?P=word)``::"

#: ../../howto/regex.rst:977
msgid ""
">>> p = re.compile(r'\\b(?P<word>\\w+)\\s+(?P=word)\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"
msgstr ""
">>> p = re.compile(r'\\b(?P<word>\\w+)\\s+(?P=word)\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"

#: ../../howto/regex.rst:983
msgid "Lookahead Assertions"
msgstr "Asserções lookahead"

#: ../../howto/regex.rst:985
msgid ""
"Another zero-width assertion is the lookahead assertion.  Lookahead "
"assertions are available in both positive and negative form, and  look like "
"this:"
msgstr ""
"Outra asserção de \"largura zero\" é a asserção lookahead. Asserções "
"lookahead estão disponíveis tanto na forma positiva quanto na negativa, e se "
"parece com isto:"

#: ../../howto/regex.rst:988
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../howto/regex.rst:989
msgid ""
"Positive lookahead assertion.  This succeeds if the contained regular "
"expression, represented here by ``...``, successfully matches at the current "
"location, and fails otherwise. But, once the contained expression has been "
"tried, the matching engine doesn't advance at all; the rest of the pattern "
"is tried right where the assertion started."
msgstr ""
"Asserção lookahead positiva. É bem-sucedida se a expressão regular "
"informada, aqui representada por ``...``, corresponde com o conteúdo da "
"localização atual, e falha caso contrário. Mas, uma vez que a expressão "
"informada tenha sido testada, o mecanismo de correspondência não faz "
"qualquer avanço; o resto do padrão é tentado no mesmo local de onde a "
"asserção foi iniciada."

#: ../../howto/regex.rst:995
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../howto/regex.rst:996
msgid ""
"Negative lookahead assertion.  This is the opposite of the positive "
"assertion; it succeeds if the contained expression *doesn't* match at the "
"current position in the string."
msgstr ""
"Asserção lookahead negativa. É o oposto da asserção positiva; será bem-"
"sucedida se a expressão informada não corresponder com o conteúdo da posição "
"atual na string."

#: ../../howto/regex.rst:1000
msgid ""
"To make this concrete, let's look at a case where a lookahead is useful. "
"Consider a simple pattern to match a filename and split it apart into a base "
"name and an extension, separated by a ``.``.  For example, in ``news.rc``, "
"``news`` is the base name, and ``rc`` is the filename's extension."
msgstr ""
"Para tornar isto concreto, vamos olhar para um caso em que uma lookahead é "
"útil. Considere um padrão simples para corresponder com um nome de arquivo e "
"dividi-lo em pedaços, um nome base e uma extensão, separados por um ``.``. "
"Por exemplo, em ``news.rc``, ``news`` é o nome base, e ``rc`` é a extensão "
"do nome de arquivo."

#: ../../howto/regex.rst:1005
msgid "The pattern to match this is quite simple:"
msgstr "O padrão para corresponder com isso é muito simples:"

#: ../../howto/regex.rst:1007
msgid "``.*[.].*$``"
msgstr "``.*[.].*$``"

#: ../../howto/regex.rst:1009
msgid ""
"Notice that the ``.`` needs to be treated specially because it's a "
"metacharacter, so it's inside a character class to only match that specific "
"character.  Also notice the trailing ``$``; this is added to ensure that all "
"the rest of the string must be included in the extension.  This regular "
"expression matches ``foo.bar`` and ``autoexec.bat`` and ``sendmail.cf`` and "
"``printers.conf``."
msgstr ""
"Observe que o ``.`` precisa ser tratado de forma especial, pois é um "
"metacaractere e, portanto, está dentro de uma classe de caracteres para "
"corresponder apenas a esse caractere específico. Observe também o ``$`` ao "
"final; ele é adicionado para garantir que todo o restante da string seja "
"incluído na extensão. Esta expressão regular corresponde a ``foo.bar``, "
"``autoexec.bat``, ``sendmail.cf`` e ``printers.conf``."

#: ../../howto/regex.rst:1016
msgid ""
"Now, consider complicating the problem a bit; what if you want to match "
"filenames where the extension is not ``bat``? Some incorrect attempts:"
msgstr ""
"Agora, considere complicar um pouco o problema; e se você desejar "
"corresponder com nomes de arquivos onde a extensão não é ``bat``? Algumas "
"tentativas incorretas:"

#: ../../howto/regex.rst:1019
msgid ""
"``.*[.][^b].*$``  The first attempt above tries to exclude ``bat`` by "
"requiring that the first character of the extension is not a ``b``.  This is "
"wrong, because the pattern also doesn't match ``foo.bar``."
msgstr ""
"``.*[.][^b].*$`` A primeira tentativa acima tenta excluir ``bat``, exigindo "
"que o primeiro caractere da extensão não seja um ``b``. Isso é errado, "
"porque o padrão também não corresponde a ``foo.bar``."

#: ../../howto/regex.rst:1023
msgid "``.*[.]([^b]..|.[^a].|..[^t])$``"
msgstr "``.*[.]([^b]..|.[^a].|..[^t])$``"

#: ../../howto/regex.rst:1025
msgid ""
"The expression gets messier when you try to patch up the first solution by "
"requiring one of the following cases to match: the first character of the "
"extension isn't ``b``; the second character isn't ``a``; or the third "
"character isn't ``t``.  This accepts ``foo.bar`` and rejects ``autoexec."
"bat``, but it requires a three-letter extension and won't accept a filename "
"with a two-letter extension such as ``sendmail.cf``.  We'll complicate the "
"pattern again in an effort to fix it."
msgstr ""
"A expressão fica mais confusa se você tentar remendar a primeira solução, "
"exigindo que uma das seguintes situações corresponda: o primeiro caractere "
"da extensão não é ``b``; o segundo caractere não é ``a``; ou o terceiro "
"caractere não é ``t``. Isso aceita ``foo.bar`` e rejeita ``autoexec.bat``, "
"mas requer uma extensão de três letras e não aceitará um nome de arquivo com "
"uma extensão de duas letras, tal como ``sendmail.cf``. Nós iremos complicar "
"o padrão novamente em um esforço para corrigi-lo."

#: ../../howto/regex.rst:1033
msgid "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"
msgstr "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"

#: ../../howto/regex.rst:1035
msgid ""
"In the third attempt, the second and third letters are all made optional in "
"order to allow matching extensions shorter than three characters, such as "
"``sendmail.cf``."
msgstr ""
"Na terceira tentativa, a segunda e terceira letras são todas consideradas "
"opcionais, a fim de permitir correspondência com as extensões mais curtas do "
"que três caracteres, tais como ``sendmail.cf``."

#: ../../howto/regex.rst:1039
msgid ""
"The pattern's getting really complicated now, which makes it hard to read "
"and understand.  Worse, if the problem changes and you want to exclude both "
"``bat`` and ``exe`` as extensions, the pattern would get even more "
"complicated and confusing."
msgstr ""
"Agora, o padrão está ficando realmente muito complicado, o que faz com que "
"seja difícil de ler e compreender. Pior ainda, se o problema mudar e você "
"quiser excluir tanto ``bat`` quanto ``exe`` como extensões, o padrão iria "
"ficar ainda mais complicado e confuso."

#: ../../howto/regex.rst:1044
msgid "A negative lookahead cuts through all this confusion:"
msgstr "Uma lookahead negativo elimina toda esta confusão:"

#: ../../howto/regex.rst:1046
msgid ""
"``.*[.](?!bat$)[^.]*$``  The negative lookahead means: if the expression "
"``bat`` doesn't match at this point, try the rest of the pattern; if "
"``bat$`` does match, the whole pattern will fail.  The trailing ``$`` is "
"required to ensure that something like ``sample.batch``, where the extension "
"only starts with ``bat``, will be allowed.  The ``[^.]*`` makes sure that "
"the pattern works when there are multiple dots in the filename."
msgstr ""
"``.*[.](?!bat$)[^.]*$`` A lookahead negativa significa: se a expressão "
"``bat`` não corresponder até este momento, tente o resto do padrão; se "
"``bat$`` tem correspondência, todo o padrão irá falhar. O final ``$`` é "
"necessário para garantir que algo como ``sample.batch``, onde a extensão só "
"começa com o ``bat``, será permitido."

#: ../../howto/regex.rst:1053
msgid ""
"Excluding another filename extension is now easy; simply add it as an "
"alternative inside the assertion.  The following pattern excludes filenames "
"that end in either ``bat`` or ``exe``:"
msgstr ""
"Excluir uma outra extensão de nome de arquivo agora é fácil; basta fazer a "
"adição de uma alternativa dentro da asserção. O padrão a seguir exclui os "
"nomes de arquivos que terminam com ``bat`` ou ``exe``:"

#: ../../howto/regex.rst:1057
msgid "``.*[.](?!bat$|exe$)[^.]*$``"
msgstr "``.*[.](?!bat$|exe$)[^.]*$``"

#: ../../howto/regex.rst:1061
msgid "Modifying Strings"
msgstr "Modificando strings"

#: ../../howto/regex.rst:1063
msgid ""
"Up to this point, we've simply performed searches against a static string. "
"Regular expressions are also commonly used to modify strings in various "
"ways, using the following pattern methods:"
msgstr ""
"Até este ponto, nós simplesmente realizamos pesquisas em uma string "
"estática. As expressões regulares também são comumente usadas para modificar "
"strings através de várias maneiras, usando os seguintes métodos padrão:"

#: ../../howto/regex.rst:1070
msgid "``split()``"
msgstr "``split()``"

#: ../../howto/regex.rst:1070
msgid "Split the string into a list, splitting it wherever the RE matches"
msgstr ""
"Divide a string em uma lista, dividindo-a onde quer que haja correspondência "
"com a RE"

#: ../../howto/regex.rst:1073
msgid "``sub()``"
msgstr "``sub()``"

#: ../../howto/regex.rst:1073
msgid ""
"Find all substrings where the RE matches, and replace them with a different "
"string"
msgstr ""
"Encontra todas as substrings que correspondem com a RE e faz a substituição "
"por uma string diferente"

#: ../../howto/regex.rst:1076
msgid "``subn()``"
msgstr "``subn()``"

#: ../../howto/regex.rst:1076
msgid ""
"Does the same thing as :meth:`!sub`,  but returns the new string and the "
"number of replacements"
msgstr ""
"Faz a mesma coisa que :meth:`!sub`, mas retorna a nova string e o número de "
"substituições"

#: ../../howto/regex.rst:1083
msgid "Splitting Strings"
msgstr "Dividindo as strings"

#: ../../howto/regex.rst:1085
msgid ""
"The :meth:`~re.Pattern.split` method of a pattern splits a string apart "
"wherever the RE matches, returning a list of the pieces. It's similar to "
"the :meth:`~str.split` method of strings but provides much more generality "
"in the delimiters that you can split by; string :meth:`!split` only supports "
"splitting by whitespace or by a fixed string.  As you'd expect, there's a "
"module-level :func:`re.split` function, too."
msgstr ""
"O método :meth:`~re.Pattern.split` de um padrão divide uma string em pedaços "
"onde quer que a RE corresponda, retornando uma lista formada por esses "
"pedaços. É semelhante ao método :meth:`~str.split` de strings, mas oferece "
"muito mais generalidade nos delimitadores que pode usar para fazer a "
"divisão; :meth:`!split` só implementa a divisão por espaço em branco ou por "
"uma string fixa. Como você deve deduzir, existe também uma função a nível de "
"módulo :func:`re.split`."

#: ../../howto/regex.rst:1096
msgid ""
"Split *string* by the matches of the regular expression.  If capturing "
"parentheses are used in the RE, then their contents will also be returned as "
"part of the resulting list.  If *maxsplit* is nonzero, at most *maxsplit* "
"splits are performed."
msgstr ""
"Divide *string* usando a correspondência com uma expressão regular. Se os "
"parênteses de captura forem utilizados na RE, então seu conteúdo também será "
"retornado como parte da lista resultante. Se *maxsplit* é diferente de zero, "
"serão feitas no máximo *maxplit* divisões."

#: ../../howto/regex.rst:1101
msgid ""
"You can limit the number of splits made, by passing a value for *maxsplit*. "
"When *maxsplit* is nonzero, at most *maxsplit* splits will be made, and the "
"remainder of the string is returned as the final element of the list.  In "
"the following example, the delimiter is any sequence of non-alphanumeric "
"characters. ::"
msgstr ""
"Você pode limitar o número de divisões feitas, passando um valor para "
"*maxsplit*. Quando *maxsplit* é diferente de zero, serão feita no máximo "
"``maxsplit`` divisões, e o restante da string é retornado como o elemento "
"final da lista. No exemplo a seguir, o delimitador é qualquer sequência de "
"caracteres não alfanuméricos. ::"

#: ../../howto/regex.rst:1107
msgid ""
">>> p = re.compile(r'\\W+')\n"
">>> p.split('This is a test, short and sweet, of split().')\n"
"['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']\n"
">>> p.split('This is a test, short and sweet, of split().', 3)\n"
"['This', 'is', 'a', 'test, short and sweet, of split().']"
msgstr ""
">>> p = re.compile(r'\\W+')\n"
">>> p.split('This is a test, short and sweet, of split().')\n"
"['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']\n"
">>> p.split('This is a test, short and sweet, of split().', 3)\n"
"['This', 'is', 'a', 'test, short and sweet, of split().']"

#: ../../howto/regex.rst:1113
msgid ""
"Sometimes you're not only interested in what the text between delimiters is, "
"but also need to know what the delimiter was.  If capturing parentheses are "
"used in the RE, then their values are also returned as part of the list.  "
"Compare the following calls::"
msgstr ""
"Às vezes, você não está interessado apenas no texto que está entre os "
"delimitadores, mas também precisa saber qual o delimitador foi usado. Se os "
"parênteses de captura são utilizados na RE, então os respectivos valores são "
"também retornados como parte da lista. Compare as seguintes chamadas::"

#: ../../howto/regex.rst:1118
msgid ""
">>> p = re.compile(r'\\W+')\n"
">>> p2 = re.compile(r'(\\W+)')\n"
">>> p.split('This... is a test.')\n"
"['This', 'is', 'a', 'test', '']\n"
">>> p2.split('This... is a test.')\n"
"['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']"
msgstr ""
">>> p = re.compile(r'\\W+')\n"
">>> p2 = re.compile(r'(\\W+)')\n"
">>> p.split('This... is a test.')\n"
"['This', 'is', 'a', 'test', '']\n"
">>> p2.split('This... is a test.')\n"
"['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']"

#: ../../howto/regex.rst:1125
msgid ""
"The module-level function :func:`re.split` adds the RE to be used as the "
"first argument, but is otherwise the same.   ::"
msgstr ""
"A função de nível de módulo :func:`re.split` adiciona a RE a ser utilizada "
"como o primeiro argumento, mas, fora isso, é a mesma. ::"

#: ../../howto/regex.rst:1128
msgid ""
">>> re.split(r'[\\W]+', 'Words, words, words.')\n"
"['Words', 'words', 'words', '']\n"
">>> re.split(r'([\\W]+)', 'Words, words, words.')\n"
"['Words', ', ', 'words', ', ', 'words', '.', '']\n"
">>> re.split(r'[\\W]+', 'Words, words, words.', 1)\n"
"['Words', 'words, words.']"
msgstr ""
">>> re.split(r'[\\W]+', 'Words, words, words.')\n"
"['Words', 'words', 'words', '']\n"
">>> re.split(r'([\\W]+)', 'Words, words, words.')\n"
"['Words', ', ', 'words', ', ', 'words', '.', '']\n"
">>> re.split(r'[\\W]+', 'Words, words, words.', 1)\n"
"['Words', 'words, words.']"

#: ../../howto/regex.rst:1137
msgid "Search and Replace"
msgstr "Busca e substituição"

#: ../../howto/regex.rst:1139
msgid ""
"Another common task is to find all the matches for a pattern, and replace "
"them with a different string.  The :meth:`~re.Pattern.sub` method takes a "
"replacement value, which can be either a string or a function, and the "
"string to be processed."
msgstr ""
"Outra tarefa comum é encontrar todas as combinações para um padrão e "
"substituí-las por uma string diferente. O método :meth:`~re.Pattern.sub` "
"recebe um valor de substituição, que pode ser uma string ou uma função, e a "
"string a ser processada."

#: ../../howto/regex.rst:1146
msgid ""
"Returns the string obtained by replacing the leftmost non-overlapping "
"occurrences of the RE in *string* by the replacement *replacement*.  If the "
"pattern isn't found, *string* is returned unchanged."
msgstr ""
"Retorna a string obtida substituindo as ocorrências mais à esquerda não "
"sobrepostas da RE em ``string`` pelo valor de substituição ``replacement``. "
"Se o padrão não for encontrado, a ``string`` é retornada inalterada."

#: ../../howto/regex.rst:1150
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  The default value "
"of 0 means to replace all occurrences."
msgstr ""
"O argumento opcional *count* é o número máximo de ocorrências do padrão a "
"ser substituído; *count* deve ser um número inteiro não negativo. O valor "
"padrão 0 significa substituir todas as ocorrências."

#: ../../howto/regex.rst:1154
msgid ""
"Here's a simple example of using the :meth:`~re.Pattern.sub` method.  It "
"replaces colour names with the word ``colour``::"
msgstr ""
"Aqui está um exemplo simples do uso do método :meth:`~re.Pattern.sub`. Ele "
"substitui nomes de cores pela palavra ``colour``::"

#: ../../howto/regex.rst:1157
msgid ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.sub('colour', 'blue socks and red shoes')\n"
"'colour socks and colour shoes'\n"
">>> p.sub('colour', 'blue socks and red shoes', count=1)\n"
"'colour socks and red shoes'"
msgstr ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.sub('colour', 'blue socks and red shoes')\n"
"'colour socks and colour shoes'\n"
">>> p.sub('colour', 'blue socks and red shoes', count=1)\n"
"'colour socks and red shoes'"

#: ../../howto/regex.rst:1163
msgid ""
"The :meth:`~re.Pattern.subn` method does the same work, but returns a 2-"
"tuple containing the new string value and the number of replacements  that "
"were performed::"
msgstr ""
"O método :meth:`~re.Pattern.subn` faz o mesmo trabalho, mas retorna uma "
"tupla com duas informações: uma string com novo valor e o número de "
"substituições que foram realizadas:"

#: ../../howto/regex.rst:1166
msgid ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.subn('colour', 'blue socks and red shoes')\n"
"('colour socks and colour shoes', 2)\n"
">>> p.subn('colour', 'no colours at all')\n"
"('no colours at all', 0)"
msgstr ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.subn('colour', 'blue socks and red shoes')\n"
"('colour socks and colour shoes', 2)\n"
">>> p.subn('colour', 'no colours at all')\n"
"('no colours at all', 0)"

#: ../../howto/regex.rst:1172
msgid ""
"Empty matches are replaced only when they're not adjacent to a previous "
"empty match. ::"
msgstr ""
"Correspondências vazias somente são substituídas quando não estão adjacente "
"(próxima) a uma correspondência vazia anterior."

#: ../../howto/regex.rst:1175
msgid ""
">>> p = re.compile('x*')\n"
">>> p.sub('-', 'abxd')\n"
"'-a-b--d-'"
msgstr ""
">>> p = re.compile('x*')\n"
">>> p.sub('-', 'abxd')\n"
"'-a-b--d-'"

#: ../../howto/regex.rst:1179
msgid ""
"If *replacement* is a string, any backslash escapes in it are processed.  "
"That is, ``\\n`` is converted to a single newline character, ``\\r`` is "
"converted to a carriage return, and so forth. Unknown escapes such as "
"``\\&`` are left alone. Backreferences, such as ``\\6``, are replaced with "
"the substring matched by the corresponding group in the RE.  This lets you "
"incorporate portions of the original text in the resulting replacement "
"string."
msgstr ""
"Se o valor de substituição (*replacement*) é uma string, qualquer barra "
"invertida é interpretada e processada. Isto é, ``\\n`` é convertido a um "
"único caractere de nova linha, ``\\r`` é convertido em um retorno do carro, "
"e assim por diante. Casos desconhecidos, como ``\\&`` são ignorados. "
"Referências anteriores, como ``\\6``, são substituídas com a substring "
"correspondida pelo grupo correspondente na RE. Isso permite que você "
"incorpore partes do texto original na string de substituição resultante."

#: ../../howto/regex.rst:1186
msgid ""
"This example matches the word ``section`` followed by a string enclosed in "
"``{``, ``}``, and changes ``section`` to ``subsection``::"
msgstr ""
"Este exemplo corresponde com a palavra ``section``, seguida por uma string "
"colocada entre ``{``, ``}``, e altera ``section`` para ``subsection``::"

#: ../../howto/regex.rst:1189
msgid ""
">>> p = re.compile('section{ ( [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First} section{second}')\n"
"'subsection{First} subsection{second}'"
msgstr ""
">>> p = re.compile('section{ ( [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First} section{second}')\n"
"'subsection{First} subsection{second}'"

#: ../../howto/regex.rst:1193
msgid ""
"There's also a syntax for referring to named groups as defined by the ``(?"
"P<name>...)`` syntax.  ``\\g<name>`` will use the substring matched by the "
"group named ``name``, and  ``\\g<number>``  uses the corresponding group "
"number. ``\\g<2>`` is therefore equivalent to ``\\2``,  but isn't ambiguous "
"in a replacement string such as ``\\g<2>0``.  (``\\20`` would be interpreted "
"as a reference to group 20, not a reference to group 2 followed by the "
"literal character ``'0'``.)  The following substitutions are all equivalent, "
"but use all three variations of the replacement string. ::"
msgstr ""
"Há também uma sintaxe para se referir a grupos nomeados como definido pela "
"sintaxe ``(?P<name>...)``. ``\\g<name>`` usará a substring correspondida "
"pelo grupo com nome ``name`` e ``\\g<number>`` utiliza o número do grupo "
"correspondente. ``\\g<2>`` é, portanto, equivalente a ``\\2``, mas não é "
"ambígua em uma string de substituição, tal como ``\\g<2>0``. (``\\20`` seria "
"interpretado como uma referência ao grupo de 20, e não uma referência ao "
"grupo 2 seguido pelo caractere literal ``'0'``). As substituições a seguir "
"são todas equivalentes, mas usam todas as três variações da string de "
"substituição. ::"

#: ../../howto/regex.rst:1202
msgid ""
">>> p = re.compile('section{ (?P<name> [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<1>}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<name>}','section{First}')\n"
"'subsection{First}'"
msgstr ""
">>> p = re.compile('section{ (?P<name> [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<1>}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<name>}','section{First}')\n"
"'subsection{First}'"

#: ../../howto/regex.rst:1210
msgid ""
"*replacement* can also be a function, which gives you even more control.  If "
"*replacement* is a function, the function is called for every non-"
"overlapping occurrence of *pattern*.  On each call, the function is passed "
"a :ref:`match object <match-objects>` argument for the match and can use "
"this information to compute the desired replacement string and return it."
msgstr ""
"*replacement* também pode ser uma função, que lhe dá ainda mais controle. Se "
"*replacement* for uma função, a função será chamada para todas as "
"ocorrências não sobrepostas de *pattern*. Em cada chamada, a função recebe "
"um argumento de :ref:`objeto Match <match-objects>` para a correspondência e "
"pode usar essas informações para calcular a string de substituição desejada "
"e retorná-la."

#: ../../howto/regex.rst:1216
msgid ""
"In the following example, the replacement function translates decimals into "
"hexadecimal::"
msgstr ""
"No exemplo a seguir, a função de substituição traduz decimais em "
"hexadecimal::"

#: ../../howto/regex.rst:1219
msgid ""
">>> def hexrepl(match):\n"
"...     \"Return the hex string for a decimal number\"\n"
"...     value = int(match.group())\n"
"...     return hex(value)\n"
"...\n"
">>> p = re.compile(r'\\d+')\n"
">>> p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')\n"
"'Call 0xffd2 for printing, 0xc000 for user code.'"
msgstr ""
">>> def hexrepl(match):\n"
"...     \"Return the hex string for a decimal number\"\n"
"...     value = int(match.group())\n"
"...     return hex(value)\n"
"...\n"
">>> p = re.compile(r'\\d+')\n"
">>> p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')\n"
"'Call 0xffd2 for printing, 0xc000 for user code.'"

#: ../../howto/regex.rst:1228
msgid ""
"When using the module-level :func:`re.sub` function, the pattern is passed "
"as the first argument.  The pattern may be provided as an object or as a "
"string; if you need to specify regular expression flags, you must either use "
"a pattern object as the first parameter, or use embedded modifiers in the "
"pattern string, e.g. ``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")`` returns ``'x "
"x'``."
msgstr ""
"Ao utilizar a função de nível de módulo :func:`re.sub`, o padrão é passado "
"como o primeiro argumento. O padrão pode ser fornecido como um objeto ou "
"como uma string; se você precisa especificar sinalizadores de expressões "
"regulares, você deve usar um objeto padrão como o primeiro parâmetro, ou "
"usar modificadores embutidos na string padrão, por exemplo, ``sub(\"(?i)b+"
"\", \"x\", \"bbbb BBBB\")`` retorna ``'x x'``."

#: ../../howto/regex.rst:1236
msgid "Common Problems"
msgstr "Problemas comuns"

#: ../../howto/regex.rst:1238
msgid ""
"Regular expressions are a powerful tool for some applications, but in some "
"ways their behaviour isn't intuitive and at times they don't behave the way "
"you may expect them to.  This section will point out some of the most common "
"pitfalls."
msgstr ""
"Expressões regulares são uma ferramenta poderosa para algumas aplicações, "
"mas de certa forma o seu comportamento não é intuitivo, e às vezes, as RE "
"não se comportam da maneira que você espera que elas se comportem. Esta "
"seção irá apontar algumas das armadilhas mais comuns."

#: ../../howto/regex.rst:1244
msgid "Use String Methods"
msgstr "Usando métodos de string"

#: ../../howto/regex.rst:1246
msgid ""
"Sometimes using the :mod:`re` module is a mistake.  If you're matching a "
"fixed string, or a single character class, and you're not using any :mod:"
"`re` features such as the :const:`~re.IGNORECASE` flag, then the full power "
"of regular expressions may not be required. Strings have several methods for "
"performing operations with fixed strings and they're usually much faster, "
"because the implementation is a single small C loop that's been optimized "
"for the purpose, instead of the large, more generalized regular expression "
"engine."
msgstr ""
"Às vezes, usar o módulo :mod:`re` é um equívoco. Se você está fazendo "
"correspondência com uma string fixa, ou uma classe de caractere única, e "
"você não está usando nenhum recurso de :mod:`re` como o sinalizador :const:"
"`~re.IGNORECASE`, então pode não ser necessário todo o poder das expressões "
"regulares. Strings possuem vários métodos para executar operações com "
"strings fixas e eles são, geralmente, muito mais rápidos, porque a "
"implementação é um único e pequeno laço de repetição em C que foi otimizado "
"para esse propósito, em vez do grande e mais generalizado mecanismo das "
"expressões regulares."

#: ../../howto/regex.rst:1254
msgid ""
"One example might be replacing a single fixed string with another one; for "
"example, you might replace ``word`` with ``deed``.  :func:`re.sub` seems "
"like the function to use for this, but consider the :meth:`~str.replace` "
"method.  Note that :meth:`!replace` will also replace ``word`` inside words, "
"turning ``swordfish`` into ``sdeedfish``, but the  naive RE ``word`` would "
"have done that, too.  (To avoid performing the substitution on parts of "
"words, the pattern would have to be ``\\bword\\b``, in order to require that "
"``word`` have a word boundary on either side.  This takes the job beyond  :"
"meth:`!replace`'s abilities.)"
msgstr ""
"Um exemplo pode ser a substituição de uma string fixa única por outra; por "
"exemplo, você pode substituir ``word`` por ``deed``. :func:`re.sub` parece "
"ser a função a ser usada para isso, mas considere o método :meth:`~str."
"replace`. Note que :meth:`!replace` também irá substituir ``word`` dentro de "
"palavras, transformando ``swordfish`` em ``sdeedfish``, mas uma RE ingênua "
"teria feito isso também. (Para evitar a realização da substituição de partes "
"de palavras, o padrão teria que ser ``\\bword\\b``, a fim de exigir que "
"``word`` tenha um delimitador de palavra em ambos os lados. Isso leva a "
"tarefa para além da capacidade de :meth:`!replace`.)"

#: ../../howto/regex.rst:1263
msgid ""
"Another common task is deleting every occurrence of a single character from "
"a string or replacing it with another single character.  You might do this "
"with something like ``re.sub('\\n', ' ', S)``, but :meth:`~str.translate` is "
"capable of doing both tasks and will be faster than any regular expression "
"operation can be."
msgstr ""
"Outra tarefa comum é apagar todas as ocorrências de um único caractere de "
"uma string ou substituí-lo por um outro caractere único. Você pode fazer "
"isso com algo como ``re.sub('\\n', ' ', S)``, mas :meth:`~str.translate` é "
"capaz de fazer ambas as tarefas e será mais rápida do que qualquer operação "
"de expressão regular pode ser."

#: ../../howto/regex.rst:1269
msgid ""
"In short, before turning to the :mod:`re` module, consider whether your "
"problem can be solved with a faster and simpler string method."
msgstr ""
"Em suma, antes de recorrer ao o módulo :mod:`re`, considere se o seu "
"problema pode ser resolvido com um método de string mais rápido e mais "
"simples."

#: ../../howto/regex.rst:1274
msgid "match() versus search()"
msgstr "match() versus search()"

#: ../../howto/regex.rst:1276
msgid ""
"The :func:`~re.match` function only checks if the RE matches at the "
"beginning of the string while :func:`~re.search` will scan forward through "
"the string for a match. It's important to keep this distinction in mind.  "
"Remember,  :func:`!match` will only report a successful match which will "
"start at 0; if the match wouldn't start at zero,  :func:`!match` will *not* "
"report it. ::"
msgstr ""
"A função :func:`~re.match` somente verifica se a  RE corresponde ao início "
"da string, enquanto :func:`~re.search` fará a varredura percorrendo a string "
"procurando por uma correspondência. É importante manter esta distinção em "
"mente. Lembre-se, :func:`!match` só irá relatar uma correspondência bem-"
"sucedida que começa em 0; se a correspondência não começar em zero, :func:`!"
"match` *não* vai reportá-la."

#: ../../howto/regex.rst:1282
msgid ""
">>> print(re.match('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.match('super', 'insuperable'))\n"
"None"
msgstr ""
">>> print(re.match('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.match('super', 'insuperable'))\n"
"None"

#: ../../howto/regex.rst:1287
msgid ""
"On the other hand, :func:`~re.search` will scan forward through the string, "
"reporting the first match it finds. ::"
msgstr ""
"Por outro lado, :func:`~re.search` fará a varredura percorrendo a string e "
"relatando a primeira correspondência que encontrar."

#: ../../howto/regex.rst:1290
msgid ""
">>> print(re.search('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.search('super', 'insuperable').span())\n"
"(2, 7)"
msgstr ""
">>> print(re.search('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.search('super', 'insuperable').span())\n"
"(2, 7)"

#: ../../howto/regex.rst:1295
msgid ""
"Sometimes you'll be tempted to keep using :func:`re.match`, and just add ``."
"*`` to the front of your RE.  Resist this temptation and use :func:`re."
"search` instead.  The regular expression compiler does some analysis of REs "
"in order to speed up the process of looking for a match.  One such analysis "
"figures out what the first character of a match must be; for example, a "
"pattern starting with ``Crow`` must match starting with a ``'C'``.  The "
"analysis lets the engine quickly scan through the string looking for the "
"starting character, only trying the full match if a ``'C'`` is found."
msgstr ""
"Às vezes, você vai ficar tentado a continuar usando :func:`re.match`, e "
"apenas adicionar ``.*`` ao início de sua RE. Resista a essa tentação e use :"
"func:`re.search` em vez disso. O compilador de expressão regular faz alguma "
"análise das REs, a fim de acelerar o processo de procura de uma "
"correspondência. Tal análise descobre o que o primeiro caractere de uma "
"string deve ser; por exemplo, um padrão começando com ``Crow`` deve "
"corresponder com algo iniciando com ``'C'``. A análise permite que o "
"mecanismo faça a varredura rapidamente através da string a procura do "
"caractere inicial, apenas tentando a combinação completa se um ``'C'`` for "
"encontrado."

#: ../../howto/regex.rst:1304
msgid ""
"Adding ``.*`` defeats this optimization, requiring scanning to the end of "
"the string and then backtracking to find a match for the rest of the RE.  "
"Use :func:`re.search` instead."
msgstr ""
"Adicionar um ``.*`` evita essa otimização, sendo necessário a varredura até "
"o final da string e, em seguida, retroceder para encontrar uma "
"correspondência para o resto da RE. Use :func:`re.search` em vez disso."

#: ../../howto/regex.rst:1310
msgid "Greedy versus Non-Greedy"
msgstr "Gulosos versus não-gulosos"

#: ../../howto/regex.rst:1312
msgid ""
"When repeating a regular expression, as in ``a*``, the resulting action is "
"to consume as much of the pattern as possible.  This fact often bites you "
"when you're trying to match a pair of balanced delimiters, such as the angle "
"brackets surrounding an HTML tag.  The naive pattern for matching a single "
"HTML tag doesn't work because of the greedy nature of ``.*``. ::"
msgstr ""
"Ao repetir uma expressão regular, como em ``a*``, a ação resultante é "
"consumir o tanto do padrão quanto possível. Este fato, muitas vezes derruba "
"você quando você está tentando corresponder com um par de delimitadores "
"balanceados, tal como os colchetes que cercam uma tag HTML. O padrão ingênuo "
"para combinar uma única tag HTML não funciona por causa da natureza gulosa "
"de ``.*``. ::"

#: ../../howto/regex.rst:1318
msgid ""
">>> s = '<html><head><title>Title</title>'\n"
">>> len(s)\n"
"32\n"
">>> print(re.match('<.*>', s).span())\n"
"(0, 32)\n"
">>> print(re.match('<.*>', s).group())\n"
"<html><head><title>Title</title>"
msgstr ""

#: ../../howto/regex.rst:1326
msgid ""
"The RE matches the ``'<'`` in ``'<html>'``, and the ``.*`` consumes the rest "
"of the string.  There's still more left in the RE, though, and the ``>`` "
"can't match at the end of the string, so the regular expression engine has "
"to backtrack character by character until it finds a match for the ``>``.   "
"The final match extends from the ``'<'`` in ``'<html>'`` to the ``'>'`` in "
"``'</title>'``, which isn't what you want."
msgstr ""
"A RE corresponde a ``'<'`` em ``'<html>'``, e o ``.*`` consome o resto da "
"string. Existe ainda mais coisa existente na RE, no entanto, e o ``>`` pode "
"não corresponder com o final da string, de modo que o mecanismo de expressão "
"regular tem que recuar caractere por caractere até encontrar uma "
"correspondência para a ``>``. A correspondência final se estende do ``'<'`` "
"em ``'<html>'`` ao ``'>'`` em ``'</title>'``, que não é o que você quer."

#: ../../howto/regex.rst:1333
msgid ""
"In this case, the solution is to use the non-greedy quantifiers ``*?``, ``+?"
"``, ``??``, or ``{m,n}?``, which match as *little* text as possible.  In the "
"above example, the ``'>'`` is tried immediately after the first ``'<'`` "
"matches, and when it fails, the engine advances a character at a time, "
"retrying the ``'>'`` at every step.  This produces just the right result::"
msgstr ""
"Neste caso, a solução é usar os quantificadores não-gulosos ``*?``, ``+?``, "
"``??`` ou ``{m,n}?``, que corresponde com o mínimo de texto possível. No "
"exemplo acima, o ``'>'`` é tentado imediatamente após a primeira "
"correspondência de ``'<'``, e quando ele falhar, o mecanismo avança um "
"caractere de cada vez, experimentado ``'>'`` a cada passo. Isso produz "
"justamente o resultado correto::"

#: ../../howto/regex.rst:1339
msgid ""
">>> print(re.match('<.*?>', s).group())\n"
"<html>"
msgstr ""

#: ../../howto/regex.rst:1342
msgid ""
"(Note that parsing HTML or XML with regular expressions is painful. Quick-"
"and-dirty patterns will handle common cases, but HTML and XML have special "
"cases that will break the obvious regular expression; by the time you've "
"written a regular expression that handles all of the possible cases, the "
"patterns will be *very* complicated.  Use an HTML or XML parser module for "
"such tasks.)"
msgstr ""
"(Note que a análise de HTML ou XML com expressões regulares é dolorosa. "
"Padrões \"sujos e rápidos\" irão lidar com casos comuns, mas HTML e XML tem "
"casos especiais que irão quebrar expressões regulares óbvias; com o tempo, "
"expressões regulares que você venha a escrever para lidar com todos os casos "
"possíveis, se tornarão um padrão muito complicado. Use um módulo de análise "
"de HTML ou XML para tais tarefas.)"

#: ../../howto/regex.rst:1350
msgid "Using re.VERBOSE"
msgstr "Usando re.VERBOSE"

#: ../../howto/regex.rst:1352
msgid ""
"By now you've probably noticed that regular expressions are a very compact "
"notation, but they're not terribly readable.  REs of moderate complexity can "
"become lengthy collections of backslashes, parentheses, and metacharacters, "
"making them difficult to read and understand."
msgstr ""
"Nesse momento, você provavelmente deve ter notado que as expressões "
"regulares são de uma notação muito compacta, mas não é possível dizer que "
"são legíveis. REs de complexidade moderada podem se tornar longas coleções "
"de barras invertidas, parênteses e metacaracteres, fazendo com que se tornem "
"difíceis de ler e compreender."

#: ../../howto/regex.rst:1357
msgid ""
"For such REs, specifying the :const:`re.VERBOSE` flag when compiling the "
"regular expression can be helpful, because it allows you to format the "
"regular expression more clearly."
msgstr ""
"Para tais REs, especificar a flag :const:`re.VERBOSE` ao compilar a "
"expressão regular pode ser útil, porque permite que você formate a expressão "
"regular de forma mais clara."

#: ../../howto/regex.rst:1361
msgid ""
"The ``re.VERBOSE`` flag has several effects.  Whitespace in the regular "
"expression that *isn't* inside a character class is ignored.  This means "
"that an expression such as ``dog | cat`` is equivalent to the less readable "
"``dog|cat``, but ``[a b]`` will still match the characters ``'a'``, ``'b'``, "
"or a space.  In addition, you can also put comments inside a RE; comments "
"extend from a ``#`` character to the next newline.  When used with triple-"
"quoted strings, this enables REs to be formatted more neatly::"
msgstr ""
"O sinalizador ``re.VERBOSE`` produz vários efeitos. Espaço em branco na "
"expressão regular que não está dentro de uma classe de caracteres é "
"ignorado. Isto significa que uma expressão como ``dog | cat`` é equivalente "
"ao menos legível ``dog|cat``, mas ``[a b]`` ainda vai coincidir com os "
"caracteres ``a``, ``b``, ou um ``espaço``. Além disso, você também pode "
"colocar comentários dentro de uma RE; comentários se estendem de um "
"caractere ``#`` até a próxima nova linha. Quando usados junto com strings de "
"aspas triplas, isso permite as REs serem formatadas mais ordenadamente::"

#: ../../howto/regex.rst:1369
msgid ""
"pat = re.compile(r\"\"\"\n"
" \\s*                 # Skip leading whitespace\n"
" (?P<header>[^:]+)   # Header name\n"
" \\s* :               # Whitespace, and a colon\n"
" (?P<value>.*?)      # The header's value -- *? used to\n"
"                     # lose the following trailing whitespace\n"
" \\s*$                # Trailing whitespace to end-of-line\n"
"\"\"\", re.VERBOSE)"
msgstr ""

#: ../../howto/regex.rst:1378
msgid "This is far more readable than::"
msgstr "Isso é muito mais legível do que::"

#: ../../howto/regex.rst:1380
msgid "pat = re.compile(r\"\\s*(?P<header>[^:]+)\\s*:(?P<value>.*?)\\s*$\")"
msgstr ""

#: ../../howto/regex.rst:1384
msgid "Feedback"
msgstr "Comentários"

#: ../../howto/regex.rst:1386
msgid ""
"Regular expressions are a complicated topic.  Did this document help you "
"understand them?  Were there parts that were unclear, or Problems you "
"encountered that weren't covered here?  If so, please send suggestions for "
"improvements to the author."
msgstr ""
"Expressões regulares são um tópico complicado. Esse documento ajudou você a "
"compreendê-las? Existem partes que foram pouco claras, ou situações que você "
"vivenciou que não foram abordadas aqui? Se assim for, por favor, envie "
"sugestões de melhorias para o autor."

#: ../../howto/regex.rst:1391
msgid ""
"The most complete book on regular expressions is almost certainly Jeffrey "
"Friedl's Mastering Regular Expressions, published by O'Reilly.  "
"Unfortunately, it exclusively concentrates on Perl and Java's flavours of "
"regular expressions, and doesn't contain any Python material at all, so it "
"won't be useful as a reference for programming in Python.  (The first "
"edition covered Python's now-removed :mod:`!regex` module, which won't help "
"you much.)  Consider checking it out from your library."
msgstr ""
"O livro mais completo sobre expressões regulares é quase certamente o "
"Mastering Regular Expressions de Jeffrey Friedl’s, publicado pela O'Reilly. "
"Infelizmente, ele se concentra exclusivamente em sabores de expressões "
"regulares do Perl e do Java, e não contém qualquer material relativo a "
"Python, por isso não vai ser útil como uma referência para a programação em "
"Python. (A primeira edição cobre o módulo :mod:`!regex` agora removido do "
"Python, o que não vai te ajudar muito.) Considere removê-lo de sua "
"biblioteca."

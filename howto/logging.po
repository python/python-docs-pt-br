# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 15:45+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../howto/logging.rst:5
msgid "Logging HOWTO"
msgstr "Logging"

#: ../../howto/logging.rst:0
msgid "Author"
msgstr "Autor"

#: ../../howto/logging.rst:7
msgid "Vinay Sajip <vinay_sajip at red-dove dot com>"
msgstr "Vinay Sajip <vinay_sajip at red-dove dot com>"

#: ../../howto/logging.rst:13
msgid ""
"This page contains tutorial information. For links to reference information "
"and a logging cookbook, please see :ref:`tutorial-ref-links`."
msgstr ""
"Essa página contém informações relativas a tutoriais. Para links de "
"informações de referência e logging cookbook, por favor veja :ref:`tutorial-"
"ref-links`."

#: ../../howto/logging.rst:17
msgid "Basic Logging Tutorial"
msgstr "Tutorial Básico de Logging"

#: ../../howto/logging.rst:19
msgid ""
"Logging is a means of tracking events that happen when some software runs. "
"The software's developer adds logging calls to their code to indicate that "
"certain events have occurred. An event is described by a descriptive message "
"which can optionally contain variable data (i.e. data that is potentially "
"different for each occurrence of the event). Events also have an importance "
"which the developer ascribes to the event; the importance can also be called "
"the *level* or *severity*."
msgstr ""
"Logging é uma maneira de rastrear eventos que acontecem quando algum "
"software executa. O desenvolvedor de software adiciona chamadas de logging "
"no código para indicar que determinado evento ocorreu. Um evento é descrito "
"por uma mensagem descritiva que pode opcionalmente conter o dado de uma "
"variável (ex.: dado que é potencialmente diferente pra cada ocorrência do "
"evento). Eventos também tem um peso que o desenvolvedor atribui para o "
"evento; o peso pode também ser chamada de *níveis* ou *severidade*."

#: ../../howto/logging.rst:28
msgid "When to use logging"
msgstr "Quando usar logging"

#: ../../howto/logging.rst:30
msgid ""
"You can access logging functionality by creating a logger via ``logger = "
"getLogger(__name__)``, and then calling the logger's :meth:`~Logger.debug`, :"
"meth:`~Logger.info`, :meth:`~Logger.warning`, :meth:`~Logger.error` and :"
"meth:`~Logger.critical` methods. To determine when to use logging, and to "
"see which logger methods to use when, see the table below. It states, for "
"each of a set of common tasks, the best tool to use for that task."
msgstr ""
"Você pode acessar a funcionalidade de logs criando um logger via ``logger = "
"getLogger(__name__)`` e, em seguida, chamar os métodos :meth:`~Logger."
"debug`, :meth:`~Logger.info`, :meth:`~Logger.warning`, :meth:`~Logger.error` "
"e :meth:`~Logger.critical`. Para determinar quando usar logging e ver quais "
"métodos de logger utilizar e quando, consulte a tabela abaixo. Ele indica, "
"para cada conjunto de tarefas comuns, a melhor ferramenta a ser usada para "
"essa tarefa."

#: ../../howto/logging.rst:38
msgid "Task you want to perform"
msgstr "Tarefa que você quer performar"

#: ../../howto/logging.rst:38
msgid "The best tool for the task"
msgstr "A melhor ferramenta para a tarefa"

#: ../../howto/logging.rst:40
msgid ""
"Display console output for ordinary usage of a command line script or program"
msgstr ""
"Exibir saída do console para uso ordinário de um script de linha de comando "
"ou programa."

#: ../../howto/logging.rst:40
msgid ":func:`print`"
msgstr ":func:`print`"

#: ../../howto/logging.rst:44
msgid ""
"Report events that occur during normal operation of a program (e.g. for "
"status monitoring or fault investigation)"
msgstr ""
"Relata eventos que podem ocorrer durante a operação normal de um programa "
"(ex: para monitoramento do status ou investigação de falha)"

#: ../../howto/logging.rst:44
msgid ""
"A logger's :meth:`~Logger.info` (or :meth:`~Logger.debug` method for very "
"detailed output for diagnostic purposes)"
msgstr ""
"O método :meth:`~Logger.info` de um logger (ou :meth:`~Logger.debug` para "
"saída muito detalhada para fins de diagnóstico)"

#: ../../howto/logging.rst:49
msgid "Issue a warning regarding a particular runtime event"
msgstr "Emite um aviso sobre um evento de tempo de execução específico"

#: ../../howto/logging.rst:49
msgid ""
":func:`warnings.warn` in library code if the issue is avoidable and the "
"client application should be modified to eliminate the warning"
msgstr ""
":func:`warnings.warn` na biblioteca de código se o problema é evitável e a "
"aplicação cliente deve ser modificada para eliminar o alerta."

#: ../../howto/logging.rst:54
msgid ""
"A logger's :meth:`~Logger.warning` method if there is nothing the client "
"application can do about the situation, but the event should still be noted"
msgstr ""
"O método :meth:`~Logger.warning` de um logger se não houver nada que a "
"aplicação cliente possa fazer sobre a situação, mas o evento ainda deve ser "
"registrado"

#: ../../howto/logging.rst:60
msgid "Report an error regarding a particular runtime event"
msgstr "Relata um erro sobre um evento de tempo de execução específico"

#: ../../howto/logging.rst:60
msgid "Raise an exception"
msgstr "Levantando uma exceção"

#: ../../howto/logging.rst:63
msgid ""
"Report suppression of an error without raising an exception (e.g. error "
"handler in a long-running server process)"
msgstr ""
"Relatar supressão de um erro sem levantar uma exceção (ex: manipulador de "
"erros em um processo de servidor em longa execução)"

#: ../../howto/logging.rst:63
msgid ""
"A logger's :meth:`~Logger.error`, :meth:`~Logger.exception` or :meth:"
"`~Logger.critical` method as appropriate for the specific error and "
"application domain"
msgstr ""
"Um método :meth:`~Logger.error`, :meth:`~Logger.exception` ou :meth:`~Logger."
"critical` do logger, conforme apropriado para o erro específico e domínio da "
"aplicação"

#: ../../howto/logging.rst:70
msgid ""
"The logger methods are named after the level or severity of the events they "
"are used to track. The standard levels and their applicability are described "
"below (in increasing order of severity):"
msgstr ""
"Os métodos de logger são nomeados de acordo com o nível ou severidade dos "
"eventos que eles são usados para rastrear. Os níveis padrão e sua "
"aplicabilidade são descritos abaixo (em ordem crescente de severidade):"

#: ../../howto/logging.rst:77 ../../howto/logging.rst:876
msgid "Level"
msgstr "Nível"

#: ../../howto/logging.rst:77
msgid "When it's used"
msgstr "Quando é usado"

#: ../../howto/logging.rst:79 ../../howto/logging.rst:886
msgid "``DEBUG``"
msgstr "``DEBUG``"

#: ../../howto/logging.rst:79
msgid ""
"Detailed information, typically of interest only when diagnosing problems."
msgstr ""
"Informação detalhada, tipicamente de interesse apenas quando diagnosticando "
"problemas."

#: ../../howto/logging.rst:82 ../../howto/logging.rst:884
msgid "``INFO``"
msgstr "``INFO``"

#: ../../howto/logging.rst:82
msgid "Confirmation that things are working as expected."
msgstr "Confirmação de que as coisas estão funcionando como esperado."

#: ../../howto/logging.rst:85 ../../howto/logging.rst:882
msgid "``WARNING``"
msgstr "``WARNING``"

#: ../../howto/logging.rst:85
msgid ""
"An indication that something unexpected happened, or indicative of some "
"problem in the near future (e.g. 'disk space low'). The software is still "
"working as expected."
msgstr ""
"Uma indicação que algo inesperado aconteceu, ou um indicativo que algum "
"problema em um futuro próximo (ex.: 'pouco espaço em disco'). O software "
"está ainda funcionando como esperado."

#: ../../howto/logging.rst:90 ../../howto/logging.rst:880
msgid "``ERROR``"
msgstr "``ERROR``"

#: ../../howto/logging.rst:90
msgid ""
"Due to a more serious problem, the software has not been able to perform "
"some function."
msgstr ""
"Por conta de um problema mais grave, o software não conseguiu executar "
"alguma função."

#: ../../howto/logging.rst:93 ../../howto/logging.rst:878
msgid "``CRITICAL``"
msgstr "``CRITICAL``"

#: ../../howto/logging.rst:93
msgid ""
"A serious error, indicating that the program itself may be unable to "
"continue running."
msgstr ""
"Um erro grave, indicando que o programa pode não conseguir continuar rodando."

#: ../../howto/logging.rst:97
msgid ""
"The default level is ``WARNING``, which means that only events of this level "
"and above will be tracked, unless the logging package is configured to do "
"otherwise."
msgstr ""
"O nível padrão é ``WARNING``, que significa que só eventos deste nível e "
"acima serão rastreados, a não ser que o pacote logging esteja configurado "
"para fazer de outra forma."

#: ../../howto/logging.rst:101
msgid ""
"Events that are tracked can be handled in different ways. The simplest way "
"of handling tracked events is to print them to the console. Another common "
"way is to write them to a disk file."
msgstr ""
"Eventos que são rastreados podem ser tratados de diferentes formas. O jeito "
"mais simples de lidar com eventos rastreados é exibi-los no console. Outra "
"maneira comum é gravá-los em um arquivo de disco."

#: ../../howto/logging.rst:109
msgid "A simple example"
msgstr "Um exemplo simples"

#: ../../howto/logging.rst:111
msgid "A very simple example is::"
msgstr "Um exemplo bastante simples é::"

#: ../../howto/logging.rst:113
msgid ""
"import logging\n"
"logging.warning('Watch out!')  # will print a message to the console\n"
"logging.info('I told you so')  # will not print anything"
msgstr ""
"import logging\n"
"logging.warning('Watch out!')  # imprimirá uma mensagem no console\n"
"logging.info('I told you so')  # não imprimirá nada"

#: ../../howto/logging.rst:117
msgid "If you type these lines into a script and run it, you'll see:"
msgstr "Se você digitar essas linhas no script e executá-lo, você verá:"

#: ../../howto/logging.rst:119
msgid "WARNING:root:Watch out!"
msgstr "WARNING:root:Watch out!"

#: ../../howto/logging.rst:123
msgid ""
"printed out on the console. The ``INFO`` message doesn't appear because the "
"default level is ``WARNING``. The printed message includes the indication of "
"the level and the description of the event provided in the logging call, i."
"e. 'Watch out!'. The actual output can be formatted quite flexibly if you "
"need that; formatting options will also be explained later."
msgstr ""
"impresso no console. A mensagem ``INFO`` não aparece porque o nível padrão é "
"``WARNING``. A mensagem impressa inclui a indicação do nível e a descrição "
"do evento fornecido na chamada de registro, ou seja, 'Watch out!'. A saída "
"real pode ser formatada de maneira bastante flexível, se necessário; as "
"opções de formatação também serão explicadas mais tarde."

#: ../../howto/logging.rst:129
msgid ""
"Notice that in this example, we use functions directly on the ``logging`` "
"module, like ``logging.debug``, rather than creating a logger and calling "
"functions on it. These functions operation on the root logger, but can be "
"useful as they will call :func:`~logging.basicConfig` for you if it has not "
"been called yet, like in this example.  In larger programs you'll usually "
"want to control the logging configuration explicitly however - so for that "
"reason as well as others, it's better to create loggers and call their "
"methods."
msgstr ""
"Observe que neste exemplo, usamos funções diretamente no módulo ``logging``, "
"como ``logging.debug``, ao invés de criar um logger e chamar funções nele. "
"Essas funções operam no logger raiz, mas podem ser úteis, pois chamarão :"
"func:`~logging.basicConfig` para você se ele ainda não tiver sido chamado, "
"como neste exemplo. Em programas maiores, você geralmente desejará controlar "
"explicitamente a configuração de logging, no entanto - então, por esse "
"motivo, assim como por outros, é melhor criar loggers e chamar seus métodos."

#: ../../howto/logging.rst:138
msgid "Logging to a file"
msgstr "Logging em um arquivo"

#: ../../howto/logging.rst:140
msgid ""
"A very common situation is that of recording logging events in a file, so "
"let's look at that next. Be sure to try the following in a newly started "
"Python interpreter, and don't just continue from the session described "
"above::"
msgstr ""
"Uma situação muito comum é a de registrar eventos de log em um arquivo, "
"então vamos dar uma olhada nisso a seguir. Certifique-se de tentar o "
"seguinte em um interpretador Python recém-iniciado, e não continue apenas a "
"partir da sessão descrita acima::"

#: ../../howto/logging.rst:144
msgid ""
"import logging\n"
"logger = logging.getLogger(__name__)\n"
"logging.basicConfig(filename='example.log', encoding='utf-8', level=logging."
"DEBUG)\n"
"logger.debug('This message should go to the log file')\n"
"logger.info('So should this')\n"
"logger.warning('And this, too')\n"
"logger.error('And non-ASCII stuff, too, like Øresund and Malmö')"
msgstr ""
"import logging\n"
"logger = logging.getLogger(__name__)\n"
"logging.basicConfig(filename='example.log', encoding='utf-8', level=logging."
"DEBUG)\n"
"logger.debug('This message should go to the log file')\n"
"logger.info('So should this')\n"
"logger.warning('And this, too')\n"
"logger.error('And non-ASCII stuff, too, like Øresund and Malmö')"

#: ../../howto/logging.rst:152
msgid ""
"The *encoding* argument was added. In earlier Python versions, or if not "
"specified, the encoding used is the default value used by :func:`open`. "
"While not shown in the above example, an *errors* argument can also now be "
"passed, which determines how encoding errors are handled. For available "
"values and the default, see the documentation for :func:`open`."
msgstr ""
"Додано аргумент *кодування*. У попередніх версіях Python або, якщо не "
"вказано, використовувалося кодування за замовчуванням, яке використовується :"
"func:`open`. Хоча це не показано в наведеному вище прикладі, тепер також "
"можна передати аргумент *errors*, який визначає, як обробляються помилки "
"кодування. Доступні значення та типові значення дивіться в документації для :"
"func:`open`."

#: ../../howto/logging.rst:159
msgid ""
"And now if we open the file and look at what we have, we should find the log "
"messages:"
msgstr ""
"E agora se nós abrirmos o arquivo e olharmos o que temos, deveremos "
"encontrar essas mensagens de log:"

#: ../../howto/logging.rst:162
msgid ""
"DEBUG:__main__:This message should go to the log file\n"
"INFO:__main__:So should this\n"
"WARNING:__main__:And this, too\n"
"ERROR:__main__:And non-ASCII stuff, too, like Øresund and Malmö"
msgstr ""
"DEBUG:__main__:This message should go to the log file\n"
"INFO:__main__:So should this\n"
"WARNING:__main__:And this, too\n"
"ERROR:__main__:And non-ASCII stuff, too, like Øresund and Malmö"

#: ../../howto/logging.rst:169
msgid ""
"This example also shows how you can set the logging level which acts as the "
"threshold for tracking. In this case, because we set the threshold to "
"``DEBUG``, all of the messages were printed."
msgstr ""
"Este exemplo também mostra como você pode configurar o nível do logging que "
"age como um limiar para o rastreamento. Neste caso, por causa que definimos "
"o limiar como ``DEBUG``, todas as mensagens foram exibidas."

#: ../../howto/logging.rst:173
msgid ""
"If you want to set the logging level from a command-line option such as:"
msgstr ""
"Se você quer definir o nível de logging a partir de uma opção da linha de "
"comando como:"

#: ../../howto/logging.rst:175
msgid "--log=INFO"
msgstr "--log=INFO"

#: ../../howto/logging.rst:179
msgid ""
"and you have the value of the parameter passed for ``--log`` in some "
"variable *loglevel*, you can use::"
msgstr ""
"e você tem o valor do parâmetro passado pelo ``--log`` em alguma variável "
"*loglevel*, você pode usar::"

#: ../../howto/logging.rst:182
msgid "getattr(logging, loglevel.upper())"
msgstr "getattr(logging, loglevel.upper())"

#: ../../howto/logging.rst:184
msgid ""
"to get the value which you'll pass to :func:`basicConfig` via the *level* "
"argument. You may want to error check any user input value, perhaps as in "
"the following example::"
msgstr ""
"para obter o valor que você passará para a :func:`basicConfig` via o *level* "
"argumento. Você pode querer verificar qualquer erros introduzidos pelo "
"usuário, talvez como no exemplo a seguir::"

#: ../../howto/logging.rst:188
msgid ""
"# assuming loglevel is bound to the string value obtained from the\n"
"# command line argument. Convert to upper case to allow the user to\n"
"# specify --log=DEBUG or --log=debug\n"
"numeric_level = getattr(logging, loglevel.upper(), None)\n"
"if not isinstance(numeric_level, int):\n"
"    raise ValueError('Invalid log level: %s' % loglevel)\n"
"logging.basicConfig(level=numeric_level, ...)"
msgstr ""
"# assuming loglevel is bound to the string value obtained from the\n"
"# command line argument. Convert to upper case to allow the user to\n"
"# specify --log=DEBUG or --log=debug\n"
"numeric_level = getattr(logging, loglevel.upper(), None)\n"
"if not isinstance(numeric_level, int):\n"
"    raise ValueError('Invalid log level: %s' % loglevel)\n"
"logging.basicConfig(level=numeric_level, ...)"

#: ../../howto/logging.rst:196
msgid ""
"The call to :func:`basicConfig` should come *before* any calls to a logger's "
"methods such as :meth:`~Logger.debug`, :meth:`~Logger.info`, etc. Otherwise, "
"that logging event may not be handled in the desired manner."
msgstr ""
"Вызов :func:`basicConfig` должен происходить *перед* любыми вызовами методов "
"регистратора, таких как :meth:`~Logger.debug`, :meth:`~Logger.info` и т. д. "
"В противном случае это событие регистрации может не обрабатываться желаемым "
"образом."

#: ../../howto/logging.rst:200
msgid ""
"If you run the above script several times, the messages from successive runs "
"are appended to the file *example.log*. If you want each run to start "
"afresh, not remembering the messages from earlier runs, you can specify the "
"*filemode* argument, by changing the call in the above example to::"
msgstr ""
"Se você executar o script acima diversas vezes, as mensagens das sucessivas "
"execuções serão acrescentadas ao arquivo *example.log*. Se você quer que "
"cada execução seja iniciada novamente, não guardando as mensagens das "
"execuções anteriores, você pode especificar o *filemode* argumento, mudando "
"a chamada no exemplo acima::"

#: ../../howto/logging.rst:205
msgid ""
"logging.basicConfig(filename='example.log', filemode='w', level=logging."
"DEBUG)"
msgstr ""
"logging.basicConfig(filename='example.log', filemode='w', level=logging."
"DEBUG)"

#: ../../howto/logging.rst:207
msgid ""
"The output will be the same as before, but the log file is no longer "
"appended to, so the messages from earlier runs are lost."
msgstr ""
"A saída será a mesma de antes, mas o arquivo de log não será mais "
"incrementado, desta forma as mensagens de execuções anteriores serão "
"perdidas."

#: ../../howto/logging.rst:212
msgid "Logging variable data"
msgstr "Logging dados de uma variável"

#: ../../howto/logging.rst:214
msgid ""
"To log variable data, use a format string for the event description message "
"and append the variable data as arguments. For example::"
msgstr ""
"Para logar o dado de uma variável, use o formato string para a mensagem "
"descritiva do evento e adicione a variável como argumento. Exemplo::"

#: ../../howto/logging.rst:217
msgid ""
"import logging\n"
"logging.warning('%s before you %s', 'Look', 'leap!')"
msgstr ""
"import logging\n"
"logging.warning('%s before you %s', 'Look', 'leap!')"

#: ../../howto/logging.rst:220
msgid "will display:"
msgstr "exibirá:"

#: ../../howto/logging.rst:222
msgid "WARNING:root:Look before you leap!"
msgstr "ВНИМАНИЕ:root: Посмотрите, прежде чем прыгать!"

#: ../../howto/logging.rst:226
msgid ""
"As you can see, merging of variable data into the event description message "
"uses the old, %-style of string formatting. This is for backwards "
"compatibility: the logging package pre-dates newer formatting options such "
"as :meth:`str.format` and :class:`string.Template`. These newer formatting "
"options *are* supported, but exploring them is outside the scope of this "
"tutorial: see :ref:`formatting-styles` for more information."
msgstr ""
"Como você pode ver, para combinar uma variável de dados na mensagem "
"descritiva do evento usamos o velho, %-s estilo de formatação de string. "
"Isto é usado para garantir compatibilidade com as versões anteriores: o "
"pacote logging pré-data novas opções de formatação como :meth:`str.format` "
"e :class:`string.Template`. Estas novas opções de formatação são suportadas, "
"mas explorá-las esta fora do escopo deste tutorial: veja :ref:`formatting-"
"styles` para mais informações."

#: ../../howto/logging.rst:235
msgid "Changing the format of displayed messages"
msgstr "Alterar o formato das mensagens exibidas"

#: ../../howto/logging.rst:237
msgid ""
"To change the format which is used to display messages, you need to specify "
"the format you want to use::"
msgstr ""
"Para mudar o formato usado para exibir mensagens, você precisa especificar o "
"formato que quer usar::"

#: ../../howto/logging.rst:240
msgid ""
"import logging\n"
"logging.basicConfig(format='%(levelname)s:%(message)s', level=logging."
"DEBUG)\n"
"logging.debug('This message should appear on the console')\n"
"logging.info('So should this')\n"
"logging.warning('And this, too')"
msgstr ""
"import logging\n"
"logging.basicConfig(format='%(levelname)s:%(message)s', level=logging."
"DEBUG)\n"
"logging.debug('This message should appear on the console')\n"
"logging.info('So should this')\n"
"logging.warning('And this, too')"

#: ../../howto/logging.rst:246
msgid "which would print:"
msgstr "que vai exibir:"

#: ../../howto/logging.rst:248
msgid ""
"DEBUG:This message should appear on the console\n"
"INFO:So should this\n"
"WARNING:And this, too"
msgstr ""
"DEBUG:This message should appear on the console\n"
"INFO:So should this\n"
"WARNING:And this, too"

#: ../../howto/logging.rst:254
msgid ""
"Notice that the 'root' which appeared in earlier examples has disappeared. "
"For a full set of things that can appear in format strings, you can refer to "
"the documentation for :ref:`logrecord-attributes`, but for simple usage, you "
"just need the *levelname* (severity), *message* (event description, "
"including variable data) and perhaps to display when the event occurred. "
"This is described in the next section."
msgstr ""
"Note que a palavra 'root' que apareceu nos exemplos anteriores desapareceu. "
"Para todas as configurações que possam aparecer na formatação de strings, "
"você pode consultar a documentação :ref:`logrecord-attributes`, mas para uso "
"simples, você só precisa do *levelname* (severidade), *message* (descrição "
"do evento, incluindo a variável com dados) e talvez exibir quando o evento "
"ocorreu. Isto esta descrito na próxima seção."

#: ../../howto/logging.rst:263
msgid "Displaying the date/time in messages"
msgstr "Exibindo data/hora em mensagens"

#: ../../howto/logging.rst:265
msgid ""
"To display the date and time of an event, you would place '%(asctime)s' in "
"your format string::"
msgstr ""
"Para exibir a data e hora de um evento, você pode colocar '%(asctime)s' no "
"seu formato string::"

#: ../../howto/logging.rst:268
msgid ""
"import logging\n"
"logging.basicConfig(format='%(asctime)s %(message)s')\n"
"logging.warning('is when this event was logged.')"
msgstr ""
"import logging\n"
"logging.basicConfig(format='%(asctime)s %(message)s')\n"
"logging.warning('is when this event was logged.')"

#: ../../howto/logging.rst:272
msgid "which should print something like this:"
msgstr "que deve exibir algo assim:"

#: ../../howto/logging.rst:274
msgid "2010-12-12 11:41:42,612 is when this event was logged."
msgstr ""
"2010-12-12 11:41:42,612 - это время, когда это событие было зарегистрировано."

#: ../../howto/logging.rst:278
msgid ""
"The default format for date/time display (shown above) is like ISO8601 or :"
"rfc:`3339`. If you need more control over the formatting of the date/time, "
"provide a *datefmt* argument to ``basicConfig``, as in this example::"
msgstr ""
"O formato padrão para data/hora (mostrado abaixo) é como a ISO8601 ou :rfc:"
"`3339`. Se você precisa de mais controle sobre a formatação de data/hora, "
"informe o *datefmt* argumento para ``basicConfig``, como neste exemplo::"

#: ../../howto/logging.rst:282
msgid ""
"import logging\n"
"logging.basicConfig(format='%(asctime)s %(message)s', datefmt='%m/%d/%Y %I:"
"%M:%S %p')\n"
"logging.warning('is when this event was logged.')"
msgstr ""
"import logging\n"
"logging.basicConfig(format='%(asctime)s %(message)s', datefmt='%m/%d/%Y %I:"
"%M:%S %p')\n"
"logging.warning('is when this event was logged.')"

#: ../../howto/logging.rst:286
msgid "which would display something like this:"
msgstr "que deve exibir algo assim:"

#: ../../howto/logging.rst:288
msgid "12/12/2010 11:46:36 AM is when this event was logged."
msgstr ""
"12.12.2010 11:46:36 — это время, когда было зарегистрировано это событие."

#: ../../howto/logging.rst:292
msgid ""
"The format of the *datefmt* argument is the same as supported by :func:`time."
"strftime`."
msgstr ""
"O formato do argumento *datefmt* é o mesmo suportado por :func:`time."
"strftime`."

#: ../../howto/logging.rst:297
msgid "Next Steps"
msgstr "Próximos Passos"

#: ../../howto/logging.rst:299
msgid ""
"That concludes the basic tutorial. It should be enough to get you up and "
"running with logging. There's a lot more that the logging package offers, "
"but to get the best out of it, you'll need to invest a little more of your "
"time in reading the following sections. If you're ready for that, grab some "
"of your favourite beverage and carry on."
msgstr ""
"Concluímos aqui o tutorial básico. Isto deve ser o bastante para você "
"começar a trabalhar com logging. Existe muito mais que o pacote de logging "
"pode oferecer, mas para ter o melhor disto, você precisará investir um pouco "
"mais do seu tempo lendo as próximas seções. Se você está pronto para isso, "
"pegue sua bebida favorita e continue."

#: ../../howto/logging.rst:305
msgid ""
"If your logging needs are simple, then use the above examples to incorporate "
"logging into your own scripts, and if you run into problems or don't "
"understand something, please post a question on the comp.lang.python Usenet "
"group (available at https://groups.google.com/g/comp.lang.python) and you "
"should receive help before too long."
msgstr ""
"Если ваши потребности в ведении журналов просты, используйте приведенные "
"выше примеры, чтобы включить ведение журнала в свои собственные сценарии, а "
"если у вас возникнут проблемы или вы что-то не понимаете, задайте вопрос в "
"группе usenet comp.lang.python (доступно по адресу https). ://groups.google."
"com/g/comp.lang.python), и вскоре вы получите помощь."

#: ../../howto/logging.rst:311
msgid ""
"Still here? You can carry on reading the next few sections, which provide a "
"slightly more advanced/in-depth tutorial than the basic one above. After "
"that, you can take a look at the :ref:`logging-cookbook`."
msgstr ""
"Ainda por aqui? Você pode continuar lendo as seções seguintes, que tem um "
"tutorial mais avançado que o básico acima. Depois disso, você pode dar uma "
"olhada no :ref:`logging-cookbook`."

#: ../../howto/logging.rst:319
msgid "Advanced Logging Tutorial"
msgstr "Tutorial Avançado do Logging"

#: ../../howto/logging.rst:321
msgid ""
"The logging library takes a modular approach and offers several categories "
"of components: loggers, handlers, filters, and formatters."
msgstr ""
"A biblioteca de logging tem uma abordagem modular e oferece algumas "
"categorias de componentes: loggers, handlers, filters, e formatters."

#: ../../howto/logging.rst:324
msgid "Loggers expose the interface that application code directly uses."
msgstr "Loggers expõem a interface que o código da aplicação usa diretamente."

#: ../../howto/logging.rst:325
msgid ""
"Handlers send the log records (created by loggers) to the appropriate "
"destination."
msgstr ""
"Handlers enviam os registros do evento (criados por loggers) aos destinos "
"apropriados."

#: ../../howto/logging.rst:327
msgid ""
"Filters provide a finer grained facility for determining which log records "
"to output."
msgstr ""
"Filters fornecem uma facilidade granular para determinar quais registros de "
"eventos enviar à saída."

#: ../../howto/logging.rst:329
msgid "Formatters specify the layout of log records in the final output."
msgstr ""
"Formatters especificam o layout dos registros de eventos na saída final."

#: ../../howto/logging.rst:331
msgid ""
"Log event information is passed between loggers, handlers, filters and "
"formatters in a :class:`LogRecord` instance."
msgstr ""
"Uma informação de um evento de log é passada entre loggers, handlers, "
"filters e formatters em uma instância de uma :class:`LogRecord`"

#: ../../howto/logging.rst:334
msgid ""
"Logging is performed by calling methods on instances of the :class:`Logger` "
"class (hereafter called :dfn:`loggers`). Each instance has a name, and they "
"are conceptually arranged in a namespace hierarchy using dots (periods) as "
"separators. For example, a logger named 'scan' is the parent of loggers "
"'scan.text', 'scan.html' and 'scan.pdf'. Logger names can be anything you "
"want, and indicate the area of an application in which a logged message "
"originates."
msgstr ""
"Logging é executada chamando métodos nas instâncias da :class:`Logger` "
"classe, também chamado de :dfn:`loggers`. Cada instância tem um nome, e eles "
"são conceitualmente organizados em uma hierarquia de espaço de nomes usando "
"pontos como separadores. Por exemplo, um logger nomeado com 'scan' é o pai "
"do logger 'scan.text', 'scan.html' e 'scan.pdf'. Você pode nomear o logger "
"do jeito que preferir, e indicar a área de uma aplicação em que uma mensagem "
"de log origina."

#: ../../howto/logging.rst:341
msgid ""
"A good convention to use when naming loggers is to use a module-level "
"logger, in each module which uses logging, named as follows::"
msgstr ""
"Uma boa convenção para usar quando nomear loggers é usar um módulo-nível "
"logger, em cada módulo que usa o logging, nomeado como sugerido abaixo::"

#: ../../howto/logging.rst:344
msgid "logger = logging.getLogger(__name__)"
msgstr "logger = logging.getLogger(__name__)"

#: ../../howto/logging.rst:346
msgid ""
"This means that logger names track the package/module hierarchy, and it's "
"intuitively obvious where events are logged just from the logger name."
msgstr ""
"Isto significa que o nome de um logger rastreia a hierarquia do pacote/"
"módulo, e isto é obviamente intuitivo onde os eventos estão sendo "
"registrados apenas pelo nome do logger."

#: ../../howto/logging.rst:349
msgid ""
"The root of the hierarchy of loggers is called the root logger. That's the "
"logger used by the functions :func:`debug`, :func:`info`, :func:`warning`, :"
"func:`error` and :func:`critical`, which just call the same-named method of "
"the root logger. The functions and the methods have the same signatures. The "
"root logger's name is printed as 'root' in the logged output."
msgstr ""
"Корінь ієрархії реєстраторів називається кореневим реєстратором. Це "
"реєстратор, який використовують функції :func:`debug`, :func:`info`, :func:"
"`warning`, :func:`error` і :func:`critical`, які просто викликають "
"одноіменний метод кореневого реєстратора. Функції та методи мають однакові "
"сигнатури. Ім'я кореневого реєстратора друкується як 'root' у зареєстрованих "
"результатах."

#: ../../howto/logging.rst:355
msgid ""
"It is, of course, possible to log messages to different destinations. "
"Support is included in the package for writing log messages to files, HTTP "
"GET/POST locations, email via SMTP, generic sockets, queues, or OS-specific "
"logging mechanisms such as syslog or the Windows NT event log. Destinations "
"are served by :dfn:`handler` classes. You can create your own log "
"destination class if you have special requirements not met by any of the "
"built-in handler classes."
msgstr ""
"Звичайно, можна записувати повідомлення до різних адресатів. У пакет "
"включено підтримку для запису повідомлень журналу у файли, розташування HTTP "
"GET/POST, електронну пошту через SMTP, загальні сокети, черги або специфічні "
"для ОС механізми журналювання, такі як syslog або журнал подій Windows NT. "
"Пункти призначення обслуговуються класами :dfn:`handler`. Ви можете створити "
"власний клас призначення журналу, якщо у вас є особливі вимоги, яких не "
"задовольняє жоден із вбудованих класів обробки."

#: ../../howto/logging.rst:362
msgid ""
"By default, no destination is set for any logging messages. You can specify "
"a destination (such as console or file) by using :func:`basicConfig` as in "
"the tutorial examples. If you call the functions  :func:`debug`, :func:"
"`info`, :func:`warning`, :func:`error` and :func:`critical`, they will check "
"to see if no destination is set; and if one is not set, they will set a "
"destination of the console (``sys.stderr``) and a default format for the "
"displayed message before delegating to the root logger to do the actual "
"message output."
msgstr ""
"За замовчуванням адресат не встановлено для будь-яких повідомлень журналу. "
"Ви можете вказати призначення (наприклад, консоль або файл) за допомогою :"
"func:`basicConfig`, як у прикладах підручника. Якщо ви викликаєте функції :"
"func:`debug`, :func:`info`, :func:`warning`, :func:`error` і :func:"
"`critical`, вони перевірять, чи не встановлено місце призначення ; і якщо "
"його не встановлено, вони встановлять призначення консолі (``sys.stderr``) і "
"формат за замовчуванням для відображеного повідомлення перед делегуванням "
"кореневому реєстратору для фактичного виведення повідомлення."

#: ../../howto/logging.rst:370
msgid "The default format set by :func:`basicConfig` for messages is:"
msgstr "O formato padrão definido por :func:`basicConfig` para mensagens é:"

#: ../../howto/logging.rst:372
msgid "severity:logger name:message"
msgstr "severity:logger name:message"

#: ../../howto/logging.rst:376
msgid ""
"You can change this by passing a format string to :func:`basicConfig` with "
"the *format* keyword argument. For all options regarding how a format string "
"is constructed, see :ref:`formatter-objects`."
msgstr ""
"Ви можете змінити це, передавши рядок формату в :func:`basicConfig` з "
"ключовим аргументом *format*. Щоб дізнатися про всі варіанти створення рядка "
"формату, перегляньте :ref:`formatter-objects`."

#: ../../howto/logging.rst:381
msgid "Logging Flow"
msgstr "Fluxo de Logging"

#: ../../howto/logging.rst:383
msgid ""
"The flow of log event information in loggers and handlers is illustrated in "
"the following diagram."
msgstr ""
"O fluxo dos eventos de log em loggers e handlers é ilustrado no diagrama a "
"seguir."

#: ../../howto/logging.rst:434
msgid "Loggers"
msgstr "Registradores"

#: ../../howto/logging.rst:436
msgid ""
":class:`Logger` objects have a threefold job.  First, they expose several "
"methods to application code so that applications can log messages at "
"runtime. Second, logger objects determine which log messages to act upon "
"based upon severity (the default filtering facility) or filter objects.  "
"Third, logger objects pass along relevant log messages to all interested log "
"handlers."
msgstr ""
"Об’єкти :class:`Logger` виконують потрійну роботу. По-перше, вони надають "
"кілька методів коду програми, щоб програми могли реєструвати повідомлення "
"під час виконання. По-друге, об’єкти реєстратора визначають, з якими "
"повідомленнями журналу діяти, залежно від серйозності (засоби фільтрації за "
"замовчуванням) або об’єктів фільтрації. По-третє, об’єкти журналу передають "
"відповідні повідомлення журналу всім зацікавленим обробникам журналів."

#: ../../howto/logging.rst:442
msgid ""
"The most widely used methods on logger objects fall into two categories: "
"configuration and message sending."
msgstr ""
"Os métodos mais usados em objetos logger se enquadram em duas categorias: "
"configuração e envio de mensagem."

#: ../../howto/logging.rst:445
msgid "These are the most common configuration methods:"
msgstr "Esses são os métodos de configuração mais comuns:"

#: ../../howto/logging.rst:447
msgid ""
":meth:`Logger.setLevel` specifies the lowest-severity log message a logger "
"will handle, where debug is the lowest built-in severity level and critical "
"is the highest built-in severity.  For example, if the severity level is "
"INFO, the logger will handle only INFO, WARNING, ERROR, and CRITICAL "
"messages and will ignore DEBUG messages."
msgstr ""
":meth:`Logger.setLevel` визначає повідомлення журналу з найнижчим рівнем "
"серйозності, яке обробить реєстратор, де debug — найнижчий вбудований рівень "
"серйозності, а критичний — найвищий вбудований рівень серйозності. "
"Наприклад, якщо рівень серйозності INFO, реєстратор оброблятиме лише "
"повідомлення INFO, WARNING, ERROR і CRITICAL і ігноруватиме повідомлення "
"DEBUG."

#: ../../howto/logging.rst:453
msgid ""
":meth:`Logger.addHandler` and :meth:`Logger.removeHandler` add and remove "
"handler objects from the logger object.  Handlers are covered in more detail "
"in :ref:`handler-basic`."
msgstr ""
":meth:`Logger.addHandler` і :meth:`Logger.removeHandler` додають і видаляють "
"об’єкти обробки з об’єкта реєстратора. Обробники описані більш детально в :"
"ref:`handler-basic`."

#: ../../howto/logging.rst:457
msgid ""
":meth:`Logger.addFilter` and :meth:`Logger.removeFilter` add and remove "
"filter objects from the logger object.  Filters are covered in more detail "
"in :ref:`filter`."
msgstr ""
":meth:`Logger.addFilter` і :meth:`Logger.removeFilter` додають і видаляють "
"об’єкти фільтрів з об’єкта реєстратора. Фільтри описані більш детально в :"
"ref:`filter`."

#: ../../howto/logging.rst:461
msgid ""
"You don't need to always call these methods on every logger you create. See "
"the last two paragraphs in this section."
msgstr ""
"Você não precisa sempre invocar esses métodos em cada logger que criar. Veja "
"os últimos dois paragrafos nessa seção."

#: ../../howto/logging.rst:464
msgid ""
"With the logger object configured, the following methods create log messages:"
msgstr ""
"Com o objeto logger configurado, os seguintes métodos criam mensagens de log:"

#: ../../howto/logging.rst:466
msgid ""
":meth:`Logger.debug`, :meth:`Logger.info`, :meth:`Logger.warning`, :meth:"
"`Logger.error`, and :meth:`Logger.critical` all create log records with a "
"message and a level that corresponds to their respective method names. The "
"message is actually a format string, which may contain the standard string "
"substitution syntax of ``%s``, ``%d``, ``%f``, and so on.  The rest of their "
"arguments is a list of objects that correspond with the substitution fields "
"in the message.  With regard to ``**kwargs``, the logging methods care only "
"about a keyword of ``exc_info`` and use it to determine whether to log "
"exception information."
msgstr ""
":meth:`Logger.debug`, :meth:`Logger.info`, :meth:`Logger.warning`, :meth:"
"`Logger.error` і :meth:`Logger.critical` створюють записи журналу з "
"повідомлення та рівень, що відповідає їх відповідним назвам методів. "
"Повідомлення фактично є рядком формату, який може містити стандартний "
"синтаксис заміни рядка ``%s``, ``%d``, ``%f`` і так далі. Решта аргументів — "
"це список об’єктів, які відповідають полям підстановки в повідомленні. Щодо "
"``**kwargs``, методи журналювання дбають лише про ключове слово ``exc_info`` "
"і використовують його, щоб визначити, чи потрібно реєструвати інформацію про "
"винятки."

#: ../../howto/logging.rst:476
msgid ""
":meth:`Logger.exception` creates a log message similar to :meth:`Logger."
"error`.  The difference is that :meth:`Logger.exception` dumps a stack trace "
"along with it.  Call this method only from an exception handler."
msgstr ""
":meth:`Logger.exception` створює повідомлення журналу, подібне до :meth:"
"`Logger.error`. Різниця полягає в тому, що :meth:`Logger.exception` виводить "
"трасування стека разом із ним. Викликайте цей метод лише з обробника "
"винятків."

#: ../../howto/logging.rst:480
msgid ""
":meth:`Logger.log` takes a log level as an explicit argument.  This is a "
"little more verbose for logging messages than using the log level "
"convenience methods listed above, but this is how to log at custom log "
"levels."
msgstr ""
":meth:`Logger.log` приймає рівень журналу як явний аргумент. Це трохи "
"докладніше для реєстрації повідомлень, ніж використання зручних методів на "
"рівні журналу, перелічених вище, але це те, як реєструвати на спеціальних "
"рівнях журналу."

#: ../../howto/logging.rst:484
msgid ""
":func:`getLogger` returns a reference to a logger instance with the "
"specified name if it is provided, or ``root`` if not.  The names are period-"
"separated hierarchical structures.  Multiple calls to :func:`getLogger` with "
"the same name will return a reference to the same logger object.  Loggers "
"that are further down in the hierarchical list are children of loggers "
"higher up in the list. For example, given a logger with a name of ``foo``, "
"loggers with names of ``foo.bar``, ``foo.bar.baz``, and ``foo.bam`` are all "
"descendants of ``foo``."
msgstr ""
":func:`getLogger` повертає посилання на екземпляр журналу з указаним іменем, "
"якщо воно надано, або ``root``, якщо ні. Назви є ієрархічними структурами, "
"розділеними на періоди. Кілька викликів :func:`getLogger` з однаковою назвою "
"повертатимуть посилання на той самий об’єкт журналу. Реєстратори, "
"розташовані нижче в ієрархічному списку, є нащадками реєстраторів, "
"розташованих вище в списку. Наприклад, якщо задано реєстратор із іменем "
"``foo``, усі реєстратори з іменами ``foo.bar``, ``foo.bar.baz`` і ``foo."
"bam`` є нащадками ``фу``."

#: ../../howto/logging.rst:492
msgid ""
"Loggers have a concept of *effective level*. If a level is not explicitly "
"set on a logger, the level of its parent is used instead as its effective "
"level. If the parent has no explicit level set, *its* parent is examined, "
"and so on - all ancestors are searched until an explicitly set level is "
"found. The root logger always has an explicit level set (``WARNING`` by "
"default). When deciding whether to process an event, the effective level of "
"the logger is used to determine whether the event is passed to the logger's "
"handlers."
msgstr ""
"Лісоруби мають поняття *ефективного рівня*. Якщо рівень не встановлено явно "
"в реєстраторі, рівень його батьківського елемента використовується замість "
"цього як ефективний рівень. Якщо батьківський елемент не має явно "
"встановленого рівня, перевіряється *його* батьківський елемент, і так далі - "
"шукаються всі предки, доки не буде знайдено явно встановлений рівень. "
"Кореневий реєстратор завжди має чітко встановлений рівень (``ПОПЕРЕДЖЕННЯ`` "
"за замовчуванням). При прийнятті рішення про обробку події ефективний рівень "
"реєстратора використовується для визначення того, чи подія передається "
"обробникам реєстратора."

#: ../../howto/logging.rst:500
msgid ""
"Child loggers propagate messages up to the handlers associated with their "
"ancestor loggers. Because of this, it is unnecessary to define and configure "
"handlers for all the loggers an application uses. It is sufficient to "
"configure handlers for a top-level logger and create child loggers as "
"needed. (You can, however, turn off propagation by setting the *propagate* "
"attribute of a logger to ``False``.)"
msgstr ""
"Дочірні реєстратори поширюють повідомлення до обробників, пов’язаних із "
"їхніми попередніми реєстраторами. Через це немає необхідності визначати та "
"налаштовувати обробники для всіх реєстраторів, які використовує програма. "
"Достатньо налаштувати обробники для реєстратора верхнього рівня та створити "
"дочірні реєстратори за потреби. (Проте ви можете вимкнути розповсюдження, "
"встановивши для атрибута *propagate* реєстратора значення ``False``.)"

#: ../../howto/logging.rst:511
msgid "Handlers"
msgstr "Manipuladores"

#: ../../howto/logging.rst:513
msgid ""
":class:`~logging.Handler` objects are responsible for dispatching the "
"appropriate log messages (based on the log messages' severity) to the "
"handler's specified destination.  :class:`Logger` objects can add zero or "
"more handler objects to themselves with an :meth:`~Logger.addHandler` "
"method.  As an example scenario, an application may want to send all log "
"messages to a log file, all log messages of error or higher to stdout, and "
"all messages of critical to an email address. This scenario requires three "
"individual handlers where each handler is responsible for sending messages "
"of a specific severity to a specific location."
msgstr ""
"Об’єкти :class:`~logging.Handler` відповідають за надсилання відповідних "
"повідомлень журналу (залежно від серйозності повідомлень журналу) до "
"вказаного призначення обробника. Об’єкти :class:`Logger` можуть додавати до "
"себе нуль або більше об’єктів обробки за допомогою методу :meth:`~Logger."
"addHandler`. Як приклад сценарію, програма може захотіти надіслати всі "
"повідомлення журналу до файлу журналу, усі повідомлення журналу про помилку "
"або вище до stdout, а всі критичні повідомлення на адресу електронної пошти. "
"Цей сценарій потребує трьох окремих обробників, де кожен обробник відповідає "
"за надсилання повідомлень певного рівня серйозності в певне місце."

#: ../../howto/logging.rst:523
msgid ""
"The standard library includes quite a few handler types (see :ref:`useful-"
"handlers`); the tutorials use mainly :class:`StreamHandler` and :class:"
"`FileHandler` in its examples."
msgstr ""
"A biblioteca padrão possui alguns tipos de handler (veja :ref:`useful-"
"handlers`); os tutoriais usam principalmente :class:`StreamHandler` e :class:"
"`FileHandler` nos seus exemplos."

#: ../../howto/logging.rst:527
msgid ""
"There are very few methods in a handler for application developers to "
"concern themselves with.  The only handler methods that seem relevant for "
"application developers who are using the built-in handler objects (that is, "
"not creating custom handlers) are the following configuration methods:"
msgstr ""
"У обробнику дуже мало методів, якими можуть зайнятися розробники програм. "
"Єдиними методами обробки, які здаються актуальними для розробників додатків, "
"які використовують вбудовані об’єкти обробки (тобто не створюють спеціальні "
"обробники), є такі методи конфігурації:"

#: ../../howto/logging.rst:532
msgid ""
"The :meth:`~Handler.setLevel` method, just as in logger objects, specifies "
"the lowest severity that will be dispatched to the appropriate destination.  "
"Why are there two :meth:`~Handler.setLevel` methods?  The level set in the "
"logger determines which severity of messages it will pass to its handlers.  "
"The level set in each handler determines which messages that handler will "
"send on."
msgstr ""
"Метод :meth:`~Handler.setLevel`, как и в объектах регистратора, определяет "
"наименьшую серьезность, которая будет отправлена ​​в соответствующий пункт "
"назначения. Почему существует два метода :meth:`~Handler.setLevel`? Уровень, "
"установленный в средстве ведения журнала, определяет, какую серьезность "
"сообщений он будет передавать своим обработчикам. Уровень, установленный в "
"каждом обработчике, определяет, какие сообщения будет отправлять этот "
"обработчик."

#: ../../howto/logging.rst:538
msgid ""
":meth:`~Handler.setFormatter` selects a Formatter object for this handler to "
"use."
msgstr ""
":meth:`~Handler.setFormatter` вибирає об’єкт Formatter для використання цим "
"обробником."

#: ../../howto/logging.rst:541
msgid ""
":meth:`~Handler.addFilter` and :meth:`~Handler.removeFilter` respectively "
"configure and deconfigure filter objects on handlers."
msgstr ""
":meth:`~Handler.addFilter` і :meth:`~Handler.removeFilter` відповідно "
"налаштовують і деконфігурують об’єкти фільтрів на обробниках."

#: ../../howto/logging.rst:544
msgid ""
"Application code should not directly instantiate and use instances of :class:"
"`Handler`.  Instead, the :class:`Handler` class is a base class that defines "
"the interface that all handlers should have and establishes some default "
"behavior that child classes can use (or override)."
msgstr ""
"Код програми не повинен безпосередньо створювати та використовувати "
"екземпляри :class:`Handler`. Натомість клас :class:`Handler` є базовим "
"класом, який визначає інтерфейс, який повинні мати всі обробники, і "
"встановлює певну поведінку за замовчуванням, яку дочірні класи можуть "
"використовувати (або замінювати)."

#: ../../howto/logging.rst:551
msgid "Formatters"
msgstr "Formatadores"

#: ../../howto/logging.rst:553
msgid ""
"Formatter objects configure the final order, structure, and contents of the "
"log message.  Unlike the base :class:`logging.Handler` class, application "
"code may instantiate formatter classes, although you could likely subclass "
"the formatter if your application needs special behavior.  The constructor "
"takes three optional arguments -- a message format string, a date format "
"string and a style indicator."
msgstr ""
"Об’єкти форматувальника налаштовують остаточний порядок, структуру та вміст "
"повідомлення журналу. На відміну від базового класу :class:`logging."
"Handler`, код програми може створювати екземпляри класів форматера, хоча ви, "
"ймовірно, можете створити підкласи форматера, якщо ваша програма потребує "
"особливої поведінки. Конструктор приймає три необов'язкові аргументи - рядок "
"формату повідомлення, рядок формату дати та індикатор стилю."

#: ../../howto/logging.rst:562
msgid ""
"If there is no message format string, the default is to use the raw "
"message.  If there is no date format string, the default date format is:"
msgstr ""
"Якщо рядок формату повідомлення відсутній, за умовчанням використовується "
"необроблене повідомлення. Якщо рядок формату дати відсутній, стандартний "
"формат дати:"

#: ../../howto/logging.rst:565
msgid "%Y-%m-%d %H:%M:%S"
msgstr "%Y-%m-%d %H:%M:%S"

#: ../../howto/logging.rst:569
msgid ""
"with the milliseconds tacked on at the end. The ``style`` is one of ``'%'``, "
"``'{'``, or ``'$'``. If one of these is not specified, then ``'%'`` will be "
"used."
msgstr ""
"с добавлением миллисекунд в конце. ``стиль`` может быть одним из ``'%'``, "
"``'{'`` или ``'$'``. Если один из них не указан, будет использоваться "
"``'%'``."

#: ../../howto/logging.rst:572
msgid ""
"If the ``style`` is ``'%'``, the message format string uses ``%(<dictionary "
"key>)s`` styled string substitution; the possible keys are documented in :"
"ref:`logrecord-attributes`. If the style is ``'{'``, the message format "
"string is assumed to be compatible with :meth:`str.format` (using keyword "
"arguments), while if the style is ``'$'`` then the message format string "
"should conform to what is expected by :meth:`string.Template.substitute`."
msgstr ""
"Если ``стиль`` равен ``'%'``, строка формата сообщения использует "
"подстановку строки в стиле ``%(<ключ словаря>)s``; возможные ключи описаны "
"в :ref:`logrecord-attributes`. Если стиль ``'{'``, предполагается, что "
"строка формата сообщения совместима с :meth:`str.format` (с использованием "
"аргументов ключевого слова), а если стиль ``'$'``, то Строка формата "
"сообщения должна соответствовать ожидаемому :meth:`string.Template."
"substitute`."

#: ../../howto/logging.rst:579
msgid "Added the ``style`` parameter."
msgstr "Adicionado o parâmetro ``style``."

#: ../../howto/logging.rst:582
msgid ""
"The following message format string will log the time in a human-readable "
"format, the severity of the message, and the contents of the message, in "
"that order::"
msgstr ""
"A string de formato a seguir vai escrever o tempo em um formato légivel para "
"humanos, a severidade da mensagem, e o conteúdo da mensagem, nessa ordem::"

#: ../../howto/logging.rst:586
msgid "'%(asctime)s - %(levelname)s - %(message)s'"
msgstr "'%(asctime)s - %(levelname)s - %(message)s'"

#: ../../howto/logging.rst:588
msgid ""
"Formatters use a user-configurable function to convert the creation time of "
"a record to a tuple. By default, :func:`time.localtime` is used; to change "
"this for a particular formatter instance, set the ``converter`` attribute of "
"the instance to a function with the same signature as :func:`time.localtime` "
"or :func:`time.gmtime`. To change it for all formatters, for example if you "
"want all logging times to be shown in GMT, set the ``converter`` attribute "
"in the Formatter class (to ``time.gmtime`` for GMT display)."
msgstr ""
"Форматери використовують настроювану користувачем функцію для перетворення "
"часу створення запису в кортеж. За замовчуванням використовується :func:"
"`time.localtime`; щоб змінити це для певного екземпляра форматера, "
"установіть атрибут ``converter`` екземпляра на функцію з тим самим підписом, "
"що й :func:`time.localtime` або :func:`time.gmtime`. Щоб змінити його для "
"всіх засобів форматування, наприклад, якщо ви хочете, щоб усі часи "
"журналювання відображалися за GMT, установіть атрибут ``converter`` у класі "
"Formatter (на ``time.gmtime`` для відображення GMT)."

#: ../../howto/logging.rst:598
msgid "Configuring Logging"
msgstr "Configurando Logging"

#: ../../howto/logging.rst:602
msgid "Programmers can configure logging in three ways:"
msgstr "Programadores podem configurar logging de três formas:"

#: ../../howto/logging.rst:604
msgid ""
"Creating loggers, handlers, and formatters explicitly using Python code that "
"calls the configuration methods listed above."
msgstr ""
"Створення реєстраторів, обробників і форматувальників явно за допомогою коду "
"Python, який викликає перелічені вище методи конфігурації."

#: ../../howto/logging.rst:606
msgid ""
"Creating a logging config file and reading it using the :func:`fileConfig` "
"function."
msgstr ""
"Створення файлу конфігурації журналу та його читання за допомогою функції :"
"func:`fileConfig`."

#: ../../howto/logging.rst:608
msgid ""
"Creating a dictionary of configuration information and passing it to the :"
"func:`dictConfig` function."
msgstr ""
"Створення словника конфігураційної інформації та передача його функції :func:"
"`dictConfig`."

#: ../../howto/logging.rst:611
msgid ""
"For the reference documentation on the last two options, see :ref:`logging-"
"config-api`.  The following example configures a very simple logger, a "
"console handler, and a simple formatter using Python code::"
msgstr ""
"Довідкову документацію щодо останніх двох параметрів див. :ref:`logging-"
"config-api`. У наступному прикладі налаштовується дуже простий реєстратор, "
"обробник консолі та простий засіб форматування за допомогою коду Python::"

#: ../../howto/logging.rst:615
msgid ""
"import logging\n"
"\n"
"# create logger\n"
"logger = logging.getLogger('simple_example')\n"
"logger.setLevel(logging.DEBUG)\n"
"\n"
"# create console handler and set level to debug\n"
"ch = logging.StreamHandler()\n"
"ch.setLevel(logging.DEBUG)\n"
"\n"
"# create formatter\n"
"formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - "
"%(message)s')\n"
"\n"
"# add formatter to ch\n"
"ch.setFormatter(formatter)\n"
"\n"
"# add ch to logger\n"
"logger.addHandler(ch)\n"
"\n"
"# 'application' code\n"
"logger.debug('debug message')\n"
"logger.info('info message')\n"
"logger.warning('warn message')\n"
"logger.error('error message')\n"
"logger.critical('critical message')"
msgstr ""
"import logging\n"
"\n"
"# create logger\n"
"logger = logging.getLogger('simple_example')\n"
"logger.setLevel(logging.DEBUG)\n"
"\n"
"# create console handler and set level to debug\n"
"ch = logging.StreamHandler()\n"
"ch.setLevel(logging.DEBUG)\n"
"\n"
"# create formatter\n"
"formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - "
"%(message)s')\n"
"\n"
"# add formatter to ch\n"
"ch.setFormatter(formatter)\n"
"\n"
"# add ch to logger\n"
"logger.addHandler(ch)\n"
"\n"
"# 'application' code\n"
"logger.debug('debug message')\n"
"logger.info('info message')\n"
"logger.warning('warn message')\n"
"logger.error('error message')\n"
"logger.critical('critical message')"

#: ../../howto/logging.rst:641
msgid ""
"Running this module from the command line produces the following output:"
msgstr "Запуск цього модуля з командного рядка дає такий результат:"

#: ../../howto/logging.rst:643
msgid ""
"$ python simple_logging_module.py\n"
"2005-03-19 15:10:26,618 - simple_example - DEBUG - debug message\n"
"2005-03-19 15:10:26,620 - simple_example - INFO - info message\n"
"2005-03-19 15:10:26,695 - simple_example - WARNING - warn message\n"
"2005-03-19 15:10:26,697 - simple_example - ERROR - error message\n"
"2005-03-19 15:10:26,773 - simple_example - CRITICAL - critical message"
msgstr ""
"$ python simple_logging_module.py\n"
"2005-03-19 15:10:26,618 - simple_example - DEBUG - debug message\n"
"2005-03-19 15:10:26,620 - simple_example - INFO - info message\n"
"2005-03-19 15:10:26,695 - simple_example - WARNING - warn message\n"
"2005-03-19 15:10:26,697 - simple_example - ERROR - error message\n"
"2005-03-19 15:10:26,773 - simple_example - CRITICAL - critical message"

#: ../../howto/logging.rst:652
msgid ""
"The following Python module creates a logger, handler, and formatter nearly "
"identical to those in the example listed above, with the only difference "
"being the names of the objects::"
msgstr ""
"Наступний модуль Python створює реєстратор, обробник і форматування, майже "
"ідентичні тим, що в наведеному вище прикладі, з тією лише різницею, як імена "
"об’єктів:"

#: ../../howto/logging.rst:656
msgid ""
"import logging\n"
"import logging.config\n"
"\n"
"logging.config.fileConfig('logging.conf')\n"
"\n"
"# create logger\n"
"logger = logging.getLogger('simpleExample')\n"
"\n"
"# 'application' code\n"
"logger.debug('debug message')\n"
"logger.info('info message')\n"
"logger.warning('warn message')\n"
"logger.error('error message')\n"
"logger.critical('critical message')"
msgstr ""
"import logging\n"
"import logging.config\n"
"\n"
"logging.config.fileConfig('logging.conf')\n"
"\n"
"# create logger\n"
"logger = logging.getLogger('simpleExample')\n"
"\n"
"# 'application' code\n"
"logger.debug('debug message')\n"
"logger.info('info message')\n"
"logger.warning('warn message')\n"
"logger.error('error message')\n"
"logger.critical('critical message')"

#: ../../howto/logging.rst:671
msgid "Here is the logging.conf file:"
msgstr "Aqui está o arquivo logging.conf:"

#: ../../howto/logging.rst:673
msgid ""
"[loggers]\n"
"keys=root,simpleExample\n"
"\n"
"[handlers]\n"
"keys=consoleHandler\n"
"\n"
"[formatters]\n"
"keys=simpleFormatter\n"
"\n"
"[logger_root]\n"
"level=DEBUG\n"
"handlers=consoleHandler\n"
"\n"
"[logger_simpleExample]\n"
"level=DEBUG\n"
"handlers=consoleHandler\n"
"qualname=simpleExample\n"
"propagate=0\n"
"\n"
"[handler_consoleHandler]\n"
"class=StreamHandler\n"
"level=DEBUG\n"
"formatter=simpleFormatter\n"
"args=(sys.stdout,)\n"
"\n"
"[formatter_simpleFormatter]\n"
"format=%(asctime)s - %(name)s - %(levelname)s - %(message)s"
msgstr ""
"[loggers]\n"
"keys=root,simpleExample\n"
"\n"
"[handlers]\n"
"keys=consoleHandler\n"
"\n"
"[formatters]\n"
"keys=simpleFormatter\n"
"\n"
"[logger_root]\n"
"level=DEBUG\n"
"handlers=consoleHandler\n"
"\n"
"[logger_simpleExample]\n"
"level=DEBUG\n"
"handlers=consoleHandler\n"
"qualname=simpleExample\n"
"propagate=0\n"
"\n"
"[handler_consoleHandler]\n"
"class=StreamHandler\n"
"level=DEBUG\n"
"formatter=simpleFormatter\n"
"args=(sys.stdout,)\n"
"\n"
"[formatter_simpleFormatter]\n"
"format=%(asctime)s - %(name)s - %(levelname)s - %(message)s"

#: ../../howto/logging.rst:703
msgid ""
"The output is nearly identical to that of the non-config-file-based example:"
msgstr "Результат майже ідентичний прикладу без конфігураційного файлу:"

#: ../../howto/logging.rst:705
msgid ""
"$ python simple_logging_config.py\n"
"2005-03-19 15:38:55,977 - simpleExample - DEBUG - debug message\n"
"2005-03-19 15:38:55,979 - simpleExample - INFO - info message\n"
"2005-03-19 15:38:56,054 - simpleExample - WARNING - warn message\n"
"2005-03-19 15:38:56,055 - simpleExample - ERROR - error message\n"
"2005-03-19 15:38:56,130 - simpleExample - CRITICAL - critical message"
msgstr ""
"$ python simple_logging_config.py\n"
"2005-03-19 15:38:55,977 - simpleExample - DEBUG - debug message\n"
"2005-03-19 15:38:55,979 - simpleExample - INFO - info message\n"
"2005-03-19 15:38:56,054 - simpleExample - WARNING - warn message\n"
"2005-03-19 15:38:56,055 - simpleExample - ERROR - error message\n"
"2005-03-19 15:38:56,130 - simpleExample - CRITICAL - critical message"

#: ../../howto/logging.rst:714
msgid ""
"You can see that the config file approach has a few advantages over the "
"Python code approach, mainly separation of configuration and code and the "
"ability of noncoders to easily modify the logging properties."
msgstr ""
"Ви бачите, що підхід із конфігураційним файлом має кілька переваг перед "
"підходом до коду Python, головним чином розділення конфігурації та коду та "
"можливість некодерів легко змінювати властивості журналювання."

#: ../../howto/logging.rst:718
msgid ""
"The :func:`fileConfig` function takes a default parameter, "
"``disable_existing_loggers``, which defaults to ``True`` for reasons of "
"backward compatibility. This may or may not be what you want, since it will "
"cause any non-root loggers existing before the :func:`fileConfig` call to be "
"disabled unless they (or an ancestor) are explicitly named in the "
"configuration. Please refer to the reference documentation for more "
"information, and specify ``False`` for this parameter if you wish."
msgstr ""
"Функція :func:`fileConfig` приймає параметр за замовчуванням, "
"``disable_existing_loggers``, який за умовчанням має значення ``True`` з "
"причин зворотної сумісності. Це може бути або не те, що ви хочете, оскільки "
"це призведе до вимкнення будь-яких некореневих реєстраторів, які існують до "
"виклику :func:`fileConfig`, якщо вони (або предок) явно не вказані в "
"конфігурації. Будь ласка, зверніться до довідкової документації для "
"отримання додаткової інформації та вкажіть ``False`` для цього параметра, "
"якщо хочете."

#: ../../howto/logging.rst:726
msgid ""
"The dictionary passed to :func:`dictConfig` can also specify a Boolean value "
"with key ``disable_existing_loggers``, which if not specified explicitly in "
"the dictionary also defaults to being interpreted as ``True``. This leads to "
"the logger-disabling behaviour described above, which may not be what you "
"want - in which case, provide the key explicitly with a value of ``False``."
msgstr ""
"Словник, переданий у :func:`dictConfig`, також може вказати логічне значення "
"з ключем ``disable_existing_loggers``, яке, якщо не вказано явно в словнику, "
"також за умовчанням інтерпретується як ``True``. Це призводить до поведінки "
"вимкнення реєстратора, описаної вище, яка може не відповідати вашим "
"побажанням - у такому випадку вкажіть ключ явно зі значенням ``False``."

#: ../../howto/logging.rst:736
msgid ""
"Note that the class names referenced in config files need to be either "
"relative to the logging module, or absolute values which can be resolved "
"using normal import mechanisms. Thus, you could use either :class:`~logging."
"handlers.WatchedFileHandler` (relative to the logging module) or ``mypackage."
"mymodule.MyHandler`` (for a class defined in package ``mypackage`` and "
"module ``mymodule``, where ``mypackage`` is available on the Python import "
"path)."
msgstr ""
"Зауважте, що назви класів, на які посилаються у конфігураційних файлах, "
"мають бути або відносними до модуля журналювання, або абсолютними "
"значеннями, які можна вирішити за допомогою звичайних механізмів імпорту. "
"Таким чином, ви можете використовувати :class:`~logging.handlers."
"WatchedFileHandler` (щодо модуля журналювання) або ``mypackage.mymodule."
"MyHandler`` (для класу, визначеного в пакунку ``mypackage`` і модулі "
"``mymodule``, де ``mypackage`` доступний на шляху імпорту Python)."

#: ../../howto/logging.rst:744
msgid ""
"In Python 3.2, a new means of configuring logging has been introduced, using "
"dictionaries to hold configuration information. This provides a superset of "
"the functionality of the config-file-based approach outlined above, and is "
"the recommended configuration method for new applications and deployments. "
"Because a Python dictionary is used to hold configuration information, and "
"since you can populate that dictionary using different means, you have more "
"options for configuration. For example, you can use a configuration file in "
"JSON format, or, if you have access to YAML processing functionality, a file "
"in YAML format, to populate the configuration dictionary. Or, of course, you "
"can construct the dictionary in Python code, receive it in pickled form over "
"a socket, or use whatever approach makes sense for your application."
msgstr ""
"У Python 3.2 було введено новий засіб конфігурації журналювання, "
"використовуючи словники для зберігання конфігураційної інформації. Це "
"забезпечує надмножину функціональних можливостей підходу на основі "
"конфігураційного файлу, описаного вище, і є рекомендованим методом "
"конфігурації для нових програм і розгортань. Оскільки словник Python "
"використовується для зберігання конфігураційної інформації, і оскільки ви "
"можете заповнювати цей словник різними засобами, у вас є більше можливостей "
"для конфігурації. Наприклад, ви можете використовувати файл конфігурації у "
"форматі JSON або, якщо у вас є доступ до функцій обробки YAML, файл у "
"форматі YAML, щоб заповнити словник конфігурації. Або, звісно, ви можете "
"побудувати словник у коді Python, отримати його в маринованому вигляді через "
"сокет або використати будь-який підхід, який має сенс для вашої програми."

#: ../../howto/logging.rst:756
msgid ""
"Here's an example of the same configuration as above, in YAML format for the "
"new dictionary-based approach:"
msgstr ""
"Ось приклад тієї ж конфігурації, що й вище, у форматі YAML для нового "
"підходу на основі словника:"

#: ../../howto/logging.rst:759
msgid ""
"version: 1\n"
"formatters:\n"
"  simple:\n"
"    format: '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n"
"handlers:\n"
"  console:\n"
"    class: logging.StreamHandler\n"
"    level: DEBUG\n"
"    formatter: simple\n"
"    stream: ext://sys.stdout\n"
"loggers:\n"
"  simpleExample:\n"
"    level: DEBUG\n"
"    handlers: [console]\n"
"    propagate: no\n"
"root:\n"
"  level: DEBUG\n"
"  handlers: [console]"
msgstr ""
"version: 1\n"
"formatters:\n"
"  simple:\n"
"    format: '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n"
"handlers:\n"
"  console:\n"
"    class: logging.StreamHandler\n"
"    level: DEBUG\n"
"    formatter: simple\n"
"    stream: ext://sys.stdout\n"
"loggers:\n"
"  simpleExample:\n"
"    level: DEBUG\n"
"    handlers: [console]\n"
"    propagate: no\n"
"root:\n"
"  level: DEBUG\n"
"  handlers: [console]"

#: ../../howto/logging.rst:780
msgid ""
"For more information about logging using a dictionary, see :ref:`logging-"
"config-api`."
msgstr ""
"Для отримання додаткової інформації про журналювання за допомогою словника "
"див. :ref:`logging-config-api`."

#: ../../howto/logging.rst:784
msgid "What happens if no configuration is provided"
msgstr "O que acontece se nenhuma configuração é fornecida"

#: ../../howto/logging.rst:786
msgid ""
"If no logging configuration is provided, it is possible to have a situation "
"where a logging event needs to be output, but no handlers can be found to "
"output the event."
msgstr ""
"Если конфигурация ведения журнала не указана, возможна ситуация, когда "
"необходимо вывести событие журнала, но не удается найти обработчики для "
"вывода этого события."

#: ../../howto/logging.rst:790
msgid ""
"The event is output using a 'handler of last resort', stored in :data:"
"`lastResort`. This internal handler is not associated with any logger, and "
"acts like a :class:`~logging.StreamHandler` which writes the event "
"description message to the current value of ``sys.stderr`` (therefore "
"respecting any redirections which may be in effect). No formatting is done "
"on the message - just the bare event description message is printed. The "
"handler's level is set to ``WARNING``, so all events at this and greater "
"severities will be output."
msgstr ""
"Событие выводится с использованием «обработчика последней инстанции», "
"хранящегося в :data:`lastResort`. Этот внутренний обработчик не связан ни с "
"каким регистратором и действует как :class:`~logging.StreamHandler`, который "
"записывает сообщение с описанием события в текущее значение ``sys.stderr`` "
"(следовательно, с учетом любых перенаправлений, которые могут быть в "
"эффект). В сообщении не выполняется форматирование — печатается только "
"сообщение с описанием события. Уровень обработчика установлен на "
"«ПРЕДУПРЕЖДЕНИЕ», поэтому будут выводиться все события этой и более "
"серьезной важности."

#: ../../howto/logging.rst:801
msgid "For versions of Python prior to 3.2, the behaviour is as follows:"
msgstr "Para versões do Python anteriores à 3.2, o comportamento é o seguinte:"

#: ../../howto/logging.rst:803
msgid ""
"If :data:`raiseExceptions` is ``False`` (production mode), the event is "
"silently dropped."
msgstr ""
"Если :data:`raiseExceptions` имеет значение ``False`` (рабочий режим), "
"событие автоматически удаляется."

#: ../../howto/logging.rst:806
msgid ""
"If :data:`raiseExceptions` is ``True`` (development mode), a message 'No "
"handlers could be found for logger X.Y.Z' is printed once."
msgstr ""
"Если :data:`raiseExceptions` имеет значение ``True`` (режим разработки), "
"сообщение «Не удалось найти обработчики для регистратора XYZ» выводится один "
"раз."

#: ../../howto/logging.rst:809
msgid ""
"To obtain the pre-3.2 behaviour, :data:`lastResort` can be set to ``None``."
msgstr ""
"Чтобы получить поведение версии до версии 3.2, для :data:`lastResort` можно "
"установить значение ``None``."

#: ../../howto/logging.rst:815
msgid "Configuring Logging for a Library"
msgstr "Налаштування журналювання для бібліотеки"

#: ../../howto/logging.rst:817
msgid ""
"When developing a library which uses logging, you should take care to "
"document how the library uses logging - for example, the names of loggers "
"used. Some consideration also needs to be given to its logging "
"configuration. If the using application does not use logging, and library "
"code makes logging calls, then (as described in the previous section) events "
"of severity ``WARNING`` and greater will be printed to ``sys.stderr``. This "
"is regarded as the best default behaviour."
msgstr ""
"Розробляючи бібліотеку, яка використовує журналювання, ви повинні подбати "
"про документування того, як бібліотека використовує журналювання - "
"наприклад, імена використовуваних журналів. Певну увагу також слід приділити "
"його конфігурації журналювання. Якщо програма, що використовує, не "
"використовує журналювання, а код бібліотеки здійснює виклики журналювання, "
"тоді (як описано в попередньому розділі) події серйозності ``ПОПЕРЕДЖЕННЯ`` "
"і вище будуть надруковані в ``sys.stderr``. Це вважається найкращою "
"поведінкою за умовчанням."

#: ../../howto/logging.rst:825
msgid ""
"If for some reason you *don't* want these messages printed in the absence of "
"any logging configuration, you can attach a do-nothing handler to the top-"
"level logger for your library. This avoids the message being printed, since "
"a handler will always be found for the library's events: it just doesn't "
"produce any output. If the library user configures logging for application "
"use, presumably that configuration will add some handlers, and if levels are "
"suitably configured then logging calls made in library code will send output "
"to those handlers, as normal."
msgstr ""
"Якщо з якоїсь причини ви *не* хочете, щоб ці повідомлення друкувались за "
"відсутності будь-якої конфігурації журналювання, ви можете приєднати "
"обробник нічого не робити до реєстратора верхнього рівня для вашої "
"бібліотеки. Це дозволяє уникнути друку повідомлення, оскільки для подій "
"бібліотеки завжди буде знайдено обробник: він просто не створює жодних "
"виводів. Якщо користувач бібліотеки налаштовує журналювання для використання "
"програмою, імовірно, ця конфігурація додасть деякі обробники, і якщо рівні "
"налаштовано відповідним чином, виклики журналювання, зроблені в коді "
"бібліотеки, надсилатимуть вихідні дані цим обробникам, як зазвичай."

#: ../../howto/logging.rst:834
msgid ""
"A do-nothing handler is included in the logging package: :class:`~logging."
"NullHandler` (since Python 3.1). An instance of this handler could be added "
"to the top-level logger of the logging namespace used by the library (*if* "
"you want to prevent your library's logged events being output to ``sys."
"stderr`` in the absence of logging configuration). If all logging by a "
"library *foo* is done using loggers with names matching 'foo.x', 'foo.x.y', "
"etc. then the code::"
msgstr ""
"Обробник нічого не робиться включено в пакет журналювання: :class:`~logging."
"NullHandler` (починаючи з Python 3.1). Екземпляр цього обробника можна "
"додати до реєстратора верхнього рівня простору імен журналювання, який "
"використовується бібліотекою (*якщо* ви хочете запобігти виведенню "
"зареєстрованих у бібліотеці подій у ``sys.stderr`` за відсутності "
"конфігурації журналювання ). Якщо все журналювання бібліотекою *foo* "
"здійснюється за допомогою реєстраторів з іменами, що відповідають \"foo.x\", "
"\"foo.x.y\" тощо, тоді код::"

#: ../../howto/logging.rst:842
msgid ""
"import logging\n"
"logging.getLogger('foo').addHandler(logging.NullHandler())"
msgstr ""
"import logging\n"
"logging.getLogger('foo').addHandler(logging.NullHandler())"

#: ../../howto/logging.rst:845
msgid ""
"should have the desired effect. If an organisation produces a number of "
"libraries, then the logger name specified can be 'orgname.foo' rather than "
"just 'foo'."
msgstr ""
"має мати бажаний ефект. Якщо організація виробляє декілька бібліотек, то "
"ім’я реєстратора може бути \"orgname.foo\", а не просто \"foo\"."

#: ../../howto/logging.rst:849
msgid ""
"It is strongly advised that you *do not log to the root logger* in your "
"library. Instead, use a logger with a unique and easily identifiable name, "
"such as the ``__name__`` for your library's top-level package or module. "
"Logging to the root logger will make it difficult or impossible for the "
"application developer to configure the logging verbosity or handlers of your "
"library as they wish."
msgstr ""
"Настоятельно рекомендуется *не входить в корневой регистратор* вашей "
"библиотеки. Вместо этого используйте средство ведения журнала с уникальным и "
"легко идентифицируемым именем, например ``__name__`` для пакета или модуля "
"верхнего уровня вашей библиотеки. Ведение журнала в корневом регистраторе "
"затруднит или сделает невозможным для разработчика приложения настройку "
"подробностей журналирования или обработчиков вашей библиотеки по своему "
"усмотрению."

#: ../../howto/logging.rst:856
msgid ""
"It is strongly advised that you *do not add any handlers other than* :class:"
"`~logging.NullHandler` *to your library's loggers*. This is because the "
"configuration of handlers is the prerogative of the application developer "
"who uses your library. The application developer knows their target audience "
"and what handlers are most appropriate for their application: if you add "
"handlers 'under the hood', you might well interfere with their ability to "
"carry out unit tests and deliver logs which suit their requirements."
msgstr ""
"Настійно рекомендується *не додавати жодних обробників, окрім* :class:"
"`~logging.NullHandler` *до реєстраторів вашої бібліотеки*. Це пояснюється "
"тим, що конфігурація обробників є прерогативою розробника програми, який "
"використовує вашу бібліотеку. Розробник програми знає свою цільову аудиторію "
"та знає, які обробники найбільше підходять для їхньої програми: якщо ви "
"додасте обробники \"під капотом\", ви цілком можете втрутитися в їх "
"здатність виконувати модульні тести та доставляти журнали, які відповідають "
"їхнім вимогам."

#: ../../howto/logging.rst:867
msgid "Logging Levels"
msgstr "Níveis de Logging"

#: ../../howto/logging.rst:869
msgid ""
"The numeric values of logging levels are given in the following table. These "
"are primarily of interest if you want to define your own levels, and need "
"them to have specific values relative to the predefined levels. If you "
"define a level with the same numeric value, it overwrites the predefined "
"value; the predefined name is lost."
msgstr ""
"Os valores númericos dos níveis de logging estão listados na tabela abaixo. "
"Eles são principalmente de interesse se você quiser definir seus próprios "
"níveis, e precisa deles para definir seus valores específicos relativos aos "
"níveis predefinidos. Se você define um nível com o mesmo valor númerico, ele "
"sobreescreve o valor predefinido; o nome predefinido é perdido."

#: ../../howto/logging.rst:876
msgid "Numeric value"
msgstr "Valor numérico"

#: ../../howto/logging.rst:878
msgid "50"
msgstr "50"

#: ../../howto/logging.rst:880
msgid "40"
msgstr "40"

#: ../../howto/logging.rst:882
msgid "30"
msgstr "30"

#: ../../howto/logging.rst:884
msgid "20"
msgstr "20"

#: ../../howto/logging.rst:886
msgid "10"
msgstr "10"

#: ../../howto/logging.rst:888
msgid "``NOTSET``"
msgstr "``NOTSET``"

#: ../../howto/logging.rst:888
msgid "0"
msgstr "0"

#: ../../howto/logging.rst:891
msgid ""
"Levels can also be associated with loggers, being set either by the "
"developer or through loading a saved logging configuration. When a logging "
"method is called on a logger, the logger compares its own level with the "
"level associated with the method call. If the logger's level is higher than "
"the method call's, no logging message is actually generated. This is the "
"basic mechanism controlling the verbosity of logging output."
msgstr ""
"Рівні також можуть бути пов’язані з реєстраторами, які встановлюються "
"розробником або через завантаження збереженої конфігурації журналювання. "
"Коли в реєстраторі викликається метод ведення журналу, реєстратор порівнює "
"свій власний рівень із рівнем, пов’язаним із викликом методу. Якщо рівень "
"реєстратора вищий, ніж виклик методу, повідомлення журналу фактично не "
"генерується. Це основний механізм, який контролює докладність вихідних даних "
"журналу."

#: ../../howto/logging.rst:898
msgid ""
"Logging messages are encoded as instances of the :class:`~logging.LogRecord` "
"class. When a logger decides to actually log an event, a :class:`~logging."
"LogRecord` instance is created from the logging message."
msgstr ""
"Повідомлення журналу кодуються як екземпляри класу :class:`~logging."
"LogRecord`. Коли реєстратор вирішує фактично зареєструвати подію, екземпляр :"
"class:`~logging.LogRecord` створюється з повідомлення журналу."

#: ../../howto/logging.rst:902
msgid ""
"Logging messages are subjected to a dispatch mechanism through the use of :"
"dfn:`handlers`, which are instances of subclasses of the :class:`Handler` "
"class. Handlers are responsible for ensuring that a logged message (in the "
"form of a :class:`LogRecord`) ends up in a particular location (or set of "
"locations) which is useful for the target audience for that message (such as "
"end users, support desk staff, system administrators, developers). Handlers "
"are passed :class:`LogRecord` instances intended for particular "
"destinations. Each logger can have zero, one or more handlers associated "
"with it (via the :meth:`~Logger.addHandler` method of :class:`Logger`). In "
"addition to any handlers directly associated with a logger, *all handlers "
"associated with all ancestors of the logger* are called to dispatch the "
"message (unless the *propagate* flag for a logger is set to a false value, "
"at which point the passing to ancestor handlers stops)."
msgstr ""
"Повідомлення журналювання підлягають механізму відправлення за допомогою :"
"dfn:`handlers`, які є екземплярами підкласів класу :class:`Handler`. "
"Обробники відповідають за те, щоб зареєстроване повідомлення (у формі :class:"
"`LogRecord`) потрапляло в певне місце (або набір місць), яке є корисним для "
"цільової аудиторії цього повідомлення (наприклад, кінцевих користувачів, "
"співробітники служби підтримки, системні адміністратори, розробники). "
"Обробники передають екземпляри :class:`LogRecord`, призначені для певних "
"місць призначення. Кожен реєстратор може мати нуль, один або більше "
"пов’язаних з ним обробників (через метод :meth:`~Logger.addHandler` :class:"
"`Logger`). На додаток до будь-яких обробників, безпосередньо пов’язаних із "
"реєстратором, *усі обробники, пов’язані з усіма предками реєстратора* "
"викликаються для надсилання повідомлення (якщо прапор *розповсюдження* для "
"реєстратора не має значення false, після чого передача до обробників предків "
"зупиняється)."

#: ../../howto/logging.rst:916
msgid ""
"Just as for loggers, handlers can have levels associated with them. A "
"handler's level acts as a filter in the same way as a logger's level does. "
"If a handler decides to actually dispatch an event, the :meth:`~Handler."
"emit` method is used to send the message to its destination. Most user-"
"defined subclasses of :class:`Handler` will need to override this :meth:"
"`~Handler.emit`."
msgstr ""
"Як і для реєстраторів, обробники можуть мати пов’язані з ними рівні. Рівень "
"обробника діє як фільтр так само, як і рівень реєстратора. Якщо обробник "
"вирішує фактично відправити подію, метод :meth:`~Handler.emit` "
"використовується для надсилання повідомлення до місця призначення. Більшість "
"визначених користувачем підкласів :class:`Handler` повинні замінити цей :"
"meth:`~Handler.emit`."

#: ../../howto/logging.rst:925
msgid "Custom Levels"
msgstr "Спеціальні рівні"

#: ../../howto/logging.rst:927
msgid ""
"Defining your own levels is possible, but should not be necessary, as the "
"existing levels have been chosen on the basis of practical experience. "
"However, if you are convinced that you need custom levels, great care should "
"be exercised when doing this, and it is possibly *a very bad idea to define "
"custom levels if you are developing a library*. That's because if multiple "
"library authors all define their own custom levels, there is a chance that "
"the logging output from such multiple libraries used together will be "
"difficult for the using developer to control and/or interpret, because a "
"given numeric value might mean different things for different libraries."
msgstr ""
"Визначення власних рівнів можливо, але це не обов’язково, оскільки існуючі "
"рівні було обрано на основі практичного досвіду. Однак, якщо ви впевнені, що "
"вам потрібні користувацькі рівні, слід бути дуже обережним, роблячи це, і "
"це, можливо, *дуже погана ідея визначати користувацькі рівні, якщо ви "
"розробляєте бібліотеку*. Це тому, що якщо кілька авторів бібліотек "
"визначають власні власні рівні, існує ймовірність того, що вихід журналу з "
"таких кількох бібліотек, які використовуються разом, розробнику буде важко "
"контролювати та/або інтерпретувати, оскільки дане числове значення може "
"означати різні речі для різних бібліотек."

#: ../../howto/logging.rst:940
msgid "Useful Handlers"
msgstr "Корисні обробники"

#: ../../howto/logging.rst:942
msgid ""
"In addition to the base :class:`Handler` class, many useful subclasses are "
"provided:"
msgstr ""
"Em adição à classe base :class:`Handler`, muitas subclasses úteis são "
"fornecidas:"

#: ../../howto/logging.rst:945
msgid ""
":class:`StreamHandler` instances send messages to streams (file-like "
"objects)."
msgstr ""
"Екземпляри :class:`StreamHandler` надсилають повідомлення до потоків "
"(файлоподібних об’єктів)."

#: ../../howto/logging.rst:948
msgid ":class:`FileHandler` instances send messages to disk files."
msgstr ""
"Екземпляри :class:`FileHandler` надсилають повідомлення до файлів на диску."

#: ../../howto/logging.rst:950
msgid ""
":class:`~handlers.BaseRotatingHandler` is the base class for handlers that "
"rotate log files at a certain point. It is not meant to be  instantiated "
"directly. Instead, use :class:`~handlers.RotatingFileHandler` or :class:"
"`~handlers.TimedRotatingFileHandler`."
msgstr ""
":class:`~handlers.BaseRotatingHandler` — це базовий клас для обробників, які "
"обертають файли журналів у певний момент. Він не призначений для "
"безпосереднього створення екземпляра. Замість цього використовуйте :class:"
"`~handlers.RotatingFileHandler` або :class:`~handlers."
"TimedRotatingFileHandler`."

#: ../../howto/logging.rst:955
msgid ""
":class:`~handlers.RotatingFileHandler` instances send messages to disk "
"files, with support for maximum log file sizes and log file rotation."
msgstr ""
"Екземпляри :class:`~handlers.RotatingFileHandler` надсилають повідомлення до "
"файлів на диску з підтримкою максимального розміру файлу журналу та ротації "
"файлів журналу."

#: ../../howto/logging.rst:958
msgid ""
":class:`~handlers.TimedRotatingFileHandler` instances send messages to disk "
"files, rotating the log file at certain timed intervals."
msgstr ""
":class:`~handlers.TimedRotatingFileHandler` екземпляри надсилають "
"повідомлення до дискових файлів, чергуючи файл журналу через певні проміжки "
"часу."

#: ../../howto/logging.rst:961
msgid ""
":class:`~handlers.SocketHandler` instances send messages to TCP/IP sockets. "
"Since 3.4, Unix domain sockets are also supported."
msgstr ""
"Екземпляри :class:`~handlers.SocketHandler` надсилають повідомлення до "
"сокетів TCP/IP. Починаючи з версії 3.4, також підтримуються доменні сокети "
"Unix."

#: ../../howto/logging.rst:964
msgid ""
":class:`~handlers.DatagramHandler` instances send messages to UDP sockets. "
"Since 3.4, Unix domain sockets are also supported."
msgstr ""
"Екземпляри :class:`~handlers.DatagramHandler` надсилають повідомлення до UDP-"
"сокетів. Починаючи з версії 3.4, також підтримуються доменні сокети Unix."

#: ../../howto/logging.rst:967
msgid ""
":class:`~handlers.SMTPHandler` instances send messages to a designated email "
"address."
msgstr ""
"Екземпляри :class:`~handlers.SMTPHandler` надсилають повідомлення на вказану "
"електронну адресу."

#: ../../howto/logging.rst:970
msgid ""
":class:`~handlers.SysLogHandler` instances send messages to a Unix syslog "
"daemon, possibly on a remote machine."
msgstr ""
"Екземпляри :class:`~handlers.SysLogHandler` надсилають повідомлення до "
"демона системного журналу Unix, можливо, на віддаленій машині."

#: ../../howto/logging.rst:973
msgid ""
":class:`~handlers.NTEventLogHandler` instances send messages to a Windows "
"NT/2000/XP event log."
msgstr ""
"Екземпляри :class:`~handlers.NTEventLogHandler` надсилають повідомлення до "
"журналу подій Windows NT/2000/XP."

#: ../../howto/logging.rst:976
msgid ""
":class:`~handlers.MemoryHandler` instances send messages to a buffer in "
"memory, which is flushed whenever specific criteria are met."
msgstr ""
"Екземпляри :class:`~handlers.MemoryHandler` надсилають повідомлення до "
"буфера в пам’яті, який очищається щоразу, коли виконуються певні критерії."

#: ../../howto/logging.rst:979
msgid ""
":class:`~handlers.HTTPHandler` instances send messages to an HTTP server "
"using either ``GET`` or ``POST`` semantics."
msgstr ""
"Екземпляри :class:`~handlers.HTTPHandler` надсилають повідомлення на сервер "
"HTTP, використовуючи семантику ``GET`` або ``POST``."

#: ../../howto/logging.rst:982
msgid ""
":class:`~handlers.WatchedFileHandler` instances watch the file they are "
"logging to. If the file changes, it is closed and reopened using the file "
"name. This handler is only useful on Unix-like systems; Windows does not "
"support the underlying mechanism used."
msgstr ""
"Екземпляри :class:`~handlers.WatchedFileHandler` спостерігають за файлом, до "
"якого вони входять. Якщо файл змінюється, він закривається та знову "
"відкривається з використанням імені файлу. Цей обробник корисний лише в Unix-"
"подібних системах; Windows не підтримує використовуваний основний механізм."

#: ../../howto/logging.rst:987
msgid ""
":class:`~handlers.QueueHandler` instances send messages to a queue, such as "
"those implemented in the :mod:`queue` or :mod:`multiprocessing` modules."
msgstr ""
"Екземпляри :class:`~handlers.QueueHandler` надсилають повідомлення до черги, "
"як-от реалізовані в модулях :mod:`queue` або :mod:`multiprocessing`."

#: ../../howto/logging.rst:990
msgid ""
":class:`NullHandler` instances do nothing with error messages. They are used "
"by library developers who want to use logging, but want to avoid the 'No "
"handlers could be found for logger *XXX*' message which can be displayed if "
"the library user has not configured logging. See :ref:`library-config` for "
"more information."
msgstr ""
"Экземпляры :class:`NullHandler` ничего не делают с сообщениями об ошибках. "
"Они используются разработчиками библиотек, которые хотят использовать "
"ведение журнала, но хотят избежать сообщения «Не удалось найти обработчики "
"для средства ведения журнала *XXX*», которое может отображаться, если "
"пользователь библиотеки не настроил ведение журнала. Дополнительную "
"информацию смотрите в :ref:`library-config`."

#: ../../howto/logging.rst:996
msgid "The :class:`NullHandler` class."
msgstr "A classe :class:`NullHandler`."

#: ../../howto/logging.rst:999
msgid "The :class:`~handlers.QueueHandler` class."
msgstr "A classe :class:`~handlers.QueueHandler`."

#: ../../howto/logging.rst:1002
msgid ""
"The :class:`NullHandler`, :class:`StreamHandler` and :class:`FileHandler` "
"classes are defined in the core logging package. The other handlers are "
"defined in a sub-module, :mod:`logging.handlers`. (There is also another sub-"
"module, :mod:`logging.config`, for configuration functionality.)"
msgstr ""
"Класи :class:`NullHandler`, :class:`StreamHandler` і :class:`FileHandler` "
"визначені в базовому пакеті журналювання. Інші обробники визначені в "
"підмодулі :mod:`logging.handlers`. (Існує також інший підмодуль, :mod:"
"`logging.config`, для функціональних можливостей налаштування.)"

#: ../../howto/logging.rst:1007
msgid ""
"Logged messages are formatted for presentation through instances of the :"
"class:`Formatter` class. They are initialized with a format string suitable "
"for use with the % operator and a dictionary."
msgstr ""
"Зареєстровані повідомлення форматуються для представлення через екземпляри "
"класу :class:`Formatter`. Вони ініціалізуються рядком формату, придатним для "
"використання з оператором % і словником."

#: ../../howto/logging.rst:1011
msgid ""
"For formatting multiple messages in a batch, instances of :class:"
"`BufferingFormatter` can be used. In addition to the format string (which is "
"applied to each message in the batch), there is provision for header and "
"trailer format strings."
msgstr ""
"Для форматирования нескольких сообщений в пакете можно использовать "
"экземпляры :class:`BufferingFormatter`. В дополнение к строке формата "
"(которая применяется к каждому сообщению в пакете) предусмотрены строки "
"формата заголовка и концевика."

#: ../../howto/logging.rst:1016
msgid ""
"When filtering based on logger level and/or handler level is not enough, "
"instances of :class:`Filter` can be added to both :class:`Logger` and :class:"
"`Handler` instances (through their :meth:`~Handler.addFilter` method). "
"Before deciding to process a message further, both loggers and handlers "
"consult all their filters for permission. If any filter returns a false "
"value, the message is not processed further."
msgstr ""
"Якщо фільтрації на основі рівня реєстратора та/або рівня обробника "
"недостатньо, екземпляри :class:`Filter` можна додати до екземплярів :class:"
"`Logger` і :class:`Handler` (через їх метод :meth:`~Handler.addFilter`). "
"Перш ніж вирішити продовжити обробку повідомлення, і реєстратори, і "
"обробники звертаються до всіх своїх фільтрів для отримання дозволу. Якщо "
"будь-який фільтр повертає хибне значення, повідомлення не обробляється далі."

#: ../../howto/logging.rst:1023
msgid ""
"The basic :class:`Filter` functionality allows filtering by specific logger "
"name. If this feature is used, messages sent to the named logger and its "
"children are allowed through the filter, and all others dropped."
msgstr ""
"Основна функція :class:`Filter` дозволяє фільтрувати за певним іменем "
"реєстратора. Якщо використовується ця функція, повідомлення, надіслані до "
"названого реєстратора та його дочірніх елементів, пропускаються через "
"фільтр, а всі інші відкидаються."

#: ../../howto/logging.rst:1031
msgid "Exceptions raised during logging"
msgstr "Exceções levantadas durante logging"

#: ../../howto/logging.rst:1033
msgid ""
"The logging package is designed to swallow exceptions which occur while "
"logging in production. This is so that errors which occur while handling "
"logging events - such as logging misconfiguration, network or other similar "
"errors - do not cause the application using logging to terminate prematurely."
msgstr ""
"Пакет журналювання призначений для ковтання винятків, які виникають під час "
"входу в робочу систему. Це зроблено для того, щоб помилки, які виникають під "
"час обробки подій журналювання (наприклад, неправильна конфігурація журналу, "
"мережа чи інші подібні помилки), не призвели до передчасного завершення "
"програми, яка використовує журналювання."

#: ../../howto/logging.rst:1038
msgid ""
":class:`SystemExit` and :class:`KeyboardInterrupt` exceptions are never "
"swallowed. Other exceptions which occur during the :meth:`~Handler.emit` "
"method of a :class:`Handler` subclass are passed to its :meth:`~Handler."
"handleError` method."
msgstr ""
"Винятки :class:`SystemExit` і :class:`KeyboardInterrupt` ніколи не "
"проковтуються. Інші винятки, які виникають під час методу :meth:`~Handler."
"emit` підкласу :class:`Handler`, передаються до його методу :meth:`~Handler."
"handleError`."

#: ../../howto/logging.rst:1043
msgid ""
"The default implementation of :meth:`~Handler.handleError` in :class:"
"`Handler` checks to see if a module-level variable, :data:`raiseExceptions`, "
"is set. If set, a traceback is printed to :data:`sys.stderr`. If not set, "
"the exception is swallowed."
msgstr ""
"Стандартна реалізація :meth:`~Handler.handleError` в :class:`Handler` "
"перевіряє, чи встановлено змінну рівня модуля, :data:`raiseExceptions`. Якщо "
"встановлено, зворотне відстеження друкується в :data:`sys.stderr`. Якщо не "
"встановлено, виняток проковтується."

#: ../../howto/logging.rst:1049
msgid ""
"The default value of :data:`raiseExceptions` is ``True``. This is because "
"during development, you typically want to be notified of any exceptions that "
"occur. It's advised that you set :data:`raiseExceptions` to ``False`` for "
"production usage."
msgstr ""
"Значенням за замовчуванням :data:`raiseExceptions` є ``True``. Це "
"пояснюється тим, що під час розробки ви зазвичай хочете отримувати "
"сповіщення про будь-які винятки, які трапляються. Радимо встановити :data:"
"`raiseExceptions` на ``False`` для використання у робочому режимі."

#: ../../howto/logging.rst:1059
msgid "Using arbitrary objects as messages"
msgstr "Usando objetos arbitrários como mensagens"

#: ../../howto/logging.rst:1061
msgid ""
"In the preceding sections and examples, it has been assumed that the message "
"passed when logging the event is a string. However, this is not the only "
"possibility. You can pass an arbitrary object as a message, and its :meth:"
"`~object.__str__` method will be called when the logging system needs to "
"convert it to a string representation. In fact, if you want to, you can "
"avoid computing a string representation altogether - for example, the :class:"
"`~handlers.SocketHandler` emits an event by pickling it and sending it over "
"the wire."
msgstr ""
"У попередніх розділах і прикладах передбачалося, що повідомлення, передане "
"під час реєстрації події, є рядком. Однак це не єдина можливість. Ви можете "
"передати довільний об’єкт як повідомлення, і його метод :meth:`~object."
"__str__` буде викликано, коли системі журналювання потрібно перетворити його "
"на представлення рядка. Насправді, якщо ви хочете, ви можете взагалі "
"уникнути обчислення представлення рядка - наприклад, :class:`~handlers."
"SocketHandler` випромінює подію, вибираючи її та надсилаючи по дроту."

#: ../../howto/logging.rst:1072
msgid "Optimization"
msgstr "Optimização"

#: ../../howto/logging.rst:1074
msgid ""
"Formatting of message arguments is deferred until it cannot be avoided. "
"However, computing the arguments passed to the logging method can also be "
"expensive, and you may want to avoid doing it if the logger will just throw "
"away your event. To decide what to do, you can call the :meth:`~Logger."
"isEnabledFor` method which takes a level argument and returns true if the "
"event would be created by the Logger for that level of call. You can write "
"code like this::"
msgstr ""
"Форматування аргументів повідомлення відкладено, доки його не можна "
"уникнути. Однак обчислення аргументів, переданих до методу журналювання, "
"також може бути дорогим, і ви можете уникнути цього, якщо реєстратор просто "
"відкине вашу подію. Щоб вирішити, що робити, ви можете викликати метод :meth:"
"`~Logger.isEnabledFor`, який приймає аргумент рівня та повертає значення "
"true, якщо подію буде створено реєстратором для цього рівня виклику. Ви "
"можете написати такий код:"

#: ../../howto/logging.rst:1082
msgid ""
"if logger.isEnabledFor(logging.DEBUG):\n"
"    logger.debug('Message with %s, %s', expensive_func1(),\n"
"                                        expensive_func2())"
msgstr ""
"if logger.isEnabledFor(logging.DEBUG):\n"
"    logger.debug('Message with %s, %s', expensive_func1(),\n"
"                                        expensive_func2())"

#: ../../howto/logging.rst:1086
msgid ""
"so that if the logger's threshold is set above ``DEBUG``, the calls to "
"``expensive_func1`` and ``expensive_func2`` are never made."
msgstr ""
"так что если порог регистратора установлен выше DEBUG, вызовы "
"expensive_func1 иexpensive_func2 никогда не выполняются."

#: ../../howto/logging.rst:1089
msgid ""
"In some cases, :meth:`~Logger.isEnabledFor` can itself be more expensive "
"than you'd like (e.g. for deeply nested loggers where an explicit level is "
"only set high up in the logger hierarchy). In such cases (or if you want to "
"avoid calling a method in tight loops), you can cache the result of a call "
"to :meth:`~Logger.isEnabledFor` in a local or instance variable, and use "
"that instead of calling the method each time. Such a cached value would only "
"need to be recomputed when the logging configuration changes dynamically "
"while the application is running (which is not all that common)."
msgstr ""
"У деяких випадках :meth:`~Logger.isEnabledFor` сам по собі може бути "
"дорожчим, ніж вам хотілося б (наприклад, для глибоко вкладених реєстраторів, "
"де явний рівень встановлюється лише високо в ієрархії реєстратора). У таких "
"випадках (або якщо ви хочете уникнути виклику методу в жорстких циклах), ви "
"можете кешувати результат виклику :meth:`~Logger.isEnabledFor` у локальній "
"змінній чи змінній екземпляра та використовувати це замість виклику метод "
"кожного разу. Таке кешоване значення потрібно було б повторно обчислити лише "
"тоді, коли конфігурація журналювання динамічно змінюється під час роботи "
"програми (що не так вже й часто)."

#: ../../howto/logging.rst:1098
msgid ""
"There are other optimizations which can be made for specific applications "
"which need more precise control over what logging information is collected. "
"Here's a list of things you can do to avoid processing during logging which "
"you don't need:"
msgstr ""
"Існують інші оптимізації, які можна зробити для конкретних програм, які "
"потребують більш точного контролю над тим, яка інформація журналу "
"збирається. Ось список речей, які ви можете зробити, щоб уникнути обробки "
"під час журналювання, яка вам не потрібна:"

#: ../../howto/logging.rst:1104
msgid "What you don't want to collect"
msgstr "O que você não quer coletar"

#: ../../howto/logging.rst:1104
msgid "How to avoid collecting it"
msgstr "Як уникнути його збору"

#: ../../howto/logging.rst:1106
msgid "Information about where calls were made from."
msgstr "Інформація про те, звідки дзвонили."

#: ../../howto/logging.rst:1106
msgid ""
"Set ``logging._srcfile`` to ``None``. This avoids calling :func:`sys."
"_getframe`, which may help to speed up your code in environments like PyPy "
"(which can't speed up code that uses :func:`sys._getframe`)."
msgstr ""
"Встановіть для ``logging._srcfile`` значення ``None``. Це дозволяє уникнути "
"виклику :func:`sys._getframe`, що може допомогти пришвидшити ваш код у таких "
"середовищах, як PyPy (який не може прискорити код, який використовує :func:"
"`sys._getframe`)."

#: ../../howto/logging.rst:1112
msgid "Threading information."
msgstr "Інформація про потоки."

#: ../../howto/logging.rst:1112
msgid "Set ``logging.logThreads`` to ``False``."
msgstr "Встановіть для ``logging.logThreads`` значення ``False``."

#: ../../howto/logging.rst:1114
msgid "Current process ID (:func:`os.getpid`)"
msgstr "Ідентифікатор поточного процесу (:func:`os.getpid`)"

#: ../../howto/logging.rst:1114
msgid "Set ``logging.logProcesses`` to ``False``."
msgstr "Встановіть для ``logging.logProcesses`` значення ``False``."

#: ../../howto/logging.rst:1116
msgid ""
"Current process name when using ``multiprocessing`` to manage multiple "
"processes."
msgstr ""
"Поточне ім’я процесу, якщо для керування кількома процесами використовується "
"``багатопроцесорна обробка``."

#: ../../howto/logging.rst:1116
msgid "Set ``logging.logMultiprocessing`` to ``False``."
msgstr "Встановіть для ``logging.logMultiprocessing`` значення ``False``."

#: ../../howto/logging.rst:1119
msgid "Current :class:`asyncio.Task` name when using ``asyncio``."
msgstr "Текущее имя :class:`asyncio.Task` при использовании ``asyncio``."

#: ../../howto/logging.rst:1119
msgid "Set ``logging.logAsyncioTasks`` to ``False``."
msgstr "Установите для logging.logAsyncioTasks значение False."

#: ../../howto/logging.rst:1123
msgid ""
"Also note that the core logging module only includes the basic handlers. If "
"you don't import :mod:`logging.handlers` and :mod:`logging.config`, they "
"won't take up any memory."
msgstr ""
"Також зауважте, що основний модуль журналювання включає лише основні "
"обробники. Якщо ви не імпортуєте :mod:`logging.handlers` і :mod:`logging."
"config`, вони не займатимуть жодної пам’яті."

#: ../../howto/logging.rst:1130
msgid "Other resources"
msgstr "Outros recursos"

#: ../../howto/logging.rst:1134
msgid "Module :mod:`logging`"
msgstr "Módulo :mod:`logging`"

#: ../../howto/logging.rst:1135
msgid "API reference for the logging module."
msgstr "Referência da API para o módulo de logging."

#: ../../howto/logging.rst:1137
msgid "Module :mod:`logging.config`"
msgstr "Módulo :mod:`logging.config`"

#: ../../howto/logging.rst:1138
msgid "Configuration API for the logging module."
msgstr "API de configuração para o módulo logging."

#: ../../howto/logging.rst:1140
msgid "Module :mod:`logging.handlers`"
msgstr "Módulo :mod:`logging.handlers`"

#: ../../howto/logging.rst:1141
msgid "Useful handlers included with the logging module."
msgstr "Tratadores úteis incluídos no módulo logging."

#: ../../howto/logging.rst:1143
msgid ":ref:`A logging cookbook <logging-cookbook>`"
msgstr ":ref:`Um livro de receitas do logging <logging-cookbook>`"

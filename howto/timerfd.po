# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Raphael Mendonça, 2024
# Adorilson Bezerra <adorilson@gmail.com>, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 14:16+0000\n"
"PO-Revision-Date: 2024-05-11 01:08+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../howto/timerfd.rst:5
msgid "timer file descriptor HOWTO"
msgstr "Descritor de arquivo de temporizador"

#: ../../howto/timerfd.rst:0
msgid "Release"
msgstr "Versão"

#: ../../howto/timerfd.rst:7
msgid "1.13"
msgstr "1.13"

#: ../../howto/timerfd.rst:9
msgid ""
"This HOWTO discusses Python's support for the linux timer file descriptor."
msgstr ""
"Este documento discute o suporte do Python para o descritor de arquivo de "
"temporizador do Linux."

#: ../../howto/timerfd.rst:13
msgid "Examples"
msgstr "Exemplos"

#: ../../howto/timerfd.rst:15
msgid ""
"The following example shows how to use a timer file descriptor to execute a "
"function twice a second:"
msgstr ""
"O exemplo a seguir mostra como usar um descritor de arquivo de temporizador "
"para executar uma função duas vezes por segundo:"

#: ../../howto/timerfd.rst:18
msgid ""
"# Practical scripts should use really use a non-blocking timer,\n"
"# we use a blocking timer here for simplicity.\n"
"import os, time\n"
"\n"
"# Create the timer file descriptor\n"
"fd = os.timerfd_create(time.CLOCK_REALTIME)\n"
"\n"
"# Start the timer in 1 second, with an interval of half a second\n"
"os.timerfd_settime(fd, initial=1, interval=0.5)\n"
"\n"
"try:\n"
"    # Process timer events four times.\n"
"    for _ in range(4):\n"
"        # read() will block until the timer expires\n"
"        _ = os.read(fd, 8)\n"
"        print(\"Timer expired\")\n"
"finally:\n"
"    # Remember to close the timer file descriptor!\n"
"    os.close(fd)"
msgstr ""
"# Scripts práticos devem realmente usar um timer sem bloqueio.\n"
"# Usamos um timer com bloqueio aqui para simplificar.\n"
"import os, time\n"
"\n"
"# Cria um descritor de arquivo de temporizador\n"
"fd = os.timerfd_create(time.CLOCK_REALTIME)\n"
"\n"
"# Inicia o temporizador em 1 segundo, com um intervalo de meio segundo\n"
"os.timerfd_settime(fd, initial=1, interval=0.5)\n"
"\n"
"try:\n"
"    # Processa eventos do temporizador quatro vezes.\n"
"    for _ in range(4):\n"
"        # read() ser bloqueado até o temporizador expirar\n"
"        _ = os.read(fd, 8)\n"
"        print(\"Timer expired\")\n"
"finally:\n"
"    # Lembre-se de fechar o descritor de arquivo de temporizador!\n"
"    os.close(fd)"

#: ../../howto/timerfd.rst:40
msgid ""
"To avoid the precision loss caused by the :class:`float` type, timer file "
"descriptors allow specifying initial expiration and interval in integer "
"nanoseconds with ``_ns`` variants of the functions."
msgstr ""
"Para evitar a perda de precisão causada pelo tipo :class:`float`, os "
"descritores de arquivos de temporizador permitem especificar a expiração "
"inicial e o intervalo em nanossegundos inteiros com variantes ``_ns`` das "
"funções."

#: ../../howto/timerfd.rst:44
msgid ""
"This example shows how :func:`~select.epoll` can be used with timer file "
"descriptors to wait until the file descriptor is ready for reading:"
msgstr ""
"Este exemplo mostra como :func:`~select.epoll` pode ser usado com "
"descritores de arquivo de temporizador para esperar até que o descritor de "
"arquivo esteja pronto para leitura:"

#: ../../howto/timerfd.rst:47
msgid ""
"import os, time, select, socket, sys\n"
"\n"
"# Create an epoll object\n"
"ep = select.epoll()\n"
"\n"
"# In this example, use loopback address to send \"stop\" command to the "
"server.\n"
"#\n"
"# $ telnet 127.0.0.1 1234\n"
"# Trying 127.0.0.1...\n"
"# Connected to 127.0.0.1.\n"
"# Escape character is '^]'.\n"
"# stop\n"
"# Connection closed by foreign host.\n"
"#\n"
"sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"sock.bind((\"127.0.0.1\", 1234))\n"
"sock.setblocking(False)\n"
"sock.listen(1)\n"
"ep.register(sock, select.EPOLLIN)\n"
"\n"
"# Create timer file descriptors in non-blocking mode.\n"
"num = 3\n"
"fds = []\n"
"for _ in range(num):\n"
"    fd = os.timerfd_create(time.CLOCK_REALTIME, flags=os.TFD_NONBLOCK)\n"
"    fds.append(fd)\n"
"    # Register the timer file descriptor for read events\n"
"    ep.register(fd, select.EPOLLIN)\n"
"\n"
"# Start the timer with os.timerfd_settime_ns() in nanoseconds.\n"
"# Timer 1 fires every 0.25 seconds; timer 2 every 0.5 seconds; etc\n"
"for i, fd in enumerate(fds, start=1):\n"
"    one_sec_in_nsec = 10**9\n"
"    i = i * one_sec_in_nsec\n"
"    os.timerfd_settime_ns(fd, initial=i//4, interval=i//4)\n"
"\n"
"timeout = 3\n"
"try:\n"
"    conn = None\n"
"    is_active = True\n"
"    while is_active:\n"
"        # Wait for the timer to expire for 3 seconds.\n"
"        # epoll.poll() returns a list of (fd, event) pairs.\n"
"        # fd is a file descriptor.\n"
"        # sock and conn[=returned value of socket.accept()] are socket "
"objects, not file descriptors.\n"
"        # So use sock.fileno() and conn.fileno() to get the file "
"descriptors.\n"
"        events = ep.poll(timeout)\n"
"\n"
"        # If more than one timer file descriptors are ready for reading at "
"once,\n"
"        # epoll.poll() returns a list of (fd, event) pairs.\n"
"        #\n"
"        # In this example settings,\n"
"        #    1st timer fires every 0.25 seconds in 0.25 seconds. (0.25, 0.5, "
"0.75, 1.0, ...)\n"
"        #    2nd timer every 0.5 seconds in 0.5 seconds. (0.5, 1.0, 1.5, "
"2.0, ...)\n"
"        #    3rd timer every 0.75 seconds in 0.75 seconds. (0.75, 1.5, 2.25, "
"3.0, ...)\n"
"        #\n"
"        #    In 0.25 seconds, only 1st timer fires.\n"
"        #    In 0.5 seconds, 1st timer and 2nd timer fires at once.\n"
"        #    In 0.75 seconds, 1st timer and 3rd timer fires at once.\n"
"        #    In 1.5 seconds, 1st timer, 2nd timer and 3rd timer fires at "
"once.\n"
"        #\n"
"        # If a timer file descriptor is signaled more than once since\n"
"        # the last os.read() call, os.read() returns the number of signaled\n"
"        # as host order of class bytes.\n"
"        print(f\"Signaled events={events}\")\n"
"        for fd, event in events:\n"
"            if event & select.EPOLLIN:\n"
"                if fd == sock.fileno():\n"
"                    # Check if there is a connection request.\n"
"                    print(f\"Accepting connection {fd}\")\n"
"                    conn, addr = sock.accept()\n"
"                    conn.setblocking(False)\n"
"                    print(f\"Accepted connection {conn} from {addr}\")\n"
"                    ep.register(conn, select.EPOLLIN)\n"
"                elif conn and fd == conn.fileno():\n"
"                    # Check if there is data to read.\n"
"                    print(f\"Reading data {fd}\")\n"
"                    data = conn.recv(1024)\n"
"                    if data:\n"
"                        # You should catch UnicodeDecodeError exception for "
"safety.\n"
"                        cmd = data.decode()\n"
"                        if cmd.startswith(\"stop\"):\n"
"                            print(f\"Stopping server\")\n"
"                            is_active = False\n"
"                        else:\n"
"                            print(f\"Unknown command: {cmd}\")\n"
"                    else:\n"
"                        # No more data, close connection\n"
"                        print(f\"Closing connection {fd}\")\n"
"                        ep.unregister(conn)\n"
"                        conn.close()\n"
"                        conn = None\n"
"                elif fd in fds:\n"
"                    print(f\"Reading timer {fd}\")\n"
"                    count = int.from_bytes(os.read(fd, 8), byteorder=sys."
"byteorder)\n"
"                    print(f\"Timer {fds.index(fd) + 1} expired {count} "
"times\")\n"
"                else:\n"
"                    print(f\"Unknown file descriptor {fd}\")\n"
"finally:\n"
"    for fd in fds:\n"
"        ep.unregister(fd)\n"
"        os.close(fd)\n"
"    ep.close()"
msgstr ""
"import os, time, select, socket, sys\n"
"\n"
"# Cria um objeto epoll\n"
"ep = select.epoll()\n"
"\n"
"# Neste exemplo, usa o endereço de loopback para enviar o comando \"stop\" "
"ao servidor.\n"
"#\n"
"# $ telnet 127.0.0.1 1234\n"
"# Trying 127.0.0.1...\n"
"# Connected to 127.0.0.1.\n"
"# Escape character is '^]'.\n"
"# stop\n"
"# Connection closed by foreign host.\n"
"#\n"
"sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"sock.bind((\"127.0.0.1\", 1234))\n"
"sock.setblocking(False)\n"
"sock.listen(1)\n"
"ep.register(sock, select.EPOLLIN)\n"
"\n"
"# Cria descritores de arquivo de temporizador no modo não bloqueante.\n"
"num = 3\n"
"fds = []\n"
"for _ in range(num):\n"
"    fd = os.timerfd_create(time.CLOCK_REALTIME, flags=os.TFD_NONBLOCK)\n"
"    fds.append(fd)\n"
"    # Registra o descritor de arquivo do temporizador para eventos de "
"leitura\n"
"    ep.register(fd, select.EPOLLIN)\n"
"\n"
"# Inicia o temporizador com os.timerfd_settime_ns() em nanossegundos.\n"
"# O temporizador 1 dispara a cada 0,25 segundos; o timer 2 a cada 0,5 "
"segundos; etc.\n"
"for i, fd in enumerate(fds, start=1):\n"
"    one_sec_in_nsec = 10**9\n"
"    i = i * one_sec_in_nsec\n"
"    os.timerfd_settime_ns(fd, initial=i//4, interval=i//4)\n"
"\n"
"timeout = 3\n"
"try:\n"
"    conn = None\n"
"    is_active = True\n"
"    while is_active:\n"
"        # Aguarda o temporizador expirar por 3 segundos.\n"
"        # epoll.poll() retorna uma lista de pares (fd, event).\n"
"        # fd é um descritor de arquivo.\n"
"        # sock e conn[=valor retornado de socket.accept()] são objetos de "
"socket, não descritores de arquivo.\n"
"        # Então use sock.fileno() e conn.fileno() para obter os descritores "
"de arquivo.\n"
"        events = ep.poll(timeout)\n"
"\n"
"        # Se mais de um descritor de arquivo de timer estiver pronto para "
"leitura ao mesmo tempo,\n"
"        # epoll.poll() retorna uma lista de pares (fd, event).\n"
"        #\n"
"        # Neste exemplo de configurações,\n"
"        #    O 1º temporizador dispara a cada 0,25 segundos em 0,25 "
"segundos. (0,25, 0,5, 0,75, 1,0, ...)\n"
"        #    O 2º temporizador dispara a cada 0,5 segundos em 0,5 segundos. "
"(0,5, 1,0, 1,5, 2,0, ...)\n"
"        #    O 3º temporizador dispara a cada 0,75 segundos em 0,75 "
"segundos. (0,75, 1,5, 2,25, 3,0, ...)\n"
"        #\n"
"        #    Em 0,25 segundos, apenas o 1º temporizador dispara.\n"
"        #    Em 0,5 segundos, o 1º temporizador e o 2º temporizador disparam "
"ao mesmo tempo.\n"
"        #    Em 0,75 segundos, o 1º temporizador e o 3º temporizador "
"disparam ao mesmo tempo.\n"
"        #    Em 1,5 segundos, o 1º temporizador, o 2º temporizador e o 3º "
"temporizador disparam ao mesmo tempo.\n"
"        #\n"
"        # Se um descritor de arquivo de temporizador for sinalizado mais de "
"uma vez desde\n"
"        # a última chamada de os.read(), os.read() retornará o número de "
"sinalizados\n"
"        # como ordem de host de bytes de classe.\n"
"        print(f\"Signaled events={events}\")\n"
"        for fd, event in events:\n"
"            if event & select.EPOLLIN:\n"
"                if fd == sock.fileno():\n"
"                    # Verifica se há uma requisição de conexão.\n"
"                    print(f\"Accepting connection {fd}\")\n"
"                    conn, addr = sock.accept()\n"
"                    conn.setblocking(False)\n"
"                    print(f\"Accepted connection {conn} from {addr}\")\n"
"                    ep.register(conn, select.EPOLLIN)\n"
"                elif conn and fd == conn.fileno():\n"
"                    # Verifica se há dados para ler.\n"
"                    print(f\"Reading data {fd}\")\n"
"                    data = conn.recv(1024)\n"
"                    if data:\n"
"                        # Você deveria capturar exceção UnicodeDecodeError "
"por segurança.\n"
"                        cmd = data.decode()\n"
"                        if cmd.startswith(\"stop\"):\n"
"                            print(f\"Stopping server\")\n"
"                            is_active = False\n"
"                        else:\n"
"                            print(f\"Unknown command: {cmd}\")\n"
"                    else:\n"
"                        # Acabaram os dados, fecha a conexão\n"
"                        print(f\"Closing connection {fd}\")\n"
"                        ep.unregister(conn)\n"
"                        conn.close()\n"
"                        conn = None\n"
"                elif fd in fds:\n"
"                    print(f\"Reading timer {fd}\")\n"
"                    count = int.from_bytes(os.read(fd, 8), byteorder=sys."
"byteorder)\n"
"                    print(f\"Timer {fds.index(fd) + 1} expired {count} "
"times\")\n"
"                else:\n"
"                    print(f\"Unknown file descriptor {fd}\")\n"
"finally:\n"
"    for fd in fds:\n"
"        ep.unregister(fd)\n"
"        os.close(fd)\n"
"    ep.close()"

#: ../../howto/timerfd.rst:153
msgid ""
"This example shows how :func:`~select.select` can be used with timer file "
"descriptors to wait until the file descriptor is ready for reading:"
msgstr ""
"Este exemplo mostra como :func:`~select.select` pode ser usado com "
"descritores de arquivo de temporizador para esperar até que o descritor de "
"arquivo esteja pronto para leitura:"

#: ../../howto/timerfd.rst:156
msgid ""
"import os, time, select, socket, sys\n"
"\n"
"# In this example, use loopback address to send \"stop\" command to the "
"server.\n"
"#\n"
"# $ telnet 127.0.0.1 1234\n"
"# Trying 127.0.0.1...\n"
"# Connected to 127.0.0.1.\n"
"# Escape character is '^]'.\n"
"# stop\n"
"# Connection closed by foreign host.\n"
"#\n"
"sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"sock.bind((\"127.0.0.1\", 1234))\n"
"sock.setblocking(False)\n"
"sock.listen(1)\n"
"\n"
"# Create timer file descriptors in non-blocking mode.\n"
"num = 3\n"
"fds = [os.timerfd_create(time.CLOCK_REALTIME, flags=os.TFD_NONBLOCK)\n"
"       for _ in range(num)]\n"
"select_fds = fds + [sock]\n"
"\n"
"# Start the timers with os.timerfd_settime() in seconds.\n"
"# Timer 1 fires every 0.25 seconds; timer 2 every 0.5 seconds; etc\n"
"for i, fd in enumerate(fds, start=1):\n"
"   os.timerfd_settime(fd, initial=i/4, interval=i/4)\n"
"\n"
"timeout = 3\n"
"try:\n"
"    conn = None\n"
"    is_active = True\n"
"    while is_active:\n"
"       # Wait for the timer to expire for 3 seconds.\n"
"       # select.select() returns a list of file descriptors or objects.\n"
"       rfd, wfd, xfd = select.select(select_fds, select_fds, select_fds, "
"timeout)\n"
"       for fd in rfd:\n"
"           if fd == sock:\n"
"               # Check if there is a connection request.\n"
"               print(f\"Accepting connection {fd}\")\n"
"               conn, addr = sock.accept()\n"
"               conn.setblocking(False)\n"
"               print(f\"Accepted connection {conn} from {addr}\")\n"
"               select_fds.append(conn)\n"
"           elif conn and fd == conn:\n"
"               # Check if there is data to read.\n"
"               print(f\"Reading data {fd}\")\n"
"               data = conn.recv(1024)\n"
"               if data:\n"
"                   # You should catch UnicodeDecodeError exception for "
"safety.\n"
"                   cmd = data.decode()\n"
"                   if cmd.startswith(\"stop\"):\n"
"                       print(f\"Stopping server\")\n"
"                       is_active = False\n"
"                   else:\n"
"                       print(f\"Unknown command: {cmd}\")\n"
"               else:\n"
"                   # No more data, close connection\n"
"                   print(f\"Closing connection {fd}\")\n"
"                   select_fds.remove(conn)\n"
"                   conn.close()\n"
"                   conn = None\n"
"           elif fd in fds:\n"
"               print(f\"Reading timer {fd}\")\n"
"               count = int.from_bytes(os.read(fd, 8), byteorder=sys."
"byteorder)\n"
"               print(f\"Timer {fds.index(fd) + 1} expired {count} times\")\n"
"           else:\n"
"               print(f\"Unknown file descriptor {fd}\")\n"
"finally:\n"
"    for fd in fds:\n"
"       os.close(fd)\n"
"    sock.close()\n"
"    sock = None"
msgstr ""
"import os, time, select, socket, sys\n"
"\n"
"# Neste exemplo, usa o endereço de loopback para enviar o comando \"stop\" "
"ao servidor.\n"
"#\n"
"# $ telnet 127.0.0.1 1234\n"
"# Trying 127.0.0.1...\n"
"# Connected to 127.0.0.1.\n"
"# Escape character is '^]'.\n"
"# stop\n"
"# Connection closed by foreign host.\n"
"#\n"
"sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"sock.bind((\"127.0.0.1\", 1234))\n"
"sock.setblocking(False)\n"
"sock.listen(1)\n"
"\n"
"# Cria descritores de arquivo de temporizador no modo não bloqueante.\n"
"num = 3\n"
"fds = [os.timerfd_create(time.CLOCK_REALTIME, flags=os.TFD_NONBLOCK)\n"
"       for _ in range(num)]\n"
"select_fds = fds + [sock]\n"
"\n"
"# Inicia o temporizador com os.timerfd_settime() em segundos.\n"
"# O temporizador 1 dispara a cada 0,25 segundos; o timer 2 a cada 0,5 "
"segundos; etc.\n"
"for i, fd in enumerate(fds, start=1):\n"
"   os.timerfd_settime(fd, initial=i/4, interval=i/4)\n"
"\n"
"timeout = 3\n"
"try:\n"
"    conn = None\n"
"    is_active = True\n"
"    while is_active:\n"
"       # Aguarda o temporizador expirar por 3 segundos.\n"
"       # select.select() retorna uma lista de objetos ou descritores de "
"arquivos.\n"
"       rfd, wfd, xfd = select.select(select_fds, select_fds, select_fds, "
"timeout)\n"
"       for fd in rfd:\n"
"           if fd == sock:\n"
"               # Verifica se há uma requisição de conexão.\n"
"               print(f\"Accepting connection {fd}\")\n"
"               conn, addr = sock.accept()\n"
"               conn.setblocking(False)\n"
"               print(f\"Accepted connection {conn} from {addr}\")\n"
"               select_fds.append(conn)\n"
"           elif conn and fd == conn:\n"
"               # Verifica se há dados para ler.\n"
"               print(f\"Reading data {fd}\")\n"
"               data = conn.recv(1024)\n"
"               if data:\n"
"                   # Você deveria capturar exceção UnicodeDecodeError por "
"segurança.\n"
"                   cmd = data.decode()\n"
"                   if cmd.startswith(\"stop\"):\n"
"                       print(f\"Stopping server\")\n"
"                       is_active = False\n"
"                   else:\n"
"                       print(f\"Unknown command: {cmd}\")\n"
"               else:\n"
"                   # Acabaram os dados, fecha a conexão\n"
"                   print(f\"Closing connection {fd}\")\n"
"                   select_fds.remove(conn)\n"
"                   conn.close()\n"
"                   conn = None\n"
"           elif fd in fds:\n"
"               print(f\"Reading timer {fd}\")\n"
"               count = int.from_bytes(os.read(fd, 8), byteorder=sys."
"byteorder)\n"
"               print(f\"Timer {fds.index(fd) + 1} expired {count} times\")\n"
"           else:\n"
"               print(f\"Unknown file descriptor {fd}\")\n"
"finally:\n"
"    for fd in fds:\n"
"       os.close(fd)\n"
"    sock.close()\n"
"    sock = None"

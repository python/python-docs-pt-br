# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-11 15:45+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../howto/unicode.rst:5
msgid "Unicode HOWTO"
msgstr "Unicode"

#: ../../howto/unicode.rst:0
msgid "Release"
msgstr "Vers√£o"

#: ../../howto/unicode.rst:7
msgid "1.12"
msgstr "1.12"

#: ../../howto/unicode.rst:9
msgid ""
"This HOWTO discusses Python's support for the Unicode specification for "
"representing textual data, and explains various problems that people "
"commonly encounter when trying to work with Unicode."
msgstr ""
"Este documento fala sobre o suporte do Python para a especifica√ß√£o Unicode "
"de representa√ß√£o de dados textuais e explica diversos problemas que as "
"pessoas costumam encontrar quando tentam trabalhar com Unicode."

#: ../../howto/unicode.rst:15
msgid "Introduction to Unicode"
msgstr "Introdu√ß√£o ao Unicode"

#: ../../howto/unicode.rst:18
msgid "Definitions"
msgstr "Defini√ß√µes"

#: ../../howto/unicode.rst:20
msgid ""
"Today's programs need to be able to handle a wide variety of characters.  "
"Applications are often internationalized to display messages and output in a "
"variety of user-selectable languages; the same program might need to output "
"an error message in English, French, Japanese, Hebrew, or Russian.  Web "
"content can be written in any of these languages and can also include a "
"variety of emoji symbols. Python's string type uses the Unicode Standard for "
"representing characters, which lets Python programs work with all these "
"different possible characters."
msgstr ""
"Os programas de hoje precisam lidar com uma grande variedade de caracteres. "
"Aplica√ß√µes s√£o frequentemente internacionalizadas para mostrar mensagens e "
"gerar sa√≠das em uma variedade de idiomas selecion√°veis por usu√°rios; o mesmo "
"programa precisar apresentar mensagens de erro em ingl√™s, franc√™s, japon√™s, "
"hebraico ou russo. Conte√∫do da web pode ser escrito em qualquer um desses "
"idiomas e ainda incluir uma variedade de emojis. O tipo string do Python usa "
"o padr√£o Unicode para representa√ß√£o de caracteres, o que permite aos "
"programas em Python funcionar com todos estes diferentes caracteres."

#: ../../howto/unicode.rst:30
msgid ""
"Unicode (https://www.unicode.org/) is a specification that aims to list "
"every character used by human languages and give each character its own "
"unique code.  The Unicode specifications are continually revised and updated "
"to add new languages and symbols."
msgstr ""
"Unicode (https://www.unicode.org/) √© a especifica√ß√£o que visa listar cada "
"caractere utilizado pelos idiomas humanos e dar a cada caractere um c√≥digo "
"√∫nico. As especifica√ß√µes Unicode s√£o continuamente revisadas e atualizadas "
"para adicionar novos idiomas e s√≠mbolos."

#: ../../howto/unicode.rst:35
msgid ""
"A **character** is the smallest possible component of a text.  'A', 'B', "
"'C', etc., are all different characters.  So are '√à' and '√ç'.  Characters "
"vary depending on the language or context you're talking about.  For "
"example, there's a character for \"Roman Numeral One\", '‚Ö†', that's separate "
"from the uppercase letter 'I'.  They'll usually look the same, but these are "
"two different characters that have different meanings."
msgstr ""
"**–°–∏–º–≤–æ–ª** - —Ü–µ –Ω–∞–π–º–µ–Ω—à–∞ –º–æ–∂–ª–∏–≤–∞ —Å–∫–ª–∞–¥–æ–≤–∞ —Ç–µ–∫—Å—Ç—É. \"A\", \"B\", \"C\" —Ç–æ—â–æ ‚Äî "
"—Ü–µ —Ä—ñ–∑–Ω—ñ —Å–∏–º–≤–æ–ª–∏. –¢–∞–∫ —Å–∞–º–æ \"√à\" —ñ \"√ç\". –°–∏–º–≤–æ–ª–∏ –≤—ñ–¥—Ä—ñ–∑–Ω—è—é—Ç—å—Å—è –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ "
"–º–æ–≤–∏ —á–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É, –ø—Ä–æ —è–∫–∏–π –≤–∏ –≥–æ–≤–æ—Ä–∏—Ç–µ. –ù–∞–ø—Ä–∏–∫–ª–∞–¥, –¥–ª—è \"—Ä–∏–º—Å—å–∫–æ—ó —Ü–∏—Ñ—Ä–∏ "
"–æ–¥–∏–Ω\" —î —Å–∏–º–≤–æ–ª \"‚Ö†\", —è–∫–∏–π —Å—Ç–æ—ó—Ç—å –æ–∫—Ä–µ–º–æ –≤—ñ–¥ –≤–µ–ª–∏–∫–æ—ó –ª—ñ—Ç–µ—Ä–∏ \"I\". –ó–∞–∑–≤–∏—á–∞–π "
"–≤–æ–Ω–∏ –≤–∏–≥–ª—è–¥–∞—é—Ç—å –æ–¥–Ω–∞–∫–æ–≤–æ, –∞–ª–µ —Ü–µ –¥–≤–∞ —Ä—ñ–∑–Ω—ñ —Å–∏–º–≤–æ–ª–∏, —è–∫—ñ –º–∞—é—Ç—å —Ä—ñ–∑–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è."

#: ../../howto/unicode.rst:42
msgid ""
"The Unicode standard describes how characters are represented by **code "
"points**.  A code point value is an integer in the range 0 to 0x10FFFF "
"(about 1.1 million values, the `actual number assigned <https://www.unicode."
"org/versions/latest/#Summary>`_ is less than that). In the standard and in "
"this document, a code point is written using the notation ``U+265E`` to mean "
"the character with value ``0x265e`` (9,822 in decimal)."
msgstr ""
"–°—Ç–∞–Ω–¥–∞—Ä—Ç Unicode –æ–ø–∏—Å—É—î, —è–∫ —Å–∏–º–≤–æ–ª–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω—ñ **–∫–æ–¥–æ–≤–∏–º–∏ —Ç–æ—á–∫–∞–º–∏**. "
"–ó–Ω–∞—á–µ–Ω–Ω—è –∫–æ–¥–æ–≤–æ—ó —Ç–æ—á–∫–∏ —î —Ü—ñ–ª–∏–º —á–∏—Å–ª–æ–º —É –¥—ñ–∞–ø–∞–∑–æ–Ω—ñ –≤—ñ–¥ 0 –¥–æ 0x10FFFF "
"(–ø—Ä–∏–±–ª–∏–∑–Ω–æ 1,1 –º—ñ–ª—å–π–æ–Ω–∞ –∑–Ω–∞—á–µ–Ω—å, `—Ñ–∞–∫—Ç–∏—á–Ω–∏–π –Ω–æ–º–µ—Ä, –ø—Ä–∏–∑–Ω–∞—á–µ–Ω–∏–π <https://www."
"unicode.org/versions/latest/#Summary>`_ –º–µ–Ω—à–µ —Ü—å–æ–≥–æ). –£ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ñ —Ç–∞ –≤ —Ü—å–æ–º—É "
"–¥–æ–∫—É–º–µ–Ω—Ç—ñ –∫–æ–¥–æ–≤–∞ —Ç–æ—á–∫–∞ –∑–∞–ø–∏—Å—É—î—Ç—å—Å—è –∑ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è–º –ø–æ–∑–Ω–∞—á–µ–Ω–Ω—è ``U+265E``, "
"—â–æ–± –æ–∑–Ω–∞—á–∞—Ç–∏ —Å–∏–º–≤–æ–ª –∑—ñ –∑–Ω–∞—á–µ–Ω–Ω—è–º ``0x265e`` (9822 —É –¥–µ—Å—è—Ç–∫–æ–≤–æ–º—É)."

#: ../../howto/unicode.rst:50
msgid ""
"The Unicode standard contains a lot of tables listing characters and their "
"corresponding code points:"
msgstr ""
"O padr√£o Unicode cont√©m v√°rias tabelas listando caracteres e seus pontos de "
"c√≥digo:"

#: ../../howto/unicode.rst:53
msgid ""
"0061    'a'; LATIN SMALL LETTER A\n"
"0062    'b'; LATIN SMALL LETTER B\n"
"0063    'c'; LATIN SMALL LETTER C\n"
"...\n"
"007B    '{'; LEFT CURLY BRACKET\n"
"...\n"
"2167    '‚Öß'; ROMAN NUMERAL EIGHT\n"
"2168    '‚Ö®'; ROMAN NUMERAL NINE\n"
"...\n"
"265E    '‚ôû'; BLACK CHESS KNIGHT\n"
"265F    '‚ôü'; BLACK CHESS PAWN\n"
"...\n"
"1F600   'üòÄ'; GRINNING FACE\n"
"1F609   'üòâ'; WINKING FACE\n"
"..."
msgstr ""
"0061    'a'; LATIN SMALL LETTER A\n"
"0062    'b'; LATIN SMALL LETTER B\n"
"0063    'c'; LATIN SMALL LETTER C\n"
"...\n"
"007B    '{'; LEFT CURLY BRACKET\n"
"...\n"
"2167    '‚Öß'; ROMAN NUMERAL EIGHT\n"
"2168    '‚Ö®'; ROMAN NUMERAL NINE\n"
"...\n"
"265E    '‚ôû'; BLACK CHESS KNIGHT\n"
"265F    '‚ôü'; BLACK CHESS PAWN\n"
"...\n"
"1F600   'üòÄ'; GRINNING FACE\n"
"1F609   'üòâ'; WINKING FACE\n"
"..."

#: ../../howto/unicode.rst:71
msgid ""
"Strictly, these definitions imply that it's meaningless to say 'this is "
"character ``U+265E``'.  ``U+265E`` is a code point, which represents some "
"particular character; in this case, it represents the character 'BLACK CHESS "
"KNIGHT', '‚ôû'.  In informal contexts, this distinction between code points "
"and characters will sometimes be forgotten."
msgstr ""
"–í–ª–∞—Å–Ω–µ, —Ü—ñ –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è –æ–∑–Ω–∞—á–∞—é—Ç—å, —â–æ –Ω–µ–º–∞—î —Å–µ–Ω—Å—É –≥–æ–≤–æ—Ä–∏—Ç–∏ \"—Ü–µ —Å–∏–º–≤–æ–ª "
"``U+265E``\". ``U+265E`` - —Ü–µ –∫–æ–¥–æ–≤–∞ —Ç–æ—á–∫–∞, —è–∫–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—î –ø–µ–≤–Ω–∏–π —Å–∏–º–≤–æ–ª; —É "
"—Ü—å–æ–º—É –≤–∏–ø–∞–¥–∫—É –≤—ñ–Ω –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—î –ø–µ—Ä—Å–æ–Ω–∞–∂ \"–ß–û–†–ù–ò–ô –®–ê–•–û–í–ò–ô –õ–ò–ö–ê–†\", \"‚ôû\". –£ "
"–Ω–µ–æ—Ñ—ñ—Ü—ñ–π–Ω–æ–º—É –∫–æ–Ω—Ç–µ–∫—Å—Ç—ñ —Ü—è –≤—ñ–¥–º—ñ–Ω–Ω—ñ—Å—Ç—å –º—ñ–∂ –∫–æ–¥–æ–≤–∏–º–∏ —Ç–æ—á–∫–∞–º–∏ —Ç–∞ —Å–∏–º–≤–æ–ª–∞–º–∏ "
"—ñ–Ω–æ–¥—ñ –∑–∞–±—É–≤–∞—î—Ç—å—Å—è."

#: ../../howto/unicode.rst:78
msgid ""
"A character is represented on a screen or on paper by a set of graphical "
"elements that's called a **glyph**.  The glyph for an uppercase A, for "
"example, is two diagonal strokes and a horizontal stroke, though the exact "
"details will depend on the font being used.  Most Python code doesn't need "
"to worry about glyphs; figuring out the correct glyph to display is "
"generally the job of a GUI toolkit or a terminal's font renderer."
msgstr ""
"Um caractere √© representado na tela ou no papel como um conjunto de "
"elementos gr√°ficos que √© chamado de **glifo**. O glifo para o A mai√∫sculo, "
"por exemplo, s√£o dois tra√ßos diagonais e um tra√ßo horizontal, embora os "
"detalhes exatos dependem da fonte utilizada. Na maior parte do c√≥digo Python "
"n√£o √© preciso se preocupar com glifos; descobrir qual o glifo correto a ser "
"mostrado √© normalmente parte do trabalho da ferramenta GUI ou do respons√°vel "
"pela renderiza√ß√£o de fontes no terminal."

#: ../../howto/unicode.rst:87
msgid "Encodings"
msgstr "Codifica√ß√µes"

#: ../../howto/unicode.rst:89
msgid ""
"To summarize the previous section: a Unicode string is a sequence of code "
"points, which are numbers from 0 through ``0x10FFFF`` (1,114,111 decimal).  "
"This sequence of code points needs to be represented in memory as a set of "
"**code units**, and **code units** are then mapped to 8-bit bytes.  The "
"rules for translating a Unicode string into a sequence of bytes are called a "
"**character encoding**, or just an **encoding**."
msgstr ""
"–ü—ñ–¥—Å—É–º–æ–≤—É—é—á–∏ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π —Ä–æ–∑–¥—ñ–ª: —Ä—è–¥–æ–∫ Unicode ‚Äì —Ü–µ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å –∫–æ–¥–æ–≤–∏—Ö "
"—Ç–æ—á–æ–∫, —è–∫—ñ —î —á–∏—Å–ª–∞–º–∏ –≤—ñ–¥ 0 –¥–æ ``0x10FFFF`` (1 114 111 –¥–µ—Å—è—Ç–∫–æ–≤–∏—Ö). –¶—é "
"–ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å –∫–æ–¥–æ–≤–∏—Ö —Ç–æ—á–æ–∫ –ø–æ—Ç—Ä—ñ–±–Ω–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–∏ –≤ –ø–∞–º‚Äô—è—Ç—ñ —è–∫ –Ω–∞–±—ñ—Ä "
"**–∫–æ–¥–æ–≤–∏—Ö –æ–¥–∏–Ω–∏—Ü—å**, –∞ **–∫–æ–¥–æ–≤—ñ –æ–¥–∏–Ω–∏—Ü—ñ** –ø–æ—Ç—ñ–º –≤—ñ–¥–æ–±—Ä–∞–∂–∞—é—Ç—å—Å—è –Ω–∞ 8-–±—ñ—Ç–Ω—ñ "
"–±–∞–π—Ç–∏. –ü—Ä–∞–≤–∏–ª–∞ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ä—è–¥–∫–∞ Unicode —É –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å –±–∞–π—Ç—ñ–≤ –Ω–∞–∑–∏–≤–∞—é—Ç—å—Å—è "
"**–∫–æ–¥—É–≤–∞–Ω–Ω—è–º —Å–∏–º–≤–æ–ª—ñ–≤** –∞–±–æ –ø—Ä–æ—Å—Ç–æ **–∫–æ–¥—É–≤–∞–Ω–Ω—è–º**."

#: ../../howto/unicode.rst:97
msgid ""
"The first encoding you might think of is using 32-bit integers as the code "
"unit, and then using the CPU's representation of 32-bit integers. In this "
"representation, the string \"Python\" might look like this:"
msgstr ""
"–ü–µ—Ä—à–µ –∫–æ–¥—É–≤–∞–Ω–Ω—è, –ø—Ä–æ —è–∫–µ –≤–∏ –º–æ–∂–µ—Ç–µ –ø–æ–¥—É–º–∞—Ç–∏, —Ü–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è 32-—Ä–æ–∑—Ä—è–¥–Ω–∏—Ö "
"—Ü—ñ–ª–∏—Ö —á–∏—Å–µ–ª —è–∫ –æ–¥–∏–Ω–∏—Ü—ñ –∫–æ–¥—É, –∞ –ø–æ—Ç—ñ–º –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è –¶–ü 32-"
"—Ä–æ–∑—Ä—è–¥–Ω–∏—Ö —Ü—ñ–ª–∏—Ö —á–∏—Å–µ–ª. –£ —Ü—å–æ–º—É –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—ñ —Ä—è–¥–æ–∫ \"Python\" –º–æ–∂–µ –≤–∏–≥–ª—è–¥–∞—Ç–∏ "
"—Ç–∞–∫:"

#: ../../howto/unicode.rst:101
msgid ""
"   P           y           t           h           o           n\n"
"0x50 00 00 00 79 00 00 00 74 00 00 00 68 00 00 00 6f 00 00 00 6e 00 00 00\n"
"   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23"
msgstr ""
"   P           y           t           h           o           n\n"
"0x50 00 00 00 79 00 00 00 74 00 00 00 68 00 00 00 6f 00 00 00 6e 00 00 00\n"
"   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23"

#: ../../howto/unicode.rst:107
msgid ""
"This representation is straightforward but using it presents a number of "
"problems."
msgstr "Esta representa√ß√£o √© direta, mas us√°-la gera uma s√©rie de problemas."

#: ../../howto/unicode.rst:110
msgid "It's not portable; different processors order the bytes differently."
msgstr ""
"Ela n√£o √© port√°til; diferentes processadores ordenam os bytes de forma "
"diferente."

#: ../../howto/unicode.rst:112
msgid ""
"It's very wasteful of space.  In most texts, the majority of the code points "
"are less than 127, or less than 255, so a lot of space is occupied by "
"``0x00`` bytes.  The above string takes 24 bytes compared to the 6 bytes "
"needed for an ASCII representation.  Increased RAM usage doesn't matter too "
"much (desktop computers have gigabytes of RAM, and strings aren't usually "
"that large), but expanding our usage of disk and network bandwidth by a "
"factor of 4 is intolerable."
msgstr ""
"Ela gera desperd√≠cio de espa√ßo. Na maior parte dos textos, a maioria dos "
"pontos de c√≥digo s√£o menores que 127 ou menores que 255, ent√£o muito do "
"espa√ßo √© ocupado por bytes ``0x00`` . A string acima necessita 24 bytes "
"comparado com os 6 bytes necess√°rios em uma representa√ß√£o ASCII. O aumento "
"de uso da mem√≥ria RAM normalmente n√£o importa tanto (computadores desktop "
"possuem gigabytes de RAM e strings normalmente n√£o s√£o t√£o grandes), mas "
"expandir o uso de disco ou de banda por um fator de 4 √© inaceit√°vel."

#: ../../howto/unicode.rst:120
msgid ""
"It's not compatible with existing C functions such as ``strlen()``, so a new "
"family of wide string functions would need to be used."
msgstr ""
"Ela n√£o √© compat√≠vel com as fun√ß√µes de C existentes, como ``strlen()``, "
"ent√£o uma s√©rie de novas fun√ß√µes de string ser√£o necess√°rias."

#: ../../howto/unicode.rst:123
msgid ""
"Therefore this encoding isn't used very much, and people instead choose "
"other encodings that are more efficient and convenient, such as UTF-8."
msgstr ""
"–¢–æ–º—É —Ü–µ –∫–æ–¥—É–≤–∞–Ω–Ω—è –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –Ω–µ –¥—É–∂–µ —á–∞—Å—Ç–æ, —ñ –ª—é–¥–∏ –Ω–∞—Ç–æ–º—ñ—Å—Ç—å –æ–±–∏—Ä–∞—é—Ç—å "
"—ñ–Ω—à—ñ –∫–æ–¥—É–≤–∞–Ω–Ω—è, —è–∫—ñ —î –±—ñ–ª—å—à –µ—Ñ–µ–∫—Ç–∏–≤–Ω–∏–º–∏ —Ç–∞ –∑—Ä—É—á–Ω–∏–º–∏, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥ UTF-8."

#: ../../howto/unicode.rst:126
msgid ""
"UTF-8 is one of the most commonly used encodings, and Python often defaults "
"to using it.  UTF stands for \"Unicode Transformation Format\", and the '8' "
"means that 8-bit values are used in the encoding.  (There are also UTF-16 "
"and UTF-32 encodings, but they are less frequently used than UTF-8.)  UTF-8 "
"uses the following rules:"
msgstr ""
"UTF-8 —î –æ–¥–Ω–∏–º —ñ–∑ –Ω–∞–π–ø–æ—à–∏—Ä–µ–Ω—ñ—à–∏—Ö –∫–æ–¥—É–≤–∞–Ω—å, —ñ Python —á–∞—Å—Ç–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î –π–æ–≥–æ "
"–∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º. UTF –æ–∑–Ω–∞—á–∞—î \"—Ñ–æ—Ä–º–∞—Ç –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è –Æ–Ω—ñ–∫–æ–¥—É\", –∞ \"8\" "
"–æ–∑–Ω–∞—á–∞—î, —â–æ –≤ –∫–æ–¥—É–≤–∞–Ω–Ω—ñ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å—Å—è 8-–±—ñ—Ç–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è. (–Ü—Å–Ω—É—é—Ç—å —Ç–∞–∫–æ–∂ "
"–∫–æ–¥—É–≤–∞–Ω–Ω—è UTF-16 —ñ UTF-32, –∞–ª–µ –≤–æ–Ω–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å—Å—è —Ä—ñ–¥—à–µ, –Ω—ñ–∂ UTF-8.) "
"UTF-8 –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î —Ç–∞–∫—ñ –ø—Ä–∞–≤–∏–ª–∞:"

#: ../../howto/unicode.rst:132
msgid ""
"If the code point is < 128, it's represented by the corresponding byte value."
msgstr ""
"–Ø–∫—â–æ –∫–æ–¥–æ–≤–∞ —Ç–æ—á–∫–∞ < 128, –≤–æ–Ω–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏–º –∑–Ω–∞—á–µ–Ω–Ω—è–º –±–∞–π—Ç–∞."

#: ../../howto/unicode.rst:133
msgid ""
"If the code point is >= 128, it's turned into a sequence of two, three, or "
"four bytes, where each byte of the sequence is between 128 and 255."
msgstr ""
"–Ø–∫—â–æ –∫–æ–¥–æ–≤–∞ —Ç–æ—á–∫–∞ >= 128, –≤–æ–Ω–∞ –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î—Ç—å—Å—è –Ω–∞ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å –∑ –¥–≤–æ—Ö, —Ç—Ä—å–æ—Ö "
"–∞–±–æ —á–æ—Ç–∏—Ä—å–æ—Ö –±–∞–π—Ç—ñ–≤, –¥–µ –∫–æ–∂–µ–Ω –±–∞–π—Ç –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ –∑–Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –º—ñ–∂ 128 —ñ 255."

#: ../../howto/unicode.rst:136
msgid "UTF-8 has several convenient properties:"
msgstr "UTF-8 tem muitas propriedades convenientes:"

#: ../../howto/unicode.rst:138
msgid "It can handle any Unicode code point."
msgstr "Ela pode lidar com qualquer ponto de c√≥digo Unicode."

#: ../../howto/unicode.rst:139
msgid ""
"A Unicode string is turned into a sequence of bytes that contains embedded "
"zero bytes only where they represent the null character (U+0000). This means "
"that UTF-8 strings can be processed by C functions such as ``strcpy()`` and "
"sent through protocols that can't handle zero bytes for anything other than "
"end-of-string markers."
msgstr ""
"–†—è–¥–æ–∫ Unicode –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î—Ç—å—Å—è –Ω–∞ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å –±–∞–π—Ç—ñ–≤, —è–∫–∞ –º—ñ—Å—Ç–∏—Ç—å –≤–±—É–¥–æ–≤–∞–Ω—ñ "
"–Ω—É–ª—å–æ–≤—ñ –±–∞–π—Ç–∏ –ª–∏—à–µ —Ç–∞–º, –¥–µ –≤–æ–Ω–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç—å –Ω—É–ª—å–æ–≤–∏–π —Å–∏–º–≤–æ–ª (U+0000). –¶–µ "
"–æ–∑–Ω–∞—á–∞—î, —â–æ —Ä—è–¥–∫–∏ UTF-8 –º–æ–∂—É—Ç—å –æ–±—Ä–æ–±–ª—è—Ç–∏—Å—è —Ç–∞–∫–∏–º–∏ —Ñ—É–Ω–∫—Ü—ñ—è–º–∏ C, —è–∫ "
"``strcpy()`` —ñ –Ω–∞–¥—Å–∏–ª–∞—Ç–∏—Å—è —á–µ—Ä–µ–∑ –ø—Ä–æ—Ç–æ–∫–æ–ª–∏, —è–∫—ñ –Ω–µ –º–æ–∂—É—Ç—å –æ–±—Ä–æ–±–ª—è—Ç–∏ –Ω—É–ª—å–æ–≤—ñ "
"–±–∞–π—Ç–∏ –¥–ª—è –±—É–¥—å-—á–æ–≥–æ, –∫—Ä—ñ–º –º–∞—Ä–∫–µ—Ä—ñ–≤ –∫—ñ–Ω—Ü—è —Ä—è–¥–∫–∞."

#: ../../howto/unicode.rst:144
msgid "A string of ASCII text is also valid UTF-8 text."
msgstr "Uma string de texto ASCII √© tamb√©m um texto UTF-8 v√°lido."

#: ../../howto/unicode.rst:145
msgid ""
"UTF-8 is fairly compact; the majority of commonly used characters can be "
"represented with one or two bytes."
msgstr ""
"UTF-8 —î –¥–æ—Å–∏—Ç—å –∫–æ–º–ø–∞–∫—Ç–Ω–∏–º; –±—ñ–ª—å—à—ñ—Å—Ç—å —á–∞—Å—Ç–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞–Ω–∏—Ö —Å–∏–º–≤–æ–ª—ñ–≤ –º–æ–∂—É—Ç—å "
"–±—É—Ç–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω—ñ –æ–¥–Ω–∏–º –∞–±–æ –¥–≤–æ–º–∞ –±–∞–π—Ç–∞–º–∏."

#: ../../howto/unicode.rst:147
msgid ""
"If bytes are corrupted or lost, it's possible to determine the start of the "
"next UTF-8-encoded code point and resynchronize.  It's also unlikely that "
"random 8-bit data will look like valid UTF-8."
msgstr ""
"–Ø–∫—â–æ –±–∞–π—Ç–∏ –ø–æ—à–∫–æ–¥–∂–µ–Ω—ñ –∞–±–æ –≤—Ç—Ä–∞—á–µ–Ω—ñ, –º–æ–∂–Ω–∞ –≤–∏–∑–Ω–∞—á–∏—Ç–∏ –ø–æ—á–∞—Ç–æ–∫ –Ω–∞—Å—Ç—É–ø–Ω–æ—ó "
"–∫–æ–¥–æ–≤–æ—ó —Ç–æ—á–∫–∏ –∫–æ–¥—É–≤–∞–Ω–Ω—è UTF-8 —ñ –ø–æ–≤—Ç–æ—Ä–Ω–æ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑—É–≤–∞—Ç–∏. –¢–∞–∫–æ–∂ –º–∞–ª–æ–π–º–æ–≤—ñ—Ä–Ω–æ, "
"—â–æ –≤–∏–ø–∞–¥–∫–æ–≤—ñ 8-–±—ñ—Ç–Ω—ñ –¥–∞–Ω—ñ –≤–∏–≥–ª—è–¥–∞—Ç–∏–º—É—Ç—å —è–∫ –¥—ñ–π—Å–Ω–∏–π UTF-8."

#: ../../howto/unicode.rst:150
msgid ""
"UTF-8 is a byte oriented encoding. The encoding specifies that each "
"character is represented by a specific sequence of one or more bytes. This "
"avoids the byte-ordering issues that can occur with integer and word "
"oriented encodings, like UTF-16 and UTF-32, where the sequence of bytes "
"varies depending on the hardware on which the string was encoded."
msgstr ""
"UTF-8 ‚Äî —Ü–µ –±–∞–π—Ç–æ–≤–µ –∫–æ–¥—É–≤–∞–Ω–Ω—è. –ö–æ–¥—É–≤–∞–Ω–Ω—è –≤–∫–∞–∑—É—î, —â–æ –∫–æ–∂–µ–Ω —Å–∏–º–≤–æ–ª "
"–ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—î—Ç—å—Å—è –ø–µ–≤–Ω–æ—é –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—é –∑ –æ–¥–Ω–æ–≥–æ –∞–±–æ –∫—ñ–ª—å–∫–æ—Ö –±–∞–π—Ç—ñ–≤. –¶–µ "
"–¥–æ–∑–≤–æ–ª—è—î —É–Ω–∏–∫–Ω—É—Ç–∏ –ø—Ä–æ–±–ª–µ–º —ñ–∑ —É–ø–æ—Ä—è–¥–∫—É–≤–∞–Ω–Ω—è–º –±–∞–π—Ç—ñ–≤, —è–∫—ñ –º–æ–∂—É—Ç—å –≤–∏–Ω–∏–∫–Ω—É—Ç–∏ –∑ "
"–∫–æ–¥—É–≤–∞–Ω–Ω—è–º–∏, –æ—Ä—ñ—î–Ω—Ç–æ–≤–∞–Ω–∏–º–∏ –Ω–∞ —Ü—ñ–ª–µ —á–∏ —Å–ª–æ–≤–æ, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥ UTF-16 —ñ UTF-32, –¥–µ "
"–ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å –±–∞–π—Ç—ñ–≤ –∑–º—ñ–Ω—é—î—Ç—å—Å—è –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –∞–ø–∞—Ä–∞—Ç–Ω–æ–≥–æ –∑–∞–±–µ–∑–ø–µ—á–µ–Ω–Ω—è, –Ω–∞ "
"—è–∫–æ–º—É –±—É–ª–æ –∑–∞–∫–æ–¥–æ–≤–∞–Ω–æ —Ä—è–¥–æ–∫."

#: ../../howto/unicode.rst:158 ../../howto/unicode.rst:514
#: ../../howto/unicode.rst:735
msgid "References"
msgstr "Refer√™ncias"

#: ../../howto/unicode.rst:160
msgid ""
"The `Unicode Consortium site <https://www.unicode.org>`_ has character "
"charts, a glossary, and PDF versions of the Unicode specification.  Be "
"prepared for some difficult reading.  `A chronology <https://www.unicode.org/"
"history/>`_ of the origin and development of Unicode is also available on "
"the site."
msgstr ""
"–ù–∞ —Å–∞–π—Ç—ñ `Unicode Consortium <https://www.unicode.org>`_ —î —Ç–∞–±–ª–∏—Ü—ñ —Å–∏–º–≤–æ–ª—ñ–≤, "
"–≥–ª–æ—Å–∞—Ä—ñ–π —ñ PDF-–≤–µ—Ä—Å—ñ—ó —Å–ø–µ—Ü–∏—Ñ—ñ–∫–∞—Ü—ñ—ó Unicode. –ë—É–¥—å—Ç–µ –≥–æ—Ç–æ–≤—ñ –¥–æ –≤–∞–∂–∫–æ–≥–æ "
"—á–∏—Ç–∞–Ω–Ω—è. `–•—Ä–æ–Ω–æ–ª–æ–≥—ñ—è <https://www.unicode.org/history/>`_ –ø–æ—Ö–æ–¥–∂–µ–Ω–Ω—è —Ç–∞ "
"—Ä–æ–∑–≤–∏—Ç–∫—É Unicode —Ç–∞–∫–æ–∂ –¥–æ—Å—Ç—É–ø–Ω–∞ –Ω–∞ —Å–∞–π—Ç—ñ."

#: ../../howto/unicode.rst:165
msgid ""
"On the Computerphile Youtube channel, Tom Scott briefly `discusses the "
"history of Unicode and UTF-8 <https://www.youtube.com/watch?v=MijmeoH9LT4>`_ "
"(9 minutes 36 seconds)."
msgstr ""
"–ù–∞ Youtube-–∫–∞–Ω–∞–ª—ñ Computerphile –¢–æ–º –°–∫–æ—Ç—Ç –∫–æ—Ä–æ—Ç–∫–æ `–æ–±–≥–æ–≤–æ—Ä—é—î —ñ—Å—Ç–æ—Ä—ñ—é Unicode "
"—Ç–∞ UTF-8 <https://www.youtube.com/watch?v=MijmeoH9LT4>`_ (9 —Ö–≤–∏–ª–∏–Ω 36 "
"—Å–µ–∫—É–Ω–¥)."

#: ../../howto/unicode.rst:169
msgid ""
"To help understand the standard, Jukka Korpela has written `an introductory "
"guide <https://jkorpela.fi/unicode/guide.html>`_ to reading the Unicode "
"character tables."
msgstr ""
"–ß—Ç–æ–±—ã –ø–æ–º–æ—á—å –ø–æ–Ω—è—Ç—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç, –Æ–∫–∫–∞ –ö–æ—Ä–ø–µ–ª–∞ –Ω–∞–ø–∏—Å–∞–ª `–≤–≤–æ–¥–Ω–æ–µ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ "
"<https://jkorpela.fi/unicode/guide.html>`_ –ø–æ —á—Ç–µ–Ω–∏—é —Ç–∞–±–ª–∏—Ü —Å–∏–º–≤–æ–ª–æ–≤ –Æ–Ω–∏–∫–æ–¥–∞."

#: ../../howto/unicode.rst:173
msgid ""
"Another `good introductory article <https://www.joelonsoftware."
"com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-"
"positively-must-know-about-unicode-and-character-sets-no-excuses/>`_ was "
"written by Joel Spolsky. If this introduction didn't make things clear to "
"you, you should try reading this alternate article before continuing."
msgstr ""
"–©–µ –æ–¥–Ω—É `—Ö–æ—Ä–æ—à—É –≤—Å—Ç—É–ø–Ω—É —Å—Ç–∞—Ç—Ç—é <https://www.joelonsoftware.com/2003/10/08/"
"the-absolute-minimum-every-software-developer-absolutely-positively-must-"
"know-about-unicode-and-character-sets-no-excuses/>`_ –Ω–∞–ø–∏—Å–∞–≤ –î–∂–æ–µ–ª –°–ø–æ–ª—å—Å–∫—ñ. "
"–Ø–∫—â–æ —Ü–µ–π –≤—Å—Ç—É–ø –Ω–µ –ø—Ä–æ—è—Å–Ω–∏–≤ –≤–∞–º —â–æ—Å—å, —Å–ø—Ä–æ–±—É–π—Ç–µ –ø—Ä–æ—á–∏—Ç–∞—Ç–∏ —Ü—é –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—É "
"—Å—Ç–∞—Ç—Ç—é, –ø–µ—Ä—à –Ω—ñ–∂ –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏."

#: ../../howto/unicode.rst:178
msgid ""
"Wikipedia entries are often helpful; see the entries for \"`character "
"encoding <https://en.wikipedia.org/wiki/Character_encoding>`_\" and `UTF-8 "
"<https://en.wikipedia.org/wiki/UTF-8>`_, for example."
msgstr ""
"–ó–∞–ø–∏—Å–∏ —É –í—ñ–∫—ñ–ø–µ–¥—ñ—ó —á–∞—Å—Ç–æ —î –∫–æ—Ä–∏—Å–Ω–∏–º–∏; –¥–∏–≤—ñ—Ç—å—Å—è, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –∑–∞–ø–∏—Å–∏ –¥–ª—è "
"\"`–∫–æ–¥—É–≤–∞–Ω–Ω—è —Å–∏–º–≤–æ–ª—ñ–≤ <https://en.wikipedia.org/wiki/Character_encoding>`_\" "
"—ñ `UTF-8 <https://en.wikipedia.org/wiki/UTF-8>`_."

#: ../../howto/unicode.rst:184
msgid "Python's Unicode Support"
msgstr "Suporte a Unicode no Python"

#: ../../howto/unicode.rst:186
msgid ""
"Now that you've learned the rudiments of Unicode, we can look at Python's "
"Unicode features."
msgstr ""
"–¢–µ–ø–µ—Ä, –∫–æ–ª–∏ –≤–∏ –≤–∏–≤—á–∏–ª–∏ –æ—Å–Ω–æ–≤–∏ –Æ–Ω—ñ–∫–æ–¥—É, –º–∏ –º–æ–∂–µ–º–æ —Ä–æ–∑–≥–ª—è–Ω—É—Ç–∏ –æ—Å–æ–±–ª–∏–≤–æ—Å—Ç—ñ "
"–Æ–Ω—ñ–∫–æ–¥—É Python."

#: ../../howto/unicode.rst:190
msgid "The String Type"
msgstr "O Tipo String"

#: ../../howto/unicode.rst:192
msgid ""
"Since Python 3.0, the language's :class:`str` type contains Unicode "
"characters, meaning any string created using ``\"unicode rocks!\"``, "
"``'unicode rocks!'``, or the triple-quoted string syntax is stored as "
"Unicode."
msgstr ""
"–ü–æ—á–∏–Ω–∞—é—á–∏ –∑ Python 3.0, —Ç–∏–ø :class:`str` –º–æ–≤–∏ –º—ñ—Å—Ç–∏—Ç—å —Å–∏–º–≤–æ–ª–∏ Unicode, —Ç–æ–±—Ç–æ "
"–±—É–¥—å-—è–∫–∏–π —Ä—è–¥–æ–∫, —Å—Ç–≤–æ—Ä–µ–Ω–∏–π –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é ``\"unicode rocks!\"``, ``'unicode "
"rocks!'`` –∞–±–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å —Ä—è–¥–∫–∞ –≤ –ø–æ—Ç—Ä—ñ–π–Ω–∏—Ö –ª–∞–ø–∫–∞—Ö –∑–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è —è–∫ Unicode."

#: ../../howto/unicode.rst:196
msgid ""
"The default encoding for Python source code is UTF-8, so you can simply "
"include a Unicode character in a string literal::"
msgstr ""
"–ö–æ–¥—É–≤–∞–Ω–Ω—è–º –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º –¥–ª—è –≤–∏—Ö—ñ–¥–Ω–æ–≥–æ –∫–æ–¥—É Python —î UTF-8, —Ç–æ–º—É –≤–∏ "
"–º–æ–∂–µ—Ç–µ –ø—Ä–æ—Å—Ç–æ –≤–∫–ª—é—á–∏—Ç–∏ —Å–∏–º–≤–æ–ª –Æ–Ω—ñ–∫–æ–¥—É –≤ —Ä—è–¥–∫–æ–≤–∏–π –ª—ñ—Ç–µ—Ä–∞–ª::"

#: ../../howto/unicode.rst:199
msgid ""
"try:\n"
"    with open('/tmp/input.txt', 'r') as f:\n"
"        ...\n"
"except OSError:\n"
"    # 'File not found' error message.\n"
"    print(\"Fichier non trouv√©\")"
msgstr ""
"try:\n"
"    with open('/tmp/input.txt', 'r') as f:\n"
"        ...\n"
"except OSError:\n"
"    # 'File not found' error message.\n"
"    print(\"Fichier non trouv√©\")"

#: ../../howto/unicode.rst:206
msgid ""
"Side note: Python 3 also supports using Unicode characters in identifiers::"
msgstr ""
"–ü—Ä–∏–º—ñ—Ç–∫–∞: Python 3 —Ç–∞–∫–æ–∂ –ø—ñ–¥—Ç—Ä–∏–º—É—î –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è —Å–∏–º–≤–æ–ª—ñ–≤ Unicode –≤ "
"—ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∞—Ö:"

#: ../../howto/unicode.rst:208
msgid ""
"r√©pertoire = \"/tmp/records.log\"\n"
"with open(r√©pertoire, \"w\") as f:\n"
"    f.write(\"test\\n\")"
msgstr ""
"r√©pertoire = \"/tmp/records.log\"\n"
"with open(r√©pertoire, \"w\") as f:\n"
"    f.write(\"test\\n\")"

#: ../../howto/unicode.rst:212
msgid ""
"If you can't enter a particular character in your editor or want to keep the "
"source code ASCII-only for some reason, you can also use escape sequences in "
"string literals. (Depending on your system, you may see the actual capital-"
"delta glyph instead of a \\u escape.) ::"
msgstr ""
"–Ø–∫—â–æ –≤–∏ –Ω–µ –º–æ–∂–µ—Ç–µ –≤–≤–µ—Å—Ç–∏ –ø–µ–≤–Ω–∏–π —Å–∏–º–≤–æ–ª —É —Å–≤–æ—î–º—É —Ä–µ–¥–∞–∫—Ç–æ—Ä—ñ –∞–±–æ –∑ —è–∫–æ—ó—Å—å "
"–ø—Ä–∏—á–∏–Ω–∏ —Ö–æ—á–µ—Ç–µ –∑–±–µ—Ä–µ–≥—Ç–∏ –≤–∏—Ö—ñ–¥–Ω–∏–π –∫–æ–¥ –ª–∏—à–µ ASCII, –≤–∏ —Ç–∞–∫–æ–∂ –º–æ–∂–µ—Ç–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ "
"–∫–µ—Ä—É—é—á—ñ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ –≤ —Ä—è–¥–∫–æ–≤–∏—Ö –ª—ñ—Ç–µ—Ä–∞–ª–∞—Ö. (–ó–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –≤–∞—à–æ—ó —Å–∏—Å—Ç–µ–º–∏, –≤–∏ "
"–º–æ–∂–µ—Ç–µ –ø–æ–±–∞—á–∏—Ç–∏ —Å–ø—Ä–∞–≤–∂–Ω—ñ–π –≥–ª—ñ—Ñ –≤–µ–ª–∏–∫–æ—ó –¥–µ–ª—å—Ç–∏ –∑–∞–º—ñ—Å—Ç—å —Å–∏–º–≤–æ–ª—É \\u.) ::"

#: ../../howto/unicode.rst:217
msgid ""
">>> \"\\N{GREEK CAPITAL LETTER DELTA}\"  # Using the character name\n"
"'\\u0394'\n"
">>> \"\\u0394\"                          # Using a 16-bit hex value\n"
"'\\u0394'\n"
">>> \"\\U00000394\"                      # Using a 32-bit hex value\n"
"'\\u0394'"
msgstr ""
">>> \"\\N{GREEK CAPITAL LETTER DELTA}\"  # Using the character name\n"
"'\\u0394'\n"
">>> \"\\u0394\"                          # Using a 16-bit hex value\n"
"'\\u0394'\n"
">>> \"\\U00000394\"                      # Using a 32-bit hex value\n"
"'\\u0394'"

#: ../../howto/unicode.rst:224
msgid ""
"In addition, one can create a string using the :func:`~bytes.decode` method "
"of :class:`bytes`.  This method takes an *encoding* argument, such as "
"``UTF-8``, and optionally an *errors* argument."
msgstr ""
"–ö—Ä—ñ–º —Ç–æ–≥–æ, –º–æ–∂–Ω–∞ —Å—Ç–≤–æ—Ä–∏—Ç–∏ —Ä—è–¥–æ–∫ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –º–µ—Ç–æ–¥—É :func:`~bytes.decode` :"
"class:`bytes`. –¶–µ–π –º–µ—Ç–æ–¥ –ø—Ä–∏–π–º–∞—î –∞—Ä–≥—É–º–µ–Ω—Ç *–∫–æ–¥—É–≤–∞–Ω–Ω—è*, —Ç–∞–∫–∏–π —è–∫ ``UTF-8``, —ñ "
"–Ω–µ–æ–±–æ–≤‚Äô—è–∑–∫–æ–≤–æ –∞—Ä–≥—É–º–µ–Ω—Ç *–ø–æ–º–∏–ª–∫–∏*."

#: ../../howto/unicode.rst:228
msgid ""
"The *errors* argument specifies the response when the input string can't be "
"converted according to the encoding's rules.  Legal values for this argument "
"are ``'strict'`` (raise a :exc:`UnicodeDecodeError` exception), "
"``'replace'`` (use ``U+FFFD``, ``REPLACEMENT CHARACTER``), ``'ignore'`` "
"(just leave the character out of the Unicode result), or "
"``'backslashreplace'`` (inserts a ``\\xNN`` escape sequence). The following "
"examples show the differences::"
msgstr ""
"–ê—Ä–≥—É–º–µ–Ω—Ç *errors* –≤–∏–∑–Ω–∞—á–∞—î –≤—ñ–¥–ø–æ–≤—ñ–¥—å, –∫–æ–ª–∏ –≤—Ö—ñ–¥–Ω–∏–π —Ä—è–¥–æ–∫ –Ω–µ –º–æ–∂–Ω–∞ "
"–ø–µ—Ä–µ—Ç–≤–æ—Ä–∏—Ç–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ –¥–æ –ø—Ä–∞–≤–∏–ª –∫–æ–¥—É–≤–∞–Ω–Ω—è. –î–æ–ø—É—Å—Ç–∏–º—ñ –∑–Ω–∞—á–µ–Ω–Ω—è –¥–ª—è —Ü—å–æ–≥–æ "
"–∞—Ä–≥—É–º–µ–Ω—Ç—É: ``'strict'`` (–≤–∏–∫–ª–∏–∫–∞—î –≤–∏–Ω—è—Ç–æ–∫ :exc:`UnicodeDecodeError`), "
"``'replace`` (–≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ ``U+FFFD``, ``REPLACEMENT CHARACTER``), "
"``'ignore'`` (–ø—Ä–æ—Å—Ç–æ –∑–∞–ª–∏—à—Ç–µ —Å–∏–º–≤–æ–ª –ø–æ–∑–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –Æ–Ω—ñ–∫–æ–¥—É) –∞–±–æ "
"``'backslashreplace'`` (–≤—Å—Ç–∞–≤–ª—è—î –∫–µ—Ä—É—é—á—É –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å ``\\xNN``). –ù–∞—Å—Ç—É–ø–Ω—ñ "
"–ø—Ä–∏–∫–ª–∞–¥–∏ –ø–æ–∫–∞–∑—É—é—Ç—å –≤—ñ–¥–º—ñ–Ω–Ω–æ—Å—Ç—ñ:"

#: ../../howto/unicode.rst:236
msgid ""
">>> b'\\x80abc'.decode(\"utf-8\", \"strict\")\n"
"Traceback (most recent call last):\n"
"    ...\n"
"UnicodeDecodeError: 'utf-8' codec can't decode byte 0x80 in position 0:\n"
"  invalid start byte\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"replace\")\n"
"'\\ufffdabc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"backslashreplace\")\n"
"'\\\\x80abc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"ignore\")\n"
"'abc'"
msgstr ""
">>> b'\\x80abc'.decode(\"utf-8\", \"strict\")\n"
"Traceback (most recent call last):\n"
"    ...\n"
"UnicodeDecodeError: 'utf-8' codec can't decode byte 0x80 in position 0:\n"
"  invalid start byte\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"replace\")\n"
"'\\ufffdabc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"backslashreplace\")\n"
"'\\\\x80abc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"ignore\")\n"
"'abc'"

#: ../../howto/unicode.rst:248
msgid ""
"Encodings are specified as strings containing the encoding's name.  Python "
"comes with roughly 100 different encodings; see the Python Library Reference "
"at :ref:`standard-encodings` for a list.  Some encodings have multiple "
"names; for example, ``'latin-1'``, ``'iso_8859_1'`` and ``'8859``' are all "
"synonyms for the same encoding."
msgstr ""
"–ö–æ–¥—É–≤–∞–Ω–Ω—è –≤–∫–∞–∑—É—é—Ç—å—Å—è —è–∫ —Ä—è–¥–∫–∏, —â–æ –º—ñ—Å—Ç—è—Ç—å –Ω–∞–∑–≤—É –∫–æ–¥—É–≤–∞–Ω–Ω—è. Python "
"–ø–æ—Å—Ç–∞–≤–ª—è—î—Ç—å—Å—è –∑ –ø—Ä–∏–±–ª–∏–∑–Ω–æ 100 —Ä—ñ–∑–Ω–∏–º–∏ –∫–æ–¥—É–≤–∞–Ω–Ω—è–º–∏; –ø–µ—Ä–µ–≥–ª—è–Ω—å—Ç–µ —Å–ø–∏—Å–æ–∫ —É "
"–î–æ–≤—ñ–¥–Ω–∏–∫—É –∑ –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∏ Python –∑–∞ –∞–¥—Ä–µ—Å–æ—é :ref:`standard-encodings`. –î–µ—è–∫—ñ "
"–∫–æ–¥—É–≤–∞–Ω–Ω—è –º–∞—é—Ç—å –∫—ñ–ª—å–∫–∞ —ñ–º–µ–Ω; –Ω–∞–ø—Ä–∏–∫–ª–∞–¥, \"latin-1\", \"iso_8859_1\" —ñ "
"\"8859\" —î —Å–∏–Ω–æ–Ω—ñ–º–∞–º–∏ –æ–¥–Ω–æ–≥–æ –∫–æ–¥—É–≤–∞–Ω–Ω—è."

#: ../../howto/unicode.rst:254
msgid ""
"One-character Unicode strings can also be created with the :func:`chr` built-"
"in function, which takes integers and returns a Unicode string of length 1 "
"that contains the corresponding code point.  The reverse operation is the "
"built-in :func:`ord` function that takes a one-character Unicode string and "
"returns the code point value::"
msgstr ""
"–û–¥–Ω–æ—Å–∏–º–≤–æ–ª—å–Ω—ñ —Ä—è–¥–∫–∏ Unicode —Ç–∞–∫–æ–∂ –º–æ–∂–Ω–∞ —Å—Ç–≤–æ—Ä–∏—Ç–∏ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –≤–±—É–¥–æ–≤–∞–Ω–æ—ó "
"—Ñ—É–Ω–∫—Ü—ñ—ó :func:`chr`, —è–∫–∞ –ø—Ä–∏–π–º–∞—î —Ü—ñ–ª—ñ —á–∏—Å–ª–∞ —Ç–∞ –ø–æ–≤–µ—Ä—Ç–∞—î —Ä—è–¥–æ–∫ Unicode "
"–¥–æ–≤–∂–∏–Ω–æ—é 1, —è–∫–∏–π –º—ñ—Å—Ç–∏—Ç—å –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω—É –∫–æ–¥–æ–≤—É —Ç–æ—á–∫—É. –ó–≤–æ—Ä–æ—Ç–Ω–æ—é –æ–ø–µ—Ä–∞—Ü—ñ—î—é —î "
"–≤–±—É–¥–æ–≤–∞–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è :func:`ord`, —è–∫–∞ –ø—Ä–∏–π–º–∞—î –æ–¥–Ω–æ—Å–∏–º–≤–æ–ª—å–Ω–∏–π —Ä—è–¥–æ–∫ –Æ–Ω—ñ–∫–æ–¥ —ñ "
"–ø–æ–≤–µ—Ä—Ç–∞—î –∑–Ω–∞—á–µ–Ω–Ω—è –∫–æ–¥–æ–≤–æ—ó —Ç–æ—á–∫–∏::"

#: ../../howto/unicode.rst:260
msgid ""
">>> chr(57344)\n"
"'\\ue000'\n"
">>> ord('\\ue000')\n"
"57344"
msgstr ""
">>> chr(57344)\n"
"'\\ue000'\n"
">>> ord('\\ue000')\n"
"57344"

#: ../../howto/unicode.rst:266
msgid "Converting to Bytes"
msgstr "Convertendo para Bytes"

#: ../../howto/unicode.rst:268
msgid ""
"The opposite method of :meth:`bytes.decode` is :meth:`str.encode`, which "
"returns a :class:`bytes` representation of the Unicode string, encoded in "
"the requested *encoding*."
msgstr ""
"–ü—Ä–æ—Ç–∏–ª–µ–∂–Ω–∏–º –º–µ—Ç–æ–¥–æ–º :meth:`bytes.decode` —î :meth:`str.encode`, —è–∫–∏–π "
"–ø–æ–≤–µ—Ä—Ç–∞—î :class:`bytes` –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è —Ä—è–¥–∫–∞ –Æ–Ω—ñ–∫–æ–¥, –∑–∞–∫–æ–¥–æ–≤–∞–Ω–æ–≥–æ –≤ "
"–ø–æ—Ç—Ä—ñ–±–Ω–æ–º—É *–∫–æ–¥—É–≤–∞–Ω–Ω—ñ*."

#: ../../howto/unicode.rst:272
msgid ""
"The *errors* parameter is the same as the parameter of the :meth:`~bytes."
"decode` method but supports a few more possible handlers. As well as "
"``'strict'``, ``'ignore'``, and ``'replace'`` (which in this case inserts a "
"question mark instead of the unencodable character), there is also "
"``'xmlcharrefreplace'`` (inserts an XML character reference), "
"``backslashreplace`` (inserts a ``\\uNNNN`` escape sequence) and "
"``namereplace`` (inserts a ``\\N{...}`` escape sequence)."
msgstr ""
"–ü–∞—Ä–∞–º–µ—Ç—Ä *errors* —Ç–∞–∫–∏–π —Å–∞–º–∏–π, —è–∫ —ñ –ø–∞—Ä–∞–º–µ—Ç—Ä –º–µ—Ç–æ–¥—É :meth:`~bytes.decode`, "
"–∞–ª–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î –∫—ñ–ª—å–∫–∞ —ñ–Ω—à–∏—Ö –º–æ–∂–ª–∏–≤–∏—Ö –æ–±—Ä–æ–±–Ω–∏–∫—ñ–≤. –ö—Ä—ñ–º ``'strict'``, "
"``'ignore'`` —ñ ``'replace'`` (—è–∫–∏–π —É —Ü—å–æ–º—É –≤–∏–ø–∞–¥–∫—É –≤—Å—Ç–∞–≤–ª—è—î –∑–Ω–∞–∫ –ø–∏—Ç–∞–Ω–Ω—è "
"–∑–∞–º—ñ—Å—Ç—å –Ω–µ–∫–æ–¥–æ–≤–∞–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª—É), —î —Ç–∞–∫–æ–∂ ``'xmlcharrefreplace \"`` (–≤—Å—Ç–∞–≤–ª—è—î "
"–ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ —Å–∏–º–≤–æ–ª XML), ``backslashreplace`` (–≤—Å—Ç–∞–≤–ª—è—î –∫–µ—Ä—É—é—á—É "
"–ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å ``\\uNNNN``) —ñ ``namereplace`` (–≤—Å—Ç–∞–≤–ª—è—î –∫–µ—Ä—É—é—á—É –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å "
"``\\N{...}`` )."

#: ../../howto/unicode.rst:280
msgid "The following example shows the different results::"
msgstr "–£ –Ω–∞—Å—Ç—É–ø–Ω–æ–º—É –ø—Ä–∏–∫–ª–∞–¥—ñ –ø–æ–∫–∞–∑–∞–Ω–æ —Ä—ñ–∑–Ω—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏:"

#: ../../howto/unicode.rst:282
msgid ""
">>> u = chr(40960) + 'abcd' + chr(1972)\n"
">>> u.encode('utf-8')\n"
"b'\\xea\\x80\\x80abcd\\xde\\xb4'\n"
">>> u.encode('ascii')\n"
"Traceback (most recent call last):\n"
"    ...\n"
"UnicodeEncodeError: 'ascii' codec can't encode character '\\ua000' in\n"
"  position 0: ordinal not in range(128)\n"
">>> u.encode('ascii', 'ignore')\n"
"b'abcd'\n"
">>> u.encode('ascii', 'replace')\n"
"b'?abcd?'\n"
">>> u.encode('ascii', 'xmlcharrefreplace')\n"
"b'&#40960;abcd&#1972;'\n"
">>> u.encode('ascii', 'backslashreplace')\n"
"b'\\\\ua000abcd\\\\u07b4'\n"
">>> u.encode('ascii', 'namereplace')\n"
"b'\\\\N{YI SYLLABLE IT}abcd\\\\u07b4'"
msgstr ""
">>> u = chr(40960) + 'abcd' + chr(1972)\n"
">>> u.encode('utf-8')\n"
"b'\\xea\\x80\\x80abcd\\xde\\xb4'\n"
">>> u.encode('ascii')\n"
"Traceback (most recent call last):\n"
"    ...\n"
"UnicodeEncodeError: 'ascii' codec can't encode character '\\ua000' in\n"
"  position 0: ordinal not in range(128)\n"
">>> u.encode('ascii', 'ignore')\n"
"b'abcd'\n"
">>> u.encode('ascii', 'replace')\n"
"b'?abcd?'\n"
">>> u.encode('ascii', 'xmlcharrefreplace')\n"
"b'&#40960;abcd&#1972;'\n"
">>> u.encode('ascii', 'backslashreplace')\n"
"b'\\\\ua000abcd\\\\u07b4'\n"
">>> u.encode('ascii', 'namereplace')\n"
"b'\\\\N{YI SYLLABLE IT}abcd\\\\u07b4'"

#: ../../howto/unicode.rst:301
msgid ""
"The low-level routines for registering and accessing the available encodings "
"are found in the :mod:`codecs` module.  Implementing new encodings also "
"requires understanding the :mod:`codecs` module. However, the encoding and "
"decoding functions returned by this module are usually more low-level than "
"is comfortable, and writing new encodings is a specialized task, so the "
"module won't be covered in this HOWTO."
msgstr ""
"–ü—Ä–æ—Ü–µ–¥—É—Ä–∏ –Ω–∏–∑—å–∫–æ–≥–æ —Ä—ñ–≤–Ω—è –¥–ª—è —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó —Ç–∞ –¥–æ—Å—Ç—É–ø—É –¥–æ –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –∫–æ–¥—É–≤–∞–Ω—å "
"–º–æ–∂–Ω–∞ –∑–Ω–∞–π—Ç–∏ –≤ –º–æ–¥—É–ª—ñ :mod:`codecs`. –†–µ–∞–ª—ñ–∑–∞—Ü—ñ—è –Ω–æ–≤–∏—Ö –∫–æ–¥—É–≤–∞–Ω—å —Ç–∞–∫–æ–∂ –≤–∏–º–∞–≥–∞—î "
"—Ä–æ–∑—É–º—ñ–Ω–Ω—è –º–æ–¥—É–ª—è :mod:`codecs`. –û–¥–Ω–∞–∫ —Ñ—É–Ω–∫—Ü—ñ—ó –∫–æ–¥—É–≤–∞–Ω–Ω—è —Ç–∞ –¥–µ–∫–æ–¥—É–≤–∞–Ω–Ω—è, —è–∫—ñ "
"–ø–æ–≤–µ—Ä—Ç–∞—î —Ü–µ–π –º–æ–¥—É–ª—å, –∑–∞–∑–≤–∏—á–∞–π –Ω–∏–∂—á—ñ, –Ω—ñ–∂ –∑—Ä—É—á–Ω–æ, –∞ –Ω–∞–ø–∏—Å–∞–Ω–Ω—è –Ω–æ–≤–∏—Ö –∫–æ–¥—É–≤–∞–Ω—å "
"—î —Å–ø–µ—Ü—ñ–∞–ª—å–Ω–∏–º –∑–∞–≤–¥–∞–Ω–Ω—è–º, —Ç–æ–º—É —Ü–µ–π –º–æ–¥—É–ª—å –Ω–µ —Ä–æ–∑–≥–ª—è–¥–∞—Ç–∏–º–µ—Ç—å—Å—è –≤ —Ü—å–æ–º—É HOWTO."

#: ../../howto/unicode.rst:310
msgid "Unicode Literals in Python Source Code"
msgstr "–õ—ñ—Ç–µ—Ä–∞–ª–∏ Unicode —É –≤–∏—Ö—ñ–¥–Ω–æ–º—É –∫–æ–¥—ñ Python"

#: ../../howto/unicode.rst:312
msgid ""
"In Python source code, specific Unicode code points can be written using the "
"``\\u`` escape sequence, which is followed by four hex digits giving the "
"code point.  The ``\\U`` escape sequence is similar, but expects eight hex "
"digits, not four::"
msgstr ""
"–£ –≤–∏—Ö—ñ–¥–Ω–æ–º—É –∫–æ–¥—ñ Python –ø–µ–≤–Ω—ñ –∫–æ–¥–æ–≤—ñ —Ç–æ—á–∫–∏ Unicode –º–æ–∂–Ω–∞ –∑–∞–ø–∏—Å–∞—Ç–∏ –∑–∞ "
"–¥–æ–ø–æ–º–æ–≥–æ—é escape-–ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ ``\\u``, –∑–∞ —è–∫–æ—é –π–¥—É—Ç—å —á–æ—Ç–∏—Ä–∏ —à—ñ—Å—Ç–Ω–∞–¥—Ü—è—Ç–∫–æ–≤—ñ "
"—Ü–∏—Ñ—Ä–∏, —â–æ –≤–∫–∞–∑—É—é—Ç—å –∫–æ–¥–æ–≤—É —Ç–æ—á–∫—É. –ï–∫—Ä–∞–Ω-–ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å ``\\U`` —Å—Ö–æ–∂–∞, –∞–ª–µ "
"–ø–µ—Ä–µ–¥–±–∞—á–∞—î –≤—ñ—Å—ñ–º —à—ñ—Å—Ç–Ω–∞–¥—Ü—è—Ç–∫–æ–≤–∏—Ö —Ü–∏—Ñ—Ä, –∞ –Ω–µ —á–æ—Ç–∏—Ä–∏:"

#: ../../howto/unicode.rst:317
msgid ""
">>> s = \"a\\xac\\u1234\\u20ac\\U00008000\"\n"
"... #     ^^^^ two-digit hex escape\n"
"... #         ^^^^^^ four-digit Unicode escape\n"
"... #                     ^^^^^^^^^^ eight-digit Unicode escape\n"
">>> [ord(c) for c in s]\n"
"[97, 172, 4660, 8364, 32768]"
msgstr ""
">>> s = \"a\\xac\\u1234\\u20ac\\U00008000\"\n"
"... #     ^^^^ two-digit hex escape\n"
"... #         ^^^^^^ four-digit Unicode escape\n"
"... #                     ^^^^^^^^^^ eight-digit Unicode escape\n"
">>> [ord(c) for c in s]\n"
"[97, 172, 4660, 8364, 32768]"

#: ../../howto/unicode.rst:324
msgid ""
"Using escape sequences for code points greater than 127 is fine in small "
"doses, but becomes an annoyance if you're using many accented characters, as "
"you would in a program with messages in French or some other accent-using "
"language.  You can also assemble strings using the :func:`chr` built-in "
"function, but this is even more tedious."
msgstr ""
"–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –∫–µ—Ä—É—é—á–∏—Ö –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç–µ–π –¥–ª—è –∫–æ–¥–æ–≤–∏—Ö —Ç–æ—á–æ–∫ –±—ñ–ª—å—à–µ 127 –¥–æ–±—Ä–µ –≤ "
"–Ω–µ–≤–µ–ª–∏–∫–∏—Ö –¥–æ–∑–∞—Ö, –∞–ª–µ —Å—Ç–∞—î –Ω–µ–ø—Ä–∏—î–º–Ω–∏–º, —è–∫—â–æ –≤–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç–µ –±–∞–≥–∞—Ç–æ —Å–∏–º–≤–æ–ª—ñ–≤ "
"–∑ –∞–∫—Ü–µ–Ω—Ç–∞–º–∏, —è–∫ —Ü–µ –±—É–ª–æ –± —É –ø—Ä–æ–≥—Ä–∞–º—ñ –∑ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º–∏ —Ñ—Ä–∞–Ω—Ü—É–∑—å–∫–æ—é –∞–±–æ —ñ–Ω—à–æ—é "
"–º–æ–≤–æ—é, —â–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î –∞–∫—Ü–µ–Ω—Ç–∏. –í–∏ —Ç–∞–∫–æ–∂ –º–æ–∂–µ—Ç–µ –∑–±–∏—Ä–∞—Ç–∏ —Ä—è–¥–∫–∏ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é "
"–≤–±—É–¥–æ–≤–∞–Ω–æ—ó —Ñ—É–Ω–∫—Ü—ñ—ó :func:`chr`, –∞–ª–µ —Ü–µ —â–µ –±—ñ–ª—å—à–µ —Å—Ç–æ–º–ª—é—î."

#: ../../howto/unicode.rst:330
msgid ""
"Ideally, you'd want to be able to write literals in your language's natural "
"encoding.  You could then edit Python source code with your favorite editor "
"which would display the accented characters naturally, and have the right "
"characters used at runtime."
msgstr ""
"–í —ñ–¥–µ–∞–ª—ñ –≤–∏ —Ö–æ—Ç—ñ–ª–∏ –± –º–∞—Ç–∏ –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å –ø–∏—Å–∞—Ç–∏ –ª—ñ—Ç–µ—Ä–∞–ª–∏ –≤ –ø—Ä–∏—Ä–æ–¥–Ω–æ–º—É –∫–æ–¥—É–≤–∞–Ω–Ω—ñ "
"–≤–∞—à–æ—ó –º–æ–≤–∏. –ü–æ—Ç—ñ–º –≤–∏ –º–æ–∂–µ—Ç–µ –≤—ñ–¥—Ä–µ–¥–∞–≥—É–≤–∞—Ç–∏ –≤–∏—Ö—ñ–¥–Ω–∏–π –∫–æ–¥ Python –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é "
"—Å–≤–æ–≥–æ —É–ª—é–±–ª–µ–Ω–æ–≥–æ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞, —è–∫–∏–π –ø—Ä–∏—Ä–æ–¥–Ω–∏–º —á–∏–Ω–æ–º –≤—ñ–¥–æ–±—Ä–∞–∂–∞—Ç–∏–º–µ —Å–∏–º–≤–æ–ª–∏ –∑ "
"–∞–∫—Ü–µ–Ω—Ç–∞–º–∏ —Ç–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏–º–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ñ —Å–∏–º–≤–æ–ª–∏ –ø—ñ–¥ —á–∞—Å –≤–∏–∫–æ–Ω–∞–Ω–Ω—è."

#: ../../howto/unicode.rst:335
msgid ""
"Python supports writing source code in UTF-8 by default, but you can use "
"almost any encoding if you declare the encoding being used.  This is done by "
"including a special comment as either the first or second line of the source "
"file::"
msgstr ""
"Python –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º –ø—ñ–¥—Ç—Ä–∏–º—É—î –Ω–∞–ø–∏—Å–∞–Ω–Ω—è –≤–∏—Ö—ñ–¥–Ω–æ–≥–æ –∫–æ–¥—É –≤ UTF-8, –∞–ª–µ –≤–∏ "
"–º–æ–∂–µ—Ç–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ –º–∞–π–∂–µ –±—É–¥—å-—è–∫–µ –∫–æ–¥—É–≤–∞–Ω–Ω—è, —è–∫—â–æ –≤–∏ –æ–≥–æ–ª–æ—Å–∏—Ç–µ "
"–∫–æ–¥—É–≤–∞–Ω–Ω—è, —è–∫–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è. –¶–µ —Ä–æ–±–∏—Ç—å—Å—è —à–ª—è—Ö–æ–º –¥–æ–¥–∞–≤–∞–Ω–Ω—è —Å–ø–µ—Ü—ñ–∞–ª—å–Ω–æ–≥–æ "
"–∫–æ–º–µ–Ω—Ç–∞—Ä—è —è–∫ –ø–µ—Ä—à–æ–≥–æ –∞–±–æ –¥—Ä—É–≥–æ–≥–æ —Ä—è–¥–∫–∞ –≤–∏—Ö—ñ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª—É::"

#: ../../howto/unicode.rst:339
msgid ""
"#!/usr/bin/env python\n"
"# -*- coding: latin-1 -*-\n"
"\n"
"u = 'abcd√©'\n"
"print(ord(u[-1]))"
msgstr ""
"#!/usr/bin/env python\n"
"# -*- coding: latin-1 -*-\n"
"\n"
"u = 'abcd√©'\n"
"print(ord(u[-1]))"

#: ../../howto/unicode.rst:345
msgid ""
"The syntax is inspired by Emacs's notation for specifying variables local to "
"a file.  Emacs supports many different variables, but Python only supports "
"'coding'.  The ``-*-`` symbols indicate to Emacs that the comment is "
"special; they have no significance to Python but are a convention.  Python "
"looks for ``coding: name`` or ``coding=name`` in the comment."
msgstr ""
"–°–∏–Ω—Ç–∞–∫—Å–∏—Å –Ω–∞—Ç—Ö–Ω–µ–Ω–Ω–∏–π –Ω–æ—Ç–∞—Ü—ñ—î—é Emacs –¥–ª—è –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è –∑–º—ñ–Ω–Ω–∏—Ö, –ª–æ–∫–∞–ª—å–Ω–∏—Ö –¥–ª—è "
"—Ñ–∞–π–ª—É. Emacs –ø—ñ–¥—Ç—Ä–∏–º—É—î –±–∞–≥–∞—Ç–æ —Ä—ñ–∑–Ω–∏—Ö –∑–º—ñ–Ω–Ω–∏—Ö, –∞–ª–µ Python –ø—ñ–¥—Ç—Ä–∏–º—É—î –ª–∏—à–µ "
"\"–∫–æ–¥—É–≤–∞–Ω–Ω—è\". –°–∏–º–≤–æ–ª–∏ ``-*-`` –≤–∫–∞–∑—É—é—Ç—å Emacs, —â–æ –∫–æ–º–µ–Ω—Ç–∞—Ä —î –æ—Å–æ–±–ª–∏–≤–∏–º; –≤–æ–Ω–∏ "
"–Ω–µ –º–∞—é—Ç—å –∑–Ω–∞—á–µ–Ω–Ω—è –¥–ª—è Python, –∞–ª–µ —î —É–º–æ–≤–Ω—ñ—Å—Ç—é. Python —à—É–∫–∞—î ``coding: name`` "
"–∞–±–æ ``coding=name`` —É –∫–æ–º–µ–Ω—Ç–∞—Ä—ñ."

#: ../../howto/unicode.rst:351
msgid ""
"If you don't include such a comment, the default encoding used will be UTF-8 "
"as already mentioned.  See also :pep:`263` for more information."
msgstr ""
"–Ø–∫—â–æ –≤–∏ –Ω–µ –≤–∫–ª—é—á–∏—Ç–µ —Ç–∞–∫–∏–π –∫–æ–º–µ–Ω—Ç–∞—Ä, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞–Ω–∏–º –∫–æ–¥—É–≤–∞–Ω–Ω—è–º –∑–∞ "
"—É–º–æ–≤—á–∞–Ω–Ω—è–º –±—É–¥–µ UTF-8, —è–∫ —É–∂–µ –∑–≥–∞–¥—É–≤–∞–ª–æ—Å—è. –î–∏–≤—ñ—Ç—å—Å—è —Ç–∞–∫–æ–∂ :pep:`263` –¥–ª—è "
"–æ—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ–¥–∞—Ç–∫–æ–≤–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó."

#: ../../howto/unicode.rst:356
msgid "Unicode Properties"
msgstr "Propriedades Unicode"

#: ../../howto/unicode.rst:358
msgid ""
"The Unicode specification includes a database of information about code "
"points.  For each defined code point, the information includes the "
"character's name, its category, the numeric value if applicable (for "
"characters representing numeric concepts such as the Roman numerals, "
"fractions such as one-third and four-fifths, etc.).  There are also display-"
"related properties, such as how to use the code point in bidirectional text."
msgstr ""
"–°–ø–µ—Ü–∏—Ñ—ñ–∫–∞—Ü—ñ—è Unicode –≤–∫–ª—é—á–∞—î –±–∞–∑—É –¥–∞–Ω–∏—Ö —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –ø—Ä–æ –∫–æ–¥–æ–≤—ñ —Ç–æ—á–∫–∏. –î–ª—è "
"–∫–æ–∂–Ω–æ—ó –≤–∏–∑–Ω–∞—á–µ–Ω–æ—ó –∫–æ–¥–æ–≤–æ—ó —Ç–æ—á–∫–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –≤–∫–ª—é—á–∞—î —ñ–º‚Äô—è —Å–∏–º–≤–æ–ª—É, –π–æ–≥–æ "
"–∫–∞—Ç–µ–≥–æ—Ä—ñ—é, —á–∏—Å–ª–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è, —è–∫—â–æ —Ü–µ –∑–∞—Å—Ç–æ—Å–æ–≤–Ω–æ (–¥–ª—è —Å–∏–º–≤–æ–ª—ñ–≤, —â–æ "
"–ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç—å —á–∏—Å–ª–æ–≤—ñ –ø–æ–Ω—è—Ç—Ç—è, —Ç–∞–∫—ñ —è–∫ —Ä–∏–º—Å—å–∫—ñ —Ü–∏—Ñ—Ä–∏, –¥—Ä–æ–±–∏, —Ç–∞–∫—ñ —è–∫ –æ–¥–Ω–∞ "
"—Ç—Ä–µ—Ç–∏–Ω–∞ —Ç–∞ —á–æ—Ç–∏—Ä–∏ –ø‚Äô—è—Ç–∏—Ö —Ç–æ—â–æ). –Ü—Å–Ω—É—é—Ç—å —Ç–∞–∫–æ–∂ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ, –ø–æ–≤‚Äô—è–∑–∞–Ω—ñ –∑ "
"–≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è–º, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥, —è–∫ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ –∫–æ–¥–æ–≤—É —Ç–æ—á–∫—É –≤ –¥–≤–æ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–æ–º—É "
"—Ç–µ–∫—Å—Ç—ñ."

#: ../../howto/unicode.rst:366
msgid ""
"The following program displays some information about several characters, "
"and prints the numeric value of one particular character::"
msgstr ""
"O programa a seguir exibe alguma informa√ß√£o sobre diversos caracteres e "
"imprime o valor num√©rico de um caractere em particular::"

#: ../../howto/unicode.rst:369
msgid ""
"import unicodedata\n"
"\n"
"u = chr(233) + chr(0x0bf2) + chr(3972) + chr(6000) + chr(13231)\n"
"\n"
"for i, c in enumerate(u):\n"
"    print(i, '%04x' % ord(c), unicodedata.category(c), end=\" \")\n"
"    print(unicodedata.name(c))\n"
"\n"
"# Get numeric value of second character\n"
"print(unicodedata.numeric(u[1]))"
msgstr ""
"import unicodedata\n"
"\n"
"u = chr(233) + chr(0x0bf2) + chr(3972) + chr(6000) + chr(13231)\n"
"\n"
"for i, c in enumerate(u):\n"
"    print(i, '%04x' % ord(c), unicodedata.category(c), end=\" \")\n"
"    print(unicodedata.name(c))\n"
"\n"
"# Get numeric value of second character\n"
"print(unicodedata.numeric(u[1]))"

#: ../../howto/unicode.rst:380
msgid "When run, this prints:"
msgstr "Quando executado, isso imprime:"

#: ../../howto/unicode.rst:382
msgid ""
"0 00e9 Ll LATIN SMALL LETTER E WITH ACUTE\n"
"1 0bf2 No TAMIL NUMBER ONE THOUSAND\n"
"2 0f84 Mn TIBETAN MARK HALANTA\n"
"3 1770 Lo TAGBANWA LETTER SA\n"
"4 33af So SQUARE RAD OVER S SQUARED\n"
"1000.0"
msgstr ""
"0 00e9 Ll LATIN SMALL LETTER E WITH ACUTE\n"
"1 0bf2 No TAMIL NUMBER ONE THOUSAND\n"
"2 0f84 Mn TIBETAN MARK HALANTA\n"
"3 1770 Lo TAGBANWA LETTER SA\n"
"4 33af So SQUARE RAD OVER S SQUARED\n"
"1000.0"

#: ../../howto/unicode.rst:391
msgid ""
"The category codes are abbreviations describing the nature of the character. "
"These are grouped into categories such as \"Letter\", \"Number\", "
"\"Punctuation\", or \"Symbol\", which in turn are broken up into "
"subcategories.  To take the codes from the above output, ``'Ll'`` means "
"'Letter, lowercase', ``'No'`` means \"Number, other\", ``'Mn'`` is \"Mark, "
"nonspacing\", and ``'So'`` is \"Symbol, other\".  See `the General Category "
"Values section of the Unicode Character Database documentation <https://www."
"unicode.org/reports/tr44/#General_Category_Values>`_ for a list of category "
"codes."
msgstr ""
"–ö–æ–¥–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ–π ‚Äî —Ü–µ –∞–±—Ä–µ–≤—ñ–∞—Ç—É—Ä–∏, —â–æ –æ–ø–∏—Å—É—é—Ç—å —Ö–∞—Ä–∞–∫—Ç–µ—Ä –ø–µ—Ä—Å–æ–Ω–∞–∂–∞. –í–æ–Ω–∏ "
"–∑–≥—Ä—É–ø–æ–≤–∞–Ω—ñ –≤ —Ç–∞–∫—ñ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó, —è–∫ \"–õ—ñ—Ç–µ—Ä–∞\", \"–¶–∏—Ñ—Ä–∞\", \"–ü—É–Ω–∫—Ç—É–∞—Ü—ñ—è\" –∞–±–æ "
"\"–°–∏–º–≤–æ–ª\", —è–∫—ñ, —É —Å–≤–æ—é —á–µ—Ä–≥—É, —Ä–æ–∑–±–∏—Ç—ñ –Ω–∞ –ø—ñ–¥–∫–∞—Ç–µ–≥–æ—Ä—ñ—ó. –©–æ–± –≤–∑—è—Ç–∏ –∫–æ–¥–∏ –∑ "
"–Ω–∞–≤–µ–¥–µ–Ω–æ–≥–æ –≤–∏—â–µ –≤–∏–≤–æ–¥—É, ``'Ll'`` –æ–∑–Ω–∞—á–∞—î '–õ—ñ—Ç–µ—Ä–∞, –Ω–∏–∂–Ω—ñ–π —Ä–µ–≥—ñ—Å—Ç—Ä', ``'–ù—ñ'`` "
"–æ–∑–Ω–∞—á–∞—î \"–ß–∏—Å–ª–æ, —ñ–Ω—à–µ\", ``'Mn'`` —Ü–µ \"–ü–æ–∑–Ω–∞—á–∫–∞, –±–µ–∑ –ø—Ä–æ–±—ñ–ª—ñ–≤\" , –∞ ``'So'`` "
"—Ü–µ \"–°–∏–º–≤–æ–ª, —ñ–Ω—à–µ\". –ü–µ—Ä–µ–≥–ª—è–Ω—å—Ç–µ `—Ä–æ–∑–¥—ñ–ª –ó–∞–≥–∞–ª—å–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è –∫–∞—Ç–µ–≥–æ—Ä—ñ–π "
"–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó –±–∞–∑–∏ –¥–∞–Ω–∏—Ö —Å–∏–º–≤–æ–ª—ñ–≤ Unicode <https://www.unicode.org/reports/"
"tr44/#General_Category_Values>`_, —â–æ–± –æ—Ç—Ä–∏–º–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ –∫–æ–¥—ñ–≤ –∫–∞—Ç–µ–≥–æ—Ä—ñ–π."

#: ../../howto/unicode.rst:402
msgid "Comparing Strings"
msgstr "Comparando Strings"

#: ../../howto/unicode.rst:404
msgid ""
"Unicode adds some complication to comparing strings, because the same set of "
"characters can be represented by different sequences of code points.  For "
"example, a letter like '√™' can be represented as a single code point U+00EA, "
"or as U+0065 U+0302, which is the code point for 'e' followed by a code "
"point for 'COMBINING CIRCUMFLEX ACCENT'.  These will produce the same output "
"when printed, but one is a string of length 1 and the other is of length 2."
msgstr ""
"–Æ–Ω—ñ–∫–æ–¥ —É—Å–∫–ª–∞–¥–Ω—é—î –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è —Ä—è–¥–∫—ñ–≤, —Ç–æ–º—É —â–æ —Ç–æ–π —Å–∞–º–∏–π –Ω–∞–±—ñ—Ä —Å–∏–º–≤–æ–ª—ñ–≤ –º–æ–∂–µ "
"–±—É—Ç–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–π —Ä—ñ–∑–Ω–∏–º–∏ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—è–º–∏ –∫–æ–¥–æ–≤–∏—Ö —Ç–æ—á–æ–∫. –ù–∞–ø—Ä–∏–∫–ª–∞–¥, —Ç–∞–∫–∞ "
"–ª—ñ—Ç–µ—Ä–∞, —è–∫ \"√™\", –º–æ–∂–µ –±—É—Ç–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∞ —è–∫ –æ–¥–Ω–∞ –∫–æ–¥–æ–≤–∞ —Ç–æ—á–∫–∞ U+00EA –∞–±–æ —è–∫ "
"U+0065 U+0302, —è–∫–∞ —î –∫–æ–¥–æ–≤–æ—é —Ç–æ—á–∫–æ—é –¥–ª—è \"e\", –∑–∞ —è–∫–æ—é –π–¥–µ –∫–æ–¥–æ–≤–∞ —Ç–æ—á–∫–∞ –¥–ª—è "
"\"COMBINING CIRCUMFLEX ACCENT\". . –í–æ–Ω–∏ —Å—Ç–≤–æ—Ä—é–≤–∞—Ç–∏–º—É—Ç—å —Ç–æ–π —Å–∞–º–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç "
"–ø—ñ–¥ —á–∞—Å –¥—Ä—É–∫—É, –∞–ª–µ –æ–¥–∏–Ω –±—É–¥–µ —Ä—è–¥–∫–æ–º –¥–æ–≤–∂–∏–Ω–∏ 1, –∞ —ñ–Ω—à–∏–π ‚Äì –¥–æ–≤–∂–∏–Ω–æ—é 2."

#: ../../howto/unicode.rst:412
msgid ""
"One tool for a case-insensitive comparison is the :meth:`~str.casefold` "
"string method that converts a string to a case-insensitive form following an "
"algorithm described by the Unicode Standard.  This algorithm has special "
"handling for characters such as the German letter '√ü' (code point U+00DF), "
"which becomes the pair of lowercase letters 'ss'."
msgstr ""
"–û–¥–Ω–∏–º —ñ–∑ —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ñ–≤ –¥–ª—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –±–µ–∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è —Ä–µ–≥—ñ—Å—Ç—Ä—É —î –º–µ—Ç–æ–¥ —Ä—è–¥–∫–∞ :"
"meth:`~str.casefold`, —è–∫–∏–π –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î —Ä—è–¥–æ–∫ —É —Ñ–æ—Ä–º—É –±–µ–∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è —Ä–µ–≥—ñ—Å—Ç—Ä—É "
"–≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ –¥–æ –∞–ª–≥–æ—Ä–∏—Ç–º—É, –æ–ø–∏—Å–∞–Ω–æ–≥–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–æ–º Unicode. –¶–µ–π –∞–ª–≥–æ—Ä–∏—Ç–º –º–∞—î "
"–æ—Å–æ–±–ª–∏–≤—É –æ–±—Ä–æ–±–∫—É —Ç–∞–∫–∏—Ö —Å–∏–º–≤–æ–ª—ñ–≤, —è–∫ –Ω—ñ–º–µ—Ü—å–∫–∞ –ª—ñ—Ç–µ—Ä–∞ \"√ü\" (–∫–æ–¥–æ–≤–∏–π –∑–Ω–∞–∫ "
"U+00DF), —è–∫–∞ —Å—Ç–∞—î –ø–∞—Ä–æ—é –º–∞–ª–∏—Ö –ª—ñ—Ç–µ—Ä \"ss\"."

#: ../../howto/unicode.rst:421
msgid ""
">>> street = 'G√ºrzenichstra√üe'\n"
">>> street.casefold()\n"
"'g√ºrzenichstrasse'"
msgstr ""
">>> street = 'G√ºrzenichstra√üe'\n"
">>> street.casefold()\n"
"'g√ºrzenichstrasse'"

#: ../../howto/unicode.rst:425
msgid ""
"A second tool is the :mod:`unicodedata` module's :func:`~unicodedata."
"normalize` function that converts strings to one of several normal forms, "
"where letters followed by a combining character are replaced with single "
"characters.  :func:`~unicodedata.normalize` can be used to perform string "
"comparisons that won't falsely report inequality if two strings use "
"combining characters differently:"
msgstr ""
"–í—Ç–æ—Ä–æ–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç ‚Äî —ç—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è :func:`~unicodedata.normalize` –º–æ–¥—É–ª—è :mod:"
"`unicodedata`, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫–∏ –≤ –æ–¥–Ω—É –∏–∑ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –Ω–æ—Ä–º–∞–ª—å–Ω—ã—Ö "
"—Ñ–æ—Ä–º, –≥–¥–µ –±—É–∫–≤—ã, –∑–∞ –∫–æ—Ç–æ—Ä—ã–º–∏ —Å–ª–µ–¥—É–µ—Ç –æ–±—ä–µ–¥–∏–Ω—è—é—â–∏–π —Å–∏–º–≤–æ–ª, –∑–∞–º–µ–Ω—è—é—Ç—Å—è "
"–æ–¥–∏–Ω–æ—á–Ω—ã–º–∏ —Å–∏–º–≤–æ–ª–∞–º–∏. :func:`~unicodedata.normalize` –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è "
"—Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å—Ç—Ä–æ–∫, –∫–æ—Ç–æ—Ä–æ–µ –Ω–µ –±—É–¥–µ—Ç –≤—ã–¥–∞–≤–∞—Ç—å –ª–æ–∂–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–µ, "
"–µ—Å–ª–∏ –¥–≤–µ —Å—Ç—Ä–æ–∫–∏ –ø–æ-—Ä–∞–∑–Ω–æ–º—É –∏—Å–ø–æ–ª—å–∑—É—é—Ç –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å–∏–º–≤–æ–ª–æ–≤:"

#: ../../howto/unicode.rst:434
msgid ""
"import unicodedata\n"
"\n"
"def compare_strs(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(s1) == NFD(s2)\n"
"\n"
"single_char = '√™'\n"
"multiple_chars = '\\N{LATIN SMALL LETTER E}\\N{COMBINING CIRCUMFLEX "
"ACCENT}'\n"
"print('length of first string=', len(single_char))\n"
"print('length of second string=', len(multiple_chars))\n"
"print(compare_strs(single_char, multiple_chars))"
msgstr ""
"import unicodedata\n"
"\n"
"def compare_strs(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(s1) == NFD(s2)\n"
"\n"
"single_char = '√™'\n"
"multiple_chars = '\\N{LATIN SMALL LETTER E}\\N{COMBINING CIRCUMFLEX "
"ACCENT}'\n"
"print('length of first string=', len(single_char))\n"
"print('length of second string=', len(multiple_chars))\n"
"print(compare_strs(single_char, multiple_chars))"

#: ../../howto/unicode.rst:448
msgid "When run, this outputs:"
msgstr "–ü—ñ–¥ —á–∞—Å –∑–∞–ø—É—Å–∫—É —Ü–µ –≤–∏–≤–æ–¥–∏—Ç—å:"

#: ../../howto/unicode.rst:450
msgid ""
"$ python compare-strs.py\n"
"length of first string= 1\n"
"length of second string= 2\n"
"True"
msgstr ""
"$ python compare-strs.py\n"
"length of first string= 1\n"
"length of second string= 2\n"
"True"

#: ../../howto/unicode.rst:457
msgid ""
"The first argument to the :func:`~unicodedata.normalize` function is a "
"string giving the desired normalization form, which can be one of 'NFC', "
"'NFKC', 'NFD', and 'NFKD'."
msgstr ""
"–ü–µ—Ä—à–∏–º –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º —Ñ—É–Ω–∫—Ü—ñ—ó :func:`~unicodedata.normalize` —î —Ä—è–¥–æ–∫, —â–æ –Ω–∞–¥–∞—î "
"–±–∞–∂–∞–Ω—É —Ñ–æ—Ä–º—É –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—ó, —è–∫–∞ –º–æ–∂–µ –±—É—Ç–∏ –æ–¥–Ω—ñ—î—é –∑ \"NFC\", \"NFKC\", \"NFD\" "
"—ñ \"NFKD\"."

#: ../../howto/unicode.rst:461
msgid "The Unicode Standard also specifies how to do caseless comparisons::"
msgstr "–°—Ç–∞–Ω–¥–∞—Ä—Ç Unicode —Ç–∞–∫–æ–∂ –≤–∏–∑–Ω–∞—á–∞—î, —è–∫ —Ä–æ–±–∏—Ç–∏ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –±–µ–∑ —Ä–µ–≥—ñ—Å—Ç—Ä—É:"

#: ../../howto/unicode.rst:463
msgid ""
"import unicodedata\n"
"\n"
"def compare_caseless(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(NFD(s1).casefold()) == NFD(NFD(s2).casefold())\n"
"\n"
"# Example usage\n"
"single_char = '√™'\n"
"multiple_chars = '\\N{LATIN CAPITAL LETTER E}\\N{COMBINING CIRCUMFLEX "
"ACCENT}'\n"
"\n"
"print(compare_caseless(single_char, multiple_chars))"
msgstr ""
"import unicodedata\n"
"\n"
"def compare_caseless(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(NFD(s1).casefold()) == NFD(NFD(s2).casefold())\n"
"\n"
"# Example usage\n"
"single_char = '√™'\n"
"multiple_chars = '\\N{LATIN CAPITAL LETTER E}\\N{COMBINING CIRCUMFLEX "
"ACCENT}'\n"
"\n"
"print(compare_caseless(single_char, multiple_chars))"

#: ../../howto/unicode.rst:477
msgid ""
"This will print ``True``.  (Why is :func:`!NFD` invoked twice?  Because "
"there are a few characters that make :meth:`~str.casefold` return a non-"
"normalized string, so the result needs to be normalized again. See section "
"3.13 of the Unicode Standard for a discussion and an example.)"
msgstr ""
"–≠—Ç–æ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç ``True``. (–ü–æ—á–µ–º—É :func:`!NFD` –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –¥–≤–∞–∂–¥—ã? –ü–æ—Ç–æ–º—É —á—Ç–æ "
"–µ—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–∏–º–≤–æ–ª–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –∑–∞—Å—Ç–∞–≤–ª—è—é—Ç :meth:`~str.casefold` –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å "
"–Ω–µ–Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É, –ø–æ—ç—Ç–æ–º—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞. "
"–°–º. —Ä–∞–∑–¥–µ–ª 3.13 —Å—Ç–∞–Ω–¥–∞—Ä—Ç Unicode –¥–ª—è –æ–±—Å—É–∂–¥–µ–Ω–∏—è –∏ –ø—Ä–∏–º–µ—Ä–∞.)"

#: ../../howto/unicode.rst:484
msgid "Unicode Regular Expressions"
msgstr "Express√µes Regulares Unicode"

#: ../../howto/unicode.rst:486
msgid ""
"The regular expressions supported by the :mod:`re` module can be provided "
"either as bytes or strings.  Some of the special character sequences such as "
"``\\d`` and ``\\w`` have different meanings depending on whether the pattern "
"is supplied as bytes or a string.  For example, ``\\d`` will match the "
"characters ``[0-9]`` in bytes but in strings will match any character that's "
"in the ``'Nd'`` category."
msgstr ""
"–†–µ–≥—É–ª—è—Ä–Ω—ñ –≤–∏—Ä–∞–∑–∏, —è–∫—ñ –ø—ñ–¥—Ç—Ä–∏–º—É—î –º–æ–¥—É–ª—å :mod:`re`, –º–æ–∂—É—Ç—å –±—É—Ç–∏ –Ω–∞–¥–∞–Ω—ñ —É "
"–≤–∏–≥–ª—è–¥—ñ –±–∞–π—Ç—ñ–≤ –∞–±–æ —Ä—è–¥–∫—ñ–≤. –î–µ—è–∫—ñ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ —Å–ø–µ—Ü—ñ–∞–ª—å–Ω–∏—Ö —Å–∏–º–≤–æ–ª—ñ–≤, "
"–Ω–∞–ø—Ä–∏–∫–ª–∞–¥ ``\\d`` —ñ ``\\w``, –º–∞—é—Ç—å —Ä—ñ–∑–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ —Ç–æ–≥–æ, —á–∏ "
"–Ω–∞–¥–∞—î—Ç—å—Å—è —à–∞–±–ª–æ–Ω —É –≤–∏–≥–ª—è–¥—ñ –±–∞–π—Ç—ñ–≤ —á–∏ —Ä—è–¥–∫–∞. –ù–∞–ø—Ä–∏–∫–ª–∞–¥, ``\\d`` –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—Ç–∏–º–µ "
"—Å–∏–º–≤–æ–ª–∞–º ``[0-9]`` —É –±–∞–π—Ç–∞—Ö, –∞–ª–µ –≤ —Ä—è–¥–∫–∞—Ö –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—Ç–∏–º–µ –±—É–¥—å-—è–∫–æ–º—É —Å–∏–º–≤–æ–ª—É "
"–∫–∞—Ç–µ–≥–æ—Ä—ñ—ó ``'Nd'``."

#: ../../howto/unicode.rst:493
msgid ""
"The string in this example has the number 57 written in both Thai and Arabic "
"numerals::"
msgstr ""
"–†—è–¥–æ–∫ —É —Ü—å–æ–º—É –ø—Ä–∏–∫–ª–∞–¥—ñ –º—ñ—Å—Ç–∏—Ç—å —á–∏—Å–ª–æ 57, –Ω–∞–ø–∏—Å–∞–Ω–µ —Ç–∞–π—Å—å–∫–∏–º–∏ —Ç–∞ –∞—Ä–∞–±—Å—å–∫–∏–º–∏ "
"—Ü–∏—Ñ—Ä–∞–º–∏:"

#: ../../howto/unicode.rst:496
msgid ""
"import re\n"
"p = re.compile(r'\\d+')\n"
"\n"
"s = \"Over \\u0e55\\u0e57 57 flavours\"\n"
"m = p.search(s)\n"
"print(repr(m.group()))"
msgstr ""
"import re\n"
"p = re.compile(r'\\d+')\n"
"\n"
"s = \"Over \\u0e55\\u0e57 57 flavours\"\n"
"m = p.search(s)\n"
"print(repr(m.group()))"

#: ../../howto/unicode.rst:503
msgid ""
"When executed, ``\\d+`` will match the Thai numerals and print them out.  If "
"you supply the :const:`re.ASCII` flag to :func:`~re.compile`, ``\\d+`` will "
"match the substring \"57\" instead."
msgstr ""
"–ü—ñ—Å–ª—è –≤–∏–∫–æ–Ω–∞–Ω–Ω—è ``\\d+`` –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—Ç–∏–º–µ —Ç–∞–π—Å—å–∫–∏–º —Ü–∏—Ñ—Ä–∞–º —ñ –≤–∏–≤–æ–¥–∏—Ç–∏–º–µ —ó—Ö. –Ø–∫—â–æ "
"–≤–∏ –¥–æ–¥–∞—Å—Ç–µ –ø—Ä–∞–ø–æ—Ä–µ—Ü—å :const:`re.ASCII` –¥–æ :func:`~re.compile`, ``\\d+`` "
"–Ω–∞—Ç–æ–º—ñ—Å—Ç—å –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—Ç–∏–º–µ –ø—ñ–¥—Ä—è–¥–∫—É \"57\"."

#: ../../howto/unicode.rst:507
msgid ""
"Similarly, ``\\w`` matches a wide variety of Unicode characters but only "
"``[a-zA-Z0-9_]`` in bytes or if :const:`re.ASCII` is supplied, and ``\\s`` "
"will match either Unicode whitespace characters or ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"–ê–Ω–∞–ª–æ–≥—ñ—á–Ω–æ, ``\\w`` –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î —à–∏—Ä–æ–∫–æ–º—É —Å–ø–µ–∫—Ç—Ä—É —Å–∏–º–≤–æ–ª—ñ–≤ –Æ–Ω—ñ–∫–æ–¥—É, –∞–ª–µ –ª–∏—à–µ "
"``[a-zA-Z0-9_]`` –≤ –±–∞–π—Ç–∞—Ö –∞–±–æ —è–∫—â–æ –Ω–∞–¥–∞–Ω–æ :const:`re.ASCII`, —ñ ``\\s`` "
"–≤—ñ–¥–ø–æ–≤—ñ–¥–∞—Ç–∏–º–µ –∞–±–æ –ø—Ä–æ–±—ñ–ª–∞–º Unicode, –∞–±–æ ``[ \\t\\n\\r\\f\\v]``."

#: ../../howto/unicode.rst:518
msgid "Some good alternative discussions of Python's Unicode support are:"
msgstr "–î–µ—è–∫—ñ —Ö–æ—Ä–æ—à—ñ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ñ –æ–±–≥–æ–≤–æ—Ä–µ–Ω–Ω—è –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ Unicode –≤ Python:"

#: ../../howto/unicode.rst:520
msgid ""
"`Processing Text Files in Python 3 <https://python-notes.curiousefficiency."
"org/en/latest/python3/text_file_processing.html>`_, by Nick Coghlan."
msgstr ""
"`–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤ –≤ Python 3 <https://python-notes."
"curiousefficiency.org/en/latest/python3/text_file_processing.html>`_, –ù–∏–∫ "
"–ö–æ–≥–ª–∞–Ω."

#: ../../howto/unicode.rst:521
msgid ""
"`Pragmatic Unicode <https://nedbatchelder.com/text/unipain.html>`_, a PyCon "
"2012 presentation by Ned Batchelder."
msgstr ""
"`Pragmatic Unicode <https://nedbatchelder.com/text/unipain.html>`_, "
"–ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü—ñ—è PyCon 2012 –ù–µ–¥–∞ –ë–∞—Ç—á–µ–ª–¥–µ—Ä–∞."

#: ../../howto/unicode.rst:523
msgid ""
"The :class:`str` type is described in the Python library reference at :ref:"
"`textseq`."
msgstr ""
"–¢–∏–ø :class:`str` –æ–ø–∏—Å–∞–Ω–æ –≤ –¥–æ–≤—ñ–¥—Ü—ñ –ø—Ä–æ –±—ñ–±–ª—ñ–æ—Ç–µ–∫—É Python –∑–∞ –∞–¥—Ä–µ—Å–æ—é :ref:"
"`textseq`."

#: ../../howto/unicode.rst:526
msgid "The documentation for the :mod:`unicodedata` module."
msgstr "–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è –¥–ª—è –º–æ–¥—É–ª—è :mod:`unicodedata`."

#: ../../howto/unicode.rst:528
msgid "The documentation for the :mod:`codecs` module."
msgstr "–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è –¥–ª—è –º–æ–¥—É–ª—è :mod:`codecs`."

#: ../../howto/unicode.rst:530
msgid ""
"Marc-Andr√© Lemburg gave `a presentation titled \"Python and Unicode\" (PDF "
"slides) <https://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf>`_ at "
"EuroPython 2002.  The slides are an excellent overview of the design of "
"Python 2's Unicode features (where the Unicode string type is called "
"``unicode`` and literals start with ``u``)."
msgstr ""
"–ú–∞—Ä–∫-–ê–Ω–¥—Ä–µ –õ–µ–º–±—É—Ä–≥ –ø—Ä–æ–≤—ñ–≤ `–ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü—ñ—é –ø—ñ–¥ –Ω–∞–∑–≤–æ—é \"Python —ñ –Æ–Ω—ñ–∫–æ–¥\" (PDF-"
"—Å–ª–∞–π–¥–∏) <https://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf>`_ –Ω–∞ "
"EuroPython 2002. –°–ª–∞–π–¥–∏ —î —á—É–¥–æ–≤–∏–º –æ–≥–ª—è–¥–æ–º –¥–∏–∑–∞–π–Ω—É —Ñ—É–Ω–∫—Ü—ñ–π –Æ–Ω—ñ–∫–æ–¥—É Python 2 "
"(–¥–µ —Ç–∏–ø —Ä—è–¥–∫–∞ –Æ–Ω—ñ–∫–æ–¥ –Ω–∞–∑–∏–≤–∞—î—Ç—å—Å—è ``unicode`` —ñ –ª—ñ—Ç–µ—Ä–∞–ª–∏ –ø–æ—á–∏–Ω–∞—é—Ç—å—Å—è –∑ ``u``)."

#: ../../howto/unicode.rst:538
msgid "Reading and Writing Unicode Data"
msgstr "–ß–∏—Ç–∞–Ω–Ω—è —Ç–∞ –∑–∞–ø–∏—Å –¥–∞–Ω–∏—Ö Unicode"

#: ../../howto/unicode.rst:540
msgid ""
"Once you've written some code that works with Unicode data, the next problem "
"is input/output.  How do you get Unicode strings into your program, and how "
"do you convert Unicode into a form suitable for storage or transmission?"
msgstr ""
"–ü—ñ—Å–ª—è —Ç–æ–≥–æ, —è–∫ –≤–∏ –Ω–∞–ø–∏—Å–∞–ª–∏ –∫–æ–¥, —è–∫–∏–π –ø—Ä–∞—Ü—é—î –∑ –¥–∞–Ω–∏–º–∏ Unicode, –Ω–∞—Å—Ç—É–ø–Ω–æ—é "
"–ø—Ä–æ–±–ª–µ–º–æ—é —î –≤–≤–µ–¥–µ–Ω–Ω—è/–≤–∏–≤–µ–¥–µ–Ω–Ω—è. –Ø–∫ –æ—Ç—Ä–∏–º–∞—Ç–∏ —Ä—è–¥–∫–∏ Unicode —É –≤–∞—à—ñ–π –ø—Ä–æ–≥—Ä–∞–º—ñ "
"—Ç–∞ —è–∫ –ø–µ—Ä–µ—Ç–≤–æ—Ä–∏—Ç–∏ Unicode —É —Ñ–æ—Ä–º—É, –ø—Ä–∏–¥–∞—Ç–Ω—É –¥–ª—è –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è —á–∏ –ø–µ—Ä–µ–¥–∞—á—ñ?"

#: ../../howto/unicode.rst:544
msgid ""
"It's possible that you may not need to do anything depending on your input "
"sources and output destinations; you should check whether the libraries used "
"in your application support Unicode natively.  XML parsers often return "
"Unicode data, for example.  Many relational databases also support Unicode-"
"valued columns and can return Unicode values from an SQL query."
msgstr ""
"–¶—ñ–ª–∫–æ–º –º–æ–∂–ª–∏–≤–æ, —â–æ –≤–∞–º –º–æ–∂–µ –Ω–µ –∑–Ω–∞–¥–æ–±–∏—Ç–∏—Å—è –Ω—ñ—á–æ–≥–æ —Ä–æ–±–∏—Ç–∏ –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –≤–∞—à–∏—Ö "
"–¥–∂–µ—Ä–µ–ª –≤–≤–µ–¥–µ–Ω–Ω—è —Ç–∞ –ø—Ä–∏–∑–Ω–∞—á–µ–Ω–Ω—è –≤–∏–≤–æ–¥—É; –≤–∞–º —Å–ª—ñ–¥ –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏, —á–∏ –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∏, "
"—è–∫—ñ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å—Å—è —É –≤–∞—à—ñ–π –ø—Ä–æ–≥—Ä–∞–º—ñ, –ø—ñ–¥—Ç—Ä–∏–º—É—é—Ç—å Unicode. –°–∏–Ω—Ç–∞–∫—Å–∏—á–Ω—ñ "
"–∞–Ω–∞–ª—ñ–∑–∞—Ç–æ—Ä–∏ XML —á–∞—Å—Ç–æ –ø–æ–≤–µ—Ä—Ç–∞—é—Ç—å, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –¥–∞–Ω—ñ Unicode. –ë–∞–≥–∞—Ç–æ —Ä–µ–ª—è—Ü—ñ–π–Ω–∏—Ö "
"–±–∞–∑ –¥–∞–Ω–∏—Ö —Ç–∞–∫–æ–∂ –ø—ñ–¥—Ç—Ä–∏–º—É—é—Ç—å —Å—Ç–æ–≤–ø—Ü—ñ –∑—ñ –∑–Ω–∞—á–µ–Ω–Ω—è–º–∏ –Æ–Ω—ñ–∫–æ–¥ —ñ –º–æ–∂—É—Ç—å –ø–æ–≤–µ—Ä—Ç–∞—Ç–∏ "
"–∑–Ω–∞—á–µ–Ω–Ω—è –Æ–Ω—ñ–∫–æ–¥ —ñ–∑ –∑–∞–ø–∏—Ç—É SQL."

#: ../../howto/unicode.rst:550
msgid ""
"Unicode data is usually converted to a particular encoding before it gets "
"written to disk or sent over a socket.  It's possible to do all the work "
"yourself: open a file, read an 8-bit bytes object from it, and convert the "
"bytes with ``bytes.decode(encoding)``.  However, the manual approach is not "
"recommended."
msgstr ""
"–î–∞–Ω—ñ Unicode –∑–∞–∑–≤–∏—á–∞–π –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—é—Ç—å—Å—è –≤ –ø–µ–≤–Ω–µ –∫–æ–¥—É–≤–∞–Ω–Ω—è –ø–µ—Ä–µ–¥ –∑–∞–ø–∏—Å–æ–º –Ω–∞ –¥–∏—Å–∫ "
"–∞–±–æ –Ω–∞–¥—Å–∏–ª–∞–Ω–Ω—è–º —á–µ—Ä–µ–∑ —Å–æ–∫–µ—Ç. –ú–æ–∂–Ω–∞ –≤–∏–∫–æ–Ω–∞—Ç–∏ –≤—Å—é —Ä–æ–±–æ—Ç—É —Å–∞–º–æ—Å—Ç—ñ–π–Ω–æ: –≤—ñ–¥–∫—Ä–∏—Ç–∏ "
"—Ñ–∞–π–ª, –ø—Ä–æ—á–∏—Ç–∞—Ç–∏ –∑ –Ω—å–æ–≥–æ 8-–±—ñ—Ç–Ω–∏–π –æ–±‚Äô—î–∫—Ç bytes —ñ –ø–µ—Ä–µ—Ç–≤–æ—Ä–∏—Ç–∏ –±–∞–π—Ç–∏ –∑–∞ "
"–¥–æ–ø–æ–º–æ–≥–æ—é ``bytes.decode(encoding)``. –û–¥–Ω–∞–∫ —Ä—É—á–Ω–∏–π –ø—ñ–¥—Ö—ñ–¥ –Ω–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É—î—Ç—å—Å—è."

#: ../../howto/unicode.rst:555
msgid ""
"One problem is the multi-byte nature of encodings; one Unicode character can "
"be represented by several bytes.  If you want to read the file in arbitrary-"
"sized chunks (say, 1024 or 4096 bytes), you need to write error-handling "
"code to catch the case where only part of the bytes encoding a single "
"Unicode character are read at the end of a chunk.  One solution would be to "
"read the entire file into memory and then perform the decoding, but that "
"prevents you from working with files that are extremely large; if you need "
"to read a 2 GiB file, you need 2 GiB of RAM. (More, really, since for at "
"least a moment you'd need to have both the encoded string and its Unicode "
"version in memory.)"
msgstr ""
"–û–¥–Ω—ñ—î—é –∑ –ø—Ä–æ–±–ª–µ–º —î –±–∞–≥–∞—Ç–æ–±–∞–π—Ç–æ–≤–∞ –ø—Ä–∏—Ä–æ–¥–∞ –∫–æ–¥—É–≤–∞–Ω—å; –æ–¥–∏–Ω —Å–∏–º–≤–æ–ª Unicode –º–æ–∂–µ "
"–±—É—Ç–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–π –∫—ñ–ª—å–∫–æ–º–∞ –±–∞–π—Ç–∞–º–∏. –Ø–∫—â–æ –≤–∏ —Ö–æ—á–µ—Ç–µ –ø—Ä–æ—á–∏—Ç–∞—Ç–∏ —Ñ–∞–π–ª "
"—Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞–º–∏ –¥–æ–≤—ñ–ª—å–Ω–æ–≥–æ —Ä–æ–∑–º—ñ—Ä—É (—Å–∫–∞–∂—ñ–º–æ, 1024 –∞–±–æ 4096 –±–∞–π—Ç—ñ–≤), –≤–∞–º –ø–æ—Ç—Ä—ñ–±–Ω–æ "
"–Ω–∞–ø–∏—Å–∞—Ç–∏ –∫–æ–¥ –æ–±—Ä–æ–±–∫–∏ –ø–æ–º–∏–ª–æ–∫, —â–æ–± —É–ª–æ–≤–∏—Ç–∏ –≤–∏–ø–∞–¥–æ–∫, –∫–æ–ª–∏ –ª–∏—à–µ —á–∞—Å—Ç–∏–Ω–∞ –±–∞–π—Ç—ñ–≤, "
"—â–æ –∫–æ–¥—É—é—Ç—å –æ–¥–∏–Ω —Å–∏–º–≤–æ–ª Unicode, —á–∏—Ç–∞—î—Ç—å—Å—è –≤ –∫—ñ–Ω—Ü—ñ —à–º–∞—Ç–æ–∫. –û–¥–Ω–∏–º —ñ–∑ —Ä—ñ—à–µ–Ω—å "
"–±—É–ª–æ –± –ø—Ä–æ—á–∏—Ç–∞—Ç–∏ –≤–µ—Å—å —Ñ–∞–π–ª —É –ø–∞–º‚Äô—è—Ç—å, –∞ –ø–æ—Ç—ñ–º –≤–∏–∫–æ–Ω–∞—Ç–∏ –¥–µ–∫–æ–¥—É–≤–∞–Ω–Ω—è, –∞–ª–µ —Ü–µ "
"–∑–∞–≤–∞–∂–∞—î –≤–∞–º –ø—Ä–∞—Ü—é–≤–∞—Ç–∏ –∑ —Ñ–∞–π–ª–∞–º–∏, —è–∫—ñ —î –Ω–∞–¥–∑–≤–∏—á–∞–π–Ω–æ –≤–µ–ª–∏–∫–∏–º–∏; —è–∫—â–æ –≤–∞–º "
"–ø–æ—Ç—Ä—ñ–±–Ω–æ –ø—Ä–æ—á–∏—Ç–∞—Ç–∏ —Ñ–∞–π–ª —Ä–æ–∑–º—ñ—Ä–æ–º 2 –ì–ë, –≤–∞–º –∑–Ω–∞–¥–æ–±–∏—Ç—å—Å—è 2 –ì–ë –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ—ó "
"–ø–∞–º‚Äô—è—Ç—ñ. (–ù–∞—Å–ø—Ä–∞–≤–¥—ñ –±—ñ–ª—å—à–µ, –æ—Å–∫—ñ–ª—å–∫–∏ –ø—Ä–∏–Ω–∞–π–º–Ω—ñ –Ω–∞ –º–∏—Ç—å –≤–∞–º –∑–Ω–∞–¥–æ–±–∏—Ç—å—Å—è –º–∞—Ç–∏ "
"–≤ –ø–∞–º‚Äô—è—Ç—ñ —è–∫ –∑–∞–∫–æ–¥–æ–≤–∞–Ω–∏–π —Ä—è–¥–æ–∫, —Ç–∞–∫ —ñ –π–æ–≥–æ –≤–µ—Ä—Å—ñ—é Unicode.)"

#: ../../howto/unicode.rst:565
msgid ""
"The solution would be to use the low-level decoding interface to catch the "
"case of partial coding sequences.  The work of implementing this has already "
"been done for you: the built-in :func:`open` function can return a file-like "
"object that assumes the file's contents are in a specified encoding and "
"accepts Unicode parameters for methods such as :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.write`.  This works through :func:`open`\\'s "
"*encoding* and *errors* parameters which are interpreted just like those in :"
"meth:`str.encode` and :meth:`bytes.decode`."
msgstr ""
"–†—ñ—à–µ–Ω–Ω—è –ø–æ–ª—è–≥–∞–ª–æ –± —É –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—ñ —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É –¥–µ–∫–æ–¥—É–≤–∞–Ω–Ω—è –Ω–∏–∑—å–∫–æ–≥–æ —Ä—ñ–≤–Ω—è –¥–ª—è "
"–≤–∏—è–≤–ª–µ–Ω–Ω—è –≤–∏–ø–∞–¥–∫—ñ–≤ —á–∞—Å—Ç–∫–æ–≤–∏—Ö –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç–µ–π –∫–æ–¥—É–≤–∞–Ω–Ω—è. –†–æ–±–æ—Ç—É –Ω–∞–¥ "
"—Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—î—é —Ü—å–æ–≥–æ –≤–∂–µ –≤–∏–∫–æ–Ω–∞–Ω–æ –∑–∞ –≤–∞—Å: –≤–±—É–¥–æ–≤–∞–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è :func:`open` –º–æ–∂–µ "
"–ø–æ–≤–µ—Ä—Ç–∞—Ç–∏ —Ñ–∞–π–ª–æ–ø–æ–¥—ñ–±–Ω–∏–π –æ–±‚Äô—î–∫—Ç, —è–∫–∏–π –ø—Ä–∏–ø—É—Å–∫–∞—î, —â–æ –≤–º—ñ—Å—Ç —Ñ–∞–π–ª—É –∑–Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è —É "
"–≤–∫–∞–∑–∞–Ω–æ–º—É –∫–æ–¥—É–≤–∞–Ω–Ω—ñ —Ç–∞ –ø—Ä–∏–π–º–∞—î –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ Unicode –¥–ª—è —Ç–∞–∫–∏—Ö –º–µ—Ç–æ–¥—ñ–≤, —è–∫ :meth:"
"`~io.TextIOBase.read` —ñ :meth:`~io.TextIOBase.write`. –¶–µ –ø—Ä–∞—Ü—é—î —á–µ—Ä–µ–∑ "
"–ø–∞—Ä–∞–º–µ—Ç—Ä–∏ *encoding* —ñ *errors* :func:`open`\\, —è–∫—ñ —ñ–Ω—Ç–µ—Ä–ø—Ä–µ—Ç—É—é—Ç—å—Å—è —Ç–∞–∫ "
"—Å–∞–º–æ, —è–∫ —Ç—ñ, —â–æ –≤ :meth:`str.encode` —ñ :meth:`bytes.decode`."

#: ../../howto/unicode.rst:574
msgid "Reading Unicode from a file is therefore simple::"
msgstr "–¢–æ–º—É —á–∏—Ç–∞–Ω–Ω—è Unicode –∑ —Ñ–∞–π–ª—É –ø—Ä–æ—Å—Ç–µ:"

#: ../../howto/unicode.rst:576
msgid ""
"with open('unicode.txt', encoding='utf-8') as f:\n"
"    for line in f:\n"
"        print(repr(line))"
msgstr ""
"with open('unicode.txt', encoding='utf-8') as f:\n"
"    for line in f:\n"
"        print(repr(line))"

#: ../../howto/unicode.rst:580
msgid ""
"It's also possible to open files in update mode, allowing both reading and "
"writing::"
msgstr ""
"–¢–∞–∫–æ–∂ –º–æ–∂–Ω–∞ –≤—ñ–¥–∫—Ä–∏–≤–∞—Ç–∏ —Ñ–∞–π–ª–∏ –≤ —Ä–µ–∂–∏–º—ñ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è, –¥–æ–∑–≤–æ–ª—è—é—á–∏ —è–∫ —á–∏—Ç–∞–Ω–Ω—è, —Ç–∞–∫ "
"—ñ –∑–∞–ø–∏—Å:"

#: ../../howto/unicode.rst:583
msgid ""
"with open('test', encoding='utf-8', mode='w+') as f:\n"
"    f.write('\\u4500 blah blah blah\\n')\n"
"    f.seek(0)\n"
"    print(repr(f.readline()[:1]))"
msgstr ""
"with open('test', encoding='utf-8', mode='w+') as f:\n"
"    f.write('\\u4500 blah blah blah\\n')\n"
"    f.seek(0)\n"
"    print(repr(f.readline()[:1]))"

#: ../../howto/unicode.rst:588
msgid ""
"The Unicode character ``U+FEFF`` is used as a byte-order mark (BOM), and is "
"often written as the first character of a file in order to assist with "
"autodetection of the file's byte ordering.  Some encodings, such as UTF-16, "
"expect a BOM to be present at the start of a file; when such an encoding is "
"used, the BOM will be automatically written as the first character and will "
"be silently dropped when the file is read.  There are variants of these "
"encodings, such as 'utf-16-le' and 'utf-16-be' for little-endian and big-"
"endian encodings, that specify one particular byte ordering and don't skip "
"the BOM."
msgstr ""
"–°–∏–º–≤–æ–ª Unicode ``U+FEFF`` –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —è–∫ –ø–æ–∑–Ω–∞—á–∫–∞ –ø–æ—Ä—è–¥–∫—É –±–∞–π—Ç—ñ–≤ (BOM) "
"—ñ —á–∞—Å—Ç–æ –∑–∞–ø–∏—Å—É—î—Ç—å—Å—è —è–∫ –ø–µ—Ä—à–∏–π —Å–∏–º–≤–æ–ª —Ñ–∞–π–ª—É, —â–æ–± –¥–æ–ø–æ–º–æ–≥—Ç–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ "
"–≤–∏–∑–Ω–∞—á–∏—Ç–∏ –ø–æ—Ä—è–¥–æ–∫ –±–∞–π—Ç—ñ–≤ —É —Ñ–∞–π–ª—ñ. –î–µ—è–∫—ñ –∫–æ–¥—É–≤–∞–Ω–Ω—è, —Ç–∞–∫—ñ —è–∫ UTF-16, –æ—á—ñ–∫—É—é—Ç—å "
"–Ω–∞—è–≤–Ω–æ—Å—Ç—ñ BOM –Ω–∞ –ø–æ—á–∞—Ç–∫—É —Ñ–∞–π–ª—É; –∫–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —Ç–∞–∫–µ –∫–æ–¥—É–≤–∞–Ω–Ω—è, "
"—Å–ø–µ—Ü–∏—Ñ—ñ–∫–∞—Ü—ñ—è –±—É–¥–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–∞–ø–∏—Å–∞–Ω–∞ —è–∫ –ø–µ—Ä—à–∏–π —Å–∏–º–≤–æ–ª —ñ –±—É–¥–µ –º–æ–≤—á–∫–∏ "
"–≤—ñ–¥–∫–∏–Ω—É—Ç–∞ –ø—ñ–¥ —á–∞—Å —á–∏—Ç–∞–Ω–Ω—è —Ñ–∞–π–ª—É. –Ü—Å–Ω—É—é—Ç—å –≤–∞—Ä—ñ–∞–Ω—Ç–∏ —Ü–∏—Ö –∫–æ–¥—É–≤–∞–Ω—å, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥ "
"\"utf-16-le\" —ñ \"utf-16-be\" –¥–ª—è –∫–æ–¥—É–≤–∞–Ω—å little-endian —ñ big-endian, —è–∫—ñ "
"–≤–∫–∞–∑—É—é—Ç—å –æ–¥–∏–Ω –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–π –ø–æ—Ä—è–¥–æ–∫ –±–∞–π—Ç—ñ–≤ —ñ –Ω–µ –ø—Ä–æ–ø—É—Å–∫–∞—é—Ç—å BOM."

#: ../../howto/unicode.rst:597
msgid ""
"In some areas, it is also convention to use a \"BOM\" at the start of UTF-8 "
"encoded files; the name is misleading since UTF-8 is not byte-order "
"dependent. The mark simply announces that the file is encoded in UTF-8.  For "
"reading such files, use the 'utf-8-sig' codec to automatically skip the mark "
"if present."
msgstr ""
"–£ –¥–µ—è–∫–∏—Ö —Ä–µ–≥—ñ–æ–Ω–∞—Ö —Ç–∞–∫–æ–∂ –ø—Ä–∏–π–Ω—è—Ç–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ \"BOM\" –Ω–∞ –ø–æ—á–∞—Ç–∫—É —Ñ–∞–π–ª—ñ–≤ —É "
"–∫–æ–¥—É–≤–∞–Ω–Ω—ñ UTF-8; –Ω–∞–∑–≤–∞ –≤–≤–æ–¥–∏—Ç—å –≤ –æ–º–∞–Ω—É, –æ—Å–∫—ñ–ª—å–∫–∏ UTF-8 –Ω–µ –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ "
"–ø–æ—Ä—è–¥–∫—É –±–∞–π—Ç—ñ–≤. –ü–æ–∑–Ω–∞—á–∫–∞ –ø—Ä–æ—Å—Ç–æ –ø–æ–≤—ñ–¥–æ–º–ª—è—î, —â–æ —Ñ–∞–π–ª –∑–∞–∫–æ–¥–æ–≤–∞–Ω–æ –≤ UTF-8. –î–ª—è "
"—á–∏—Ç–∞–Ω–Ω—è —Ç–∞–∫–∏—Ö —Ñ–∞–π–ª—ñ–≤ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∫–æ–¥–µ–∫ \"utf-8-sig\", —â–æ–± –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ "
"–ø—Ä–æ–ø—É—Å–∫–∞—Ç–∏ –ø–æ–∑–Ω–∞—á–∫—É, —è–∫—â–æ –≤–æ–Ω–∞ —î."

#: ../../howto/unicode.rst:604
msgid "Unicode filenames"
msgstr "Nomes de arquivos Unicode"

#: ../../howto/unicode.rst:606
msgid ""
"Most of the operating systems in common use today support filenames that "
"contain arbitrary Unicode characters.  Usually this is implemented by "
"converting the Unicode string into some encoding that varies depending on "
"the system.  Today Python is converging on using UTF-8: Python on MacOS has "
"used UTF-8 for several versions, and Python 3.6 switched to using UTF-8 on "
"Windows as well.  On Unix systems, there will only be a :term:`filesystem "
"encoding <filesystem encoding and error handler>`. if you've set the "
"``LANG`` or ``LC_CTYPE`` environment variables; if you haven't, the default "
"encoding is again UTF-8."
msgstr ""
"–ë—ñ–ª—å—à—ñ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü—ñ–π–Ω–∏—Ö —Å–∏—Å—Ç–µ–º, —è–∫—ñ —Å—å–æ–≥–æ–¥–Ω—ñ —à–∏—Ä–æ–∫–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å—Å—è, "
"–ø—ñ–¥—Ç—Ä–∏–º—É—é—Ç—å —ñ–º–µ–Ω–∞ —Ñ–∞–π–ª—ñ–≤, —è–∫—ñ –º—ñ—Å—Ç—è—Ç—å –¥–æ–≤—ñ–ª—å–Ω—ñ —Å–∏–º–≤–æ–ª–∏ Unicode. –ó–∞–∑–≤–∏—á–∞–π —Ü–µ "
"—Ä–µ–∞–ª—ñ–∑—É—î—Ç—å—Å—è —à–ª—è—Ö–æ–º –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ä—è–¥–∫–∞ Unicode —É –∫–æ–¥—É–≤–∞–Ω–Ω—è, —è–∫–µ –∑–º—ñ–Ω—é—î—Ç—å—Å—è "
"–∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ —Å–∏—Å—Ç–µ–º–∏. –°—å–æ–≥–æ–¥–Ω—ñ Python –Ω–∞–±–ª–∏–∂–∞—î—Ç—å—Å—è –¥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è UTF-8: "
"Python –Ω–∞ MacOS –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞–≤ UTF-8 –¥–ª—è –∫—ñ–ª—å–∫–æ—Ö –≤–µ—Ä—Å—ñ–π, –∞ Python 3.6 —Ç–∞–∫–æ–∂ "
"–ø–µ—Ä–µ–π—à–æ–≤ –Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è UTF-8 —É Windows. –£ —Å–∏—Å—Ç–µ–º–∞—Ö Unix –±—É–¥–µ –ª–∏—à–µ :term:"
"`–∫–æ–¥—É–≤–∞–Ω–Ω—è —Ñ–∞–π–ª–æ–≤–æ—ó —Å–∏—Å—Ç–µ–º–∏ <filesystem encoding and error handler>`. —è–∫—â–æ "
"–≤–∏ –≤—Å—Ç–∞–Ω–æ–≤–∏–ª–∏ –∑–º—ñ–Ω–Ω—ñ —Å–µ—Ä–µ–¥–æ–≤–∏—â–∞ ``LANG`` –∞–±–æ ``LC_CTYPE``; —è–∫—â–æ –≤–∏ —Ü—å–æ–≥–æ –Ω–µ "
"–∑—Ä–æ–±–∏–ª–∏, —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏–º –∫–æ–¥—É–≤–∞–Ω–Ω—è–º –∑–Ω–æ–≤—É —î UTF-8."

#: ../../howto/unicode.rst:616
msgid ""
"The :func:`sys.getfilesystemencoding` function returns the encoding to use "
"on your current system, in case you want to do the encoding manually, but "
"there's not much reason to bother.  When opening a file for reading or "
"writing, you can usually just provide the Unicode string as the filename, "
"and it will be automatically converted to the right encoding for you::"
msgstr ""
"–§—É–Ω–∫—Ü—ñ—è :func:`sys.getfilesystemencoding` –ø–æ–≤–µ—Ä—Ç–∞—î –∫–æ–¥—É–≤–∞–Ω–Ω—è –¥–ª—è "
"–≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è —É –≤–∞—à—ñ–π –ø–æ—Ç–æ—á–Ω—ñ–π —Å–∏—Å—Ç–µ–º—ñ, —è–∫—â–æ –≤–∏ —Ö–æ—á–µ—Ç–µ –∑—Ä–æ–±–∏—Ç–∏ –∫–æ–¥—É–≤–∞–Ω–Ω—è "
"–≤—Ä—É—á–Ω—É, –∞–ª–µ –Ω–µ–º–∞—î –æ—Å–æ–±–ª–∏–≤–∏—Ö –ø—Ä–∏—á–∏–Ω —Ç—É—Ä–±—É–≤–∞—Ç–∏—Å—è. –í—ñ–¥–∫—Ä–∏–≤–∞—é—á–∏ —Ñ–∞–π–ª –¥–ª—è —á–∏—Ç–∞–Ω–Ω—è "
"–∞–±–æ –∑–∞–ø–∏—Å—É, –≤–∏ –∑–∞–∑–≤–∏—á–∞–π –º–æ–∂–µ—Ç–µ –ø—Ä–æ—Å—Ç–æ –≤–∫–∞–∑–∞—Ç–∏ —Ä—è–¥–æ–∫ –Æ–Ω—ñ–∫–æ–¥ —è–∫ —ñ–º‚Äô—è —Ñ–∞–π–ª—É, —ñ "
"–≤—ñ–Ω –±—É–¥–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–∏–π —É –ø—Ä–∞–≤–∏–ª—å–Ω–µ –¥–ª—è –≤–∞—Å –∫–æ–¥—É–≤–∞–Ω–Ω—è::"

#: ../../howto/unicode.rst:622
msgid ""
"filename = 'filename\\u4500abc'\n"
"with open(filename, 'w') as f:\n"
"    f.write('blah\\n')"
msgstr ""
"filename = 'filename\\u4500abc'\n"
"with open(filename, 'w') as f:\n"
"    f.write('blah\\n')"

#: ../../howto/unicode.rst:626
msgid ""
"Functions in the :mod:`os` module such as :func:`os.stat` will also accept "
"Unicode filenames."
msgstr ""
"–§—É–Ω–∫—Ü—ñ—ó –≤ –º–æ–¥—É–ª—ñ :mod:`os`, —Ç–∞–∫—ñ —è–∫ :func:`os.stat`, —Ç–∞–∫–æ–∂ –ø—Ä–∏–π–º–∞—Ç–∏–º—É—Ç—å "
"—ñ–º–µ–Ω–∞ —Ñ–∞–π–ª—ñ–≤ —É –∫–æ–¥—É–≤–∞–Ω–Ω—ñ Unicode."

#: ../../howto/unicode.rst:629
msgid ""
"The :func:`os.listdir` function returns filenames, which raises an issue: "
"should it return the Unicode version of filenames, or should it return bytes "
"containing the encoded versions?  :func:`os.listdir` can do both, depending "
"on whether you provided the directory path as bytes or a Unicode string.  If "
"you pass a Unicode string as the path, filenames will be decoded using the "
"filesystem's encoding and a list of Unicode strings will be returned, while "
"passing a byte path will return the filenames as bytes.  For example, "
"assuming the default :term:`filesystem encoding <filesystem encoding and "
"error handler>` is UTF-8, running the following program::"
msgstr ""
"–§—É–Ω–∫—Ü—ñ—è :func:`os.listdir` –ø–æ–≤–µ—Ä—Ç–∞—î —ñ–º–µ–Ω–∞ —Ñ–∞–π–ª—ñ–≤, —â–æ –≤–∏–∫–ª–∏–∫–∞—î –ø—Ä–æ–±–ª–µ–º—É: —á–∏ "
"–º–∞—î –≤–æ–Ω–∞ –ø–æ–≤–µ—Ä—Ç–∞—Ç–∏ –≤–µ—Ä—Å—ñ—é —ñ–º–µ–Ω —Ñ–∞–π–ª—ñ–≤ —É –∫–æ–¥—É–≤–∞–Ω–Ω—ñ Unicode, —á–∏ –º–∞—î –ø–æ–≤–µ—Ä—Ç–∞—Ç–∏ "
"–±–∞–π—Ç–∏, —â–æ –º—ñ—Å—Ç—è—Ç—å –∑–∞–∫–æ–¥–æ–≤–∞–Ω—ñ –≤–µ—Ä—Å—ñ—ó? :func:`os.listdir` –º–æ–∂–µ —Ä–æ–±–∏—Ç–∏ —ñ —Ç–µ, —ñ "
"—ñ–Ω—à–µ, –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ —Ç–æ–≥–æ, —á–∏ –≤–∫–∞–∑–∞–ª–∏ –≤–∏ —à–ª—è—Ö –¥–æ –∫–∞—Ç–∞–ª–æ–≥—É —É –±–∞–π—Ç–∞—Ö —á–∏ —Ä—è–¥–∫—É "
"Unicode. –Ø–∫—â–æ –≤–∏ –ø–µ—Ä–µ–¥–∞—Å—Ç–µ —Ä—è–¥–æ–∫ Unicode —è–∫ —à–ª—è—Ö, –Ω–∞–∑–≤–∏ —Ñ–∞–π–ª—ñ–≤ –±—É–¥–µ "
"—Ä–æ–∑—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ –∑ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è–º –∫–æ–¥—É–≤–∞–Ω–Ω—è —Ñ–∞–π–ª–æ–≤–æ—ó —Å–∏—Å—Ç–µ–º–∏, —ñ –±—É–¥–µ –ø–æ–≤–µ—Ä–Ω–µ–Ω–æ "
"—Å–ø–∏—Å–æ–∫ —Ä—è–¥–∫—ñ–≤ Unicode, —Ç–æ–¥—ñ —è–∫ –ø–µ—Ä–µ–¥–∞—á–∞ –±–∞–π—Ç–æ–≤–æ–≥–æ —à–ª—è—Ö—É –ø–æ–≤–µ—Ä–Ω–µ –Ω–∞–∑–≤–∏ —Ñ–∞–π–ª—ñ–≤ "
"—è–∫ –±–∞–π—Ç–∏. –ù–∞–ø—Ä–∏–∫–ª–∞–¥, –ø—Ä–∏–ø—É—Å—Ç–∏–≤—à–∏, —â–æ —Ç–∏–ø–æ–≤–∏–º :term:`–∫–æ–¥—É–≤–∞–Ω–Ω—è–º —Ñ–∞–π–ª–æ–≤–æ—ó "
"—Å–∏—Å—Ç–µ–º–∏ <filesystem encoding and error handler>` —î UTF-8, –∑–∞–ø—É—Å—Ç—ñ—Ç—å —Ç–∞–∫—É "
"–ø—Ä–æ–≥—Ä–∞–º—É::"

#: ../../howto/unicode.rst:639
msgid ""
"fn = 'filename\\u4500abc'\n"
"f = open(fn, 'w')\n"
"f.close()\n"
"\n"
"import os\n"
"print(os.listdir(b'.'))\n"
"print(os.listdir('.'))"
msgstr ""
"fn = 'filename\\u4500abc'\n"
"f = open(fn, 'w')\n"
"f.close()\n"
"\n"
"import os\n"
"print(os.listdir(b'.'))\n"
"print(os.listdir('.'))"

#: ../../howto/unicode.rst:647
msgid "will produce the following output:"
msgstr "–≤–∏–≤–µ–¥–µ –Ω–∞—Å—Ç—É–ø–Ω–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:"

#: ../../howto/unicode.rst:649
msgid ""
"$ python listdir-test.py\n"
"[b'filename\\xe4\\x94\\x80abc', ...]\n"
"['filename\\u4500abc', ...]"
msgstr ""
"$ python listdir-test.py\n"
"[b'filename\\xe4\\x94\\x80abc', ...]\n"
"['filename\\u4500abc', ...]"

#: ../../howto/unicode.rst:655
msgid ""
"The first list contains UTF-8-encoded filenames, and the second list "
"contains the Unicode versions."
msgstr ""
"–ü–µ—Ä—à–∏–π —Å–ø–∏—Å–æ–∫ –º—ñ—Å—Ç–∏—Ç—å —ñ–º–µ–Ω–∞ —Ñ–∞–π–ª—ñ–≤ —É –∫–æ–¥—É–≤–∞–Ω–Ω—ñ UTF-8, –∞ –¥—Ä—É–≥–∏–π —Å–ø–∏—Å–æ–∫ "
"–º—ñ—Å—Ç–∏—Ç—å –≤–µ—Ä—Å—ñ—ó Unicode."

#: ../../howto/unicode.rst:658
msgid ""
"Note that on most occasions, you should can just stick with using Unicode "
"with these APIs.  The bytes APIs should only be used on systems where "
"undecodable file names can be present; that's pretty much only Unix systems "
"now."
msgstr ""
"–ó–≤–µ—Ä–Ω—ñ—Ç—å —É–≤–∞–≥—É, —â–æ –≤ –±—ñ–ª—å—à–æ—Å—Ç—ñ –≤–∏–ø–∞–¥–∫—ñ–≤ –≤–∏ –º–æ–∂–µ—Ç–µ –ø—Ä–æ—Å—Ç–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ "
"Unicode –∑ —Ü–∏–º–∏ API. API –±–∞–π—Ç—ñ–≤ —Å–ª—ñ–¥ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ –ª–∏—à–µ –≤ —Å–∏—Å—Ç–µ–º–∞—Ö, –¥–µ "
"–º–æ–∂—É—Ç—å –±—É—Ç–∏ –ø—Ä–∏—Å—É—Ç–Ω—ñ —ñ–º–µ–Ω–∞ —Ñ–∞–π–ª—ñ–≤, —â–æ –Ω–µ —Ä–æ–∑—à–∏—Ñ—Ä–æ–≤—É—é—Ç—å—Å—è; –∑–∞—Ä–∞–∑ —Ü–µ –º–∞–π–∂–µ "
"–ª–∏—à–µ —Å–∏—Å—Ç–µ–º–∏ Unix."

#: ../../howto/unicode.rst:665
msgid "Tips for Writing Unicode-aware Programs"
msgstr "–ü–æ—Ä–∞–¥–∏ —â–æ–¥–æ –Ω–∞–ø–∏—Å–∞–Ω–Ω—è –ø—Ä–æ–≥—Ä–∞–º, —â–æ –ø—ñ–¥—Ç—Ä–∏–º—É—é—Ç—å Unicode"

#: ../../howto/unicode.rst:667
msgid ""
"This section provides some suggestions on writing software that deals with "
"Unicode."
msgstr ""
"–£ —Ü—å–æ–º—É —Ä–æ–∑–¥—ñ–ª—ñ –Ω–∞–¥–∞–Ω–æ –¥–µ—è–∫—ñ –ø–æ—Ä–∞–¥–∏ —â–æ–¥–æ –Ω–∞–ø–∏—Å–∞–Ω–Ω—è –ø—Ä–æ–≥—Ä–∞–º–Ω–æ–≥–æ –∑–∞–±–µ–∑–ø–µ—á–µ–Ω–Ω—è, "
"—è–∫–µ –ø—Ä–∞—Ü—é—î –∑ Unicode."

#: ../../howto/unicode.rst:670
msgid "The most important tip is:"
msgstr "A dica mais importante √©:"

#: ../../howto/unicode.rst:672
msgid ""
"Software should only work with Unicode strings internally, decoding the "
"input data as soon as possible and encoding the output only at the end."
msgstr ""
"–ü—Ä–æ–≥—Ä–∞–º–Ω–µ –∑–∞–±–µ–∑–ø–µ—á–µ–Ω–Ω—è –ø–æ–≤–∏–Ω–Ω–æ –ø—Ä–∞—Ü—é–≤–∞—Ç–∏ –ª–∏—à–µ –∑ –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ–º–∏ —Ä—è–¥–∫–∞–º–∏ Unicode, "
"–¥–µ–∫–æ–¥—É—é—á–∏ –≤—Ö—ñ–¥–Ω—ñ –¥–∞–Ω—ñ —è–∫–Ω–∞–π—à–≤–∏–¥—à–µ —Ç–∞ –∫–æ–¥—É—é—á–∏ –≤–∏—Ö—ñ–¥ –ª–∏—à–µ –≤ –∫—ñ–Ω—Ü—ñ."

#: ../../howto/unicode.rst:675
msgid ""
"If you attempt to write processing functions that accept both Unicode and "
"byte strings, you will find your program vulnerable to bugs wherever you "
"combine the two different kinds of strings.  There is no automatic encoding "
"or decoding: if you do e.g. ``str + bytes``, a :exc:`TypeError` will be "
"raised."
msgstr ""
"–Ø–∫—â–æ –≤–∏ —Å–ø—Ä–æ–±—É—î—Ç–µ –Ω–∞–ø–∏—Å–∞—Ç–∏ —Ñ—É–Ω–∫—Ü—ñ—ó –æ–±—Ä–æ–±–∫–∏, —è–∫—ñ –ø—Ä–∏–π–º–∞—é—Ç—å —è–∫ –Æ–Ω—ñ–∫–æ–¥, —Ç–∞–∫ —ñ "
"–±–∞–π—Ç–æ–≤—ñ —Ä—è–¥–∫–∏, –≤–∏ –ø–æ–±–∞—á–∏—Ç–µ, —â–æ –≤–∞—à–∞ –ø—Ä–æ–≥—Ä–∞–º–∞ –≤—Ä–∞–∑–ª–∏–≤–∞ –¥–æ –ø–æ–º–∏–ª–æ–∫, –∫–æ–ª–∏ –± –≤–∏ "
"–Ω–µ –ø–æ—î–¥–Ω—É–≤–∞–ª–∏ –¥–≤–∞ —Ä—ñ–∑–Ω–∏—Ö —Ç–∏–ø–∏ —Ä—è–¥–∫—ñ–≤. –ù–µ–º–∞—î –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ–≥–æ –∫–æ–¥—É–≤–∞–Ω–Ω—è –∞–±–æ "
"–¥–µ–∫–æ–¥—É–≤–∞–Ω–Ω—è: —è–∫—â–æ –≤–∏ —Ä–æ–±–∏—Ç–µ, –Ω–∞–ø—Ä. ``str + bytes``, –±—É–¥–µ –≤–∏–∫–ª–∏–∫–∞–Ω–æ :exc:"
"`TypeError`."

#: ../../howto/unicode.rst:680
msgid ""
"When using data coming from a web browser or some other untrusted source, a "
"common technique is to check for illegal characters in a string before using "
"the string in a generated command line or storing it in a database.  If "
"you're doing this, be careful to check the decoded string, not the encoded "
"bytes data; some encodings may have interesting properties, such as not "
"being bijective or not being fully ASCII-compatible.  This is especially "
"true if the input data also specifies the encoding, since the attacker can "
"then choose a clever way to hide malicious text in the encoded bytestream."
msgstr ""
"–ü—ñ–¥ —á–∞—Å –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö, —â–æ –Ω–∞–¥—Ö–æ–¥—è—Ç—å —ñ–∑ –≤–µ–±-–±—Ä–∞—É–∑–µ—Ä–∞ —á–∏ —ñ–Ω—à–æ–≥–æ "
"–Ω–µ–Ω–∞–¥—ñ–π–Ω–æ–≥–æ –¥–∂–µ—Ä–µ–ª–∞, –ø–æ—à–∏—Ä–µ–Ω–æ—é —Ç–µ—Ö–Ω—ñ–∫–æ—é —î –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ä—è–¥–∫–∞ –Ω–∞ –Ω–µ–¥–æ–∑–≤–æ–ª–µ–Ω—ñ "
"—Å–∏–º–≤–æ–ª–∏ –ø–µ—Ä–µ–¥ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è–º —Ä—è–¥–∫–∞ –≤ —Å—Ç–≤–æ—Ä–µ–Ω–æ–º—É –∫–æ–º–∞–Ω–¥–Ω–æ–º—É —Ä—è–¥–∫—É –∞–±–æ "
"–∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è–º –π–æ–≥–æ –≤ –±–∞–∑—ñ –¥–∞–Ω–∏—Ö. –Ø–∫—â–æ –≤–∏ —Ä–æ–±–∏—Ç–µ —Ü–µ, –±—É–¥—å—Ç–µ –æ–±–µ—Ä–µ–∂–Ω—ñ, —â–æ–± "
"–ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –¥–µ–∫–æ–¥–æ–≤–∞–Ω–∏–π —Ä—è–¥–æ–∫, –∞ –Ω–µ –∑–∞–∫–æ–¥–æ–≤–∞–Ω—ñ –¥–∞–Ω—ñ –±–∞–π—Ç—ñ–≤; –¥–µ—è–∫—ñ –∫–æ–¥—É–≤–∞–Ω–Ω—è "
"–º–æ–∂—É—Ç—å –º–∞—Ç–∏ —Ü—ñ–∫–∞–≤—ñ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ, —Ç–∞–∫—ñ —è–∫ –Ω–µ–±—ñ–µ–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –∞–±–æ –Ω–µ–ø–æ–≤–Ω–∞ ASCII-"
"—Å—É–º—ñ—Å–Ω—ñ—Å—Ç—å. –¶–µ –æ—Å–æ–±–ª–∏–≤–æ –≤—ñ—Ä–Ω–æ, —è–∫—â–æ –≤—Ö—ñ–¥–Ω—ñ –¥–∞–Ω—ñ —Ç–∞–∫–æ–∂ –≤–∏–∑–Ω–∞—á–∞—é—Ç—å –∫–æ–¥—É–≤–∞–Ω–Ω—è, "
"–æ—Å–∫—ñ–ª—å–∫–∏ –∑–ª–æ–≤–º–∏—Å–Ω–∏–∫ –º–æ–∂–µ –≤–∏–±—Ä–∞—Ç–∏ —Ä–æ–∑—É–º–Ω–∏–π —Å–ø–æ—Å—ñ–± –ø—Ä–∏—Ö–æ–≤–∞—Ç–∏ —à–∫—ñ–¥–ª–∏–≤–∏–π —Ç–µ–∫—Å—Ç —É "
"–∑–∞–∫–æ–¥–æ–≤–∞–Ω–æ–º—É –±–∞–π—Ç–æ–≤–æ–º—É –ø–æ—Ç–æ—Ü—ñ."

#: ../../howto/unicode.rst:691
msgid "Converting Between File Encodings"
msgstr "–ü–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è –º—ñ–∂ –∫–æ–¥—É–≤–∞–Ω–Ω—è–º–∏ —Ñ–∞–π–ª—ñ–≤"

#: ../../howto/unicode.rst:693
msgid ""
"The :class:`~codecs.StreamRecoder` class can transparently convert between "
"encodings, taking a stream that returns data in encoding #1 and behaving "
"like a stream returning data in encoding #2."
msgstr ""
"–ö–ª–∞—Å :class:`~codecs.StreamRecoder` –º–æ–∂–µ –ø—Ä–æ–∑–æ—Ä–æ –∫–æ–Ω–≤–µ—Ä—Ç—É–≤–∞—Ç–∏ –º—ñ–∂ "
"–∫–æ–¥—É–≤–∞–Ω–Ω—è–º–∏, –ø—Ä–∏–π–º–∞—é—á–∏ –ø–æ—Ç—ñ–∫, —è–∫–∏–π –ø–æ–≤–µ—Ä—Ç–∞—î –¥–∞–Ω—ñ –≤ –∫–æ–¥—É–≤–∞–Ω–Ω—ñ ‚Ññ1, —ñ "
"–ø–æ–≤–æ–¥–∏—Ç–∏—Å—è —è–∫ –ø–æ—Ç—ñ–∫, —è–∫–∏–π –ø–æ–≤–µ—Ä—Ç–∞—î –¥–∞–Ω—ñ –≤ –∫–æ–¥—É–≤–∞–Ω–Ω—ñ ‚Ññ2."

#: ../../howto/unicode.rst:697
msgid ""
"For example, if you have an input file *f* that's in Latin-1, you can wrap "
"it with a :class:`~codecs.StreamRecoder` to return bytes encoded in UTF-8::"
msgstr ""
"–ù–∞–ø—Ä–∏–∫–ª–∞–¥, —è–∫—â–æ —É –≤–∞—Å —î –≤—Ö—ñ–¥–Ω–∏–π —Ñ–∞–π–ª *f*, –Ω–∞–ø–∏—Å–∞–Ω–∏–π –º–æ–≤–æ—é Latin-1, –≤–∏ –º–æ–∂–µ—Ç–µ "
"–æ–±–µ—Ä–Ω—É—Ç–∏ –π–æ–≥–æ :class:`~codecs.StreamRecoder`, —â–æ–± –ø–æ–≤–µ—Ä–Ω—É—Ç–∏ –±–∞–π—Ç–∏, "
"–∑–∞–∫–æ–¥–æ–≤–∞–Ω—ñ –≤ UTF-8::"

#: ../../howto/unicode.rst:701
msgid ""
"new_f = codecs.StreamRecoder(f,\n"
"    # en/decoder: used by read() to encode its results and\n"
"    # by write() to decode its input.\n"
"    codecs.getencoder('utf-8'), codecs.getdecoder('utf-8'),\n"
"\n"
"    # reader/writer: used to read and write to the stream.\n"
"    codecs.getreader('latin-1'), codecs.getwriter('latin-1') )"
msgstr ""
"new_f = codecs.StreamRecoder(f,\n"
"    # en/decoder: used by read() to encode its results and\n"
"    # by write() to decode its input.\n"
"    codecs.getencoder('utf-8'), codecs.getdecoder('utf-8'),\n"
"\n"
"    # reader/writer: used to read and write to the stream.\n"
"    codecs.getreader('latin-1'), codecs.getwriter('latin-1') )"

#: ../../howto/unicode.rst:711
msgid "Files in an Unknown Encoding"
msgstr "–§–∞–π–ª–∏ –≤ –Ω–µ–≤—ñ–¥–æ–º–æ–º—É –∫–æ–¥—É–≤–∞–Ω–Ω—ñ"

#: ../../howto/unicode.rst:713
msgid ""
"What can you do if you need to make a change to a file, but don't know the "
"file's encoding?  If you know the encoding is ASCII-compatible and only want "
"to examine or modify the ASCII parts, you can open the file with the "
"``surrogateescape`` error handler::"
msgstr ""
"–©–æ —Ä–æ–±–∏—Ç–∏, —è–∫—â–æ –≤–∞–º –ø–æ—Ç—Ä—ñ–±–Ω–æ –≤–Ω–µ—Å—Ç–∏ –∑–º—ñ–Ω–∏ —É —Ñ–∞–π–ª, –∞–ª–µ –≤–∏ –Ω–µ –∑–Ω–∞—î—Ç–µ –∫–æ–¥—É–≤–∞–Ω–Ω—è "
"—Ñ–∞–π–ª—É? –Ø–∫—â–æ –≤–∏ –∑–Ω–∞—î—Ç–µ, —â–æ –∫–æ–¥—É–≤–∞–Ω–Ω—è —Å—É–º—ñ—Å–Ω–µ –∑ ASCII, —ñ —Ö–æ—á–µ—Ç–µ –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –∞–±–æ "
"–∑–º—ñ–Ω–∏—Ç–∏ –ª–∏—à–µ —á–∞—Å—Ç–∏–Ω–∏ ASCII, –≤–∏ –º–æ–∂–µ—Ç–µ –≤—ñ–¥–∫—Ä–∏—Ç–∏ —Ñ–∞–π–ª –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –æ–±—Ä–æ–±–Ω–∏–∫–∞ "
"–ø–æ–º–∏–ª–æ–∫ ``surrogateescape``::"

#: ../../howto/unicode.rst:718
msgid ""
"with open(fname, 'r', encoding=\"ascii\", errors=\"surrogateescape\") as f:\n"
"    data = f.read()\n"
"\n"
"# make changes to the string 'data'\n"
"\n"
"with open(fname + '.new', 'w',\n"
"          encoding=\"ascii\", errors=\"surrogateescape\") as f:\n"
"    f.write(data)"
msgstr ""
"with open(fname, 'r', encoding=\"ascii\", errors=\"surrogateescape\") as f:\n"
"    data = f.read()\n"
"\n"
"# make changes to the string 'data'\n"
"\n"
"with open(fname + '.new', 'w',\n"
"          encoding=\"ascii\", errors=\"surrogateescape\") as f:\n"
"    f.write(data)"

#: ../../howto/unicode.rst:727
msgid ""
"The ``surrogateescape`` error handler will decode any non-ASCII bytes as "
"code points in a special range running from U+DC80 to U+DCFF.  These code "
"points will then turn back into the same bytes when the ``surrogateescape`` "
"error handler is used to encode the data and write it back out."
msgstr ""
"–û–±—Ä–æ–±–Ω–∏–∫ –ø–æ–º–∏–ª–æ–∫ ``surrogateescape`` –¥–µ–∫–æ–¥—É—î –±—É–¥—å-—è–∫—ñ –±–∞–π—Ç–∏, –≤—ñ–¥–º—ñ–Ω–Ω—ñ –≤—ñ–¥ "
"ASCII, —è–∫ –∫–æ–¥–æ–≤—ñ —Ç–æ—á–∫–∏ –≤ —Å–ø–µ—Ü—ñ–∞–ª—å–Ω–æ–º—É –¥—ñ–∞–ø–∞–∑–æ–Ω—ñ –≤—ñ–¥ U+DC80 –¥–æ U+DCFF. –ü–æ—Ç—ñ–º "
"—Ü—ñ –∫–æ–¥–æ–≤—ñ —Ç–æ—á–∫–∏ –∑–Ω–æ–≤—É –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—é—Ç—å—Å—è –Ω–∞ —Ç—ñ —Å–∞–º—ñ –±–∞–π—Ç–∏, –∫–æ–ª–∏ –æ–±—Ä–æ–±–Ω–∏–∫ –ø–æ–º–∏–ª–æ–∫ "
"``surrogateescape`` –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –¥–ª—è –∫–æ–¥—É–≤–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö —ñ —ó—Ö –∑–≤–æ—Ä–æ—Ç–Ω–æ–≥–æ "
"–∑–∞–ø–∏—Å—É."

#: ../../howto/unicode.rst:737
msgid ""
"One section of `Mastering Python 3 Input/Output <https://pyvideo.org/"
"video/289/pycon-2010--mastering-python-3-i-o>`_, a PyCon 2010 talk by David "
"Beazley, discusses text processing and binary data handling."
msgstr ""
"–í –æ–¥–Ω–æ–º —Ä–∞–∑–¥–µ–ª–µ ¬´–û—Å–≤–æ–µ–Ω–∏–µ –≤–≤–æ–¥–∞/–≤—ã–≤–æ–¥–∞ Python 3 <https://pyvideo.org/"
"video/289/pycon-2010--mastering-python-3-io>¬ª, –¥–æ–∫–ª–∞–¥–∞ –î—ç–≤–∏–¥–∞ –ë–∏–∑–ª–∏ –Ω–∞ PyCon "
"2010, –æ–±—Å—É–∂–¥–∞–µ—Ç—Å—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞. –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–≤–æ–∏—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö."

#: ../../howto/unicode.rst:741
msgid ""
"The `PDF slides for Marc-Andr√© Lemburg's presentation \"Writing Unicode-"
"aware Applications in Python\" <https://downloads.egenix.com/python/LSM2005-"
"Developing-Unicode-aware-applications-in-Python.pdf>`_ discuss questions of "
"character encodings as well as how to internationalize and localize an "
"application.  These slides cover Python 2.x only."
msgstr ""
"–£ `PDF-—Å–ª–∞–π–¥–∞—Ö –¥–ª—è –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü—ñ—ó –ú–∞—Ä–∫–∞-–ê–Ω–¥—Ä–µ –õ–µ–º–±—É—Ä–≥–∞ \"–ù–∞–ø–∏—Å–∞–Ω–Ω—è –ø—Ä–æ–≥—Ä–∞–º, —â–æ "
"–ø—ñ–¥—Ç—Ä–∏–º—É—é—Ç—å Unicode –Ω–∞ Python\" <https://downloads.egenix.com/python/LSM2005-"
"Developing-Unicode-aware-applications-in-Python.pdf>`_ –æ–±–≥–æ–≤–æ—Ä—é—é—Ç—å—Å—è –ø–∏—Ç–∞–Ω–Ω—è "
"–∫–æ–¥—É–≤–∞–Ω–Ω—è —Å–∏–º–≤–æ–ª—ñ–≤, –∞ —Ç–∞–∫–æ–∂ —Ç–µ, —è–∫ —ñ–Ω—Ç–µ—Ä–Ω–∞—Ü—ñ–æ–Ω–∞–ª—ñ–∑—É–≤–∞—Ç–∏ —Ç–∞ –ª–æ–∫–∞–ª—ñ–∑—É–≤–∞—Ç–∏ "
"–ø—Ä–æ–≥—Ä–∞–º—É. –¶—ñ —Å–ª–∞–π–¥–∏ —Å—Ç–æ—Å—É—é—Ç—å—Å—è –ª–∏—à–µ Python 2.x."

#: ../../howto/unicode.rst:747
msgid ""
"`The Guts of Unicode in Python <https://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ is a PyCon 2013 talk by Benjamin Peterson that "
"discusses the internal Unicode representation in Python 3.3."
msgstr ""
"`The Guts of Unicode –≤ Python <https://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ ‚Äî —ç—Ç–æ –¥–æ–∫–ª–∞–¥ –ë–µ–Ω–¥–∂–∞–º–∏–Ω–∞ –ü–µ—Ç–µ—Ä—Å–æ–Ω–∞ –Ω–∞ PyCon 2013, –≤ "
"–∫–æ—Ç–æ—Ä–æ–º –æ–±—Å—É–∂–¥–∞–µ—Ç—Å—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ Unicode –≤ Python. 3.3."

#: ../../howto/unicode.rst:754
msgid "Acknowledgements"
msgstr "Reconhecimentos"

#: ../../howto/unicode.rst:756
msgid ""
"The initial draft of this document was written by Andrew Kuchling. It has "
"since been revised further by Alexander Belopolsky, Georg Brandl, Andrew "
"Kuchling, and Ezio Melotti."
msgstr ""
"–ü–æ—á–∞—Ç–∫–æ–≤–∏–π –ø—Ä–æ–µ–∫—Ç —Ü—å–æ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –±—É–≤ –Ω–∞–ø–∏—Å–∞–Ω–∏–π –ï–Ω–¥—Ä—é –ö—É—Ö–ª—ñ–Ω–≥–æ–º. –í—ñ–¥—Ç–æ–¥—ñ –≤—ñ–Ω "
"–±—É–≤ –¥–æ–¥–∞—Ç–∫–æ–≤–æ –ø–µ—Ä–µ–≥–ª—è–Ω—É—Ç –û–ª–µ–∫—Å–∞–Ω–¥—Ä–æ–º –ë—î–ª–æ–ø–æ–ª—å—Å—å–∫–∏–º, –ì–µ–æ—Ä–≥–æ–º –ë—Ä–∞–Ω–¥–ª–æ–º, –ï–Ω–¥—Ä—é "
"–ö—É—Ö–ª—ñ–Ω–≥–æ–º —Ç–∞ –ï—Ü—ñ–æ –ú–µ–ª–æ—Ç—Ç—ñ."

#: ../../howto/unicode.rst:760
msgid ""
"Thanks to the following people who have noted errors or offered suggestions "
"on this article: √âric Araujo, Nicholas Bastin, Nick Coghlan, Marius "
"Gedminas, Kent Johnson, Ken Krugler, Marc-Andr√© Lemburg, Martin von L√∂wis, "
"Terry J. Reedy, Serhiy Storchaka, Eryk Sun, Chad Whitacre, Graham Wideman."
msgstr ""
"–î—è–∫—É—î–º–æ —Ç–∞–∫–∏–º –ª—é–¥—è–º, —è–∫—ñ –ø–æ–º—ñ—Ç–∏–ª–∏ –ø–æ–º–∏–ª–∫–∏ –∞–±–æ –Ω–∞–¥–∞–ª–∏ –ø—Ä–æ–ø–æ–∑–∏—Ü—ñ—ó —â–æ–¥–æ —Ü—ñ—î—ó "
"—Å—Ç–∞—Ç—Ç—ñ: –ï—Ä—ñ–∫ –ê—Ä–∞—É—Ö–æ, –ù—ñ–∫–æ–ª–∞—Å –ë–∞—Å—Ç—ñ–Ω, –ù—ñ–∫ –ö–æ–≥–ª–∞–Ω, –ú–∞—Ä—ñ—É—Å –ì–µ–¥–º—ñ–Ω–∞—Å, –ö–µ–Ω—Ç "
"–î–∂–æ–Ω—Å–æ–Ω, –ö–µ–Ω –ö—Ä—É–≥–ª–µ—Ä, –ú–∞—Ä–∫-–ê–Ω–¥—Ä–µ –õ–µ–º–±—É—Ä–≥, –ú–∞—Ä—Ç—ñ–Ω —Ñ–æ–Ω –õ—å–æ–≤—ñ—Å, –¢–µ—Ä—Ä—ñ –î–∂. –†—ñ–¥—ñ, "
"–°–µ—Ä–≥—ñ–π –°—Ç–æ—Ä—á–∞–∫–∞ , –ï—Ä—ñ–∫ –°–∞–Ω, –ß–∞–¥ –í—ñ—Ç–∞–∫—Ä, –ì—Ä–µ–º –£–∞–π–¥–º–µ–Ω."

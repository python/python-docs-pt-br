# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Hildeberto Abreu Magalhães <hildeberto@gmail.com>, 2021
# Tiago Henrique <tiagohrm@gmail.com>, 2021
# Adorilson Bezerra <adorilson@gmail.com>, 2022
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2023
# Marco Rougeth <marco@rougeth.com>, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-06 14:20+0000\n"
"PO-Revision-Date: 2021-06-28 01:50+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../tutorial/modules.rst:5
msgid "Modules"
msgstr "Módulos"

#: ../../tutorial/modules.rst:7
msgid ""
"If you quit from the Python interpreter and enter it again, the definitions "
"you have made (functions and variables) are lost. Therefore, if you want to "
"write a somewhat longer program, you are better off using a text editor to "
"prepare the input for the interpreter and running it with that file as input "
"instead.  This is known as creating a *script*.  As your program gets "
"longer, you may want to split it into several files for easier maintenance.  "
"You may also want to use a handy function that you've written in several "
"programs without copying its definition into each program."
msgstr ""
"Ao sair e entrar de novo no interpretador Python, as definições anteriores "
"(funções e variáveis) são perdidas. Portanto, se quiser escrever um programa "
"maior, será mais eficiente usar um editor de texto para preparar as entradas "
"para o interpretador, e executá-lo usando o arquivo como entrada. Isso é "
"conhecido como criar um *script*. Se o programa se torna ainda maior, é uma "
"boa prática dividi-lo em arquivos menores, para facilitar a manutenção. "
"Também é preferível usar um arquivo separado para uma função que você "
"escreveria em vários programas diferentes, para não copiar a definição de "
"função em cada um deles."

#: ../../tutorial/modules.rst:16
msgid ""
"To support this, Python has a way to put definitions in a file and use them "
"in a script or in an interactive instance of the interpreter. Such a file is "
"called a *module*; definitions from a module can be *imported* into other "
"modules or into the *main* module (the collection of variables that you have "
"access to in a script executed at the top level and in calculator mode)."
msgstr ""
"Para permitir isso, Python tem uma maneira de colocar as definições em um "
"arquivo e então usá-las em um script ou em uma execução interativa do "
"interpretador. Tal arquivo é chamado de *módulo*; definições de um módulo "
"podem ser *importadas* para outros módulos, ou para o módulo *principal* (a "
"coleção de variáveis a que você tem acesso num script executado como um "
"programa e no modo calculadora)."

#: ../../tutorial/modules.rst:22
msgid ""
"A module is a file containing Python definitions and statements.  The file "
"name is the module name with the suffix :file:`.py` appended.  Within a "
"module, the module's name (as a string) is available as the value of the "
"global variable ``__name__``.  For instance, use your favorite text editor "
"to create a file called :file:`fibo.py` in the current directory with the "
"following contents::"
msgstr ""
"Um módulo é um arquivo contendo definições e instruções Python. O nome do "
"arquivo é o nome do módulo acrescido do sufixo :file:`.py`. Dentro de um "
"módulo, o nome do módulo (como uma string) está disponível como o valor da "
"variável global ``__name__``. Por exemplo, use seu editor de texto favorito "
"para criar um arquivo chamado :file:`fibo.py` no diretório atual com o "
"seguinte conteúdo::"

#: ../../tutorial/modules.rst:28
msgid ""
"# Fibonacci numbers module\n"
"\n"
"def fib(n):\n"
"    \"\"\"Write Fibonacci series up to n.\"\"\"\n"
"    a, b = 0, 1\n"
"    while a < n:\n"
"        print(a, end=' ')\n"
"        a, b = b, a+b\n"
"    print()\n"
"\n"
"def fib2(n):\n"
"    \"\"\"Return Fibonacci series up to n.\"\"\"\n"
"    result = []\n"
"    a, b = 0, 1\n"
"    while a < n:\n"
"        result.append(a)\n"
"        a, b = b, a+b\n"
"    return result"
msgstr ""
"# Módulo de números de Fibonacci\n"
"\n"
"def fib(n):\n"
"    \"\"\"Escreve a série de Fibonacci até n.\"\"\"\n"
"    a, b = 0, 1\n"
"    while a < n:\n"
"        print(a, end=' ')\n"
"        a, b = b, a+b\n"
"    print()\n"
"\n"
"def fib2(n):\n"
"    \"\"\"Retorna a série de Fibonacci até n.\"\"\"\n"
"    result = []\n"
"    a, b = 0, 1\n"
"    while a < n:\n"
"        result.append(a)\n"
"        a, b = b, a+b\n"
"    return result"

#: ../../tutorial/modules.rst:47
msgid ""
"Now enter the Python interpreter and import this module with the following "
"command::"
msgstr ""
"Agora, entre no interpretador Python e importe esse módulo com o seguinte\n"
"comando::"

#: ../../tutorial/modules.rst:50
msgid ">>> import fibo"
msgstr ">>> import fibo"

#: ../../tutorial/modules.rst:52
msgid ""
"This does not add the names of the functions defined in ``fibo``  directly "
"to the current :term:`namespace` (see :ref:`tut-scopes` for more details); "
"it only adds the module name ``fibo`` there. Using the module name you can "
"access the functions::"
msgstr ""
"Isso não adiciona os nomes das funções definidas em ``fibo`` diretamente ao :"
"term:`espaço de nomes` atual (veja :ref:`tut-scopes` para mais detalhes); "
"isso adiciona somente o nome do módulo ``fibo``. Usando o nome do módulo "
"você pode acessar as funções::"

#: ../../tutorial/modules.rst:57
msgid ""
">>> fibo.fib(1000)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n"
">>> fibo.fib2(100)\n"
"[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n"
">>> fibo.__name__\n"
"'fibo'"
msgstr ""
">>> fibo.fib(1000)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n"
">>> fibo.fib2(100)\n"
"[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n"
">>> fibo.__name__\n"
"'fibo'"

#: ../../tutorial/modules.rst:64
msgid ""
"If you intend to use a function often you can assign it to a local name::"
msgstr ""
"Se você pretende usar uma função muitas vezes, você pode atribui-lá a um "
"nome local::"

#: ../../tutorial/modules.rst:66
msgid ""
">>> fib = fibo.fib\n"
">>> fib(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
msgstr ""
">>> fib = fibo.fib\n"
">>> fib(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"

#: ../../tutorial/modules.rst:74
msgid "More on Modules"
msgstr "Mais sobre módulos"

#: ../../tutorial/modules.rst:76
msgid ""
"A module can contain executable statements as well as function definitions. "
"These statements are intended to initialize the module. They are executed "
"only the *first* time the module name is encountered in an import statement. "
"[#]_ (They are also run if the file is executed as a script.)"
msgstr ""
"Um módulo pode conter tanto instruções executáveis quanto definições de "
"funções e classes. Essas instruções servem para inicializar o módulo. Eles "
"são executados somente na *primeira* vez que o módulo é encontrado em uma "
"instrução de importação. [#]_ (Também rodam se o arquivo é executado como um "
"script.)"

#: ../../tutorial/modules.rst:81
msgid ""
"Each module has its own private namespace, which is used as the global "
"namespace by all functions defined in the module. Thus, the author of a "
"module can use global variables in the module without worrying about "
"accidental clashes with a user's global variables. On the other hand, if you "
"know what you are doing you can touch a module's global variables with the "
"same notation used to refer to its functions, ``modname.itemname``."
msgstr ""
"Cada módulo tem seu próprio espaço de nomes privado, que é usado como espaço "
"de nomes global para todas as funções definidas no módulo. Assim, o autor de "
"um módulo pode usar variáveis globais no seu módulo sem se preocupar com "
"conflitos acidentais com as variáveis globais do usuário. Por outro lado, se "
"você precisar usar uma variável global de um módulo, poderá fazê-lo com a "
"mesma notação usada para se referir às suas funções, ``nomemodulo.nomeitem``."

#: ../../tutorial/modules.rst:88
msgid ""
"Modules can import other modules.  It is customary but not required to place "
"all :keyword:`import` statements at the beginning of a module (or script, "
"for that matter).  The imported module names, if placed at the top level of "
"a module (outside any functions or classes), are added to the module's "
"global namespace."
msgstr ""
"Módulos podem importar outros módulos. É costume, porém não obrigatório, "
"colocar todas as instruções :keyword:`import` no início do módulo (ou "
"script , se preferir). As definições do módulo importado, se colocados no "
"nível de um módulo (fora de quaisquer funções ou classes), elas são "
"adicionadas a espaço de nomes global da módulo."

#: ../../tutorial/modules.rst:93
msgid ""
"There is a variant of the :keyword:`import` statement that imports names "
"from a module directly into the importing module's namespace.  For example::"
msgstr ""
"Existe uma variante da instrução :keyword:`import` que importa definições de "
"um módulo diretamente para o espaço de nomes do módulo importador. Por "
"exemplo::"

#: ../../tutorial/modules.rst:96
msgid ""
">>> from fibo import fib, fib2\n"
">>> fib(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
msgstr ""
">>> from fibo import fib, fib2\n"
">>> fib(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"

#: ../../tutorial/modules.rst:100
msgid ""
"This does not introduce the module name from which the imports are taken in "
"the local namespace (so in the example, ``fibo`` is not defined)."
msgstr ""
"Isso não coloca o nome do módulo de onde foram feitas as importações no "
"espaço de nomes local (assim, no exemplo, ``fibo`` não está definido)."

#: ../../tutorial/modules.rst:103
msgid "There is even a variant to import all names that a module defines::"
msgstr ""
"Existe ainda uma variante que importa todos os nomes definidos em um módulo::"

#: ../../tutorial/modules.rst:105
msgid ""
">>> from fibo import *\n"
">>> fib(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
msgstr ""
">>> from fibo import *\n"
">>> fib(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"

#: ../../tutorial/modules.rst:109
msgid ""
"This imports all names except those beginning with an underscore (``_``). In "
"most cases Python programmers do not use this facility since it introduces "
"an unknown set of names into the interpreter, possibly hiding some things "
"you have already defined."
msgstr ""
"Isso importa todos as declarações de nomes, exceto aqueles que iniciam com "
"um sublinhado (``_``). Na maioria dos casos, programadores Python não usam "
"esta facilidade porque ela introduz um conjunto desconhecido de nomes no "
"ambiente, podendo esconder outros nomes previamente definidos."

#: ../../tutorial/modules.rst:114
msgid ""
"Note that in general the practice of importing ``*`` from a module or "
"package is frowned upon, since it often causes poorly readable code. "
"However, it is okay to use it to save typing in interactive sessions."
msgstr ""
"Note que, em geral, a prática do ``import *`` de um módulo ou pacote é "
"desaprovada, uma vez que muitas vezes dificulta a leitura do código. "
"Contudo, é aceitável para diminuir a digitação em sessões interativas."

#: ../../tutorial/modules.rst:118
msgid ""
"If the module name is followed by :keyword:`!as`, then the name following :"
"keyword:`!as` is bound directly to the imported module."
msgstr ""
"Se o nome do módulo é seguido pela palavra-chave :keyword:`!as`, o nome a "
"seguir é vinculado diretamente ao módulo importado."

#: ../../tutorial/modules.rst:123
msgid ""
">>> import fibo as fib\n"
">>> fib.fib(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
msgstr ""
">>> import fibo as fib\n"
">>> fib.fib(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"

#: ../../tutorial/modules.rst:127
msgid ""
"This is effectively importing the module in the same way that ``import "
"fibo`` will do, with the only difference of it being available as ``fib``."
msgstr ""
"Isto efetivamente importa o módulo, da mesma maneira que ``import fibo`` "
"fará, com a única diferença de estar disponível com o nome ``fib``."

#: ../../tutorial/modules.rst:130
msgid ""
"It can also be used when utilising :keyword:`from` with similar effects::"
msgstr ""
"Também pode ser utilizado com a palavra-chave :keyword:`from`, com efeitos "
"similares::"

#: ../../tutorial/modules.rst:132
msgid ""
">>> from fibo import fib as fibonacci\n"
">>> fibonacci(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
msgstr ""
">>> from fibo import fib as fibonacci\n"
">>> fibonacci(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"

#: ../../tutorial/modules.rst:139
msgid ""
"For efficiency reasons, each module is only imported once per interpreter "
"session.  Therefore, if you change your modules, you must restart the "
"interpreter -- or, if it's just one module you want to test interactively, "
"use :func:`importlib.reload`, e.g. ``import importlib; importlib."
"reload(modulename)``."
msgstr ""
" Por razões de eficiência, cada módulo é importado uma única vez por sessão "
"do interpretador. Portanto, se você alterar seus módulos, você deve "
"reiniciar o interpretador -- ou, se é somente um módulo que você quer testar "
"interativamente, use a função :func:`reload`, ex. ``import importlib; "
"importlib.reload(nomemodulo)``."

#: ../../tutorial/modules.rst:149
msgid "Executing modules as scripts"
msgstr "Executando módulos como scripts"

#: ../../tutorial/modules.rst:151
msgid "When you run a Python module with ::"
msgstr "Quando você rodar um módulo Python com ::"

#: ../../tutorial/modules.rst:153
msgid "python fibo.py <arguments>"
msgstr "python fibo.py <argumentos>"

#: ../../tutorial/modules.rst:155
msgid ""
"the code in the module will be executed, just as if you imported it, but "
"with the ``__name__`` set to ``\"__main__\"``.  That means that by adding "
"this code at the end of your module::"
msgstr ""
"o código no módulo será executado, da mesma forma que quando é importado, "
"mas com a variável ``__name__`` com valor ``\"__main__\"``. Isto significa "
"que adicionando este código ao final do seu módulo::"

#: ../../tutorial/modules.rst:159
msgid ""
"if __name__ == \"__main__\":\n"
"    import sys\n"
"    fib(int(sys.argv[1]))"
msgstr ""
"if __name__ == \"__main__\":\n"
"    import sys\n"
"    fib(int(sys.argv[1]))"

#: ../../tutorial/modules.rst:163
msgid ""
"you can make the file usable as a script as well as an importable module, "
"because the code that parses the command line only runs if the module is "
"executed as the \"main\" file:"
msgstr ""
"você pode tornar o arquivo utilizável tanto como script quanto como um "
"módulo importável, porque o código que analisa a linha de comando só roda se "
"o módulo é executado como arquivo \"principal\":"

#: ../../tutorial/modules.rst:167
msgid ""
"$ python fibo.py 50\n"
"0 1 1 2 3 5 8 13 21 34"
msgstr ""
"$ python fibo.py 50\n"
"0 1 1 2 3 5 8 13 21 34"

#: ../../tutorial/modules.rst:172
msgid "If the module is imported, the code is not run::"
msgstr "Se o módulo é importado, o código não é executado::"

#: ../../tutorial/modules.rst:174
msgid ""
">>> import fibo\n"
">>>"
msgstr ""
">>> import fibo\n"
">>>"

#: ../../tutorial/modules.rst:177
msgid ""
"This is often used either to provide a convenient user interface to a "
"module, or for testing purposes (running the module as a script executes a "
"test suite)."
msgstr ""
"Isso é frequentemente usado para fornecer uma interface de usuário "
"conveniente para um módulo, ou para realizar testes (rodando o módulo como "
"um script executa um conjunto de testes)."

#: ../../tutorial/modules.rst:184
msgid "The Module Search Path"
msgstr "O caminho de busca dos módulos"

#: ../../tutorial/modules.rst:188
msgid ""
"When a module named :mod:`!spam` is imported, the interpreter first searches "
"for a built-in module with that name. These module names are listed in :data:"
"`sys.builtin_module_names`. If not found, it then searches for a file named :"
"file:`spam.py` in a list of directories given by the variable :data:`sys."
"path`.  :data:`sys.path` is initialized from these locations:"
msgstr ""
"Quando um módulo chamado :mod:`!spam` é importado, o interpretador procura "
"um módulo embutido com este nome. Estes nomes de módulo são listados em :"
"data:`sys.builtin_module_names`. Se não encontra, procura um arquivo "
"chamado :file:`spam.py` em uma lista de diretórios incluídos na variável :"
"data:`sys.path`. A :data:`sys.path` é inicializada com estes locais:"

#: ../../tutorial/modules.rst:194
msgid ""
"The directory containing the input script (or the current directory when no "
"file is specified)."
msgstr ""
"O diretório que contém o script importador (ou o diretório atual quando "
"nenhum arquivo é especificado)."

#: ../../tutorial/modules.rst:196
msgid ""
":envvar:`PYTHONPATH` (a list of directory names, with the same syntax as the "
"shell variable :envvar:`PATH`)."
msgstr ""
"A variável de ambiente :envvar:`PYTHONPATH` (uma lista de nomes de "
"diretórios, com a mesma sintaxe da variável de ambiente :envvar:`PATH`)."

#: ../../tutorial/modules.rst:198
msgid ""
"The installation-dependent default (by convention including a ``site-"
"packages`` directory, handled by the :mod:`site` module)."
msgstr ""
"O padrão dependente da instalação (por convenção, incluindo um diretório "
"``site-packages``, tratado pelo módulo :mod:`site`)."

#: ../../tutorial/modules.rst:201
msgid "More details are at :ref:`sys-path-init`."
msgstr "Mais detalhes em :ref:`sys-path-init`."

#: ../../tutorial/modules.rst:204
msgid ""
"On file systems which support symlinks, the directory containing the input "
"script is calculated after the symlink is followed. In other words the "
"directory containing the symlink is **not** added to the module search path."
msgstr ""
"Nos sistemas de arquivos que suportam links simbólicos, o diretório contendo "
"o script de entrada é resultante do diretório apontado pelo link simbólico. "
"Em outras palavras o diretório que contém o link simbólico **não** é "
"adicionado ao caminho de busca de módulos."

#: ../../tutorial/modules.rst:208
msgid ""
"After initialization, Python programs can modify :data:`sys.path`.  The "
"directory containing the script being run is placed at the beginning of the "
"search path, ahead of the standard library path. This means that scripts in "
"that directory will be loaded instead of modules of the same name in the "
"library directory. This is an error unless the replacement is intended.  See "
"section :ref:`tut-standardmodules` for more information."
msgstr ""
"Após a inicialização, programas Python podem modificar :data:`sys.path`. O "
"diretório que contém o script sendo executado é colocado no início da lista "
"de caminhos, à frente do caminho da biblioteca padrão. Isto significa que "
"módulos nesse diretório serão carregados, no lugar de módulos com o mesmo "
"nome na biblioteca padrão. Isso costuma ser um erro, a menos que seja "
"intencional. Veja a seção :ref:`tut-standardmodules` para mais informações."

#: ../../tutorial/modules.rst:221
msgid "\"Compiled\" Python files"
msgstr "Arquivos Python \"compilados\""

#: ../../tutorial/modules.rst:223
msgid ""
"To speed up loading modules, Python caches the compiled version of each "
"module in the ``__pycache__`` directory under the name :file:`module."
"{version}.pyc`, where the version encodes the format of the compiled file; "
"it generally contains the Python version number.  For example, in CPython "
"release 3.3 the compiled version of spam.py would be cached as ``__pycache__/"
"spam.cpython-33.pyc``.  This naming convention allows compiled modules from "
"different releases and different versions of Python to coexist."
msgstr ""
"Para acelerar o carregamento de módulos, o Python guarda versões compiladas "
"de cada módulo no diretório ``__pycache__`` com o nome :file:`modulo."
"{versão}.pyc`, onde a versão corresponde ao formato do arquivo compilado; "
"geralmente contêm o número da versão Python utilizada. Por exemplo, no "
"CPython release 3.3 a versão compilada de spam.py será guardada como "
"``__pycache__/spam.cpython-33.pyc``. Esta convenção de nomes permite a "
"coexistência de módulos compilados de diferentes releases e versões de "
"Python."

#: ../../tutorial/modules.rst:231
msgid ""
"Python checks the modification date of the source against the compiled "
"version to see if it's out of date and needs to be recompiled.  This is a "
"completely automatic process.  Also, the compiled modules are platform-"
"independent, so the same library can be shared among systems with different "
"architectures."
msgstr ""
"O Python verifica a data de modificação do arquivo fonte mediante a versão "
"compilada, para ver se está desatualizada e precisa ser recompilada. É um "
"processo completamente automático. Além disso, os módulos compilados são "
"independentes de plataforma, portanto a mesma biblioteca pode ser "
"compartilhada entre sistemas de arquiteturas diferentes."

#: ../../tutorial/modules.rst:236
msgid ""
"Python does not check the cache in two circumstances.  First, it always "
"recompiles and does not store the result for the module that's loaded "
"directly from the command line.  Second, it does not check the cache if "
"there is no source module.  To support a non-source (compiled only) "
"distribution, the compiled module must be in the source directory, and there "
"must not be a source module."
msgstr ""
"O Python não verifica as versões compiladas em duas circunstâncias. "
"Primeiro, sempre recompila e não armazena o resultado para módulos "
"carregados diretamente da linha de comando. Segundo, não verifica se não "
"houver um módulo fonte. Para suportar uma distribuição sem fontes (somente "
"as versões compiladas), o módulo compilado deve estar no diretório de "
"fontes, e não deve haver um módulo fonte."

#: ../../tutorial/modules.rst:243
msgid "Some tips for experts:"
msgstr "Algumas dicas para especialistas:"

#: ../../tutorial/modules.rst:245
msgid ""
"You can use the :option:`-O` or :option:`-OO` switches on the Python command "
"to reduce the size of a compiled module.  The ``-O`` switch removes assert "
"statements, the ``-OO`` switch removes both assert statements and __doc__ "
"strings.  Since some programs may rely on having these available, you should "
"only use this option if you know what you're doing.  \"Optimized\" modules "
"have an ``opt-`` tag and are usually smaller.  Future releases may change "
"the effects of optimization."
msgstr ""
"Você pode usar as opções :option:`-O` ou :option:`-OO` no comando Python "
"para reduzir o tamanho de um módulo compilado. A opção ``-O`` remove as "
"instruções assert, e a opção ``-OO`` remove, além das instruções assert, as "
"strings de documentações. Como alguns programas podem contar com essa "
"disponibilidade, só use essa opção se souber o que está fazendo. Módulos "
"\"otimizados\" tem uma marcação ``opt-`` e são geralmente de menor tamanho. "
"Futuros releases podem mudar os efeitos da otimização."

#: ../../tutorial/modules.rst:253
msgid ""
"A program doesn't run any faster when it is read from a ``.pyc`` file than "
"when it is read from a ``.py`` file; the only thing that's faster about ``."
"pyc`` files is the speed with which they are loaded."
msgstr ""
"Um programa não roda mais rápido quando é lido de um arquivo ``.pyc`` do que "
"quando lido de um arquivo ``.py``; a única coisa que é mais rápida com "
"arquivos ``.pyc`` é sua velocidade de carregamento."

#: ../../tutorial/modules.rst:257
msgid ""
"The module :mod:`compileall` can create .pyc files for all modules in a "
"directory."
msgstr ""
"O módulo :mod:`compileall` pode criar arquivos .pyc para todos os módulos de "
"um diretório."

#: ../../tutorial/modules.rst:260
msgid ""
"There is more detail on this process, including a flow chart of the "
"decisions, in :pep:`3147`."
msgstr ""
"Há mais detalhes desse processo, incluindo um fluxograma de decisões, no :"
"pep:`3147`."

#: ../../tutorial/modules.rst:267
msgid "Standard Modules"
msgstr "Módulos padrões"

#: ../../tutorial/modules.rst:271
msgid ""
"Python comes with a library of standard modules, described in a separate "
"document, the Python Library Reference (\"Library Reference\" hereafter).  "
"Some modules are built into the interpreter; these provide access to "
"operations that are not part of the core of the language but are "
"nevertheless built in, either for efficiency or to provide access to "
"operating system primitives such as system calls.  The set of such modules "
"is a configuration option which also depends on the underlying platform.  "
"For example, the :mod:`winreg` module is only provided on Windows systems. "
"One particular module deserves some attention: :mod:`sys`, which is built "
"into every Python interpreter.  The variables ``sys.ps1`` and ``sys.ps2`` "
"define the strings used as primary and secondary prompts::"
msgstr ""
"O Python traz uma biblioteca padrão de módulos, descrita em um documento em "
"separado, a Referência da Biblioteca Python (doravante “Referência da "
"Biblioteca”). Alguns módulos estão embutidos no interpretador; estes "
"possibilitam acesso a operações que não são parte do núcleo da linguagem, "
"mas estão no interpretador seja por eficiência ou para permitir o acesso a "
"chamadas do sistema operacional. O conjunto destes módulos é uma opção de "
"configuração que depende também da plataforma utilizada. Por exemplo, o "
"módulo :mod:`winreg` só está disponível em sistemas Windows. Existe um "
"módulo que requer especial atenção: :mod:`sys`, que é embutido em qualquer "
"interpretador Python. As variáveis ``sys.ps1`` e ``sys.ps2`` definem as "
"strings utilizadas como prompt primário e secundário::"

#: ../../tutorial/modules.rst:283
msgid ""
">>> import sys\n"
">>> sys.ps1\n"
"'>>> '\n"
">>> sys.ps2\n"
"'... '\n"
">>> sys.ps1 = 'C> '\n"
"C> print('Yuck!')\n"
"Yuck!\n"
"C>"
msgstr ""
">>> import sys\n"
">>> sys.ps1\n"
"'>>> '\n"
">>> sys.ps2\n"
"'... '\n"
">>> sys.ps1 = 'C> '\n"
"C> print('ECA!')\n"
"Yuck!\n"
"C>"

#: ../../tutorial/modules.rst:294
msgid ""
"These two variables are only defined if the interpreter is in interactive "
"mode."
msgstr ""
"Essas variáveis só estão definidas se o interpretador está em modo "
"interativo."

#: ../../tutorial/modules.rst:296
msgid ""
"The variable ``sys.path`` is a list of strings that determines the "
"interpreter's search path for modules. It is initialized to a default path "
"taken from the environment variable :envvar:`PYTHONPATH`, or from a built-in "
"default if :envvar:`PYTHONPATH` is not set.  You can modify it using "
"standard list operations::"
msgstr ""
"A variável ``sys.path`` contém uma lista de strings que determina os "
"caminhos de busca de módulos conhecidos pelo interpretador. Ela é "
"inicializada para um caminho padrão, determinado pela variável de ambiente :"
"envvar:`PYTHONPATH`, ou por um valor padrão embutido, se :envvar:"
"`PYTHONPATH` não estiver definida. Você pode modificá-la com as operações "
"típicas de lista, por exemplo::"

#: ../../tutorial/modules.rst:302
msgid ""
">>> import sys\n"
">>> sys.path.append('/ufs/guido/lib/python')"
msgstr ""
">>> import sys\n"
">>> sys.path.append('/ufs/guido/lib/python')"

#: ../../tutorial/modules.rst:309
msgid "The :func:`dir` Function"
msgstr "A função :func:`dir`"

#: ../../tutorial/modules.rst:311
msgid ""
"The built-in function :func:`dir` is used to find out which names a module "
"defines.  It returns a sorted list of strings::"
msgstr ""
"A função embutida :func:`dir` é usada para descobrir quais nomes são "
"definidos por um módulo. Ela devolve uma lista ordenada de strings::"

#: ../../tutorial/modules.rst:314
msgid ""
">>> import fibo, sys\n"
">>> dir(fibo)\n"
"['__name__', 'fib', 'fib2']\n"
">>> dir(sys)\n"
"['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__',\n"
" '__interactivehook__', '__loader__', '__name__', '__package__', "
"'__spec__',\n"
" '__stderr__', '__stdin__', '__stdout__', '__unraisablehook__',\n"
" '_clear_type_cache', '_current_frames', '_debugmallocstats', '_framework',\n"
" '_getframe', '_git', '_home', '_xoptions', 'abiflags', 'addaudithook',\n"
" 'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix',\n"
" 'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing',\n"
" 'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', "
"'exc_info',\n"
" 'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info',\n"
" 'float_repr_style', 'get_asyncgen_hooks', "
"'get_coroutine_origin_tracking_depth',\n"
" 'getallocatedblocks', 'getdefaultencoding', 'getdlopenflags',\n"
" 'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile',\n"
" 'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval',\n"
" 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',\n"
" 'intern', 'is_finalizing', 'last_traceback', 'last_type', 'last_value',\n"
" 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks',\n"
" 'path_importer_cache', 'platform', 'prefix', 'ps1', 'ps2', "
"'pycache_prefix',\n"
" 'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', "
"'setdlopenflags',\n"
" 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', "
"'stderr',\n"
" 'stdin', 'stdout', 'thread_info', 'unraisablehook', 'version', "
"'version_info',\n"
" 'warnoptions']"
msgstr ""
">>> import fibo, sys\n"
">>> dir(fibo)\n"
"['__name__', 'fib', 'fib2']\n"
">>> dir(sys)\n"
"['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__',\n"
" '__interactivehook__', '__loader__', '__name__', '__package__', "
"'__spec__',\n"
" '__stderr__', '__stdin__', '__stdout__', '__unraisablehook__',\n"
" '_clear_type_cache', '_current_frames', '_debugmallocstats', '_framework',\n"
" '_getframe', '_git', '_home', '_xoptions', 'abiflags', 'addaudithook',\n"
" 'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix',\n"
" 'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing',\n"
" 'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', "
"'exc_info',\n"
" 'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info',\n"
" 'float_repr_style', 'get_asyncgen_hooks', "
"'get_coroutine_origin_tracking_depth',\n"
" 'getallocatedblocks', 'getdefaultencoding', 'getdlopenflags',\n"
" 'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile',\n"
" 'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval',\n"
" 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',\n"
" 'intern', 'is_finalizing', 'last_traceback', 'last_type', 'last_value',\n"
" 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks',\n"
" 'path_importer_cache', 'platform', 'prefix', 'ps1', 'ps2', "
"'pycache_prefix',\n"
" 'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', "
"'setdlopenflags',\n"
" 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', "
"'stderr',\n"
" 'stdin', 'stdout', 'thread_info', 'unraisablehook', 'version', "
"'version_info',\n"
" 'warnoptions']"

#: ../../tutorial/modules.rst:340
msgid ""
"Without arguments, :func:`dir` lists the names you have defined currently::"
msgstr "Sem argumentos, :func:`dir` lista os nomes atualmente definidos::"

#: ../../tutorial/modules.rst:342
msgid ""
">>> a = [1, 2, 3, 4, 5]\n"
">>> import fibo\n"
">>> fib = fibo.fib\n"
">>> dir()\n"
"['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']"
msgstr ""
">>> a = [1, 2, 3, 4, 5]\n"
">>> import fibo\n"
">>> fib = fibo.fib\n"
">>> dir()\n"
"['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']"

#: ../../tutorial/modules.rst:348
msgid ""
"Note that it lists all types of names: variables, modules, functions, etc."
msgstr ""
"Observe que ela lista todo tipo de nomes: variáveis, módulos, funções, etc."

#: ../../tutorial/modules.rst:352
msgid ""
":func:`dir` does not list the names of built-in functions and variables.  If "
"you want a list of those, they are defined in the standard module :mod:"
"`builtins`::"
msgstr ""
":func:`dir` não lista os nomes de variáveis e funções embutidas. Esta lista "
"está disponível no módulo padrão :mod:`builtins`::"

#: ../../tutorial/modules.rst:356
msgid ""
">>> import builtins\n"
">>> dir(builtins)\n"
"['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',\n"
" 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',\n"
" 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',\n"
" 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',\n"
" 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',\n"
" 'FileExistsError', 'FileNotFoundError', 'FloatingPointError',\n"
" 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',\n"
" 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',\n"
" 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',\n"
" 'MemoryError', 'NameError', 'None', 'NotADirectoryError', "
"'NotImplemented',\n"
" 'NotImplementedError', 'OSError', 'OverflowError',\n"
" 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',\n"
" 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',\n"
" 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',\n"
" 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',\n"
" 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',\n"
" 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',\n"
" 'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',\n"
" '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',\n"
" 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',\n"
" 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',\n"
" 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',\n"
" 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',\n"
" 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',\n"
" 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',\n"
" 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',\n"
" 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',\n"
" 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',\n"
" 'zip']"
msgstr ""
">>> import builtins\n"
">>> dir(builtins)\n"
"['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',\n"
" 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',\n"
" 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',\n"
" 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',\n"
" 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',\n"
" 'FileExistsError', 'FileNotFoundError', 'FloatingPointError',\n"
" 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',\n"
" 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',\n"
" 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',\n"
" 'MemoryError', 'NameError', 'None', 'NotADirectoryError', "
"'NotImplemented',\n"
" 'NotImplementedError', 'OSError', 'OverflowError',\n"
" 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',\n"
" 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',\n"
" 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',\n"
" 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',\n"
" 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',\n"
" 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',\n"
" 'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',\n"
" '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',\n"
" 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',\n"
" 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',\n"
" 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',\n"
" 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',\n"
" 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',\n"
" 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',\n"
" 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',\n"
" 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',\n"
" 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',\n"
" 'zip']"

#: ../../tutorial/modules.rst:391
msgid "Packages"
msgstr "Pacotes"

#: ../../tutorial/modules.rst:393
msgid ""
"Packages are a way of structuring Python's module namespace by using "
"\"dotted module names\".  For example, the module name :mod:`!A.B` "
"designates a submodule named ``B`` in a package named ``A``.  Just like the "
"use of modules saves the authors of different modules from having to worry "
"about each other's global variable names, the use of dotted module names "
"saves the authors of multi-module packages like NumPy or Pillow from having "
"to worry about each other's module names."
msgstr ""
"Os pacotes são uma maneira de estruturar o \"espaço de nomes\" dos módulos "
"Python, usando \"nomes de módulo com pontos\". Por exemplo, o nome do "
"módulo :mod:`!A.B` designa um submódulo chamado ``B``, em um pacote chamado "
"``A``. Assim como o uso de módulos evita que os autores de módulos "
"diferentes tenham que se preocupar com nomes de variáveis globais, o uso de "
"nomes de módulos com pontos evita que os autores de pacotes com muitos "
"módulos, como NumPy ou Pillow, tenham que se preocupar com os nomes dos "
"módulos uns dos outros."

#: ../../tutorial/modules.rst:401
msgid ""
"Suppose you want to design a collection of modules (a \"package\") for the "
"uniform handling of sound files and sound data.  There are many different "
"sound file formats (usually recognized by their extension, for example: :"
"file:`.wav`, :file:`.aiff`, :file:`.au`), so you may need to create and "
"maintain a growing collection of modules for the conversion between the "
"various file formats. There are also many different operations you might "
"want to perform on sound data (such as mixing, adding echo, applying an "
"equalizer function, creating an artificial stereo effect), so in addition "
"you will be writing a never-ending stream of modules to perform these "
"operations.  Here's a possible structure for your package (expressed in "
"terms of a hierarchical filesystem):"
msgstr ""
"Suponha que você queira projetar uma coleção de módulos (um \"pacote\") para "
"o gerenciamento uniforme de arquivos de som. Existem muitos formatos "
"diferentes (normalmente identificados pela extensão do nome de arquivo, por "
"exemplo :file:`.wav`, :file:`.aiff`, :file:`.au`), de forma que você pode "
"precisar criar e manter uma crescente coleção de módulos de conversão entre "
"formatos. Ainda podem existir muitas operações diferentes, passíveis de "
"aplicação sobre os arquivos de som (mixagem, eco, equalização, efeito stereo "
"artificial). Logo, possivelmente você também estará escrevendo uma coleção "
"sempre crescente de módulos para aplicar estas operações. Eis uma possível "
"estrutura para o seu pacote (expressa em termos de um sistema de arquivos "
"hierárquico)::"

#: ../../tutorial/modules.rst:412
msgid ""
"sound/                          Top-level package\n"
"      __init__.py               Initialize the sound package\n"
"      formats/                  Subpackage for file format conversions\n"
"              __init__.py\n"
"              wavread.py\n"
"              wavwrite.py\n"
"              aiffread.py\n"
"              aiffwrite.py\n"
"              auread.py\n"
"              auwrite.py\n"
"              ...\n"
"      effects/                  Subpackage for sound effects\n"
"              __init__.py\n"
"              echo.py\n"
"              surround.py\n"
"              reverse.py\n"
"              ...\n"
"      filters/                  Subpackage for filters\n"
"              __init__.py\n"
"              equalizer.py\n"
"              vocoder.py\n"
"              karaoke.py\n"
"              ..."
msgstr ""
"sound/                          pacote de nível superior\n"
"      __init__.py               Inicializa o pacote de som\n"
"      formats/                  Subpacote para as conversões entre formatos "
"de arquivos\n"
"              __init__.py\n"
"              wavread.py\n"
"              wavwrite.py\n"
"              aiffread.py\n"
"              aiffwrite.py\n"
"              auread.py\n"
"              auwrite.py\n"
"              ...\n"
"      effects/                  Subpacote para efeitos de som\n"
"              __init__.py\n"
"              echo.py\n"
"              surround.py\n"
"              reverse.py\n"
"              ...\n"
"      filters/                  Subpacote para filtros\n"
"              __init__.py\n"
"              equalizer.py\n"
"              vocoder.py\n"
"              karaoke.py\n"
"              ..."

#: ../../tutorial/modules.rst:438
msgid ""
"When importing the package, Python searches through the directories on ``sys."
"path`` looking for the package subdirectory."
msgstr ""
"Ao importar esse pacote, Python busca pelo subdiretório com mesmo nome, nos "
"diretórios listados em ``sys.path``."

#: ../../tutorial/modules.rst:441
msgid ""
"The :file:`__init__.py` files are required to make Python treat directories "
"containing the file as packages (unless using a :term:`namespace package`, a "
"relatively advanced feature). This prevents directories with a common name, "
"such as ``string``, from unintentionally hiding valid modules that occur "
"later on the module search path. In the simplest case, :file:`__init__.py` "
"can just be an empty file, but it can also execute initialization code for "
"the package or set the ``__all__`` variable, described later."
msgstr ""
"Os arquivos :file:`__init__.py` são necessários para que o Python trate "
"diretórios contendo o arquivo como pacotes (a menos que se esteja usando um :"
"term:`pacote de espaço de nomes`, um recurso relativamente avançado). Isso "
"impede que diretórios com um nome comum, como ``string``, ocultem, "
"involuntariamente, módulos válidos que ocorrem posteriormente no caminho de "
"busca do módulo. No caso mais simples, :file:`__init__.py` pode ser apenas "
"um arquivo vazio, mas pode também executar código de inicialização do "
"pacote, ou configurar a variável ``__all__``, descrita mais adiante."

#: ../../tutorial/modules.rst:449
msgid ""
"Users of the package can import individual modules from the package, for "
"example::"
msgstr "Usuários do pacote podem importar módulos individuais, por exemplo::"

#: ../../tutorial/modules.rst:452
msgid "import sound.effects.echo"
msgstr "import sound.effects.echo"

#: ../../tutorial/modules.rst:454
msgid ""
"This loads the submodule :mod:`!sound.effects.echo`.  It must be referenced "
"with its full name. ::"
msgstr ""
"Isso carrega o submódulo :mod:`!sound.effects.echo`. Ele deve ser "
"referenciado com seu nome completo, como em::"

#: ../../tutorial/modules.rst:457
msgid "sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)"
msgstr "sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)"

#: ../../tutorial/modules.rst:459
msgid "An alternative way of importing the submodule is::"
msgstr "Uma maneira alternativa para a importação desse módulo é::"

#: ../../tutorial/modules.rst:461
msgid "from sound.effects import echo"
msgstr "from sound.effects import echo"

#: ../../tutorial/modules.rst:463
msgid ""
"This also loads the submodule :mod:`!echo`, and makes it available without "
"its package prefix, so it can be used as follows::"
msgstr ""
"Isso carrega o submódulo :mod:`!echo` sem necessidade de mencionar o prefixo "
"do pacote no momento da utilização, assim::"

#: ../../tutorial/modules.rst:466
msgid "echo.echofilter(input, output, delay=0.7, atten=4)"
msgstr "echo.echofilter(input, output, delay=0.7, atten=4)"

#: ../../tutorial/modules.rst:468
msgid ""
"Yet another variation is to import the desired function or variable "
"directly::"
msgstr "Também é possível importar diretamente uma única variável ou função::"

#: ../../tutorial/modules.rst:470
msgid "from sound.effects.echo import echofilter"
msgstr "from sound.effects.echo import echofilter"

#: ../../tutorial/modules.rst:472
msgid ""
"Again, this loads the submodule :mod:`!echo`, but this makes its function :"
"func:`!echofilter` directly available::"
msgstr ""
"Novamente, isso carrega o submódulo :mod:`!echo`, mas a função :func:`!"
"echofilter` está acessível diretamente sem prefixo::"

#: ../../tutorial/modules.rst:475
msgid "echofilter(input, output, delay=0.7, atten=4)"
msgstr "echofilter(input, output, delay=0.7, atten=4)"

#: ../../tutorial/modules.rst:477
msgid ""
"Note that when using ``from package import item``, the item can be either a "
"submodule (or subpackage) of the package, or some  other name defined in the "
"package, like a function, class or variable.  The ``import`` statement first "
"tests whether the item is defined in the package; if not, it assumes it is a "
"module and attempts to load it.  If it fails to find it, an :exc:"
"`ImportError` exception is raised."
msgstr ""
"Observe que ao utilizar ``from pacote import item``, o item pode ser um "
"subpacote, submódulo, classe, função ou variável. A instrução ``import`` "
"primeiro testa se o item está definido no pacote, senão presume que é um "
"módulo e tenta carregá-lo. Se falhar em encontrar o módulo, uma exceção :exc:"
"`ImportError` é levantada."

#: ../../tutorial/modules.rst:484
msgid ""
"Contrarily, when using syntax like ``import item.subitem.subsubitem``, each "
"item except for the last must be a package; the last item can be a module or "
"a package but can't be a class or function or variable defined in the "
"previous item."
msgstr ""
"Em oposição, em uma construção como ``import item.subitem.subsubitem``, cada "
"item, com exceção do último, deve ser um pacote. O último pode ser também um "
"pacote ou módulo, mas nunca uma classe, função ou variável contida em um "
"módulo."

#: ../../tutorial/modules.rst:493
msgid "Importing \\* From a Package"
msgstr "Importando \\* de um pacote"

#: ../../tutorial/modules.rst:497
msgid ""
"Now what happens when the user writes ``from sound.effects import *``?  "
"Ideally, one would hope that this somehow goes out to the filesystem, finds "
"which submodules are present in the package, and imports them all.  This "
"could take a long time and importing sub-modules might have unwanted side-"
"effects that should only happen when the sub-module is explicitly imported."
msgstr ""
"Agora, o que acontece quando um usuário escreve ``from sound.effects import "
"*`` ? Idealmente, poderia se esperar que este comando vasculhasse o sistema "
"de arquivos, encontrasse todos os submódulos presentes no pacote, e os "
"importasse. Isso poderia demorar muito e a importação de submódulos pode "
"ocasionar efeitos colaterais, que somente deveriam ocorrer quando o "
"submódulo é explicitamente importado."

#: ../../tutorial/modules.rst:503
msgid ""
"The only solution is for the package author to provide an explicit index of "
"the package.  The :keyword:`import` statement uses the following convention: "
"if a package's :file:`__init__.py` code defines a list named ``__all__``, it "
"is taken to be the list of module names that should be imported when ``from "
"package import *`` is encountered.  It is up to the package author to keep "
"this list up-to-date when a new version of the package is released.  Package "
"authors may also decide not to support it, if they don't see a use for "
"importing \\* from their package.  For example, the file :file:`sound/"
"effects/__init__.py` could contain the following code::"
msgstr ""
"A única solução é o autor do pacote fornecer um índice explícito do pacote. "
"A instrução :keyword:`import` usa a seguinte convenção: se o arquivo :file:"
"`__init__.py` do pacote define uma lista chamada ``__all__``, então esta "
"lista indica os nomes dos módulos a serem importados quando a instrução "
"``from pacote import *`` é acionada. Fica a cargo do autor do pacote manter "
"esta lista atualizada, inclusive fica a seu critério excluir inteiramente o "
"suporte a importação direta de todo o pacote através de ``from pacote import "
"*``. Por exemplo, o arquivo :file:`sounds/effects/__init__.py` poderia "
"conter apenas::"

#: ../../tutorial/modules.rst:513
msgid "__all__ = [\"echo\", \"surround\", \"reverse\"]"
msgstr "__all__ = [\"echo\", \"surround\", \"reverse\"]"

#: ../../tutorial/modules.rst:515
msgid ""
"This would mean that ``from sound.effects import *`` would import the three "
"named submodules of the :mod:`!sound.effects` package."
msgstr ""
"Isso significaria que ``from sound.effects import *`` importaria os três "
"submódulos nomeados do pacote :mod:`!sound.effects`."

#: ../../tutorial/modules.rst:518
msgid ""
"Be aware that submodules might become shadowed by locally defined names. For "
"example, if you added a ``reverse`` function to the :file:`sound/effects/"
"__init__.py` file, the ``from sound.effects import *`` would only import the "
"two submodules ``echo`` and ``surround``, but *not* the ``reverse`` "
"submodule, because it is shadowed by the locally defined ``reverse`` "
"function::"
msgstr ""
"Esteja ciente de que os submódulos podem ficar sobrepostos por nomes "
"definidos localmente. Por exemplo, se você adicionou uma função ``reverse`` "
"ao arquivo :file:`sound/effects/__init__.py`, usar ``from sound.effects "
"import *`` só importaria os dois submódulos ``echo`` e ``surround``, mas "
"*não* o submódulo ``reverse``, porque ele fica sobreposto pela função "
"``reverse`` definida localmente::"

#: ../../tutorial/modules.rst:525
msgid ""
"__all__ = [\n"
"    \"echo\",      # refers to the 'echo.py' file\n"
"    \"surround\",  # refers to the 'surround.py' file\n"
"    \"reverse\",   # !!! refers to the 'reverse' function now !!!\n"
"]\n"
"\n"
"def reverse(msg: str):  # <-- this name shadows the 'reverse.py' submodule\n"
"    return msg[::-1]    #     in the case of a 'from sound.effects import *'"
msgstr ""
"__all__ = [\n"
"    \"echo\",      # refere-se ao arquivo 'echo.py'\n"
"    \"surround\",  # refere-se ao arquivo 'surround.py'\n"
"    \"reverse\",   # !!! refere-se à função 'reverse' agora !!!\n"
"]\n"
"\n"
"def reverse(msg: str):  # <-- este nome ofusca o submódulo 'reverse.py'\n"
"    return msg[::-1]    #     no caso de uma importação 'from sound.effects "
"import *'"

#: ../../tutorial/modules.rst:534
msgid ""
"If ``__all__`` is not defined, the statement ``from sound.effects import *`` "
"does *not* import all submodules from the package :mod:`!sound.effects` into "
"the current namespace; it only ensures that the package :mod:`!sound."
"effects` has been imported (possibly running any initialization code in :"
"file:`__init__.py`) and then imports whatever names are defined in the "
"package.  This includes any names defined (and submodules explicitly loaded) "
"by :file:`__init__.py`.  It also includes any submodules of the package that "
"were explicitly loaded by previous :keyword:`import` statements.  Consider "
"this code::"
msgstr ""
"Se ``__all__`` não estiver definido, a instrução ``from sound.effects import "
"*`` não importa todos os submódulos do pacote :mod:`!sound.effects` no "
"espaço de nomes atual. Há apenas garantia que o pacote :mod:`!sound.effects` "
"foi importado (possivelmente executando qualquer código de inicialização em :"
"file:`__init__.py`) juntamente com os nomes definidos no pacote. Isso inclui "
"todo nome definido em :file:`__init__.py` bem como em qualquer submódulo "
"importado a partir deste. Também inclui quaisquer submódulos do pacote que "
"tenham sido carregados explicitamente por instruções :keyword:`import` "
"anteriores. Considere o código abaixo::"

#: ../../tutorial/modules.rst:543
msgid ""
"import sound.effects.echo\n"
"import sound.effects.surround\n"
"from sound.effects import *"
msgstr ""
"import sound.effects.echo\n"
"import sound.effects.surround\n"
"from sound.effects import *"

#: ../../tutorial/modules.rst:547
msgid ""
"In this example, the :mod:`!echo` and :mod:`!surround` modules are imported "
"in the current namespace because they are defined in the :mod:`!sound."
"effects` package when the ``from...import`` statement is executed.  (This "
"also works when ``__all__`` is defined.)"
msgstr ""
"Nesse exemplo, os módulos :mod:`!echo` e :mod:`!surround` são importados no "
"espaço de nomes atual, no momento em que a instrução ``from...import`` é "
"executada, pois estão definidos no pacote :mod:`!sound.effects`. (Isso "
"também funciona quando ``__all__`` estiver definida.)"

#: ../../tutorial/modules.rst:552
msgid ""
"Although certain modules are designed to export only names that follow "
"certain patterns when you use ``import *``, it is still considered bad "
"practice in production code."
msgstr ""
"Apesar de que certos módulos são projetados para exportar apenas nomes "
"conforme algum critério quando se faz ``import *``, ainda assim essa sintaxe "
"é considerada uma prática ruim em código de produção."

#: ../../tutorial/modules.rst:556
msgid ""
"Remember, there is nothing wrong with using ``from package import "
"specific_submodule``!  In fact, this is the recommended notation unless the "
"importing module needs to use submodules with the same name from different "
"packages."
msgstr ""
"Lembre-se, não há nada errado em usar ``from pacote import "
"submodulo_especifico``! De fato, essa é a notação recomendada, a menos que o "
"módulo importado necessite usar submódulos com o mesmo nome, de diferentes "
"pacotes."

#: ../../tutorial/modules.rst:565
msgid "Intra-package References"
msgstr "Referências em um mesmo pacote"

#: ../../tutorial/modules.rst:567
msgid ""
"When packages are structured into subpackages (as with the :mod:`!sound` "
"package in the example), you can use absolute imports to refer to submodules "
"of siblings packages.  For example, if the module :mod:`!sound.filters."
"vocoder` needs to use the :mod:`!echo` module in the :mod:`!sound.effects` "
"package, it can use ``from sound.effects import echo``."
msgstr ""
"Quando pacotes são estruturados em subpacotes (como no pacote :mod:`!sound` "
"do exemplo), pode-se usar a sintaxe de importações absolutas para se referir "
"aos submódulos de pacotes irmãos (o que na prática é uma forma de fazer um "
"import relativo, a partir da base do pacote). Por exemplo, se o módulo :mod:"
"`!sound.filters.vocoder` precisa usar o módulo :mod:`!echo` do pacote :mod:`!"
"sound.effects`, é preciso importá-lo com ``from sound.effects import echo``."

#: ../../tutorial/modules.rst:573
msgid ""
"You can also write relative imports, with the ``from module import name`` "
"form of import statement.  These imports use leading dots to indicate the "
"current and parent packages involved in the relative import.  From the :mod:"
"`!surround` module for example, you might use::"
msgstr ""
"Também é possível escrever imports relativos, com a forma ``from module "
"import name``. Esses imports usam pontos para indicar o pacote pai e o "
"atual, envolvidos no import relativo. Do módulo :mod:`!surround`, por "
"exemplo, pode-se usar::"

#: ../../tutorial/modules.rst:578
msgid ""
"from . import echo\n"
"from .. import formats\n"
"from ..filters import equalizer"
msgstr ""
"from . import echo\n"
"from .. import formats\n"
"from ..filters import equalizer"

#: ../../tutorial/modules.rst:582
msgid ""
"Note that relative imports are based on the name of the current module.  "
"Since the name of the main module is always ``\"__main__\"``, modules "
"intended for use as the main module of a Python application must always use "
"absolute imports."
msgstr ""
"Note que imports relativos são baseados no nome do módulo atual. Uma vez que "
"o nome do módulo principal é sempre ``\"__main__\"``, módulos destinados ao "
"uso como módulo principal de um aplicativo Python devem sempre usar imports "
"absolutos."

#: ../../tutorial/modules.rst:588
msgid "Packages in Multiple Directories"
msgstr "Pacotes em múltiplos diretórios"

#: ../../tutorial/modules.rst:590
msgid ""
"Packages support one more special attribute, :attr:`~module.__path__`.  This "
"is initialized to be a :term:`sequence` of strings containing the name of "
"the directory holding the package's :file:`__init__.py` before the code in "
"that file is executed.  This variable can be modified; doing so affects "
"future searches for modules and subpackages contained in the package."
msgstr ""
"Pacotes possuem mais um atributo especial, :attr:`~module.__path__`. "
"Inicializado como uma :term:`sequência` de strings contendo o nome do "
"diretório onde está o arquivo :file:`__init__.py` do pacote, antes do código "
"naquele arquivo ser executado. Esta variável pode ser modificada; isso afeta "
"a busca futura de módulos e subpacotes contidos no pacote."

#: ../../tutorial/modules.rst:597
msgid ""
"While this feature is not often needed, it can be used to extend the set of "
"modules found in a package."
msgstr ""
"Apesar de não ser muito usado, esse mecanismo permite estender o conjunto de "
"módulos encontrados em um pacote."

#: ../../tutorial/modules.rst:602
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../tutorial/modules.rst:603
msgid ""
"In fact function definitions are also 'statements' that are 'executed'; the "
"execution of a module-level function definition adds the function name to "
"the module's global namespace."
msgstr ""
"[#] Na verdade, definições de funções também são 'instruções' que são "
"'executados'; a execução da definição de uma função adiciona o nome da "
"função no espaço de nomes global do módulo."

#: ../../tutorial/modules.rst:186 ../../tutorial/modules.rst:269
#: ../../tutorial/modules.rst:350
msgid "module"
msgstr "módulo"

#: ../../tutorial/modules.rst:186
msgid "search"
msgstr "pesquisa"

#: ../../tutorial/modules.rst:186
msgid "path"
msgstr "caminho"

#: ../../tutorial/modules.rst:269
msgid "sys"
msgstr "sys"

#: ../../tutorial/modules.rst:350
msgid "builtins"
msgstr "builtins"

#: ../../tutorial/modules.rst:495
msgid "__all__"
msgstr "__all__"

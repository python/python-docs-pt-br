# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-08 14:49-0300\n"
"PO-Revision-Date: 2025-08-15 19:01+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../tutorial/classes.rst:5
msgid "Classes"
msgstr "Classes"

#: ../../tutorial/classes.rst:7
msgid ""
"Classes provide a means of bundling data and functionality together.  "
"Creating a new class creates a new *type* of object, allowing new "
"*instances* of that type to be made.  Each class instance can have "
"attributes attached to it for maintaining its state.  Class instances can "
"also have methods (defined by its class) for modifying its state."
msgstr ""
"Classes proporcionam uma forma de organizar dados e funcionalidades juntos. "
"Criar uma nova classe cria um novo \"tipo\" de objeto, permitindo que novas "
"\"instâncias\" desse tipo sejam produzidas. Cada instância da classe pode "
"ter atributos anexados a ela, para manter seu estado. Instâncias da classe "
"também podem ter métodos (definidos pela classe) para modificar seu estado."

#: ../../tutorial/classes.rst:13
msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"Em comparação com outras linguagens de programação, o mecanismo de classes "
"de Python introduz a programação orientada a objetos sem acrescentar muitas "
"novidades de sintaxe ou semântica. É uma mistura de mecanismos equivalentes "
"encontrados em C++ e Modula-3. As classes em Python oferecem todas as "
"características tradicionais da programação orientada a objetos: o mecanismo "
"de herança permite múltiplas classes base (herança múltipla), uma classe "
"derivada pode sobrescrever quaisquer métodos de uma classe ancestral, e um "
"método pode invocar outro método homônimo de uma classe ancestral. Objetos "
"podem armazenar uma quantidade arbitrária de dados de qualquer tipo. Assim "
"como acontece com os módulos, as classes fazem parte da natureza dinâmica de "
"Python: são criadas em tempo de execução, e podem ser alteradas após sua "
"criação."

#: ../../tutorial/classes.rst:23
msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are "
"*virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"Usando a terminologia de C++, todos os membros de uma classe (incluindo "
"dados) são *públicos* (veja exceção abaixo :ref:`tut-private`), e todos as "
"funções membro são *virtuais*. Como em Modula-3, não existem atalhos para "
"referenciar membros do objeto de dentro dos seus métodos: o método (função "
"definida em uma classe) é declarado com um primeiro argumento explícito "
"representando o objeto (instância da classe), que é fornecido implicitamente "
"pela chamada ao método. Como em Smalltalk, classes são objetos. Isso fornece "
"uma semântica para importar e renomear. Ao contrário de C++ ou Modula-3, "
"tipos pré-definidos podem ser utilizados como classes base para extensões "
"por herança pelo usuário. Também, como em C++, a maioria dos operadores "
"(aritméticos, indexação, etc) podem ser redefinidos por instâncias de classe."

#: ../../tutorial/classes.rst:34
msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make "
"occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"(Na falta de uma terminologia universalmente aceita para falar sobre "
"classes, ocasionalmente farei uso de termos comuns em Smalltalk ou C++. Eu "
"usaria termos de Modula-3, já que sua semântica de orientação a objetos é "
"mais próxima da de Python, mas creio que poucos leitores já ouviram falar "
"dessa linguagem.)"

#: ../../tutorial/classes.rst:43
msgid "A Word About Names and Objects"
msgstr "Uma palavra sobre nomes e objetos"

#: ../../tutorial/classes.rst:45
msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"Objetos têm individualidade, e vários nomes (em diferentes escopos) podem "
"ser vinculados a um mesmo objeto. Isso é chamado de apelidamento em outras "
"linguagens. Geralmente, esta característica não é muito apreciada, e pode "
"ser ignorada com segurança ao lidar com tipos imutáveis (números, strings, "
"tuplas). Entretanto, apelidamento pode ter um efeito surpreendente na "
"semântica do código Python envolvendo objetos mutáveis como listas, "
"dicionários e a maioria dos outros tipos. Isso pode ser usado em benefício "
"do programa, porque os apelidos funcionam de certa forma como ponteiros. Por "
"exemplo, passar um objeto como argumento é barato, pois só um ponteiro é "
"passado na implementação; e se uma função modifica um objeto passado como "
"argumento, o invocador verá a mudança --- isso elimina a necessidade de ter "
"dois mecanismos de passagem de parâmetros como em Pascal."

#: ../../tutorial/classes.rst:61
msgid "Python Scopes and Namespaces"
msgstr "Escopos e espaços de nomes do Python"

#: ../../tutorial/classes.rst:63
msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"Antes de introduzir classes, é preciso falar das regras de escopo em Python. "
"Definições de classe fazem alguns truques com espaços de nomes. Portanto, "
"primeiro é preciso entender claramente como escopos e espaços de nomes "
"funcionam, para entender o que está acontecendo. Esse conhecimento é muito "
"útil para qualquer programador Python avançado."

#: ../../tutorial/classes.rst:69
msgid "Let's begin with some definitions."
msgstr "Vamos começar com algumas definições."

#: ../../tutorial/classes.rst:71
msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense "
"the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"Um *espaço de nomes* é um mapeamento que associa nomes a objetos. "
"Atualmente, são implementados como dicionários em Python, mas isso não é "
"perceptível (a não ser pelo desempenho), e pode mudar no futuro. Exemplos de "
"espaços de nomes são: o conjunto de nomes pré-definidos (funções como :func:"
"`abs` e as exceções pré-definidas); nomes globais em um módulo; e nomes "
"locais na invocação de uma função. De certa forma, os atributos de um objeto "
"também formam um espaço de nomes. O mais importante é saber que não existe "
"nenhuma relação entre nomes em espaços de nomes distintos. Por exemplo, dois "
"módulos podem definir uma função de nome ``maximize`` sem confusão --- "
"usuários dos módulos devem prefixar a função com o nome do módulo, para "
"evitar colisão."

#: ../../tutorial/classes.rst:82
msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is "
"a module object and ``funcname`` is an attribute of it.  In this case there "
"happens to be a straightforward mapping between the module's attributes and "
"the global names defined in the module: they share the same namespace!  [#]_"
msgstr ""
"A propósito, utilizo a palavra *atributo* para qualquer nome depois de um "
"ponto. Na expressão ``z.real``, por exemplo, ``real`` é um atributo do "
"objeto ``z``. Estritamente falando, referências para nomes em módulos são "
"atributos: na expressão ``modname.funcname``, ``modname`` é um objeto módulo "
"e ``funcname`` é um de seus atributos. Neste caso, existe um mapeamento "
"direto entre os atributos de um módulo e os nomes globais definidos no "
"módulo: eles compartilham o mesmo espaço de nomes! [#]_"

#: ../../tutorial/classes.rst:90
msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`!the_answer` from the object named by "
"``modname``."
msgstr ""
"Atributos podem ser somente leitura ou para leitura e escrita. No segundo "
"caso, é possível atribuir um novo valor ao atributo. Atributos de módulos "
"são passíveis de atribuição: você pode escrever ``modname.the_answer = 42``. "
"Atributos que aceitam escrita também podem ser apagados através da "
"instrução :keyword:`del`. Por exemplo, ``del modname.the_answer`` removerá o "
"atributo :attr:`!the_answer` do objeto referenciado por ``modname``."

#: ../../tutorial/classes.rst:96
msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called :mod:"
"`__main__`, so they have their own global namespace.  (The built-in names "
"actually also live in a module; this is called :mod:`builtins`.)"
msgstr ""
"Espaços de nomes são criados em momentos diferentes e possuem diferentes "
"ciclos de vida. O espaço de nomes que contém os nomes embutidos é criado "
"quando o interpretador inicializa e nunca é removido. O espaço de nomes "
"global de um módulo é criado quando a definição do módulo é lida, e "
"normalmente duram até a terminação do interpretador. Os comandos executados "
"pela invocação do interpretador, pela leitura de um script com programa "
"principal, ou interativamente, são parte do módulo chamado :mod:`__main__`, "
"e portanto possuem seu próprio espaço de nomes. (Os nomes embutidos possuem "
"seu próprio espaço de nomes no módulo chamado :mod:`builtins`.)."

#: ../../tutorial/classes.rst:106
msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to "
"describe what actually happens.)  Of course, recursive invocations each have "
"their own local namespace."
msgstr ""
"O espaço de nomes local de uma função é criado quando a função é invocada, e "
"apagado quando a função retorna ou levanta uma exceção que não é tratada na "
"própria função. (Na verdade, uma forma melhor de descrever o que realmente "
"acontece é que o espaço de nomes local é \"esquecido\" quando a função "
"termina.) Naturalmente, cada invocação recursiva de uma função tem seu "
"próprio espaço de nomes."

#: ../../tutorial/classes.rst:112
msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified "
"reference to a name attempts to find the name in the namespace."
msgstr ""
"Um *escopo* é uma região textual de um programa Python onde um espaço de "
"nomes é diretamente acessível. Aqui, \"diretamente acessível\" significa que "
"uma referência sem um prefixo qualificador permite o acesso ao nome."

#: ../../tutorial/classes.rst:116
msgid ""
"Although scopes are determined statically, they are used dynamically. At any "
"time during execution, there are 3 or 4 nested scopes whose namespaces are "
"directly accessible:"
msgstr ""
"Ainda que escopos sejam determinados estaticamente, eles são usados "
"dinamicamente. A qualquer momento durante a execução, existem 3 ou 4 escopos "
"aninhados cujos espaços de nomes são diretamente acessíveis:"

#: ../../tutorial/classes.rst:120
msgid "the innermost scope, which is searched first, contains the local names"
msgstr "o escopo mais interno, que é acessado primeiro, contem os nomes locais"

#: ../../tutorial/classes.rst:121
msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contain non-local, but also non-global names"
msgstr ""
"os escopos das funções que envolvem a função atual, que são acessados a "
"partir do escopo mais próximo, contêm nomes não-locais, mas também não-"
"globais"

#: ../../tutorial/classes.rst:123
msgid "the next-to-last scope contains the current module's global names"
msgstr "o penúltimo escopo contém os nomes globais do módulo atual"

#: ../../tutorial/classes.rst:124
msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr ""
"e o escopo mais externo (acessado por último) contém os nomes das funções "
"embutidas e demais objetos pré-definidos do interpretador"

#: ../../tutorial/classes.rst:126
msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the next-to-last scope containing the module's global names.  To "
"rebind variables found outside of the innermost scope, the :keyword:"
"`nonlocal` statement can be used; if not declared nonlocal, those variables "
"are read-only (an attempt to write to such a variable will simply create a "
"*new* local variable in the innermost scope, leaving the identically named "
"outer variable unchanged)."
msgstr ""
"Se um nome é declarado no escopo global, então todas as referências e "
"atribuições de valores vão diretamente para o penúltimo escopo, que contém "
"os nomes globais do módulo. Para alterar variáveis declaradas fora do escopo "
"mais interno, a instrução :keyword:`nonlocal` pode ser usada; caso "
"contrário, todas essas variáveis serão apenas para leitura (a tentativa de "
"atribuir valores a essas variáveis simplesmente criará uma *nova* variável "
"local, no escopo interno, não alterando nada na variável de nome idêntico "
"fora dele)."

#: ../../tutorial/classes.rst:133
msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"Normalmente, o escopo local referencia os nomes locais da função corrente no "
"texto do programa. Fora de funções, o escopo local referencia os nomes do "
"escopo global: espaço de nomes do módulo. Definições de classes adicionam um "
"outro espaço de nomes ao escopo local."

#: ../../tutorial/classes.rst:138
msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution, "
"at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"É importante perceber que escopos são determinados estaticamente, pelo texto "
"do código-fonte: o escopo global de uma função definida em um módulo é o "
"espaço de nomes deste módulo, sem importar de onde ou por qual apelido a "
"função é invocada. Por outro lado, a busca de nomes é dinâmica, ocorrendo "
"durante a execução. Porém, a evolução da linguagem está caminhando para uma "
"resolução de nomes estática, em \"tempo de compilação\", portanto não conte "
"com a resolução dinâmica de nomes! (De fato, variáveis locais já são "
"resolvidas estaticamente.)"

#: ../../tutorial/classes.rst:146
msgid ""
"A special quirk of Python is that -- if no :keyword:`global` or :keyword:"
"`nonlocal` statement is in effect -- assignments to names always go into the "
"innermost scope. Assignments do not copy data --- they just bind names to "
"objects.  The same is true for deletions: the statement ``del x`` removes "
"the binding of ``x`` from the namespace referenced by the local scope.  In "
"fact, all operations that introduce new names use the local scope: in "
"particular, :keyword:`import` statements and function definitions bind the "
"module or function name in the local scope."
msgstr ""
"Uma peculiaridade especial do Python é que -- se nenhuma instrução :keyword:"
"`global` ou :keyword:`nonlocal` estiver em vigor -- as atribuições de nomes "
"sempre entram no escopo mais interno. As atribuições não copiam dados --- "
"elas apenas vinculam nomes aos objetos. O mesmo vale para exclusões: a "
"instrução ``del x`` remove a ligação de ``x`` do espaço de nomes "
"referenciado pelo escopo local. De fato, todas as operações que introduzem "
"novos nomes usam o escopo local: em particular, instruções :keyword:`import` "
"e definições de funções ligam o módulo ou o nome da função no escopo local."

#: ../../tutorial/classes.rst:154
msgid ""
"The :keyword:`global` statement can be used to indicate that particular "
"variables live in the global scope and should be rebound there; the :keyword:"
"`nonlocal` statement indicates that particular variables live in an "
"enclosing scope and should be rebound there."
msgstr ""
"A instrução :keyword:`global` pode ser usada para indicar que certas "
"variáveis residem no escopo global ao invés do local; a instrução :keyword:"
"`nonlocal` indica que variáveis particulares estão em um espoco mais interno "
"e devem ser recuperadas lá."

#: ../../tutorial/classes.rst:162
msgid "Scopes and Namespaces Example"
msgstr "Exemplo de escopos e espaço de nomes"

#: ../../tutorial/classes.rst:164
msgid ""
"This is an example demonstrating how to reference the different scopes and "
"namespaces, and how :keyword:`global` and :keyword:`nonlocal` affect "
"variable binding::"
msgstr ""
"Este é um exemplo que demonstra como se referir aos diferentes escopos e aos "
"espaços de nomes, e como :keyword:`global` e :keyword:`nonlocal` pode afetar "
"ligação entre as variáveis::"

#: ../../tutorial/classes.rst:168
msgid ""
"def scope_test():\n"
"    def do_local():\n"
"        spam = \"local spam\"\n"
"\n"
"    def do_nonlocal():\n"
"        nonlocal spam\n"
"        spam = \"nonlocal spam\"\n"
"\n"
"    def do_global():\n"
"        global spam\n"
"        spam = \"global spam\"\n"
"\n"
"    spam = \"test spam\"\n"
"    do_local()\n"
"    print(\"After local assignment:\", spam)\n"
"    do_nonlocal()\n"
"    print(\"After nonlocal assignment:\", spam)\n"
"    do_global()\n"
"    print(\"After global assignment:\", spam)\n"
"\n"
"scope_test()\n"
"print(\"In global scope:\", spam)"
msgstr ""
"def teste_de_escopo():\n"
"    def faz_local():\n"
"        spam = \"spam local\"\n"
"\n"
"    def faz_nonlocal():\n"
"        nonlocal spam\n"
"        spam = \"spam não-local\"\n"
"\n"
"    def faz_global():\n"
"        global spam\n"
"        spam = \"spam global\"\n"
"\n"
"    spam = \"spam teste\"\n"
"    faz_local()\n"
"    print(\"Após atribuição local:\", spam)\n"
"    faz_nonlocal()\n"
"    print(\"Após atribuição não-local:\", spam)\n"
"    faz_global()\n"
"    print(\"Após atribuição global:\", spam)\n"
"\n"
"teste_de_escopo()\n"
"print(\"No escopo global:\", spam)"

#: ../../tutorial/classes.rst:191
msgid "The output of the example code is:"
msgstr "A saída do código de exemplo é:"

#: ../../tutorial/classes.rst:193
msgid ""
"After local assignment: test spam\n"
"After nonlocal assignment: nonlocal spam\n"
"After global assignment: nonlocal spam\n"
"In global scope: global spam"
msgstr ""
"Após atribuição local: spam teste\n"
"Após atribuição não-local: spam não-local\n"
"Após atribuição global: spam não-local\n"
"No escopo global: spam global"

#: ../../tutorial/classes.rst:200
msgid ""
"Note how the *local* assignment (which is default) didn't change "
"*scope_test*\\'s binding of *spam*.  The :keyword:`nonlocal` assignment "
"changed *scope_test*\\'s binding of *spam*, and the :keyword:`global` "
"assignment changed the module-level binding."
msgstr ""
"Observe como uma atribuição *local* (que é o padrão) não altera o vínculo de "
"*teste_de_escopo* a *spam*. A instrução :keyword:`nonlocal` mudou o vínculo "
"de *teste_de_escopo* de *spam* e a atribuição :keyword:`global` alterou a "
"ligação para o nível do módulo."

#: ../../tutorial/classes.rst:205
msgid ""
"You can also see that there was no previous binding for *spam* before the :"
"keyword:`global` assignment."
msgstr ""
"Você também pode ver que não havia nenhuma ligação anterior para *spam* "
"antes da atribuição :keyword:`global`."

#: ../../tutorial/classes.rst:212
msgid "A First Look at Classes"
msgstr "Uma primeira olhada nas classes"

#: ../../tutorial/classes.rst:214
msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr ""
"Classes introduzem novidades sintáticas, três novos tipos de objetos, e "
"também alguma semântica nova."

#: ../../tutorial/classes.rst:221
msgid "Class Definition Syntax"
msgstr "Sintaxe da definição de classe"

#: ../../tutorial/classes.rst:223
msgid "The simplest form of class definition looks like this::"
msgstr "A forma mais simples de definir uma classe é::"

#: ../../tutorial/classes.rst:225
msgid ""
"class ClassName:\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"class NomeClasse:\n"
"    <instrução-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <instrução-N>"

#: ../../tutorial/classes.rst:232
msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"Definições de classe, assim como definições de função (instruções :keyword:"
"`def`), precisam ser executadas antes que tenham qualquer efeito. (Você pode "
"colocar uma definição de classe dentro do teste condicional de um :keyword:"
"`if` ou dentro de uma função.)"

#: ../../tutorial/classes.rst:236
msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful "
"--- we'll come back to this later.  The function definitions inside a class "
"normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"Na prática, as instruções dentro da definição de classe geralmente serão "
"definições de funções, mas outras instruções são permitidas, e às vezes são "
"bem úteis --- voltaremos a este tema depois. Definições de funções dentro da "
"classe normalmente têm um forma peculiar de lista de argumentos, determinada "
"pela convenção de chamada a métodos --- isso também será explicado mais "
"tarde."

#: ../../tutorial/classes.rst:242
msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new "
"function here."
msgstr ""
"Quando se inicia a definição de classe, um novo espaço de nomes é criado, e "
"usado como escopo local --- assim, todas atribuições a variáveis locais "
"ocorrem nesse espaço de nomes. Em particular, funções definidas aqui são "
"vinculadas a nomes nesse escopo."

#: ../../tutorial/classes.rst:247
msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the "
"next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header (:class:`!"
"ClassName` in the example)."
msgstr ""
"Quando uma definição de classe é finalizada normalmente (até o fim), um "
"*objeto classe* é criado. Este objeto encapsula o conteúdo do espaço de "
"nomes criado pela definição da classe; aprenderemos mais sobre objetos "
"classe na próxima seção. O escopo local (que estava vigente antes da "
"definição da classe) é reativado, e o objeto classe é vinculado ao "
"identificador da classe nesse escopo (:class:`!NomeClasse` no exemplo)."

#: ../../tutorial/classes.rst:259
msgid "Class Objects"
msgstr "Objetos classe"

#: ../../tutorial/classes.rst:261
msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"Objetos classe suportam dois tipos de operações: *referências a atributos* e "
"*instanciação*."

#: ../../tutorial/classes.rst:264
msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names "
"that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"*Referências a atributos* de classe utilizam a sintaxe padrão utilizada para "
"quaisquer referências a atributos em Python: ``obj.nome``. Nomes de "
"atributos válidos são todos os nomes presentes dentro do espaço de nomes da "
"classe, quando o objeto classe foi criado. Portanto, se a definição de "
"classe tem esta forma::"

#: ../../tutorial/classes.rst:269
msgid ""
"class MyClass:\n"
"    \"\"\"A simple example class\"\"\"\n"
"    i = 12345\n"
"\n"
"    def f(self):\n"
"        return 'hello world'"
msgstr ""
"class MinhaClasse:\n"
"    \"\"\"Um exemplo de classe simples\"\"\"\n"
"    i = 12345\n"
"\n"
"    def f(self):\n"
"        return 'olá mundo'"

#: ../../tutorial/classes.rst:276
msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`~type.__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""
"então ``MinhaClasse.i`` e ``MinhaClasse.f`` são referências a atributo "
"válidas, retornando, respectivamente, um inteiro e um objeto função. "
"Atributos de classe podem receber valores, pode-se modificar o valor de "
"``MinhaClasse.i`` num atribuição. :attr:`~type.__doc__` também é um atributo "
"válido da classe, retornando a docstring associada à classe: ``\"Um exemplo "
"de classe simples\"``."

#: ../../tutorial/classes.rst:282
msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class. "
"For example (assuming the above class)::"
msgstr ""
"Para *instanciar* uma classe, usa-se a mesma sintaxe de invocar uma função. "
"Apenas finja que o objeto classe do exemplo é uma função sem parâmetros, que "
"devolve uma nova instância da classe. Por exemplo (presumindo a classe "
"acima)::"

#: ../../tutorial/classes.rst:286 ../../tutorial/classes.rst:303
msgid "x = MyClass()"
msgstr "x = MinhaClasse()"

#: ../../tutorial/classes.rst:288
msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr ""
"cria uma nova *instância* da classe e atribui o objeto resultante à variável "
"local ``x``."

#: ../../tutorial/classes.rst:291
msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named :"
"meth:`~object.__init__`, like this::"
msgstr ""
"A operação de instanciação (\"invocar\" um objeto classe) cria um objeto "
"vazio. Muitas classes preferem criar novos objetos com um estado inicial "
"predeterminado. Para tanto, a classe pode definir um método especial "
"chamado :meth:`~object.__init__`, assim::"

#: ../../tutorial/classes.rst:296
msgid ""
"def __init__(self):\n"
"    self.data = []"
msgstr ""
"def __init__(self):\n"
"    self.data = []"

#: ../../tutorial/classes.rst:299
msgid ""
"When a class defines an :meth:`~object.__init__` method, class instantiation "
"automatically invokes :meth:`!__init__` for the newly created class "
"instance.  So in this example, a new, initialized instance can be obtained "
"by::"
msgstr ""
"Quando uma classe define um método :meth:`~object.__init__`, o processo de "
"instanciação automaticamente invoca :meth:`!__init__` sobre a instância "
"recém criada. Em nosso exemplo, uma nova instância já inicializada pode ser "
"obtida desta maneira::"

#: ../../tutorial/classes.rst:305
msgid ""
"Of course, the :meth:`~object.__init__` method may have arguments for "
"greater flexibility.  In that case, arguments given to the class "
"instantiation operator are passed on to :meth:`!__init__`.  For example, ::"
msgstr ""
"Naturalmente, o método :meth:`~object.__init__` pode ter parâmetros para "
"maior flexibilidade. Neste caso, os argumentos fornecidos na invocação da "
"classe serão passados para o método :meth:`!__init__`. Por exemplo, ::"

#: ../../tutorial/classes.rst:309
msgid ""
">>> class Complex:\n"
"...     def __init__(self, realpart, imagpart):\n"
"...         self.r = realpart\n"
"...         self.i = imagpart\n"
"...\n"
">>> x = Complex(3.0, -4.5)\n"
">>> x.r, x.i\n"
"(3.0, -4.5)"
msgstr ""
">>> class Complex:\n"
"...     def __init__(self, realpart, imagpart):\n"
"...         self.r = realpart\n"
"...         self.i = imagpart\n"
"...\n"
">>> x = Complex(3.0, -4.5)\n"
">>> x.r, x.i\n"
"(3.0, -4.5)"

#: ../../tutorial/classes.rst:322
msgid "Instance Objects"
msgstr "Objetos instância"

#: ../../tutorial/classes.rst:324
msgid ""
"Now what can we do with instance objects?  The only operations understood by "
"instance objects are attribute references.  There are two kinds of valid "
"attribute names: data attributes and methods."
msgstr ""
"Agora o que podemos fazer com objetos de instância? As únicas operações "
"compreendidas por objetos de instância são os atributos de referência. "
"Existem duas maneiras válidas para nomear atributos: atributos de dados e "
"métodos."

#: ../../tutorial/classes.rst:328
msgid ""
"*Data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`!MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""
"*Atributos de dados* correspondem a \"variáveis de instância\" em Smalltalk, "
"e a \"membros de dados\" em C++. Atributos de dados não precisam ser "
"declarados. Assim como variáveis locais, eles passam a existir na primeira "
"vez em que é feita uma atribuição. Por exemplo, se ``x`` é uma instância da :"
"class:`!MinhaClasse` criada acima, o próximo trecho de código irá exibir o "
"valor ``16``, sem deixar nenhum rastro::"

#: ../../tutorial/classes.rst:334
msgid ""
"x.counter = 1\n"
"while x.counter < 10:\n"
"    x.counter = x.counter * 2\n"
"print(x.counter)\n"
"del x.counter"
msgstr ""
"x.contador = 1\n"
"while x.contador < 10:\n"
"    x.contador = x.contador * 2\n"
"print(x.contador)\n"
"del x.contador"

#: ../../tutorial/classes.rst:340
msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object."
msgstr ""
"O outro tipo de referência a um atributo de instância é um *método*. Um "
"método é uma função que \"pertence a\" um objeto."

#: ../../tutorial/classes.rst:345
msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"Nomes de métodos válidos de uma instância dependem de sua classe. Por "
"definição, cada atributo de uma classe que é uma função corresponde a um "
"método das instâncias. Em nosso exemplo, ``x.f`` é uma referência de método "
"válida já que ``MinhaClasse.f`` é uma função, enquanto ``x.i`` não é, já que "
"``MinhaClasse.i`` não é uma função. Entretanto, ``x.f`` não é o mesmo que "
"``MinhaClasse.f``. A referência ``x.f`` acessa um objeto método e a "
"``MinhaClasse.f`` acessa um objeto função."

#: ../../tutorial/classes.rst:356
msgid "Method Objects"
msgstr "Objetos método"

#: ../../tutorial/classes.rst:358
msgid "Usually, a method is called right after it is bound::"
msgstr "Normalmente, um método é chamado imediatamente após ser referenciado::"

#: ../../tutorial/classes.rst:360
msgid "x.f()"
msgstr "x.f()"

#: ../../tutorial/classes.rst:362
msgid ""
"If ``x = MyClass()``, as above, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""

#: ../../tutorial/classes.rst:366
msgid ""
"xf = x.f\n"
"while True:\n"
"    print(xf())"
msgstr ""
"xf = x.f\n"
"while True:\n"
"    print(xf())"

#: ../../tutorial/classes.rst:370
msgid "will continue to print ``hello world`` until the end of time."
msgstr "exibirá o texto ``olá mundo`` até o mundo acabar."

#: ../../tutorial/classes.rst:372
msgid ""
"What exactly happens when a method is called?  You may have noticed that ``x."
"f()`` was called without an argument above, even though the function "
"definition for :meth:`!f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an "
"argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""
"O que ocorre precisamente quando um método é invocado? Você deve ter notado "
"que ``x.f()`` foi chamado sem nenhum argumento, porém a definição da função :"
"meth:`!f` especificava um argumento. O que aconteceu com esse argumento? "
"Certamente Python levanta uma exceção quando uma função que declara um "
"argumento é invocada sem nenhum argumento --- mesmo que o argumento não seja "
"usado no corpo da função..."

#: ../../tutorial/classes.rst:378
msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the instance object is passed as the first argument of the "
"function.  In our example, the call ``x.f()`` is exactly equivalent to "
"``MyClass.f(x)``.  In general, calling a method with a list of *n* arguments "
"is equivalent to calling the corresponding function with an argument list "
"that is created by inserting the method's instance object before the first "
"argument."
msgstr ""
"Na verdade, pode-se supor a resposta: a particularidade sobre os métodos é "
"que o objeto da instância é passado como o primeiro argumento da função. Em "
"nosso exemplo, a chamada ``x.f()`` é exatamente equivalente a ``MinhaClasse."
"f(x)``. Em geral, chamar um método com uma lista de *n* argumentos é "
"equivalente a chamar a função correspondente com uma lista de argumentos que "
"é criada inserindo o objeto de instância do método antes do primeiro "
"argumento."

#: ../../tutorial/classes.rst:385
msgid ""
"In general, methods work as follows.  When a non-data attribute of an "
"instance is referenced, the instance's class is searched. If the name "
"denotes a valid class attribute that is a function object, references to "
"both the instance object and the function object are packed into a method "
"object.  When the method object is called with an argument list, a new "
"argument list is constructed from the instance object and the argument list, "
"and the function object is called with this new argument list."
msgstr ""
"Em geral, os métodos funcionam da seguinte forma. Quando um atributo de uma "
"instância, não relacionado a dados, é referenciado, a classe da instância é "
"pesquisada. Se o nome é um atributo de classe válido que é um objeto função, "
"referências ao objeto de instância e ao objeto função serão empacotadas em "
"um objeto método. Quando o objeto método é chamado com uma lista de "
"argumentos, uma nova lista de argumentos é construída a partir do objeto de "
"instância e da lista de argumentos, e o objeto função é chamado com essa "
"nova lista de argumentos."

#: ../../tutorial/classes.rst:398
msgid "Class and Instance Variables"
msgstr "Variáveis de classe e instância"

#: ../../tutorial/classes.rst:400
msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""
"De forma geral, variáveis de instância são variáveis que indicam dados que "
"são únicos a cada instância individual, e variáveis de classe são variáveis "
"de atributos e de métodos que são comuns a todas as instâncias de uma "
"classe::"

#: ../../tutorial/classes.rst:404
msgid ""
"class Dog:\n"
"\n"
"    kind = 'canine'         # class variable shared by all instances\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name    # instance variable unique to each instance\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.kind                  # shared by all dogs\n"
"'canine'\n"
">>> e.kind                  # shared by all dogs\n"
"'canine'\n"
">>> d.name                  # unique to d\n"
"'Fido'\n"
">>> e.name                  # unique to e\n"
"'Buddy'"
msgstr ""
"class Cachorro:\n"
"\n"
"    tipo = 'canino'         # variável de classe compartilhada por todas as "
"instâncias\n"
"\n"
"    def __init__(self, nome):\n"
"        self.nome = nome    # variável de instância única para cada "
"instância\n"
"\n"
">>> d = Cachorro('Fido')\n"
">>> e = Cachorro('Buddy')\n"
">>> d.tipo                  # compartilhada por todos os cachorros\n"
"'canino'\n"
">>> e.tipo                  # compartilhada por todos os cachorros\n"
"'canino'\n"
">>> d.nome                  # exclusiva do d\n"
"'Fido'\n"
">>> e.nome                  # exclusiva do e\n"
"'Buddy'"

#: ../../tutorial/classes.rst:422
msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""
"Como vimos em :ref:`tut-object`, dados compartilhados podem causar efeitos "
"inesperados quando envolvem objetos (:term:`mutáveis <mutável>`), como "
"listas ou dicionários. Por exemplo, a lista *tricks* do código abaixo não "
"deve ser usada como variável de classe, pois assim seria compartilhada por "
"todas as instâncias de *Cachorro*::"

#: ../../tutorial/classes.rst:428
msgid ""
"class Dog:\n"
"\n"
"    tricks = []             # mistaken use of a class variable\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.add_trick('roll over')\n"
">>> e.add_trick('play dead')\n"
">>> d.tricks                # unexpectedly shared by all dogs\n"
"['roll over', 'play dead']"
msgstr ""
"class Cachorro:\n"
"\n"
"    truques = []             # uso incorreto de uma variável de classe\n"
"\n"
"    def __init__(self, nome):\n"
"        self.nome = nome\n"
"\n"
"    def adicionar_truque(self, truque):\n"
"        self.truques.append(truque)\n"
"\n"
">>> d = Cachorro('Fido')\n"
">>> e = Cachorro('Buddy')\n"
">>> d.adicionar_truque('rolar')\n"
">>> e.adicionar_truque('fingir de morto')\n"
">>> d.truques                # inesperadamente compartilhado por todos os "
"cães\n"
"['rolar', 'fingir de morto']"

#: ../../tutorial/classes.rst:445
msgid "Correct design of the class should use an instance variable instead::"
msgstr ""
"Em vez disso, o modelo correto da classe deve usar uma variável de "
"instância::"

#: ../../tutorial/classes.rst:447
msgid ""
"class Dog:\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"        self.tricks = []    # creates a new empty list for each dog\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.add_trick('roll over')\n"
">>> e.add_trick('play dead')\n"
">>> d.tricks\n"
"['roll over']\n"
">>> e.tricks\n"
"['play dead']"
msgstr ""
"class Cachorro:\n"
"\n"
"    def __init__(self, nome):\n"
"        self.nome = nome\n"
"        self.truques = []    # cria uma nova lista vazia para cada cachorro\n"
"\n"
"    def adicionar_truque(self, truque):\n"
"        self.truques.append(truque)\n"
"\n"
">>> d = Cachorro('Fido')\n"
">>> e = Cachorro('Buddy')\n"
">>> d.adicionar_truque('rolar')\n"
">>> e.adicionar_truque('fingir de morto')\n"
">>> d.truques\n"
"['rolar']\n"
">>> e.truques\n"
"['fingir de morto']"

#: ../../tutorial/classes.rst:469
msgid "Random Remarks"
msgstr "Observações aleatórias"

#: ../../tutorial/classes.rst:473
msgid ""
"If the same attribute name occurs in both an instance and in a class, then "
"attribute lookup prioritizes the instance::"
msgstr ""
"Se um mesmo nome de atributo ocorre tanto na instância quanto na classe, a "
"busca pelo atributo prioriza a instância::"

#: ../../tutorial/classes.rst:476
msgid ""
">>> class Warehouse:\n"
"...    purpose = 'storage'\n"
"...    region = 'west'\n"
"...\n"
">>> w1 = Warehouse()\n"
">>> print(w1.purpose, w1.region)\n"
"storage west\n"
">>> w2 = Warehouse()\n"
">>> w2.region = 'east'\n"
">>> print(w2.purpose, w2.region)\n"
"storage east"
msgstr ""
">>> class Armazém:\n"
"...    propósito = 'armazenar'\n"
"...    região = 'oeste'\n"
"...\n"
">>> a1 = Armazém()\n"
">>> print(a1.propósito, a1.região)\n"
"armazenar oeste\n"
">>> a2 = Armazém()\n"
">>> a2.região = 'leste'\n"
">>> print(a2.propósito, a2.região)\n"
"armazenar leste"

#: ../../tutorial/classes.rst:488
msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide "
"implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"Atributos de dados podem ser referenciados por métodos da própria instância, "
"bem como por qualquer outro usuário do objeto (também chamados \"clientes\" "
"do objeto). Em outras palavras, classes não servem para implementar tipos "
"puramente abstratos de dados. De fato, nada em Python torna possível "
"assegurar o encapsulamento de dados --- tudo é baseado em convenção. (Por "
"outro lado, a implementação de Python, escrita em C, pode esconder "
"completamente detalhes de um objeto e controlar o acesso ao objeto, se "
"necessário; isto pode ser utilizado por extensões de Python escritas em C.)"

#: ../../tutorial/classes.rst:496
msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object "
"without affecting the validity of the methods, as long as name conflicts are "
"avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"Clientes devem utilizar atributos de dados com cuidado, pois podem bagunçar "
"invariantes assumidas pelos métodos ao esbarrar em seus atributos de dados. "
"Note que clientes podem adicionar atributos de dados a suas próprias "
"instâncias, sem afetar a validade dos métodos, desde que seja evitado o "
"conflito de nomes. Novamente, uma convenção de nomenclatura poupa muita dor "
"de cabeça."

#: ../../tutorial/classes.rst:502
msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of "
"methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"Não existe atalho para referenciar atributos de dados (ou outros métodos!) "
"de dentro de um método. Isso aumenta a legibilidade dos métodos: não há como "
"confundir variáveis locais com variáveis da instância quando lemos "
"rapidamente um método."

#: ../../tutorial/classes.rst:507
msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable "
"that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"Frequentemente, o primeiro argumento de um método é chamado ``self``. Isso "
"não passa de uma convenção: o identificador ``self`` não é uma palavra "
"reservada nem possui qualquer significado especial em Python. Mas note que, "
"ao seguir essa convenção, seu código se torna legível por uma grande "
"comunidade de desenvolvedores Python e é possível que alguma *IDE* dependa "
"dessa convenção para analisar seu código."

#: ../../tutorial/classes.rst:513
msgid ""
"Any function object that is a class attribute defines a method for instances "
"of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a "
"local variable in the class is also ok.  For example::"
msgstr ""
"Qualquer objeto função que é atributo de uma classe, define um método para "
"as instâncias dessa classe. Não é necessário que a definição da função "
"esteja textualmente embutida na definição da classe. Atribuir um objeto "
"função a uma variável local da classe é válido. Por exemplo::"

#: ../../tutorial/classes.rst:518
msgid ""
"# Function defined outside the class\n"
"def f1(self, x, y):\n"
"    return min(x, x+y)\n"
"\n"
"class C:\n"
"    f = f1\n"
"\n"
"    def g(self):\n"
"        return 'hello world'\n"
"\n"
"    h = g"
msgstr ""
"# Função definida fora da classe\n"
"def f1(self, x, y):\n"
"    return min(x, x+y)\n"
"\n"
"class C:\n"
"    f = f1\n"
"\n"
"    def g(self):\n"
"        return 'olá mundo'\n"
"\n"
"    h = g"

#: ../../tutorial/classes.rst:530
msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`!C` that "
"refer to function objects, and consequently they are all methods of "
"instances of :class:`!C` --- ``h`` being exactly equivalent to ``g``.  Note "
"that this practice usually only serves to confuse the reader of a program."
msgstr ""
"Agora ``f``, ``g`` e ``h`` são todos atributos da classe :class:`!C` que "
"referenciam funções, e consequentemente são todos métodos de instâncias da "
"classe :class:`!C`, onde ``h`` é exatamente equivalente a ``g``. No entanto, "
"essa prática serve apenas para confundir o leitor do programa."

#: ../../tutorial/classes.rst:535
msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr ""
"Métodos podem invocar outros métodos usando atributos de método do argumento "
"``self``::"

#: ../../tutorial/classes.rst:538
msgid ""
"class Bag:\n"
"    def __init__(self):\n"
"        self.data = []\n"
"\n"
"    def add(self, x):\n"
"        self.data.append(x)\n"
"\n"
"    def addtwice(self, x):\n"
"        self.add(x)\n"
"        self.add(x)"
msgstr ""
"class Bolsa:\n"
"    def __init__(self):\n"
"        self.data = []\n"
"\n"
"    def adicionar(self, x):\n"
"        self.data.append(x)\n"
"\n"
"    def adicionar_em_dobro(self, x):\n"
"        self.adicionar(x)\n"
"        self.adicionar(x)"

#: ../../tutorial/classes.rst:549
msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some "
"good reasons why a method would want to reference its own class."
msgstr ""
"Métodos podem referenciar nomes globais da mesma forma que funções comuns. O "
"escopo global associado a um método é o módulo contendo sua definição na "
"classe (a classe propriamente dita nunca é usada como escopo global!). Ainda "
"que seja raro justificar o uso de dados globais em um método, há diversos "
"usos legítimos do escopo global. Por exemplo, funções e módulos importados "
"no escopo global podem ser usados por métodos, bem como as funções e classes "
"definidas no próprio escopo global. Provavelmente, a classe contendo o "
"método em questão também foi definida neste escopo global. Na próxima seção "
"veremos razões pelas quais um método pode querer referenciar sua própria "
"classe."

#: ../../tutorial/classes.rst:559
msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"Cada valor é um objeto e, portanto, tem uma *classe* (também chamada de "
"*tipo*). Ela é armazenada como ``object.__class__``."

#: ../../tutorial/classes.rst:566
msgid "Inheritance"
msgstr "Herança"

#: ../../tutorial/classes.rst:568
msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"Obviamente, uma característica da linguagem não seria digna do nome "
"\"classe\" se não suportasse herança. A sintaxe para uma classe derivada é "
"assim::"

#: ../../tutorial/classes.rst:572
msgid ""
"class DerivedClassName(BaseClassName):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"class NomeClasseDerivada(NomeClasseBase):\n"
"    <instrução-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <instrução-N>"

#: ../../tutorial/classes.rst:579
msgid ""
"The name :class:`!BaseClassName` must be defined in a namespace accessible "
"from the scope containing the derived class definition.  In place of a base "
"class name, other arbitrary expressions are also allowed.  This can be "
"useful, for example, when the base class is defined in another module::"
msgstr ""
"O identificador :class:`!BaseClassName` deve estar definido em um espaço de "
"nomes acessível do  escopo que contém a definição da classe derivada. No "
"lugar do nome da classe base, também são aceitas outras expressões. Isso é "
"muito útil, por exemplo, quando a classe base é definida em outro módulo::"

#: ../../tutorial/classes.rst:585
msgid "class DerivedClassName(modname.BaseClassName):"
msgstr "class NomeClasseDerivada(nomemódulo.NomeClasseBase):"

#: ../../tutorial/classes.rst:587
msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is "
"not found in the class, the search proceeds to look in the base class.  This "
"rule is applied recursively if the base class itself is derived from some "
"other class."
msgstr ""
"A execução de uma definição de classe derivada procede da mesma forma que a "
"de uma classe base. Quando o objeto classe é construído, a classe base é "
"lembrada. Isso é utilizado para resolver referências a atributos. Se um "
"atributo requisitado não for encontrado na classe, ele é procurado na classe "
"base. Essa regra é aplicada recursivamente se a classe base por sua vez for "
"derivada de outra."

#: ../../tutorial/classes.rst:593
msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"Não há nada de especial sobre instanciação de classes derivadas: "
"``NomeClasseDerivada()`` cria uma nova instância da classe. Referências a "
"métodos são resolvidas da seguinte forma: o atributo correspondente é "
"procurado através da cadeia de classes base, e referências a métodos são "
"válidas se essa procura produzir um objeto função."

#: ../../tutorial/classes.rst:599
msgid ""
"Derived classes may override methods of their base classes.  Because methods "
"have no special privileges when calling other methods of the same object, a "
"method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"Classes derivadas podem sobrescrever métodos das suas classes base. Uma vez "
"que métodos não possuem privilégios especiais quando invocam outros métodos "
"no mesmo objeto, um método na classe base que invoca um outro método da "
"mesma classe base pode, efetivamente, acabar invocando um método sobreposto "
"por uma classe derivada. (Para programadores C++ isso significa que todos os "
"métodos em Python são realmente ``virtuais``.)"

#: ../../tutorial/classes.rst:605
msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call ``BaseClassName."
"methodname(self, arguments)``.  This is occasionally useful to clients as "
"well.  (Note that this only works if the base class is accessible as "
"``BaseClassName`` in the global scope.)"
msgstr ""
"Um método sobrescrito em uma classe derivada, de fato, pode querer estender, "
"em vez de simplesmente substituir, o método da classe base, de mesmo nome. "
"Existe uma maneira simples de chamar diretamente o método da classe base: "
"apenas chame ``BaseClassName.methodname(self, arguments)``. Isso é "
"geralmente útil para os clientes também. (Note que isto só funciona se a "
"classe base estiver acessível como ``BaseClassName`` no escopo global)."

#: ../../tutorial/classes.rst:612
msgid "Python has two built-in functions that work with inheritance:"
msgstr "Python tem duas funções embutidas que trabalham com herança:"

#: ../../tutorial/classes.rst:614
msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)`` "
"will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""
"Use :func:`isinstance` para verificar o tipo de uma instância: "
"``isinstance(obj, int)`` será ``True`` somente se ``obj.__class__`` é a "
"classe :class:`int` ou alguma classe derivada de :class:`int`."

#: ../../tutorial/classes.rst:618
msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)`` "
"is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(float, int)`` is ``False`` since :class:`float` is not a "
"subclass of :class:`int`."
msgstr ""
"Use :func:`issubclass` para verificar herança entre classes: "
"``issubclass(bool, int)`` é ``True`` porque :class:`bool` é uma subclasse "
"de :class:`int`. Porém, ``issubclass(float, int)`` é ``False`` porque :class:"
"`float` não é uma subclasse de :class:`int`."

#: ../../tutorial/classes.rst:628
msgid "Multiple Inheritance"
msgstr "Herança múltipla"

#: ../../tutorial/classes.rst:630
msgid ""
"Python supports a form of multiple inheritance as well.  A class definition "
"with multiple base classes looks like this::"
msgstr ""
"Python também suporta uma forma de herança múltipla. Uma definição de classe "
"com várias classes bases tem esta forma::"

#: ../../tutorial/classes.rst:633
msgid ""
"class DerivedClassName(Base1, Base2, Base3):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"class NomeClasseDerivada(Base1, Base2, Base3):\n"
"    <instrução-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <instrução-N>"

#: ../../tutorial/classes.rst:640
msgid ""
"For most purposes, in the simplest cases, you can think of the search for "
"attributes inherited from a parent class as depth-first, left-to-right, not "
"searching twice in the same class where there is an overlap in the "
"hierarchy. Thus, if an attribute is not found in :class:`!DerivedClassName`, "
"it is searched for in :class:`!Base1`, then (recursively) in the base "
"classes of :class:`!Base1`, and if it was not found there, it was searched "
"for in :class:`!Base2`, and so on."
msgstr ""
"Para a maioria dos casos mais simples, pense na pesquisa de atributos "
"herdados de uma classe pai como o primeiro nível de profundidade, da "
"esquerda para a direita, não pesquisando duas vezes na mesma classe em que "
"há uma sobreposição na hierarquia. Assim, se um atributo não é encontrado "
"em :class:`!DerivedClassName`, é procurado em :class:`!Base1`, depois, "
"recursivamente, nas classes base de :class:`!Base1`, e se não for encontrado "
"lá, é pesquisado em :class:`!Base2` e assim por diante."

#: ../../tutorial/classes.rst:647
msgid ""
"In fact, it is slightly more complex than that; the method resolution order "
"changes dynamically to support cooperative calls to :func:`super`.  This "
"approach is known in some other multiple-inheritance languages as call-next-"
"method and is more powerful than the super call found in single-inheritance "
"languages."
msgstr ""
"De fato, é um pouco mais complexo que isso; a ordem de resolução de métodos "
"muda dinamicamente para suportar chamadas cooperativas para :func:`super`. "
"Essa abordagem é conhecida em outras linguagens de herança múltipla como "
"chamar-o-próximo-método, e é mais poderosa que a chamada à função super, "
"encontrada em linguagens de herança única."

#: ../../tutorial/classes.rst:653
msgid ""
"Dynamic ordering is necessary because all cases of multiple inheritance "
"exhibit one or more diamond relationships (where at least one of the parent "
"classes can be accessed through multiple paths from the bottommost class).  "
"For example, all classes inherit from :class:`object`, so any case of "
"multiple inheritance provides more than one path to reach :class:`object`.  "
"To keep the base classes from being accessed more than once, the dynamic "
"algorithm linearizes the search order in a way that preserves the left-to-"
"right ordering specified in each class, that calls each parent only once, "
"and that is monotonic (meaning that a class can be subclassed without "
"affecting the precedence order of its parents). Taken together, these "
"properties make it possible to design reliable and extensible classes with "
"multiple inheritance.  For more detail, see :ref:`python_2.3_mro`."
msgstr ""
"A ordenação dinâmica é necessária porque todos os casos de herança múltipla "
"exibem um ou mais relacionamentos de diamante (em que pelo menos uma das "
"classes bases pode ser acessada por meio de vários caminhos da classe mais "
"inferior). Por exemplo, todas as classes herdam de :class:`object`, "
"portanto, qualquer caso de herança múltipla fornece mais de um caminho para "
"alcançar :class:`object`. Para evitar que as classes base sejam acessadas "
"mais de uma vez, o algoritmo dinâmico lineariza a ordem de pesquisa, de "
"forma a preservar a ordenação da esquerda para a direita, especificada em "
"cada classe, que chama cada pai apenas uma vez, e que é monotônica "
"(significando que uma classe pode ser subclassificada sem afetar a ordem de "
"precedência de seus pais). Juntas, essas propriedades tornam possível "
"projetar classes confiáveis e extensíveis com herança múltipla. Para mais "
"detalhes, veja :ref:`python_2.3_mro`."

#: ../../tutorial/classes.rst:670
msgid "Private Variables"
msgstr "Variáveis privadas"

#: ../../tutorial/classes.rst:672
msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an "
"object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"Variáveis de instância \"privadas\", que não podem ser acessadas, exceto em "
"métodos do próprio objeto, não existem em Python. No entanto, existe uma "
"convenção que é seguida pela maioria dos programas em Python: um nome "
"prefixado com um sublinhado (por exemplo: ``_spam`` ) deve ser tratado como "
"uma parte não-pública da API (seja uma função, um método ou um atributo de "
"dados). Tais nomes devem ser considerados um detalhe de implementação e "
"sujeito a alteração sem aviso prévio."

#: ../../tutorial/classes.rst:682
msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) "
"stripped.  This mangling is done without regard to the syntactic position of "
"the identifier, as long as it occurs within the definition of a class."
msgstr ""
"Uma vez que existe um caso de uso válido para a definição de atributos "
"privados em classes (especificamente para evitar conflitos com nomes "
"definidos em subclasses), existe um suporte limitado a identificadores "
"privados em classes, chamado :dfn:`desfiguração de nomes`. Qualquer "
"identificador no formato ``__spam`` (pelo menos dois sublinhados no início, "
"e no máximo um sublinhado no final) é textualmente substituído por "
"``_classname__spam``, onde ``classname`` é o nome da classe atual com "
"sublinhado(s) iniciais omitidos. Essa desfiguração independe da posição "
"sintática do identificador, desde que ele apareça dentro da definição de uma "
"classe."

#: ../../tutorial/classes.rst:693
msgid ""
"The :ref:`private name mangling specifications <private-name-mangling>` for "
"details and special cases."
msgstr ""
"O :ref:`especificações de desfiguração de nome privado <private-name-"
"mangling>` para detalhes e casos especiais."

#: ../../tutorial/classes.rst:696
msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""
"A desfiguração de nomes é útil para que subclasses possam sobrescrever "
"métodos sem quebrar invocações de métodos dentro de outra classe. Por "
"exemplo::"

#: ../../tutorial/classes.rst:699
msgid ""
"class Mapping:\n"
"    def __init__(self, iterable):\n"
"        self.items_list = []\n"
"        self.__update(iterable)\n"
"\n"
"    def update(self, iterable):\n"
"        for item in iterable:\n"
"            self.items_list.append(item)\n"
"\n"
"    __update = update   # private copy of original update() method\n"
"\n"
"class MappingSubclass(Mapping):\n"
"\n"
"    def update(self, keys, values):\n"
"        # provides new signature for update()\n"
"        # but does not break __init__()\n"
"        for item in zip(keys, values):\n"
"            self.items_list.append(item)"
msgstr ""
"class Mapeamento:\n"
"    def __init__(self, iterável):\n"
"        self.lista_itens = []\n"
"        self.__atualizar(iterável)\n"
"\n"
"    def atualizar(self, iterável):\n"
"        for item in iterável:\n"
"            self.lista_itens.append(item)\n"
"\n"
"    __atualizar = atualizar   # cópia privada do método atualizar() "
"original\n"
"\n"
"class SubclasseMapeamento(Mapeamento):\n"
"\n"
"    def update(self, chaves, valores):\n"
"        # fornece nova assinatura para atualizar(),\n"
"        # mas não quebra __init__()\n"
"        for item in zip(chaves, valores):\n"
"            self.lista_itens.append(item)"

#: ../../tutorial/classes.rst:718
msgid ""
"The above example would work even if ``MappingSubclass`` were to introduce a "
"``__update`` identifier since it is replaced with ``_Mapping__update`` in "
"the ``Mapping`` class  and ``_MappingSubclass__update`` in the "
"``MappingSubclass`` class respectively."
msgstr ""
"O exemplo acima deve funcionar mesmo se ``SubclasseMapeamento`` introduzisse "
"um identificador ``__atualizar`` uma vez que é substituído por "
"``_Mapeamento__atualizar`` na classe ``Mapeamento`` e "
"``_SubclasseMapeamento__atualizar`` na classe ``SubclasseMapeamento``, "
"respectivamente."

#: ../../tutorial/classes.rst:723
msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered "
"private.  This can even be useful in special circumstances, such as in the "
"debugger."
msgstr ""
"Note que as regras de desfiguração de nomes foram projetadas para evitar "
"acidentes; ainda é possível acessar ou modificar uma variável que é "
"considerada privada. Isso pode ser útil em certas circunstâncias especiais, "
"como depuração de código."

#: ../../tutorial/classes.rst:727
msgid ""
"Notice that code passed to ``exec()`` or ``eval()`` does not consider the "
"classname of the invoking class to be the current class; this is similar to "
"the effect of the ``global`` statement, the effect of which is likewise "
"restricted to code that is byte-compiled together.  The same restriction "
"applies to ``getattr()``, ``setattr()`` and ``delattr()``, as well as when "
"referencing ``__dict__`` directly."
msgstr ""
"Código passado para ``exec()`` ou ``eval()`` não considera o nome da classe "
"que invocou como sendo a classe corrente; isso é semelhante ao funcionamento "
"da instrução ``global``, cujo efeito se aplica somente ao código que é "
"compilado junto. A mesma restrição se aplica às funções ``getattr()``, "
"``setattr()`` e ``delattr()``, e quando acessamos diretamente o ``__dict__`` "
"da classe."

#: ../../tutorial/classes.rst:738
msgid "Odds and Ends"
msgstr "Curiosidades e conclusões"

#: ../../tutorial/classes.rst:740
msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items. The idiomatic "
"approach is to use :mod:`dataclasses` for this purpose::"
msgstr ""
"Às vezes, é útil ter um tipo semelhante ao \"record\" de Pascal ou ao "
"\"struct\" de C, para agrupar alguns itens de dados. A maneira pythônica "
"para este fim é usar :mod:`dataclasses`::"

#: ../../tutorial/classes.rst:744
msgid ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class Employee:\n"
"    name: str\n"
"    dept: str\n"
"    salary: int"
msgstr ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class Empregado:\n"
"    nome: str\n"
"    dept: str\n"
"    salário: int"

#: ../../tutorial/classes.rst:754
msgid ""
">>> john = Employee('john', 'computer lab', 1000)\n"
">>> john.dept\n"
"'computer lab'\n"
">>> john.salary\n"
"1000"
msgstr ""
">>> joão = Empregado('joão', 'lab de computadores', 1000)\n"
">>> joão.dept\n"
"'lab de computadores'\n"
">>> joão.salário\n"
"1000"

#: ../../tutorial/classes.rst:760
msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type "
"instead.  For instance, if you have a function that formats some data from a "
"file object, you can define a class with methods :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.readline` that get the data from a string buffer "
"instead, and pass it as an argument."
msgstr ""
"Um trecho de código Python que espera um tipo de dado abstrato em "
"particular, pode receber, ao invés disso, uma classe que imita os métodos "
"que aquele tipo suporta. Por exemplo, se você tem uma função que formata "
"dados obtidos de um objeto do tipo \"arquivo\", pode definir uma classe com "
"métodos :meth:`~io.TextIOBase.read` e :meth:`~io.TextIOBase.readline` que "
"obtém os dados de um \"buffer de caracteres\" e passar como argumento."

#: ../../tutorial/classes.rst:772
msgid ""
":ref:`Instance method objects <instance-methods>` have attributes, too: :"
"attr:`m.__self__ <method.__self__>` is the instance object with the method :"
"meth:`!m`, and :attr:`m.__func__ <method.__func__>` is the :ref:`function "
"object <user-defined-funcs>` corresponding to the method."
msgstr ""
":ref:`Métodos de instância <instance-methods>` têm atributos também: :attr:"
"`m.__self__ <method.__self__>` é o objeto instância com o método :meth:`!m`, "
"e :attr:`m.__func__ <method.__func__>` é o :ref:`objeto função <user-defined-"
"funcs>` correspondente ao método."

#: ../../tutorial/classes.rst:782
msgid "Iterators"
msgstr "Iteradores"

#: ../../tutorial/classes.rst:784
msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"Você já deve ter notado que pode usar laços :keyword:`for` com a maioria das "
"coleções em Python::"

#: ../../tutorial/classes.rst:787
msgid ""
"for element in [1, 2, 3]:\n"
"    print(element)\n"
"for element in (1, 2, 3):\n"
"    print(element)\n"
"for key in {'one':1, 'two':2}:\n"
"    print(key)\n"
"for char in \"123\":\n"
"    print(char)\n"
"for line in open(\"myfile.txt\"):\n"
"    print(line, end='')"
msgstr ""
"for elemento in [1, 2, 3]:\n"
"    print(elemento)\n"
"for elemento in (1, 2, 3):\n"
"    print(elemento)\n"
"for chave in {'um':1, 'dois':2}:\n"
"    print(chave)\n"
"for char in \"123\":\n"
"    print(char)\n"
"for linha in open(\"meuarquivo.txt\"):\n"
"    print(linha, end='')"

#: ../../tutorial/classes.rst:798
msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the :keyword:"
"`for` statement calls :func:`iter` on the container object.  The function "
"returns an iterator object that defines the method :meth:`~iterator."
"__next__` which accesses elements in the container one at a time.  When "
"there are no more elements, :meth:`~iterator.__next__` raises a :exc:"
"`StopIteration` exception which tells the :keyword:`!for` loop to "
"terminate.  You can call the :meth:`~iterator.__next__` method using the :"
"func:`next` built-in function; this example shows how it all works::"
msgstr ""
"Esse estilo de acesso é claro, conciso e conveniente. O uso de iteradores "
"permeia e unifica o Python. Nos bastidores, a instrução :keyword:`for` "
"chama :func:`iter` no objeto contêiner. A função retorna um objeto iterador "
"que define o método :meth:`~iterator.__next__` que acessa elementos no "
"contêiner, um de cada vez. Quando não há mais elementos, :meth:`~iterator."
"__next__` levanta uma exceção :exc:`StopIteration` que informa ao :keyword:`!"
"for` para terminar. Você pode chamar o método :meth:`~iterator.__next__` "
"usando a função embutida :func:`next`; este exemplo mostra como tudo "
"funciona::"

#: ../../tutorial/classes.rst:807
msgid ""
">>> s = 'abc'\n"
">>> it = iter(s)\n"
">>> it\n"
"<str_iterator object at 0x10c90e650>\n"
">>> next(it)\n"
"'a'\n"
">>> next(it)\n"
"'b'\n"
">>> next(it)\n"
"'c'\n"
">>> next(it)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"    next(it)\n"
"StopIteration"
msgstr ""
">>> s = 'abc'\n"
">>> it = iter(s)\n"
">>> it\n"
"<str_iterator object at 0x10c90e650>\n"
">>> next(it)\n"
"'a'\n"
">>> next(it)\n"
"'b'\n"
">>> next(it)\n"
"'c'\n"
">>> next(it)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"    next(it)\n"
"StopIteration"

#: ../../tutorial/classes.rst:823
msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`~container.__iter__` "
"method which returns an object with a :meth:`~iterator.__next__` method.  If "
"the class defines :meth:`!__next__`, then :meth:`!__iter__` can just return "
"``self``::"
msgstr ""
"Observando o mecanismo por trás do protocolo dos iteradores, fica fácil "
"adicionar esse comportamento às suas classes. Defina um método :meth:"
"`~container.__iter__` que retorna um objeto que tenha um método :meth:"
"`~iterator.__next__`. Se uma classe já define :meth:`!__next__`, então :meth:"
"`!__iter__` pode simplesmente retornar ``self``::"

#: ../../tutorial/classes.rst:828
msgid ""
"class Reverse:\n"
"    \"\"\"Iterator for looping over a sequence backwards.\"\"\"\n"
"    def __init__(self, data):\n"
"        self.data = data\n"
"        self.index = len(data)\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        if self.index == 0:\n"
"            raise StopIteration\n"
"        self.index = self.index - 1\n"
"        return self.data[self.index]"
msgstr ""
"class Inverter:\n"
"    \"\"\"Iterador para fazer um laço em uma sequência de trás para frente."
"\"\"\"\n"
"    def __init__(self, dados):\n"
"        self.dados = dados\n"
"        self.índice = len(dados)\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        if self.índice == 0:\n"
"            raise StopIteration\n"
"        self.índice = self.índice - 1\n"
"        return self.dados[self.índice]"

#: ../../tutorial/classes.rst:845
msgid ""
">>> rev = Reverse('spam')\n"
">>> iter(rev)\n"
"<__main__.Reverse object at 0x00A1DB50>\n"
">>> for char in rev:\n"
"...     print(char)\n"
"...\n"
"m\n"
"a\n"
"p\n"
"s"
msgstr ""
">>> rev = Interverter('spam')\n"
">>> iter(rev)\n"
"<__main__.Interverter object at 0x00A1DB50>\n"
">>> for char in rev:\n"
"...     print(char)\n"
"...\n"
"m\n"
"a\n"
"p\n"
"s"

#: ../../tutorial/classes.rst:860
msgid "Generators"
msgstr "Geradores"

#: ../../tutorial/classes.rst:862
msgid ""
":term:`Generators <generator>` are a simple and powerful tool for creating "
"iterators.  They are written like regular functions but use the :keyword:"
"`yield` statement whenever they want to return data.  Each time :func:`next` "
"is called on it, the generator resumes where it left off (it remembers all "
"the data values and which statement was last executed).  An example shows "
"that generators can be trivially easy to create::"
msgstr ""
":term:`Geradores <generator>` são uma ferramenta simples e poderosa para "
"criar iteradores. São escritos como funções normais mas usam a instrução :"
"keyword:`yield` quando precisam retornar dados. Cada vez que :func:`next` é "
"chamado, o gerador volta ao ponto onde parou (lembrando  todos os valores de "
"dados e qual instrução foi executada pela última vez). Um exemplo mostra "
"como geradores podem ser trivialmente fáceis de criar::"

#: ../../tutorial/classes.rst:869
msgid ""
"def reverse(data):\n"
"    for index in range(len(data)-1, -1, -1):\n"
"        yield data[index]"
msgstr ""
"def inverter(dados):\n"
"    for índice in range(len(dados)-1, -1, -1):\n"
"        yield dados[índice]"

#: ../../tutorial/classes.rst:875
msgid ""
">>> for char in reverse('golf'):\n"
"...     print(char)\n"
"...\n"
"f\n"
"l\n"
"o\n"
"g"
msgstr ""
">>> for char in inverter('golf'):\n"
"...     print(char)\n"
"...\n"
"f\n"
"l\n"
"o\n"
"g"

#: ../../tutorial/classes.rst:883
msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`~iterator.__iter__` and :meth:`~generator."
"__next__` methods are created automatically."
msgstr ""
"Qualquer coisa que possa ser feita com geradores também pode ser feita com "
"iteradores baseados numa classe, como descrito na seção anterior. O que "
"torna geradores tão compactos é que os métodos :meth:`~iterator.__iter__` e :"
"meth:`~generator.__next__` são criados automaticamente."

#: ../../tutorial/classes.rst:888
msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like ``self."
"index`` and ``self.data``."
msgstr ""
"Outro ponto chave é que as variáveis locais e o estado da execução são "
"preservados automaticamente entre as chamadas. Isto torna a função mais "
"fácil de escrever e muito mais clara do que uma implementação usando "
"variáveis de instância como ``self.index`` e ``self.data``."

#: ../../tutorial/classes.rst:893
msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"Além disso, quando geradores terminam, eles levantam :exc:`StopIteration` "
"automaticamente. Combinados, todos estes aspectos tornam a criação de "
"iteradores tão fácil quanto escrever uma função normal."

#: ../../tutorial/classes.rst:902
msgid "Generator Expressions"
msgstr "Expressões geradoras"

#: ../../tutorial/classes.rst:904
msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax "
"similar to list comprehensions but with parentheses instead of square "
"brackets. These expressions are designed for situations where the generator "
"is used right away by an enclosing function.  Generator expressions are more "
"compact but less versatile than full generator definitions and tend to be "
"more memory friendly than equivalent list comprehensions."
msgstr ""
"Alguns geradores simples podem ser codificados, de forma sucinta, como "
"expressões, usando uma sintaxe semelhante a compreensões de lista, mas com "
"parênteses em vez de colchetes. Essas expressões são projetadas para "
"situações em que o gerador é usado imediatamente, pela função que o engloba. "
"As expressões geradoras são mais compactas, mas menos versáteis do que as "
"definições completas do gerador, e tendem a usar menos memória do que as "
"compreensões de lista equivalentes."

#: ../../tutorial/classes.rst:911
msgid "Examples::"
msgstr "Exemplos::"

#: ../../tutorial/classes.rst:913
msgid ""
">>> sum(i*i for i in range(10))                 # sum of squares\n"
"285\n"
"\n"
">>> xvec = [10, 20, 30]\n"
">>> yvec = [7, 5, 3]\n"
">>> sum(x*y for x,y in zip(xvec, yvec))         # dot product\n"
"260\n"
"\n"
">>> unique_words = set(word for line in page  for word in line.split())\n"
"\n"
">>> valedictorian = max((student.gpa, student.name) for student in "
"graduates)\n"
"\n"
">>> data = 'golf'\n"
">>> list(data[i] for i in range(len(data)-1, -1, -1))\n"
"['f', 'l', 'o', 'g']"
msgstr ""
">>> sum(i*i for i in range(10))                 # soma dos quadrados\n"
"285\n"
"\n"
">>> xvec = [10, 20, 30]\n"
">>> yvec = [7, 5, 3]\n"
">>> sum(x*y for x,y in zip(xvec, yvec))         # produto escalar\n"
"260\n"
"\n"
">>> palavras_únicas = set(palavra for linha página for palavra in linha."
"split())\n"
"\n"
">>> orador_da_turma = max((estudante.gpa, estudante.nome) for estudante in "
"graduados)\n"
"\n"
">>> dados = 'golf'\n"
">>> list(dados[i] for i in range(len(dados)-1, -1, -1))\n"
"['f', 'l', 'o', 'g']"

#: ../../tutorial/classes.rst:932
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../tutorial/classes.rst:933
msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name ``__dict__`` is an attribute but "
"not a global name. Obviously, using this violates the abstraction of "
"namespace implementation, and should be restricted to things like post-"
"mortem debuggers."
msgstr ""
"Exceto por uma coisa. Os objetos módulo têm um atributo secreto e somente "
"para leitura chamado :attr:`~object.__dict__` que retorna o dicionário usado "
"para implementar o espaço de nomes do módulo; o nome ``__dict__`` é um "
"atributo, mas não um nome global. Obviamente, usar isso viola a abstração da "
"implementação do espaço de nomes, e deve ser restrito a coisas como "
"depuradores post-mortem."

#: ../../tutorial/classes.rst:343
msgid "object"
msgstr "objeto"

#: ../../tutorial/classes.rst:343
msgid "method"
msgstr "método"

#: ../../tutorial/classes.rst:679
msgid "name"
msgstr "nome"

#: ../../tutorial/classes.rst:679
msgid "mangling"
msgstr "desfiguração"

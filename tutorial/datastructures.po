# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2019, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Raphael Mendonça, 2017
# Victor Matheus Castro <victormatheuscastro@gmail.com>, 2017
# Leticia Portella <leportella@gmail.com>, 2017
# Cauê Baasch de Souza <cauebaasch@gmail.com>, 2017
# Claudio Rogerio Carvalho Filho, 2017
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-01-01 10:14+0900\n"
"PO-Revision-Date: 2017-02-16 23:40+0000\n"
"Last-Translator: Claudio Rogerio Carvalho Filho, 2017\n"
"Language-Team: Portuguese (Brazil) (https://www.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/datastructures.rst:5
msgid "Data Structures"
msgstr "Estrutura de Dados"

#: ../../tutorial/datastructures.rst:7
msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr ""
"Esse capítulo descreve algumas coisas que você já aprendeu em detalhes e "
"adiciona algumas coisas novas também."

#: ../../tutorial/datastructures.rst:13
msgid "More on Lists"
msgstr "Mais sobre Listas"

#: ../../tutorial/datastructures.rst:15
msgid ""
"The list data type has some more methods.  Here are all of the methods of "
"list objects:"
msgstr ""
"O tipo de dado lista tem ainda mais métodos. Aqui estão apresentados todos "
"os métodos de objetos do tipo lista:"

#: ../../tutorial/datastructures.rst:22
msgid ""
"Add an item to the end of the list.  Equivalent to ``a[len(a):] = [x]``."
msgstr "Adiciona um item ao fim da lista. Equivalente a ``a[len(a):] = [x]``."

#: ../../tutorial/datastructures.rst:28
msgid ""
"Extend the list by appending all the items from the iterable.  Equivalent to "
"``a[len(a):] = iterable``."
msgstr ""
"Extende a lista adicionando todos os itens do iterável. Equivalente a "
"``a[len(a):] = iterable``."

#: ../../tutorial/datastructures.rst:35
msgid ""
"Insert an item at a given position.  The first argument is the index of the "
"element before which to insert, so ``a.insert(0, x)`` inserts at the front "
"of the list, and ``a.insert(len(a), x)`` is equivalent to ``a.append(x)``."
msgstr ""
"Insere um item em uma dada posição. O primeiro argumento é o índice do "
"elemento anterior ao qual você deseja inserir, então ``a.insert(0, x)`` "
"insere um elemento na frente da lista e ``a.insert(len(a), x)`` é "
"equivalente a ``a.append(x)``."

#: ../../tutorial/datastructures.rst:43
msgid ""
"Remove the first item from the list whose value is equal to *x*.  It raises "
"a :exc:`ValueError` if there is no such item."
msgstr ""

#: ../../tutorial/datastructures.rst:50
msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list.  (The square brackets around the *i* in the method signature denote "
"that the parameter is optional, not that you should type square brackets at "
"that position.  You will see this notation frequently in the Python Library "
"Reference.)"
msgstr ""
"Remove um item em uma dada posição na lista e o retorna. Se nenhum índice é "
"especificado, ``a.pop()`` remove e retorna o último item da lista. (O "
"colchetes na frente do *i* na demonstração do método indica que o parâmetro "
"é opcional, e não que é necessário escrever estes colchetes ao chamar o "
"método. Você verá este tipo de notação frequentemente na Biblioteca de "
"Referência Python.)"

#: ../../tutorial/datastructures.rst:60
msgid "Remove all items from the list.  Equivalent to ``del a[:]``."
msgstr "Remove todos os itens de uma lista. Equivalente a ``del a[:]``."

#: ../../tutorial/datastructures.rst:66
msgid ""
"Return zero-based index in the list of the first item whose value is equal "
"to *x*. Raises a :exc:`ValueError` if there is no such item."
msgstr ""

#: ../../tutorial/datastructures.rst:69
msgid ""
"The optional arguments *start* and *end* are interpreted as in the slice "
"notation and are used to limit the search to a particular subsequence of the "
"list.  The returned index is computed relative to the beginning of the full "
"sequence rather than the *start* argument."
msgstr ""
"Os argumentos opcionais *start* e *end* são interpretados como nas notações "
"de fatiamento e são usados para limitar a busca para uma subsequência "
"específica da lista. O índice retornado é calculado relativo ao começo da "
"sequência inteira e não referente ao argumento *start*."

#: ../../tutorial/datastructures.rst:78
msgid "Return the number of times *x* appears in the list."
msgstr "Retorna o número de vezes em que *x* aparece na lista."

#: ../../tutorial/datastructures.rst:84
msgid ""
"Sort the items of the list in place (the arguments can be used for sort "
"customization, see :func:`sorted` for their explanation)."
msgstr ""
"Ordena os itens da lista em questão (os argumentos podem ser usados para "
"customizar a ordenação, veja a função :func:`sorted` para maiores "
"explicações)."

#: ../../tutorial/datastructures.rst:91
msgid "Reverse the elements of the list in place."
msgstr "Reverse os elementos da lista em questão."

#: ../../tutorial/datastructures.rst:97
msgid "Return a shallow copy of the list.  Equivalent to ``a[:]``."
msgstr "Uma cópia simples da lista. Equivalente a ``a[:]``."

#: ../../tutorial/datastructures.rst:100
msgid "An example that uses most of the list methods::"
msgstr "Um exemplo que usa a maior parte dos métodos das listas::"

#: ../../tutorial/datastructures.rst:123
msgid ""
"You might have noticed that methods like ``insert``, ``remove`` or ``sort`` "
"that only modify the list have no return value printed -- they return the "
"default ``None``. [1]_  This is a design principle for all mutable data "
"structures in Python."
msgstr ""
"Você pode ter percebido que métodos como ``insert``, ``remove`` ou ``sort``, "
"que apenas modificam a lista, não têm valor de retorno impresso -- eles "
"retornam o ``None`` padrão. [1]_  Isto é um princípio de design para todas "
"as estruturas de dados mutáveis em Python."

#: ../../tutorial/datastructures.rst:132
msgid "Using Lists as Stacks"
msgstr "Usando listas como pilhas"

#: ../../tutorial/datastructures.rst:137
msgid ""
"The list methods make it very easy to use a list as a stack, where the last "
"element added is the first element retrieved (\"last-in, first-out\").  To "
"add an item to the top of the stack, use :meth:`append`.  To retrieve an "
"item from the top of the stack, use :meth:`pop` without an explicit index.  "
"For example::"
msgstr ""
"Os métodos de lista tornam muito fácil utilizar listas como pilhas, onde o "
"item adicionado por último é o primeiro a ser recuperado (política “último a "
"entrar, primeiro a sair”). Para adicionar um item ao topo da pilha, use :"
"meth:`append`. Para recuperar um item do topo da pilha use :meth:`pop` sem "
"nenhum índice. Por exemplo::"

#: ../../tutorial/datastructures.rst:162
msgid "Using Lists as Queues"
msgstr "Usando listas como filas"

#: ../../tutorial/datastructures.rst:166
msgid ""
"It is also possible to use a list as a queue, where the first element added "
"is the first element retrieved (\"first-in, first-out\"); however, lists are "
"not efficient for this purpose.  While appends and pops from the end of list "
"are fast, doing inserts or pops from the beginning of a list is slow "
"(because all of the other elements have to be shifted by one)."
msgstr ""
"Você também pode usar uma lista como uma fila, onde o primeiro item "
"adicionado é o primeiro a ser recuperado (política “primeiro a entrar, "
"primeiro a sair”); porém, listas não são eficientes para esta finalidade. "
"Embora *appends* e *pops* no final da lista sejam rápidos, fazer *inserts* "
"ou *pops* no início da lista é lento (porque todos os demais elementos têm "
"que ser deslocados)."

#: ../../tutorial/datastructures.rst:172
msgid ""
"To implement a queue, use :class:`collections.deque` which was designed to "
"have fast appends and pops from both ends.  For example::"
msgstr ""
"Para implementar uma fila, use a classe :class:`collections.deque` que foi\n"
"projetada para permitir *appends* e *pops* eficientes nas duas "
"extremidades.\n"
"Por exemplo::"

#: ../../tutorial/datastructures.rst:190
msgid "List Comprehensions"
msgstr "Compreensões de lista"

#: ../../tutorial/datastructures.rst:192
msgid ""
"List comprehensions provide a concise way to create lists. Common "
"applications are to make new lists where each element is the result of some "
"operations applied to each member of another sequence or iterable, or to "
"create a subsequence of those elements that satisfy a certain condition."
msgstr ""
"Uma *list comprehension* é uma maneira concisa de construir uma lista "
"preenchida. (N.d.T. literalmente, *abrangência de lista* mas no Brasil o "
"termo em inglês é muito usado; também se usa a abreviação *listcomp*)"

#: ../../tutorial/datastructures.rst:197
msgid "For example, assume we want to create a list of squares, like::"
msgstr ""
"Por exemplo, suponha que queremos criar uma lista de quadrados, assim::"

#: ../../tutorial/datastructures.rst:206
msgid ""
"Note that this creates (or overwrites) a variable named ``x`` that still "
"exists after the loop completes.  We can calculate the list of squares "
"without any side effects using::"
msgstr ""
"Note que isto cria (ou sobrescreve) uma variável chamada ``x`` que ainda "
"existe após o término do laço. Podemos calcular a lista dos quadrados sem "
"qualquer efeito colateral usando::"

#: ../../tutorial/datastructures.rst:212
msgid "or, equivalently::"
msgstr "ou, de maneira equivalente::"

#: ../../tutorial/datastructures.rst:216
msgid "which is more concise and readable."
msgstr "que é mais conciso e legível."

#: ../../tutorial/datastructures.rst:218
msgid ""
"A list comprehension consists of brackets containing an expression followed "
"by a :keyword:`!for` clause, then zero or more :keyword:`!for` or :keyword:`!"
"if` clauses.  The result will be a new list resulting from evaluating the "
"expression in the context of the :keyword:`!for` and :keyword:`!if` clauses "
"which follow it. For example, this listcomp combines the elements of two "
"lists if they are not equal::"
msgstr ""

#: ../../tutorial/datastructures.rst:228
msgid "and it's equivalent to::"
msgstr "e é equivalente a::"

#: ../../tutorial/datastructures.rst:239
msgid ""
"Note how the order of the :keyword:`for` and :keyword:`if` statements is the "
"same in both these snippets."
msgstr ""
"Uma abrangência de lista é formada por um par de colchetes contendo uma\n"
"expressão seguida de uma cláusula :keyword:`for`, e então zero ou mais\n"
"cláusulas :keyword:`for` ou :keyword:`if`. O resultado será uma lista\n"
"resultante da avaliação da expressão no contexto das cláusulas :keyword:"
"`for`\n"
"e :keyword:`if`."

#: ../../tutorial/datastructures.rst:242
msgid ""
"If the expression is a tuple (e.g. the ``(x, y)`` in the previous example), "
"it must be parenthesized. ::"
msgstr ""
"Se a expressão é uma tupla, ela deve ser inserida entre parênteses (ex., "
"``(x, y)`` no exemplo anterior). ::"

#: ../../tutorial/datastructures.rst:273
msgid ""
"List comprehensions can contain complex expressions and nested functions::"
msgstr ""
"List comprehensions podem conter expressões complexas e funções aninhadas::"

#: ../../tutorial/datastructures.rst:280
msgid "Nested List Comprehensions"
msgstr "List Comprehensions aninhadas"

#: ../../tutorial/datastructures.rst:282
msgid ""
"The initial expression in a list comprehension can be any arbitrary "
"expression, including another list comprehension."
msgstr ""
"A expressão inicial em uma list comprehension pode ser qualquer expressão "
"arbitrária, incluindo outra list comprehension."

#: ../../tutorial/datastructures.rst:285
msgid ""
"Consider the following example of a 3x4 matrix implemented as a list of 3 "
"lists of length 4::"
msgstr ""
"Observe este exemplo de uma matriz 3x4 implementada como uma lista de\n"
"3 listas de comprimento 4::"

#: ../../tutorial/datastructures.rst:294
msgid "The following list comprehension will transpose rows and columns::"
msgstr "A abrangência de listas abaixo transpõe as linhas e colunas::"

#: ../../tutorial/datastructures.rst:299
msgid ""
"As we saw in the previous section, the nested listcomp is evaluated in the "
"context of the :keyword:`for` that follows it, so this example is equivalent "
"to::"
msgstr ""
"Como vimos na seção anterior, a listcomp aninhada é computada no contexto\n"
"da cláusula :keyword:`for` seguinte, portanto o exemplo acima equivale a::"

#: ../../tutorial/datastructures.rst:310
msgid "which, in turn, is the same as::"
msgstr "e isso, por sua vez, faz o mesmo que isto::"

#: ../../tutorial/datastructures.rst:323
msgid ""
"In the real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use case::"
msgstr ""
"Na prática, você deve dar preferência a funções embutidas em vez de "
"expressões\n"
"complexas. A função :func:`zip` resolve muito bem este caso de uso::"

#: ../../tutorial/datastructures.rst:329
msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this line."
msgstr ""
"Veja :ref:`tut-unpacking-arguments` para entender o uso do asterisco neste "
"exemplo."

#: ../../tutorial/datastructures.rst:334
msgid "The :keyword:`!del` statement"
msgstr ""

#: ../../tutorial/datastructures.rst:336
msgid ""
"There is a way to remove an item from a list given its index instead of its "
"value: the :keyword:`del` statement.  This differs from the :meth:`pop` "
"method which returns a value.  The :keyword:`!del` statement can also be "
"used to remove slices from a list or clear the entire list (which we did "
"earlier by assignment of an empty list to the slice).  For example::"
msgstr ""

#: ../../tutorial/datastructures.rst:353
msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ""
":keyword:`del` também pode ser usado para remover totalmente uma variável::"

#: ../../tutorial/datastructures.rst:357
msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` later."
msgstr ""
"Referenciar a variável ``a`` depois de sua remoção constitui erro (pelo "
"menos\n"
"até que seja feita uma nova atribuição para ela). Encontraremos outros\n"
"usos para o comando :keyword:`del` mais tarde."

#: ../../tutorial/datastructures.rst:364
msgid "Tuples and Sequences"
msgstr "Tuplas e sequências"

#: ../../tutorial/datastructures.rst:366
msgid ""
"We saw that lists and strings have many common properties, such as indexing "
"and slicing operations.  They are two examples of *sequence* data types "
"(see :ref:`typesseq`).  Since Python is an evolving language, other sequence "
"data types may be added.  There is also another standard sequence data type: "
"the *tuple*."
msgstr ""
"Vimos que listas e strings têm muitas propriedades em comum, como indexação "
"e\n"
"operações de fatiamento (*slicing*). Elas são dois exemplos de *sequências*\n"
"(veja :ref:`typesseq`). Como Python é uma linguagem em evolução, outros "
"tipos\n"
"de sequências podem ser adicionados. Existe ainda um outro tipo de "
"sequência\n"
"padrão na linguagem: a tupla (*tuple*)."

#: ../../tutorial/datastructures.rst:372
msgid ""
"A tuple consists of a number of values separated by commas, for instance::"
msgstr ""
"Uma tupla consiste em uma sequência de valores separados por vírgulas::"

#: ../../tutorial/datastructures.rst:394
msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or without "
"surrounding parentheses, although often parentheses are necessary anyway (if "
"the tuple is part of a larger expression).  It is not possible to assign to "
"the individual items of a tuple, however it is possible to create tuples "
"which contain mutable objects, such as lists."
msgstr ""
"Como você pode ver no trecho acima, na saída do console as tuplas são "
"sempre\n"
"envolvidas por parênteses, assim tuplas aninhadas podem ser lidas\n"
"corretamente. Na criação, tuplas podem ser envolvidas ou não por "
"parênteses,\n"
"desde que o contexto não exija os parênteses (como no caso da tupla dentro\n"
"a uma expressão maior)."

#: ../../tutorial/datastructures.rst:401
msgid ""
"Though tuples may seem similar to lists, they are often used in different "
"situations and for different purposes. Tuples are :term:`immutable`, and "
"usually contain a heterogeneous sequence of elements that are accessed via "
"unpacking (see later in this section) or indexing (or even by attribute in "
"the case of :func:`namedtuples <collections.namedtuple>`). Lists are :term:"
"`mutable`, and their elements are usually homogeneous and are accessed by "
"iterating over the list."
msgstr ""
"Tuplas podem ser usadas de diversas formas: pares ordenados ``(x, y)``,\n"
"registros de funcionário extraídos uma base de dados, etc. Tuplas, assim "
"como\n"
"strings, são imutáveis: não é possível atribuir valores a itens individuais "
"de\n"
"uma tupla (você pode simular o mesmo efeito através de operações de "
"fatiamento\n"
"e concatenação; N.d.T. mas neste caso nunca estará modificando tuplas, "
"apenas\n"
"criando novas). Também é possível criar tuplas contendo objetos mutáveis,\n"
"como listas."

#: ../../tutorial/datastructures.rst:409
msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: the "
"syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For example::"
msgstr ""
"Um problema especial é a criação de tuplas contendo 0 ou 1 itens: a sintaxe\n"
"usa certos truques para acomodar estes casos. Tuplas vazias são construídas\n"
"por uma par de parênteses vazios; uma tupla unitária é construída por um\n"
"único valor e uma vírgula entre parênteses (não basta colocar um único "
"valor\n"
"entre parênteses). Feio, mas funciona::"

#: ../../tutorial/datastructures.rst:424
msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""
"O comando ``t = 12345, 54321, 'hello!'`` é um exemplo de *empacotamento de\n"
"tupla* (*tuple packing*): os valores ``12345``, ``54321`` e ``'bom dia!'`` "
"são\n"
"empacotados juntos em uma tupla. A operação inversa também é possível::"

#: ../../tutorial/datastructures.rst:430
msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for any "
"sequence on the right-hand side.  Sequence unpacking requires that there are "
"as many variables on the left side of the equals sign as there are elements "
"in the sequence.  Note that multiple assignment is really just a combination "
"of tuple packing and sequence unpacking."
msgstr ""
"Isso é chamado, apropriadamente, *seqüência de desempacotamento* e funciona "
"para qualquer seqüência no lado direito. O desempacotamento de sequência "
"requer que haja tantas variáveis no lado esquerdo do sinal de igual, quanto "
"existem de elementos na seqüência. Observe que a atribuição múltipla é "
"realmente apenas uma combinação de empacotamento de tupla e desempacotamento "
"de seqüência."

#: ../../tutorial/datastructures.rst:440
msgid "Sets"
msgstr "Sets (conjuntos)"

#: ../../tutorial/datastructures.rst:442
msgid ""
"Python also includes a data type for *sets*.  A set is an unordered "
"collection with no duplicate elements.  Basic uses include membership "
"testing and eliminating duplicate entries.  Set objects also support "
"mathematical operations like union, intersection, difference, and symmetric "
"difference."
msgstr ""
"Python também inclui um tipo de dados para conjuntos, chamado ``set``. Um\n"
"conjunto é uma coleção desordenada de elementos, sem elementos repetidos. "
"Usos\n"
"comuns para sets incluem a verificação eficiente da existência de objetos e "
"a\n"
"eliminação de itens duplicados. Conjuntos também suportam operações\n"
"matemáticas como união, interseção, diferença e diferença simétrica."

#: ../../tutorial/datastructures.rst:447
msgid ""
"Curly braces or the :func:`set` function can be used to create sets.  Note: "
"to create an empty set you have to use ``set()``, not ``{}``; the latter "
"creates an empty dictionary, a data structure that we discuss in the next "
"section."
msgstr ""
"Chaves ou a função :func:`set` podem ser usados para criar conjuntos. Note: "
"para criar um conjunto vazio você precisa usar ``set()``, não ``{}``; este "
"último cria um dicionário vazio, uma estrutura de dados que discutiremos na "
"próxima seção."

#: ../../tutorial/datastructures.rst:451
msgid "Here is a brief demonstration::"
msgstr "Uma pequena demonstração:"

#: ../../tutorial/datastructures.rst:476
msgid ""
"Similarly to :ref:`list comprehensions <tut-listcomps>`, set comprehensions "
"are also supported::"
msgstr ""
"Da mesma forma que :ref:`list comprehensions <tut-listcomps>`, set "
"comprehensions também são suportadas::"

#: ../../tutorial/datastructures.rst:487
msgid "Dictionaries"
msgstr "Dicionários"

#: ../../tutorial/datastructures.rst:489
msgid ""
"Another useful data type built into Python is the *dictionary* (see :ref:"
"`typesmapping`). Dictionaries are sometimes found in other languages as "
"\"associative memories\" or \"associative arrays\".  Unlike sequences, which "
"are indexed by a range of numbers, dictionaries are indexed by *keys*, which "
"can be any immutable type; strings and numbers can always be keys.  Tuples "
"can be used as keys if they contain only strings, numbers, or tuples; if a "
"tuple contains any mutable object either directly or indirectly, it cannot "
"be used as a key. You can't use lists as keys, since lists can be modified "
"in place using index assignments, slice assignments, or methods like :meth:"
"`append` and :meth:`extend`."
msgstr ""
"Outra estrutura de dados muito útil embutida em Python é o *dicionário*, "
"cujo\n"
"tipo é ``dict`` (ver :ref:`typesmapping`). Dicionários são também chamados "
"de\n"
"“memória associativa” ou “vetor associativo” em outras linguagens. "
"Diferente\n"
"de sequências que são indexadas por inteiros, dicionários são indexados por\n"
"chaves (*keys*), que podem ser de qualquer tipo imutável (como strings e\n"
"inteiros). Tuplas também podem ser chaves se contiverem apenas strings,\n"
"inteiros ou outras tuplas. Se a tupla contiver, direta ou indiretamente,\n"
"qualquer valor mutável, não poderá ser chave. Listas não podem ser usadas "
"como\n"
"chaves porque podem ser modificadas *in place* pela atribuição em índices "
"ou\n"
"fatias, e por métodos como :meth:`append` e :meth:`extend`."

#: ../../tutorial/datastructures.rst:500
msgid ""
"It is best to think of a dictionary as a set of *key: value* pairs, with the "
"requirement that the keys are unique (within one dictionary). A pair of "
"braces creates an empty dictionary: ``{}``. Placing a comma-separated list "
"of key:value pairs within the braces adds initial key:value pairs to the "
"dictionary; this is also the way dictionaries are written on output."
msgstr ""

#: ../../tutorial/datastructures.rst:506
msgid ""
"The main operations on a dictionary are storing a value with some key and "
"extracting the value given the key.  It is also possible to delete a key:"
"value pair with ``del``. If you store using a key that is already in use, "
"the old value associated with that key is forgotten.  It is an error to "
"extract a value using a non-existent key."
msgstr ""
"As principais operações em um dicionário são armazenar e recuperar valores "
"a\n"
"partir de chaves. Também é possível remover um par *chave:valor* com o "
"comando\n"
"``del``. Se você armazenar um valor utilizando uma chave já presente, o "
"antigo\n"
"valor será substituído pelo novo. Se tentar recuperar um valor usando uma "
"chave\n"
"inexistente, será gerado um erro."

#: ../../tutorial/datastructures.rst:512
msgid ""
"Performing ``list(d)`` on a dictionary returns a list of all the keys used "
"in the dictionary, in insertion order (if you want it sorted, just use "
"``sorted(d)`` instead). To check whether a single key is in the dictionary, "
"use the :keyword:`in` keyword."
msgstr ""

#: ../../tutorial/datastructures.rst:517
msgid "Here is a small example using a dictionary::"
msgstr "A seguir, um exemplo de uso do dicionário:"

#: ../../tutorial/datastructures.rst:538
msgid ""
"The :func:`dict` constructor builds dictionaries directly from sequences of "
"key-value pairs::"
msgstr ""
"O construtor :func:`dict` produz dicionários diretamente a partir de uma "
"lista\n"
"de chaves-valores, armazenadas como duplas (tuplas de 2 elementos). Quando "
"os\n"
"pares formam um padrão, uma list comprehensions pode especificar a lista de\n"
"chaves-valores de forma mais compacta. ::"

#: ../../tutorial/datastructures.rst:544
msgid ""
"In addition, dict comprehensions can be used to create dictionaries from "
"arbitrary key and value expressions::"
msgstr ""
"Além disso, os dict comprehensions podem ser usadas para criar dicionários a "
"partir de expressões arbitrárias de chave e valor::"

#: ../../tutorial/datastructures.rst:550
msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs "
"using keyword arguments::"
msgstr ""
"Quando chaves são strings simples, é mais fácil especificar os pares usando\n"
"argumentos nomeados no construtor:"

#: ../../tutorial/datastructures.rst:560
msgid "Looping Techniques"
msgstr "Técnicas de Iteração"

#: ../../tutorial/datastructures.rst:562
msgid ""
"When looping through dictionaries, the key and corresponding value can be "
"retrieved at the same time using the :meth:`items` method. ::"
msgstr ""
"Ao iterar sobre dicionários, a chave e o valor correspondente podem ser "
"obtidos simultaneamente usando o método :meth:`items`. ::"

#: ../../tutorial/datastructures.rst:572
msgid ""
"When looping through a sequence, the position index and corresponding value "
"can be retrieved at the same time using the :func:`enumerate` function. ::"
msgstr ""
"N.d.T: acrescentei esse parágrafo e o exemplo a seguir. ~LR\n"
"Ao percorrer um dicionário em um laço, a variável de iteração receberá uma "
"chave de cada vez::"

#: ../../tutorial/datastructures.rst:582
msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""
"Quando conveniente, a chave e o valor correspondente podem ser obtidos\n"
"simultaneamente com o método :meth:`iteritems`."

#: ../../tutorial/datastructures.rst:594
msgid ""
"To loop over a sequence in reverse, first specify the sequence in a forward "
"direction and then call the :func:`reversed` function. ::"
msgstr ""
"Para percorrer uma sequência em ordem inversa, chame a função :func:"
"`reversed` com a sequência na ordem original. ::"

#: ../../tutorial/datastructures.rst:606
msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""
"Para percorrer uma sequência de maneira ordenada, use a função :func:"
"`sorted`,\n"
"que retorna uma lista ordenada com os itens, mantendo a sequência original\n"
"inalterada. ::"

#: ../../tutorial/datastructures.rst:618
msgid ""
"It is sometimes tempting to change a list while you are looping over it; "
"however, it is often simpler and safer to create a new list instead. ::"
msgstr ""
"Às vezes é tentador alterar uma lista enquanto você itera sobre ela; porém, "
"costuma ser mais simples e seguro criar uma nova lista. ::"

#: ../../tutorial/datastructures.rst:635
msgid "More on Conditions"
msgstr "Mais sobre condições"

#: ../../tutorial/datastructures.rst:637
msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr ""
"As condições de controle usadas em ``while`` e ``if`` podem conter quaisquer "
"operadores, não apenas comparações."

#: ../../tutorial/datastructures.rst:640
msgid ""
"The comparison operators ``in`` and ``not in`` check whether a value occurs "
"(does not occur) in a sequence.  The operators ``is`` and ``is not`` compare "
"whether two objects are really the same object; this only matters for "
"mutable objects like lists.  All comparison operators have the same "
"priority, which is lower than that of all numerical operators."
msgstr ""
"Os operadores de comparação ``in`` e ``not in`` verificam se um valor "
"ocorre\n"
"(ou não ocorre) em uma dada sequência. Os operadores ``is`` e ``is not``\n"
"comparam se dois objetos são na verdade o mesmo objeto; isto só é relevante "
"no\n"
"contexto de objetos mutáveis, como listas. Todos os operadores de "
"comparação\n"
"possuem a mesma precedência, que é menor do que a prioridade de todos os\n"
"operadores numéricos."

#: ../../tutorial/datastructures.rst:646
msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether ``a`` "
"is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""
"Comparações podem ser encadeadas: Por exemplo ``a < b == c`` testa se ``a`` "
"é menor\n"
"que ``b`` e também se ``b`` é igual a ``c``."

#: ../../tutorial/datastructures.rst:649
msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and ``or``, "
"and the outcome of a comparison (or of any other Boolean expression) may be "
"negated with ``not``.  These have lower priorities than comparison "
"operators; between them, ``not`` has the highest priority and ``or`` the "
"lowest, so that ``A and not B or C`` is equivalent to ``(A and (not B)) or "
"C``. As always, parentheses can be used to express the desired composition."
msgstr ""
"Comparações podem ser combinadas através de operadores booleanos ``and`` e\n"
"``or``, e o resultado de uma comparação (ou de qualquer outra expressão), "
"pode\n"
"ter seu valor booleano negado através de ``not``. Estes possuem menor\n"
"prioridade que os demais operadores de comparação. Entre eles, ``not`` é o "
"de\n"
"maior prioridade e ``or`` o de menor. Dessa forma, a condição ``A and not B "
"or\n"
"C`` é equivalente a ``(A and (not B)) or C``. Naturalmente, parênteses "
"podem\n"
"ser usados para expressar o agrupamento desejado."

#: ../../tutorial/datastructures.rst:656
msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and evaluation "
"stops as soon as the outcome is determined.  For example, if ``A`` and ``C`` "
"are true but ``B`` is false, ``A and B and C`` does not evaluate the "
"expression ``C``.  When used as a general value and not as a Boolean, the "
"return value of a short-circuit operator is the last evaluated argument."
msgstr ""
"Os operadores booleanos ``and`` e ``or`` são operadores *short-circuit*: "
"seus\n"
"argumentos são avaliados da esquerda para a direita, e a avaliação para "
"quando\n"
"o resultado é determinado. Por exemplo, se ``A`` e ``C`` são expressões\n"
"verdadeiras, mas ``B`` é falsa, então ``A and B and C`` não chega a avaliar "
"a\n"
"expressão ``C``. Em geral, quando usado sobre valores genéricos e não\n"
"como booleanos, o valor do resultado de um operador atalho é o último valor\n"
"avaliado na expressão."

#: ../../tutorial/datastructures.rst:663
msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr ""
"É possível atribuir o resultado de uma comparação ou outra expressão "
"booleana\n"
"para uma variável. Por exemplo::"

#: ../../tutorial/datastructures.rst:671
msgid ""
"Note that in Python, unlike C, assignment cannot occur inside expressions. C "
"programmers may grumble about this, but it avoids a common class of problems "
"encountered in C programs: typing ``=`` in an expression when ``==`` was "
"intended."
msgstr ""
"Observe que em Python, diferente de C, atribuição não pode ocorrer dentro\n"
"de uma expressão. Programadores C podem resmungar, mas isso evita toda uma\n"
"classe de problemas frequentemente encontrados em programas C: digitar "
"``=``\n"
"numa expressão quando a intenção era ``==``."

#: ../../tutorial/datastructures.rst:680
msgid "Comparing Sequences and Other Types"
msgstr "Comparando sequências e outros tipos"

#: ../../tutorial/datastructures.rst:682
msgid ""
"Sequence objects may be compared to other objects with the same sequence "
"type. The comparison uses *lexicographical* ordering: first the first two "
"items are compared, and if they differ this determines the outcome of the "
"comparison; if they are equal, the next two items are compared, and so on, "
"until either sequence is exhausted. If two items to be compared are "
"themselves sequences of the same type, the lexicographical comparison is "
"carried out recursively.  If all items of two sequences compare equal, the "
"sequences are considered equal. If one sequence is an initial sub-sequence "
"of the other, the shorter sequence is the smaller (lesser) one.  "
"Lexicographical ordering for strings uses the Unicode code point number to "
"order individual characters.  Some examples of comparisons between sequences "
"of the same type::"
msgstr ""

#: ../../tutorial/datastructures.rst:702
msgid ""
"Note that comparing objects of different types with ``<`` or ``>`` is legal "
"provided that the objects have appropriate comparison methods.  For example, "
"mixed numeric types are compared according to their numeric value, so 0 "
"equals 0.0, etc.  Otherwise, rather than providing an arbitrary ordering, "
"the interpreter will raise a :exc:`TypeError` exception."
msgstr ""
"Note que comparar objetos de tipos diferentes com ``<`` ou ``>`` é permitido "
"desde que os objetos possuam os métodos de comparação apropriados.  Por "
"exemplo, tipos numéricos mistos são comparados de acordo com os seus valores "
"numéricos, portanto 0 é igual a 0.0, etc.  Em caso contrário, ao invés de "
"fornecer uma ordenação arbitrária, o interpretador levantará um :exc:"
"`TypeError`."

#: ../../tutorial/datastructures.rst:710
msgid "Footnotes"
msgstr "Notas de Rodapé"

#: ../../tutorial/datastructures.rst:711
msgid ""
"Other languages may return the mutated object, which allows method chaining, "
"such as ``d->insert(\"a\")->remove(\"b\")->sort();``."
msgstr ""
"Outras linguagens podem retornar o objeto modificado, o que permite "
"encadeamento de métodos, como ``d->insert(\"a\")->remove(\"b\")->sort();``."

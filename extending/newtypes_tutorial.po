# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Rainer Terroso, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-23 14:12+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../extending/newtypes_tutorial.rst:7
msgid "Defining Extension Types: Tutorial"
msgstr "Definindo Tipos de Extensão: Tutorial"

#: ../../extending/newtypes_tutorial.rst:14
msgid ""
"Python allows the writer of a C extension module to define new types that "
"can be manipulated from Python code, much like the built-in :class:`str` "
"and :class:`list` types.  The code for all extension types follows a "
"pattern, but there are some details that you need to understand before you "
"can get started.  This document is a gentle introduction to the topic."
msgstr ""
"O Python permite que o desenvolvedor de um módulo de extensão em C defina "
"novos tipos que podem ser manipulados a partir do código Python, da mesma "
"forma que os tipos embutidos :class:`str` e :class:`list`. O código para de "
"todos tipos de extensão segue um padrão, mas há alguns detalhes que você "
"precisa entender antes de começar. Este documento é uma introdução suave ao "
"tópico."

#: ../../extending/newtypes_tutorial.rst:24
msgid "The Basics"
msgstr "O básico"

#: ../../extending/newtypes_tutorial.rst:26
msgid ""
"The :term:`CPython` runtime sees all Python objects as variables of type :c:"
"expr:`PyObject*`, which serves as a \"base type\" for all Python objects. "
"The :c:type:`PyObject` structure itself only contains the object's :term:"
"`reference count` and a pointer to the object's \"type object\". This is "
"where the action is; the type object determines which (C) functions get "
"called by the interpreter when, for instance, an attribute gets looked up on "
"an object, a method called, or it is multiplied by another object.  These C "
"functions are called \"type methods\"."
msgstr ""
"O tempo de execução do :term:`CPython` trata todos os objetos Python como "
"variáveis do tipo :c:expr:`PyObject*`, que funciona como um “tipo base” para "
"todos os objetos Python. A estrutura :c:type:`PyObject` em si contém apenas "
"a :term:`contagem de referências` do objeto e um ponteiro para o “objeto de "
"tipo” correspondente. É nesse objeto de tipo que tudo acontece: ele "
"determina quais funções em C o interpretador chama quando, por exemplo, um "
"atributo é acessado em um objeto, um método é chamado ou o objeto é "
"multiplicado por outro. Essas funções em C são chamadas de “métodos de tipo”."

#: ../../extending/newtypes_tutorial.rst:35
msgid ""
"So, if you want to define a new extension type, you need to create a new "
"type object."
msgstr ""
"Então, se você quiser definir um novo tipo de extensão, você precisa criar "
"um novo objeto de tipo."

#: ../../extending/newtypes_tutorial.rst:38
msgid ""
"This sort of thing can only be explained by example, so here's a minimal, "
"but complete, module that defines a new type named :class:`!Custom` inside a "
"C extension module :mod:`!custom`:"
msgstr ""
"Esse tipo de coisa só pode ser explicado com exemplo, então aqui está um "
"módulo mínimo, mas completo, que define um novo tipo nomeado :class:`!"
"Custom` dentro de um módulo de extensão C :mod:`!custom`:"

#: ../../extending/newtypes_tutorial.rst:43
msgid ""
"What we're showing here is the traditional way of defining *static* "
"extension types.  It should be adequate for most uses.  The C API also "
"allows defining heap-allocated extension types using the :c:func:"
"`PyType_FromSpec` function, which isn't covered in this tutorial."
msgstr ""
"O que estamos mostrando aqui é a maneira tradicional de definir tipos de "
"extensão *estáticos*. Deve ser adequada para a maioria dos usos. A API C "
"também permite definir tipos de extensão alocados em heap usando a função :c:"
"func:`PyType_FromSpec`, que não é abordada neste tutorial."

#: ../../extending/newtypes_tutorial.rst:48
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    /* Type-specific fields go here. */\n"
"} CustomObject;\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT,\n"
"    .tp_new = PyType_GenericNew,\n"
"};\n"
"\n"
"static int\n"
"custom_module_exec(PyObject *m)\n"
"{\n"
"    if (PyType_Ready(&CustomType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot custom_module_slots[] = {\n"
"    {Py_mod_exec, custom_module_exec},\n"
"    // Just use this while using static types\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static PyModuleDef custom_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = 0,\n"
"    .m_slots = custom_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom(void)\n"
"{\n"
"    return PyModuleDef_Init(&custom_module);\n"
"}\n"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    /* Campos específico do tipo vão aqui. */\n"
"} CustomObject;\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT,\n"
"    .tp_new = PyType_GenericNew,\n"
"};\n"
"\n"
"static int\n"
"custom_module_exec(PyObject *m)\n"
"{\n"
"    if (PyType_Ready(&CustomType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot custom_module_slots[] = {\n"
"    {Py_mod_exec, custom_module_exec},\n"
"    // Só use isso quando estiver usando tipos estáticos\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static PyModuleDef custom_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = 0,\n"
"    .m_slots = custom_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom(void)\n"
"{\n"
"    return PyModuleDef_Init(&custom_module);\n"
"}\n"

#: ../../extending/newtypes_tutorial.rst:50
msgid ""
"Now that's quite a bit to take in at once, but hopefully bits will seem "
"familiar from the previous chapter.  This file defines three things:"
msgstr ""
"Isso é bastante informação para assimilar de uma só vez, mas algumas partes "
"devem parecer familiares pelo que foi visto no capítulo anterior. Este "
"arquivo define três elementos:"

#: ../../extending/newtypes_tutorial.rst:53
msgid ""
"What a :class:`!Custom` **object** contains: this is the ``CustomObject`` "
"struct, which is allocated once for each :class:`!Custom` instance."
msgstr ""
"O que um **objeto** :class:`!Custom` contém: esta é uma estrutura "
"``CustomObject``, alocada uma vez para cada instância de :class:`!Custom`."

#: ../../extending/newtypes_tutorial.rst:55
msgid ""
"How the :class:`!Custom` **type** behaves: this is the ``CustomType`` "
"struct, which defines a set of flags and function pointers that the "
"interpreter inspects when specific operations are requested."
msgstr ""
"Como o **tipo** :class:`!Custom` se comporta: esta é a estrutura "
"``CustomType``, que define um conjunto de sinalizadores e ponteiros de "
"função que o interpretador inspeciona quando operações específicas são "
"solicitadas."

#: ../../extending/newtypes_tutorial.rst:58
msgid ""
"How to define and execute the :mod:`!custom` module: this is the "
"``PyInit_custom`` function and the associated ``custom_module`` struct for "
"defining the module, and the ``custom_module_exec`` function to set up a "
"fresh module object."
msgstr ""
"Como definir e executar o módulo :mod:`!custom`: esta é a função "
"``PyInit_custom`` e a estrutura associada ``custom_module`` para definir o "
"módulo, e a função ``custom_module_exec`` para configurar um novo objeto de "
"módulo."

#: ../../extending/newtypes_tutorial.rst:63
msgid "The first bit is::"
msgstr "O primeiro bit é ::"

#: ../../extending/newtypes_tutorial.rst:65
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} CustomObject;"
msgstr ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} CustomObject;"

#: ../../extending/newtypes_tutorial.rst:69
msgid ""
"This is what a Custom object will contain.  ``PyObject_HEAD`` is mandatory "
"at the start of each object struct and defines a field called ``ob_base`` of "
"type :c:type:`PyObject`, containing a pointer to a type object and a "
"reference count (these can be accessed using the macros :c:macro:`Py_TYPE` "
"and :c:macro:`Py_REFCNT` respectively).  The reason for the macro is to "
"abstract away the layout and to enable additional fields in :ref:`debug "
"builds <debug-build>`."
msgstr ""
"Isto é o que um objeto Custom conterá. ``PyObject_HEAD`` é obrigatório no "
"início de cada estrutura de objeto e define um campo chamado ``ob_base`` do "
"tipo :c:type:`PyObject`, contendo um ponteiro para um objeto de tipo e uma "
"contagem de referências (esses podem ser acessados usando os macros :c:macro:"
"`Py_TYPE` e :c:macro:`Py_REFCNT`, respectivamente). O objetivo do macro é "
"abstrair o layout e permitir campos adicionais em :ref:`construções de "
"depuração <debug-build>`."

#: ../../extending/newtypes_tutorial.rst:78
msgid ""
"There is no semicolon above after the :c:macro:`PyObject_HEAD` macro. Be "
"wary of adding one by accident: some compilers will complain."
msgstr ""
"Não há ponto e vírgula acima após o macro :c:macro:`PyObject_HEAD`. Tenha "
"cuidado para não adicionar um por engano: alguns compiladores podem emitir "
"erros."

#: ../../extending/newtypes_tutorial.rst:81
msgid ""
"Of course, objects generally store additional data besides the standard "
"``PyObject_HEAD`` boilerplate; for example, here is the definition for "
"standard Python floats::"
msgstr ""
"Obviamente, objetos geralmente armazenam dados adicionais além do padrão "
"``PyObject_HEAD`` boilerplate; por exemplo, aqui está a definição do padrão "
"Python floats::"

#: ../../extending/newtypes_tutorial.rst:85
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    double ob_fval;\n"
"} PyFloatObject;"
msgstr ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    double ob_fval;\n"
"} PyFloatObject;"

#: ../../extending/newtypes_tutorial.rst:90
msgid "The second bit is the definition of the type object. ::"
msgstr "O segundo bit é a definição do objeto de tipo. ::"

#: ../../extending/newtypes_tutorial.rst:92
msgid ""
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT,\n"
"    .tp_new = PyType_GenericNew,\n"
"};"
msgstr ""
"estático PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objeto\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT,\n"
"    .tp_new = PyType_GenericNew,\n"
"};"

#: ../../extending/newtypes_tutorial.rst:103
msgid ""
"We recommend using C99-style designated initializers as above, to avoid "
"listing all the :c:type:`PyTypeObject` fields that you don't care about and "
"also to avoid caring about the fields' declaration order."
msgstr ""
"Recomendamos usar inicializadores nomeados no estilo C99, como mostrado "
"acima, para evitar listar todos os campos de :c:type:`PyTypeObject` com os "
"quais você não precisa se preocupar e também para não depender da ordem de "
"declaração desses campos"

#: ../../extending/newtypes_tutorial.rst:107
msgid ""
"The actual definition of :c:type:`PyTypeObject` in :file:`object.h` has many "
"more :ref:`fields <type-structs>` than the definition above.  The remaining "
"fields will be filled with zeros by the C compiler, and it's common practice "
"to not specify them explicitly unless you need them."
msgstr ""
"A definição real de :c:type:`PyTypeObject` no :file:`object.h` possui muito "
"mais :ref:`campos <type-structs>` do que a definição acima. Os campos "
"restantes serão preenchidos com zeros pelo compilador C, e é prática comum "
"não especificá-los explicitamente, a menos que sejam necessários."

#: ../../extending/newtypes_tutorial.rst:112
msgid "We're going to pick it apart, one field at a time::"
msgstr "Vamos separá-lo, um campo de cada vez ::"

#: ../../extending/newtypes_tutorial.rst:114
msgid ".ob_base = PyVarObject_HEAD_INIT(NULL, 0)"
msgstr ".ob_base = PyVarObject_HEAD_INIT(NULL, 0)"

#: ../../extending/newtypes_tutorial.rst:116
msgid ""
"This line is mandatory boilerplate to initialize the ``ob_base`` field "
"mentioned above. ::"
msgstr ""
"Essa linha é um boilerplate obrigatório para inicializar o campo ``ob_base`` "
"mencionado acima. ::"

#: ../../extending/newtypes_tutorial.rst:119
msgid ".tp_name = \"custom.Custom\","
msgstr ".tp_name = \"custom.Custom\","

#: ../../extending/newtypes_tutorial.rst:121
msgid ""
"The name of our type.  This will appear in the default textual "
"representation of our objects and in some error messages, for example:"
msgstr ""
"O nome do nosso tipo.  Ele aparecerá na representação textual padrão do "
"nosso objeto e em algumas mensagens erro, por exemplo:"

#: ../../extending/newtypes_tutorial.rst:124
msgid ""
">>> \"\" + custom.Custom()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: can only concatenate str (not \"custom.Custom\") to str"
msgstr ""
">>> \"\" + custom.Custom()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: can only concatenate str (not \"custom.Custom\") to str"

#: ../../extending/newtypes_tutorial.rst:131
msgid ""
"Note that the name is a dotted name that includes both the module name and "
"the name of the type within the module. The module in this case is :mod:`!"
"custom` and the type is :class:`!Custom`, so we set the type name to :class:"
"`!custom.Custom`. Using the real dotted import path is important to make "
"your type compatible with the :mod:`pydoc` and :mod:`pickle` modules. ::"
msgstr ""
"Observe que o nome é um nome pontilhado que inclui o nome módulo e o nome do "
"tipo dentro do módulo. O módulo, neste caso, é :mod:`!custom` e o tipo é :"
"class:`!Custom`, portanto, definimos o nome do tipo como :class:`!custom."
"Custom`. O uso do pontilhado real caminho de importação é importante para "
"tornar seu tipo compatível com o :mod:`pydoc` e os módulos :mod:`pickle`. ::"

#: ../../extending/newtypes_tutorial.rst:137
msgid ""
".tp_basicsize = sizeof(CustomObject),\n"
".tp_itemsize = 0,"
msgstr ""
".tp_basicsize = sizeof(CustomObject),\n"
".tp_itemsize = 0,"

#: ../../extending/newtypes_tutorial.rst:140
msgid ""
"This is so that Python knows how much memory to allocate when creating new :"
"class:`!Custom` instances.  :c:member:`~PyTypeObject.tp_itemsize` is only "
"used for variable-sized objects and should otherwise be zero."
msgstr ""
"Isso serve para que o Python saiba quanta memória deve ser alocada ao criar "
"novas instâncias do :class:`!Custom`. O :c:member:`~PyTypeObject."
"tp_itemsize` é usado somente para objeto de tamanho variável e, caso "
"contrário, deve ser zero."

#: ../../extending/newtypes_tutorial.rst:146
msgid ""
"If you want your type to be subclassable from Python, and your type has the "
"same :c:member:`~PyTypeObject.tp_basicsize` as its base type, you may have "
"problems with multiple inheritance.  A Python subclass of your type will "
"have to list your type first in its :attr:`~type.__bases__`, or else it will "
"not be able to call your type's :meth:`~object.__new__` method without "
"getting an error.  You can avoid this problem by ensuring that your type has "
"a larger value for :c:member:`~PyTypeObject.tp_basicsize` than its base type "
"does.  Most of the time, this will be true anyway, because either your base "
"type will be :class:`object`, or else you will be adding data members to "
"your base type, and therefore increasing its size."
msgstr ""
"Se você quiser que seu tipo possa ser subclassificado a partir do Python, e "
"seu tipo tiver o mesmo :c:member:`~PyTypeObject.tp_basicsize` que seu tipo "
"base, você poderá ter problemas com herança múltipla. Uma subclasse Python "
"do seu tipo terá de listar o seu tipo primeiro em :attr:`~type.__bases__`, "
"caso contrário ela não conseguirá chamar o método :meth:`~object.__new__` do "
"seu tipo sem gerar um erro. Você pode evitar esse problema garantindo que "
"seu tipo tenha um valor de :c:member:`~PyTypeObject.tp_basicsize` maior que "
"o do tipo base. Na maior parte do tempo, isso já será verdadeiro, pois ou o "
"tipo base será :class:`object`, ou você estará adicionando membros de dados "
"ao seu tipo base e, portanto, aumentando seu tamanho."

#: ../../extending/newtypes_tutorial.rst:156
msgid "We set the class flags to :c:macro:`Py_TPFLAGS_DEFAULT`. ::"
msgstr ""
"Definimos os sinalizadores da classe como :c:macro:`Py_TPFLAGS_DEFAULT`. ::"

#: ../../extending/newtypes_tutorial.rst:158
msgid ".tp_flags = Py_TPFLAGS_DEFAULT,"
msgstr ".tp_flags = Py_TPFLAGS_DEFAULT,"

#: ../../extending/newtypes_tutorial.rst:160
msgid ""
"All types should include this constant in their flags.  It enables all of "
"the members defined until at least Python 3.3.  If you need further members, "
"you will need to OR the corresponding flags."
msgstr ""
"Todos os tipos devem incluir essa constante em seus sinalizadores. Ela "
"habilita todos os membros definidos até pelo menos o Python 3.3. Se você "
"precisar de membros adicionais, será necessário fazer um OR com os "
"sinalizadores correspondentes."

#: ../../extending/newtypes_tutorial.rst:164
msgid ""
"We provide a doc string for the type in :c:member:`~PyTypeObject.tp_doc`. ::"
msgstr ""
"Fornecemos uma docstring para o tipo em tp_doc :c:member:`~PyTypeObject."
"tp_doc`. ::"

#: ../../extending/newtypes_tutorial.rst:166
msgid ".tp_doc = PyDoc_STR(\"Custom objects\"),"
msgstr ".tp_doc = PyDoc_STR(\"Custom objects\"),"

#: ../../extending/newtypes_tutorial.rst:168
msgid ""
"To enable object creation, we have to provide a :c:member:`~PyTypeObject."
"tp_new` handler.  This is the equivalent of the Python method :meth:`~object."
"__new__`, but has to be specified explicitly.  In this case, we can just use "
"the default implementation provided by the API function :c:func:"
"`PyType_GenericNew`. ::"
msgstr ""
"Para habilitar a criação de objetos, precisamos fornecer um manipulador "
"para :c:member:`~PyTypeObject.tp_new`. Esse é o equivalente ao método "
"Python :meth:`~object.__new__`, mas precisa ser especificado explicitamente. "
"Neste caso, podemos simplesmente usar a implementação padrão fornecida pela "
"função da API :c:func:`PyType_GenericNew`. ::"

#: ../../extending/newtypes_tutorial.rst:173
msgid ".tp_new = PyType_GenericNew,"
msgstr ".tp_new = PyType_GenericNew,"

#: ../../extending/newtypes_tutorial.rst:175
msgid ""
"Everything else in the file should be familiar, except for some code in :c:"
"func:`!custom_module_exec`::"
msgstr ""
"Todo o restante do arquivo deve ser familiar, exceto por alguns códigos em :"
"c:func:`!custom_module_exec`::"

#: ../../extending/newtypes_tutorial.rst:178
msgid ""
"if (PyType_Ready(&CustomType) < 0) {\n"
"    return -1;\n"
"}"
msgstr ""
"se (PyType_Ready(&CustomType) < 0) {\n"
"    retorno -1;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:182
msgid ""
"This initializes the :class:`!Custom` type, filling in a number of members "
"to the appropriate default values, including :c:member:`~PyObject.ob_type` "
"that we initially set to ``NULL``. ::"
msgstr ""
"Isso inicializa o tipo :class:`!Custom`, preenchendo vários membros com os "
"valores padrão apropriados, incluindo :c:member:`~PyObject.ob_type`, que "
"definimos inicialmente como ``NULL``. ::"

#: ../../extending/newtypes_tutorial.rst:186
msgid ""
"if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) {\n"
"    return -1;\n"
"}"
msgstr ""
"if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) {\n"
"return -1;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:190
msgid ""
"This adds the type to the module dictionary.  This allows us to create :"
"class:`!Custom` instances by calling the :class:`!Custom` class:"
msgstr ""
"Isso adiciona o tipo ao dicionário do módulo.\n"
"Isso nos permite criar instâncias de :class:`!Custom` chamando a classe :"
"class:`!Custom`:"

#: ../../extending/newtypes_tutorial.rst:193
msgid ""
">>> import custom\n"
">>> mycustom = custom.Custom()"
msgstr ""
">>> import custom\n"
">>> mycustom = custom.Custom()"

#: ../../extending/newtypes_tutorial.rst:198
msgid ""
"That's it!  All that remains is to build it; put the above code in a file "
"called :file:`custom.c`,"
msgstr ""
"É isso! Só resta compilá-lo; coloque o código acima em um arquivo chamado :"
"file:`custom.c`,"

#: ../../extending/newtypes_tutorial.rst:201
msgid ""
"[build-system]\n"
"requires = [\"setuptools\"]\n"
"build-backend = \"setuptools.build_meta\"\n"
"\n"
"[project]\n"
"name = \"custom\"\n"
"version = \"1\"\n"
msgstr ""
"[build-system]\n"
"requires = [\"setuptools\"]\n"
"build-backend = \"setuptools.build_meta\"\n"
"\n"
"[project]\n"
"name = \"custom\"\n"
"version = \"1\"\n"

#: ../../extending/newtypes_tutorial.rst:203
msgid "in a file called :file:`pyproject.toml`, and"
msgstr "Em um arquivo chamado :file:`pyproject.toml`, e"

#: ../../extending/newtypes_tutorial.rst:205
msgid ""
"from setuptools import Extension, setup\n"
"setup(ext_modules=[Extension(\"custom\", [\"custom.c\"])])"
msgstr ""
"from setuptools import Extension, setup\n"
"setup(ext_modules=[Extension(\"custom\", [\"custom.c\"])])"

#: ../../extending/newtypes_tutorial.rst:210
msgid "in a file called :file:`setup.py`; then typing"
msgstr "Em um arquivo chamado :file:`setup.py`; e então digitando"

#: ../../extending/newtypes_tutorial.rst:212
#: ../../extending/newtypes_tutorial.rst:550
msgid "$ python -m pip install ."
msgstr "$ python -m pip install ."

#: ../../extending/newtypes_tutorial.rst:216
msgid ""
"in a shell should produce a file :file:`custom.so` in a subdirectory and "
"install it; now fire up Python --- you should be able to ``import custom`` "
"and play around with ``Custom`` objects."
msgstr ""
"no console deverá gerar um arquivo :file:`custom.so` em um subdiretório e "
"instalá-lo; agora abra o Python — você já deve conseguir ``import custom`` e "
"experimentar objetos ``Custom``."

#: ../../extending/newtypes_tutorial.rst:220
msgid "That wasn't so hard, was it?"
msgstr "Isso não foi tão difícil, foi?"

#: ../../extending/newtypes_tutorial.rst:222
msgid ""
"Of course, the current Custom type is pretty uninteresting. It has no data "
"and doesn't do anything. It can't even be subclassed."
msgstr ""
"Naturalmente, o tipo Custom atual é bastante desinteressante. Não tem dados "
"e não faz nada. Não pode nem ser subclassificado."

#: ../../extending/newtypes_tutorial.rst:227
msgid "Adding data and methods to the Basic example"
msgstr "Adicionando dados e métodos ao exemplo básico"

#: ../../extending/newtypes_tutorial.rst:229
msgid ""
"Let's extend the basic example to add some data and methods.  Let's also "
"make the type usable as a base class. We'll create a new module, :mod:`!"
"custom2` that adds these capabilities:"
msgstr ""
"Vamos estender o exemplo básico para adicionar alguns dados e métodos. "
"Também vamos tornar o tipo utilizável como uma classe base. Iremos criar um "
"novo módulo, :mod:`!custom2`, que adiciona esses recursos:"

#: ../../extending/newtypes_tutorial.rst:233
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free(self);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_XSETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_XSETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"first\", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,\n"
"     \"first name\"},\n"
"    {\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,\n"
"     \"last name\"},\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (self->first == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"first\");\n"
"        return NULL;\n"
"    }\n"
"    if (self->last == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"last\");\n"
"        return NULL;\n"
"    }\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom2.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = Custom_init,\n"
"    .tp_dealloc = Custom_dealloc,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"};\n"
"\n"
"static int\n"
"custom_module_exec(PyObject *m)\n"
"{\n"
"    if (PyType_Ready(&CustomType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot custom_module_slots[] = {\n"
"    {Py_mod_exec, custom_module_exec},\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static PyModuleDef custom_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom2\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = 0,\n"
"    .m_slots = custom_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom2(void)\n"
"{\n"
"    return PyModuleDef_Init(&custom_module);\n"
"}\n"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free(self);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_XSETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_XSETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"first\", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,\n"
"     \"first name\"},\n"
"    {\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,\n"
"     \"last name\"},\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (self->first == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"first\");\n"
"        return NULL;\n"
"    }\n"
"    if (self->last == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"last\");\n"
"        return NULL;\n"
"    }\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom2.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = Custom_init,\n"
"    .tp_dealloc = Custom_dealloc,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"};\n"
"\n"
"static int\n"
"custom_module_exec(PyObject *m)\n"
"{\n"
"    if (PyType_Ready(&CustomType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot custom_module_slots[] = {\n"
"    {Py_mod_exec, custom_module_exec},\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static PyModuleDef custom_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom2\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = 0,\n"
"    .m_slots = custom_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom2(void)\n"
"{\n"
"    return PyModuleDef_Init(&custom_module);\n"
"}\n"

#: ../../extending/newtypes_tutorial.rst:236
msgid "This version of the module has a number of changes."
msgstr "Esta versão do módulo possui várias alterações."

#: ../../extending/newtypes_tutorial.rst:238
msgid ""
"The  :class:`!Custom` type now has three data attributes in its C struct, "
"*first*, *last*, and *number*.  The *first* and *last* variables are Python "
"strings containing first and last names.  The *number* attribute is a C "
"integer."
msgstr ""
"O tipo :class:`!Custom` agora possui três atributos de dados em sua "
"estrutura C: first, last e number. As variáveis first e last são strings "
"Python contendo o primeiro e o último nome. O atributo number é um inteiro "
"em C."

#: ../../extending/newtypes_tutorial.rst:242
msgid "The object structure is updated accordingly::"
msgstr "A estrutura do objeto é atualizada de acordo ::"

#: ../../extending/newtypes_tutorial.rst:244
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;"
msgstr ""
"typedef struct {\n"
"PyObject_HEAD\n"
"PyObject *first; /* first name */\n"
"PyObject *last; /* last name */\n"
"int number;\n"
"} CustomObject;"

#: ../../extending/newtypes_tutorial.rst:251
msgid ""
"Because we now have data to manage, we have to be more careful about object "
"allocation and deallocation.  At a minimum, we need a deallocation method::"
msgstr ""
"Como agora temos dados para gerenciar, precisamos ter mais cuidado com a "
"alocação e a desalocação do objeto.  No mínimo, precisamos de método de "
"desalocação::"

#: ../../extending/newtypes_tutorial.rst:254
msgid ""
"static void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free(self);\n"
"}"
msgstr ""
"static void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"CustomObject *self = (CustomObject *) op;\n"
"Py_XDECREF(self->first);\n"
"Py_XDECREF(self->last);\n"
"Py_TYPE(self)->tp_free(self);\n"
"}"

#: ../../extending/newtypes_tutorial.rst:263
msgid "which is assigned to the :c:member:`~PyTypeObject.tp_dealloc` member::"
msgstr "que é atribuído ao membro :c:member:`~PyTypeObject.tp_dealloc`::"

#: ../../extending/newtypes_tutorial.rst:265
msgid ".tp_dealloc = Custom_dealloc,"
msgstr "tp_dealloc = Custom_dealloc,"

#: ../../extending/newtypes_tutorial.rst:267
msgid ""
"This method first clears the reference counts of the two Python attributes. :"
"c:func:`Py_XDECREF` correctly handles the case where its argument is "
"``NULL`` (which might happen here if ``tp_new`` failed midway).  It then "
"calls the :c:member:`~PyTypeObject.tp_free` member of the object's type "
"(computed by ``Py_TYPE(self)``) to free the object's memory.  Note that the "
"object's type might not be :class:`!CustomType`, because the object may be "
"an instance of a subclass."
msgstr ""
"Esse método primeiro limpa a contagem de referências dos dois atributos "
"Python. :c:func:`Py_XDECREF` lida corretamente com o caso em que seu "
"argumento é ``NULL`` (o que pode acontecer aqui se ``tp_new`` falhou no meio "
"do processo). Em seguida, ele chama o membro :c:member:`~PyTypeObject."
"tp_free` do tipo do objeto (obtido por ``Py_TYPE(self)``) para liberar a "
"memória do objeto. Observe que o tipo do objeto pode não ser :class:`!"
"CustomType`, pois o objeto pode ser uma instância de uma subclasse."

#: ../../extending/newtypes_tutorial.rst:277
msgid ""
"The explicit cast to ``CustomObject *`` above is needed because we defined "
"``Custom_dealloc`` to take a ``PyObject *`` argument, as the ``tp_dealloc`` "
"function pointer expects to receive a ``PyObject *`` argument. By assigning "
"to the ``tp_dealloc`` slot of a type, we declare that it can only be called "
"with instances of our ``CustomObject`` class, so the cast to ``(CustomObject "
"*)`` is safe. This is object-oriented polymorphism, in C!"
msgstr ""
"O cast explícito para ``CustomObject *`` acima é necessário porque definimos "
"``Custom_dealloc`` para receber um argumento do tipo ``PyObject *``, "
"enquanto o ponteiro de função ``tp_dealloc`` espera receber um argumento "
"``PyObject *``. Ao atribuir nossa função ao slot ``tp_dealloc`` de um tipo, "
"estamos declarando que ela só pode ser chamada com instâncias da classe "
"``CustomObject``; portanto, o cast para ``(CustomObject *)`` é seguro. Isso "
"é polimorfismo orientado a objetos, em C!"

#: ../../extending/newtypes_tutorial.rst:285
msgid ""
"In existing code, or in previous versions of this tutorial, you might see "
"similar functions take a pointer to the subtype object structure "
"(``CustomObject*``) directly, like this::"
msgstr ""
"Em códigos existentes, ou em versões anteriores deste tutorial, você pode "
"consultar funções semelhantes receberem diretamente um ponteiro para "
"estrutura de objeto do subtipo (``CustomObject*``), assim: ::"

#: ../../extending/newtypes_tutorial.rst:289
msgid ""
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}\n"
"...\n"
".tp_dealloc = (destructor) Custom_dealloc,"
msgstr ""
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"Py_XDECREF(self->first);\n"
"Py_XDECREF(self->last);\n"
"Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}\n"
"...\n"
".tp_dealloc = (destructor) Custom_dealloc,"

#: ../../extending/newtypes_tutorial.rst:298
msgid ""
"This does the same thing on all architectures that CPython supports, but "
"according to the C standard, it invokes undefined behavior."
msgstr ""
"Isso faz a mesma coisa em todas as arquiteturas que o CPython oferece "
"suporte, mas, de acordo com o padrão da linguagem C, isso invoca um "
"comportamento indefinido."

#: ../../extending/newtypes_tutorial.rst:302
msgid ""
"We want to make sure that the first and last names are initialized to empty "
"strings, so we provide a ``tp_new`` implementation::"
msgstr ""
"Queremos nos certificar de que o primeiro e o último nome sejam "
"inicializados como strings vazias, portanto, fornecemos uma implementação:: "
"``tp_new``::"

#: ../../extending/newtypes_tutorial.rst:305
msgid ""
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = PyUnicode_FromString(\"\");\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = PyUnicode_FromString(\"\");\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}"
msgstr ""
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"CustomObject *self;\n"
"self = (CustomObject *) type->tp_alloc(type, 0);\n"
"if (self != NULL) {\n"
"self->first = PyUnicode_FromString(\"\");\n"
"if (self->first == NULL) {\n"
"Py_DECREF(self);\n"
"return NULL;\n"
"}\n"
"self->last = PyUnicode_FromString(\"\");\n"
"if (self->last == NULL) {\n"
"Py_DECREF(self);\n"
"return NULL;\n"
"}\n"
"self->number = 0;\n"
"}\n"
"return (PyObject *) self;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:326
msgid "and install it in the :c:member:`~PyTypeObject.tp_new` member::"
msgstr "e instale-o no membro:: :c:member:`~PyTypeObject.tp_new`"

#: ../../extending/newtypes_tutorial.rst:328
msgid ".tp_new = Custom_new,"
msgstr ".tp_new = Custom_new,"

#: ../../extending/newtypes_tutorial.rst:330
msgid ""
"The ``tp_new`` handler is responsible for creating (as opposed to "
"initializing) objects of the type.  It is exposed in Python as the :meth:"
"`~object.__new__` method. It is not required to define a ``tp_new`` member, "
"and indeed many extension types will simply reuse :c:func:"
"`PyType_GenericNew` as done in the first version of the :class:`!Custom` "
"type above.  In this case, we use the ``tp_new`` handler to initialize the "
"``first`` and ``last`` attributes to non-``NULL`` default values."
msgstr ""
"O manipulador ``tp_new`` é responsável por criar (em oposição a inicializar) "
"os objetos do tipo. Ele é exposto no Python como o método :meth:`~object."
"__new__`. Não é obrigatório definir um membro ``tp_new`` e, de fato, muitos "
"tipos de extensão simplesmente reutilizam :c:func:`PyType_GenericNew`, como "
"na primeira versão do tipo :class:`!Custom` acima. Neste caso, usamos o "
"manipulador ``tp_new`` para inicializar os atributos ``first`` e ``last`` "
"com valores padrão que não sejam ``NULL``."

#: ../../extending/newtypes_tutorial.rst:338
msgid ""
"``tp_new`` is passed the type being instantiated (not necessarily "
"``CustomType``, if a subclass is instantiated) and any arguments passed when "
"the type was called, and is expected to return the instance created.  "
"``tp_new`` handlers always accept positional and keyword arguments, but they "
"often ignore the arguments, leaving the argument handling to initializer (a."
"k.a. ``tp_init`` in C or ``__init__`` in Python) methods."
msgstr ""
"O ``tp_new`` recebe o tipo que está sendo instanciado (não necessariamente "
"``CustomType``, caso uma subclasse esteja sendo instanciada) e quaisquer "
"argumentos passados quando o tipo foi chamado, e deve retornar a instância "
"criada. Manipuladores ``tp_new`` sempre aceitam argumentos posicionais e "
"argumentos nomeados, mas frequentemente os ignoram, deixando o tratamento "
"dos argumentos para os métodos inicializadores (ou seja, ``tp_init`` em C ou "
"``__init__`` em Python)."

#: ../../extending/newtypes_tutorial.rst:346
msgid ""
"``tp_new`` shouldn't call ``tp_init`` explicitly, as the interpreter will do "
"it itself."
msgstr ""
"``tp_new`` não deve chamar ``tp_init`` explicitamente, pois o interpretador "
"fará isso por conta própria."

#: ../../extending/newtypes_tutorial.rst:349
msgid ""
"The ``tp_new`` implementation calls the :c:member:`~PyTypeObject.tp_alloc` "
"slot to allocate memory::"
msgstr ""
"A implementação de ``tp_new`` chama o slot :c:member:`~PyTypeObject."
"tp_alloc` para alocar memória::"

#: ../../extending/newtypes_tutorial.rst:352
msgid "self = (CustomObject *) type->tp_alloc(type, 0);"
msgstr "self = (CustomObject *) type->tp_alloc(type, 0);"

#: ../../extending/newtypes_tutorial.rst:354
msgid ""
"Since memory allocation may fail, we must check the :c:member:`~PyTypeObject."
"tp_alloc` result against ``NULL`` before proceeding."
msgstr ""
"Como a alocação de memória pode falhar, precisamos verificar se o resultado "
"de :c:member:`~PyTypeObject.tp_alloc` é ``NULL`` antes de prosseguir."

#: ../../extending/newtypes_tutorial.rst:358
msgid ""
"We didn't fill the :c:member:`~PyTypeObject.tp_alloc` slot ourselves. "
"Rather :c:func:`PyType_Ready` fills it for us by inheriting it from our base "
"class, which is :class:`object` by default.  Most types use the default "
"allocation strategy."
msgstr ""
"Nós não preenchemos o slot :c:member:`~PyTypeObject.tp_alloc` por conta "
"própria. Em vez disso, :c:func:`PyType_Ready` o preenche herdando-o da nossa "
"classe base, que por padrão é :class:`object`. A maioria dos tipos usa a "
"estratégia de alocação padrão."

#: ../../extending/newtypes_tutorial.rst:364
msgid ""
"If you are creating a co-operative :c:member:`~PyTypeObject.tp_new` (one "
"that calls a base type's :c:member:`~PyTypeObject.tp_new` or :meth:`~object."
"__new__`), you must *not* try to determine what method to call using method "
"resolution order at runtime.  Always statically determine what type you are "
"going to call, and call its :c:member:`~PyTypeObject.tp_new` directly, or "
"via ``type->tp_base->tp_new``.  If you do not do this, Python subclasses of "
"your type that also inherit from other Python-defined classes may not work "
"correctly. (Specifically, you may not be able to create instances of such "
"subclasses without getting a :exc:`TypeError`.)"
msgstr ""
"Se você estiver criando um :c:member:`~PyTypeObject.tp_new` cooperativo (um "
"que chama o :c:member:`~PyTypeObject.tp_new` ou :meth:`~object.__new__` de "
"um tipo base), você *não* deve tentar determinar qual método chamar usando a "
"ordem de resolução de métodos em tempo de execução. Sempre determine "
"estaticamente qual tipo você vai chamar e chame seu :c:member:`~PyTypeObject."
"tp_new` diretamente ou via ``type->tp_base->tp_new``. Se você não fizer "
"isso, as subclasses Python do seu tipo que também herdam de outras classes "
"definidas em Python podem não funcionar corretamente. (Especificamente, você "
"pode não conseguir criar instâncias dessas subclasses sem receber um :exc:"
"`TypeError`.)"

#: ../../extending/newtypes_tutorial.rst:374
msgid ""
"We also define an initialization function which accepts arguments to provide "
"initial values for our instance::"
msgstr ""
"Também definimos uma função de inicialização que aceita argumentos para "
"fornecer valores iniciais para nosso instância::"

#: ../../extending/newtypes_tutorial.rst:377
msgid ""
"static int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL, *tmp;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        tmp = self->first;\n"
"        Py_INCREF(first);\n"
"        self->first = first;\n"
"        Py_XDECREF(tmp);\n"
"    }\n"
"    if (last) {\n"
"        tmp = self->last;\n"
"        Py_INCREF(last);\n"
"        self->last = last;\n"
"        Py_XDECREF(tmp);\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""
"static intCustom_init(PyObject *op, PyObject *args, PyObject *kwds)"
"{ CustomObject *self = (CustomObject *) op; static char *kwlist[] = "
"{\"first\", \"last\", \"number\", NULL}; PyObject *first = NULL, *last = "
"NULL, *tmp; if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist, "
"&first, &last, &self->number)) return -1; if (first) { tmp = self->first; "
"Py_INCREF(first); self->first = first; Py_XDECREF(tmp); } if (last) { tmp = "
"self->last; Py_INCREF(last); self->last = last; Py_XDECREF(tmp); } return 0;}"

#: ../../extending/newtypes_tutorial.rst:404
msgid "by filling the :c:member:`~PyTypeObject.tp_init` slot. ::"
msgstr "preenchendo o slot :: :c:member:`~PyTypeObject.tp_init`."

#: ../../extending/newtypes_tutorial.rst:406
msgid ".tp_init = Custom_init,"
msgstr ".tp_init = Custom_init,"

#: ../../extending/newtypes_tutorial.rst:408
msgid ""
"The :c:member:`~PyTypeObject.tp_init` slot is exposed in Python as the :meth:"
"`~object.__init__` method.  It is used to initialize an object after it's "
"created.  Initializers always accept positional and keyword arguments, and "
"they should return either ``0`` on success or ``-1`` on error."
msgstr ""
"O slot :c:member:`~PyTypeObject.tp_init` é exposto em Python como o método :"
"meth:`~object.__init__`. Ele é usado para inicializar um objeto depois que "
"ele é criado. Inicializadores sempre aceitam argumentos posicionais e "
"argumentos nomeados, e devem retornar ``0`` em caso de sucesso ou ``-1`` em "
"caso de erro."

#: ../../extending/newtypes_tutorial.rst:413
msgid ""
"Unlike the ``tp_new`` handler, there is no guarantee that ``tp_init`` is "
"called at all (for example, the :mod:`pickle` module by default doesn't "
"call :meth:`~object.__init__` on unpickled instances).  It can also be "
"called multiple times.  Anyone can call the :meth:`!__init__` method on our "
"objects.  For this reason, we have to be extra careful when assigning the "
"new attribute values.  We might be tempted, for example to assign the "
"``first`` member like this::"
msgstr ""
"Ao contrário do manipulador ``tp_new``, não há garantia de que  seja chamado "
"(por exemplo, o módulo :mod:`pickle` por padrão não chama :meth:`~object."
"__init__` em instâncias desserializadas). Além disso, ``tp_init`` pode ser "
"chamado várias vezes. Qualquer um pode chamar o método :meth:`!__init__` em "
"nossos objetos. Por esse motivo, precisamos ter cuidado redobrado ao "
"atribuir os novos valores de atributos. Poderíamos ficar tentados, por "
"exemplo, a atribuir o membro ``first`` assim::"

#: ../../extending/newtypes_tutorial.rst:421
msgid ""
"if (first) {\n"
"    Py_XDECREF(self->first);\n"
"    Py_INCREF(first);\n"
"    self->first = first;\n"
"}"
msgstr ""
"if (first) { Py_XDECREF(self->first); Py_INCREF(first); self->first = first;}"

#: ../../extending/newtypes_tutorial.rst:427
msgid ""
"But this would be risky.  Our type doesn't restrict the type of the "
"``first`` member, so it could be any kind of object.  It could have a "
"destructor that causes code to be executed that tries to access the "
"``first`` member; or that destructor could detach the :term:`thread state "
"<attached thread state>` and let arbitrary code run in other threads that "
"accesses and modifies our object."
msgstr ""
"Mas isso seria arriscado. Nosso tipo não restringe o tipo do membro "
"``first``, então ele poderia ser qualquer tipo de objeto. Ele poderia ter um "
"destrutor que executasse código que tentasse acessar o membro ``first``; ou "
"esse destrutor poderia desanexar o :term:`estado de thread <attached thread "
"state>` e permitir que código arbitrário fosse executado em outras threads, "
"acessando e modificando nosso objeto."

#: ../../extending/newtypes_tutorial.rst:434
msgid ""
"To be paranoid and protect ourselves against this possibility, we almost "
"always reassign members before decrementing their reference counts.  When "
"don't we have to do this?"
msgstr ""
"Para sermos extremamente cautelosos e nos proteger dessa possibilidade, "
"quase sempre atribuímos novamente os membros antes de decrementar a contagem "
"de referências. Quando não precisamos fazer isso?"

#: ../../extending/newtypes_tutorial.rst:438
msgid "when we absolutely know that the reference count is greater than 1;"
msgstr ""
"quando sabemos absolutamente que a contagem de referência é maior que 1;"

#: ../../extending/newtypes_tutorial.rst:440
msgid ""
"when we know that deallocation of the object [#]_ will neither detach the :"
"term:`thread state <attached thread state>` nor cause any calls back into "
"our type's code;"
msgstr ""
"quando sabemos que a desalocação do objeto [#]_ não desvinculará o :term:"
"`estado de thread <attached thread state>` nem causará quaisquer chamadas de "
"volta no código do nosso tipo;"

#: ../../extending/newtypes_tutorial.rst:443
msgid ""
"when decrementing a reference count in a :c:member:`~PyTypeObject."
"tp_dealloc` handler on a type which doesn't support cyclic garbage "
"collection [#]_."
msgstr ""
"quando estamos decrementando uma contagem de referências em um manipulador :"
"c:member:`~PyTypeObject.tp_dealloc` de um tipo que não oferece suporte à "
"coleta de lixo cíclica [#]_."

#: ../../extending/newtypes_tutorial.rst:446
msgid ""
"We want to expose our instance variables as attributes. There are a number "
"of ways to do that. The simplest way is to define member definitions::"
msgstr ""
"Queremos expor nossas variáveis de instância como atributos. Há várias "
"maneiras de fazer isso. A forma mais simples é estabelecer definições de "
"membros::"

#: ../../extending/newtypes_tutorial.rst:449
msgid ""
"static PyMemberDef Custom_members[] = {\n"
"    {\"first\", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,\n"
"     \"first name\"},\n"
"    {\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,\n"
"     \"last name\"},\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""
"static PyMemberDef Custom_members[] = { {\"first\", Py_T_OBJECT_EX, "
"offsetof(CustomObject, first), 0, \"first name\"}, {\"last\", "
"Py_T_OBJECT_EX, offsetof(CustomObject, last), 0, \"last name\"}, "
"{\"number\", Py_T_INT, offsetof(CustomObject, number), 0, \"custom "
"number\"}, {NULL} /* Sentinel */};"

#: ../../extending/newtypes_tutorial.rst:459
msgid ""
"and put the definitions in the :c:member:`~PyTypeObject.tp_members` slot::"
msgstr "e colocar as definições no slot :c:member:`~PyTypeObject.tp_members`::"

#: ../../extending/newtypes_tutorial.rst:461
msgid ".tp_members = Custom_members,"
msgstr ".tp_members = Custom_members,"

#: ../../extending/newtypes_tutorial.rst:463
msgid ""
"Each member definition has a member name, type, offset, access flags and "
"documentation string.  See the :ref:`Generic-Attribute-Management` section "
"below for details."
msgstr ""
"Cada definição de membro possui um nome de membro, um tipo, um deslocamento, "
"sinalizadores de acesso e uma string de documentação. Consulte a seção :ref:"
"`Generic-Attribute-Management` abaixo para mais detalhes."

#: ../../extending/newtypes_tutorial.rst:467
msgid ""
"A disadvantage of this approach is that it doesn't provide a way to restrict "
"the types of objects that can be assigned to the Python attributes.  We "
"expect the first and last names to be strings, but any Python objects can be "
"assigned. Further, the attributes can be deleted, setting the C pointers to "
"``NULL``.  Even though we can make sure the members are initialized to non-"
"``NULL`` values, the members can be set to ``NULL`` if the attributes are "
"deleted."
msgstr ""
"Uma desvantagem dessa abordagem é que ela não fornece uma forma de "
"restringir os tipos de objetos que podem ser atribuídos aos atributos em "
"Python. Esperamos que os nomes first e last sejam strings, mas qualquer "
"objeto Python pode ser atribuído. Além disso, os atributos podem ser "
"excluídos, fazendo com que os ponteiros em C sejam definidos como ``NULL``. "
"Mesmo que possamos garantir que os membros sejam inicializados com valores "
"não ``NULL``, eles ainda podem acabar sendo definidos como ``NULL`` caso os "
"atributos sejam apagados."

#: ../../extending/newtypes_tutorial.rst:474
msgid ""
"We define a single method, :meth:`!Custom.name`, that outputs the objects "
"name as the concatenation of the first and last names. ::"
msgstr ""
"Definimos um único método,:meth:`!Custom.name`, que exibe o nome do objeto "
"como a concatenação do primeiro nome com o último nome ::"

#: ../../extending/newtypes_tutorial.rst:477
msgid ""
"static PyObject *\n"
"Custom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (self->first == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"first\");\n"
"        return NULL;\n"
"    }\n"
"    if (self->last == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"last\");\n"
"        return NULL;\n"
"    }\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}"
msgstr ""
"static PyObject *Custom_name(PyObject *op, PyObject *Py_UNUSED(dummy))"
"{ CustomObject *self = (CustomObject *) op; if (self->first == NULL) "
"{ PyErr_SetString(PyExc_AttributeError, \"first\"); return NULL; } if (self-"
">last == NULL) { PyErr_SetString(PyExc_AttributeError, \"last\"); return "
"NULL; } return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);}"

#: ../../extending/newtypes_tutorial.rst:492
msgid ""
"The method is implemented as a C function that takes a :class:`!Custom` (or :"
"class:`!Custom` subclass) instance as the first argument.  Methods always "
"take an instance as the first argument. Methods often take positional and "
"keyword arguments as well, but in this case we don't take any and don't need "
"to accept a positional argument tuple or keyword argument dictionary. This "
"method is equivalent to the Python method:"
msgstr ""
"O método é implementado como uma função em C que recebe uma instância de :"
"class:`!Custom` (ou de uma subclasse de :class:`!Custom`) como primeiro "
"argumento. Métodos sempre recebem a instância como primeiro argumento. Eles "
"também costumam aceitar argumentos posicionais e nomeados, mas, neste caso, "
"não recebemos nenhum e não precisamos aceitar uma tupla de argumentos "
"posicionais nem um dicionário de argumentos nomeados. Este método equivale "
"ao método Python:"

#: ../../extending/newtypes_tutorial.rst:499
msgid ""
"def name(self):\n"
"    return \"%s %s\" % (self.first, self.last)"
msgstr "def name(self): return \"%s %s\" % (self.first, self.last)"

#: ../../extending/newtypes_tutorial.rst:504
msgid ""
"Note that we have to check for the possibility that our :attr:`!first` and :"
"attr:`!last` members are ``NULL``.  This is because they can be deleted, in "
"which case they are set to ``NULL``.  It would be better to prevent deletion "
"of these attributes and to restrict the attribute values to be strings.  "
"We'll see how to do that in the next section."
msgstr ""
"Observe que precisamos verificar a possibilidade de que nossos atributos :"
"attr:`!first` e :attr:`!last` estejam com valor ``NULL``. Isso ocorre porque "
"eles podem ser excluídos e, nesse caso, ficam definidos como ``NULL``. Seria "
"melhor impedir a exclusão desses atributos e restringir seus valores para "
"que sejam sempre strings. Veremos como fazer isso na próxima seção."

#: ../../extending/newtypes_tutorial.rst:510
msgid ""
"Now that we've defined the method, we need to create an array of method "
"definitions::"
msgstr ""
"Agora que definimos o método, precisamos criar uma array de definições de "
"métodos::"

#: ../../extending/newtypes_tutorial.rst:513
msgid ""
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""
"static PyMethodDef Custom_methods[] = {\n"
"{\"name\", Custom_name, METH_NOARGS,\n"
"\"Return the name, combining the first and last name\"\n"
"},\n"
"{NULL} /* Sentinel */\n"
"};"

#: ../../extending/newtypes_tutorial.rst:520
msgid ""
"(note that we used the :c:macro:`METH_NOARGS` flag to indicate that the "
"method is expecting no arguments other than *self*)"
msgstr ""
"note que usamos o sinalizador :c:macro:`METH_NOARGS` para indicar que o "
"método não espera argumentos além de *self*)"

#: ../../extending/newtypes_tutorial.rst:523
msgid "and assign it to the :c:member:`~PyTypeObject.tp_methods` slot::"
msgstr "e atribuí-lo para o slot:: :c:member:`~PyTypeObject.tp_methods`"

#: ../../extending/newtypes_tutorial.rst:525
msgid ".tp_methods = Custom_methods,"
msgstr ".tp_methods = Custom_methods,"

#: ../../extending/newtypes_tutorial.rst:527
msgid ""
"Finally, we'll make our type usable as a base class for subclassing.  We've "
"written our methods carefully so far so that they don't make any assumptions "
"about the type of the object being created or used, so all we need to do is "
"to add the :c:macro:`Py_TPFLAGS_BASETYPE` to our class flag definition::"
msgstr ""
"Por fim, tornaremos nosso tipo utilizável como classe base para herança. "
"Escrevemos nossos métodos com cuidado até agora, garantindo que eles não "
"façam suposições sobre o tipo do objeto que está sendo criado ou utilizado; "
"portanto, tudo o que precisamos fazer é adicionar a :c:macro:"
"`Py_TPFLAGS_BASETYPE` à definição dos sinalizadores da nossa classe::"

#: ../../extending/newtypes_tutorial.rst:532
msgid ".tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,"
msgstr ".tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,"

#: ../../extending/newtypes_tutorial.rst:534
msgid ""
"We rename :c:func:`!PyInit_custom` to :c:func:`!PyInit_custom2`, update the "
"module name in the :c:type:`PyModuleDef` struct, and update the full class "
"name in the :c:type:`PyTypeObject` struct."
msgstr ""
"Renomeamos :c:func:`!PyInit_custom` para :c:func:`!PyInit_custom2`, "
"atualizamos o nome do módulo na estrutura :c:type:`PyModuleDef`, e "
"atualizamos o nome completo da classe na estrutura :c:type:`PyTypeObject`."

#: ../../extending/newtypes_tutorial.rst:538
msgid "Finally, we update our :file:`setup.py` file to include the new module,"
msgstr ""
"Finalmente, atualizamos nosso arquivo :file:`setup.py` para incluir o novo "
"módulo,"

#: ../../extending/newtypes_tutorial.rst:540
msgid ""
"from setuptools import Extension, setup\n"
"setup(ext_modules=[\n"
"    Extension(\"custom\", [\"custom.c\"]),\n"
"    Extension(\"custom2\", [\"custom2.c\"]),\n"
"])"
msgstr ""
"from setuptools import Extension, "
"setupsetup(ext_modules=[ Extension(\"custom\", [\"custom.c\"]), "
"Extension(\"custom2\", [\"custom2.c\"]),])"

#: ../../extending/newtypes_tutorial.rst:548
msgid "and then we re-install so that we can ``import custom2``:"
msgstr "então podemos instalar novamente para realizarmos o ``import custom2``"

#: ../../extending/newtypes_tutorial.rst:555
msgid "Providing finer control over data attributes"
msgstr "Fornecendo controle mais preciso sobre atributos de dados"

#: ../../extending/newtypes_tutorial.rst:557
msgid ""
"In this section, we'll provide finer control over how the :attr:`!first` "
"and :attr:`!last` attributes are set in the :class:`!Custom` example. In the "
"previous version of our module, the instance variables :attr:`!first` and :"
"attr:`!last` could be set to non-string values or even deleted. We want to "
"make sure that these attributes always contain strings."
msgstr ""
"Nesta seção, forneceremos um controle mais preciso sobre como os atributos :"
"attr:`!first` e :attr:`!last` são definidos no exemplo :class:`!Custom`. Na "
"versão anterior do nosso módulo, as variáveis de instância :attr:`!first` e :"
"attr:`!last` podiam receber valores que não fossem strings ou até mesmo ser "
"excluídas. Queremos garantir que esses atributos sempre contenham strings."

#: ../../extending/newtypes_tutorial.rst:563
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free(self);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_SETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_SETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_getfirst(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return Py_NewRef(self->first);\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_SETREF(self->first, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_getlast(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return Py_NewRef(self->last);\n"
"}\n"
"\n"
"static int\n"
"Custom_setlast(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the last "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The last attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_SETREF(self->last, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", Custom_getfirst, Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", Custom_getlast, Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom3.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = Custom_init,\n"
"    .tp_dealloc = Custom_dealloc,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"    .tp_getset = Custom_getsetters,\n"
"};\n"
"\n"
"static int\n"
"custom_module_exec(PyObject *m)\n"
"{\n"
"    if (PyType_Ready(&CustomType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot custom_module_slots[] = {\n"
"    {Py_mod_exec, custom_module_exec},\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static PyModuleDef custom_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom3\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = 0,\n"
"    .m_slots = custom_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom3(void)\n"
"{\n"
"    return PyModuleDef_Init(&custom_module);\n"
"}\n"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free(self);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_SETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_SETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_getfirst(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return Py_NewRef(self->first);\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_SETREF(self->first, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_getlast(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return Py_NewRef(self->last);\n"
"}\n"
"\n"
"static int\n"
"Custom_setlast(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the last "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The last attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_SETREF(self->last, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", Custom_getfirst, Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", Custom_getlast, Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom3.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = Custom_init,\n"
"    .tp_dealloc = Custom_dealloc,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"    .tp_getset = Custom_getsetters,\n"
"};\n"
"\n"
"static int\n"
"custom_module_exec(PyObject *m)\n"
"{\n"
"    if (PyType_Ready(&CustomType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot custom_module_slots[] = {\n"
"    {Py_mod_exec, custom_module_exec},\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static PyModuleDef custom_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom3\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = 0,\n"
"    .m_slots = custom_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom3(void)\n"
"{\n"
"    return PyModuleDef_Init(&custom_module);\n"
"}\n"

#: ../../extending/newtypes_tutorial.rst:566
msgid ""
"To provide greater control, over the :attr:`!first` and :attr:`!last` "
"attributes, we'll use custom getter and setter functions.  Here are the "
"functions for getting and setting the :attr:`!first` attribute::"
msgstr ""
"Para oferecer um controle maior sobre os atributos :attr:`!first` e :attr:`!"
"last`, usaremos funções personalizadas de acesso (getters) e modificação "
"(setters). A seguir estão as funções para obter e definir o atributo :attr:`!"
"first`::"

#: ../../extending/newtypes_tutorial.rst:570
msgid ""
"static PyObject *\n"
"Custom_getfirst(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_INCREF(self->first);\n"
"    return self->first;\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    PyObject *tmp;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    tmp = self->first;\n"
"    Py_INCREF(value);\n"
"    self->first = value;\n"
"    Py_DECREF(tmp);\n"
"    return 0;\n"
"}"
msgstr ""
"static PyObject *\n"
"Custom_getfirst(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_INCREF(self->first);\n"
"    return self->first;\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    PyObject *tmp;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    tmp = self->first;\n"
"    Py_INCREF(value);\n"
"    self->first = value;\n"
"    Py_DECREF(tmp);\n"
"    return 0;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:599
msgid ""
"The getter function is passed a :class:`!Custom` object and a \"closure\", "
"which is a void pointer.  In this case, the closure is ignored.  (The "
"closure supports an advanced usage in which definition data is passed to the "
"getter and setter. This could, for example, be used to allow a single set of "
"getter and setter functions that decide the attribute to get or set based on "
"data in the closure.)"
msgstr ""
"A função getter recebe um objeto :class:`!Custom` e um closure, que é um "
"ponteiro para void. Neste caso, o closure é ignorado. (O closure oferece "
"suporte a um modo de usar mais avançado, no qual dados de definição são "
"passados ao getter e ao setter. Isso pode, por exemplo, permitir que um "
"único conjunto de funções getter e setter decida qual atributo obter ou "
"definir com base nos dados presentes no closure.)"

#: ../../extending/newtypes_tutorial.rst:605
msgid ""
"The setter function is passed the :class:`!Custom` object, the new value, "
"and the closure.  The new value may be ``NULL``, in which case the attribute "
"is being deleted.  In our setter, we raise an error if the attribute is "
"deleted or if its new value is not a string."
msgstr ""
"A função setter recebe o objeto :class:`!Custom`, o novo valor e o closure. "
"O novo valor pode ser ``NULL``, caso em que o atributo está sendo excluído. "
"No nosso setter, levantamos um erro se o atributo for excluído ou se o novo "
"valor não for uma string."

#: ../../extending/newtypes_tutorial.rst:610
msgid "We create an array of :c:type:`PyGetSetDef` structures::"
msgstr "Nós criamos um vetor de estruturas :c:type:`PyGetSetDef`::"

#: ../../extending/newtypes_tutorial.rst:612
msgid ""
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", Custom_getfirst, Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", Custom_getlast, Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", Custom_getfirst, Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", Custom_getlast, Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};"

#: ../../extending/newtypes_tutorial.rst:620
msgid "and register it in the :c:member:`~PyTypeObject.tp_getset` slot::"
msgstr "e registra isso num slot :c:member:`~PyTypeObject.tp_getset`::"

#: ../../extending/newtypes_tutorial.rst:622
msgid ".tp_getset = Custom_getsetters,"
msgstr ".tp_getset = Custom_getsetters,"

#: ../../extending/newtypes_tutorial.rst:624
msgid ""
"The last item in a :c:type:`PyGetSetDef` structure is the \"closure\" "
"mentioned above.  In this case, we aren't using a closure, so we just pass "
"``NULL``."
msgstr ""
"A última entrada em uma estrutura :c:type:`PyGetSetDef` é o “closure” "
"mencionado acima. Neste caso, não estamos usando um closure, então "
"simplesmente passamos ``NULL``."

#: ../../extending/newtypes_tutorial.rst:627
msgid "We also remove the member definitions for these attributes::"
msgstr "Também removemos as definições de membros para esses atributos::"

#: ../../extending/newtypes_tutorial.rst:629
msgid ""
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};"

#: ../../extending/newtypes_tutorial.rst:635
msgid ""
"We also need to update the :c:member:`~PyTypeObject.tp_init` handler to only "
"allow strings [#]_ to be passed::"
msgstr ""
"Também precisamos atualizar o manipulador :c:member:`~PyTypeObject.tp_init` "
"para permitir apenas strings [#]_ como valores passados::"

#: ../../extending/newtypes_tutorial.rst:638
msgid ""
"static int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL, *tmp;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        tmp = self->first;\n"
"        Py_INCREF(first);\n"
"        self->first = first;\n"
"        Py_DECREF(tmp);\n"
"    }\n"
"    if (last) {\n"
"        tmp = self->last;\n"
"        Py_INCREF(last);\n"
"        self->last = last;\n"
"        Py_DECREF(tmp);\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL, *tmp;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        tmp = self->first;\n"
"        Py_INCREF(first);\n"
"        self->first = first;\n"
"        Py_DECREF(tmp);\n"
"    }\n"
"    if (last) {\n"
"        tmp = self->last;\n"
"        Py_INCREF(last);\n"
"        self->last = last;\n"
"        Py_DECREF(tmp);\n"
"    }\n"
"    return 0;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:665
msgid ""
"With these changes, we can assure that the ``first`` and ``last`` members "
"are never ``NULL`` so we can remove checks for ``NULL`` values in almost all "
"cases. This means that most of the :c:func:`Py_XDECREF` calls can be "
"converted to :c:func:`Py_DECREF` calls.  The only place we can't change "
"these calls is in the ``tp_dealloc`` implementation, where there is the "
"possibility that the initialization of these members failed in ``tp_new``."
msgstr ""
"Com essas alterações, podemos garantir que os membros ``first`` e ``last`` "
"nunca sejam ``NULL``, de modo que podemos remover quase todas as "
"verificações de valores ``NULL``. Isso significa que a maioria das chamadas "
"para :c:func:`Py_XDECREF` pode ser substituída por chamadas para :c:func:"
"`Py_DECREF`. O único lugar em que não podemos substituir essas chamadas é na "
"implementação de ``tp_dealloc``, onde existe a possibilidade de que a "
"inicialização desses membros tenha falhado em ``tp_new``."

#: ../../extending/newtypes_tutorial.rst:672
msgid ""
"We also rename the module initialization function and module name in the "
"initialization function, as we did before, and we add an extra definition to "
"the :file:`setup.py` file."
msgstr ""
"Também renomeamos a função de inicialização do módulo e o nome do módulo "
"dentro da função de inicialização, como fizemos anteriormente, e adicionamos "
"uma definição extra ao arquivo :file:`setup.py`."

#: ../../extending/newtypes_tutorial.rst:678
msgid "Supporting cyclic garbage collection"
msgstr "Apoiando a coleta de lixo cíclica"

#: ../../extending/newtypes_tutorial.rst:680
msgid ""
"Python has a :term:`cyclic garbage collector (GC) <garbage collection>` that "
"can identify unneeded objects even when their reference counts are not zero. "
"This can happen when objects are involved in cycles.  For example, consider:"
msgstr ""
"O Python possui um :term:`coletor de lixo (GC) cíclico <garbage collection>` "
"que pode identificar objetos que não são mais necessários mesmo quando suas "
"contagens de referências não são zero. Isso pode acontecer quando os objetos "
"participam de ciclos. Por exemplo, considere:"

#: ../../extending/newtypes_tutorial.rst:684
msgid ""
">>> l = []\n"
">>> l.append(l)\n"
">>> del l"
msgstr ""
">>> l = []\n"
">>> l.append(l)\n"
">>> del l"

#: ../../extending/newtypes_tutorial.rst:690
msgid ""
"In this example, we create a list that contains itself. When we delete it, "
"it still has a reference from itself. Its reference count doesn't drop to "
"zero. Fortunately, Python's cyclic garbage collector will eventually figure "
"out that the list is garbage and free it."
msgstr ""
"Neste exemplo, criamos uma lista que contém a si mesma. Quando a apagamos, "
"ela ainda possui uma referência apontando para si própria. Sua contagem de "
"referências não cai para zero. Felizmente, o coletor de lixo cíclico do "
"Python acabará percebendo que a lista é lixo e irá liberá-la."

#: ../../extending/newtypes_tutorial.rst:695
msgid ""
"In the second version of the :class:`!Custom` example, we allowed any kind "
"of object to be stored in the :attr:`!first` or :attr:`!last` attributes "
"[#]_. Besides, in the second and third versions, we allowed subclassing :"
"class:`!Custom`, and subclasses may add arbitrary attributes.  For any of "
"those two reasons, :class:`!Custom` objects can participate in cycles:"
msgstr ""
"No segunda versão do exemplo de :class:`!Custom`, permitimos que qualquer "
"tipo de objeto fosse armazenado nos atributos :attr:`!first` ou :attr:`!"
"last` [#]_. Além disso, na segunda e na terceira versões, permitimos "
"estender :class:`!Custom`, e subclasses podem adicionar atributos "
"arbitrários. Por qualquer um desses dois motivos, instâncias de :class:`!"
"Custom` podem participar de ciclos:"

#: ../../extending/newtypes_tutorial.rst:701
msgid ""
">>> import custom3\n"
">>> class Derived(custom3.Custom): pass\n"
"...\n"
">>> n = Derived()\n"
">>> n.some_attribute = n"
msgstr ""
">>> import custom3\n"
">>> class Derived(custom3.Custom): pass\n"
"...\n"
">>> n = Derived()\n"
">>> n.some_attribute = n"

#: ../../extending/newtypes_tutorial.rst:709
msgid ""
"To allow a :class:`!Custom` instance participating in a reference cycle to "
"be properly detected and collected by the cyclic GC, our :class:`!Custom` "
"type needs to fill two additional slots and to enable a flag that enables "
"these slots:"
msgstr ""
"Para permitir que uma instância de :class:`!Custom` que participa de um "
"ciclo de referência seja corretamente detectada e coletada pelo coletor de "
"lixo cíclico, nosso tipo :class:`!Custom` precisa preencher dois slots "
"adicionais e ativar um sinalizador que habilita esses slots:"

#: ../../extending/newtypes_tutorial.rst:713
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static int\n"
"Custom_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_VISIT(self->first);\n"
"    Py_VISIT(self->last);\n"
"    return 0;\n"
"}\n"
"\n"
"static int\n"
"Custom_clear(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_CLEAR(self->first);\n"
"    Py_CLEAR(self->last);\n"
"    return 0;\n"
"}\n"
"\n"
"static void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    PyObject_GC_UnTrack(op);\n"
"    (void)Custom_clear(op);\n"
"    Py_TYPE(op)->tp_free(op);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_SETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_SETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_getfirst(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return Py_NewRef(self->first);\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_XSETREF(self->first, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_getlast(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return Py_NewRef(self->last);\n"
"}\n"
"\n"
"static int\n"
"Custom_setlast(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the last "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The last attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_XSETREF(self->last, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", Custom_getfirst, Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", Custom_getlast, Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom4.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | "
"Py_TPFLAGS_HAVE_GC,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = Custom_init,\n"
"    .tp_dealloc = Custom_dealloc,\n"
"    .tp_traverse = Custom_traverse,\n"
"    .tp_clear = Custom_clear,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"    .tp_getset = Custom_getsetters,\n"
"};\n"
"\n"
"static int\n"
"custom_module_exec(PyObject *m)\n"
"{\n"
"    if (PyType_Ready(&CustomType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot custom_module_slots[] = {\n"
"    {Py_mod_exec, custom_module_exec},\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static PyModuleDef custom_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom4\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = 0,\n"
"    .m_slots = custom_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom4(void)\n"
"{\n"
"    return PyModuleDef_Init(&custom_module);\n"
"}\n"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static int\n"
"Custom_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_VISIT(self->first);\n"
"    Py_VISIT(self->last);\n"
"    return 0;\n"
"}\n"
"\n"
"static int\n"
"Custom_clear(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_CLEAR(self->first);\n"
"    Py_CLEAR(self->last);\n"
"    return 0;\n"
"}\n"
"\n"
"static void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    PyObject_GC_UnTrack(op);\n"
"    (void)Custom_clear(op);\n"
"    Py_TYPE(op)->tp_free(op);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_SETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_SETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_getfirst(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return Py_NewRef(self->first);\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_XSETREF(self->first, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_getlast(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return Py_NewRef(self->last);\n"
"}\n"
"\n"
"static int\n"
"Custom_setlast(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the last "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The last attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_XSETREF(self->last, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", Custom_getfirst, Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", Custom_getlast, Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom4.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | "
"Py_TPFLAGS_HAVE_GC,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = Custom_init,\n"
"    .tp_dealloc = Custom_dealloc,\n"
"    .tp_traverse = Custom_traverse,\n"
"    .tp_clear = Custom_clear,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"    .tp_getset = Custom_getsetters,\n"
"};\n"
"\n"
"static int\n"
"custom_module_exec(PyObject *m)\n"
"{\n"
"    if (PyType_Ready(&CustomType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot custom_module_slots[] = {\n"
"    {Py_mod_exec, custom_module_exec},\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static PyModuleDef custom_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom4\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = 0,\n"
"    .m_slots = custom_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom4(void)\n"
"{\n"
"    return PyModuleDef_Init(&custom_module);\n"
"}\n"

#: ../../extending/newtypes_tutorial.rst:716
msgid ""
"First, the traversal method lets the cyclic GC know about subobjects that "
"could participate in cycles::"
msgstr ""
"Primeiro, o método de travessia informa ao coletor de lixo cíclico quais "
"subobjetos podem participar de ciclos::"

#: ../../extending/newtypes_tutorial.rst:719
msgid ""
"static int\n"
"Custom_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    int vret;\n"
"    if (self->first) {\n"
"        vret = visit(self->first, arg);\n"
"        if (vret != 0)\n"
"            return vret;\n"
"    }\n"
"    if (self->last) {\n"
"        vret = visit(self->last, arg);\n"
"        if (vret != 0)\n"
"            return vret;\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"Custom_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    int vret;\n"
"    if (self->first) {\n"
"        vret = visit(self->first, arg);\n"
"        if (vret != 0)\n"
"            return vret;\n"
"    }\n"
"    if (self->last) {\n"
"        vret = visit(self->last, arg);\n"
"        if (vret != 0)\n"
"            return vret;\n"
"    }\n"
"    return 0;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:737
msgid ""
"For each subobject that can participate in cycles, we need to call the :c:"
"func:`!visit` function, which is passed to the traversal method. The :c:func:"
"`!visit` function takes as arguments the subobject and the extra argument "
"*arg* passed to the traversal method.  It returns an integer value that must "
"be returned if it is non-zero."
msgstr ""
"Para cada subobjeto que pode participar de ciclos, precisamos chamar a "
"função :c:func:`!visit`, que é passada para o método de travessia. A função :"
"c:func:`!visit` recebe como argumentos o subobjeto e o argumento extra *arg* "
"fornecido ao método de travessia. Ela retorna um valor inteiro que deve ser "
"retornado se for diferente de zero."

#: ../../extending/newtypes_tutorial.rst:743
msgid ""
"Python provides a :c:func:`Py_VISIT` macro that automates calling visit "
"functions.  With :c:func:`Py_VISIT`, we can minimize the amount of "
"boilerplate in ``Custom_traverse``::"
msgstr ""
"O Python fornece o macro :c:func:`Py_VISIT`, que automatiza as chamadas às "
"funções visit. Com :c:func:`Py_VISIT`, podemos minimizar a quantidade de "
"boilerplate em ``Custom_traverse``::"

#: ../../extending/newtypes_tutorial.rst:747
msgid ""
"static int\n"
"Custom_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_VISIT(self->first);\n"
"    Py_VISIT(self->last);\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"Custom_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_VISIT(self->first);\n"
"    Py_VISIT(self->last);\n"
"    return 0;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:757
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` implementation must name its "
"arguments exactly *visit* and *arg* in order to use :c:func:`Py_VISIT`."
msgstr ""
"A implementação de :c:member:`~PyTypeObject.tp_traverse` deve nomear seus "
"argumentos exatamente como *visit* e *arg* para que seja possível usar :c:"
"func:`Py_VISIT`."

#: ../../extending/newtypes_tutorial.rst:760
msgid ""
"Second, we need to provide a method for clearing any subobjects that can "
"participate in cycles::"
msgstr ""
"Segundo, precisamos fornecer um método para limpar quaisquer subobjetos que "
"possam participar de ciclos::"

#: ../../extending/newtypes_tutorial.rst:763
msgid ""
"static int\n"
"Custom_clear(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_CLEAR(self->first);\n"
"    Py_CLEAR(self->last);\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"Custom_clear(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_CLEAR(self->first);\n"
"    Py_CLEAR(self->last);\n"
"    return 0;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:772
msgid ""
"Notice the use of the :c:func:`Py_CLEAR` macro.  It is the recommended and "
"safe way to clear data attributes of arbitrary types while decrementing "
"their reference counts.  If you were to call :c:func:`Py_XDECREF` instead on "
"the attribute before setting it to ``NULL``, there is a possibility that the "
"attribute's destructor would call back into code that reads the attribute "
"again (*especially* if there is a reference cycle)."
msgstr ""
"Observe o uso do macro :c:func:`Py_CLEAR`. Ele é a forma recomendada e "
"segura de limpar atributos de dados de tipos arbitrários enquanto decrementa "
"suas contagens de referências. Se você chamasse :c:func:`Py_XDECREF` no "
"atributo antes de defini-lo como ``NULL``, haveria a possibilidade de que o "
"destrutor do atributo chamasse novamente algum código que lesse o atributo "
"(especialmente se houver um ciclo de referência)."

#: ../../extending/newtypes_tutorial.rst:780
msgid "You could emulate :c:func:`Py_CLEAR` by writing::"
msgstr "Você poderia emular :c:func:`Py_CLEAR` ao escrever::"

#: ../../extending/newtypes_tutorial.rst:782
msgid ""
"PyObject *tmp;\n"
"tmp = self->first;\n"
"self->first = NULL;\n"
"Py_XDECREF(tmp);"
msgstr ""
"PyObject *tmp;\n"
"tmp = self->first;\n"
"self->first = NULL;\n"
"Py_XDECREF(tmp);"

#: ../../extending/newtypes_tutorial.rst:787
msgid ""
"Nevertheless, it is much easier and less error-prone to always use :c:func:"
"`Py_CLEAR` when deleting an attribute.  Don't try to micro-optimize at the "
"expense of robustness!"
msgstr ""
"Apesar disso, é muito mais fácil e menos propenso a erros, usar sempre :c:"
"func:`Py_CLEAR` ao excluir um atributo. Não tente micro‐otimizar às custas "
"da robustez!"

#: ../../extending/newtypes_tutorial.rst:791
msgid ""
"The deallocator ``Custom_dealloc`` may call arbitrary code when clearing "
"attributes.  It means the circular GC can be triggered inside the function. "
"Since the GC assumes reference count is not zero, we need to untrack the "
"object from the GC by calling :c:func:`PyObject_GC_UnTrack` before clearing "
"members. Here is our reimplemented deallocator using :c:func:"
"`PyObject_GC_UnTrack` and ``Custom_clear``::"
msgstr ""
"O desalocador ``Custom_dealloc`` pode executar código arbitrário ao limpar "
"atributos. Isso significa que o GC pode ser acionado dentro da função. Como "
"o GC presume que a contagem de referências não é zero, precisamos remover o "
"objeto do rastreamento do GC chamando :c:func:`PyObject_GC_UnTrack` antes de "
"limpar os membros. A seguir está nossa versão reimplementada do desalocador "
"usando :c:func:`PyObject_GC_UnTrack` e ``Custom_clear``::"

#: ../../extending/newtypes_tutorial.rst:798
msgid ""
"static void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    PyObject_GC_UnTrack(op);\n"
"    (void)Custom_clear(op);\n"
"    Py_TYPE(op)->tp_free(op);\n"
"}"
msgstr ""
"static void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    PyObject_GC_UnTrack(op);\n"
"    (void)Custom_clear(op);\n"
"    Py_TYPE(op)->tp_free(op);\n"
"}"

#: ../../extending/newtypes_tutorial.rst:806
msgid ""
"Finally, we add the :c:macro:`Py_TPFLAGS_HAVE_GC` flag to the class flags::"
msgstr ""
"Por fim, adicionamos o macro :c:macro:`Py_TPFLAGS_HAVE_GC` aos sinalizadores "
"da classe::"

#: ../../extending/newtypes_tutorial.rst:808
msgid ""
".tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,"
msgstr ""
".tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,"

#: ../../extending/newtypes_tutorial.rst:810
msgid ""
"That's pretty much it.  If we had written custom :c:member:`~PyTypeObject."
"tp_alloc` or :c:member:`~PyTypeObject.tp_free` handlers, we'd need to modify "
"them for cyclic garbage collection.  Most extensions will use the versions "
"automatically provided."
msgstr ""
"Isso é praticamente tudo. Se tivéssemos escrito manipuladores personalizados "
"para :c:member:`~PyTypeObject.tp_alloc` ou :c:member:`~PyTypeObject."
"tp_free`, precisaríamos adaptá-los para a coleta de lixo cíclica. A maior "
"parte das extensões usará as versões fornecidas automaticamente."

#: ../../extending/newtypes_tutorial.rst:816
msgid "Subclassing other types"
msgstr "Criando subclasses de outros tipos"

#: ../../extending/newtypes_tutorial.rst:818
msgid ""
"It is possible to create new extension types that are derived from existing "
"types. It is easiest to inherit from the built in types, since an extension "
"can easily use the :c:type:`PyTypeObject` it needs. It can be difficult to "
"share these :c:type:`PyTypeObject` structures between extension modules."
msgstr ""
"É possível criar novos tipos de extensão derivados de tipos já existentes. É "
"mais fácil herdar dos tipos embutidos, já que uma extensão pode usar "
"diretamente o :c:type:`PyTypeObject` de que precisa. Pode ser difícil "
"compartilhar essas estruturas :c:type:`PyTypeObject` entre módulos de "
"extensão distintos."

#: ../../extending/newtypes_tutorial.rst:823
msgid ""
"In this example we will create a :class:`!SubList` type that inherits from "
"the built-in :class:`list` type. The new type will be completely compatible "
"with regular lists, but will have an additional :meth:`!increment` method "
"that increases an internal counter:"
msgstr ""
"Neste exemplo, criaremos um tipo :class:`!SubList` que herda do tipo "
"embutido :class:`list`. O novo tipo será totalmente compatível com listas "
"comuns, mas terá um método adicional, :meth:`!increment`, que incrementa um "
"contador interno:"

#: ../../extending/newtypes_tutorial.rst:828
msgid ""
">>> import sublist\n"
">>> s = sublist.SubList(range(3))\n"
">>> s.extend(s)\n"
">>> print(len(s))\n"
"6\n"
">>> print(s.increment())\n"
"1\n"
">>> print(s.increment())\n"
"2"
msgstr ""
">>> import sublist\n"
">>> s = sublist.SubList(range(3))\n"
">>> s.extend(s)\n"
">>> print(len(s))\n"
"6\n"
">>> print(s.increment())\n"
"1\n"
">>> print(s.increment())\n"
"2"

#: ../../extending/newtypes_tutorial.rst:840
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"typedef struct {\n"
"    PyListObject list;\n"
"    int state;\n"
"} SubListObject;\n"
"\n"
"static PyObject *\n"
"SubList_increment(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    SubListObject *self = (SubListObject *) op;\n"
"    self->state++;\n"
"    return PyLong_FromLong(self->state);\n"
"}\n"
"\n"
"static PyMethodDef SubList_methods[] = {\n"
"    {\"increment\", SubList_increment, METH_NOARGS,\n"
"     PyDoc_STR(\"increment state counter\")},\n"
"    {NULL},\n"
"};\n"
"\n"
"static int\n"
"SubList_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    SubListObject *self = (SubListObject *) op;\n"
"    if (PyList_Type.tp_init(op, args, kwds) < 0)\n"
"        return -1;\n"
"    self->state = 0;\n"
"    return 0;\n"
"}\n"
"\n"
"static PyTypeObject SubListType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"sublist.SubList\",\n"
"    .tp_doc = PyDoc_STR(\"SubList objects\"),\n"
"    .tp_basicsize = sizeof(SubListObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_init = SubList_init,\n"
"    .tp_methods = SubList_methods,\n"
"};\n"
"\n"
"static int\n"
"sublist_module_exec(PyObject *m)\n"
"{\n"
"    SubListType.tp_base = &PyList_Type;\n"
"    if (PyType_Ready(&SubListType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) < "
"0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot sublist_module_slots[] = {\n"
"    {Py_mod_exec, sublist_module_exec},\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static PyModuleDef sublist_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"sublist\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = 0,\n"
"    .m_slots = sublist_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_sublist(void)\n"
"{\n"
"    return PyModuleDef_Init(&sublist_module);\n"
"}\n"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"typedef struct {\n"
"    PyListObject list;\n"
"    int state;\n"
"} SubListObject;\n"
"\n"
"static PyObject *\n"
"SubList_increment(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    SubListObject *self = (SubListObject *) op;\n"
"    self->state++;\n"
"    return PyLong_FromLong(self->state);\n"
"}\n"
"\n"
"static PyMethodDef SubList_methods[] = {\n"
"    {\"increment\", SubList_increment, METH_NOARGS,\n"
"     PyDoc_STR(\"increment state counter\")},\n"
"    {NULL},\n"
"};\n"
"\n"
"static int\n"
"SubList_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    SubListObject *self = (SubListObject *) op;\n"
"    if (PyList_Type.tp_init(op, args, kwds) < 0)\n"
"        return -1;\n"
"    self->state = 0;\n"
"    return 0;\n"
"}\n"
"\n"
"static PyTypeObject SubListType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"sublist.SubList\",\n"
"    .tp_doc = PyDoc_STR(\"SubList objects\"),\n"
"    .tp_basicsize = sizeof(SubListObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_init = SubList_init,\n"
"    .tp_methods = SubList_methods,\n"
"};\n"
"\n"
"static int\n"
"sublist_module_exec(PyObject *m)\n"
"{\n"
"    SubListType.tp_base = &PyList_Type;\n"
"    if (PyType_Ready(&SubListType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) < "
"0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot sublist_module_slots[] = {\n"
"    {Py_mod_exec, sublist_module_exec},\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static PyModuleDef sublist_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"sublist\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = 0,\n"
"    .m_slots = sublist_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_sublist(void)\n"
"{\n"
"    return PyModuleDef_Init(&sublist_module);\n"
"}\n"

#: ../../extending/newtypes_tutorial.rst:843
msgid ""
"As you can see, the source code closely resembles the :class:`!Custom` "
"examples in previous sections. We will break down the main differences "
"between them. ::"
msgstr ""
"Como você pode consultar, o código-fonte se assemelha bastante aos exemplos "
"de :class:`!Custom` das seções anteriores. Vamos detalhar as principais "
"diferenças entre eles. ::"

#: ../../extending/newtypes_tutorial.rst:846
msgid ""
"typedef struct {\n"
"    PyListObject list;\n"
"    int state;\n"
"} SubListObject;"
msgstr ""
"typedef struct {\n"
"    PyListObject list;\n"
"    int state;\n"
"} SubListObject;"

#: ../../extending/newtypes_tutorial.rst:851
msgid ""
"The primary difference for derived type objects is that the base type's "
"object structure must be the first value.  The base type will already "
"include the :c:func:`PyObject_HEAD` at the beginning of its structure."
msgstr ""
"A diferença principal para objetos de tipos derivados é que a estrutura de "
"objeto do tipo base deve ser o primeiro valor. O tipo base já inclui o :c:"
"func:`PyObject_HEAD` no início de sua própria estrutura."

#: ../../extending/newtypes_tutorial.rst:855
msgid ""
"When a Python object is a :class:`!SubList` instance, its ``PyObject *`` "
"pointer can be safely cast to both ``PyListObject *`` and ``SubListObject "
"*``::"
msgstr ""
"Quando um objeto Python é uma instância de :class:`!SubList`, seu ponteiro "
"``PyObject *`` pode ser convertido com segurança tanto para ``PyListObject "
"*`` quanto para ``SubListObject *``::"

#: ../../extending/newtypes_tutorial.rst:858
msgid ""
"static int\n"
"SubList_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    SubListObject *self = (SubListObject *) op;\n"
"    if (PyList_Type.tp_init(op, args, kwds) < 0)\n"
"        return -1;\n"
"    self->state = 0;\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"SubList_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    SubListObject *self = (SubListObject *) op;\n"
"    if (PyList_Type.tp_init(op, args, kwds) < 0)\n"
"        return -1;\n"
"    self->state = 0;\n"
"    return 0;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:868
msgid ""
"We see above how to call through to the :meth:`~object.__init__` method of "
"the base type."
msgstr ""
"Vemos acima como chamar o método :meth:`~object.__init__` do tipo base."

#: ../../extending/newtypes_tutorial.rst:871
msgid ""
"This pattern is important when writing a type with custom :c:member:"
"`~PyTypeObject.tp_new` and :c:member:`~PyTypeObject.tp_dealloc` members.  "
"The :c:member:`~PyTypeObject.tp_new` handler should not actually create the "
"memory for the object with its :c:member:`~PyTypeObject.tp_alloc`, but let "
"the base class handle it by calling its own :c:member:`~PyTypeObject.tp_new`."
msgstr ""
"Esse padrão é importante ao escrever um tipo que possui membros "
"personalizados em :c:member:`~PyTypeObject.tp_new` e :c:member:"
"`~PyTypeObject.tp_dealloc`. O manipulador :c:member:`~PyTypeObject.tp_new` "
"não deve realmente criar a memória do objeto usando o seu próprio :c:member:"
"`~PyTypeObject.tp_alloc`; em vez disso, deve permitir que a classe base faça "
"isso, chamando o seu próprio :c:member:`~PyTypeObject.tp_new`."

#: ../../extending/newtypes_tutorial.rst:877
msgid ""
"The :c:type:`PyTypeObject` struct supports a :c:member:`~PyTypeObject."
"tp_base` specifying the type's concrete base class.  Due to cross-platform "
"compiler issues, you can't fill that field directly with a reference to :c:"
"type:`PyList_Type`; it should be done in the :c:data:`Py_mod_exec` function::"
msgstr ""
"A estrutura :c:type:`PyTypeObject` provê o campo :c:member:`~PyTypeObject."
"tp_base`, que especifica a classe base concreta do tipo. Devido a problemas "
"de compilação multiplataforma, não se deve preencher esse campo diretamente "
"com uma referência para :c:type:`PyList_Type`; isso deve ser feito dentro da "
"função :c:data:`Py_mod_exec`::"

#: ../../extending/newtypes_tutorial.rst:883
msgid ""
"static int\n"
"sublist_module_exec(PyObject *m)\n"
"{\n"
"    SubListType.tp_base = &PyList_Type;\n"
"    if (PyType_Ready(&SubListType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) < "
"0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"sublist_module_exec(PyObject *m)\n"
"{\n"
"    SubListType.tp_base = &PyList_Type;\n"
"    if (PyType_Ready(&SubListType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) < "
"0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:898
msgid ""
"Before calling :c:func:`PyType_Ready`, the type structure must have the :c:"
"member:`~PyTypeObject.tp_base` slot filled in.  When we are deriving an "
"existing type, it is not necessary to fill out the :c:member:`~PyTypeObject."
"tp_alloc` slot with :c:func:`PyType_GenericNew` -- the allocation function "
"from the base type will be inherited."
msgstr ""
"Antes de chamar :c:func:`PyType_Ready`, a estrutura do tipo deve ter o slot :"
"c:member:`~PyTypeObject.tp_base` preenchido. Ao derivarmos um tipo "
"existente, não é necessário preencher o slot :c:member:`~PyTypeObject."
"tp_alloc` com :c:func:`PyType_GenericNew` — a função de alocação do tipo "
"base será herdada."

#: ../../extending/newtypes_tutorial.rst:904
msgid ""
"After that, calling :c:func:`PyType_Ready` and adding the type object to the "
"module is the same as with the basic :class:`!Custom` examples."
msgstr ""
"Depois disso, chamar :c:func:`PyType_Ready` e adicionar o objeto de tipo ao "
"módulo é o mesmo processo usado nos exemplos básicos com :class:`!Custom`."

#: ../../extending/newtypes_tutorial.rst:909
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../extending/newtypes_tutorial.rst:910
msgid ""
"This is true when we know that the object is a basic type, like a string or "
"a float."
msgstr ""
"Isso é verdade quando sabemos que o objeto é um tipo básico, como uma string "
"ou um float."

#: ../../extending/newtypes_tutorial.rst:913
msgid ""
"We relied on this in the :c:member:`~PyTypeObject.tp_dealloc` handler in "
"this example, because our type doesn't support garbage collection."
msgstr ""
"Confiamos nisso no manipulador :c:member:`~PyTypeObject.tp_dealloc` neste "
"exemplo, porque o nosso tipo não oferece suporte à coleta de lixo."

#: ../../extending/newtypes_tutorial.rst:916
msgid ""
"We now know that the first and last members are strings, so perhaps we could "
"be less careful about decrementing their reference counts, however, we "
"accept instances of string subclasses.  Even though deallocating normal "
"strings won't call back into our objects, we can't guarantee that "
"deallocating an instance of a string subclass won't call back into our "
"objects."
msgstr ""
"Agora sabemos que o primeiro e último membros são strings, então talvez "
"pudéssemos ter menos cuidado com a diminuição de suas contagens de "
"referência, no entanto, aceitamos instâncias de subclasses de string. Mesmo "
"que a desalocação de strings normais não retorne aos nossos objetos, não "
"podemos garantir que a desalocação de uma instância de uma subclasse de "
"cadeias de caracteres não retornará aos nossos objetos."

#: ../../extending/newtypes_tutorial.rst:922
msgid ""
"Also, even with our attributes restricted to strings instances, the user "
"could pass arbitrary :class:`str` subclasses and therefore still create "
"reference cycles."
msgstr ""
"Além disso, mesmo com nossos atributos restritos a instâncias de strings, o "
"usuário poderia passar arbitrariamente subclasses :class:`str` e, portanto, "
"ainda criar ciclos de referência."

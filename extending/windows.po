# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-20 14:57+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../extending/windows.rst:8
msgid "Building C and C++ Extensions on Windows"
msgstr "Construindo Extensões C e C++ no Windows"

#: ../../extending/windows.rst:10
msgid ""
"This chapter briefly explains how to create a Windows extension module for "
"Python using Microsoft Visual C++, and follows with more detailed background "
"information on how it works.  The explanatory material is useful for both "
"the Windows programmer learning to build Python extensions and the Unix "
"programmer interested in producing software which can be successfully built "
"on both Unix and Windows."
msgstr ""
"Este capítulo explica brevemente como criar um módulo de extensão do Windows "
"para Python usando o Microsoft Visual C++ e segue com informações mais "
"detalhadas sobre como ele funciona. O material explicativo é útil para o "
"programador do Windows aprender a construir extensões Python e o programador "
"Unix interessado em produzir software que possa ser construído com sucesso "
"no Unix e no Windows."

#: ../../extending/windows.rst:17
msgid ""
"Module authors are encouraged to use the distutils approach for building "
"extension modules, instead of the one described in this section. You will "
"still need the C compiler that was used to build Python; typically Microsoft "
"Visual C++."
msgstr ""
"Os autores de módulos são encorajados a usar a abordagem distutils para "
"construir módulos de extensão, em vez daquele descrito nesta seção. Você "
"ainda precisará do compilador C que foi usado para construir o Python; "
"normalmente o Microsoft Visual C++."

#: ../../extending/windows.rst:24
msgid ""
"This chapter mentions a number of filenames that include an encoded Python "
"version number.  These filenames are represented with the version number "
"shown as ``XY``; in practice, ``'X'`` will be the major version number and "
"``'Y'`` will be the minor version number of the Python release you're "
"working with.  For example, if you are using Python 2.2.1, ``XY`` will "
"actually be ``22``."
msgstr ""
"Este capítulo menciona vários nomes de arquivos que incluem um número de "
"versão do Python codificado. Esses nomes de arquivos são representados com o "
"número da versão mostrado como ``XY``; na prática, ``'X'`` será o número da "
"versão principal e ``'Y'`` será o número da versão secundária da versão do "
"Python com a qual você está trabalhando. Por exemplo, se você estiver usando "
"o Python 2.2.1, ``XY`` será ``22``."

#: ../../extending/windows.rst:34
msgid "A Cookbook Approach"
msgstr "Uma abordagem de livro de receitas"

#: ../../extending/windows.rst:36
msgid ""
"There are two approaches to building extension modules on Windows, just as "
"there are on Unix: use the ``setuptools`` package to control the build "
"process, or do things manually.  The setuptools approach works well for most "
"extensions; documentation on using ``setuptools`` to build and package "
"extension modules is available in :ref:`setuptools-index`.  If you find you "
"really need to do things manually, it may be instructive to study the "
"project file for the :source:`winsound <PCbuild/winsound.vcxproj>` standard "
"library module."
msgstr ""
"Existem duas abordagens para construir módulos de extensão no Windows, assim "
"como no Unix: use o pacote ``setuptools`` para controlar o processo de "
"construção ou faça as coisas manualmente. A abordagem setuptools funciona "
"bem para a maioria das extensões; documentação sobre o uso de ``setuptools`` "
"para construir e empacotar módulos de extensão está disponível em :ref:"
"`setuptools-index`. Se você achar que realmente precisa fazer as coisas "
"manualmente, pode ser instrutivo estudar o arquivo do projeto para o módulo "
"de biblioteca padrão :source:`winsound <PCbuild/winsound.vcxproj>`."

#: ../../extending/windows.rst:48
msgid "Differences Between Unix and Windows"
msgstr "Diferenças entre o Unix e o Windows"

#: ../../extending/windows.rst:53
msgid ""
"Unix and Windows use completely different paradigms for run-time loading of "
"code.  Before you try to build a module that can be dynamically loaded, be "
"aware of how your system works."
msgstr ""
"O Unix e o Windows usam paradigmas completamente diferentes para o "
"carregamento do código em tempo de execução. Antes de tentar construir um "
"módulo que possa ser carregado dinamicamente, esteja ciente de como o seu "
"sistema funciona."

#: ../../extending/windows.rst:57
msgid ""
"In Unix, a shared object (:file:`.so`) file contains code to be used by the "
"program, and also the names of functions and data that it expects to find in "
"the program.  When the file is joined to the program, all references to "
"those functions and data in the file's code are changed to point to the "
"actual locations in the program where the functions and data are placed in "
"memory. This is basically a link operation."
msgstr ""
"No Unix, um arquivo de objeto compartilhado (:file:`.so`) contém código a "
"ser usado pelo programa e também os nomes de funções e dados que ele espera "
"encontrar no programa. Quando o arquivo é associado ao programa, todas as "
"referências a essas funções e dados no código do arquivo são alteradas para "
"apontar para os locais reais no programa em que as funções e os dados são "
"colocados na memória. Isso é basicamente uma operação de vinculação."

#: ../../extending/windows.rst:64
msgid ""
"In Windows, a dynamic-link library (:file:`.dll`) file has no dangling "
"references.  Instead, an access to functions or data goes through a lookup "
"table.  So the DLL code does not have to be fixed up at runtime to refer to "
"the program's memory; instead, the code already uses the DLL's lookup table, "
"and the lookup table is modified at runtime to point to the functions and "
"data."
msgstr ""
"No Windows, um arquivo de biblioteca de vínculo dinâmico (:file:`.dll`) não "
"possui referências pendentes. Em vez disso, um acesso a funções ou dados "
"passa por uma tabela de pesquisa. Portanto, o código DLL não precisa ser "
"corrigido no tempo de execução para se referir à memória do programa; em vez "
"disso, o código já usa a tabela de pesquisa da DLL e a tabela de pesquisa é "
"modificada em tempo de execução para apontar para as funções e dados."

#: ../../extending/windows.rst:70
msgid ""
"In Unix, there is only one type of library file (:file:`.a`) which contains "
"code from several object files (:file:`.o`).  During the link step to create "
"a shared object file (:file:`.so`), the linker may find that it doesn't know "
"where an identifier is defined.  The linker will look for it in the object "
"files in the libraries; if it finds it, it will include all the code from "
"that object file."
msgstr ""
"No Unix, existe apenas um tipo de arquivo de biblioteca (:file:`.a`) que "
"contém código de vários arquivos de objetos (:file:`.o`). Durante a etapa da "
"vinculação para criar um arquivo de objeto compartilhado (:file:`.so`), o "
"vinculador pode achar que não sabe onde um identificador está definido. O "
"vinculador procurará nos arquivos de objeto nas bibliotecas; se encontrar, "
"incluirá todo o código desse arquivo de objeto."

#: ../../extending/windows.rst:76
msgid ""
"In Windows, there are two types of library, a static library and an import "
"library (both called :file:`.lib`).  A static library is like a Unix :file:`."
"a` file; it contains code to be included as necessary. An import library is "
"basically used only to reassure the linker that a certain identifier is "
"legal, and will be present in the program when the DLL is loaded.  So the "
"linker uses the information from the import library to build the lookup "
"table for using identifiers that are not included in the DLL.  When an "
"application or a DLL is linked, an import library may be generated, which "
"will need to be used for all future DLLs that depend on the symbols in the "
"application or DLL."
msgstr ""
"No Windows, existem dois tipos de biblioteca, uma biblioteca estática e uma "
"biblioteca de importação (ambas chamadas :file:`.lib`). Uma biblioteca "
"estática é como um arquivo Unix :file:`.a`; contém código a ser incluído "
"conforme necessário. Uma biblioteca de importação é basicamente usada apenas "
"para garantir ao vinculador que um determinado identificador é legal e "
"estará presente no programa quando a DLL for carregada. Portanto, o "
"vinculador usa as informações da biblioteca de importação para construir a "
"tabela de pesquisa para o uso de identificadores que não estão incluídos na "
"DLL. Quando uma aplicação ou uma DLL é vinculado, pode ser gerada uma "
"biblioteca de importação, que precisará ser usada para todas as DLLs futuras "
"que dependem dos símbolos na aplicação ou DLL."

#: ../../extending/windows.rst:86
msgid ""
"Suppose you are building two dynamic-load modules, B and C, which should "
"share another block of code A.  On Unix, you would *not* pass :file:`A.a` to "
"the linker for :file:`B.so` and :file:`C.so`; that would cause it to be "
"included twice, so that B and C would each have their own copy.  In Windows, "
"building :file:`A.dll` will also build :file:`A.lib`.  You *do* pass :file:"
"`A.lib` to the linker for B and C.  :file:`A.lib` does not contain code; it "
"just contains information which will be used at runtime to access A's code."
msgstr ""
"Suponha que você esteja construindo dois módulos de carregamento dinâmico, B "
"e C, que devem compartilhar outro bloco de código A. No Unix, você *não* "
"passaria :file:`A.a` ao vinculador para :file:`B.so` e :file:`C.so`; isso "
"faria com que fosse incluído duas vezes, para que B e C tivessem sua própria "
"cópia. No Windows, a construção :file:`A.dll` também construirá :file:`A."
"lib`. Você *passa* :file:`A.lib` ao vinculador para B e C. :file:`A.lib` não "
"contém código; apenas contém informações que serão usadas em tempo de "
"execução para acessar o código de A."

#: ../../extending/windows.rst:94
msgid ""
"In Windows, using an import library is sort of like using ``import spam``; "
"it gives you access to spam's names, but does not create a separate copy.  "
"On Unix, linking with a library is more like ``from spam import *``; it does "
"create a separate copy."
msgstr ""
"No Windows, usar uma biblioteca de importação é como usar ``import spam``; "
"fornece acesso aos nomes de spam, mas não cria uma cópia separada. No Unix, "
"vincular a uma biblioteca é mais como ``from spam import *``; ele cria uma "
"cópia separada."

#: ../../extending/windows.rst:103
msgid "Using DLLs in Practice"
msgstr "Usando DLLs na prática"

#: ../../extending/windows.rst:108
msgid ""
"Windows Python is built in Microsoft Visual C++; using other compilers may "
"or may not work.  The rest of this section is MSVC++ specific."
msgstr ""
"O Python para Windows é criado no Microsoft Visual C++; o uso de outros "
"compiladores pode ou não funcionar. O restante desta seção é específico do "
"MSVC++."

#: ../../extending/windows.rst:111
msgid ""
"When creating DLLs in Windows, you must pass :file:`pythonXY.lib` to the "
"linker. To build two DLLs, spam and ni (which uses C functions found in "
"spam), you could use these commands::"
msgstr ""
"Ao criar DLLs no Windows, você deve passar :file:`pythonXY.lib` para o "
"vinculador. Para construir duas DLLs, spam e ni (que usa funções C "
"encontradas em spam), você pode usar estes comandos::"

#: ../../extending/windows.rst:115
msgid ""
"cl /LD /I/python/include spam.c ../libs/pythonXY.lib\n"
"cl /LD /I/python/include ni.c spam.lib ../libs/pythonXY.lib"
msgstr ""
"cl /LD /I/python/include spam.c ../libs/pythonXY.lib\n"
"cl /LD /I/python/include ni.c spam.lib ../libs/pythonXY.lib"

#: ../../extending/windows.rst:118
msgid ""
"The first command created three files: :file:`spam.obj`, :file:`spam.dll` "
"and :file:`spam.lib`.  :file:`Spam.dll` does not contain any Python "
"functions (such as :c:func:`PyArg_ParseTuple`), but it does know how to find "
"the Python code thanks to :file:`pythonXY.lib`."
msgstr ""
"O primeiro comando criou três arquivos: :file:`spam.obj`, :file:`spam.dll` "
"e :file:`spam.lib`. O :file:`spam.dll` não contém nenhuma função Python "
"(como :c:func:`PyArg_ParseTuple`), mas sabe como encontrar o código Python "
"graças a :file:`pythonXY.lib`."

#: ../../extending/windows.rst:123
msgid ""
"The second command created :file:`ni.dll` (and :file:`.obj` and :file:`."
"lib`), which knows how to find the necessary functions from spam, and also "
"from the Python executable."
msgstr ""
"O segundo comando criou :file:`ni.dll` (e :file:`.obj` e :file:`.lib`), que "
"sabe como encontrar as funções necessárias do spam e também do executável do "
"Python."

#: ../../extending/windows.rst:127
msgid ""
"Not every identifier is exported to the lookup table.  If you want any other "
"modules (including Python) to be able to see your identifiers, you have to "
"say ``_declspec(dllexport)``, as in ``void _declspec(dllexport) "
"initspam(void)`` or ``PyObject _declspec(dllexport) *NiGetSpamData(void)``."
msgstr ""
"Nem todo identificador é exportado para a tabela de pesquisa. Se você deseja "
"que outros módulos (incluindo Python) possam ver seus identificadores, é "
"necessário dizer ``_declspec(dllexport)``, como em ``void "
"_declspec(dllexport) initspam(void)`` ou ``PyObject _declspec(dllexport) "
"*NiGetSpamData(void)``."

#: ../../extending/windows.rst:132
msgid ""
"Developer Studio will throw in a lot of import libraries that you do not "
"really need, adding about 100K to your executable.  To get rid of them, use "
"the Project Settings dialog, Link tab, to specify *ignore default "
"libraries*.  Add the correct :file:`msvcrt{xx}.lib` to the list of libraries."
msgstr ""
"O Developer Studio incluirá muitas bibliotecas importadas que você realmente "
"não precisa, adicionando cerca de 100K ao seu executável.  Para se livrar "
"delas, use a caixa de diálogo de configurações do projeto, na aba vincular, "
"para especificar *ignorar bibliotecas padrão*.  Adicione o :file:`msvcrt{xx}."
"lib` correto à lista de bibliotecas."

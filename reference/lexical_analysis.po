# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Welington Carlos <wcarlos3@gmail.com>, 2017
# Misael borges <misael@planosassessoria.com.br>, 2017
# (Douglas da Silva) <dementikovalev@yandex.ru>, 2017
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2017
# Vinicius Gubiani Ferreira <vini.g.fer@gmail.com>, 2020
# Adorilson Bezerra <adorilson@gmail.com>, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-03-28 17:02+0000\n"
"PO-Revision-Date: 2017-02-16 23:39+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr "Análise léxica"

#: ../../reference/lexical_analysis.rst:10
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr ""
"Um programa Python é lido por um *analisador*. A entrada para o analisador é "
"um fluxo de *tokens*, gerado pelo *analisador léxico*. Este capítulo "
"descreve como o analisador léxico divide um arquivo em tokens."

#: ../../reference/lexical_analysis.rst:14
msgid ""
"Python reads program text as Unicode code points; the encoding of a source "
"file can be given by an encoding declaration and defaults to UTF-8, see :pep:"
"`3120` for details.  If the source file cannot be decoded, a :exc:"
"`SyntaxError` is raised."
msgstr ""
"Python lê o texto do programa como pontos de código Unicode; a codificação "
"de um arquivo de origem pode ser fornecida por uma declaração de codificação "
"que por padrão é UTF-8, consulte :pep:`3120` para obter detalhes. Se o "
"arquivo de origem não puder ser decodificado, uma exceção :exc:`SyntaxError` "
"será levantada."

#: ../../reference/lexical_analysis.rst:23
msgid "Line structure"
msgstr "Estrutura das linhas"

#: ../../reference/lexical_analysis.rst:27
msgid "A Python program is divided into a number of *logical lines*."
msgstr "Um programa Python é dividido em uma série de *linhas lógicas*."

#: ../../reference/lexical_analysis.rst:33
msgid "Logical lines"
msgstr "Linhas lógicas"

#: ../../reference/lexical_analysis.rst:37
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr ""
"O fim de uma linha lógica é representado pelo token NEWLINE. As declarações "
"não podem cruzar os limites da linha lógica, exceto onde NEWLINE for "
"permitido pela sintaxe (por exemplo, entre as declarações de declarações "
"compostas). Uma linha lógica é construída a partir de uma ou mais *linhas "
"físicas* seguindo as regras explícitas ou implícitas que *juntam as linhas*."

#: ../../reference/lexical_analysis.rst:47
msgid "Physical lines"
msgstr "Linhas físicas"

#: ../../reference/lexical_analysis.rst:49
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files and strings, any of the standard platform line "
"termination sequences can be used - the Unix form using ASCII LF (linefeed), "
"the Windows form using the ASCII sequence CR LF (return followed by "
"linefeed), or the old Macintosh form using the ASCII CR (return) character.  "
"All of these forms can be used equally, regardless of platform. The end of "
"input also serves as an implicit terminator for the final physical line."
msgstr ""
"Uma linha física é uma sequência de caracteres terminada por uma sequência "
"de fim de linha. Nos arquivos de origem e cadeias de caracteres, qualquer "
"uma das sequências de terminação de linha de plataforma padrão pode ser "
"usada - o formato Unix usando ASCII LF (linefeed), o formato Windows usando "
"a sequência ASCII CR LF (return seguido de linefeed) ou o antigo formato "
"Macintosh usando o caractere ASCII CR (return). Todos esses formatos podem "
"ser usados igualmente, independentemente da plataforma. O final da entrada "
"também serve como um finalizador implícito para a linha física final."

#: ../../reference/lexical_analysis.rst:57
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr ""
"Ao incorporar o Python, strings de código-fonte devem ser passadas para APIs "
"do Python usando as convenções C padrão para caracteres de nova linha (o "
"caractere ``\\n``, representando ASCII LF, será o terminador de linha)."

#: ../../reference/lexical_analysis.rst:65
msgid "Comments"
msgstr "Comentários"

#: ../../reference/lexical_analysis.rst:70
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax."
msgstr ""
"Um  comentário inicia com um caracter cerquilha (``#``) que não é parte de "
"uma string literal, e termina com o fim da linha física.  Um comentário "
"significa o fim da linha lógica a menos que regras de junção de linha "
"implicitas sejam invocadas. Comentários são ignorados pela sintaxe."

#: ../../reference/lexical_analysis.rst:79
msgid "Encoding declarations"
msgstr "Declarações de codificação"

#: ../../reference/lexical_analysis.rst:84
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""
"Se um comentário na primeira ou segunda linha de um script Python "
"corresponde com a expressão regular  ``coding[=:]\\s*([-\\w.]+)``, esse "
"comentário é processado com uma declaração de codificação; o primeiro grupo "
"dessa expressão indica a codificação do arquivo do código-fonte. A "
"declaração de codificação deve aparecer em uma linha exclusiva para tal. Se "
"está na segunda linha, a primeira linha também deve ser uma linha somente "
"com comentário. As formas recomendadas de uma declaração de codificação são:"

#: ../../reference/lexical_analysis.rst:93
msgid "which is recognized also by GNU Emacs, and ::"
msgstr "que é reconhecido também por GNU Emacs, e ::"

#: ../../reference/lexical_analysis.rst:97
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr "que é reconhecido pelo VIM de Bram Moolenaar."

#: ../../reference/lexical_analysis.rst:99
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  In "
"addition, if the first bytes of the file are the UTF-8 byte-order mark "
"(``b'\\xef\\xbb\\xbf'``), the declared file encoding is UTF-8 (this is "
"supported, among others, by Microsoft's :program:`notepad`)."
msgstr ""
"Se nenhuma declaração de codificação é encontrada, a codificação padrão é "
"UTF-8.  Adicionalmente, se os primeiros bytes do arquivo são a marca de "
"ordem de byte (BOM) do UTF-8 (``b'\\xef\\xbb\\xbf'``), a codificação de "
"arquivo declarada é UTF-8 (isto é  suportado, entre outros, pelo :program:"
"`notepad` da Microsoft)."

#: ../../reference/lexical_analysis.rst:104
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python "
"(see :ref:`standard-encodings`). The encoding is used for all lexical "
"analysis, including string literals, comments and identifiers."
msgstr ""
"Se uma codificação é declarada, o nome da codificação deve ser reconhecida "
"pelo Python (veja :ref:`standard-encodings`). A codificação é usada por toda "
"análise léxica, incluindo literais strings, comment and identificadores."

#: ../../reference/lexical_analysis.rst:113
msgid "Explicit line joining"
msgstr "Junção de linha explícita"

#: ../../reference/lexical_analysis.rst:117
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""
"Duas ou mais linhas físicas podem ser juntadas em linhas lógicas usando o "
"caractere contrabarra  (``\\``) da seguinte forma: quando uma linha física "
"termina com uma contrabarra que não é parte da uma literal string ou "
"comentário, ela é juntada com a linha seguinte formando uma única linha "
"lógica, removendo a contrabarra e o caractere de fim de linha seguinte. Por "
"exemplo::"

#: ../../reference/lexical_analysis.rst:128
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string "
"literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""
"Uma linha terminada em uma contrabarra não pode conter um comentário.  Uma "
"barra invertida não continua um comentário.  Uma contrabarra não continua um "
"token, exceto para strings literais (ou seja, tokens diferentes de strings "
"literais não podem ser divididos em linhas físicas usando uma contrabarra).  "
"Uma contrabarra é ilegal em qualquer outro lugar em uma linha fora de uma "
"string literal."

#: ../../reference/lexical_analysis.rst:138
msgid "Implicit line joining"
msgstr "Junção de linha implícita"

#: ../../reference/lexical_analysis.rst:140
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""
"Expressões entre parênteses, colchetes ou chaves podem ser quebradas em mais "
"de uma linha física sem a necessidade do uso de contrabarras. Por exemplo::"

#: ../../reference/lexical_analysis.rst:148
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""
"Linhas continuadas implicitamente podem conter comentários. O recuo das "
"linhas de continuação não é importante. Linhas de continuação em branco são "
"permitidas. Não há token NEWLINE entre linhas de continuação implícitas. "
"Linhas continuadas implicitamente também podem ocorrer dentro de strings com "
"aspas triplas (veja abaixo); nesse caso, eles não podem conter comentários."

#: ../../reference/lexical_analysis.rst:158
msgid "Blank lines"
msgstr "Linhas em branco"

#: ../../reference/lexical_analysis.rst:162
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard interactive interpreter, an entirely blank logical line (i.e. one "
"containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""
"Uma linha lógica que contém apenas espaços, tabulações, quebras de página e "
"possivelmente um comentário é ignorada (ou seja, nenhum token NEWLINE é "
"gerado). Durante a entrada interativa de instruções, o tratamento de uma "
"linha em branco pode diferir dependendo da implementação do interpretador. "
"No interpretador interativo padrão, uma linha lógica totalmente em branco "
"(ou seja, uma que não contenha nem mesmo espaço em branco ou um comentário) "
"encerra uma instrução de várias linhas."

#: ../../reference/lexical_analysis.rst:173
msgid "Indentation"
msgstr "Indentação"

#: ../../reference/lexical_analysis.rst:177
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr ""
"O espaço em branco (espaços e tabulações) no início de uma linha lógica é "
"usado para calcular o nível de indentação da linha, que por sua vez é usado "
"para determinar o agrupamento de instruções."

#: ../../reference/lexical_analysis.rst:181
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that the "
"total number of characters up to and including the replacement is a multiple "
"of eight (this is intended to be the same rule as used by Unix).  The total "
"number of spaces preceding the first non-blank character then determines the "
"line's indentation.  Indentation cannot be split over multiple physical "
"lines using backslashes; the whitespace up to the first backslash determines "
"the indentation."
msgstr ""
"As tabulações são substituídas (da esquerda para a direita) por um a oito "
"espaços, de modo que o número total de caracteres até e incluindo a "
"substituição seja um múltiplo de oito (essa é intencionalmente a mesma regra "
"usada pelo Unix). O número total de espaços que precedem o primeiro "
"caractere não em branco determina o recuo da linha. O recuo não pode ser "
"dividido em várias linhas físicas usando contrabarra; o espaço em branco até "
"a primeira contrabarra determina a indentação."

#: ../../reference/lexical_analysis.rst:189
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in "
"spaces; a :exc:`TabError` is raised in that case."
msgstr ""
"A indentação é rejeitada como inconsistente se um arquivo de origem mistura "
"tabulações e espaços de uma forma que torna o significado dependente do "
"valor de uma tabulação em espaços; uma exceção :exc:`TabError` é levantada "
"nesse caso."

#: ../../reference/lexical_analysis.rst:193
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors "
"on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for "
"the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""
"**Nota de compatibilidade entre plataformas:** devido à natureza dos "
"editores de texto em plataformas não-UNIX, não é aconselhável usar uma "
"mistura de espaços e tabulações para o recuo em um único arquivo de origem. "
"Deve-se notar também que diferentes plataformas podem limitar explicitamente "
"o nível máximo de indentação."

#: ../../reference/lexical_analysis.rst:198
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""
"Um caractere de quebra de página pode estar presente no início da linha; ele "
"será ignorado para os cálculos de indentação acima. Os caracteres de quebra "
"de página que ocorrem em outro lugar além do espaço em branco inicial têm um "
"efeito indefinido (por exemplo, eles podem redefinir a contagem de espaços "
"para zero)."

#: ../../reference/lexical_analysis.rst:205
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr ""
"Os níveis de indentação das linhas consecutivas são usados para gerar tokens "
"INDENT e DEDENT, usando uma pilha, como segue."

#: ../../reference/lexical_analysis.rst:208
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack "
"will always be strictly increasing from bottom to top.  At the beginning of "
"each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on "
"the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr ""
"Antes da leitura da primeira linha do arquivo, um único zero é colocado na "
"pilha; isso nunca mais será exibido. Os números colocados na pilha sempre "
"aumentarão estritamente de baixo para cima. No início de cada linha lógica, "
"o nível de indentação da linha é comparado ao topo da pilha. Se for igual, "
"nada acontece. Se for maior, ele é colocado na pilha e um token INDENT é "
"gerado. Se for menor, *deve* ser um dos números que aparecem na pilha; todos "
"os números maiores na pilha são retirados e, para cada número retirado, um "
"token DEDENT é gerado. Ao final do arquivo, um token DEDENT é gerado para "
"cada número restante na pilha que seja maior que zero."

#: ../../reference/lexical_analysis.rst:219
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr ""
"Aqui está um exemplo de um trecho de código Python indentado corretamente "
"(embora confuso):"

#: ../../reference/lexical_analysis.rst:234
msgid "The following example shows various indentation errors::"
msgstr "O exemplo a seguir mostra vários erros de indentação:"

#: ../../reference/lexical_analysis.rst:244
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""
"(Na verdade, os três primeiros erros são detectados pelo analisador "
"sintático; apenas o último erro é encontrado pelo analisador léxico --- o "
"recuo de não corresponde a um nível retirado da pilha.)"

#: ../../reference/lexical_analysis.rst:252
msgid "Whitespace between tokens"
msgstr "Espaços em branco entre tokens"

#: ../../reference/lexical_analysis.rst:254
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to "
"separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr ""
"Exceto no início de uma linha lógica ou em string literais, os caracteres de "
"espaço em branco (espaço, tabulação e quebra de página) podem ser usados "
"alternadamente para separar tokens. O espaço em branco é necessário entre "
"dois tokens somente se sua concatenação puder ser interpretada como um token "
"diferente (por exemplo, ab é um token, mas a b são dois tokens)."

#: ../../reference/lexical_analysis.rst:264
msgid "Other tokens"
msgstr "Outros tokens"

#: ../../reference/lexical_analysis.rst:266
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. "
"Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr ""
"Além de NEWLINE, INDENT e DEDENT, existem as seguintes categorias de tokens: "
"*identificadores*, *palavras-chave*, *literais*, *operadores* e "
"*delimitadores*. Caracteres de espaço em branco (exceto terminadores de "
"linha, discutidos anteriormente) não são tokens, mas servem para delimitar "
"tokens. Onde existe ambiguidade, um token compreende a string mais longa "
"possível que forma um token legal, quando lido da esquerda para a direita."

#: ../../reference/lexical_analysis.rst:276
msgid "Identifiers and keywords"
msgstr "Identificadores e palavras-chave"

#: ../../reference/lexical_analysis.rst:280
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions."
msgstr ""
"Identificadores (também chamados de *nomes*) são descritos pelas seguintes "
"definições lexicais."

#: ../../reference/lexical_analysis.rst:283
msgid ""
"The syntax of identifiers in Python is based on the Unicode standard annex "
"UAX-31, with elaboration and changes as defined below; see also :pep:`3131` "
"for further details."
msgstr ""
"A sintaxe dos identificadores em Python é baseada no anexo do padrão Unicode "
"UAX-31, com elaboração e alterações conforme definido abaixo; veja também :"
"pep:`3131` para mais detalhes."

#: ../../reference/lexical_analysis.rst:287
msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for "
"identifiers are the same as in Python 2.x: the uppercase and lowercase "
"letters ``A`` through ``Z``, the underscore ``_`` and, except for the first "
"character, the digits ``0`` through ``9``."
msgstr ""
"Dentro do intervalo ASCII (U+0001..U+007F), os caracteres válidos para "
"identificadores são os mesmos de Python 2.x: as letras maiúsculas e "
"minúsculas de ``A`` até ``Z``, o sublinhado ``_`` e, exceto para o primeiro "
"caractere, os dígitos ``0`` até ``9``."

#: ../../reference/lexical_analysis.rst:292
msgid ""
"Python 3.0 introduces additional characters from outside the ASCII range "
"(see :pep:`3131`).  For these characters, the classification uses the "
"version of the Unicode Character Database as included in the :mod:"
"`unicodedata` module."
msgstr ""
"Python 3.0 introduz caracteres adicionais fora do intervalo ASCII (consulte :"
"pep:`3131`). Para esses caracteres, a classificação utiliza a versão do "
"Banco de Dados de Caracteres Unicode incluída no módulo :mod:`unicodedata`."

#: ../../reference/lexical_analysis.rst:296
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr ""
"Os identificadores têm comprimento ilimitado. Maiúsculas são diferentes de "
"minúsculas."

#: ../../reference/lexical_analysis.rst:305
msgid "The Unicode category codes mentioned above stand for:"
msgstr "Os códigos de categoria Unicode mencionados acima significam:"

#: ../../reference/lexical_analysis.rst:307
msgid "*Lu* - uppercase letters"
msgstr "*Lu* - letras maiúsculas"

#: ../../reference/lexical_analysis.rst:308
msgid "*Ll* - lowercase letters"
msgstr "*Ll* - letras minúsculas"

#: ../../reference/lexical_analysis.rst:309
msgid "*Lt* - titlecase letters"
msgstr "*Lt* - letras em titlecase"

#: ../../reference/lexical_analysis.rst:310
msgid "*Lm* - modifier letters"
msgstr "*Lm* - letras modificadoras"

#: ../../reference/lexical_analysis.rst:311
msgid "*Lo* - other letters"
msgstr "*Lo* - outras letras"

#: ../../reference/lexical_analysis.rst:312
msgid "*Nl* - letter numbers"
msgstr "*Nl* - letras numéricas"

#: ../../reference/lexical_analysis.rst:313
msgid "*Mn* - nonspacing marks"
msgstr "*Mn* - marcas sem espaçamento"

#: ../../reference/lexical_analysis.rst:314
msgid "*Mc* - spacing combining marks"
msgstr "*Mc* - marcas de combinação de espaçamento"

#: ../../reference/lexical_analysis.rst:315
msgid "*Nd* - decimal numbers"
msgstr "*Nd* - números decimais"

#: ../../reference/lexical_analysis.rst:316
msgid "*Pc* - connector punctuations"
msgstr "*Pc* - pontuações de conectores"

#: ../../reference/lexical_analysis.rst:317
msgid ""
"*Other_ID_Start* - explicit list of characters in `PropList.txt <https://www."
"unicode.org/Public/13.0.0/ucd/PropList.txt>`_ to support backwards "
"compatibility"
msgstr ""

#: ../../reference/lexical_analysis.rst:320
msgid "*Other_ID_Continue* - likewise"
msgstr "*Other_ID_Continue* - igualmente"

#: ../../reference/lexical_analysis.rst:322
msgid ""
"All identifiers are converted into the normal form NFKC while parsing; "
"comparison of identifiers is based on NFKC."
msgstr ""
"Todos os identificadores são convertidos no formato normal NFKC durante a "
"análise; a comparação de identificadores é baseada no NFKC."

#: ../../reference/lexical_analysis.rst:325
msgid ""
"A non-normative HTML file listing all valid identifier characters for "
"Unicode 4.1 can be found at https://www.unicode.org/Public/13.0.0/ucd/"
"DerivedCoreProperties.txt"
msgstr ""

#: ../../reference/lexical_analysis.rst:333
msgid "Keywords"
msgstr "Palavras reservadas"

#: ../../reference/lexical_analysis.rst:339
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr ""
"Os seguintes identificadores são usados como palavras reservadas, ou "
"*palavras-chave* da linguagem, e não podem ser usados como identificadores "
"comuns. Eles devem ser escritos exatamente como estão escritos aqui:"

#: ../../reference/lexical_analysis.rst:359
msgid "Reserved classes of identifiers"
msgstr "Classes reservadas de identificadores"

#: ../../reference/lexical_analysis.rst:361
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""
"Certas classes de identificadores (além de palavras reservadas) possuem "
"significados especiais. Essas classes são identificadas pelos padrões de "
"caracteres de sublinhado iniciais e finais:"

#: ../../reference/lexical_analysis.rst:375
msgid "``_*``"
msgstr "``_*``"

#: ../../reference/lexical_analysis.rst:366
msgid ""
"Not imported by ``from module import *``.  The special identifier ``_`` is "
"used in the interactive interpreter to store the result of the last "
"evaluation; it is stored in the :mod:`builtins` module.  When not in "
"interactive mode, ``_`` has no special meaning and is not defined. See "
"section :ref:`import`."
msgstr ""

#: ../../reference/lexical_analysis.rst:373
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer "
"to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr ""
"O nome ``_`` é frequentemente usado em conjunto com internacionalização; "
"consulte a documentação do módulo :mod:`gettext` para obter mais informações "
"sobre esta convenção."

#: ../../reference/lexical_analysis.rst:383
msgid "``__*__``"
msgstr "``__*__``"

#: ../../reference/lexical_analysis.rst:378
msgid ""
"System-defined names, informally known as \"dunder\" names. These names are "
"defined by the interpreter and its implementation (including the standard "
"library). Current system names are discussed in the :ref:`specialnames` "
"section and elsewhere. More will likely be defined in future versions of "
"Python.  *Any* use of ``__*__`` names, in any context, that does not follow "
"explicitly documented use, is subject to breakage without warning."
msgstr ""
"Nomes definidos pelo sistema, informalmente conhecidos como nomes "
"\"dunder\". Esses nomes e suas implementações são definidos pelo "
"interpretador (incluindo a biblioteca padrão). Os nomes de sistema atuais "
"são discutidos na seção :ref:`specialnames` e em outros lugares. "
"Provavelmente mais nomes serão definidos em versões futuras do Python. "
"*Qualquer* uso de nomes ``__*__``, em qualquer contexto, que não siga o uso "
"explicitamente documentado, está sujeito a quebra sem aviso prévio."

#: ../../reference/lexical_analysis.rst:390
msgid "``__*``"
msgstr "``__*``"

#: ../../reference/lexical_analysis.rst:386
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See "
"section :ref:`atom-identifiers`."
msgstr ""
"Nomes de classes privadas. Os nomes nesta categoria, quando usados no "
"contexto de uma definição de classe, são reescritos para usar uma forma "
"desfigurada para ajudar a evitar conflitos de nomes entre atributos "
"\"privados\" de classes base e derivadas. Consulte a seção :ref:`atom-"
"identifiers`."

#: ../../reference/lexical_analysis.rst:395
msgid "Literals"
msgstr "Literais"

#: ../../reference/lexical_analysis.rst:399
msgid "Literals are notations for constant values of some built-in types."
msgstr ""
"Literais são notações para valores constantes de alguns tipos embutidos."

#: ../../reference/lexical_analysis.rst:410
msgid "String and Bytes literals"
msgstr "Literais de string e bytes"

#: ../../reference/lexical_analysis.rst:412
msgid "String literals are described by the following lexical definitions:"
msgstr "Literais de string são descritos pelas seguintes definições lexicais:"

#: ../../reference/lexical_analysis.rst:437
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`stringprefix` or :token:"
"`bytesprefix` and the rest of the literal. The source character set is "
"defined by the encoding declaration; it is UTF-8 if no encoding declaration "
"is given in the source file; see section :ref:`encodings`."
msgstr ""

#: ../../reference/lexical_analysis.rst:447
msgid ""
"In plain English: Both types of literals can be enclosed in matching single "
"quotes (``'``) or double quotes (``\"``).  They can also be enclosed in "
"matching groups of three single or double quotes (these are generally "
"referred to as *triple-quoted strings*). The backslash (``\\``) character is "
"used to give special meaning to otherwise ordinary characters like ``n``, "
"which means 'newline' when escaped (``\\n``). It can also be used to escape "
"characters that otherwise have a special meaning, such as newline, backslash "
"itself, or the quote character. See :ref:`escape sequences <escape-"
"sequences>` below for examples."
msgstr ""
"Em inglês simples: ambos os tipos de literais podem ser colocados entre "
"aspas simples (``'``) ou aspas duplas (``\"``). Eles também podem ser "
"colocados em grupos correspondentes de três aspas simples ou duplas "
"(geralmente chamadas de *strings com aspas triplas*). O caractere de "
"contrabarra (``\\``) é usado para dar um significado especial a caracteres "
"comuns como , que significa 'nova linha' quando escapado (``\\n``). Também "
"pode ser usado para caracteres de escape que, de outra forma, teriam um "
"significado especial, como nova linha, contrabarra ou o caractere de aspas. "
"Veja :ref:`sequências de escape <escape-sequences>` abaixo para exemplos."

#: ../../reference/lexical_analysis.rst:460
msgid ""
"Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an "
"instance of the :class:`bytes` type instead of the :class:`str` type.  They "
"may only contain ASCII characters; bytes with a numeric value of 128 or "
"greater must be expressed with escapes."
msgstr ""
"Literais de bytes são sempre prefixados com ``'b'`` ou ``'B'``; eles "
"produzem uma instância do tipo :class:`bytes` em vez do tipo :class:`str`. "
"Eles só podem conter caracteres ASCII; bytes com valor numérico igual ou "
"superior a 128 devem ser expressos com escapes."

#: ../../reference/lexical_analysis.rst:469
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat "
"backslashes as literal characters.  As a result, in string literals, "
"``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated specially. "
"Given that Python 2.x's raw unicode literals behave differently than Python "
"3.x's the ``'ur'`` syntax is not supported."
msgstr ""
"Literais de string e bytes podem opcionalmente ser prefixados com uma letra "
"``'r'`` ou ``'R'``; essas strings são chamadas de strings brutas e tratam as "
"barras invertidas como caracteres literais. Como resultado, em literais de "
"string, os escapes ``'\\U'`` e ``'\\u'`` em strings brutas não são tratados "
"de maneira especial. Dado que os literais unicode brutos de Python 2.x se "
"comportam de maneira diferente dos de Python 3.x, não há suporte para a "
"sintaxe ``'ur'`` ."

#: ../../reference/lexical_analysis.rst:476
msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr ""
"O prefixo ``'rb'`` de literais de bytes brutos foi adicionado como sinônimo "
"de ``'br'``."

#: ../../reference/lexical_analysis.rst:480
msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to "
"simplify the maintenance of dual Python 2.x and 3.x codebases. See :pep:"
"`414` for more information."
msgstr ""
"O suporte para o literal legado unicode (``u'value'``) foi reintroduzido "
"para simplificar a manutenção de bases de código duplas Python 2.x e 3.x. "
"Consulte :pep:`414` para obter mais informações."

#: ../../reference/lexical_analysis.rst:489
msgid ""
"A string literal with ``'f'`` or ``'F'`` in its prefix is a :dfn:`formatted "
"string literal`; see :ref:`f-strings`.  The ``'f'`` may be combined with "
"``'r'``, but not with ``'b'`` or ``'u'``, therefore raw formatted strings "
"are possible, but formatted bytes literals are not."
msgstr ""
"Uma string literal com ``'f'`` ou ``'F'`` em seu prefixo é uma string "
"literal formatada; veja :ref:`f-strings`. O ``'f'`` pode ser combinado com "
"``'r'``, mas não com ``'b'`` ou ``'u'``, portanto strings formatadas brutas "
"são possíveis, mas literais de bytes formatados não são."

#: ../../reference/lexical_analysis.rst:494
msgid ""
"In triple-quoted literals, unescaped newlines and quotes are allowed (and "
"are retained), except that three unescaped quotes in a row terminate the "
"literal.  (A \"quote\" is the character used to open the literal, i.e. "
"either ``'`` or ``\"``.)"
msgstr ""
"Em literais com aspas triplas, novas linhas e aspas sem escape são "
"permitidas (e são retidas), exceto que três aspas sem escape em uma linha "
"encerram o literal. (Uma “aspas” é o caractere usado para abrir o literal, "
"ou seja, ``'`` ou ``\"``.)"

#: ../../reference/lexical_analysis.rst:515
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in string "
"and bytes literals are interpreted according to rules similar to those used "
"by Standard C.  The recognized escape sequences are:"
msgstr ""
"A menos que um prefixo ``'r'`` ou ``'R'`` esteja presente, as sequências de "
"escape em literais de string e bytes são interpretadas de acordo com regras "
"semelhantes àquelas usadas pelo Standard C. As sequências de escape "
"reconhecidas são:"

#: ../../reference/lexical_analysis.rst:520
#: ../../reference/lexical_analysis.rst:553
msgid "Escape Sequence"
msgstr "Sequência de escape"

#: ../../reference/lexical_analysis.rst:520
#: ../../reference/lexical_analysis.rst:553
msgid "Meaning"
msgstr "Significado"

#: ../../reference/lexical_analysis.rst:520
#: ../../reference/lexical_analysis.rst:553
msgid "Notes"
msgstr "Notas"

#: ../../reference/lexical_analysis.rst:522
msgid "``\\newline``"
msgstr "``\\newline``"

#: ../../reference/lexical_analysis.rst:522
msgid "Backslash and newline ignored"
msgstr "A barra invertida e a nova linha foram ignoradas"

#: ../../reference/lexical_analysis.rst:524
msgid "``\\\\``"
msgstr "``\\\\``"

#: ../../reference/lexical_analysis.rst:524
msgid "Backslash (``\\``)"
msgstr "Contrabarra (``\\``)"

#: ../../reference/lexical_analysis.rst:526
msgid "``\\'``"
msgstr "``\\'``"

#: ../../reference/lexical_analysis.rst:526
msgid "Single quote (``'``)"
msgstr "Aspas simples (``'``)"

#: ../../reference/lexical_analysis.rst:528
msgid "``\\\"``"
msgstr "``\\\"``"

#: ../../reference/lexical_analysis.rst:528
msgid "Double quote (``\"``)"
msgstr "Aspas duplas (``\"``)"

#: ../../reference/lexical_analysis.rst:530
msgid "``\\a``"
msgstr "``\\a``"

#: ../../reference/lexical_analysis.rst:530
msgid "ASCII Bell (BEL)"
msgstr "ASCII Bell (BEL) - um sinal audível é emitido"

#: ../../reference/lexical_analysis.rst:532
msgid "``\\b``"
msgstr "``\\b``"

#: ../../reference/lexical_analysis.rst:532
msgid "ASCII Backspace (BS)"
msgstr "ASCII Backspace (BS) - apaga caractere à esquerda"

#: ../../reference/lexical_analysis.rst:534
msgid "``\\f``"
msgstr "``\\f``"

#: ../../reference/lexical_analysis.rst:534
msgid "ASCII Formfeed (FF)"
msgstr "ASCII Formfeed (FF) - quebra de página"

#: ../../reference/lexical_analysis.rst:536
msgid "``\\n``"
msgstr "``\\n``"

#: ../../reference/lexical_analysis.rst:536
msgid "ASCII Linefeed (LF)"
msgstr "ASCII Linefeed (LF) - quebra de linha"

#: ../../reference/lexical_analysis.rst:538
msgid "``\\r``"
msgstr "``\\r``"

#: ../../reference/lexical_analysis.rst:538
msgid "ASCII Carriage Return (CR)"
msgstr "ASCII Carriage Return (CR) - retorno de carro"

#: ../../reference/lexical_analysis.rst:540
msgid "``\\t``"
msgstr "``\\t``"

#: ../../reference/lexical_analysis.rst:540
msgid "ASCII Horizontal Tab (TAB)"
msgstr "ASCII Horizontal Tab (TAB) - tabulação horizontal"

#: ../../reference/lexical_analysis.rst:542
msgid "``\\v``"
msgstr "``\\v``"

#: ../../reference/lexical_analysis.rst:542
msgid "ASCII Vertical Tab (VT)"
msgstr "ASCII Vertical Tab (VT) - tabulação vertical"

#: ../../reference/lexical_analysis.rst:544
msgid "``\\ooo``"
msgstr "``\\ooo``"

#: ../../reference/lexical_analysis.rst:544
msgid "Character with octal value *ooo*"
msgstr "Caractere com valor octal *ooo*"

#: ../../reference/lexical_analysis.rst:544
msgid "(1,3)"
msgstr "(1,3)"

#: ../../reference/lexical_analysis.rst:547
msgid "``\\xhh``"
msgstr "``\\xhh``"

#: ../../reference/lexical_analysis.rst:547
msgid "Character with hex value *hh*"
msgstr "Caractere com valor hexadecimal *hh*"

#: ../../reference/lexical_analysis.rst:547
msgid "(2,3)"
msgstr "(2,3)"

#: ../../reference/lexical_analysis.rst:550
msgid "Escape sequences only recognized in string literals are:"
msgstr ""
"As sequências de escape apenas reconhecidas em literais de strings são:"

#: ../../reference/lexical_analysis.rst:555
msgid "``\\N{name}``"
msgstr "``\\N{name}``"

#: ../../reference/lexical_analysis.rst:555
msgid "Character named *name* in the Unicode database"
msgstr "Caractere chamado *name* no banco de dados Unicode"

#: ../../reference/lexical_analysis.rst:555
msgid "\\(4)"
msgstr "\\(4)"

#: ../../reference/lexical_analysis.rst:558
msgid "``\\uxxxx``"
msgstr "``\\uxxxx``"

#: ../../reference/lexical_analysis.rst:558
msgid "Character with 16-bit hex value *xxxx*"
msgstr "Caractere com valor hexadecimal de 16 bits *xxxx*"

#: ../../reference/lexical_analysis.rst:558
msgid "\\(5)"
msgstr "\\(5)"

#: ../../reference/lexical_analysis.rst:561
msgid "``\\Uxxxxxxxx``"
msgstr "``\\Uxxxxxxxx``"

#: ../../reference/lexical_analysis.rst:561
msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr "Caractere com valor hexadecimal de 32 bits *xxxxxxxx*"

#: ../../reference/lexical_analysis.rst:561
msgid "\\(6)"
msgstr "\\(6)"

#: ../../reference/lexical_analysis.rst:565
msgid "Notes:"
msgstr "Notas:"

#: ../../reference/lexical_analysis.rst:568
msgid "As in Standard C, up to three octal digits are accepted."
msgstr "Como no padrão C, são aceitos até três dígitos octais."

#: ../../reference/lexical_analysis.rst:571
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr ""
"Ao contrário do padrão C, são necessários exatamente dois dígitos "
"hexadecimais."

#: ../../reference/lexical_analysis.rst:574
msgid ""
"In a bytes literal, hexadecimal and octal escapes denote the byte with the "
"given value. In a string literal, these escapes denote a Unicode character "
"with the given value."
msgstr ""
"Em um literal de bytes, os escapes hexadecimais e octais denotam o byte com "
"o valor fornecido. Em uma literal de string, esses escapes denotam um "
"caractere Unicode com o valor fornecido."

#: ../../reference/lexical_analysis.rst:579
msgid "Support for name aliases [#]_ has been added."
msgstr "O suporte para apelidos de nome [#]_ foi adicionado."

#: ../../reference/lexical_analysis.rst:583
msgid "Exactly four hex digits are required."
msgstr "São necessários exatos quatro dígitos hexadecimais."

#: ../../reference/lexical_analysis.rst:586
msgid ""
"Any Unicode character can be encoded this way.  Exactly eight hex digits are "
"required."
msgstr ""
"Qualquer caractere Unicode pode ser codificado desta forma. São necessários "
"exatamente oito dígitos hexadecimais."

#: ../../reference/lexical_analysis.rst:592
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the result*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences only recognized in string literals fall into the "
"category of unrecognized escapes for bytes literals."
msgstr ""
"Ao contrário do padrão C, todas as sequências de escape não reconhecidas são "
"deixadas inalteradas na string, ou seja, *a contrabarra é deixada no "
"resultado*. (Esse comportamento é útil durante a depuração: se uma sequência "
"de escape for digitada incorretamente, a saída resultante será mais "
"facilmente reconhecida como quebrada.) Também é importante observar que as "
"sequências de escape reconhecidas apenas em literais de string se enquadram "
"na categoria de escapes não reconhecidos para literais de bytes."

#: ../../reference/lexical_analysis.rst:599
msgid ""
"Unrecognized escape sequences produce a :exc:`DeprecationWarning`.  In a "
"future Python version they will be a :exc:`SyntaxWarning` and eventually a :"
"exc:`SyntaxError`."
msgstr ""

#: ../../reference/lexical_analysis.rst:604
msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double quote; "
"``r\"\\\"`` is not a valid string literal (even a raw string cannot end in "
"an odd number of backslashes).  Specifically, *a raw literal cannot end in a "
"single backslash* (since the backslash would escape the following quote "
"character).  Note also that a single backslash followed by a newline is "
"interpreted as those two characters as part of the literal, *not* as a line "
"continuation."
msgstr ""
"Mesmo em um literal bruto, as aspas podem ser escapadas com uma contrabarra, "
"mas a barra invertida permanece no resultado; por exemplo, ``r\"\\\"\"`` é "
"uma literal de string válida que consiste em dois caracteres: uma "
"contrabarra e aspas duplas; ``r\"\\\"`` não é uma literal de string válida "
"(mesmo uma string bruta não pode terminar em um número ímpar de "
"contrabarras). Especificamente, *um literal bruto não pode terminar em uma "
"única contrabarra* (já que a contrabarra escaparia do seguinte caractere de "
"aspas). Observe também que uma única contrabarra seguida por uma nova linha "
"é interpretada como esses dois caracteres como parte do literal, *não* como "
"uma continuação de linha."

#: ../../reference/lexical_analysis.rst:617
msgid "String literal concatenation"
msgstr "Concatenação de literal de string"

#: ../../reference/lexical_analysis.rst:619
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their meaning "
"is the same as their concatenation.  Thus, ``\"hello\" 'world'`` is "
"equivalent to ``\"helloworld\"``.  This feature can be used to reduce the "
"number of backslashes needed, to split long strings conveniently across long "
"lines, or even to add comments to parts of strings, for example::"
msgstr ""
"São permitidos vários literais de strings ou bytes adjacentes (delimitados "
"por espaços em branco), possivelmente usando diferentes convenções de "
"delimitação de strings, e seu significado é o mesmo de sua concatenação. "
"Assim, ``\"hello\" 'world'`` é equivalente a ``\"helloworld\"``. Este "
"recurso pode ser usado para reduzir o número de barras invertidas "
"necessárias, para dividir strings longas convenientemente em linhas longas "
"ou até mesmo para adicionar comentários a partes de strings, por exemplo:"

#: ../../reference/lexical_analysis.rst:630
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings), and formatted string literals may be concatenated "
"with plain string literals."
msgstr ""
"Observe que esse recurso é definido no nível sintático, mas implementado em "
"tempo de compilação. O operador '+' deve ser usado para concatenar "
"expressões de string em tempo de execução. Observe também que a concatenação "
"literal pode usar diferentes estilos de delimitação de strings para cada "
"componente (mesmo misturando strings brutas e strings com aspas triplas), e "
"literais de string formatados podem ser concatenados com literais de string "
"simples."

#: ../../reference/lexical_analysis.rst:651
msgid "Formatted string literals"
msgstr "Literais de string formatados"

#: ../../reference/lexical_analysis.rst:655
msgid ""
"A :dfn:`formatted string literal` or :dfn:`f-string` is a string literal "
"that is prefixed with ``'f'`` or ``'F'``.  These strings may contain "
"replacement fields, which are expressions delimited by curly braces ``{}``. "
"While other string literals always have a constant value, formatted strings "
"are really expressions evaluated at run time."
msgstr ""
"Um :dfn:`literal de string formatado` ou :dfn:`f-string`  é uma literal de "
"string prefixado com ``'f'`` ou ``'F'``. Essas strings podem conter campos "
"de substituição, que são expressões delimitadas por chaves ``{}``. Embora "
"outros literais de string sempre tenham um valor constante, strings "
"formatadas são, na verdade, expressões avaliadas em tempo de execução."

#: ../../reference/lexical_analysis.rst:661
msgid ""
"Escape sequences are decoded like in ordinary string literals (except when a "
"literal is also marked as a raw string).  After decoding, the grammar for "
"the contents of the string is:"
msgstr ""
"As sequências de escape são decodificadas como em literais de string comuns "
"(exceto quando um literal também é marcado como uma string bruta). Após a "
"decodificação, a gramática do conteúdo da string é:"

#: ../../reference/lexical_analysis.rst:675
msgid ""
"The parts of the string outside curly braces are treated literally, except "
"that any doubled curly braces ``'{{'`` or ``'}}'`` are replaced with the "
"corresponding single curly brace.  A single opening curly bracket ``'{'`` "
"marks a replacement field, which starts with a Python expression. To display "
"both the expression text and its value after evaluation, (useful in "
"debugging), an equal sign ``'='`` may be added after the expression. A "
"conversion field, introduced by an exclamation point ``'!'`` may follow.  A "
"format specifier may also be appended, introduced by a colon ``':'``. A "
"replacement field ends with a closing curly bracket ``'}'``."
msgstr ""
"As partes da string fora das chaves são tratadas literalmente, exceto que "
"quaisquer chaves duplas ``'{{'`` ou ``'}}'`` são substituídas pela chave "
"única correspondente. Uma única chave de abertura ``'{'`` marca um campo de "
"substituição, que começa com uma expressão Python. Para exibir o texto da "
"expressão e seu valor após a avaliação (útil na depuração), um sinal de "
"igual ``'='`` pode ser adicionado após a expressão. Um campo de conversão, "
"introduzido por um ponto de exclamação ``'!'``, pode vir a seguir. Um "
"especificador de formato também pode ser anexado, introduzido por dois "
"pontos ``':'``. Um campo de substituição termina com uma chave de fechamento "
"``'}'``."

#: ../../reference/lexical_analysis.rst:685
msgid ""
"Expressions in formatted string literals are treated like regular Python "
"expressions surrounded by parentheses, with a few exceptions. An empty "
"expression is not allowed, and both :keyword:`lambda`  and assignment "
"expressions ``:=`` must be surrounded by explicit parentheses. Replacement "
"expressions can contain line breaks (e.g. in triple-quoted strings), but "
"they cannot contain comments.  Each expression is evaluated in the context "
"where the formatted string literal appears, in order from left to right."
msgstr ""

#: ../../reference/lexical_analysis.rst:694
msgid ""
"Prior to Python 3.7, an :keyword:`await` expression and comprehensions "
"containing an :keyword:`async for` clause were illegal in the expressions in "
"formatted string literals due to a problem with the implementation."
msgstr ""
"Antes do Python 3.7, uma expressão :keyword:`await` e compreensões contendo "
"uma cláusula :keyword:`async for`  eram ilegais nas expressões em literais "
"de string formatados devido a um problema com a implementação."

#: ../../reference/lexical_analysis.rst:699
msgid ""
"When the equal sign ``'='`` is provided, the output will have the expression "
"text, the ``'='`` and the evaluated value. Spaces after the opening brace "
"``'{'``, within the expression and after the ``'='`` are all retained in the "
"output. By default, the ``'='`` causes the :func:`repr` of the expression to "
"be provided, unless there is a format specified. When a format is specified "
"it defaults to the :func:`str` of the expression unless a conversion ``'!"
"r'`` is declared."
msgstr ""
"Quando o sinal de igual ``'='`` for fornecido, a saída terá o texto da "
"expressão, o ``'='`` e o valor avaliado. Os espaços após a chave de abertura "
"``'{'``, dentro da expressão e após ``'='`` são todos preservados na saída. "
"Por padrão, ``'='`` faz com que :func:`repr` da expressão seja fornecida, a "
"menos que haja um formato especificado. Quando um formato é especificado, o "
"padrão é o :func:`str` da expressão, a menos que uma conversão ``'!r'`` seja "
"declarada."

#: ../../reference/lexical_analysis.rst:707
msgid "The equal sign ``'='``."
msgstr "O sinal de igual ``'='``."

#: ../../reference/lexical_analysis.rst:710
msgid ""
"If a conversion is specified, the result of evaluating the expression is "
"converted before formatting.  Conversion ``'!s'`` calls :func:`str` on the "
"result, ``'!r'`` calls :func:`repr`, and ``'!a'`` calls :func:`ascii`."
msgstr ""
"Se uma conversão for especificada, o resultado da avaliação da expressão "
"será convertido antes da formatação. A conversão ``'!s'`` chama :func:`str` "
"no resultado, ``'!r'`` chama :func:`repr` e ``'!a'`` chama :func:`ascii`."

#: ../../reference/lexical_analysis.rst:714
msgid ""
"The result is then formatted using the :func:`format` protocol.  The format "
"specifier is passed to the :meth:`__format__` method of the expression or "
"conversion result.  An empty string is passed when the format specifier is "
"omitted.  The formatted result is then included in the final value of the "
"whole string."
msgstr ""

#: ../../reference/lexical_analysis.rst:720
msgid ""
"Top-level format specifiers may include nested replacement fields. These "
"nested fields may include their own conversion fields and :ref:`format "
"specifiers <formatspec>`, but may not include more deeply-nested replacement "
"fields. The :ref:`format specifier mini-language <formatspec>` is the same "
"as that used by the :meth:`str.format` method."
msgstr ""

#: ../../reference/lexical_analysis.rst:726
msgid ""
"Formatted string literals may be concatenated, but replacement fields cannot "
"be split across literals."
msgstr ""
"Literais de string formatados podem ser concatenados, mas os campos de "
"substituição não podem ser divididos entre literais."

#: ../../reference/lexical_analysis.rst:729
msgid "Some examples of formatted string literals::"
msgstr "Alguns exemplos de literais de string formatados::"

#: ../../reference/lexical_analysis.rst:761
msgid ""
"A consequence of sharing the same syntax as regular string literals is that "
"characters in the replacement fields must not conflict with the quoting used "
"in the outer formatted string literal::"
msgstr ""

#: ../../reference/lexical_analysis.rst:768
msgid ""
"Backslashes are not allowed in format expressions and will raise an error::"
msgstr ""
"As barras invertidas não são permitidas nas expressões de formatação e "
"levantarão uma exceção::"

#: ../../reference/lexical_analysis.rst:773
msgid ""
"To include a value in which a backslash escape is required, create a "
"temporary variable."
msgstr ""

#: ../../reference/lexical_analysis.rst:780
msgid ""
"Formatted string literals cannot be used as docstrings, even if they do not "
"include expressions."
msgstr ""
"Literais de string formatados não podem ser usados como strings de "
"documentação, mesmo que não incluam expressões."

#: ../../reference/lexical_analysis.rst:791
msgid ""
"See also :pep:`498` for the proposal that added formatted string literals, "
"and :meth:`str.format`, which uses a related format string mechanism."
msgstr ""
"Consulte também :pep:`498` para a proposta que adicionou literais de string "
"formatados e :meth:`str.format`, que usa um mecanismo de string de formato "
"relacionado."

#: ../../reference/lexical_analysis.rst:798
msgid "Numeric literals"
msgstr "Literais numéricos"

#: ../../reference/lexical_analysis.rst:804
msgid ""
"There are three types of numeric literals: integers, floating point numbers, "
"and imaginary numbers.  There are no complex literals (complex numbers can "
"be formed by adding a real number and an imaginary number)."
msgstr ""
"Existem três tipos de literais numéricos: inteiros, números de ponto "
"flutuante e números imaginários. Não existem literais complexos (números "
"complexos podem ser formados adicionando um número real e um número "
"imaginário)."

#: ../../reference/lexical_analysis.rst:808
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr ""
"Observe que os literais numéricos não incluem um sinal; uma frase como "
"``-1`` é, na verdade, uma expressão composta pelo operador unário '``-2``' e "
"o literal ``1``."

#: ../../reference/lexical_analysis.rst:822
msgid "Integer literals"
msgstr "Inteiros literais"

#: ../../reference/lexical_analysis.rst:824
msgid "Integer literals are described by the following lexical definitions:"
msgstr "Literais inteiros são descritos pelas seguintes definições léxicas:"

#: ../../reference/lexical_analysis.rst:838
msgid ""
"There is no limit for the length of integer literals apart from what can be "
"stored in available memory."
msgstr ""
"Não há limite para o comprimento de literais inteiros além do que pode ser "
"armazenado na memória disponível."

#: ../../reference/lexical_analysis.rst:841
msgid ""
"Underscores are ignored for determining the numeric value of the literal.  "
"They can be used to group digits for enhanced readability.  One underscore "
"can occur between digits, and after base specifiers like ``0x``."
msgstr ""
"Os sublinhados são ignorados para determinar o valor numérico do literal. "
"Eles podem ser usados para agrupar dígitos para maior legibilidade. Um "
"sublinhado pode ocorrer entre dígitos e após especificadores de base como "
"``0x``."

#: ../../reference/lexical_analysis.rst:845
msgid ""
"Note that leading zeros in a non-zero decimal number are not allowed. This "
"is for disambiguation with C-style octal literals, which Python used before "
"version 3.0."
msgstr ""
"Observe que não são permitidos zeros à esquerda em um número decimal "
"diferente de zero. Isto é para desambiguação com literais octais de estilo "
"C, que o Python usava antes da versão 3.0."

#: ../../reference/lexical_analysis.rst:849
msgid "Some examples of integer literals::"
msgstr "Alguns exemplos de literais inteiros::"

#: ../../reference/lexical_analysis.rst:855
#: ../../reference/lexical_analysis.rst:887
msgid "Underscores are now allowed for grouping purposes in literals."
msgstr ""
"Os sublinhados agora são permitidos para fins de agrupamento de literais."

#: ../../reference/lexical_analysis.rst:866
msgid "Floating point literals"
msgstr "Literais de ponto flutuante"

#: ../../reference/lexical_analysis.rst:868
msgid ""
"Floating point literals are described by the following lexical definitions:"
msgstr ""
"Literais de ponto flutuante são descritos pelas seguintes definições léxicas:"

#: ../../reference/lexical_analysis.rst:878
msgid ""
"Note that the integer and exponent parts are always interpreted using radix "
"10. For example, ``077e010`` is legal, and denotes the same number as "
"``77e10``. The allowed range of floating point literals is implementation-"
"dependent.  As in integer literals, underscores are supported for digit "
"grouping."
msgstr ""
"Observe que as partes inteiras e expoentes são sempre interpretadas usando "
"base 10. Por exemplo, ``077e010`` é válido e representa o mesmo número que "
"``77e10``. O intervalo permitido de literais de ponto flutuante depende da "
"implementação. Assim como em literais inteiros, os sublinhados são "
"permitidos para agrupamento de dígitos."

#: ../../reference/lexical_analysis.rst:883
msgid "Some examples of floating point literals::"
msgstr "Alguns exemplos de literais de ponto flutuante::"

#: ../../reference/lexical_analysis.rst:896
msgid "Imaginary literals"
msgstr "Literais imaginários"

#: ../../reference/lexical_analysis.rst:898
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr ""
"Os literais imaginários são descritos pelas seguintes definições léxicas:"

#: ../../reference/lexical_analysis.rst:903
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and have "
"the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr ""
"Um literal imaginário produz um número complexo com uma parte real igual a "
"0.0. Os números complexos são representados como um par de números de ponto "
"flutuante e têm as mesmas restrições em seu alcance. Para criar um número "
"complexo com uma parte real diferente de zero, adicione um número de ponto "
"flutuante a ele, por exemplo, ``(3 + 4j)``. Alguns exemplos de literais "
"imaginários::"

#: ../../reference/lexical_analysis.rst:915
msgid "Operators"
msgstr "Operadores"

#: ../../reference/lexical_analysis.rst:919
msgid "The following tokens are operators:"
msgstr "Os seguintes tokens são operadores:"

#: ../../reference/lexical_analysis.rst:932
msgid "Delimiters"
msgstr "Delimitadores"

#: ../../reference/lexical_analysis.rst:936
msgid "The following tokens serve as delimiters in the grammar:"
msgstr "Os seguintes tokens servem como delimitadores na gramática:"

#: ../../reference/lexical_analysis.rst:945
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis literal. The "
"second half of the list, the augmented assignment operators, serve lexically "
"as delimiters, but also perform an operation."
msgstr ""
"O ponto também pode ocorrer em literais de ponto flutuante e imaginário. Uma "
"sequência de três períodos tem um significado especial como um literal de "
"reticências. A segunda metade da lista, os operadores de atribuição "
"aumentada, servem lexicalmente como delimitadores, mas também realizam uma "
"operação."

#: ../../reference/lexical_analysis.rst:950
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr ""
"Os seguintes caracteres ASCII imprimíveis têm um significado especial como "
"parte de outros tokens ou são significativos para o analisador léxico:"

#: ../../reference/lexical_analysis.rst:957
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error:"
msgstr ""
"Os seguintes caracteres ASCII imprimíveis não são usados em Python. Sua "
"ocorrência fora de literais de string e comentários é um erro incondicional:"

#: ../../reference/lexical_analysis.rst:966
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../reference/lexical_analysis.rst:967
msgid "https://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
msgstr ""

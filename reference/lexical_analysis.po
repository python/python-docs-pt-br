# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-09 18:46+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: Adorilson Bezerra <adorilson@gmail.com>\n"
"Language-Team: Portuguese (Brazil) (http://www.transifex.com/python-doc/"
"python-27/language/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr "Análise Léxica"

#: ../../reference/lexical_analysis.rst:13
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr ""
"Um programa Python é lido por um *analisador*. A entrada para o analisador é "
"um fluxo de *tokens*, gerado pelo *analisador lexical*. Este capítulo "
"descreve como o analisador lexical divide um arquivo em tokens."

#: ../../reference/lexical_analysis.rst:17
msgid "Python uses the 7-bit ASCII character set for program text."
msgstr ""

#: ../../reference/lexical_analysis.rst:19
msgid ""
"An encoding declaration can be used to indicate that  string literals and "
"comments use an encoding different from ASCII."
msgstr ""

#: ../../reference/lexical_analysis.rst:23
msgid ""
"For compatibility with older versions, Python only warns if it finds 8-bit "
"characters; those warnings should be corrected by either declaring an "
"explicit encoding, or using escape sequences if those bytes are binary data, "
"instead of characters."
msgstr ""

#: ../../reference/lexical_analysis.rst:28
msgid ""
"The run-time character set depends on the I/O devices connected to the "
"program but is generally a superset of ASCII."
msgstr ""

#: ../../reference/lexical_analysis.rst:31
msgid ""
"**Future compatibility note:** It may be tempting to assume that the "
"character set for 8-bit characters is ISO Latin-1 (an ASCII superset that "
"covers most western languages that use the Latin alphabet), but it is "
"possible that in the future Unicode text editors will become common.  These "
"generally use the UTF-8 encoding, which is also an ASCII superset, but with "
"very different use for the characters with ordinals 128-255.  While there is "
"no consensus on this subject yet, it is unwise to assume either Latin-1 or "
"UTF-8, even though the current implementation appears to favor Latin-1.  "
"This applies both to the source character set and the run-time character set."
msgstr ""

#: ../../reference/lexical_analysis.rst:45
msgid "Line structure"
msgstr "Estrutura da Linha"

#: ../../reference/lexical_analysis.rst:49
msgid "A Python program is divided into a number of *logical lines*."
msgstr "Um programa Python é dividido em uma série de *linhas lógicas*."

#: ../../reference/lexical_analysis.rst:55
msgid "Logical lines"
msgstr "Linhas Lógicas"

#: ../../reference/lexical_analysis.rst:63
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr ""
"O fim de uma linha lógica é representado pelo token NEWLINE. As declarações "
"não podem cruzar os limites da linha lógica, exceto onde NEWLINE for "
"permitido pela sintaxe (por exemplo, entre as declarações de declarações "
"compostas). Uma linha lógica é construída a partir de uma ou mais *linhas "
"físicas* seguindo a linha explícita ou implícita que *junta as linhas* das "
"regras."

#: ../../reference/lexical_analysis.rst:73
msgid "Physical lines"
msgstr "Linha Física"

#: ../../reference/lexical_analysis.rst:75
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files and strings, any of the standard platform line "
"termination sequences can be used - the Unix form using ASCII LF (linefeed), "
"the Windows form using the ASCII sequence CR LF (return followed by "
"linefeed), or the old Macintosh form using the ASCII CR (return) character.  "
"All of these forms can be used equally, regardless of platform. The end of "
"input also serves as an implicit terminator for the final physical line."
msgstr ""
"Uma linha física é uma sequência de caracteres terminados por uma sequência "
"de quebra de linha. Nos arquivos de origem e cadeias de caracteres, qualquer "
"uma das sequências de terminação de linha de plataforma padrão pode ser "
"usada - o formato Unix usando ASCII LF (linefeed), o formato Windows usando "
"a sequência ASCII CR LF (return followed by linefeed) ou o antigo formato "
"Macintosh usando o caractere ASCII CR (return). Todos esses formatos podem "
"ser usados ​​igualmente, independentemente da plataforma. O final da entrada "
"também serve como um finalizador implícito para a linha física final."

#: ../../reference/lexical_analysis.rst:83
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr ""
"Ao incorporar o Python, o código-fonte das Strings devem ser passadas para "
"APIs do Python usando as convenções C padrão para caracteres de nova linha "
"(o caractere ``\\n``, representando ASCII LF, será o terminador de linha)."

#: ../../reference/lexical_analysis.rst:91
msgid "Comments"
msgstr "Comentários"

#: ../../reference/lexical_analysis.rst:97
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax; they are not tokens."
msgstr ""

#: ../../reference/lexical_analysis.rst:106
msgid "Encoding declarations"
msgstr "Declarações de codificação"

#: ../../reference/lexical_analysis.rst:110
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""
"Se um comentário na primeira ou segunda linha de um script Python "
"corresponde com a expressão regular  ``coding[=:]\\s*([-\\w.]+)``, esse "
"comentário é processado com uma declaração de codificação; o primeiro grupo "
"dessa expressão indica a codificação do arquivo do código-fonte. A "
"declaração de codificação deve aparecer em uma linha exclusiva para tal. Se "
"está na segunda linha, a primeira linha também deve ser uma linha somente "
"com comentário. As formas recomendadas de uma declaração de codificação são:"

#: ../../reference/lexical_analysis.rst:119
msgid "which is recognized also by GNU Emacs, and ::"
msgstr "que é reconhecido também por GNU Emacs, e::"

#: ../../reference/lexical_analysis.rst:123
msgid ""
"which is recognized by Bram Moolenaar's VIM. In addition, if the first bytes "
"of the file are the UTF-8 byte-order mark (``'\\xef\\xbb\\xbf'``), the "
"declared file encoding is UTF-8 (this is supported, among others, by "
"Microsoft's :program:`notepad`)."
msgstr ""

#: ../../reference/lexical_analysis.rst:128
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python. "
"The encoding is used for all lexical analysis, in particular to find the end "
"of a string, and to interpret the contents of Unicode literals. String "
"literals are converted to Unicode for syntactical analysis, then converted "
"back to their original encoding before interpretation starts."
msgstr ""

#: ../../reference/lexical_analysis.rst:140
msgid "Explicit line joining"
msgstr "Junção de linha explícita"

#: ../../reference/lexical_analysis.rst:148
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""
"Duas ou mais linhas físicas podem ser juntadas em linhas lógicas usando o "
"caractere contrabarra  (``\\``) da seguinte forma: quando uma linha física "
"termina com uma contrabarra que não é parte da uma literal string ou "
"comentário, ela é juntada com a linha seguinte formando uma única linha "
"lógica, removendo a contrabarra e o caractere de fim de linha seguinte. Por "
"exemplo::"

#: ../../reference/lexical_analysis.rst:159
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string "
"literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""
"Uma linha terminada em uma contrabarra não pode conter um comentário.  Uma "
"barra invertida não continua um comentário.  Uma contrabarra não continua um "
"token, exceto para strings literais (ou seja, tokens diferentes de strings "
"literais não podem ser divididos em linhas físicas usando uma contrabarra).  "
"Uma contrabarra é ilegal em qualquer outro lugar em uma linha fora de uma "
"string literal."

#: ../../reference/lexical_analysis.rst:169
msgid "Implicit line joining"
msgstr "Junção de linha implicita"

#: ../../reference/lexical_analysis.rst:171
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""
"Expressões entre parênteses, colchetes ou chaves podem ser quebradas em mais "
"de uma linha física sem a necessidade do uso de contrabarras. Por exemplo::"

#: ../../reference/lexical_analysis.rst:179
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""
"Linhas continuadas implicitamente podem conter comentários. O recuo das "
"linhas de continuação não é importante. Linhas de continuação em branco são "
"permitidas. Não há token NEWLINE entre linhas de continuação implícitas. "
"Linhas continuadas implicitamente também podem ocorrer dentro de strings com "
"aspas triplas (veja abaixo); nesse caso, eles não podem conter comentários."

#: ../../reference/lexical_analysis.rst:189
msgid "Blank lines"
msgstr "Linhas em Branco"

#: ../../reference/lexical_analysis.rst:193
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard implementation, an entirely blank logical line (i.e. one containing "
"not even whitespace or a comment) terminates a multi-line statement."
msgstr ""

#: ../../reference/lexical_analysis.rst:204
msgid "Indentation"
msgstr "Indentação"

#: ../../reference/lexical_analysis.rst:215
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr ""
"O espaço em branco (espaços e tabulações) no início de uma linha lógica é "
"usado para calcular o nível de indentação da linha, que por sua vez é usado "
"para determinar o agrupamento de instruções."

#: ../../reference/lexical_analysis.rst:219
msgid ""
"First, tabs are replaced (from left to right) by one to eight spaces such "
"that the total number of characters up to and including the replacement is a "
"multiple of eight (this is intended to be the same rule as used by Unix).  "
"The total number of spaces preceding the first non-blank character then "
"determines the line's indentation.  Indentation cannot be split over "
"multiple physical lines using backslashes; the whitespace up to the first "
"backslash determines the indentation."
msgstr ""

#: ../../reference/lexical_analysis.rst:227
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors "
"on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for "
"the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""
"**Nota de compatibilidade entre plataformas:** devido à natureza dos "
"editores de texto em plataformas não-UNIX, não é aconselhável usar uma "
"mistura de espaços e tabulações para o recuo em um único arquivo de origem. "
"Deve-se notar também que diferentes plataformas podem limitar explicitamente "
"o nível máximo de indentação."

#: ../../reference/lexical_analysis.rst:232
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""
"Um caractere de quebra de página pode estar presente no início da linha; ele "
"será ignorado para os cálculos de indentação acima. Os caracteres de quebra "
"de página que ocorrem em outro lugar além do espaço em branco inicial têm um "
"efeito indefinido (por exemplo, eles podem redefinir a contagem de espaços "
"para zero)."

#: ../../reference/lexical_analysis.rst:241
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr ""
"Os níveis de indentação das linhas consecutivas são usados para gerar tokens "
"INDENT e DEDENT, usando uma pilha, como segue."

#: ../../reference/lexical_analysis.rst:244
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack "
"will always be strictly increasing from bottom to top.  At the beginning of "
"each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on "
"the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr ""
"Antes da leitura da primeira linha do arquivo, um único zero é colocado na "
"pilha; isso nunca mais será exibido. Os números colocados na pilha sempre "
"aumentarão estritamente de baixo para cima. No início de cada linha lógica, "
"o nível de indentação da linha é comparado ao topo da pilha. Se for igual, "
"nada acontece. Se for maior, ele é colocado na pilha e um token INDENT é "
"gerado. Se for menor, *deve* ser um dos números que aparecem na pilha; todos "
"os números maiores na pilha são retirados e, para cada número retirado, um "
"token DEDENT é gerado. Ao final do arquivo, um token DEDENT é gerado para "
"cada número restante na pilha que seja maior que zero."

#: ../../reference/lexical_analysis.rst:255
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr ""
"Aqui está um exemplo de um trecho de código Python indentado corretamente "
"(embora confuso):"

#: ../../reference/lexical_analysis.rst:270
msgid "The following example shows various indentation errors::"
msgstr "O exemplo a seguir mostra vários erros de indentação:"

#: ../../reference/lexical_analysis.rst:280
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""
"(Na verdade, os três primeiros erros são detectados pelo analisador "
"sintático; apenas o último erro é encontrado pelo analisador léxico --- o "
"recuo de não corresponde a um nível retirado da pilha.)"

#: ../../reference/lexical_analysis.rst:288
msgid "Whitespace between tokens"
msgstr "Espaços em branco entre tokens"

#: ../../reference/lexical_analysis.rst:290
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to "
"separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr ""
"Exceto no início de uma linha lógica ou em string literais, os caracteres de "
"espaço em branco (espaço, tabulação e quebra de página) podem ser usados "
"alternadamente para separar tokens. O espaço em branco é necessário entre "
"dois tokens somente se sua concatenação puder ser interpretada como um token "
"diferente (por exemplo, ab é um token, mas a b são dois tokens)."

#: ../../reference/lexical_analysis.rst:300
msgid "Other tokens"
msgstr "Outros Tokens"

#: ../../reference/lexical_analysis.rst:302
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. "
"Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr ""
"Além de NEWLINE, INDENT e DEDENT, existem as seguintes categorias de tokens: "
"*identificadores*, *palavras-chave*, *literais*, *operadores* e "
"*delimitadores*. Caracteres de espaço em branco (exceto terminadores de "
"linha, discutidos anteriormente) não são tokens, mas servem para delimitar "
"tokens. Onde existe ambiguidade, um token compreende a string mais longa "
"possível que forma um token legal, quando lido da esquerda para a direita."

#: ../../reference/lexical_analysis.rst:312
msgid "Identifiers and keywords"
msgstr "Identificadores e Keywords"

#: ../../reference/lexical_analysis.rst:318
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions:"
msgstr ""

#: ../../reference/lexical_analysis.rst:328
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr ""
"Os identificadores têm comprimento ilimitado. Maiúsculas são diferentes de "
"minúsculas."

#: ../../reference/lexical_analysis.rst:334
msgid "Keywords"
msgstr "Keywords"

#: ../../reference/lexical_analysis.rst:340
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr ""
"Os seguintes identificadores são usados como palavras reservadas, ou "
"*palavras-chave* da linguagem, e não podem ser usados como identificadores "
"comuns. Eles devem ser escritos exatamente como estão escritos aqui:"

#: ../../reference/lexical_analysis.rst:354
msgid ""
":const:`None` became a constant and is now recognized by the compiler as a "
"name for the built-in object :const:`None`.  Although it is not a keyword, "
"you cannot assign a different object to it."
msgstr ""

#: ../../reference/lexical_analysis.rst:359
msgid ""
"Using :keyword:`as` and :keyword:`with` as identifiers triggers a warning.  "
"To use them as keywords, enable the ``with_statement`` future feature ."
msgstr ""

#: ../../reference/lexical_analysis.rst:363
msgid ":keyword:`as` and :keyword:`with` are full keywords."
msgstr ""

#: ../../reference/lexical_analysis.rst:370
msgid "Reserved classes of identifiers"
msgstr "Classes reservadas de identificadores"

#: ../../reference/lexical_analysis.rst:372
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""
"Certas classes de identificadores (além de keywords) possuem significados "
"especiais. Essas classes são identificadas pelos padrões de caracteres de "
"sublinhado principais e à direita:"

#: ../../reference/lexical_analysis.rst:386
msgid "``_*``"
msgstr "``_*``"

#: ../../reference/lexical_analysis.rst:377
msgid ""
"Not imported by ``from module import *``.  The special identifier ``_`` is "
"used in the interactive interpreter to store the result of the last "
"evaluation; it is stored in the :mod:`__builtin__` module.  When not in "
"interactive mode, ``_`` has no special meaning and is not defined. See "
"section :ref:`import`."
msgstr ""

#: ../../reference/lexical_analysis.rst:384
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer "
"to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr ""
"O nome ``_`` é frequentemente usado em conjunto com internacionalização; "
"consulte a documentação do módulo :mod:`gettext` para obter mais informações "
"sobre esta convenção."

#: ../../reference/lexical_analysis.rst:394
msgid "``__*__``"
msgstr "``__*__``"

#: ../../reference/lexical_analysis.rst:389
msgid ""
"System-defined names. These names are defined by the interpreter and its "
"implementation (including the standard library).  Current system names are "
"discussed in the :ref:`specialnames` section and elsewhere.  More will "
"likely be defined in future versions of Python.  *Any* use of ``__*__`` "
"names, in any context, that does not follow explicitly documented use, is "
"subject to breakage without warning."
msgstr ""

#: ../../reference/lexical_analysis.rst:401
msgid "``__*``"
msgstr "``__*``"

#: ../../reference/lexical_analysis.rst:397
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See "
"section :ref:`atom-identifiers`."
msgstr ""
"Nomes de classes privadas. Os nomes nesta categoria, quando usados no "
"contexto de uma definição de classe, são reescritos para usar uma forma "
"desfigurada para ajudar a evitar conflitos de nomes entre atributos "
"\"privados\" de classes base e derivadas. Consulte a seção :ref:`atom-"
"identifiers`."

#: ../../reference/lexical_analysis.rst:406
msgid "Literals"
msgstr "Literais"

#: ../../reference/lexical_analysis.rst:412
msgid "Literals are notations for constant values of some built-in types."
msgstr ""
"Os literais são notações para valores constantes de alguns tipos "
"incorporados."

#: ../../reference/lexical_analysis.rst:418
msgid "String literals"
msgstr ""

#: ../../reference/lexical_analysis.rst:422
msgid "String literals are described by the following lexical definitions:"
msgstr "Literais de string são descritos pelas seguintes definições lexicais:"

#: ../../reference/lexical_analysis.rst:439
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`stringprefix` and the rest of "
"the string literal. The source character set is defined by the encoding "
"declaration; it is ASCII if no encoding declaration is given in the source "
"file; see section :ref:`encodings`."
msgstr ""

#: ../../reference/lexical_analysis.rst:451
msgid ""
"In plain English: String literals can be enclosed in matching single quotes "
"(``'``) or double quotes (``\"``).  They can also be enclosed in matching "
"groups of three single or double quotes (these are generally referred to as "
"*triple-quoted strings*).  The backslash (``\\``) character is used to "
"escape characters that otherwise have a special meaning, such as newline, "
"backslash itself, or the quote character.  String literals may optionally be "
"prefixed with a letter ``'r'`` or ``'R'``; such strings are called :dfn:`raw "
"strings` and use different rules for interpreting backslash escape "
"sequences.  A prefix of ``'u'`` or ``'U'`` makes the string a Unicode "
"string.  Unicode strings use the Unicode character set as defined by the "
"Unicode Consortium and ISO 10646.  Some additional escape sequences, "
"described below, are available in Unicode strings. A prefix of ``'b'`` or "
"``'B'`` is ignored in Python 2; it indicates that the literal should become "
"a bytes literal in Python 3 (e.g. when code is automatically converted with "
"2to3).  A ``'u'`` or ``'b'`` prefix may be followed by an ``'r'`` prefix."
msgstr ""

#: ../../reference/lexical_analysis.rst:467
msgid ""
"In triple-quoted strings, unescaped newlines and quotes are allowed (and are "
"retained), except that three unescaped quotes in a row terminate the "
"string.  (A \"quote\" is the character used to open the string, i.e. either "
"``'`` or ``\"``.)"
msgstr ""

#: ../../reference/lexical_analysis.rst:477
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in strings "
"are interpreted according to rules similar to those used by Standard C.  The "
"recognized escape sequences are:"
msgstr ""

#: ../../reference/lexical_analysis.rst:482
msgid "Escape Sequence"
msgstr "Caracteres de Escapes (Escapes Sequence)"

#: ../../reference/lexical_analysis.rst:482
msgid "Meaning"
msgstr "Significado"

#: ../../reference/lexical_analysis.rst:482
msgid "Notes"
msgstr "Notas"

#: ../../reference/lexical_analysis.rst:484
msgid "``\\newline``"
msgstr "``\\newline``"

#: ../../reference/lexical_analysis.rst:484
msgid "Ignored"
msgstr ""

#: ../../reference/lexical_analysis.rst:486
msgid "``\\\\``"
msgstr "``\\\\``"

#: ../../reference/lexical_analysis.rst:486
msgid "Backslash (``\\``)"
msgstr "Backslash (``\\``)"

#: ../../reference/lexical_analysis.rst:488
msgid "``\\'``"
msgstr "``\\'``"

#: ../../reference/lexical_analysis.rst:488
msgid "Single quote (``'``)"
msgstr "Aspas Simples (``'``)"

#: ../../reference/lexical_analysis.rst:490
msgid "``\\\"``"
msgstr "``\\\"``"

#: ../../reference/lexical_analysis.rst:490
msgid "Double quote (``\"``)"
msgstr "Aspas Dupla (``\"``)"

#: ../../reference/lexical_analysis.rst:492
msgid "``\\a``"
msgstr "``\\a``"

#: ../../reference/lexical_analysis.rst:492
msgid "ASCII Bell (BEL)"
msgstr "ASCII Bell (BEL)"

#: ../../reference/lexical_analysis.rst:494
msgid "``\\b``"
msgstr "``\\b``"

#: ../../reference/lexical_analysis.rst:494
msgid "ASCII Backspace (BS)"
msgstr "ASCII Backspace (BS)"

#: ../../reference/lexical_analysis.rst:496
msgid "``\\f``"
msgstr "``\\f``"

#: ../../reference/lexical_analysis.rst:496
msgid "ASCII Formfeed (FF)"
msgstr "ASCII Formfeed (FF)"

#: ../../reference/lexical_analysis.rst:498
msgid "``\\n``"
msgstr "``\\n``"

#: ../../reference/lexical_analysis.rst:498
msgid "ASCII Linefeed (LF)"
msgstr "ASCII Linefeed (LF)"

#: ../../reference/lexical_analysis.rst:500
msgid "``\\N{name}``"
msgstr "``\\N{name}``"

#: ../../reference/lexical_analysis.rst:500
msgid "Character named *name* in the Unicode database (Unicode only)"
msgstr ""

#: ../../reference/lexical_analysis.rst:503
msgid "``\\r``"
msgstr "``\\r``"

#: ../../reference/lexical_analysis.rst:503
msgid "ASCII Carriage Return (CR)"
msgstr "ASCII Carriage Return (CR)"

#: ../../reference/lexical_analysis.rst:505
msgid "``\\t``"
msgstr "``\\t``"

#: ../../reference/lexical_analysis.rst:505
msgid "ASCII Horizontal Tab (TAB)"
msgstr "ASCII Horizontal Tab (TAB)"

#: ../../reference/lexical_analysis.rst:507
msgid "``\\uxxxx``"
msgstr "``\\uxxxx``"

#: ../../reference/lexical_analysis.rst:507
msgid "Character with 16-bit hex value *xxxx* (Unicode only)"
msgstr ""

#: ../../reference/lexical_analysis.rst:507
msgid "\\(1)"
msgstr "\\(1)"

#: ../../reference/lexical_analysis.rst:510
msgid "``\\Uxxxxxxxx``"
msgstr "``\\Uxxxxxxxx``"

#: ../../reference/lexical_analysis.rst:510
msgid "Character with 32-bit hex value *xxxxxxxx* (Unicode only)"
msgstr ""

#: ../../reference/lexical_analysis.rst:510
msgid "\\(2)"
msgstr "\\(2)"

#: ../../reference/lexical_analysis.rst:513
msgid "``\\v``"
msgstr "``\\v``"

#: ../../reference/lexical_analysis.rst:513
msgid "ASCII Vertical Tab (VT)"
msgstr "ASCII Vertical Tab (VT)"

#: ../../reference/lexical_analysis.rst:515
msgid "``\\ooo``"
msgstr "``\\ooo``"

#: ../../reference/lexical_analysis.rst:515
msgid "Character with octal value *ooo*"
msgstr "Caráter com valor octal *ooo*"

#: ../../reference/lexical_analysis.rst:515
msgid "(3,5)"
msgstr ""

#: ../../reference/lexical_analysis.rst:518
msgid "``\\xhh``"
msgstr "``\\xhh``"

#: ../../reference/lexical_analysis.rst:518
msgid "Character with hex value *hh*"
msgstr "Caráter com valor hexadecimal *hh*"

#: ../../reference/lexical_analysis.rst:518
msgid "(4,5)"
msgstr ""

#: ../../reference/lexical_analysis.rst:523
msgid "Notes:"
msgstr "Notas:"

#: ../../reference/lexical_analysis.rst:526
msgid ""
"Individual code units which form parts of a surrogate pair can be encoded "
"using this escape sequence."
msgstr ""

#: ../../reference/lexical_analysis.rst:530
msgid ""
"Any Unicode character can be encoded this way, but characters outside the "
"Basic Multilingual Plane (BMP) will be encoded using a surrogate pair if "
"Python is compiled to use 16-bit code units (the default)."
msgstr ""

#: ../../reference/lexical_analysis.rst:535
msgid "As in Standard C, up to three octal digits are accepted."
msgstr "Como no padrão C, são aceitos até três dígitos octal."

#: ../../reference/lexical_analysis.rst:538
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr ""
"Ao contrário do padrão C, são necessários exatamente dois dígitos "
"hexadecimais."

#: ../../reference/lexical_analysis.rst:541
msgid ""
"In a string literal, hexadecimal and octal escapes denote the byte with the "
"given value; it is not necessary that the byte encodes a character in the "
"source character set. In a Unicode literal, these escapes denote a Unicode "
"character with the given value."
msgstr ""

#: ../../reference/lexical_analysis.rst:548
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the string*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences marked as \"(Unicode only)\" in the table above "
"fall into the category of unrecognized escapes for non-Unicode string "
"literals."
msgstr ""

#: ../../reference/lexical_analysis.rst:555
msgid ""
"When an ``'r'`` or ``'R'`` prefix is present, a character following a "
"backslash is included in the string without change, and *all backslashes are "
"left in the string*.  For example, the string literal ``r\"\\n\"`` consists "
"of two characters: a backslash and a lowercase ``'n'``.  String quotes can "
"be escaped with a backslash, but the backslash remains in the string; for "
"example, ``r\"\\\"\"`` is a valid string literal consisting of two "
"characters: a backslash and a double quote; ``r\"\\\"`` is not a valid "
"string literal (even a raw string cannot end in an odd number of "
"backslashes).  Specifically, *a raw string cannot end in a single backslash* "
"(since the backslash would escape the following quote character).  Note also "
"that a single backslash followed by a newline is interpreted as those two "
"characters as part of the string, *not* as a line continuation."
msgstr ""

#: ../../reference/lexical_analysis.rst:568
msgid ""
"When an ``'r'`` or ``'R'`` prefix is used in conjunction with a ``'u'`` or "
"``'U'`` prefix, then the ``\\uXXXX`` and ``\\UXXXXXXXX`` escape sequences "
"are processed while  *all other backslashes are left in the string*. For "
"example, the string literal ``ur\"\\u0062\\n\"`` consists of three Unicode "
"characters: 'LATIN SMALL LETTER B', 'REVERSE SOLIDUS', and 'LATIN SMALL "
"LETTER N'. Backslashes can be escaped with a preceding backslash; however, "
"both remain in the string.  As a result, ``\\uXXXX`` escape sequences are "
"only recognized when there are an odd number of backslashes."
msgstr ""

#: ../../reference/lexical_analysis.rst:581
msgid "String literal concatenation"
msgstr "Concatenação de literal de string"

#: ../../reference/lexical_analysis.rst:583
msgid ""
"Multiple adjacent string literals (delimited by whitespace), possibly using "
"different quoting conventions, are allowed, and their meaning is the same as "
"their concatenation.  Thus, ``\"hello\" 'world'`` is equivalent to "
"``\"helloworld\"``.  This feature can be used to reduce the number of "
"backslashes needed, to split long strings conveniently across long lines, or "
"even to add comments to parts of strings, for example::"
msgstr ""

#: ../../reference/lexical_analysis.rst:594
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings)."
msgstr ""

#: ../../reference/lexical_analysis.rst:603
msgid "Numeric literals"
msgstr "Literais Numéricos"

#: ../../reference/lexical_analysis.rst:619
msgid ""
"There are four types of numeric literals: plain integers, long integers, "
"floating point numbers, and imaginary numbers.  There are no complex "
"literals (complex numbers can be formed by adding a real number and an "
"imaginary number)."
msgstr ""

#: ../../reference/lexical_analysis.rst:623
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr ""
"Observe que os literais numéricos não incluem um sinal; uma frase como "
"``-1`` é, na verdade, uma expressão composta pelo operador unário '``-2``' e "
"o literal ``1``."

#: ../../reference/lexical_analysis.rst:631
msgid "Integer and long integer literals"
msgstr ""

#: ../../reference/lexical_analysis.rst:633
msgid ""
"Integer and long integer literals are described by the following lexical "
"definitions:"
msgstr ""

#: ../../reference/lexical_analysis.rst:648
msgid ""
"Although both lower case ``'l'`` and upper case ``'L'`` are allowed as "
"suffix for long integers, it is strongly recommended to always use ``'L'``, "
"since the letter ``'l'`` looks too much like the digit ``'1'``."
msgstr ""

#: ../../reference/lexical_analysis.rst:652
msgid ""
"Plain integer literals that are above the largest representable plain "
"integer (e.g., 2147483647 when using 32-bit arithmetic) are accepted as if "
"they were long integers instead. [#]_  There is no limit for long integer "
"literals apart from what can be stored in available memory."
msgstr ""

#: ../../reference/lexical_analysis.rst:657
msgid ""
"Some examples of plain integer literals (first row) and long integer "
"literals (second and third rows)::"
msgstr ""

#: ../../reference/lexical_analysis.rst:668
msgid "Floating point literals"
msgstr "Literais de Ponto Flutuante"

#: ../../reference/lexical_analysis.rst:670
msgid ""
"Floating point literals are described by the following lexical definitions:"
msgstr ""

#: ../../reference/lexical_analysis.rst:680
msgid ""
"Note that the integer and exponent parts of floating point numbers can look "
"like octal integers, but are interpreted using radix 10.  For example, "
"``077e010`` is legal, and denotes the same number as ``77e10``. The allowed "
"range of floating point literals is implementation-dependent. Some examples "
"of floating point literals::"
msgstr ""

#: ../../reference/lexical_analysis.rst:688
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator ``-`` and the literal "
"``1``."
msgstr ""

#: ../../reference/lexical_analysis.rst:696
msgid "Imaginary literals"
msgstr "Literais Imaginários"

#: ../../reference/lexical_analysis.rst:698
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr ""
"Os literais imaginários são descritos pelas seguintes definições léxicas:"

#: ../../reference/lexical_analysis.rst:703
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and have "
"the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr ""
"Um literal imaginário produz um número complexo com uma parte real de 0.0. "
"Os números complexos são representados como um par de números de ponto "
"flutuante e têm as mesmas restrições em seu alcance. Para criar um número "
"complexo com uma parte real diferente de zero, adicione um número de ponto "
"flutuante a ele, por exemplo, ``(3 + 4j)``. Alguns exemplos de literais "
"imaginários ::"

#: ../../reference/lexical_analysis.rst:715
msgid "Operators"
msgstr "Operadores"

#: ../../reference/lexical_analysis.rst:719
msgid "The following tokens are operators:"
msgstr "Os seguintes tokens são operadores:"

#: ../../reference/lexical_analysis.rst:728
msgid ""
"The comparison operators ``<>`` and ``!=`` are alternate spellings of the "
"same operator.  ``!=`` is the preferred spelling; ``<>`` is obsolescent."
msgstr ""

#: ../../reference/lexical_analysis.rst:735
msgid "Delimiters"
msgstr "Delimitadores"

#: ../../reference/lexical_analysis.rst:739
msgid "The following tokens serve as delimiters in the grammar:"
msgstr "Os seguintes tokens servem como delimitadores na gramática:"

#: ../../reference/lexical_analysis.rst:748
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis in slices. "
"The second half of the list, the augmented assignment operators, serve "
"lexically as delimiters, but also perform an operation."
msgstr ""

#: ../../reference/lexical_analysis.rst:753
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr ""
"Os seguintes caracteres ASCII imprimíveis têm um significado especial como "
"parte de outros tokens ou são significativos para o analisador léxico:"

#: ../../reference/lexical_analysis.rst:762
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error:"
msgstr ""
"Os seguintes caracteres ASCII imprimíveis não são usados em Python. Sua "
"ocorrência fora de literais de string e comentários é um erro incondicional:"

#: ../../reference/lexical_analysis.rst:770
msgid "Footnotes"
msgstr "Notas de Rodapé"

#: ../../reference/lexical_analysis.rst:771
msgid ""
"In versions of Python prior to 2.4, octal and hexadecimal literals in the "
"range just above the largest representable plain integer but below the "
"largest unsigned 32-bit number (on a machine using 32-bit arithmetic), "
"4294967296, were taken as the negative plain integer obtained by subtracting "
"4294967296 from their unsigned value."
msgstr ""

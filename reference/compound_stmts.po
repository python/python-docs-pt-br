# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-11 14:18+0000\n"
"PO-Revision-Date: 2025-08-15 19:01+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr "Instruções compostas"

#: ../../reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""
"Instruções compostas contém (grupos de) outras instruções; Elas afetam ou "
"controlam a execução dessas outras instruções de alguma maneira. Em geral, "
"instruções compostas abrangem múltiplas linhas, no entanto em algumas "
"manifestações simples uma instrução composta inteira pode estar contida em "
"uma linha."

#: ../../reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while the :keyword:"
"`with` statement allows the execution of initialization and finalization "
"code around a block of code.  Function and class definitions are also "
"syntactically compound statements."
msgstr ""
"As instruções :keyword:`if`, :keyword:`while` e :keyword:`for` implementam "
"construções  tradicionais de controle do fluxo de execução. :keyword:`try` "
"especifica tratadores de exceção e/ou código de limpeza para uma instrução "
"ou grupo de instruções, enquanto a palavra reservada :keyword:`with` permite "
"a execução de código de inicialização e finalização em volta de um bloco de "
"código. Definições de função e classe também são sintaticamente instruções "
"compostas."

#: ../../reference/compound_stmts.rst:26
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause consists "
"of a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of a suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be "
"clear to which :keyword:`if` clause a following :keyword:`else` clause would "
"belong::"
msgstr ""
"Uma instrução composta consiste em uma ou mais \"cláusulas\". Uma cláusula "
"consiste em um cabeçalho e um \"conjunto\". Os cabeçalhos das cláusulas de "
"uma instrução composta específica estão todos no mesmo nível de indentação. "
"Cada cabeçalho de cláusula começa com uma palavra reservada de identificação "
"exclusiva e termina com dois pontos. Um conjunto é um grupo de instruções "
"controladas por uma cláusula. Um conjunto pode ser uma ou mais instruções "
"simples separadas por ponto e vírgula na mesma linha do cabeçalho, após os "
"dois pontos do cabeçalho, ou pode ser uma ou mais instruções indentadas nas "
"linhas subsequentes. Somente a última forma de conjunto pode conter "
"instruções compostas aninhadas; o seguinte é ilegal, principalmente porque "
"não ficaria claro a qual cláusula :keyword:`if` a seguinte cláusula :keyword:"
"`else` pertenceria::"

#: ../../reference/compound_stmts.rst:37
msgid "if test1: if test2: print(x)"
msgstr "if test1: if test2: print(x)"

#: ../../reference/compound_stmts.rst:39
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr ""
"Observe também que o ponto e vírgula é mais vinculado que os dois pontos "
"neste contexto, de modo que no exemplo a seguir, todas ou nenhuma das "
"chamadas :func:`print` são executadas::"

#: ../../reference/compound_stmts.rst:43
msgid "if x < y < z: print(x); print(y); print(z)"
msgstr "if x < y < z: print(x); print(y); print(z)"

#: ../../reference/compound_stmts.rst:45
msgid "Summarizing:"
msgstr "Resumindo:"

#: ../../reference/compound_stmts.rst:69
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested :"
"keyword:`if` statements to be indented)."
msgstr ""
"Note que instruções sempre terminam em uma ``NEWLINE`` possivelmente seguida "
"por uma ``DEDENT``. Note também que cláusulas opcionais de continuação "
"sempre começam com uma palavra reservada que não pode iniciar uma instrução, "
"desta forma não há ambiguidades (o problema do \":keyword:`else` pendurado\" "
"é resolvido em Python obrigando que instruções :keyword:`if` aninhadas "
"tenham indentação)"

#: ../../reference/compound_stmts.rst:75
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr ""
"A formatação das regras de gramática nas próximas seções põe cada cláusula "
"em uma linha separada para as tornar mais claras."

#: ../../reference/compound_stmts.rst:84
msgid "The :keyword:`!if` statement"
msgstr "A instrução :keyword:`!if`"

#: ../../reference/compound_stmts.rst:92
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr "A instrução :keyword:`if` é usada para execução condicional:"

#: ../../reference/compound_stmts.rst:99
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""
"Ele seleciona exatamente um dos conjuntos avaliando as expressões uma por "
"uma até que uma seja considerada verdadeira (veja a seção :ref:`booleans` "
"para a definição de verdadeiro e falso); então esse conjunto é executado (e "
"nenhuma outra parte da instrução :keyword:`if` é executada ou avaliada). Se "
"todas as expressões forem falsas, o conjunto da cláusula :keyword:`else`, se "
"presente, é executado."

#: ../../reference/compound_stmts.rst:109
msgid "The :keyword:`!while` statement"
msgstr "A instrução :keyword:`!while`"

#: ../../reference/compound_stmts.rst:117
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ""
"A instrução :keyword:`while` é usada para execução repetida desde que uma "
"expressão seja verdadeira:"

#: ../../reference/compound_stmts.rst:124
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested) "
"the suite of the :keyword:`!else` clause, if present, is executed and the "
"loop terminates."
msgstr ""
"Isto testa repetidamente a expressão e, se for verdadeira, executa o "
"primeiro conjunto; se a expressão for falsa (o que pode ser a primeira vez "
"que ela é testada) o conjunto da cláusula :keyword:`!else`, se presente, é "
"executado e o laço termina."

#: ../../reference/compound_stmts.rst:133
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and goes back to testing the expression."
msgstr ""
"Uma instrução :keyword:`break` executada no primeiro conjunto termina o laço "
"sem executar o conjunto da cláusula :keyword:`!else`. Uma instrução :keyword:"
"`continue` executada no primeiro conjunto ignora o resto do conjunto e volta "
"a testar a expressão."

#: ../../reference/compound_stmts.rst:142
msgid "The :keyword:`!for` statement"
msgstr "A instrução :keyword:`!for`"

#: ../../reference/compound_stmts.rst:153
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""
"A instrução :keyword:`for` é usada para iterar sobre os elementos de uma "
"sequência (como uma string, tupla ou lista) ou outro objeto iterável:"

#: ../../reference/compound_stmts.rst:160
msgid ""
"The :token:`~python-grammar:starred_expression_list` expression is evaluated "
"once; it should yield an :term:`iterable` object. An :term:`iterator` is "
"created for that iterable. The first item provided by the iterator is then "
"assigned to the target list using the standard rules for assignments (see :"
"ref:`assignment`), and the suite is executed. This repeats for each item "
"provided by the iterator. When the iterator is exhausted, the suite in the :"
"keyword:`!else` clause, if present, is executed, and the loop terminates."
msgstr ""
"A expressão :token:`~python-grammar:starred_expression_list` é avaliada uma "
"vez; deve produzir um objeto :term:`iterável`. Um :term:`iterador` é criado "
"para esse iterável. O primeiro item fornecido pelo iterador é então "
"atribuído à lista de alvos usando as regras padrão para atribuições (veja :"
"ref:`assignment`), e o conjunto é executado. Isso se repete para cada item "
"fornecido pelo iterador. Quando o iterador se esgota, o conjunto na "
"cláusula :keyword:`!else`, se presente, é executado e laço termina."

#: ../../reference/compound_stmts.rst:173
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and continues with the next item, or with the :keyword:`!else` clause if "
"there is no next item."
msgstr ""
"Uma instrução :keyword:`break` executada no primeiro conjunto termina o loop "
"sem executar o conjunto da cláusula :keyword:`!else`. Uma instrução :keyword:"
"`continue` executada no primeiro conjunto pula o resto do conjunto e "
"continua com o próximo item, ou com a cláusula :keyword:`!else` se não "
"houver próximo item."

#: ../../reference/compound_stmts.rst:179
msgid ""
"The for-loop makes assignments to the variables in the target list. This "
"overwrites all previous assignments to those variables including those made "
"in the suite of the for-loop::"
msgstr ""
"O laço for faz atribuições às variáveis na lista de destino. Isso substitui "
"todas as atribuições anteriores a essas variáveis, incluindo aquelas feitas "
"no conjunto do laço for::"

#: ../../reference/compound_stmts.rst:183
msgid ""
"for i in range(10):\n"
"    print(i)\n"
"    i = 5             # this will not affect the for-loop\n"
"                      # because i will be overwritten with the next\n"
"                      # index in the range"
msgstr ""
"for i in range(10):\n"
"    print(i)\n"
"    i = 5             # não afeta o laço for, porque i será\n"
"                      # substituída pelo índice seguinte no range"

#: ../../reference/compound_stmts.rst:193
msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, they will not have been assigned to at all by the "
"loop.  Hint: the built-in type :func:`range` represents immutable arithmetic "
"sequences of integers. For instance, iterating ``range(3)`` successively "
"yields 0, 1, and then 2."
msgstr ""
"Os nomes na lista de destinos não são excluídos quando o laço termina, mas "
"se a sequência estiver vazia, eles não serão atribuídos pelo laço. Dica: o "
"tipo embutido :func:`range` representa sequências aritméticas imutáveis de "
"inteiros. Por exemplo, iterar ``range(3)`` sucessivamente produz 0, 1 e "
"depois 2."

#: ../../reference/compound_stmts.rst:198
msgid "Starred elements are now allowed in the expression list."
msgstr ""
"Elementos marcados com estrela agora são permitidos na lista de expressões."

#: ../../reference/compound_stmts.rst:205
msgid "The :keyword:`!try` statement"
msgstr "A instrução :keyword:`!try`"

#: ../../reference/compound_stmts.rst:215
msgid ""
"The :keyword:`!try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ""
"A instrução :keyword:`!try` especifica manipuladores de exceção e/ou código "
"de limpeza para um grupo de instruções:"

#: ../../reference/compound_stmts.rst:231
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information on using the :keyword:`raise` statement to "
"generate exceptions may be found in section :ref:`raise`."
msgstr ""
"Informações adicionais sobre exceções podem ser encontradas na seção :ref:"
"`exceptions`, e informações sobre como usar a instrução :keyword:`raise` "
"para gerar exceções podem ser encontradas na seção :ref:`raise`."

#: ../../reference/compound_stmts.rst:235
msgid ""
"Support for optionally dropping grouping parentheses when using multiple "
"exception types. See :pep:`758`."
msgstr ""
"Suporte para a remoção opcional de parênteses de agrupamento ao usar vários "
"tipos de exceção. Veja :pep:`758`."

#: ../../reference/compound_stmts.rst:241
msgid ":keyword:`!except` clause"
msgstr "Cláusula :keyword:`!except`"

#: ../../reference/compound_stmts.rst:243
msgid ""
"The :keyword:`!except` clause(s) specify one or more exception handlers. "
"When no exception occurs in the :keyword:`try` clause, no exception handler "
"is executed. When an exception occurs in the :keyword:`!try` suite, a search "
"for an exception handler is started. This search inspects the :keyword:`!"
"except` clauses in turn until one is found that matches the exception. An "
"expression-less :keyword:`!except` clause, if present, must be last; it "
"matches any exception."
msgstr ""
"As cláusulas :keyword:`!except` especificam um ou mais manipuladores de "
"exceção. Quando nenhuma exceção ocorre na cláusula :keyword:`try`, nenhum "
"manipulador de exceção é executado. Quando uma exceção ocorre no conjunto :"
"keyword:`!try`, uma busca por um manipulador de exceção é iniciada. Essa "
"busca inspeciona as cláusulas :keyword:`!except` por vez até que uma seja "
"encontrada que corresponda à exceção. Uma cláusula :keyword:`!except` sem "
"expressão, se presente, deve ser a última; ela corresponde a qualquer "
"exceção."

#: ../../reference/compound_stmts.rst:251
msgid ""
"For an :keyword:`!except` clause with an expression, the expression must "
"evaluate to an exception type or a tuple of exception types. Parentheses can "
"be dropped if multiple exception types are provided and the ``as`` clause is "
"not used. The raised exception matches an :keyword:`!except` clause whose "
"expression evaluates to the class or a :term:`non-virtual base class "
"<abstract base class>` of the exception object, or to a tuple that contains "
"such a class."
msgstr ""
"Para uma cláusula :keyword:`!except` com uma expressão, a expressão deve ser "
"avaliada como um tipo de exceção ou uma tupla de tipos de exceção. "
"Parênteses podem ser descartados se vários tipos de exceção forem fornecidos "
"e a cláusula ``as`` não for usada. A exceção levantada corresponde a uma "
"cláusula :keyword:`!except` cuja expressão é avaliada como a classe ou uma :"
"term:`classe base não virtual <abstract base class>` do objeto exceção, ou "
"como uma tupla que contém tal classe."

#: ../../reference/compound_stmts.rst:258
msgid ""
"If no :keyword:`!except` clause matches the exception, the search for an "
"exception handler continues in the surrounding code and on the invocation "
"stack.  [#]_"
msgstr ""
"Se nenhuma cláusula :keyword:`!except` corresponder à exceção, a busca por "
"um manipulador de exceção continua no código circundante e na pilha de "
"invocação. [#]_"

#: ../../reference/compound_stmts.rst:262
msgid ""
"If the evaluation of an expression in the header of an :keyword:`!except` "
"clause raises an exception, the original search for a handler is canceled "
"and a search starts for the new exception in the surrounding code and on the "
"call stack (it is treated as if the entire :keyword:`try` statement raised "
"the exception)."
msgstr ""
"Se a avaliação de uma expressão no cabeçalho de uma cláusula :keyword:`!"
"except` levantar uma exceção, a busca original por um manipulador será "
"cancelada e uma busca pela nova exceção será iniciada no código circundante "
"e na pilha de chamadas (ela é tratado como se toda a instrução :keyword:"
"`try` levantasse a exceção)."

#: ../../reference/compound_stmts.rst:270
msgid ""
"When a matching :keyword:`!except` clause is found, the exception is "
"assigned to the target specified after the :keyword:`!as` keyword in that :"
"keyword:`!except` clause, if present, and the :keyword:`!except` clause's "
"suite is executed. All :keyword:`!except` clauses must have an executable "
"block. When the end of this block is reached, execution continues normally "
"after the entire :keyword:`try` statement. (This means that if two nested "
"handlers exist for the same exception, and the exception occurs in the :"
"keyword:`!try` clause of the inner handler, the outer handler will not "
"handle the exception.)"
msgstr ""
"Quando uma cláusula :keyword:`!except` correspondente é encontrada, a "
"exceção é atribuída ao destino especificado após a palavra reservada :"
"keyword:`!as` nessa cláusula :keyword:`!except`, se presente, e o conjunto "
"da cláusula :keyword:`!except` é executado. Todas as cláusulas :keyword:`!"
"except` devem ter um bloco executável. Quando o final deste bloco é "
"atingido, a execução continua normalmente após toda a instrução :keyword:"
"`try`. (Isso significa que se existirem dois manipuladores aninhados para a "
"mesma exceção, e a exceção ocorrer na cláusula :keyword:`!try` do "
"manipulador interno, o manipulador externo não tratará a exceção.)"

#: ../../reference/compound_stmts.rst:281
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the :keyword:`!except` clause.  This is as if ::"
msgstr ""
"Quando uma exceção foi atribuída usando ``as target``, ela é limpa no final "
"da cláusula :keyword:`!except`. É como se ::"

#: ../../reference/compound_stmts.rst:284
msgid ""
"except E as N:\n"
"    foo"
msgstr ""
"except E as N:\n"
"    foo"

#: ../../reference/compound_stmts.rst:287
msgid "was translated to ::"
msgstr "fosse traduzido para ::"

#: ../../reference/compound_stmts.rst:289
msgid ""
"except E as N:\n"
"    try:\n"
"        foo\n"
"    finally:\n"
"        del N"
msgstr ""
"except E as N:\n"
"    try:\n"
"        foo\n"
"    finally:\n"
"        del N"

#: ../../reference/compound_stmts.rst:295
msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the :keyword:`!except` clause. Exceptions are cleared "
"because with the traceback attached to them, they form a reference cycle "
"with the stack frame, keeping all locals in that frame alive until the next "
"garbage collection occurs."
msgstr ""
"Isso significa que a exceção deve ser atribuída a um nome diferente para "
"poder referenciá-la após a cláusula :keyword:`!except`. As exceções são "
"limpas porque, com o traceback (situação da pilha de execução) anexado a "
"elas, elas formam um ciclo de referência com o quadro de pilha, mantendo "
"todos os locais nesse quadro vivos até que ocorra a próxima coleta de lixo."

#: ../../reference/compound_stmts.rst:305
msgid ""
"Before an :keyword:`!except` clause's suite is executed, the exception is "
"stored in the :mod:`sys` module, where it can be accessed from within the "
"body of the :keyword:`!except` clause by calling :func:`sys.exception`. When "
"leaving an exception handler, the exception stored in the :mod:`sys` module "
"is reset to its previous value::"
msgstr ""
"Antes de um conjunto de cláusulas :keyword:`!except` ser executado, a "
"exceção é armazenada no módulo :mod:`sys`, onde pode ser acessada de dentro "
"do corpo da cláusula :keyword:`!except` chamando :func:`sys.exception`. Ao "
"sair de um manipulador de exceções, a exceção armazenada no módulo :mod:"
"`sys` é redefinida para seu valor anterior::"

#: ../../reference/compound_stmts.rst:311
msgid ""
">>> print(sys.exception())\n"
"None\n"
">>> try:\n"
"...     raise TypeError\n"
"... except:\n"
"...     print(repr(sys.exception()))\n"
"...     try:\n"
"...          raise ValueError\n"
"...     except:\n"
"...         print(repr(sys.exception()))\n"
"...     print(repr(sys.exception()))\n"
"...\n"
"TypeError()\n"
"ValueError()\n"
"TypeError()\n"
">>> print(sys.exception())\n"
"None"
msgstr ""
">>> print(sys.exception())\n"
"None\n"
">>> try:\n"
"...     raise TypeError\n"
"... except:\n"
"...     print(repr(sys.exception()))\n"
"...     try:\n"
"...          raise ValueError\n"
"...     except:\n"
"...         print(repr(sys.exception()))\n"
"...     print(repr(sys.exception()))\n"
"...\n"
"TypeError()\n"
"ValueError()\n"
"TypeError()\n"
">>> print(sys.exception())\n"
"None"

#: ../../reference/compound_stmts.rst:336
msgid ":keyword:`!except*` clause"
msgstr "Cláusula :keyword:`!except*`"

#: ../../reference/compound_stmts.rst:338
msgid ""
"The :keyword:`!except*` clause(s) are used for handling :exc:"
"`ExceptionGroup`\\s. The exception type for matching is interpreted as in "
"the case of :keyword:`except`, but in the case of exception groups we can "
"have partial matches when the type matches some of the exceptions in the "
"group. This means that multiple :keyword:`!except*` clauses can execute, "
"each handling part of the exception group. Each clause executes at most once "
"and handles an exception group of all matching exceptions.  Each exception "
"in the group is handled by at most one :keyword:`!except*` clause, the first "
"that matches it. ::"
msgstr ""
"As cláusulas :keyword:`!except*` são usadas para manipular :exc:"
"`ExceptionGroup`\\s. O tipo de exceção para correspondência é interpretado "
"como no caso de :keyword:`except`, mas no caso de grupos de exceção, podemos "
"ter correspondências parciais quando o tipo corresponde a algumas das "
"exceções no grupo. Isso significa que várias cláusulas :keyword:`!except*` "
"podem ser executadas, cada uma manipulando parte do grupo de exceções. Cada "
"cláusula é executada no máximo uma vez e manipula um grupo de exceções de "
"todas as exceções correspondentes. Cada exceção no grupo é manipulada por no "
"máximo uma cláusula :keyword:`!except*`, a primeira que corresponde a ela. ::"

#: ../../reference/compound_stmts.rst:348
msgid ""
">>> try:\n"
"...     raise ExceptionGroup(\"eg\",\n"
"...         [ValueError(1), TypeError(2), OSError(3), OSError(4)])\n"
"... except* TypeError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"... except* OSError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"...\n"
"caught <class 'ExceptionGroup'> with nested (TypeError(2),)\n"
"caught <class 'ExceptionGroup'> with nested (OSError(3), OSError(4))\n"
"  + Exception Group Traceback (most recent call last):\n"
"  |   File \"<stdin>\", line 2, in <module>\n"
"  | ExceptionGroup: eg\n"
"  +-+---------------- 1 ----------------\n"
"    | ValueError: 1\n"
"    +------------------------------------"
msgstr ""
">>> try:\n"
"...     raise ExceptionGroup(\"eg\",\n"
"...         [ValueError(1), TypeError(2), OSError(3), OSError(4)])\n"
"... except* TypeError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"... except* OSError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"...\n"
"caught <class 'ExceptionGroup'> with nested (TypeError(2),)\n"
"caught <class 'ExceptionGroup'> with nested (OSError(3), OSError(4))\n"
"  + Exception Group Traceback (most recent call last):\n"
"  |   File \"<stdin>\", line 2, in <module>\n"
"  | ExceptionGroup: eg\n"
"  +-+---------------- 1 ----------------\n"
"    | ValueError: 1\n"
"    +------------------------------------"

#: ../../reference/compound_stmts.rst:366
msgid ""
"Any remaining exceptions that were not handled by any :keyword:`!except*` "
"clause are re-raised at the end, along with all exceptions that were raised "
"from within the :keyword:`!except*` clauses. If this list contains more than "
"one exception to reraise, they are combined into an exception group."
msgstr ""
"Quaisquer exceções restantes que não foram manipuladas por nenhuma cláusula :"
"keyword:`!except*` são levantadas novamente no final, junto com todas as "
"exceções que foram levantadas de dentro das cláusulas :keyword:`!except*`. "
"Se esta lista contiver mais de uma exceção para levantar novamente, elas "
"serão combinadas em um grupo de exceções."

#: ../../reference/compound_stmts.rst:372
msgid ""
"If the raised exception is not an exception group and its type matches one "
"of the :keyword:`!except*` clauses, it is caught and wrapped by an exception "
"group with an empty message string. ::"
msgstr ""
"Se a exceção levantada não for um grupo de exceções e seu tipo corresponder "
"a uma das cláusulas :keyword:`!except*`, ela será capturada e encapsulada "
"por um grupo de exceções com uma string de mensagem vazia. ::"

#: ../../reference/compound_stmts.rst:376
msgid ""
">>> try:\n"
"...     raise BlockingIOError\n"
"... except* BlockingIOError as e:\n"
"...     print(repr(e))\n"
"...\n"
"ExceptionGroup('', (BlockingIOError()))"
msgstr ""
">>> try:\n"
"...     raise BlockingIOError\n"
"... except* BlockingIOError as e:\n"
"...     print(repr(e))\n"
"...\n"
"ExceptionGroup('', (BlockingIOError()))"

#: ../../reference/compound_stmts.rst:383
msgid ""
"An :keyword:`!except*` clause must have a matching expression; it cannot be "
"``except*:``. Furthermore, this expression cannot contain exception group "
"types, because that would have ambiguous semantics."
msgstr ""
"Uma cláusula :keyword:`!except*` deve ter uma expressão correspondente; não "
"pode ser ``except*:``. Além disso, essa expressão não pode conter tipos de "
"grupo de exceção, porque isso teria semântica ambígua."

#: ../../reference/compound_stmts.rst:387
msgid ""
"It is not possible to mix :keyword:`except` and :keyword:`!except*` in the "
"same :keyword:`try`. The :keyword:`break`, :keyword:`continue`, and :keyword:"
"`return` statements cannot appear in an :keyword:`!except*` clause."
msgstr ""

#: ../../reference/compound_stmts.rst:402
msgid ":keyword:`!else` clause"
msgstr "Cláusula :keyword:`!else`"

#: ../../reference/compound_stmts.rst:404
msgid ""
"The optional :keyword:`!else` clause is executed if the control flow leaves "
"the :keyword:`try` suite, no exception was raised, and no :keyword:"
"`return`, :keyword:`continue`, or :keyword:`break` statement was executed.  "
"Exceptions in the :keyword:`!else` clause are not handled by the preceding :"
"keyword:`except` clauses."
msgstr ""
"A cláusula opcional :keyword:`!else` é executada se o fluxo de controle "
"deixar o conjunto :keyword:`try`, nenhuma exceção foi levantada e nenhuma "
"instrução :keyword:`return`, :keyword:`continue` ou :keyword:`break` foi "
"executada. Exceções na cláusula :keyword:`!else` não são manipuladas pelas "
"cláusulas :keyword:`except` precedentes."

#: ../../reference/compound_stmts.rst:416
msgid ":keyword:`!finally` clause"
msgstr "Cláusula :keyword:`!finally`"

#: ../../reference/compound_stmts.rst:418
msgid ""
"If :keyword:`!finally` is present, it specifies a 'cleanup' handler.  The :"
"keyword:`try` clause is executed, including any :keyword:`except` and :"
"keyword:`else <except_else>` clauses. If an exception occurs in any of the "
"clauses and is not handled, the exception is temporarily saved. The :keyword:"
"`!finally` clause is executed.  If there is a saved exception it is re-"
"raised at the end of the :keyword:`!finally` clause. If the :keyword:`!"
"finally` clause raises another exception, the saved exception is set as the "
"context of the new exception. If the :keyword:`!finally` clause executes a :"
"keyword:`return`, :keyword:`break` or :keyword:`continue` statement, the "
"saved exception is discarded. For example, this function returns 42."
msgstr ""
"Se :keyword:`!finally` estiver presente, especifica um manipulador de "
"\"limpeza\". A cláusula :keyword:`try` é executada, incluindo quaisquer "
"cláusulas :keyword:`except` e :keyword:`else <except_else>`. Se uma exceção "
"ocorrer em qualquer uma das cláusulas e não for tratada, a exceção será "
"salva temporariamente. A cláusula :keyword:`!finally` é executada. Se houver "
"uma exceção salva, ela será levantada novamente no final da cláusula :"
"keyword:`!finally`. Se a cláusula :keyword:`!finally` levantar outra "
"exceção, a exceção salva será definida como o contexto da nova exceção. Se a "
"cláusula :keyword:`!finally` executar uma instrução :keyword:`return`, :"
"keyword:`break` ou :keyword:`continue`, a exceção salva será descartada. Por "
"exemplo, esta função retorna 42."

#: ../../reference/compound_stmts.rst:431
msgid ""
"def f():\n"
"    try:\n"
"        1/0\n"
"    finally:\n"
"        return 42"
msgstr ""
"def f():\n"
"    try:\n"
"        1/0\n"
"    finally:\n"
"        return 42"

#: ../../reference/compound_stmts.rst:439
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`!finally` clause."
msgstr ""
"As informações de exceção não estão disponíveis para o programa durante a "
"execução da cláusula :keyword:`!finally`."

#: ../../reference/compound_stmts.rst:447
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`!try`...\\ :keyword:`!"
"finally` statement, the :keyword:`!finally` clause is also executed 'on the "
"way out.'"
msgstr ""
"Quando uma instrução :keyword:`return`, :keyword:`break` ou :keyword:"
"`continue` é executada no conjunto :keyword:`try` de uma instrução :keyword:"
"`!try`...\\ :keyword:`!finally`, a cláusula :keyword:`!finally` também é "
"executada \"na saída\"."

#: ../../reference/compound_stmts.rst:451
msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`!finally` clause always executes, "
"a :keyword:`!return` statement executed in the :keyword:`!finally` clause "
"will always be the last one executed. The following function returns "
"'finally'."
msgstr ""
"O valor de retorno de uma função é determinado pela última instrução :"
"keyword:`return` executada. Como a cláusula :keyword:`!finally` sempre é "
"executada, uma instrução :keyword:`!return` executada na cláusula :keyword:`!"
"finally` sempre será a última executada. A função a seguir retorna "
"\"finally\"."

#: ../../reference/compound_stmts.rst:456
msgid ""
"def foo():\n"
"    try:\n"
"        return 'try'\n"
"    finally:\n"
"        return 'finally'"
msgstr ""
"def foo():\n"
"    try:\n"
"        return 'try'\n"
"    finally:\n"
"        return 'finally'"

#: ../../reference/compound_stmts.rst:464
msgid ""
"Prior to Python 3.8, a :keyword:`continue` statement was illegal in the :"
"keyword:`!finally` clause due to a problem with the implementation."
msgstr ""
"Antes do Python 3.8, uma instrução :keyword:`continue` era ilegal na "
"cláusula :keyword:`!finally` devido a um problema com a implementação."

#: ../../reference/compound_stmts.rst:468
msgid ""
"The compiler emits a :exc:`SyntaxWarning` when a :keyword:`return`, :keyword:"
"`break` or :keyword:`continue` appears in a :keyword:`!finally` block (see :"
"pep:`765`)."
msgstr ""
"O compilador emite uma exceção :exc:`SyntaxWarning` quando um :keyword:"
"`return`, :keyword:`break` ou :keyword:`continue` aparece em um bloco :"
"keyword:`!finally` (veja :pep:`765`)."

#: ../../reference/compound_stmts.rst:478
msgid "The :keyword:`!with` statement"
msgstr "A instrução :keyword:`!with`"

#: ../../reference/compound_stmts.rst:487
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ :keyword:"
"`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
"A instrução :keyword:`with` é usada para envolver em um invólucro a execução "
"de um bloco com métodos definidos por um gerenciador de contexto (veja a "
"seção :ref:`context-managers`). Isso permite que padrões comuns de uso de :"
"keyword:`try`...\\ :keyword:`except`...\\ :keyword:`finally` sejam "
"encapsulados para reutilização conveniente."

#: ../../reference/compound_stmts.rst:497
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as "
"follows:"
msgstr ""
"A execução da instrução :keyword:`with` com um \"item\" ocorre da seguinte "
"maneira:"

#: ../../reference/compound_stmts.rst:499
msgid ""
"The context expression (the expression given in the :token:`~python-grammar:"
"with_item`) is evaluated to obtain a context manager."
msgstr ""
"A expressão de contexto (a expressão fornecida em :token:`~python-grammar:"
"with_item`) é avaliada para obter um gerenciador de contexto."

#: ../../reference/compound_stmts.rst:502
msgid ""
"The context manager's :meth:`~object.__enter__` is loaded for later use."
msgstr ""
"O :meth:`~object.__enter__` do gerenciador de contexto é carregado para uso "
"posterior."

#: ../../reference/compound_stmts.rst:504
msgid "The context manager's :meth:`~object.__exit__` is loaded for later use."
msgstr ""
"O :meth:`~object.__exit__` do gerenciador de contexto é carregado para uso "
"posterior."

#: ../../reference/compound_stmts.rst:506
msgid "The context manager's :meth:`~object.__enter__` method is invoked."
msgstr ""
"O método :meth:`~object.__enter__` do gerenciador de contexto é invocado."

#: ../../reference/compound_stmts.rst:508
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`~object.__enter__` is assigned to it."
msgstr ""
"Se um alvo foi incluído na instrução :keyword:`with`, o valor de retorno de :"
"meth:`~object.__enter__` é atribuído a ele."

#: ../../reference/compound_stmts.rst:513
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`~object."
"__enter__` method returns without an error, then :meth:`~object.__exit__` "
"will always be called. Thus, if an error occurs during the assignment to the "
"target list, it will be treated the same as an error occurring within the "
"suite would be. See step 7 below."
msgstr ""
"A instrução :keyword:`with` garante que se o método :meth:`~object."
"__enter__` retornar sem um erro, então :meth:`~object.__exit__` sempre será "
"chamado. Assim, se ocorrer um erro durante a atribuição à lista de alvos, "
"ele será tratado da mesma forma que um erro ocorrendo dentro do conjunto "
"seria. Veja a etapa 7 abaixo."

#: ../../reference/compound_stmts.rst:519
msgid "The suite is executed."
msgstr "O conjunto é executado."

#: ../../reference/compound_stmts.rst:521
msgid ""
"The context manager's :meth:`~object.__exit__` method is invoked.  If an "
"exception caused the suite to be exited, its type, value, and traceback are "
"passed as arguments to :meth:`~object.__exit__`. Otherwise, three :const:"
"`None` arguments are supplied."
msgstr ""
"O método :meth:`~object.__exit__` do gerenciador de contexto é invocado. Se "
"uma exceção fez com que o conjunto fosse encerrado, seu tipo, valor e "
"traceback são passados como argumentos para :meth:`~object.__exit__`. Caso "
"contrário, três argumentos :const:`None` são fornecidos."

#: ../../reference/compound_stmts.rst:526
msgid ""
"If the suite was exited due to an exception, and the return value from the :"
"meth:`~object.__exit__` method was false, the exception is reraised.  If the "
"return value was true, the exception is suppressed, and execution continues "
"with the statement following the :keyword:`with` statement."
msgstr ""
"Se o conjunto foi encerrado devido a uma exceção, e o valor de retorno do "
"método :meth:`~object.__exit__` foi falso, a exceção é levantada novamente. "
"Se o valor de retorno era verdadeiro, a exceção é suprimida, e a execução "
"continua com a instrução após a instrução :keyword:`with`."

#: ../../reference/compound_stmts.rst:531
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`~object.__exit__` is ignored, and execution proceeds at "
"the normal location for the kind of exit that was taken."
msgstr ""
"Se o conjunto foi encerrado por qualquer motivo diferente de uma exceção, o "
"valor de retorno de :meth:`~object.__exit__` é ignorado e a execução "
"prossegue no local normal para o tipo de saída que foi realizada."

#: ../../reference/compound_stmts.rst:535
#: ../../reference/compound_stmts.rst:1552
#: ../../reference/compound_stmts.rst:1593
msgid "The following code::"
msgstr "O seguinte código::"

#: ../../reference/compound_stmts.rst:537
msgid ""
"with EXPRESSION as TARGET:\n"
"    SUITE"
msgstr ""
"with EXPRESSION as TARGET:\n"
"    SUITE"

#: ../../reference/compound_stmts.rst:540
#: ../../reference/compound_stmts.rst:565
#: ../../reference/compound_stmts.rst:1598
msgid "is semantically equivalent to::"
msgstr "é semanticamente equivalente a::"

#: ../../reference/compound_stmts.rst:542
msgid ""
"manager = (EXPRESSION)\n"
"enter = type(manager).__enter__\n"
"exit = type(manager).__exit__\n"
"value = enter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not exit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        exit(manager, None, None, None)"
msgstr ""
"manager = (EXPRESSION)\n"
"enter = type(manager).__enter__\n"
"exit = type(manager).__exit__\n"
"value = enter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not exit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        exit(manager, None, None, None)"

#: ../../reference/compound_stmts.rst:559
msgid ""
"With more than one item, the context managers are processed as if multiple :"
"keyword:`with` statements were nested::"
msgstr ""
"Com mais de um item, os gerenciadores de contexto são processados como se "
"várias instruções :keyword:`with` estivessem aninhadas::"

#: ../../reference/compound_stmts.rst:562
msgid ""
"with A() as a, B() as b:\n"
"    SUITE"
msgstr ""
"with A() as a, B() as b:\n"
"    SUITE"

#: ../../reference/compound_stmts.rst:567
msgid ""
"with A() as a:\n"
"    with B() as b:\n"
"        SUITE"
msgstr ""
"with A() as a:\n"
"    with B() as b:\n"
"        SUITE"

#: ../../reference/compound_stmts.rst:571
msgid ""
"You can also write multi-item context managers in multiple lines if the "
"items are surrounded by parentheses. For example::"
msgstr ""
"Você também pode escrever gerenciadores de contexto multi-item em várias "
"linhas se os itens estiverem entre parênteses. Por exemplo::"

#: ../../reference/compound_stmts.rst:574
msgid ""
"with (\n"
"    A() as a,\n"
"    B() as b,\n"
"):\n"
"    SUITE"
msgstr ""
"with (\n"
"    A() as a,\n"
"    B() as b,\n"
"):\n"
"    SUITE"

#: ../../reference/compound_stmts.rst:580
msgid "Support for multiple context expressions."
msgstr "Suporte para múltiplas expressões de contexto."

#: ../../reference/compound_stmts.rst:583
msgid ""
"Support for using grouping parentheses to break the statement in multiple "
"lines."
msgstr ""
"Suporte para usar parênteses de agrupamento para dividir a instrução em "
"várias linhas."

#: ../../reference/compound_stmts.rst:588
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - A instrução \"with\""

#: ../../reference/compound_stmts.rst:589
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""
"A especificação, o histórico e os exemplos para a instrução Python :keyword:"
"`with`."

#: ../../reference/compound_stmts.rst:595
msgid "The :keyword:`!match` statement"
msgstr "A instrução :keyword:`!match`"

#: ../../reference/compound_stmts.rst:609
msgid "The match statement is used for pattern matching.  Syntax:"
msgstr "A instrução match é usada para correspondência de padrões. Sintaxe:"

#: ../../reference/compound_stmts.rst:618
msgid ""
"This section uses single quotes to denote :ref:`soft keywords <soft-"
"keywords>`."
msgstr ""
"Esta seção usa aspas simples para denotar :ref:`palavras reservadas "
"contextuais <soft-keywords>`."

#: ../../reference/compound_stmts.rst:621
msgid ""
"Pattern matching takes a pattern as input (following ``case``) and a subject "
"value (following ``match``).  The pattern (which may contain subpatterns) is "
"matched against the subject value.  The outcomes are:"
msgstr ""
"A correspondência de padrões aceita um padrão como entrada (seguindo "
"``case``) e um valor de sujeito (seguindo ``match``). O padrão (que pode "
"conter subpadrões) é correspondido ao valor de assunto. Os resultados são:"

#: ../../reference/compound_stmts.rst:625
msgid "A match success or failure (also termed a pattern success or failure)."
msgstr ""
"Um sucesso ou falha de correspondência (também chamado de sucesso ou falha "
"de padrão)."

#: ../../reference/compound_stmts.rst:627
msgid ""
"Possible binding of matched values to a name.  The prerequisites for this "
"are further discussed below."
msgstr ""
"Possível vinculação de valores correspondentes a um nome. Os pré-requisitos "
"para isso são discutidos mais adiante."

#: ../../reference/compound_stmts.rst:630
msgid ""
"The ``match`` and ``case`` keywords are :ref:`soft keywords <soft-keywords>`."
msgstr ""
"As palavras reservadas ``match`` e ``case`` são :ref:`palavras reservadas "
"contextuais <soft-keywords>`."

#: ../../reference/compound_stmts.rst:634
#: ../../reference/compound_stmts.rst:1191
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` -- Structural Pattern Matching: Specification"

#: ../../reference/compound_stmts.rst:635
#: ../../reference/compound_stmts.rst:1192
msgid ":pep:`636` -- Structural Pattern Matching: Tutorial"
msgstr ":pep:`636` -- Correspondência de padrões estruturais: Tutorial"

#: ../../reference/compound_stmts.rst:639
msgid "Overview"
msgstr "Visão Geral"

#: ../../reference/compound_stmts.rst:641
msgid "Here's an overview of the logical flow of a match statement:"
msgstr "Aqui está uma visão geral do fluxo lógico de uma instrução match:"

#: ../../reference/compound_stmts.rst:644
msgid ""
"The subject expression ``subject_expr`` is evaluated and a resulting subject "
"value obtained. If the subject expression contains a comma, a tuple is "
"constructed using :ref:`the standard rules <typesseq-tuple>`."
msgstr ""
"A expressão de sujeito ``subject_expr`` é avaliada e um valor de sujeito "
"resultante é obtido. Se a expressão de sujeito contiver uma vírgula, uma "
"tupla é construída usando :ref:`as regras padrão <typesseq-tuple>`."

#: ../../reference/compound_stmts.rst:648
msgid ""
"Each pattern in a ``case_block`` is attempted to match with the subject "
"value. The specific rules for success or failure are described below. The "
"match attempt can also bind some or all of the standalone names within the "
"pattern. The precise pattern binding rules vary per pattern type and are "
"specified below.  **Name bindings made during a successful pattern match "
"outlive the executed block and can be used after the match statement**."
msgstr ""
"Cada padrão em um ``case_block`` é tentado para corresponder ao valor de "
"sujeito. As regras específicas para sucesso ou falha são descritas abaixo. A "
"tentativa de correspondência também pode vincular alguns ou todos os nomes "
"autônomos dentro do padrão. As regras precisas de vinculação de padrão "
"variam por tipo de padrão e são especificadas abaixo. **As vinculações de "
"nome feitas durante uma correspondência de padrão bem-sucedida sobrevivem ao "
"bloco executado e podem ser usadas após a instrução match**."

#: ../../reference/compound_stmts.rst:657
msgid ""
"During failed pattern matches, some subpatterns may succeed.  Do not rely on "
"bindings being made for a failed match.  Conversely, do not rely on "
"variables remaining unchanged after a failed match.  The exact behavior is "
"dependent on implementation and may vary.  This is an intentional decision "
"made to allow different implementations to add optimizations."
msgstr ""
"Durante correspondências de padrões com falha, alguns subpadrões podem ter "
"sucesso. Não confie em vinculações sendo feitas para uma correspondência com "
"falha. Por outro lado, não confie em variáveis permanecendo inalteradas após "
"uma correspondência com falha. O comportamento exato depende da "
"implementação e pode variar. Esta é uma decisão intencional feita para "
"permitir que diferentes implementações adicionem otimizações."

#: ../../reference/compound_stmts.rst:664
msgid ""
"If the pattern succeeds, the corresponding guard (if present) is evaluated. "
"In this case all name bindings are guaranteed to have happened."
msgstr ""
"Se o padrão for bem-sucedido, o *guard* correspondente (se presente) é "
"avaliado. Neste caso, todas as vinculações de nome são garantidas como tendo "
"acontecido."

#: ../../reference/compound_stmts.rst:667
msgid ""
"If the guard evaluates as true or is missing, the ``block`` inside "
"``case_block`` is executed."
msgstr ""
"Se o *guard* for avaliado como verdadeiro ou estiver ausente, o ``block`` "
"dentro de ``case_block`` será executado."

#: ../../reference/compound_stmts.rst:670
msgid "Otherwise, the next ``case_block`` is attempted as described above."
msgstr ""
"Caso contrário, o próximo ``case_block`` será tentado conforme descrito "
"acima."

#: ../../reference/compound_stmts.rst:672
msgid "If there are no further case blocks, the match statement is completed."
msgstr "Se não houver mais blocos de caso, a instrução match será concluída."

#: ../../reference/compound_stmts.rst:676
msgid ""
"Users should generally never rely on a pattern being evaluated.  Depending "
"on implementation, the interpreter may cache values or use other "
"optimizations which skip repeated evaluations."
msgstr ""
"Os usuários geralmente nunca devem confiar em um padrão sendo avaliado. "
"Dependendo da implementação, o interpretador pode armazenar valores em cache "
"ou usar outras otimizações que pulam avaliações repetidas."

#: ../../reference/compound_stmts.rst:680
msgid "A sample match statement::"
msgstr "Um exemplo de instrução match::"

#: ../../reference/compound_stmts.rst:682
msgid ""
">>> flag = False\n"
">>> match (100, 200):\n"
"...    case (100, 300):  # Mismatch: 200 != 300\n"
"...        print('Case 1')\n"
"...    case (100, 200) if flag:  # Successful match, but guard fails\n"
"...        print('Case 2')\n"
"...    case (100, y):  # Matches and binds y to 200\n"
"...        print(f'Case 3, y: {y}')\n"
"...    case _:  # Pattern not attempted\n"
"...        print('Case 4, I match anything!')\n"
"...\n"
"Case 3, y: 200"
msgstr ""
">>> flag = False\n"
">>> match (100, 200):\n"
"...    case (100, 300):  # Não corresponde: 200 != 300\n"
"...        print('Case 1')\n"
"...    case (100, 200) if flag:  # Corresponde com sucesso, mas o guard "
"falha...\n"
"        print('Case 2')\n"
"...    case (100, y):  # Corresponde e vincula y a 200\n"
"...        print(f'Case 3, y: {y}')\n"
"...    case _:  # Padrão não testado\n"
"...        print('Case 4, I match anything!')\n"
"...\n"
"Case 3, y: 200"

#: ../../reference/compound_stmts.rst:696
msgid ""
"In this case, ``if flag`` is a guard.  Read more about that in the next "
"section."
msgstr ""
"Neste caso, ``if flag`` é um *guard*. Leia mais sobre isso na próxima seção."

#: ../../reference/compound_stmts.rst:699
msgid "Guards"
msgstr "Guards"

#: ../../reference/compound_stmts.rst:706
msgid ""
"A ``guard`` (which is part of the ``case``) must succeed for code inside the "
"``case`` block to execute.  It takes the form: :keyword:`if` followed by an "
"expression."
msgstr ""
"Um ``guard`` (que faz parte do ``case``) deve ter sucesso para que o código "
"dentro do bloco ``case`` seja executado. Ele assume a forma: :keyword:`if` "
"seguido por uma expressão."

#: ../../reference/compound_stmts.rst:711
msgid "The logical flow of a ``case`` block with a ``guard`` follows:"
msgstr "O fluxo lógico de um bloco ``case`` com um ``guard`` é o seguinte:"

#: ../../reference/compound_stmts.rst:713
msgid ""
"Check that the pattern in the ``case`` block succeeded.  If the pattern "
"failed, the ``guard`` is not evaluated and the next ``case`` block is "
"checked."
msgstr ""
"Verifique se o padrão no bloco ``case`` foi bem-sucedido. Se o padrão "
"falhou, o ``guard`` não é avaliado e o próximo bloco ``case`` é verificado."

#: ../../reference/compound_stmts.rst:717
msgid "If the pattern succeeded, evaluate the ``guard``."
msgstr "Se o padrão for bem-sucedido, avalia o ``guard``."

#: ../../reference/compound_stmts.rst:719
msgid ""
"If the ``guard`` condition evaluates as true, the case block is selected."
msgstr ""
"Se a condição ``guard`` for avaliada como verdadeira, o bloco de caso será "
"selecionado."

#: ../../reference/compound_stmts.rst:722
msgid ""
"If the ``guard`` condition evaluates as false, the case block is not "
"selected."
msgstr ""
"Se a condição ``guard`` for avaliada como falsa, o bloco de caso não será "
"selecionado."

#: ../../reference/compound_stmts.rst:725
msgid ""
"If the ``guard`` raises an exception during evaluation, the exception "
"bubbles up."
msgstr ""
"Se o ``guard`` levantar uma exceção durante a avaliação, a exceção surgirá."

#: ../../reference/compound_stmts.rst:728
msgid ""
"Guards are allowed to have side effects as they are expressions.  Guard "
"evaluation must proceed from the first to the last case block, one at a "
"time, skipping case blocks whose pattern(s) don't all succeed. (I.e., guard "
"evaluation must happen in order.) Guard evaluation must stop once a case "
"block is selected."
msgstr ""
"Guards podem ter efeitos colaterais, pois são expressões. A avaliação de "
"guards deve prosseguir do primeiro ao último bloco de caso, um de cada vez, "
"pulando blocos de caso cujos padrões não são todos bem-sucedidos. (Isto é, a "
"avaliação de guardas deve acontecer em ordem.) A avaliação de guards deve "
"parar quando um bloco de caso for selecionado."

#: ../../reference/compound_stmts.rst:738
msgid "Irrefutable Case Blocks"
msgstr "Blocos irrefutáveis de case"

#: ../../reference/compound_stmts.rst:742
msgid ""
"An irrefutable case block is a match-all case block.  A match statement may "
"have at most one irrefutable case block, and it must be last."
msgstr ""
"Um bloco irrefutável de case é um bloco de case que corresponde a qualquer "
"valor. Uma instrução match pode ter no máximo um bloco irrefutável de case, "
"e ele deve ser o último."

#: ../../reference/compound_stmts.rst:745
msgid ""
"A case block is considered irrefutable if it has no guard and its pattern is "
"irrefutable.  A pattern is considered irrefutable if we can prove from its "
"syntax alone that it will always succeed.  Only the following patterns are "
"irrefutable:"
msgstr ""
"Um bloco de case é considerado irrefutável se não tiver guard e seu padrão "
"for irrefutável. Um padrão é considerado irrefutável se pudermos provar "
"somente por sua sintaxe que ele sempre terá sucesso. Somente os seguintes "
"padrões são irrefutáveis:"

#: ../../reference/compound_stmts.rst:750
msgid ":ref:`as-patterns` whose left-hand side is irrefutable"
msgstr ":ref:`as-patterns` cujo lado esquerdo é irrefutável"

#: ../../reference/compound_stmts.rst:752
msgid ":ref:`or-patterns` containing at least one irrefutable pattern"
msgstr ":ref:`or-patterns` contendo pelo menos um padrão irrefutável"

#: ../../reference/compound_stmts.rst:754
msgid ":ref:`capture-patterns`"
msgstr ":ref:`capture-patterns`"

#: ../../reference/compound_stmts.rst:756
msgid ":ref:`wildcard-patterns`"
msgstr ":ref:`wildcard-patterns`"

#: ../../reference/compound_stmts.rst:758
msgid "parenthesized irrefutable patterns"
msgstr "padrões irrefutáveis entre parêteses"

#: ../../reference/compound_stmts.rst:762
msgid "Patterns"
msgstr "Padrões"

#: ../../reference/compound_stmts.rst:769
msgid "This section uses grammar notations beyond standard EBNF:"
msgstr "Esta seção usa notações de gramática para além do padrão de EBNF:"

#: ../../reference/compound_stmts.rst:771
msgid "the notation ``SEP.RULE+`` is shorthand for ``RULE (SEP RULE)*``"
msgstr "a notação ``SEP.RULE+`` é uma abreviação para ``RULE (SEP RULE)*``"

#: ../../reference/compound_stmts.rst:773
msgid "the notation ``!RULE`` is shorthand for a negative lookahead assertion"
msgstr ""
"a notação ``!RULE`` é uma abreviação para uma asserção de negação antecipada."

#: ../../reference/compound_stmts.rst:776
msgid "The top-level syntax for ``patterns`` is:"
msgstr "Esta é a sintaxe de nível superior para ``patterns`` (padrões):"

#: ../../reference/compound_stmts.rst:790
msgid ""
"The descriptions below will include a description \"in simple terms\" of "
"what a pattern does for illustration purposes (credits to Raymond Hettinger "
"for a document that inspired most of the descriptions). Note that these "
"descriptions are purely for illustration purposes and **may not** reflect "
"the underlying implementation.  Furthermore, they do not cover all valid "
"forms."
msgstr ""
"As descrições abaixo incluirão uma descrição \"em termos simples\" de o que "
"o padrão faz para fins ilustrativos (créditos a Raymond Hettinger pelo "
"documento que inspirou a maioria das descrições). Note que essas descrições "
"são puramente para fins ilustrativos, e **não necessariamente** refletem a "
"implementação subjacente.  Além disso, elas não cobrem todas as formas "
"válidas."

#: ../../reference/compound_stmts.rst:800
msgid "OR Patterns"
msgstr "Padrões OR"

#: ../../reference/compound_stmts.rst:802
msgid ""
"An OR pattern is two or more patterns separated by vertical bars ``|``.  "
"Syntax:"
msgstr ""
"Um padrão OR é composto por dois ou mais padrões separados por barras "
"verticais ``|``.  Sintaxe:"

#: ../../reference/compound_stmts.rst:808
msgid ""
"Only the final subpattern may be :ref:`irrefutable <irrefutable_case>`, and "
"each subpattern must bind the same set of names to avoid ambiguity."
msgstr ""
"Somente o último subpadrão pode ser :ref:`irrefutável <irrefutable_case>`, e "
"cada subpadrão deve vincular o mesmo conjunto de nomes para evitar "
"ambiguidades."

#: ../../reference/compound_stmts.rst:811
msgid ""
"An OR pattern matches each of its subpatterns in turn to the subject value, "
"until one succeeds.  The OR pattern is then considered successful.  "
"Otherwise, if none of the subpatterns succeed, the OR pattern fails."
msgstr ""
"Um padrão OR testa a correspondência de cada um dos seus subpadrões, em "
"sequência, ao valor do sujeito, até que uma delas seja bem sucedida.  O "
"padrão OR é então considerado bem sucedido.  Caso contrário, se todas elas "
"falharam, o padrão OR falhou."

#: ../../reference/compound_stmts.rst:815
msgid ""
"In simple terms, ``P1 | P2 | ...`` will try to match ``P1``, if it fails it "
"will try to match ``P2``, succeeding immediately if any succeeds, failing "
"otherwise."
msgstr ""
"Em termos simples, ``P1 | P2 | ...`` vai tentar fazer corresponder ``P1``, "
"se falhar vai tentar ``P2``, declarando sucesso se houver sucesso em "
"qualquer uma das tentativas, e falhando caso contrário."

#: ../../reference/compound_stmts.rst:821
msgid "AS Patterns"
msgstr "Padrões AS"

#: ../../reference/compound_stmts.rst:823
msgid ""
"An AS pattern matches an OR pattern on the left of the :keyword:`as` keyword "
"against a subject.  Syntax:"
msgstr ""
"Um padrão AS corresponde a um padrão OR à esquerda da palavra reservada :"
"keyword:`as` de um assunto. Sintaxe:"

#: ../../reference/compound_stmts.rst:829
msgid ""
"If the OR pattern fails, the AS pattern fails.  Otherwise, the AS pattern "
"binds the subject to the name on the right of the as keyword and succeeds. "
"``capture_pattern`` cannot be a ``_``."
msgstr ""
"Se o padrão OR falhar, o padrão AS falhará. Caso contrário, o padrão AS "
"vincula o assunto ao nome à direita da palavra-chave as e obtém sucesso. "
"``capture_pattern`` não pode ser um ``_``."

#: ../../reference/compound_stmts.rst:833
msgid ""
"In simple terms ``P as NAME`` will match with ``P``, and on success it will "
"set ``NAME = <subject>``."
msgstr ""
"Em termos simples, ``P as NAME`` corresponderá a ``P`` e, em caso de "
"sucesso, definirá ``NAME = <assunto>``."

#: ../../reference/compound_stmts.rst:840
msgid "Literal Patterns"
msgstr "Padrões literais"

#: ../../reference/compound_stmts.rst:842
msgid ""
"A literal pattern corresponds to most :ref:`literals <literals>` in Python.  "
"Syntax:"
msgstr ""
"Um padrão literal corresponde à maioria dos :ref:`literais <literals>` em "
"Python. Sintaxe:"

#: ../../reference/compound_stmts.rst:855
msgid ""
"The rule ``strings`` and the token ``NUMBER`` are defined in the :doc:"
"`standard Python grammar <./grammar>`.  Triple-quoted strings are "
"supported.  Raw strings and byte strings are supported.  :ref:`f-strings` "
"and :ref:`t-strings` are not supported."
msgstr ""
"A regra ``strings`` e o token ``NUMBER`` são definidos na :doc:`gramática "
"padrão do Python <./grammar>`. Strings entre aspas triplas são suportadas. "
"Strings brutas e strings de bytes são suportadas. :ref:`f-strings` e :ref:`t-"
"strings` não são suportadas."

#: ../../reference/compound_stmts.rst:860
msgid ""
"The forms ``signed_number '+' NUMBER`` and ``signed_number '-' NUMBER`` are "
"for expressing :ref:`complex numbers <imaginary>`; they require a real "
"number on the left and an imaginary number on the right. E.g. ``3 + 4j``."
msgstr ""
"As formas ``signed_number '+' NUMBER`` e ``signed_number '-' NUMBER`` são "
"para expressar :ref:`números complexos <imaginary>`; elas requerem um número "
"real à esquerda e um número imaginário à direita. Por exemplo, ``3 + 4j``."

#: ../../reference/compound_stmts.rst:864
msgid ""
"In simple terms, ``LITERAL`` will succeed only if ``<subject> == LITERAL``. "
"For the singletons ``None``, ``True`` and ``False``, the :keyword:`is` "
"operator is used."
msgstr ""
"Em termos simples, ``LITERAL`` terá sucesso somente se ``<assunto> == "
"LITERAL``. Para os singletons ``None``, ``True`` e ``False``, o operador :"
"keyword:`is` é usado."

#: ../../reference/compound_stmts.rst:870
msgid "Capture Patterns"
msgstr "Padrões de captura"

#: ../../reference/compound_stmts.rst:872
msgid "A capture pattern binds the subject value to a name. Syntax:"
msgstr "Um padrão de captura vincula o valor do assunto a um nome. Sintaxe:"

#: ../../reference/compound_stmts.rst:878
msgid ""
"A single underscore ``_`` is not a capture pattern (this is what ``!'_'`` "
"expresses). It is instead treated as a :token:`~python-grammar:"
"wildcard_pattern`."
msgstr ""
"Um único sublinhado ``_`` não é um padrão de captura (é o que ``!'_'`` "
"expressa). Em vez disso, ele é tratado como um :token:`~python-grammar:"
"wildcard_pattern`."

#: ../../reference/compound_stmts.rst:882
msgid ""
"In a given pattern, a given name can only be bound once.  E.g. ``case x, "
"x: ...`` is invalid while ``case [x] | x: ...`` is allowed."
msgstr ""
"Em um determinado padrão, um determinado nome só pode ser vinculado uma vez. "
"Por exemplo, ``case x, x: ...`` é inválido enquanto ``case [x] | x: ...`` é "
"permitido."

#: ../../reference/compound_stmts.rst:885
msgid ""
"Capture patterns always succeed.  The binding follows scoping rules "
"established by the assignment expression operator in :pep:`572`; the name "
"becomes a local variable in the closest containing function scope unless "
"there's an applicable :keyword:`global` or :keyword:`nonlocal` statement."
msgstr ""
"Os padrões de captura sempre são bem-sucedidos. A vinculação segue regras de "
"escopo estabelecidas pelo operador de expressão de atribuição na :pep:`572`; "
"o nome se torna uma variável local no escopo de função de contenção mais "
"próximo, a menos que haja uma instrução :keyword:`global` ou :keyword:"
"`nonlocal` aplicável."

#: ../../reference/compound_stmts.rst:890
msgid ""
"In simple terms ``NAME`` will always succeed and it will set ``NAME = "
"<subject>``."
msgstr ""
"Em termos simples, ``NAME`` sempre terá sucesso e definirá ``NAME = "
"<assunto>``."

#: ../../reference/compound_stmts.rst:895
msgid "Wildcard Patterns"
msgstr "Padrões curingas"

#: ../../reference/compound_stmts.rst:897
msgid ""
"A wildcard pattern always succeeds (matches anything) and binds no name.  "
"Syntax:"
msgstr ""
"Um padrão curinga sempre tem sucesso (corresponde a qualquer coisa) e não "
"vincula nenhum nome. Sintaxe:"

#: ../../reference/compound_stmts.rst:903
msgid ""
"``_`` is a :ref:`soft keyword <soft-keywords>` within any pattern, but only "
"within patterns.  It is an identifier, as usual, even within ``match`` "
"subject expressions, ``guard``\\ s, and ``case`` blocks."
msgstr ""
"``_`` é uma :ref:`palavra reservada contextual <soft-keywords>` dentro de "
"qualquer padrão, mas somente dentro de padrões. É um identificador, como de "
"costume, mesmo dentro de expressões de assunto ``match``\\ s, ``guard``\\ s "
"e blocos ``case``."

#: ../../reference/compound_stmts.rst:907
msgid "In simple terms, ``_`` will always succeed."
msgstr "Em termos simples, ``_`` sempre terá sucesso."

#: ../../reference/compound_stmts.rst:912
msgid "Value Patterns"
msgstr "Padrões de valor"

#: ../../reference/compound_stmts.rst:914
msgid "A value pattern represents a named value in Python. Syntax:"
msgstr "Um padrão de valor representa um valor nomeado em Python. Sintaxe:"

#: ../../reference/compound_stmts.rst:922
msgid ""
"The dotted name in the pattern is looked up using standard Python :ref:`name "
"resolution rules <resolve_names>`.  The pattern succeeds if the value found "
"compares equal to the subject value (using the ``==`` equality operator)."
msgstr ""
"O nome pontilhado no padrão é pesquisado usando as :ref:`regras de resolução "
"de nomes <resolve_names>` padrão do Python. O padrão é bem-sucedido se o "
"valor encontrado for comparado igual ao valor do assunto (usando o operador "
"de igualdade ``==``)."

#: ../../reference/compound_stmts.rst:927
msgid ""
"In simple terms ``NAME1.NAME2`` will succeed only if ``<subject> == NAME1."
"NAME2``"
msgstr ""
"Em termos simples, ``NAME1.NAME2`` terá sucesso somente se ``<assunto> == "
"NAME1.NAME2``"

#: ../../reference/compound_stmts.rst:931
msgid ""
"If the same value occurs multiple times in the same match statement, the "
"interpreter may cache the first value found and reuse it rather than repeat "
"the same lookup.  This cache is strictly tied to a given execution of a "
"given match statement."
msgstr ""
"Se o mesmo valor ocorrer várias vezes na mesma instrução match, o "
"interpretador pode armazenar em cache o primeiro valor encontrado e "
"reutilizá-lo em vez de repetir a mesma pesquisa. Esse cache é estritamente "
"vinculado a uma determinada execução de uma determinada instrução match."

#: ../../reference/compound_stmts.rst:939
msgid "Group Patterns"
msgstr "Padrões de grupo"

#: ../../reference/compound_stmts.rst:941
msgid ""
"A group pattern allows users to add parentheses around patterns to emphasize "
"the intended grouping.  Otherwise, it has no additional syntax. Syntax:"
msgstr ""
"Um padrão de grupo permite que os usuários adicionem parênteses em torno de "
"padrões para enfatizar o agrupamento pretendido. Caso contrário, não há "
"sintaxe adicional. Sintaxe:"

#: ../../reference/compound_stmts.rst:948
msgid "In simple terms ``(P)`` has the same effect as ``P``."
msgstr "Em termos simples, ``(P)`` tem o mesmo efeito que ``P``."

#: ../../reference/compound_stmts.rst:953
msgid "Sequence Patterns"
msgstr "Padrões de sequência"

#: ../../reference/compound_stmts.rst:955
msgid ""
"A sequence pattern contains several subpatterns to be matched against "
"sequence elements. The syntax is similar to the unpacking of a list or tuple."
msgstr ""
"Um padrão de sequência contém vários subpadrões a serem correspondidos com "
"elementos de sequência. A sintaxe é similar ao desempacotamento de uma lista "
"ou tupla."

#: ../../reference/compound_stmts.rst:966
msgid ""
"There is no difference if parentheses  or square brackets are used for "
"sequence patterns (i.e. ``(...)`` vs ``[...]`` )."
msgstr ""
"Não há diferença se parênteses ou colchetes são usados para padrões de "
"sequência (por exemplo, ``(...)`` vs ``[...]``)."

#: ../../reference/compound_stmts.rst:970
msgid ""
"A single pattern enclosed in parentheses without a trailing comma (e.g. ``(3 "
"| 4)``) is a :ref:`group pattern <group-patterns>`. While a single pattern "
"enclosed in square brackets (e.g. ``[3 | 4]``) is still a sequence pattern."
msgstr ""
"Um único padrão entre parênteses sem uma vírgula final (por exemplo, ``(3 | "
"4)``) é um :ref:`padrão de grupo <group-patterns>`. Enquanto um único padrão "
"entre colchetes (por exemplo, ``[3 | 4]``) ainda é um padrão de sequência."

#: ../../reference/compound_stmts.rst:975
msgid ""
"At most one star subpattern may be in a sequence pattern.  The star "
"subpattern may occur in any position. If no star subpattern is present, the "
"sequence pattern is a fixed-length sequence pattern; otherwise it is a "
"variable-length sequence pattern."
msgstr ""
"No máximo um subpadrão de estrela pode estar em um padrão de sequência. O "
"subpadrão de estrela pode ocorrer em qualquer posição. Se nenhum subpadrão "
"de estrela estiver presente, o padrão de sequência é um padrão de sequência "
"de comprimento fixo; caso contrário, é um padrão de sequência de comprimento "
"variável."

#: ../../reference/compound_stmts.rst:980
msgid ""
"The following is the logical flow for matching a sequence pattern against a "
"subject value:"
msgstr ""
"A seguir está o fluxo lógico para corresponder um padrão de sequência com um "
"valor de assunto:"

#: ../../reference/compound_stmts.rst:983
msgid ""
"If the subject value is not a sequence [#]_, the sequence pattern fails."
msgstr ""
"Se o valor do assunto não for uma sequência [#]_, o padrão de sequência "
"falhará."

#: ../../reference/compound_stmts.rst:986
msgid ""
"If the subject value is an instance of ``str``, ``bytes`` or ``bytearray`` "
"the sequence pattern fails."
msgstr ""
"Se o valor do assunto for uma instância de ``str``, ``bytes`` ou "
"``bytearray``, o padrão de sequência falhará."

#: ../../reference/compound_stmts.rst:989
msgid ""
"The subsequent steps depend on whether the sequence pattern is fixed or "
"variable-length."
msgstr ""
"As etapas subsequentes dependem se o padrão de sequência é fixo ou de "
"comprimento variável."

#: ../../reference/compound_stmts.rst:992
msgid "If the sequence pattern is fixed-length:"
msgstr "Se o padrão de sequência for de comprimento fixo:"

#: ../../reference/compound_stmts.rst:994
msgid ""
"If the length of the subject sequence is not equal to the number of "
"subpatterns, the sequence pattern fails"
msgstr ""
"Se o comprimento da sequência do assunto não for igual ao número de "
"subpadrões, o padrão da sequência falha"

#: ../../reference/compound_stmts.rst:997
msgid ""
"Subpatterns in the sequence pattern are matched to their corresponding items "
"in the subject sequence from left to right.  Matching stops as soon as a "
"subpattern fails.  If all subpatterns succeed in matching their "
"corresponding item, the sequence pattern succeeds."
msgstr ""
"Subpadrões no padrão de sequência são correspondidos aos seus itens "
"correspondentes na sequência de assunto da esquerda para a direita. A "
"correspondência para assim que um subpadrão falha. Se todos os subpadrões "
"tiverem sucesso em corresponder ao seu item correspondente, o padrão de "
"sequência é bem-sucedido."

#: ../../reference/compound_stmts.rst:1002
msgid "Otherwise, if the sequence pattern is variable-length:"
msgstr "Caso contrário, se o padrão de sequência for de comprimento variável:"

#: ../../reference/compound_stmts.rst:1004
msgid ""
"If the length of the subject sequence is less than the number of non-star "
"subpatterns, the sequence pattern fails."
msgstr ""
"Se o comprimento da sequência do assunto for menor que o número de "
"subpadrões não-estrela, o padrão da sequência falha."

#: ../../reference/compound_stmts.rst:1007
msgid ""
"The leading non-star subpatterns are matched to their corresponding items as "
"for fixed-length sequences."
msgstr ""
"Os principais subpadrões não estelares são correspondidos aos seus itens "
"correspondentes, como nas sequências de comprimento fixo."

#: ../../reference/compound_stmts.rst:1010
msgid ""
"If the previous step succeeds, the star subpattern matches a list formed of "
"the remaining subject items, excluding the remaining items corresponding to "
"non-star subpatterns following the star subpattern."
msgstr ""
"Se a etapa anterior for bem-sucedida, o subpadrão estrela corresponde a uma "
"lista formada pelos itens de assunto restantes, excluindo os itens restantes "
"correspondentes aos subpadrões não-estrela que seguem o subpadrão estrela."

#: ../../reference/compound_stmts.rst:1014
msgid ""
"Remaining non-star subpatterns are matched to their corresponding subject "
"items, as for a fixed-length sequence."
msgstr ""
"Os subpadrões não-estrela restantes são correspondidos aos seus itens de "
"assunto correspondentes, como em uma sequência de comprimento fixo."

#: ../../reference/compound_stmts.rst:1017
msgid ""
"The length of the subject sequence is obtained via :func:`len` (i.e. via "
"the :meth:`~object.__len__` protocol). This length may be cached by the "
"interpreter in a similar manner as :ref:`value patterns <value-patterns>`."
msgstr ""

#: ../../reference/compound_stmts.rst:1023
msgid ""
"In simple terms ``[P1, P2, P3,`` ... ``, P<N>]`` matches only if all the "
"following happens:"
msgstr ""
"Em termos simples, ``[P1, P2, P3,`` ... ``, P<N>]`` corresponde somente se "
"tudo o seguinte acontecer:"

#: ../../reference/compound_stmts.rst:1026
msgid "check ``<subject>`` is a sequence"
msgstr "verifica se ``<subject>`` é uma sequência"

#: ../../reference/compound_stmts.rst:1027
msgid "``len(subject) == <N>``"
msgstr "``len(subject) == <N>``"

#: ../../reference/compound_stmts.rst:1028
msgid ""
"``P1`` matches ``<subject>[0]`` (note that this match can also bind names)"
msgstr ""
"``P1`` corresponde a ``<subject>[0]`` (observe que esta correspondência "
"também pode vincular nomes)"

#: ../../reference/compound_stmts.rst:1029
msgid ""
"``P2`` matches ``<subject>[1]`` (note that this match can also bind names)"
msgstr ""
"``P2`` corresponde a ``<subject>[1]`` (observe que esta correspondência "
"também pode vincular nomes)"

#: ../../reference/compound_stmts.rst:1030
msgid "... and so on for the corresponding pattern/element."
msgstr "... e assim por diante para o padrão/elemento correspondente."

#: ../../reference/compound_stmts.rst:1035
msgid "Mapping Patterns"
msgstr "Padrões de mapeamento"

#: ../../reference/compound_stmts.rst:1037
msgid ""
"A mapping pattern contains one or more key-value patterns.  The syntax is "
"similar to the construction of a dictionary. Syntax:"
msgstr ""
"Um padrão de mapeamento contém um ou mais padrões de chave-valor. A sintaxe "
"é similar à construção de um dicionário. Sintaxe:"

#: ../../reference/compound_stmts.rst:1048
msgid ""
"At most one double star pattern may be in a mapping pattern.  The double "
"star pattern must be the last subpattern in the mapping pattern."
msgstr ""
"No máximo um padrão de estrela dupla pode estar em um padrão de mapeamento. "
"O padrão de estrela dupla deve ser o último subpadrão no padrão de "
"mapeamento."

#: ../../reference/compound_stmts.rst:1051
msgid ""
"Duplicate keys in mapping patterns are disallowed. Duplicate literal keys "
"will raise a :exc:`SyntaxError`. Two keys that otherwise have the same value "
"will raise a :exc:`ValueError` at runtime."
msgstr ""
"Chaves duplicadas em padrões de mapeamento não são permitidas. Chaves "
"literais duplicadas levantarão um :exc:`SyntaxError`. Duas chaves que de "
"outra forma têm o mesmo valor levantarão :exc:`ValueError` em tempo de "
"execução."

#: ../../reference/compound_stmts.rst:1055
msgid ""
"The following is the logical flow for matching a mapping pattern against a "
"subject value:"
msgstr ""
"A seguir está o fluxo lógico para comparar um padrão de mapeamento com um "
"valor de assunto:"

#: ../../reference/compound_stmts.rst:1058
msgid "If the subject value is not a mapping [#]_,the mapping pattern fails."
msgstr ""
"Se o valor do assunto não for um mapeamento [#]_, o padrão de mapeamento "
"falhará."

#: ../../reference/compound_stmts.rst:1060
msgid ""
"If every key given in the mapping pattern is present in the subject mapping, "
"and the pattern for each key matches the corresponding item of the subject "
"mapping, the mapping pattern succeeds."
msgstr ""
"Se cada chave fornecida no padrão de mapeamento estiver presente no "
"mapeamento de assunto, e o padrão para cada chave corresponder ao item "
"correspondente do mapeamento de assunto, o padrão de mapeamento será bem-"
"sucedido."

#: ../../reference/compound_stmts.rst:1064
msgid ""
"If duplicate keys are detected in the mapping pattern, the pattern is "
"considered invalid. A :exc:`SyntaxError` is raised for duplicate literal "
"values; or a :exc:`ValueError` for named keys of the same value."
msgstr ""
"Se chaves duplicadas forem detectadas no padrão de mapeamento, o padrão será "
"considerado inválido. Uma exceção :exc:`SyntaxError` é levantada para "
"valores literais duplicados; ou :exc:`ValueError` para chaves nomeadas do "
"mesmo valor."

#: ../../reference/compound_stmts.rst:1068
msgid ""
"Key-value pairs are matched using the two-argument form of the mapping "
"subject's ``get()`` method.  Matched key-value pairs must already be present "
"in the mapping, and not created on-the-fly via :meth:`~object.__missing__` "
"or :meth:`~object.__getitem__`."
msgstr ""

#: ../../reference/compound_stmts.rst:1073
msgid ""
"In simple terms ``{KEY1: P1, KEY2: P2, ... }`` matches only if all the "
"following happens:"
msgstr ""
"Em termos simples, ``{KEY1: P1, KEY2: P2, ... }`` corresponde somente se "
"tudo o seguinte acontecer:"

#: ../../reference/compound_stmts.rst:1076
msgid "check ``<subject>`` is a mapping"
msgstr "verifica se ``<assunto>`` é um mapeamento"

#: ../../reference/compound_stmts.rst:1077
msgid "``KEY1 in <subject>``"
msgstr "``KEY1 in <assunto>``"

#: ../../reference/compound_stmts.rst:1078
msgid "``P1`` matches ``<subject>[KEY1]``"
msgstr "``P1`` corresponde a ``<assunto>[KEY1]``"

#: ../../reference/compound_stmts.rst:1079
msgid "... and so on for the corresponding KEY/pattern pair."
msgstr "... e assim por diante para o par KEY/elemento correspondente."

#: ../../reference/compound_stmts.rst:1085
msgid "Class Patterns"
msgstr "Padrões de classe"

#: ../../reference/compound_stmts.rst:1087
msgid ""
"A class pattern represents a class and its positional and keyword arguments "
"(if any).  Syntax:"
msgstr ""
"Um padrão de classe representa uma classe e seus argumentos nomeados e "
"posicionais (se houver). Sintaxe:"

#: ../../reference/compound_stmts.rst:1098
msgid "The same keyword should not be repeated in class patterns."
msgstr "O mesmo argumento nomeado não deve ser repetido em padrões de classe."

#: ../../reference/compound_stmts.rst:1100
msgid ""
"The following is the logical flow for matching a class pattern against a "
"subject value:"
msgstr ""
"A seguir está o fluxo lógico para corresponder a um padrão de classe com um "
"valor de assunto:"

#: ../../reference/compound_stmts.rst:1103
msgid ""
"If ``name_or_attr`` is not an instance of the builtin :class:`type` , raise :"
"exc:`TypeError`."
msgstr ""
"Se ``name_or_attr`` não for uma instância do tipo embutido :class:`type` , "
"levanta :exc:`TypeError`."

#: ../../reference/compound_stmts.rst:1106
msgid ""
"If the subject value is not an instance of ``name_or_attr`` (tested via :"
"func:`isinstance`), the class pattern fails."
msgstr ""
"Se o valor do assunto não for uma instância de ``name_or_attr`` (testado "
"via :func:`isinstance`), o padrão de classe falhará."

#: ../../reference/compound_stmts.rst:1109
msgid ""
"If no pattern arguments are present, the pattern succeeds.  Otherwise, the "
"subsequent steps depend on whether keyword or positional argument patterns "
"are present."
msgstr ""
"Se nenhum argumento de padrão estiver presente, o padrão é bem-sucedido. "
"Caso contrário, as etapas subsequentes dependem se os padrões de argumento "
"posicional ou nomeado estão presentes."

#: ../../reference/compound_stmts.rst:1113
msgid ""
"For a number of built-in types (specified below), a single positional "
"subpattern is accepted which will match the entire subject; for these types "
"keyword patterns also work as for other types."
msgstr ""
"Para vários tipos embutidos (especificados abaixo), um único subpadrão "
"posicional é aceito, o qual corresponderá a todo o assunto; para esses "
"tipos, os padrões de argumentos nomeados também funcionam como para outros "
"tipos."

#: ../../reference/compound_stmts.rst:1117
msgid ""
"If only keyword patterns are present, they are processed as follows, one by "
"one:"
msgstr ""
"Se apenas padrões de argumentos nomeados estiverem presentes, eles serão "
"processados da seguinte forma, um por um:"

#: ../../reference/compound_stmts.rst:1120
msgid "I. The keyword is looked up as an attribute on the subject."
msgstr "I. A palavra-chave é procurada como um atributo no assunto."

#: ../../reference/compound_stmts.rst:1122
msgid ""
"If this raises an exception other than :exc:`AttributeError`, the exception "
"bubbles up."
msgstr ""
"Se isso levantar uma exceção diferente de :exc:`AttributeError`, a exceção "
"será exibida."

#: ../../reference/compound_stmts.rst:1125
msgid "If this raises :exc:`AttributeError`, the class pattern has failed."
msgstr "Se isso levantar :exc:`AttributeError`, o padrão de classe falhou."

#: ../../reference/compound_stmts.rst:1127
msgid ""
"Else, the subpattern associated with the keyword pattern is matched against "
"the subject's attribute value.  If this fails, the class pattern fails; if "
"this succeeds, the match proceeds to the next keyword."
msgstr ""
"Caso contrário, o subpadrão associado ao padrão de argumento nomeado é "
"correspondido ao valor de atributo do sujeito. Se isso falhar, o padrão de "
"classe falha; se isso for bem-sucedido, a correspondência prossegue para o "
"próximo argumento nomeado."

#: ../../reference/compound_stmts.rst:1132
msgid "II. If all keyword patterns succeed, the class pattern succeeds."
msgstr ""
"II. Se todos os padrões de argumento nomeado forem bem-sucedidos, o padrão "
"de classe será bem-sucedido."

#: ../../reference/compound_stmts.rst:1134
msgid ""
"If any positional patterns are present, they are converted to keyword "
"patterns using the :data:`~object.__match_args__` attribute on the class "
"``name_or_attr`` before matching:"
msgstr ""
"Se houver algum padrão posicional presente, ele será convertido em padrões "
"de argumento nomeado usando o atributo :data:`~object.__match_args__` na "
"classe ``name_or_attr`` antes da correspondência:"

#: ../../reference/compound_stmts.rst:1138
msgid ""
"I. The equivalent of ``getattr(cls, \"__match_args__\", ())`` is called."
msgstr ""
"I. O equivalente de ``getattr(cls, \"__match_args__\", ())`` é chamado."

#: ../../reference/compound_stmts.rst:1140
msgid "If this raises an exception, the exception bubbles up."
msgstr "Se isso levantar uma exceção, a exceção surgirá."

#: ../../reference/compound_stmts.rst:1142
msgid ""
"If the returned value is not a tuple, the conversion fails and :exc:"
"`TypeError` is raised."
msgstr ""
"Se o valor retornado não for uma tupla, a conversão falhará e :exc:"
"`TypeError` será levantada."

#: ../../reference/compound_stmts.rst:1145
msgid ""
"If there are more positional patterns than ``len(cls.__match_args__)``, :exc:"
"`TypeError` is raised."
msgstr ""
"Se houver mais padrões posicionais do que ``len(cls.__match_args__)``, :exc:"
"`TypeError` será levantada."

#: ../../reference/compound_stmts.rst:1148
msgid ""
"Otherwise, positional pattern ``i`` is converted to a keyword pattern using "
"``__match_args__[i]`` as the keyword.  ``__match_args__[i]`` must be a "
"string; if not :exc:`TypeError` is raised."
msgstr ""
"Caso contrário, o padrão posicional ``i`` é convertido em um padrão de "
"argumento nomeado usando ``__match_args__[i]`` como argumento nomeado. "
"``__match_args__[i]`` deve ser uma string; caso contrário, :exc:`TypeError` "
"é levantada."

#: ../../reference/compound_stmts.rst:1152
msgid "If there are duplicate keywords, :exc:`TypeError` is raised."
msgstr ""
"Se houver argumentos nomeados duplicados, :exc:`TypeError` será levantada."

#: ../../reference/compound_stmts.rst:1154
msgid ":ref:`class-pattern-matching`"
msgstr ":ref:`class-pattern-matching`"

#: ../../reference/compound_stmts.rst:1156
msgid ""
"II. Once all positional patterns have been converted to keyword patterns,"
msgstr ""
"II. Uma vez que todos os padrões posicionais foram convertidos em padrões de "
"argumentos nomeados,"

#: ../../reference/compound_stmts.rst:1157
msgid "the match proceeds as if there were only keyword patterns."
msgstr ""
"a partida prossegue como se houvesse apenas padrões de argumentos nomeados."

#: ../../reference/compound_stmts.rst:1159
msgid ""
"For the following built-in types the handling of positional subpatterns is "
"different:"
msgstr ""
"Para os seguintes tipos embutidos, o tratamento de subpadrões posicionais é "
"diferente:"

#: ../../reference/compound_stmts.rst:1162
msgid ":class:`bool`"
msgstr ":class:`bool`"

#: ../../reference/compound_stmts.rst:1163
msgid ":class:`bytearray`"
msgstr ":class:`bytearray`"

#: ../../reference/compound_stmts.rst:1164
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../reference/compound_stmts.rst:1165
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: ../../reference/compound_stmts.rst:1166
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../reference/compound_stmts.rst:1167
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: ../../reference/compound_stmts.rst:1168
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../reference/compound_stmts.rst:1169
#: ../../reference/compound_stmts.rst:1927
msgid ":class:`list`"
msgstr ":class:`list`"

#: ../../reference/compound_stmts.rst:1170
msgid ":class:`set`"
msgstr ":class:`set`"

#: ../../reference/compound_stmts.rst:1171
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../reference/compound_stmts.rst:1172
#: ../../reference/compound_stmts.rst:1930
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: ../../reference/compound_stmts.rst:1174
msgid ""
"These classes accept a single positional argument, and the pattern there is "
"matched against the whole object rather than an attribute. For example "
"``int(0|1)`` matches the value ``0``, but not the value ``0.0``."
msgstr ""
"Essas classes aceitam um único argumento posicional, e o padrão ali é "
"correspondido ao objeto inteiro em vez de um atributo. Por exemplo, ``int(0|"
"1)`` corresponde ao valor ``0``, mas não ao valor ``0.0``."

#: ../../reference/compound_stmts.rst:1178
msgid ""
"In simple terms ``CLS(P1, attr=P2)`` matches only if the following happens:"
msgstr ""
"Em termos simples, ``CLS(P1, attr=P2)`` corresponde somente se o seguinte "
"acontecer:"

#: ../../reference/compound_stmts.rst:1180
msgid "``isinstance(<subject>, CLS)``"
msgstr "``isinstance(<assunto>, CLS)``"

#: ../../reference/compound_stmts.rst:1181
msgid "convert ``P1`` to a keyword pattern using ``CLS.__match_args__``"
msgstr ""
"converte ``P1`` em um padrão de argumento nomeado usando ``CLS."
"__match_args__``"

#: ../../reference/compound_stmts.rst:1182
msgid "For each keyword argument ``attr=P2``:"
msgstr "Para cada argumento de palavra-chave ``attr=P2``:"

#: ../../reference/compound_stmts.rst:1184
msgid "``hasattr(<subject>, \"attr\")``"
msgstr "``hasattr(<assunto>, \"attr\")``"

#: ../../reference/compound_stmts.rst:1185
msgid "``P2`` matches ``<subject>.attr``"
msgstr "``P2`` corresponde a ``<assunto>.attr``"

#: ../../reference/compound_stmts.rst:1187
msgid "... and so on for the corresponding keyword argument/pattern pair."
msgstr ""
"... e assim por diante para o par argumento nomeado/elemento correspondente."

#: ../../reference/compound_stmts.rst:1202
msgid "Function definitions"
msgstr "Definições de função"

#: ../../reference/compound_stmts.rst:1217
msgid ""
"A function definition defines a user-defined function object (see section :"
"ref:`types`):"
msgstr ""
"Uma definição de função define um objeto de função definido pelo usuário "
"(veja a seção :ref:`types`):"

#: ../../reference/compound_stmts.rst:1239
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper "
"around the executable code for the function).  This function object contains "
"a reference to the current global namespace as the global namespace to be "
"used when the function is called."
msgstr ""
"Uma definição de função é uma instrução executável. Sua execução vincula o "
"nome da função no espaço de nomes local atual a um objeto função (um "
"invólucro em torno do código executável para a função). Este objeto função "
"contém uma referência ao espaço de nomes global atual como o espaço de nomes "
"global a ser usado quando a função é chamada."

#: ../../reference/compound_stmts.rst:1245
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr ""
"A definição da função não executa o corpo da função; ela é executada somente "
"quando a função é chamada. [#]_"

#: ../../reference/compound_stmts.rst:1251
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""
"Uma definição de função pode ser encapsulada por uma ou mais expressões :"
"term:`decoradoras <decorador>`. Expressões decoradoras são avaliadas quando "
"a função é definida, no escopo que contém a definição da função. O resultado "
"deve ser um chamável, que é invocado com o objeto de função como o único "
"argumento. O valor retornado é vinculado ao nome da função em vez do objeto "
"de função. Vários decoradores são aplicados de forma aninhada. Por exemplo, "
"o código a seguir ::"

#: ../../reference/compound_stmts.rst:1258
msgid ""
"@f1(arg)\n"
"@f2\n"
"def func(): pass"
msgstr ""
"@f1(arg)\n"
"@f2\n"
"def func(): pass"

#: ../../reference/compound_stmts.rst:1262
#: ../../reference/compound_stmts.rst:1451
msgid "is roughly equivalent to ::"
msgstr "é aproximadamente equivalente a ::"

#: ../../reference/compound_stmts.rst:1264
msgid ""
"def func(): pass\n"
"func = f1(arg)(f2(func))"
msgstr ""
"def func(): pass\n"
"func = f1(arg)(f2(func))"

#: ../../reference/compound_stmts.rst:1267
msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr ""
"exceto que a função original não está temporariamente vinculada ao nome "
"``func``."

#: ../../reference/compound_stmts.rst:1269
msgid ""
"Functions may be decorated with any valid :token:`~python-grammar:"
"assignment_expression`. Previously, the grammar was much more restrictive; "
"see :pep:`614` for details."
msgstr ""
"Funções podem ser decoradas com qualquer :token:`~python-grammar:"
"assignment_expression` válida. Anteriormente, a gramática era muito mais "
"restritiva; veja :pep:`614` para detalhes."

#: ../../reference/compound_stmts.rst:1274
msgid ""
"A list of :ref:`type parameters <type-params>` may be given in square "
"brackets between the function's name and the opening parenthesis for its "
"parameter list. This indicates to static type checkers that the function is "
"generic. At runtime, the type parameters can be retrieved from the "
"function's :attr:`~function.__type_params__` attribute. See :ref:`generic-"
"functions` for more."
msgstr ""
"Uma lista de :ref:`parâmetros de tipo <type-params>` pode ser dada entre "
"colchetes entre o nome da função e o parêntese de abertura para sua lista de "
"parâmetros. Isso indica aos verificadores de tipo estático que a função é "
"genérica. Em tempo de execução, os parâmetros de tipo podem ser recuperados "
"do atributo :attr:`~function.__type_params__` da função. Veja :ref:`generic-"
"functions` para mais."

#: ../../reference/compound_stmts.rst:1281
#: ../../reference/compound_stmts.rst:1470
msgid "Type parameter lists are new in Python 3.12."
msgstr "Listas de parâmetros de tipo são novas no Python 3.12."

#: ../../reference/compound_stmts.rst:1289
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter values."
"\"  For a parameter with a default value, the corresponding :term:`argument` "
"may be omitted from a call, in which case the parameter's default value is "
"substituted.  If a parameter has a default value, all following parameters "
"up until the \"``*``\" must also have a default value --- this is a "
"syntactic restriction that is not expressed by the grammar."
msgstr ""
"Quando um ou mais :term:`parâmetros <parameter>` têm a forma *parameter* "
"``=`` *expression*, diz-se que a função tem \"valores de parâmetro padrão\". "
"Para um parâmetro com um valor padrão, o :term:`argumento` correspondente "
"pode ser omitido de uma chamada, em cujo caso o valor padrão do parâmetro é "
"substituído. Se um parâmetro tiver um valor padrão, todos os parâmetros "
"seguintes até \"``*``\" também devem ter um valor padrão --- esta é uma "
"restrição sintática que não é expressa pela gramática."

#: ../../reference/compound_stmts.rst:1297
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter value is a mutable object, such as a "
"list or a dictionary: if the function modifies the object (e.g. by appending "
"an item to a list), the default parameter value is in effect modified.  This "
"is generally not what was intended.  A way around this is to use ``None`` as "
"the default, and explicitly test for it in the body of the function, e.g.::"
msgstr ""
"**Os valores de parâmetro padrão são avaliados da esquerda para a direita "
"quando a definição da função é executada.** Isso significa que a expressão é "
"avaliada uma vez, quando a função é definida, e que o mesmo valor \"pré-"
"calculado\" é usado para cada chamada. Isso é especialmente importante para "
"entender quando um valor de parâmetro padrão é um objeto mutável, como uma "
"lista ou um dicionário: se a função modifica o objeto (por exemplo, anexando "
"um item a uma lista), o valor de parâmetro padrão é efetivamente modificado. "
"Isso geralmente não é o que se pretendia. Uma maneira de contornar isso é "
"usar ``None`` como o padrão e testá-lo explicitamente no corpo da função, "
"por exemplo::"

#: ../../reference/compound_stmts.rst:1307
msgid ""
"def whats_on_the_telly(penguin=None):\n"
"    if penguin is None:\n"
"        penguin = []\n"
"    penguin.append(\"property of the zoo\")\n"
"    return penguin"
msgstr ""
"def whats_on_the_telly(penguin=None):\n"
"    if penguin is None:\n"
"        penguin = []\n"
"    penguin.append(\"property of the zoo\")\n"
"    return penguin"

#: ../../reference/compound_stmts.rst:1318
msgid ""
"Function call semantics are described in more detail in section :ref:"
"`calls`. A function call always assigns values to all parameters mentioned "
"in the parameter list, either from positional arguments, from keyword "
"arguments, or from default values.  If the form \"``*identifier``\" is "
"present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple. If the form \"``**identifier``\" "
"is present, it is initialized to a new ordered mapping receiving any excess "
"keyword arguments, defaulting to a new empty mapping of the same type.  "
"Parameters after \"``*``\" or \"``*identifier``\" are keyword-only "
"parameters and may only be passed by keyword arguments.  Parameters before "
"\"``/``\" are positional-only parameters and may only be passed by "
"positional arguments."
msgstr ""
"A semântica de chamada de função é descrita em mais detalhes na seção :ref:"
"`calls`. Uma chamada de função sempre atribui valores a todos os parâmetros "
"mencionados na lista de parâmetros, seja de argumentos posicionais, de "
"argumentos nomeados ou de valores padrão. Se o formato \"``*identifier``\" "
"estiver presente, ele será inicializado para uma tupla que recebe quaisquer "
"parâmetros posicionais excedentes, padronizando para a tupla vazia. Se o "
"formato \"``**identifier``\" estiver presente, ele será inicializado para um "
"novo mapeamento ordenado que recebe quaisquer argumentos nomeados "
"excedentes, padronizando para um novo mapeamento vazio do mesmo tipo. "
"Parâmetros após \"``*``\" ou \"``*identifier``\" são parâmetros somente-"
"nomeados e podem ser passados somente por argumentos nomeados. Parâmetros "
"antes de \"``/``\" são parâmetros somente-posicionais e podem ser passados "
"somente por argumentos posicionais."

#: ../../reference/compound_stmts.rst:1330
msgid ""
"The ``/`` function parameter syntax may be used to indicate positional-only "
"parameters. See :pep:`570` for details."
msgstr ""
"A sintaxe do parâmetro de função ``/`` pode ser usada para indicar "
"parâmetros somente-posicionais. Veja a :pep:`570` para detalhes."

#: ../../reference/compound_stmts.rst:1339
msgid ""
"Parameters may have an :term:`annotation <function annotation>` of the form "
"\"``: expression``\" following the parameter name.  Any parameter may have "
"an annotation, even those of the form ``*identifier`` or ``**identifier``. "
"(As a special case, parameters of the form ``*identifier`` may have an "
"annotation \"``: *expression``\".) Functions may have \"return\" annotation "
"of the form \"``-> expression``\" after the parameter list.  These "
"annotations can be any valid Python expression.  The presence of annotations "
"does not change the semantics of a function. See :ref:`annotations` for more "
"information on annotations."
msgstr ""
"Os parâmetros podem ter uma :term:`anotação <function annotation>` do "
"formato \"``: expressão``\" após o nome do parâmetro. Qualquer parâmetro "
"pode ter uma anotação, mesmo aqueles do formato ``*identificador`` ou "
"``**identificador``. (Como um caso especial, parâmetros do formato "
"``*identificador`` podem ter uma anotação \"``: *expressão``\".) As funções "
"podem ter uma anotação \"return\" do formato \"``-> expressão``\" após a "
"lista de parâmetros. Essas anotações podem ser qualquer expressão Python "
"válida. A presença de anotações não altera a semântica de uma função. Veja :"
"ref:`annotations` para mais informações sobre anotações."

#: ../../reference/compound_stmts.rst:1347
msgid ""
"Parameters of the form \"``*identifier``\" may have an annotation \"``: "
"*expression``\". See :pep:`646`."
msgstr ""
"Parâmetros do formato \"``*identificador``\" podem ter uma anotação \"``: "
"*expressão``\". Veja :pep:`646`."

#: ../../reference/compound_stmts.rst:1353
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The \":"
"keyword:`!def`\" form is actually more powerful since it allows the "
"execution of multiple statements and annotations."
msgstr ""
"Também é possível criar funções anônimas (funções não vinculadas a um nome), "
"para uso imediato em expressões. Isso usa expressões lambda, descritas na "
"seção :ref:`lambda`. Observe que a expressão lambda é meramente uma "
"abreviação para uma definição de função simplificada; uma função definida em "
"uma instrução \":keyword:`def`\" pode ser passada adiante ou atribuída a "
"outro nome, assim como uma função definida por uma expressão lambda. O "
"formato \":keyword:`!def`\" é, na verdade, mais poderoso, pois permite a "
"execução de várias instruções e anotações."

#: ../../reference/compound_stmts.rst:1361
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested "
"function can access the local variables of the function containing the def.  "
"See section :ref:`naming` for details."
msgstr ""
"**Nota do programador:** Funções são objetos de primeira classe. Uma "
"instrução \"``def``\" executada dentro de uma definição de função define uma "
"função local que pode ser retornada ou passada adiante. Variáveis livres "
"usadas na função aninhada podem acessar as variáveis locais da função que "
"contém o \"def\". Veja a seção :ref:`naming` para detalhes."

#: ../../reference/compound_stmts.rst:1369
msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` - Anotações de função"

#: ../../reference/compound_stmts.rst:1370
msgid "The original specification for function annotations."
msgstr "A especificação original para anotações de funções."

#: ../../reference/compound_stmts.rst:1372
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - Dicas de tipo"

#: ../../reference/compound_stmts.rst:1373
msgid "Definition of a standard meaning for annotations: type hints."
msgstr "Definição de um significado padrão para anotações: dicas de tipo."

#: ../../reference/compound_stmts.rst:1375
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - Sintaxe para anotações de variáveis"

#: ../../reference/compound_stmts.rst:1376
msgid ""
"Ability to type hint variable declarations, including class variables and "
"instance variables."
msgstr ""
"Capacidade de fornecer dica de tipo para declarações de variáveis, incluindo "
"variáveis de classe e variáveis de instância."

#: ../../reference/compound_stmts.rst:1379
msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ":pep:`563` - Avaliação postergada de anotações"

#: ../../reference/compound_stmts.rst:1380
msgid ""
"Support for forward references within annotations by preserving annotations "
"in a string form at runtime instead of eager evaluation."
msgstr ""
"Suporte para referências futuras dentro de anotações, preservando anotações "
"em um formato de string em tempo de execução em vez de avaliação antecipada."

#: ../../reference/compound_stmts.rst:1383
msgid ":pep:`318` - Decorators for Functions and Methods"
msgstr ":pep:`318` - Decoradores para funções e métodos"

#: ../../reference/compound_stmts.rst:1384
msgid ""
"Function and method decorators were introduced. Class decorators were "
"introduced in :pep:`3129`."
msgstr ""
"Decoradores de função e método foram introduzidos. Decoradores de classe "
"foram introduzidos na :pep:`3129`."

#: ../../reference/compound_stmts.rst:1390
msgid "Class definitions"
msgstr "Definições de classe"

#: ../../reference/compound_stmts.rst:1405
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr ""
"Uma definição de classe define um objeto classe (veja a seção :ref:`types`):"

#: ../../reference/compound_stmts.rst:1412
msgid ""
"A class definition is an executable statement.  The inheritance list usually "
"gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""
"Uma definição de classe é uma instrução executável. A lista de herança "
"geralmente fornece uma lista de classes base (veja :ref:`metaclasses` para "
"usos mais avançados), então cada item na lista deve ser executada como um "
"objeto classe que permite extensão via subclasse. Classes sem uma lista de "
"herança herdam, por padrão, da classe base :class:`object`; portanto, ::"

#: ../../reference/compound_stmts.rst:1418
msgid ""
"class Foo:\n"
"    pass"
msgstr ""
"class Foo:\n"
"    pass"

#: ../../reference/compound_stmts.rst:1421
msgid "is equivalent to ::"
msgstr "equivale a ::"

#: ../../reference/compound_stmts.rst:1423
msgid ""
"class Foo(object):\n"
"    pass"
msgstr ""
"class Foo(object):\n"
"    pass"

#: ../../reference/compound_stmts.rst:1426
msgid ""
"The class's suite is then executed in a new execution frame (see :ref:"
"`naming`), using a newly created local namespace and the original global "
"namespace. (Usually, the suite contains mostly function definitions.)  When "
"the class's suite finishes execution, its execution frame is discarded but "
"its local namespace is saved. [#]_ A class object is then created using the "
"inheritance list for the base classes and the saved local namespace for the "
"attribute dictionary.  The class name is bound to this class object in the "
"original local namespace."
msgstr ""
"O conjunto da classe é então executado em um novo quadro de execução (veja :"
"ref:`naming`), usando um espaço de nomes local recém-criado e o espaço de "
"nomes global original. (Normalmente, o conjunto contém principalmente "
"definições de função.) Quando o conjunto da classe termina a execução, seu "
"quadro de execução é descartado, mas seu espaço de nomes local é salvo. [#]_ "
"Um objeto classe é então criado usando a lista de herança para as classes "
"base e o espaço de nomes local salvo para o dicionário de atributos. O nome "
"da classe é vinculado a este objeto classe no espaço de nomes local original."

#: ../../reference/compound_stmts.rst:1435
msgid ""
"The order in which attributes are defined in the class body is preserved in "
"the new class's :attr:`~type.__dict__`.  Note that this is reliable only "
"right after the class is created and only for classes that were defined "
"using the definition syntax."
msgstr ""
"A ordem em que os atributos são definidos no corpo da classe é preservada "
"no :attr:`~type.__dict__` da nova classe. Observe que isso é confiável "
"somente logo após a classe ser criada e somente para classes que foram "
"definidas usando a sintaxe de definição."

#: ../../reference/compound_stmts.rst:1440
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr ""
"A criação de classes pode ser bastante personalizada usando :ref:"
"`metaclasses <metaclasses>`."

#: ../../reference/compound_stmts.rst:1445
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr ""
"As classes também podem ser decoradas: assim como na decoração de funções, ::"

#: ../../reference/compound_stmts.rst:1447
msgid ""
"@f1(arg)\n"
"@f2\n"
"class Foo: pass"
msgstr ""
"@f1(arg)\n"
"@f2\n"
"class Foo: pass"

#: ../../reference/compound_stmts.rst:1453
msgid ""
"class Foo: pass\n"
"Foo = f1(arg)(f2(Foo))"
msgstr ""
"class Foo: pass\n"
"Foo = f1(arg)(f2(Foo))"

#: ../../reference/compound_stmts.rst:1456
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr ""
"As regras de execução para as expressões de decorador são as mesmas que para "
"decoradores de função. O resultado é então vinculado ao nome da classe."

#: ../../reference/compound_stmts.rst:1459
msgid ""
"Classes may be decorated with any valid :token:`~python-grammar:"
"assignment_expression`. Previously, the grammar was much more restrictive; "
"see :pep:`614` for details."
msgstr ""
"Classes podem ser decoradas com qualquer :token:`~python-grammar:"
"assignment_expression` válida. Anteriormente, a gramática era muito mais "
"restritiva; veja :pep:`614` para detalhes."

#: ../../reference/compound_stmts.rst:1464
msgid ""
"A list of :ref:`type parameters <type-params>` may be given in square "
"brackets immediately after the class's name. This indicates to static type "
"checkers that the class is generic. At runtime, the type parameters can be "
"retrieved from the class's :attr:`~type.__type_params__` attribute. See :ref:"
"`generic-classes` for more."
msgstr ""
"Uma lista de :ref:`parâmetros de tipo <type-params>` pode ser dada entre "
"colchetes imediatamente após o nome da classe. Isso indica aos verificadores "
"de tipo estático que a classe é genérica. Em tempo de execução, os "
"parâmetros de tipo podem ser recuperados do atributo :attr:`~type."
"__type_params__` da classe. Veja :ref:`generic-classes` para mais."

#: ../../reference/compound_stmts.rst:1473
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in "
"a method with ``self.name = value``.  Both class and instance attributes are "
"accessible through the notation \"``self.name``\", and an instance attribute "
"hides a class attribute with the same name when accessed in this way.  Class "
"attributes can be used as defaults for instance attributes, but using "
"mutable values there can lead to unexpected results.  :ref:`Descriptors "
"<descriptors>` can be used to create instance variables with different "
"implementation details."
msgstr ""
"**Nota do programador:** Variáveis definidas na definição de classe são "
"atributos de classe; elas são compartilhadas por instâncias. Atributos de "
"instância podem ser definidos em um método com ``self.nome = valor``. "
"Atributos de classe e instância são acessíveis por meio da notação \"``self."
"nome``\", e um atributo de instância oculta um atributo de classe com o "
"mesmo nome quando acessado dessa forma. Atributos de classe podem ser usados "
"como padrões para atributos de instância, mas usar valores mutáveis pode "
"levar a resultados inesperados. :ref:`Descritores <descriptors>` podem ser "
"usados para criar variáveis de instância com diferentes detalhes de "
"implementação."

#: ../../reference/compound_stmts.rst:1485
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Metaclasses no Python 3000"

#: ../../reference/compound_stmts.rst:1486
msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are constructed."
msgstr ""
"A proposta que alterou a declaração de metaclasses para a sintaxe atual e a "
"semântica de como as classes com metaclasses são construídas."

#: ../../reference/compound_stmts.rst:1490
msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - Decoradores de classe"

#: ../../reference/compound_stmts.rst:1491
msgid ""
"The proposal that added class decorators.  Function and method decorators "
"were introduced in :pep:`318`."
msgstr ""
"A proposta que adicionou decoradores de classe. Decoradores de função e "
"método foram introduzidos na :pep:`318`."

#: ../../reference/compound_stmts.rst:1498
msgid "Coroutines"
msgstr "Corrotinas"

#: ../../reference/compound_stmts.rst:1506
msgid "Coroutine function definition"
msgstr "Definição de função de corrotina"

#: ../../reference/compound_stmts.rst:1516
msgid ""
"Execution of Python coroutines can be suspended and resumed at many points "
"(see :term:`coroutine`). :keyword:`await` expressions, :keyword:`async for` "
"and :keyword:`async with` can only be used in the body of a coroutine "
"function."
msgstr ""
"A execução de corrotinas do Python pode ser suspensa e retomada em muitos "
"pontos (consulte :term:`coroutine`). As expressões :keyword:`await`, :"
"keyword:`async for` e :keyword:`async with` só podem ser usadas no corpo de "
"uma função de corrotina."

#: ../../reference/compound_stmts.rst:1520
msgid ""
"Functions defined with ``async def`` syntax are always coroutine functions, "
"even if they do not contain ``await`` or ``async`` keywords."
msgstr ""
"Funções definidas com a sintaxe ``async def`` são sempre funções de "
"corrotina, mesmo que não contenham palavras reservadas ``await`` ou "
"``async``."

#: ../../reference/compound_stmts.rst:1523
msgid ""
"It is a :exc:`SyntaxError` to use a ``yield from`` expression inside the "
"body of a coroutine function."
msgstr ""
"Ocorre uma :exc:`SyntaxError` se usada uma expressão ``yield from`` dentro "
"do corpo de uma função de corrotina."

#: ../../reference/compound_stmts.rst:1526
msgid "An example of a coroutine function::"
msgstr "Um exemplo de uma função de corrotina::"

#: ../../reference/compound_stmts.rst:1528
msgid ""
"async def func(param1, param2):\n"
"    do_stuff()\n"
"    await some_coroutine()"
msgstr ""
"async def func(param1, param2):\n"
"    faz_algo()\n"
"    await alguma_corrotina()"

#: ../../reference/compound_stmts.rst:1532
msgid ""
"``await`` and ``async`` are now keywords; previously they were only treated "
"as such inside the body of a coroutine function."
msgstr ""
"``await`` e ``async`` agora são palavras reservadas; anteriormente, elas só "
"eram tratadas como tal dentro do corpo de uma função de corrotina."

#: ../../reference/compound_stmts.rst:1540
msgid "The :keyword:`!async for` statement"
msgstr "A instrução :keyword:`!async for`"

#: ../../reference/compound_stmts.rst:1545
msgid ""
"An :term:`asynchronous iterable` provides an ``__aiter__`` method that "
"directly returns an :term:`asynchronous iterator`, which can call "
"asynchronous code in its ``__anext__`` method."
msgstr ""
"Um :term:`iterável assíncrono` fornece um método ``__aiter__`` que retorna "
"diretamente um :term:`iterador assíncrono`, que pode chamar código "
"assíncrono em seu método ``__anext__``."

#: ../../reference/compound_stmts.rst:1549
msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous "
"iterables."
msgstr ""
"A instrução ``async for`` permite iteração conveniente sobre iteráveis "
"assíncronos."

#: ../../reference/compound_stmts.rst:1554
msgid ""
"async for TARGET in ITER:\n"
"    SUITE\n"
"else:\n"
"    SUITE2"
msgstr ""
"async for TARGET in ITER:\n"
"    SUITE\n"
"else:\n"
"    SUITE2"

#: ../../reference/compound_stmts.rst:1559
msgid "Is semantically equivalent to::"
msgstr "É semanticamente equivalente a::"

#: ../../reference/compound_stmts.rst:1561
msgid ""
"iter = (ITER)\n"
"iter = type(iter).__aiter__(iter)\n"
"running = True\n"
"\n"
"while running:\n"
"    try:\n"
"        TARGET = await type(iter).__anext__(iter)\n"
"    except StopAsyncIteration:\n"
"        running = False\n"
"    else:\n"
"        SUITE\n"
"else:\n"
"    SUITE2"
msgstr ""
"iter = (ITER)\n"
"iter = type(iter).__aiter__(iter)\n"
"running = True\n"
"\n"
"while running:\n"
"    try:\n"
"        TARGET = await type(iter).__anext__(iter)\n"
"    except StopAsyncIteration:\n"
"        running = False\n"
"    else:\n"
"        SUITE\n"
"else:\n"
"    SUITE2"

#: ../../reference/compound_stmts.rst:1575
msgid ""
"See also :meth:`~object.__aiter__` and :meth:`~object.__anext__` for details."
msgstr ""
"Veja também :meth:`~object.__aiter__` e :meth:`~object.__anext__` para "
"detalhes."

#: ../../reference/compound_stmts.rst:1577
msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside the "
"body of a coroutine function."
msgstr ""
"Ocorre uma :exc:`SyntaxError` se usada uma instrução ``async for`` fora do "
"corpo de uma função de corrotina."

#: ../../reference/compound_stmts.rst:1585
msgid "The :keyword:`!async with` statement"
msgstr "A instrução :keyword:`!async with`"

#: ../../reference/compound_stmts.rst:1590
msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that is "
"able to suspend execution in its *enter* and *exit* methods."
msgstr ""
"Um :term:`gerenciador de contexto assíncrono` é um :term:`gerenciador de "
"contexto` que é capaz de suspender a execução em seus métodos *enter* e "
"*exit*."

#: ../../reference/compound_stmts.rst:1595
msgid ""
"async with EXPRESSION as TARGET:\n"
"    SUITE"
msgstr ""
"async with EXPRESSÃO as ALVO:\n"
"    COMANDOS"

#: ../../reference/compound_stmts.rst:1600
msgid ""
"manager = (EXPRESSION)\n"
"aenter = type(manager).__aenter__\n"
"aexit = type(manager).__aexit__\n"
"value = await aenter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not await aexit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        await aexit(manager, None, None, None)"
msgstr ""
"manager = (EXPRESSÃO)\n"
"aenter = type(manager).__aenter__\n"
"aexit = type(manager).__aexit__\n"
"value = await aenter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    ALVO = value\n"
"    COMANDOS\n"
"except:\n"
"    hit_except = True\n"
"    if not await aexit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        await aexit(manager, None, None, None)"

#: ../../reference/compound_stmts.rst:1617
msgid ""
"See also :meth:`~object.__aenter__` and :meth:`~object.__aexit__` for "
"details."
msgstr ""
"Veja também  :meth:`~object.__aenter__` e :meth:`~object.__aexit__` para "
"detalhes."

#: ../../reference/compound_stmts.rst:1619
msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside the "
"body of a coroutine function."
msgstr ""
"Ocorre uma :exc:`SyntaxError` se usada uma instrução ``async with`` fora do "
"corpo de uma função de corrotina."

#: ../../reference/compound_stmts.rst:1624
msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` - Corrotina com sintaxe de async e wait"

#: ../../reference/compound_stmts.rst:1625
msgid ""
"The proposal that made coroutines a proper standalone concept in Python, and "
"added supporting syntax."
msgstr ""
"A proposta que tornou as corrotinas um conceito autônomo em Python e "
"adicionou sintaxe de suporte."

#: ../../reference/compound_stmts.rst:1631
msgid "Type parameter lists"
msgstr "Listas de parâmetros de tipo"

#: ../../reference/compound_stmts.rst:1635
msgid "Support for default values was added (see :pep:`696`)."
msgstr "Foi adicionado suporte para valores padrão (veja :pep:`696`)."

#: ../../reference/compound_stmts.rst:1648
msgid ""
":ref:`Functions <def>` (including :ref:`coroutines <async def>`), :ref:"
"`classes <class>` and :ref:`type aliases <type>` may contain a type "
"parameter list::"
msgstr ""
":ref:`Funções <def>` (incluindo :ref:`corrotinas <async def>`), :ref:"
"`classes <class>` e :ref:`apelidos de tipo <type>` podem conter uma lista de "
"parâmetros de tipo::"

#: ../../reference/compound_stmts.rst:1652
msgid ""
"def max[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"async def amax[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"class Bag[T]:\n"
"    def __iter__(self) -> Iterator[T]:\n"
"        ...\n"
"\n"
"    def add(self, arg: T) -> None:\n"
"        ...\n"
"\n"
"type ListOrSet[T] = list[T] | set[T]"
msgstr ""
"def max[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"async def amax[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"class Bag[T]:\n"
"    def __iter__(self) -> Iterator[T]:\n"
"        ...\n"
"\n"
"    def add(self, arg: T) -> None:\n"
"        ...\n"
"\n"
"type ListOrSet[T] = list[T] | set[T]"

#: ../../reference/compound_stmts.rst:1667
msgid ""
"Semantically, this indicates that the function, class, or type alias is "
"generic over a type variable. This information is primarily used by static "
"type checkers, and at runtime, generic objects behave much like their non-"
"generic counterparts."
msgstr ""
"Semanticamente, isso indica que a função, classe ou apelido de tipo é "
"genérico sobre uma variável de tipo. Essas informações são usadas "
"principalmente por verificadores de tipo estático e, em tempo de execução, "
"objetos genéricos se comportam muito como suas contrapartes não genéricas."

#: ../../reference/compound_stmts.rst:1672
msgid ""
"Type parameters are declared in square brackets (``[]``) immediately after "
"the name of the function, class, or type alias. The type parameters are "
"accessible within the scope of the generic object, but not elsewhere. Thus, "
"after a declaration ``def func[T](): pass``, the name ``T`` is not available "
"in the module scope. Below, the semantics of generic objects are described "
"with more precision. The scope of type parameters is modeled with a special "
"function (technically, an :ref:`annotation scope <annotation-scopes>`) that "
"wraps the creation of the generic object."
msgstr ""
"Parâmetros de tipo são declarados entre colchetes (``[]``) imediatamente "
"após o nome da função, classe ou apelido de tipo. Os parâmetros de tipo são "
"acessíveis dentro do escopo do objeto genérico, mas não em outro lugar. "
"Assim, após uma declaração ``def func[T](): pass``, o nome ``T`` não está "
"disponível no escopo do módulo. Abaixo, a semântica de objetos genéricos é "
"descrita com mais precisão. O escopo de parâmetros de tipo é modelado com "
"uma função especial (tecnicamente, um :ref:`escopo de anotação <annotation-"
"scopes>`) que encapsula a criação do objeto genérico."

#: ../../reference/compound_stmts.rst:1681
msgid ""
"Generic functions, classes, and type aliases have a :attr:`~definition."
"__type_params__` attribute listing their type parameters."
msgstr ""
"Funções genéricas, classes e apelidos de tipo têm um atributo :attr:"
"`~definition.__type_params__` listando seus parâmetros de tipo."

#: ../../reference/compound_stmts.rst:1684
msgid "Type parameters come in three kinds:"
msgstr "Existem três espécies de parâmetros de tipo:"

#: ../../reference/compound_stmts.rst:1686
msgid ""
":data:`typing.TypeVar`, introduced by a plain name (e.g., ``T``). "
"Semantically, this represents a single type to a type checker."
msgstr ""
":data:`typing.TypeVar`, introduzido por um nome simples (por exemplo, "
"``T``). Semanticamente, isso representa um único tipo para um verificador de "
"tipos."

#: ../../reference/compound_stmts.rst:1688
msgid ""
":data:`typing.TypeVarTuple`, introduced by a name prefixed with a single "
"asterisk (e.g., ``*Ts``). Semantically, this stands for a tuple of any "
"number of types."
msgstr ""
":data:`typing.TypeVarTuple`, introduzido por um nome prefixado com um único "
"asterisco (por exemplo, ``*Ts``). Semanticamente, isso representa uma tupla "
"de qualquer número de tipos."

#: ../../reference/compound_stmts.rst:1691
msgid ""
":data:`typing.ParamSpec`, introduced by a name prefixed with two asterisks "
"(e.g., ``**P``). Semantically, this stands for the parameters of a callable."
msgstr ""
":data:`typing.ParamSpec`, introduzido por um nome prefixado com dois "
"asteriscos (por exemplo, ``**P``). Semanticamente, isso representa os "
"parâmetros de um chamável."

#: ../../reference/compound_stmts.rst:1694
msgid ""
":data:`typing.TypeVar` declarations can define *bounds* and *constraints* "
"with a colon (``:``) followed by an expression. A single expression after "
"the colon indicates a bound (e.g. ``T: int``). Semantically, this means that "
"the :data:`!typing.TypeVar` can only represent types that are a subtype of "
"this bound. A parenthesized tuple of expressions after the colon indicates a "
"set of constraints (e.g. ``T: (str, bytes)``). Each member of the tuple "
"should be a type (again, this is not enforced at runtime). Constrained type "
"variables can only take on one of the types in the list of constraints."
msgstr ""
"As declarações de :data:`typing.TypeVar` podem definir delimitações "
"(*bounds*) e restrições (*constraints*) com dois pontos (``:``) seguidos por "
"uma expressão. Uma única expressão após os dois pontos indica uma "
"delimitação (por exemplo, ``T: int``). Semanticamente, isso significa que o :"
"data:`!typing.TypeVar` pode representar apenas tipos que são um subtipo "
"desse limite. Uma tupla de expressões entre parênteses após os dois pontos "
"indica um conjunto de restrições (por exemplo, ``T: (str, bytes)``). Cada "
"membro da tupla deve ser um tipo (novamente, isso não é imposto em tempo de "
"execução). Variáveis de tipo restrito podem assumir apenas um dos tipos na "
"lista de restrições."

#: ../../reference/compound_stmts.rst:1703
msgid ""
"For :data:`!typing.TypeVar`\\ s declared using the type parameter list "
"syntax, the bound and constraints are not evaluated when the generic object "
"is created, but only when the value is explicitly accessed through the "
"attributes ``__bound__`` and ``__constraints__``. To accomplish this, the "
"bounds or constraints are evaluated in a separate :ref:`annotation scope "
"<annotation-scopes>`."
msgstr ""
"Para :data:`!typing.TypeVar`\\ s declarados usando a sintaxe de lista de "
"parâmetros de tipo, a delimitação e as restrições não são avaliados quando o "
"objeto genérico é criado, mas somente quando o valor é acessado "
"explicitamente por meio dos atributos ``__bound__`` e ``__constraints__``. "
"Para fazer isso, as delimitações ou restrições são avaliados em um :ref:"
"`escopo de anotação <annotation-scopes>` separado."

#: ../../reference/compound_stmts.rst:1709
msgid ""
":data:`typing.TypeVarTuple`\\ s and :data:`typing.ParamSpec`\\ s cannot have "
"bounds or constraints."
msgstr ""
":data:`typing.TypeVarTuple`\\ s e :data:`typing.ParamSpec`\\ s não pode ter "
"delimitações e restrições."

#: ../../reference/compound_stmts.rst:1712
msgid ""
"All three flavors of type parameters can also have a *default value*, which "
"is used when the type parameter is not explicitly provided. This is added by "
"appending a single equals sign (``=``) followed by an expression. Like the "
"bounds and constraints of type variables, the default value is not evaluated "
"when the object is created, but only when the type parameter's "
"``__default__`` attribute is accessed. To this end, the default value is "
"evaluated in a separate :ref:`annotation scope <annotation-scopes>`. If no "
"default value is specified for a type parameter, the ``__default__`` "
"attribute is set to the special sentinel object :data:`typing.NoDefault`."
msgstr ""
"Todas as três espécies de parâmetros de tipo também podem ter um *valor "
"padrão*, que é usado quando o parâmetro de tipo não é fornecido "
"explicitamente. Isso é adicionado anexando um único sinal de igual (``=``) "
"seguido por uma expressão. Como os limites e restrições de tipos variáveis, "
"o valor padrão não é avaliado quando o objeto é criado, mas apenas quando o "
"atributo ``__default__`` do parâmetro de tipo é acessado. Para esse fim, o "
"valor padrão é avaliado em um :ref:`escopo de anotação <annotation-scopes>` "
"separado. Se nenhum valor padrão for especificado para um parâmetro de tipo, "
"o atributo ``__default__`` é definido como o objeto sinalizador especial :"
"data:`typing.NoDefault`."

#: ../../reference/compound_stmts.rst:1722
msgid ""
"The following example indicates the full set of allowed type parameter "
"declarations::"
msgstr ""
"O exemplo a seguir indica o conjunto completo de declarações de parâmetros "
"de tipo permitidas:"

#: ../../reference/compound_stmts.rst:1724
msgid ""
"def overly_generic[\n"
"   SimpleTypeVar,\n"
"   TypeVarWithDefault = int,\n"
"   TypeVarWithBound: int,\n"
"   TypeVarWithConstraints: (str, bytes),\n"
"   *SimpleTypeVarTuple = (int, float),\n"
"   **SimpleParamSpec = (str, bytearray),\n"
"](\n"
"   a: SimpleTypeVar,\n"
"   b: TypeVarWithDefault,\n"
"   c: TypeVarWithBound,\n"
"   d: Callable[SimpleParamSpec, TypeVarWithConstraints],\n"
"   *e: SimpleTypeVarTuple,\n"
"): ..."
msgstr ""
"def overly_generic[\n"
"   SimpleTypeVar,\n"
"   TypeVarWithDefault = int,\n"
"   TypeVarWithBound: int,\n"
"   TypeVarWithConstraints: (str, bytes),\n"
"   *SimpleTypeVarTuple = (int, float),\n"
"   **SimpleParamSpec = (str, bytearray),\n"
"](\n"
"   a: SimpleTypeVar,\n"
"   b: TypeVarWithDefault,\n"
"   c: TypeVarWithBound,\n"
"   d: Callable[SimpleParamSpec, TypeVarWithConstraints],\n"
"   *e: SimpleTypeVarTuple,\n"
"): ..."

#: ../../reference/compound_stmts.rst:1742
msgid "Generic functions"
msgstr "Funções genéricas"

#: ../../reference/compound_stmts.rst:1744
msgid "Generic functions are declared as follows::"
msgstr "Funções genéricas são declaradas assim:"

#: ../../reference/compound_stmts.rst:1746
msgid "def func[T](arg: T): ..."
msgstr "def func[T](arg: T): ..."

#: ../../reference/compound_stmts.rst:1748
#: ../../reference/compound_stmts.rst:1808
msgid "This syntax is equivalent to::"
msgstr "Essa sintaxe é equivalente a:"

#: ../../reference/compound_stmts.rst:1750
msgid ""
"annotation-def TYPE_PARAMS_OF_func():\n"
"    T = typing.TypeVar(\"T\")\n"
"    def func(arg: T): ...\n"
"    func.__type_params__ = (T,)\n"
"    return func\n"
"func = TYPE_PARAMS_OF_func()"
msgstr ""
"annotation-def TYPE_PARAMS_OF_func():\n"
"    T = typing.TypeVar(\"T\")\n"
"    def func(arg: T): ...\n"
"    func.__type_params__ = (T,)\n"
"    return func\n"
"func = TYPE_PARAMS_OF_func()"

#: ../../reference/compound_stmts.rst:1757
msgid ""
"Here ``annotation-def`` indicates an :ref:`annotation scope <annotation-"
"scopes>`, which is not actually bound to any name at runtime. (One other "
"liberty is taken in the translation: the syntax does not go through "
"attribute access on the :mod:`typing` module, but creates an instance of :"
"data:`typing.TypeVar` directly.)"
msgstr ""
"Aqui, ``annotation-def`` indica um :ref:`escopo de anotação <annotation-"
"scopes>`, que não é vinculado de verdade a nenhum nome em tempo de execução. "
"(Uma outra liberdade foi tomada na tradução: essa sintaxe não faz ocorrer um "
"acesso de atributo no módulo :mod:`typing`; ao invés disso é criada uma "
"instância de :data:`typing.TypeVar` diretamente.)"

#: ../../reference/compound_stmts.rst:1763
msgid ""
"The annotations of generic functions are evaluated within the annotation "
"scope used for declaring the type parameters, but the function's defaults "
"and decorators are not."
msgstr ""
"As anotações das funções genéricas são lidas dentro do escopo de anotação "
"usado para declarar os parâmetros de tipo, mas os valores padrão dos "
"argumentos e decoradores da função não são."

#: ../../reference/compound_stmts.rst:1767
msgid ""
"The following example illustrates the scoping rules for these cases, as well "
"as for additional flavors of type parameters::"
msgstr ""
"Este exemplo ilustra as regras de escopo para estes casos, bem como para "
"outras espécies de parâmetros de tipo::"

#: ../../reference/compound_stmts.rst:1770
msgid ""
"@decorator\n"
"def func[T: int, *Ts, **P](*args: *Ts, arg: Callable[P, T] = some_default):\n"
"    ..."
msgstr ""
"@decorator\n"
"def func[T: int, *Ts, **P](*args: *Ts, arg: Callable[P, T] = some_default):\n"
"    ..."

#: ../../reference/compound_stmts.rst:1774
msgid ""
"Except for the :ref:`lazy evaluation <lazy-evaluation>` of the :class:"
"`~typing.TypeVar` bound, this is equivalent to::"
msgstr ""
"Tirando a :ref:`avaliação preguiçosa <lazy-evaluation>` da delimitação da :"
"class:`~typing.TypeVar`, isso é equivalente a::"

#: ../../reference/compound_stmts.rst:1777
msgid ""
"DEFAULT_OF_arg = some_default\n"
"\n"
"annotation-def TYPE_PARAMS_OF_func():\n"
"\n"
"    annotation-def BOUND_OF_T():\n"
"        return int\n"
"    # In reality, BOUND_OF_T() is evaluated only on demand.\n"
"    T = typing.TypeVar(\"T\", bound=BOUND_OF_T())\n"
"\n"
"    Ts = typing.TypeVarTuple(\"Ts\")\n"
"    P = typing.ParamSpec(\"P\")\n"
"\n"
"    def func(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):\n"
"        ...\n"
"\n"
"    func.__type_params__ = (T, Ts, P)\n"
"    return func\n"
"func = decorator(TYPE_PARAMS_OF_func())"
msgstr ""
"DEFAULT_OF_arg = some_default\n"
"\n"
"annotation-def TYPE_PARAMS_OF_func():\n"
"\n"
"    annotation-def BOUND_OF_T():\n"
"        return int\n"
"    # In reality, BOUND_OF_T() is evaluated only on demand.\n"
"    T = typing.TypeVar(\"T\", bound=BOUND_OF_T())\n"
"\n"
"    Ts = typing.TypeVarTuple(\"Ts\")\n"
"    P = typing.ParamSpec(\"P\")\n"
"\n"
"    def func(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):\n"
"        ...\n"
"\n"
"    func.__type_params__ = (T, Ts, P)\n"
"    return func\n"
"func = decorator(TYPE_PARAMS_OF_func())"

#: ../../reference/compound_stmts.rst:1796
msgid ""
"The capitalized names like ``DEFAULT_OF_arg`` are not actually bound at "
"runtime."
msgstr ""
"Os nomes com maiúsculas como ``DEFAULT_OF_arg`` não são realmente vinculados "
"em tempo de execução."

#: ../../reference/compound_stmts.rst:1802
msgid "Generic classes"
msgstr "Classes genéricas"

#: ../../reference/compound_stmts.rst:1804
msgid "Generic classes are declared as follows::"
msgstr "Classes genéricas são declaradas assim:"

#: ../../reference/compound_stmts.rst:1806
msgid "class Bag[T]: ..."
msgstr "class Bag[T]: ..."

#: ../../reference/compound_stmts.rst:1810
msgid ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(typing.Generic[T]):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = TYPE_PARAMS_OF_Bag()"
msgstr ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(typing.Generic[T]):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = TYPE_PARAMS_OF_Bag()"

#: ../../reference/compound_stmts.rst:1818
msgid ""
"Here again ``annotation-def`` (not a real keyword) indicates an :ref:"
"`annotation scope <annotation-scopes>`, and the name ``TYPE_PARAMS_OF_Bag`` "
"is not actually bound at runtime."
msgstr ""
"Aqui novamente ``annotation-def`` (não é uma palavra reservada real) indica "
"um :ref:`escopo de anotação <annotation-scopes>`, e o nome "
"``TYPE_PARAMS_OF_Bag`` não é realmente vinculado em tempo de execução."

#: ../../reference/compound_stmts.rst:1822
msgid ""
"Generic classes implicitly inherit from :data:`typing.Generic`. The base "
"classes and keyword arguments of generic classes are evaluated within the "
"type scope for the type parameters, and decorators are evaluated outside "
"that scope. This is illustrated by this example::"
msgstr ""
"Classes genéricas herdam implicitamente de :data:`typing.Generic`. As "
"classes base e os argumentos nomeados de classes genéricas são avaliados "
"dentro do escopo de tipo para os parâmetros de tipo, e os decoradores são "
"avaliados fora desse escopo. Isso é ilustrado por este exemplo::"

#: ../../reference/compound_stmts.rst:1828
msgid ""
"@decorator\n"
"class Bag(Base[T], arg=T): ..."
msgstr ""
"@decorator\n"
"class Bag(Base[T], arg=T): ..."

#: ../../reference/compound_stmts.rst:1831
msgid "This is equivalent to::"
msgstr "Isso equivale a::"

#: ../../reference/compound_stmts.rst:1833
msgid ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(Base[T], typing.Generic[T], arg=T):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = decorator(TYPE_PARAMS_OF_Bag())"
msgstr ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(Base[T], typing.Generic[T], arg=T):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = decorator(TYPE_PARAMS_OF_Bag())"

#: ../../reference/compound_stmts.rst:1844
msgid "Generic type aliases"
msgstr "Apelidos de tipo genérico"

#: ../../reference/compound_stmts.rst:1846
msgid ""
"The :keyword:`type` statement can also be used to create a generic type "
"alias::"
msgstr ""
"A instrução :keyword:`type` também pode ser usada para criar um apelido de "
"tipo genérico::"

#: ../../reference/compound_stmts.rst:1848
msgid "type ListOrSet[T] = list[T] | set[T]"
msgstr "type ListOrSet[T] = list[T] | set[T]"

#: ../../reference/compound_stmts.rst:1850
msgid ""
"Except for the :ref:`lazy evaluation <lazy-evaluation>` of the value, this "
"is equivalent to::"
msgstr ""
"Exceto pela :ref:`avaliação preguiçosa <lazy-evaluation>` do valor, isso é "
"equivalente a::"

#: ../../reference/compound_stmts.rst:1853
msgid ""
"annotation-def TYPE_PARAMS_OF_ListOrSet():\n"
"    T = typing.TypeVar(\"T\")\n"
"\n"
"    annotation-def VALUE_OF_ListOrSet():\n"
"        return list[T] | set[T]\n"
"    # In reality, the value is lazily evaluated\n"
"    return typing.TypeAliasType(\"ListOrSet\", VALUE_OF_ListOrSet(), "
"type_params=(T,))\n"
"ListOrSet = TYPE_PARAMS_OF_ListOrSet()"
msgstr ""
"annotation-def TYPE_PARAMS_OF_ListOrSet():\n"
"    T = typing.TypeVar(\"T\")\n"
"\n"
"    annotation-def VALUE_OF_ListOrSet():\n"
"        return list[T] | set[T]\n"
"    # Na realidade, o valor é avaliado preguiçosamente\n"
"    return typing.TypeAliasType(\"ListOrSet\", VALUE_OF_ListOrSet(), "
"type_params=(T,))\n"
"ListOrSet = TYPE_PARAMS_OF_ListOrSet()"

#: ../../reference/compound_stmts.rst:1862
msgid ""
"Here, ``annotation-def`` (not a real keyword) indicates an :ref:`annotation "
"scope <annotation-scopes>`. The capitalized names like "
"``TYPE_PARAMS_OF_ListOrSet`` are not actually bound at runtime."
msgstr ""
"Aqui, ``annotation-def`` (não é uma palavra reservada real) indica um :ref:"
"`escopo de anotação <annotation-scopes>`. Os nomes em maiúsculas como "
"``TYPE_PARAMS_OF_ListOrSet`` não são realmente vinculados em tempo de "
"execução."

#: ../../reference/compound_stmts.rst:1869
msgid "Annotations"
msgstr "Anotações"

#: ../../reference/compound_stmts.rst:1871
msgid "Annotations are now lazily evaluated by default."
msgstr "Anotações são agora avaliados preguiçosamente por padrão."

#: ../../reference/compound_stmts.rst:1874
msgid ""
"Variables and function parameters may carry :term:`annotations "
"<annotation>`, created by adding a colon after the name, followed by an "
"expression::"
msgstr ""
"Variáveis e parâmetros de função podem conter :term:`anotações "
"<annotation>`, criadas adicionando dois pontos após o nome, seguidos de uma "
"expressão::"

#: ../../reference/compound_stmts.rst:1877
msgid ""
"x: annotation = 1\n"
"def f(param: annotation): ..."
msgstr ""
"x: annotation = 1\n"
"def f(param: annotation): ..."

#: ../../reference/compound_stmts.rst:1880
msgid "Functions may also carry a return annotation following an arrow::"
msgstr ""
"As funções também podem ter uma anotação de retorno seguindo uma seta::"

#: ../../reference/compound_stmts.rst:1882
msgid "def f() -> annotation: ..."
msgstr "def f() -> annotation: ..."

#: ../../reference/compound_stmts.rst:1884
msgid ""
"Annotations are conventionally used for :term:`type hints <type hint>`, but "
"this is not enforced by the language, and in general annotations may contain "
"arbitrary expressions. The presence of annotations does not change the "
"runtime semantics of the code, except if some mechanism is used that "
"introspects and uses the annotations (such as :mod:`dataclasses` or :func:"
"`functools.singledispatch`)."
msgstr ""
"Anotações são convencionalmente usadas para :term:`dicas de tipo <type "
"hint>`, mas isso não é imposto pela linguagem e, em geral, anotações podem "
"conter expressões arbitrárias. A presença de anotações não altera a "
"semântica de tempo de execução do código, exceto se algum mecanismo for "
"usado para introspectar e utilizar as anotações (como :mod:`dataclasses` ou :"
"func:`functools.singledispatch`)."

#: ../../reference/compound_stmts.rst:1890
msgid ""
"By default, annotations are lazily evaluated in an :ref:`annotation scope "
"<annotation-scopes>`. This means that they are not evaluated when the code "
"containing the annotation is evaluated. Instead, the interpreter saves "
"information that can be used to evaluate the annotation later if requested. "
"The :mod:`annotationlib` module provides tools for evaluating annotations."
msgstr ""
"Por padrão, as anotações são avaliadas preguiçosamente em um :ref:`escopo de "
"anotações <annotation-scopes>`. Isso significa que elas não são avaliadas "
"quando o código que contém a anotação é avaliado. Em vez disso, o "
"interpretador salva informações que podem ser usadas para avaliar a anotação "
"posteriormente, se solicitado. O módulo :mod:`annotationlib` fornece "
"ferramentas para avaliar anotações."

#: ../../reference/compound_stmts.rst:1895
msgid ""
"If the :ref:`future statement <future>` ``from __future__ import "
"annotations`` is present, all annotations are instead stored as strings::"
msgstr ""
"Se :ref:`instrução future <future>` ``from __future__ import annotations`` "
"estiver presente, todas as anotações serão armazenadas como strings::"

#: ../../reference/compound_stmts.rst:1898
msgid ""
">>> from __future__ import annotations\n"
">>> def f(param: annotation): ...\n"
">>> f.__annotations__\n"
"{'param': 'annotation'}"
msgstr ""
">>> from __future__ import annotations\n"
">>> def f(param: annotation): ...\n"
">>> f.__annotations__\n"
"{'param': 'annotation'}"

#: ../../reference/compound_stmts.rst:1903
msgid ""
"This future statement will be deprecated and removed in a future version of "
"Python, but not before Python 3.13 reaches its end of life (see :pep:`749`). "
"When it is used, introspection tools like :func:`annotationlib."
"get_annotations` and :func:`typing.get_type_hints` are less likely to be "
"able to resolve annotations at runtime."
msgstr ""
"Esta instrução future será descontinuada e removida em uma versão futura do "
"Python, mas não antes do Python 3.13 chegar ao fim de sua vida útil "
"(consulte :pep:`749`). Quando usada, ferramentas de introspecção como :func:"
"`annotationlib.get_annotations` e :func:`typing.get_type_hints` têm menor "
"probabilidade de resolver anotações em tempo de execução."

#: ../../reference/compound_stmts.rst:1911
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../reference/compound_stmts.rst:1912
msgid ""
"The exception is propagated to the invocation stack unless there is a :"
"keyword:`finally` clause which happens to raise another exception. That new "
"exception causes the old one to be lost."
msgstr ""
"A exceção é propagada para a pilha de invocação, a menos que haja uma "
"cláusula :keyword:`finally` que por acaso levante outra exceção. Essa nova "
"exceção faz com que a antiga seja perdida."

#: ../../reference/compound_stmts.rst:1916
msgid "In pattern matching, a sequence is defined as one of the following:"
msgstr ""
"Na correspondência de padrões, uma sequência é definida como uma das "
"seguintes:"

#: ../../reference/compound_stmts.rst:1918
msgid "a class that inherits from :class:`collections.abc.Sequence`"
msgstr "uma classe que herda de :class:`collections.abc.Sequence`"

#: ../../reference/compound_stmts.rst:1919
msgid ""
"a Python class that has been registered as :class:`collections.abc.Sequence`"
msgstr ""
"uma classe Python que foi registrada como :class:`collections.abc.Sequence`"

#: ../../reference/compound_stmts.rst:1920
msgid ""
"a builtin class that has its (CPython) :c:macro:`Py_TPFLAGS_SEQUENCE` bit set"
msgstr ""
"uma classe embutida que tem seu bit :c:macro:`Py_TPFLAGS_SEQUENCE` (CPython) "
"definido"

#: ../../reference/compound_stmts.rst:1921
#: ../../reference/compound_stmts.rst:1940
msgid "a class that inherits from any of the above"
msgstr "uma classe que herda de qualquer uma das anteriores"

#: ../../reference/compound_stmts.rst:1923
msgid "The following standard library classes are sequences:"
msgstr "As seguintes classes de biblioteca padrão são sequências:"

#: ../../reference/compound_stmts.rst:1925
msgid ":class:`array.array`"
msgstr ":class:`array.array`"

#: ../../reference/compound_stmts.rst:1926
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: ../../reference/compound_stmts.rst:1928
msgid ":class:`memoryview`"
msgstr ":class:`memoryview`"

#: ../../reference/compound_stmts.rst:1929
msgid ":class:`range`"
msgstr ":class:`range`"

#: ../../reference/compound_stmts.rst:1932
msgid ""
"Subject values of type ``str``, ``bytes``, and ``bytearray`` do not match "
"sequence patterns."
msgstr ""
"Valores de assunto do tipo ``str``, ``bytes`` e ``bytearray`` não "
"correspondem aos padrões de sequência."

#: ../../reference/compound_stmts.rst:1935
msgid "In pattern matching, a mapping is defined as one of the following:"
msgstr ""
"Na correspondência de padrões, um mapeamento é definido como uma das "
"seguintes:"

#: ../../reference/compound_stmts.rst:1937
msgid "a class that inherits from :class:`collections.abc.Mapping`"
msgstr "uma classe que herda de :class:`collections.abc.Mapping`"

#: ../../reference/compound_stmts.rst:1938
msgid ""
"a Python class that has been registered as :class:`collections.abc.Mapping`"
msgstr ""
"uma classe Python que foi registrada como :class:`collections.abc.Mapping`"

#: ../../reference/compound_stmts.rst:1939
msgid ""
"a builtin class that has its (CPython) :c:macro:`Py_TPFLAGS_MAPPING` bit set"
msgstr ""
"uma classe embutida que tem seu bit :c:macro:`Py_TPFLAGS_MAPPING` (CPython) "
"definido"

#: ../../reference/compound_stmts.rst:1942
msgid ""
"The standard library classes :class:`dict` and :class:`types."
"MappingProxyType` are mappings."
msgstr ""
"As classes de biblioteca padrão :class:`dict` e :class:`types."
"MappingProxyType` são mapeamentos."

#: ../../reference/compound_stmts.rst:1945
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's :attr:`~function.__doc__` attribute and "
"therefore the function's :term:`docstring`."
msgstr ""
"Um literal de string que aparece como a primeira instrução no corpo da "
"função é transformado no atributo :attr:`~function.__doc__` da função e, "
"portanto, no :term:`docstring` da função."

#: ../../reference/compound_stmts.rst:1949
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's :attr:`~type.__doc__` item and therefore "
"the class's :term:`docstring`."
msgstr ""
"Um literal de string que aparece como a primeira instrução no corpo da "
"classe é transformado no item :attr:`~type.__doc__` do espaço de nomes e, "
"portanto, no :term:`docstring` da classe."

#: ../../reference/compound_stmts.rst:7
msgid "compound"
msgstr "compound"

#: ../../reference/compound_stmts.rst:7 ../../reference/compound_stmts.rst:86
#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:129
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:169
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:393
#: ../../reference/compound_stmts.rst:442
#: ../../reference/compound_stmts.rst:480
#: ../../reference/compound_stmts.rst:597
#: ../../reference/compound_stmts.rst:1204
#: ../../reference/compound_stmts.rst:1392
#: ../../reference/compound_stmts.rst:1502
#: ../../reference/compound_stmts.rst:1536
#: ../../reference/compound_stmts.rst:1581
msgid "statement"
msgstr "instrução"

#: ../../reference/compound_stmts.rst:21
msgid "clause"
msgstr "cláusula"

#: ../../reference/compound_stmts.rst:21
msgid "suite"
msgstr "conjunto (suite)"

#: ../../reference/compound_stmts.rst:21
msgid "; (semicolon)"
msgstr "; (ponto e vírgula)"

#: ../../reference/compound_stmts.rst:64
msgid "NEWLINE token"
msgstr "token NEWLINE"

#: ../../reference/compound_stmts.rst:64
msgid "DEDENT token"
msgstr "token DEDENT"

#: ../../reference/compound_stmts.rst:64
msgid "dangling"
msgstr "pendurado"

#: ../../reference/compound_stmts.rst:64 ../../reference/compound_stmts.rst:86
#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:393
msgid "else"
msgstr "else"

#: ../../reference/compound_stmts.rst:86 ../../reference/compound_stmts.rst:597
msgid "if"
msgstr "if"

#: ../../reference/compound_stmts.rst:86 ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:330
#: ../../reference/compound_stmts.rst:393
#: ../../reference/compound_stmts.rst:411
#: ../../reference/compound_stmts.rst:480
#: ../../reference/compound_stmts.rst:597
#: ../../reference/compound_stmts.rst:1512
msgid "keyword"
msgstr "palavra reservada"

#: ../../reference/compound_stmts.rst:86
msgid "elif"
msgstr "elif"

#: ../../reference/compound_stmts.rst:86 ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:480
#: ../../reference/compound_stmts.rst:597
#: ../../reference/compound_stmts.rst:1204
#: ../../reference/compound_stmts.rst:1334
#: ../../reference/compound_stmts.rst:1392
msgid ": (colon)"
msgstr ": (dois pontos)"

#: ../../reference/compound_stmts.rst:86 ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:480
#: ../../reference/compound_stmts.rst:597
#: ../../reference/compound_stmts.rst:1204
#: ../../reference/compound_stmts.rst:1392
msgid "compound statement"
msgstr "instrução composta"

#: ../../reference/compound_stmts.rst:111
msgid "while"
msgstr "while"

#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
msgid "loop"
msgstr "laço"

#: ../../reference/compound_stmts.rst:129
#: ../../reference/compound_stmts.rst:169
#: ../../reference/compound_stmts.rst:393
#: ../../reference/compound_stmts.rst:442
msgid "break"
msgstr "break"

#: ../../reference/compound_stmts.rst:129
#: ../../reference/compound_stmts.rst:169
#: ../../reference/compound_stmts.rst:393
#: ../../reference/compound_stmts.rst:442
msgid "continue"
msgstr "continue"

#: ../../reference/compound_stmts.rst:144
msgid "for"
msgstr "for"

#: ../../reference/compound_stmts.rst:144
msgid "in"
msgstr "in"

#: ../../reference/compound_stmts.rst:144
msgid "target"
msgstr "alvo"

#: ../../reference/compound_stmts.rst:144
msgid "list"
msgstr "lista"

#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:301
#: ../../reference/compound_stmts.rst:1204
#: ../../reference/compound_stmts.rst:1392
msgid "object"
msgstr "objeto"

#: ../../reference/compound_stmts.rst:144
msgid "sequence"
msgstr "sequência"

#: ../../reference/compound_stmts.rst:190
msgid "built-in function"
msgstr "função embutida"

#: ../../reference/compound_stmts.rst:190
msgid "range"
msgstr "range"

#: ../../reference/compound_stmts.rst:207
msgid "try"
msgstr "try"

#: ../../reference/compound_stmts.rst:207
msgid "except"
msgstr "except"

#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:411
msgid "finally"
msgstr "finally"

#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:268
#: ../../reference/compound_stmts.rst:480
#: ../../reference/compound_stmts.rst:597
msgid "as"
msgstr "as"

#: ../../reference/compound_stmts.rst:268
msgid "except clause"
msgstr "cláusula except"

#: ../../reference/compound_stmts.rst:301
msgid "module"
msgstr "módulo"

#: ../../reference/compound_stmts.rst:301
msgid "sys"
msgstr "sys"

#: ../../reference/compound_stmts.rst:301
msgid "traceback"
msgstr "traceback"

#: ../../reference/compound_stmts.rst:330
msgid "except_star"
msgstr "except_star"

#: ../../reference/compound_stmts.rst:393
#: ../../reference/compound_stmts.rst:442
msgid "return"
msgstr "return"

#: ../../reference/compound_stmts.rst:480
msgid "with"
msgstr "with"

#: ../../reference/compound_stmts.rst:480
msgid "with statement"
msgstr "instrução with"

#: ../../reference/compound_stmts.rst:480
#: ../../reference/compound_stmts.rst:1204
#: ../../reference/compound_stmts.rst:1392
msgid ", (comma)"
msgstr ", (vírgula)"

#: ../../reference/compound_stmts.rst:597
msgid "match"
msgstr "match"

#: ../../reference/compound_stmts.rst:597
msgid "case"
msgstr "case"

#: ../../reference/compound_stmts.rst:597
msgid "pattern matching"
msgstr "correspondência de padrões"

#: ../../reference/compound_stmts.rst:597
msgid "match statement"
msgstr "instrução match"

#: ../../reference/compound_stmts.rst:701
msgid "guard"
msgstr "guard"

#: ../../reference/compound_stmts.rst:740
msgid "irrefutable case block"
msgstr "bloco irrefutável de case"

#: ../../reference/compound_stmts.rst:740
msgid "case block"
msgstr "bloco de case"

#: ../../reference/compound_stmts.rst:764
msgid "! patterns"
msgstr "padrões !"

#: ../../reference/compound_stmts.rst:764
msgid "AS pattern, OR pattern, capture pattern, wildcard pattern"
msgstr "padrão AS, padrão OR, padrão de captura, padrão curinga"

#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1284
msgid "parameter"
msgstr "parâmetro"

#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1204
#: ../../reference/compound_stmts.rst:1248
#: ../../reference/compound_stmts.rst:1284
#: ../../reference/compound_stmts.rst:1313
msgid "function definition"
msgstr "definição de função"

#: ../../reference/compound_stmts.rst:1204
msgid "def"
msgstr "def"

#: ../../reference/compound_stmts.rst:1204
#: ../../reference/compound_stmts.rst:1334
msgid "function"
msgstr "função"

#: ../../reference/compound_stmts.rst:1204
#: ../../reference/compound_stmts.rst:1392
msgid "definition"
msgstr "definição"

#: ../../reference/compound_stmts.rst:1204
#: ../../reference/compound_stmts.rst:1392
msgid "name"
msgstr "nome"

#: ../../reference/compound_stmts.rst:1204
#: ../../reference/compound_stmts.rst:1392
msgid "binding"
msgstr "vinculação"

#: ../../reference/compound_stmts.rst:1204
msgid "user-defined function"
msgstr "função definida por usuário"

#: ../../reference/compound_stmts.rst:1204
#: ../../reference/compound_stmts.rst:1392
msgid "() (parentheses)"
msgstr "() (parênteses)"

#: ../../reference/compound_stmts.rst:1204
msgid "parameter list"
msgstr "lista de parâmetros"

#: ../../reference/compound_stmts.rst:1248
#: ../../reference/compound_stmts.rst:1442
msgid "@ (at)"
msgstr "@ (arroba)"

#: ../../reference/compound_stmts.rst:1284
msgid "default"
msgstr "default"

#: ../../reference/compound_stmts.rst:1284
msgid "value"
msgstr "value"

#: ../../reference/compound_stmts.rst:1284
msgid "argument"
msgstr "argumento"

#: ../../reference/compound_stmts.rst:1284
msgid "= (equals)"
msgstr "= (igual)"

#: ../../reference/compound_stmts.rst:1313
msgid "/ (slash)"
msgstr "/ (barra)"

#: ../../reference/compound_stmts.rst:1313
msgid "* (asterisk)"
msgstr "* (asterisco)"

#: ../../reference/compound_stmts.rst:1313
msgid "**"
msgstr "**"

#: ../../reference/compound_stmts.rst:1334
msgid "annotations"
msgstr "annotations"

#: ../../reference/compound_stmts.rst:1334
msgid "->"
msgstr "->"

#: ../../reference/compound_stmts.rst:1334
msgid "function annotations"
msgstr "anotações de função"

#: ../../reference/compound_stmts.rst:1351
msgid "lambda"
msgstr "lambda"

#: ../../reference/compound_stmts.rst:1351
msgid "expression"
msgstr "expressão"

#: ../../reference/compound_stmts.rst:1392
msgid "class"
msgstr "classe"

#: ../../reference/compound_stmts.rst:1392
msgid "execution"
msgstr "execução"

#: ../../reference/compound_stmts.rst:1392
msgid "frame"
msgstr "quadro"

#: ../../reference/compound_stmts.rst:1392
msgid "inheritance"
msgstr "herança"

#: ../../reference/compound_stmts.rst:1392
msgid "docstring"
msgstr "docstring"

#: ../../reference/compound_stmts.rst:1392
#: ../../reference/compound_stmts.rst:1442
msgid "class definition"
msgstr "definição de classe"

#: ../../reference/compound_stmts.rst:1392
msgid "expression list"
msgstr "expressão, lista de"

#: ../../reference/compound_stmts.rst:1502
msgid "async def"
msgstr "async def"

#: ../../reference/compound_stmts.rst:1512
msgid "async"
msgstr "async"

#: ../../reference/compound_stmts.rst:1512
msgid "await"
msgstr "await"

#: ../../reference/compound_stmts.rst:1536
msgid "async for"
msgstr "async for"

#: ../../reference/compound_stmts.rst:1581
msgid "async with"
msgstr "async with"

#: ../../reference/compound_stmts.rst:1638
msgid "type parameters"
msgstr "parâmetros de tipo"

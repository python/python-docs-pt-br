# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-15 15:27+0000\n"
"PO-Revision-Date: 2023-05-24 02:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../reference/import.rst:6
msgid "The import system"
msgstr "O sistema de importação"

#: ../../reference/import.rst:10
msgid ""
"Python code in one :term:`module` gains access to the code in another module "
"by the process of :term:`importing` it.  The :keyword:`import` statement is "
"the most common way of invoking the import machinery, but it is not the only "
"way.  Functions such as :func:`importlib.import_module` and built-in :func:"
"`__import__` can also be used to invoke the import machinery."
msgstr ""
"O código Python em um :term:`módulo` obtém acesso ao código em outro módulo "
"pelo processo de :term:`importação` dele. A instrução :keyword:`import` é a "
"maneira mais comum de invocar o mecanismo de importação, mas não é a única "
"maneira. Funções como :func:`importlib.import_module` e a função embutida :"
"func:`__import__` também podem ser usadas para chamar o mecanismo de "
"importação."

#: ../../reference/import.rst:16
msgid ""
"The :keyword:`import` statement combines two operations; it searches for the "
"named module, then it binds the results of that search to a name in the "
"local scope.  The search operation of the :keyword:`!import` statement is "
"defined as a call to the :func:`__import__` function, with the appropriate "
"arguments. The return value of :func:`__import__` is used to perform the "
"name binding operation of the :keyword:`!import` statement.  See the :"
"keyword:`!import` statement for the exact details of that name binding "
"operation."
msgstr ""
"A instrução :keyword:`import` combina duas operações; ela procura o módulo "
"nomeado e vincula os resultados dessa pesquisa a um nome no escopo local. A "
"operação de busca da instrução :keyword:`!import` é definida como uma "
"chamada para a função :func:`__import__`, com os argumentos apropriados. O "
"valor de retorno de :func:`__import__` é usado para executar a operação de "
"ligação de nome da instrução :keyword:`!import`. Veja a instrução :keyword:`!"
"import` para os detalhes exatos da operação de ligação desse nome."

#: ../../reference/import.rst:25
msgid ""
"A direct call to :func:`__import__` performs only the module search and, if "
"found, the module creation operation.  While certain side-effects may occur, "
"such as the importing of parent packages, and the updating of various caches "
"(including :data:`sys.modules`), only the :keyword:`import` statement "
"performs a name binding operation."
msgstr ""
"Uma chamada direta para :func:`__import__` realiza apenas a pesquisa do "
"módulo e, se encontrada, a operação de criação do módulo. Embora certos "
"efeitos colaterais possam ocorrer, como a importação de pacotes pai e a "
"atualização de vários caches (incluindo :data:`sys.modules`), apenas a "
"instrução :keyword:`import` realiza uma operação de ligação de nome."

#: ../../reference/import.rst:31
msgid ""
"When an :keyword:`import` statement is executed, the standard builtin :func:"
"`__import__` function is called. Other mechanisms for invoking the import "
"system (such as :func:`importlib.import_module`) may choose to bypass :func:"
"`__import__` and use their own solutions to implement import semantics."
msgstr ""
"Quando uma instrução :keyword:`import` é executada, a função embutida "
"padrão :func:`__import__` é chamada. Outros mecanismos para chamar o sistema "
"de importação (como :func:`importlib.import_module`) podem optar por "
"ignorar :func:`__import__` e usar suas próprias soluções para implementar a "
"semântica de importação."

#: ../../reference/import.rst:36
msgid ""
"When a module is first imported, Python searches for the module and if "
"found, it creates a module object [#fnmo]_, initializing it.  If the named "
"module cannot be found, a :exc:`ModuleNotFoundError` is raised.  Python "
"implements various strategies to search for the named module when the import "
"machinery is invoked.  These strategies can be modified and extended by "
"using various hooks described in the sections below."
msgstr ""
"Quando um módulo é importado pela primeira vez, o Python procura pelo módulo "
"e, se encontrado, cria um objeto de módulo [#fnmo]_, inicializando-o. Se o "
"módulo nomeado não puder ser encontrado, uma :exc:`ModuleNotFoundError` será "
"levantada. O Python implementa várias estratégias para procurar o módulo "
"nomeado quando o mecanismo de importação é chamado. Essas estratégias podem "
"ser modificadas e estendidas usando vários ganchos descritos nas seções "
"abaixo."

#: ../../reference/import.rst:43
msgid ""
"The import system has been updated to fully implement the second phase of :"
"pep:`302`. There is no longer any implicit import machinery - the full "
"import system is exposed through :data:`sys.meta_path`. In addition, native "
"namespace package support has been implemented (see :pep:`420`)."
msgstr ""
"O sistema de importação foi atualizado para implementar completamente a "
"segunda fase da :pep:`302`. Não há mais um mecanismo de importação implícito "
"-- o sistema completo de importação é exposto através de :data:`sys."
"meta_path`. Além disso, o suporte nativo a pacote de espaço de nomes foi "
"implementado (consulte :pep:`420`)."

#: ../../reference/import.rst:51
msgid ":mod:`importlib`"
msgstr ":mod:`importlib`"

#: ../../reference/import.rst:53
msgid ""
"The :mod:`importlib` module provides a rich API for interacting with the "
"import system.  For example :func:`importlib.import_module` provides a "
"recommended, simpler API than built-in :func:`__import__` for invoking the "
"import machinery.  Refer to the :mod:`importlib` library documentation for "
"additional detail."
msgstr ""
"O módulo :mod:`importlib` fornece uma API rica para interagir com o sistema "
"de importação. Por exemplo, :func:`importlib.import_module` fornece uma API "
"mais simples e recomendada do que a função embutida :func:`__import__` para "
"chamar o mecanismo de importação. Consulte a documentação da biblioteca :mod:"
"`importlib` para obter detalhes adicionais."

#: ../../reference/import.rst:62
msgid "Packages"
msgstr "Pacotes"

#: ../../reference/import.rst:67
msgid ""
"Python has only one type of module object, and all modules are of this type, "
"regardless of whether the module is implemented in Python, C, or something "
"else.  To help organize modules and provide a naming hierarchy, Python has a "
"concept of :term:`packages <package>`."
msgstr ""
"O Python possui apenas um tipo de objeto de módulo e todos os módulos são "
"desse tipo, independentemente de o módulo estar implementado em Python, C ou "
"qualquer outra coisa. Para ajudar a organizar os módulos e fornecer uma "
"hierarquia de nomes, o Python tem o conceito de :term:`pacotes <pacote>`."

#: ../../reference/import.rst:72
msgid ""
"You can think of packages as the directories on a file system and modules as "
"files within directories, but don't take this analogy too literally since "
"packages and modules need not originate from the file system.  For the "
"purposes of this documentation, we'll use this convenient analogy of "
"directories and files.  Like file system directories, packages are organized "
"hierarchically, and packages may themselves contain subpackages, as well as "
"regular modules."
msgstr ""
"Você pode pensar em pacotes como os diretórios em um sistema de arquivos e "
"os módulos como arquivos nos diretórios, mas não tome essa analogia muito "
"literalmente, já que pacotes e módulos não precisam se originar do sistema "
"de arquivos. Para os fins desta documentação, usaremos essa analogia "
"conveniente de diretórios e arquivos. Como os diretórios do sistema de "
"arquivos, os pacotes são organizados hierarquicamente e os próprios pacotes "
"podem conter subpacotes e módulos regulares."

#: ../../reference/import.rst:80
msgid ""
"It's important to keep in mind that all packages are modules, but not all "
"modules are packages.  Or put another way, packages are just a special kind "
"of module.  Specifically, any module that contains a ``__path__`` attribute "
"is considered a package."
msgstr ""
"É importante ter em mente que todos os pacotes são módulos, mas nem todos os "
"módulos são pacotes. Ou, dito de outra forma, os pacotes são apenas um tipo "
"especial de módulo. Especificamente, qualquer módulo que contenha um "
"atributo ``__path__`` é considerado um pacote."

#: ../../reference/import.rst:85
msgid ""
"All modules have a name.  Subpackage names are separated from their parent "
"package name by a dot, akin to Python's standard attribute access syntax.  "
"Thus you might have a package called :mod:`email`, which in turn has a "
"subpackage called :mod:`email.mime` and a module within that subpackage "
"called :mod:`email.mime.text`."
msgstr ""
"Todo módulo tem um nome. Nomes de subpacotes são separados do nome do pacote "
"por um ponto, semelhante à sintaxe de acesso aos atributos padrão do Python. "
"Assim pode ter um pacote chamado :mod:`email`, que por sua vez tem um "
"subpacote chamado :mod:`email.mime` e um módulo dentro dele chamado :mod:"
"`email.mime.text`."

#: ../../reference/import.rst:93
msgid "Regular packages"
msgstr "Pacotes regulares"

#: ../../reference/import.rst:98
msgid ""
"Python defines two types of packages, :term:`regular packages <regular "
"package>` and :term:`namespace packages <namespace package>`.  Regular "
"packages are traditional packages as they existed in Python 3.2 and earlier. "
"A regular package is typically implemented as a directory containing an "
"``__init__.py`` file.  When a regular package is imported, this ``__init__."
"py`` file is implicitly executed, and the objects it defines are bound to "
"names in the package's namespace.  The ``__init__.py`` file can contain the "
"same Python code that any other module can contain, and Python will add some "
"additional attributes to the module when it is imported."
msgstr ""
"O Python define dois tipos de pacotes, :term:`pacotes regulares <regular "
"package>` e :term:`pacotes de espaço de nomes <namespace package>`. Pacotes "
"regulares são pacotes tradicionais, como existiam no Python 3.2 e versões "
"anteriores. Um pacote regular é normalmente implementado como um diretório "
"que contém um arquivo ``__init__.py``. Quando um pacote regular é importado, "
"esse arquivo ``__init__.py`` é executado implicitamente, e os objetos que "
"ele define são vinculados aos nomes no espaço de nomes do pacote. O arquivo "
"``__init__.py`` pode conter o mesmo código Python que qualquer outro módulo "
"pode conter, e o Python adicionará alguns atributos adicionais ao módulo "
"quando ele for importado."

#: ../../reference/import.rst:108
msgid ""
"For example, the following file system layout defines a top level ``parent`` "
"package with three subpackages::"
msgstr ""
"Por exemplo, o layout do sistema de arquivos a seguir define um pacote "
"``parent`` de nível superior com três subpacotes::"

#: ../../reference/import.rst:120
msgid ""
"Importing ``parent.one`` will implicitly execute ``parent/__init__.py`` and "
"``parent/one/__init__.py``.  Subsequent imports of ``parent.two`` or "
"``parent.three`` will execute ``parent/two/__init__.py`` and ``parent/three/"
"__init__.py`` respectively."
msgstr ""
"A importação de ``parent.one`` vai executar implicitamente ``parent/__init__."
"py`` e ``parent/one/__init__.py``.  Importações subsequentes de ``parent."
"two`` ou ``parent.three`` vão executar ``parent/two/__init__.py`` e ``parent/"
"three/__init__.py``, respectivamente."

#: ../../reference/import.rst:127
msgid "Namespace packages"
msgstr "Pacotes de espaço de nomes"

#: ../../reference/import.rst:133
msgid ""
"A namespace package is a composite of various :term:`portions <portion>`, "
"where each portion contributes a subpackage to the parent package.  Portions "
"may reside in different locations on the file system.  Portions may also be "
"found in zip files, on the network, or anywhere else that Python searches "
"during import.  Namespace packages may or may not correspond directly to "
"objects on the file system; they may be virtual modules that have no "
"concrete representation."
msgstr ""
"Um pacote de espaço de nomes é um composto de várias :term:`porções "
"<portion>`, em que cada parte contribui com um subpacote para o pacote pai. "
"Partes podem residir em locais diferentes no sistema de arquivos. Partes "
"também podem ser encontradas em arquivos zip, na rede ou em qualquer outro "
"lugar que o Python pesquisar durante a importação. Os pacotes de espaço de "
"nomes podem ou não corresponder diretamente aos objetos no sistema de "
"arquivos; eles podem ser módulos virtuais que não têm representação concreta."

#: ../../reference/import.rst:141
msgid ""
"Namespace packages do not use an ordinary list for their ``__path__`` "
"attribute. They instead use a custom iterable type which will automatically "
"perform a new search for package portions on the next import attempt within "
"that package if the path of their parent package (or :data:`sys.path` for a "
"top level package) changes."
msgstr ""
"Os pacotes de espaço de nomes não usam uma lista comum para o atributo "
"``__path__``. Em vez disso, eles usam um tipo iterável personalizado que "
"executará automaticamente uma nova pesquisa por partes do pacote na próxima "
"tentativa de importação dentro desse pacote, se o caminho do pacote pai (ou :"
"data:`sys.path` para um pacote de nível superior) for alterado."

#: ../../reference/import.rst:147
msgid ""
"With namespace packages, there is no ``parent/__init__.py`` file.  In fact, "
"there may be multiple ``parent`` directories found during import search, "
"where each one is provided by a different portion.  Thus ``parent/one`` may "
"not be physically located next to ``parent/two``.  In this case, Python will "
"create a namespace package for the top-level ``parent`` package whenever it "
"or one of its subpackages is imported."
msgstr ""
"Com pacotes de espaço de nomes, não há arquivo ``pai/__init__.py``. De fato, "
"pode haver vários diretórios ``pai`` encontrados durante a pesquisa de "
"importação, onde cada um é fornecido por uma parte diferente. Portanto, "
"``pai/um`` pode não estar fisicamente localizado próximo a ``pai/dois``. "
"Nesse caso, o Python criará um pacote de espaço de nomes para o pacote "
"``pai`` de nível superior sempre que ele ou um de seus subpacotes for "
"importado."

#: ../../reference/import.rst:154
msgid "See also :pep:`420` for the namespace package specification."
msgstr ""
"Veja também :pep:`420` para a especificação de pacotes de espaço de nomes."

#: ../../reference/import.rst:158
msgid "Searching"
msgstr "Caminho de busca"

#: ../../reference/import.rst:160
msgid ""
"To begin the search, Python needs the :term:`fully qualified <qualified "
"name>` name of the module (or package, but for the purposes of this "
"discussion, the difference is immaterial) being imported.  This name may "
"come from various arguments to the :keyword:`import` statement, or from the "
"parameters to the :func:`importlib.import_module` or :func:`__import__` "
"functions."
msgstr ""
"Para iniciar a busca, o Python precisa do nome :term:`completo <qualified "
"name>` do módulo (ou pacote, mas para o propósito dessa exposição, não há "
"diferença) que se quer importar. Esse nome vem de vários argumentos passados "
"para a instrução :keyword:`import`, ou dos parâmetros das funções :func:"
"`importlib.import_module` ou :func:`__import__`."

#: ../../reference/import.rst:166
msgid ""
"This name will be used in various phases of the import search, and it may be "
"the dotted path to a submodule, e.g. ``foo.bar.baz``.  In this case, Python "
"first tries to import ``foo``, then ``foo.bar``, and finally ``foo.bar."
"baz``. If any of the intermediate imports fail, a :exc:`ModuleNotFoundError` "
"is raised."
msgstr ""
"Esse nome será usado em várias fases da busca da importação, e pode ser um "
"nome com pontos para um submódulo como, por exemplo, ``foo.bar.baz``. Nesse "
"caso, Python primeiro tenta importar ``foo``, depois ``foo.bar`` e, "
"finalmente, ``foo.bar.baz``. Se alguma das importações intermediárias "
"falharem, uma exceção :exc:`ModuleNotFoundError` é levantada."

#: ../../reference/import.rst:173
msgid "The module cache"
msgstr "O cache de módulos"

#: ../../reference/import.rst:178
msgid ""
"The first place checked during import search is :data:`sys.modules`.  This "
"mapping serves as a cache of all modules that have been previously imported, "
"including the intermediate paths.  So if ``foo.bar.baz`` was previously "
"imported, :data:`sys.modules` will contain entries for ``foo``, ``foo.bar``, "
"and ``foo.bar.baz``.  Each key will have as its value the corresponding "
"module object."
msgstr ""
"A primeira verificação durante a busca da importação é feita no :data:`sys."
"modules`. Esse mapeamento serve como um cache de todos os módulos que já "
"foram importados previamente, incluindo os caminhos intermediários. Se ``foo."
"bar.baz`` foi previamente importado, :data:`sys.modules` conterá entradas "
"para ``foo``, ``foo.bar`` e ``foo.bar.baz``. Cada chave terá como valor um "
"objeto módulo correspondente."

#: ../../reference/import.rst:185
msgid ""
"During import, the module name is looked up in :data:`sys.modules` and if "
"present, the associated value is the module satisfying the import, and the "
"process completes.  However, if the value is ``None``, then a :exc:"
"`ModuleNotFoundError` is raised.  If the module name is missing, Python will "
"continue searching for the module."
msgstr ""
"Durante a importação, o nome do módulo é procurado em :data:`sys.modules` e, "
"se estiver presente, o valor associado é o módulo que satisfaz a importação, "
"e o processo termina. Entretanto, se o valor é ``None``, uma exceção :exc:"
"`ModuleNotFoundError` é levantada. Se o nome do módulo não foi encontrado, "
"Python continuará a busca pelo módulo."

#: ../../reference/import.rst:191
msgid ""
":data:`sys.modules` is writable.  Deleting a key may not destroy the "
"associated module (as other modules may hold references to it), but it will "
"invalidate the cache entry for the named module, causing Python to search "
"anew for the named module upon its next import. The key can also be assigned "
"to ``None``, forcing the next import of the module to result in a :exc:"
"`ModuleNotFoundError`."
msgstr ""
"É possível alterar :data:`sys.modules`. Apagar uma chave pode não destruir o "
"objeto módulo associado (outros módulos podem manter referências para ele), "
"mas a entrada do cache será invalidada para o nome daquele módulo, fazendo "
"Python executar nova busca na próxima importação. Pode ser atribuído "
"``None`` para a chave, forçando que a próxima importação do módulo resulte "
"numa exceção :exc:`ModuleNotFoundError`."

#: ../../reference/import.rst:198
msgid ""
"Beware though, as if you keep a reference to the module object, invalidate "
"its cache entry in :data:`sys.modules`, and then re-import the named module, "
"the two module objects will *not* be the same. By contrast, :func:`importlib."
"reload` will reuse the *same* module object, and simply reinitialise the "
"module contents by rerunning the module's code."
msgstr ""
"No entanto, tenha cuidado, pois se você mantiver uma referência para o "
"objeto módulo, invalidar sua entrada de cache em :data:`sys.modules` e, em "
"seguida, reimportar do módulo nomeado, os dois módulo objetos *não* serão os "
"mesmos. Por outro lado, o :func:`importlib.reload` reutilizará o *mesmo* "
"objeto módulo e simplesmente reinicializará o conteúdo do módulo executando "
"novamente o código do módulo."

#: ../../reference/import.rst:208
msgid "Finders and loaders"
msgstr "Localizadores e carregadores"

#: ../../reference/import.rst:215
msgid ""
"If the named module is not found in :data:`sys.modules`, then Python's "
"import protocol is invoked to find and load the module.  This protocol "
"consists of two conceptual objects, :term:`finders <finder>` and :term:"
"`loaders <loader>`. A finder's job is to determine whether it can find the "
"named module using whatever strategy it knows about. Objects that implement "
"both of these interfaces are referred to as :term:`importers <importer>` - "
"they return themselves when they find that they can load the requested "
"module."
msgstr ""
"Se o módulo nomeado não for encontrado em :data:`sys.modules`, então o "
"protocolo de importação do Python é invocado para localizar e carregar o "
"módulo. Este protocolo consiste em dois objetos conceituais, :term:"
"`localizadores <finder>` e :term:`carregadores <loader>`. O trabalho de um "
"localizador é determinar se ele pode localizar o módulo nomeado usando "
"qualquer estratégia que ele conheça. Objetos que implementam ambas essas "
"interfaces são referenciadas como :term:`importadores <importer>` -- eles "
"retornam a si mesmos, quando eles descobrem que eles podem carregar o módulo "
"requisitado."

#: ../../reference/import.rst:223
msgid ""
"Python includes a number of default finders and importers.  The first one "
"knows how to locate built-in modules, and the second knows how to locate "
"frozen modules.  A third default finder searches an :term:`import path` for "
"modules.  The :term:`import path` is a list of locations that may name file "
"system paths or zip files.  It can also be extended to search for any "
"locatable resource, such as those identified by URLs."
msgstr ""
"Python inclui um número de localizadores e carregadores padrões.  O primeiro "
"sabe como localizar módulos embutidos, e o segundo sabe como localizar "
"módulos congelados. Um terceiro localizador padrão procura em um :term:"
"`caminho de importação` por módulos. O :term:`caminho de importação` é uma "
"lista de localizações que podem nomear caminhos de sistema de arquivo ou "
"arquivos zip. Ele também pode ser estendido para buscar por qualquer recurso "
"localizável, tais como aqueles identificados por URLs."

#: ../../reference/import.rst:230
msgid ""
"The import machinery is extensible, so new finders can be added to extend "
"the range and scope of module searching."
msgstr ""
"O mecanismo de importação é extensível, então novos localizadores podem ser "
"adicionados para estender o alcance e o escopo de buscar módulos."

#: ../../reference/import.rst:233
msgid ""
"Finders do not actually load modules.  If they can find the named module, "
"they return a :dfn:`module spec`, an encapsulation of the module's import-"
"related information, which the import machinery then uses when loading the "
"module."
msgstr ""
"Localizadores na verdade não carregam módulos. Se eles conseguirem encontrar "
"o módulo nomeado, eles retornam um :dfn:`spec de módulo`, um encapsulamento "
"da informação relacionada a importação do módulo, a qual o mecanismo de "
"importação então usa quando o módulo é carregado."

#: ../../reference/import.rst:237
msgid ""
"The following sections describe the protocol for finders and loaders in more "
"detail, including how you can create and register new ones to extend the "
"import machinery."
msgstr ""
"As seguintes seções descrevem o protocolo para localizadores e carregadores "
"em mais detalhes, incluindo como você pode criar e registrar novos para "
"estender o mecanismo de importação."

#: ../../reference/import.rst:241
msgid ""
"In previous versions of Python, finders returned :term:`loaders <loader>` "
"directly, whereas now they return module specs which *contain* loaders. "
"Loaders are still used during import but have fewer responsibilities."
msgstr ""
"Em versões anteriores do Python, localizadores retornavam :term:"
"`carregadores <loader>` diretamente, enquanto agora eles retornam "
"especificações de módulo, as qual *contêm* carregadores. Carregadores ainda "
"são usados durante a importação, mas possuem menos responsabilidades."

#: ../../reference/import.rst:247
msgid "Import hooks"
msgstr "Ganchos de importação"

#: ../../reference/import.rst:257
msgid ""
"The import machinery is designed to be extensible; the primary mechanism for "
"this are the *import hooks*.  There are two types of import hooks: *meta "
"hooks* and *import path hooks*."
msgstr ""
"O mecanismo de importação é desenhado para ser extensível; o mecanismo "
"primário para isso são os *ganchos de importação*.  Existem dois tipos de "
"ganchos de importação: *metaganchos* e *ganchos de importação de caminho*."

#: ../../reference/import.rst:261
msgid ""
"Meta hooks are called at the start of import processing, before any other "
"import processing has occurred, other than :data:`sys.modules` cache look "
"up. This allows meta hooks to override :data:`sys.path` processing, frozen "
"modules, or even built-in modules.  Meta hooks are registered by adding new "
"finder objects to :data:`sys.meta_path`, as described below."
msgstr ""
"Metaganchos são chamados no início do processo de importação, antes que "
"qualquer outro processo de importação tenha ocorrido, que não seja busca de "
"cache de :data:`sys.modules`. Isso permite aos metaganchos substituir "
"processamento de :data:`sys.path`, módulos congelados ou mesmo módulos "
"embutidos. Metaganchos são registrados adicionando novos objetos "
"localizadores a :data:`sys.meta_path`, conforme descrito abaixo."

#: ../../reference/import.rst:267
msgid ""
"Import path hooks are called as part of :data:`sys.path` (or ``package."
"__path__``) processing, at the point where their associated path item is "
"encountered.  Import path hooks are registered by adding new callables to :"
"data:`sys.path_hooks` as described below."
msgstr ""
"Ganchos de caminho de importação são chamados como parte do processamento "
"de :data:`sys.path` (ou ``package.__path__``), no ponto onde é encontrado o "
"item do caminho associado. Ganchos de caminho de importação são registrados "
"adicionando novos chamáveis para :data:`sys.path_hooks`, conforme descrito "
"abaixo."

#: ../../reference/import.rst:274
msgid "The meta path"
msgstr "O metacaminho"

#: ../../reference/import.rst:280
msgid ""
"When the named module is not found in :data:`sys.modules`, Python next "
"searches :data:`sys.meta_path`, which contains a list of meta path finder "
"objects.  These finders are queried in order to see if they know how to "
"handle the named module.  Meta path finders must implement a method called :"
"meth:`~importlib.abc.MetaPathFinder.find_spec()` which takes three "
"arguments: a name, an import path, and (optionally) a target module.  The "
"meta path finder can use any strategy it wants to determine whether it can "
"handle the named module or not."
msgstr ""
"Quando o módulo nomeado não é encontrado em :data:`sys.modules`, Python em "
"seguida busca :data:`sys.meta_path`, o qual contém uma lista de objetos "
"localizador de metacaminho. Esses buscadores são consultados a fim de "
"verificar se eles sabem como manipular o módulo nomeado. Os localizadores de "
"metacaminho devem implementar um método chamado :meth:`~importlib.abc."
"MetaPathFinder.find_spec()`, o qual recebe três argumentos: um nome, um "
"caminho de importação, e (opcionalmente) um módulo alvo. O localizador de "
"metacaminho pode usar qualquer estratégia que ele quiser para determinar se "
"ele pode manipular o módulo nomeado ou não."

#: ../../reference/import.rst:289
msgid ""
"If the meta path finder knows how to handle the named module, it returns a "
"spec object.  If it cannot handle the named module, it returns ``None``.  "
"If :data:`sys.meta_path` processing reaches the end of its list without "
"returning a spec, then a :exc:`ModuleNotFoundError` is raised.  Any other "
"exceptions raised are simply propagated up, aborting the import process."
msgstr ""
"Se o localizador de metacaminho souber como tratar o módulo nomeado, ele "
"retorna um objeto spec. Se ele não puder tratar o módulo nomeado, ele "
"retorna ``None``. Se o processamento de :data:`sys.meta_path` alcançar o fim "
"da sua lista sem retornar um spec, então :exc:`ModuleNotFoundError` é "
"levantada. Quaisquer outras exceções levantadas são simplesmente propagadas "
"para cima, abortando o processo de importação."

#: ../../reference/import.rst:295
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec()` method of meta path "
"finders is called with two or three arguments.  The first is the fully "
"qualified name of the module being imported, for example ``foo.bar.baz``. "
"The second argument is the path entries to use for the module search.  For "
"top-level modules, the second argument is ``None``, but for submodules or "
"subpackages, the second argument is the value of the parent package's "
"``__path__`` attribute. If the appropriate ``__path__`` attribute cannot be "
"accessed, a :exc:`ModuleNotFoundError` is raised.  The third argument is an "
"existing module object that will be the target of loading later. The import "
"system passes in a target module only during reload."
msgstr ""
"O método :meth:`~importlib.abc.MetaPathFinder.find_spec()` dos localizadores "
"de metacaminhos é chamado com dois ou três argumentos. O primeiro é o nome "
"totalmente qualificado do módulo sendo importado, por exemplo ``foo.bar."
"baz``. O segundo argumento é o caminho de entradas para usar para a busca do "
"módulo. Para módulos de alto nível, o segundo argumento é ``None``, mas para "
"submódulos ou subpacotes, o segundo argumento é o valor do atributo "
"``__path__`` do pacote pai. Se o atributo ``__path__`` apropriado não puder "
"ser acessado, uma exceção :exc:`ModuleNotFoundError` é levantada. O terceiro "
"argumento é um objeto módulo existente que será o alvo do carregamento "
"posteriormente. O sistema de importação passa um módulo alvo apenas durante "
"o recarregamento."

#: ../../reference/import.rst:306
msgid ""
"The meta path may be traversed multiple times for a single import request. "
"For example, assuming none of the modules involved has already been cached, "
"importing ``foo.bar.baz`` will first perform a top level import, calling "
"``mpf.find_spec(\"foo\", None, None)`` on each meta path finder (``mpf``). "
"After ``foo`` has been imported, ``foo.bar`` will be imported by traversing "
"the meta path a second time, calling ``mpf.find_spec(\"foo.bar\", foo."
"__path__, None)``. Once ``foo.bar`` has been imported, the final traversal "
"will call ``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)``."
msgstr ""
"O metacaminho pode ser percorrido múltiplas vezes para uma requisição de "
"importação individual. Por exemplo, presumindo que nenhum dos módulos "
"envolvidos já tenha sido cacheado, importar ``foo.bar.baz`` irá primeiro "
"executar uma importação de alto nível, chamando ``mpf.find_spec(\"foo\", "
"None, None)`` em cada localizador de metacaminho (``mpf``). Depois que "
"``foo`` foi importado, ``foo.bar`` será importado percorrendo o metacaminho "
"uma segunda vez, chamando ``mpf.find_spec(\"foo.bar\", foo.__path__, "
"None)``. Uma vez que ``foo.bar`` tenha sido importado, a travessia final irá "
"chamar ``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)``."

#: ../../reference/import.rst:316
msgid ""
"Some meta path finders only support top level imports. These importers will "
"always return ``None`` when anything other than ``None`` is passed as the "
"second argument."
msgstr ""
"Alguns localizadores de metacaminho apenas dão suporte a importações de alto "
"nível. Estes importadores vão sempre retornar ``None`` quando qualquer coisa "
"diferente de ``None`` for passada como o segundo argumento."

#: ../../reference/import.rst:320
msgid ""
"Python's default :data:`sys.meta_path` has three meta path finders, one that "
"knows how to import built-in modules, one that knows how to import frozen "
"modules, and one that knows how to import modules from an :term:`import "
"path` (i.e. the :term:`path based finder`)."
msgstr ""
"O :data:`sys.meta_path` padrão do Python possui três localizador de "
"metacaminho, um que sabe como importar módulos embutidos, um que sabe como "
"importar módulos congelados, e outro que sabe como importar módulos de um :"
"term:`caminho de importação` (isto é, o :term:`localizador baseado no "
"caminho`)."

#: ../../reference/import.rst:325
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec` method of meta path "
"finders replaced :meth:`~importlib.abc.MetaPathFinder.find_module`, which is "
"now deprecated.  While it will continue to work without change, the import "
"machinery will try it only if the finder does not implement :meth:"
"`~importlib.abc.MetaPathFinder.find_spec`."
msgstr ""

#: ../../reference/import.rst:332
msgid ""
"Use of :meth:`~importlib.abc.MetaPathFinder.find_module` by the import "
"system now raises :exc:`ImportWarning`."
msgstr ""

#: ../../reference/import.rst:338
msgid "Loading"
msgstr "Carregando"

#: ../../reference/import.rst:340
msgid ""
"If and when a module spec is found, the import machinery will use it (and "
"the loader it contains) when loading the module.  Here is an approximation "
"of what happens during the loading portion of import::"
msgstr ""
"Se e quando uma spec de módulo é encontrada, o mecanismo de importação vai "
"usá-la (e o carregador que ela contém) durante o carregamento do módulo. "
"Esta é uma aproximação do que acontece durante a etapa de carregamento de "
"uma importação::"

#: ../../reference/import.rst:374
msgid "Note the following details:"
msgstr "Perceba os seguintes detalhes:"

#: ../../reference/import.rst:376
msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, import will have already returned it."
msgstr ""
"Se houver um objeto módulo existente com o nome fornecido em :data:`sys."
"modules`, a importação já tera retornado ele."

#: ../../reference/import.rst:379
msgid ""
"The module will exist in :data:`sys.modules` before the loader executes the "
"module code.  This is crucial because the module code may (directly or "
"indirectly) import itself; adding it to :data:`sys.modules` beforehand "
"prevents unbounded recursion in the worst case and multiple loading in the "
"best."
msgstr ""
"O módulo irá existir em :data:`sys.modules` antes do carregador executar o "
"código do módulo. Isso é crucial porque o código do módulo pode (direta ou "
"indiretamente) importar a si mesmo; adicioná-lo a :data:`sys.modules` "
"antecipadamente previne recursão infinita no pior caso e múltiplos "
"carregamentos no melhor caso."

#: ../../reference/import.rst:385
msgid ""
"If loading fails, the failing module -- and only the failing module -- gets "
"removed from :data:`sys.modules`.  Any module already in the :data:`sys."
"modules` cache, and any module that was successfully loaded as a side-"
"effect, must remain in the cache.  This contrasts with reloading where even "
"the failing module is left in :data:`sys.modules`."
msgstr ""
"Se o carregamento falhar, o módulo com falha -- e apenas o módulo com falha "
"-- é removido de :data:`sys.modules`. Qualquer módulo já presente no cache "
"de :data:`sys.modules`, e qualquer módulo que tenha sido carregado com "
"sucesso como um efeito colateral, deve permanecer no cache. Isso contrasta "
"com recarregamento, onde mesmo o módulo com falha é mantido em :data:`sys."
"modules`."

#: ../../reference/import.rst:391
msgid ""
"After the module is created but before execution, the import machinery sets "
"the import-related module attributes (\"_init_module_attrs\" in the pseudo-"
"code example above), as summarized in a :ref:`later section <import-mod-"
"attrs>`."
msgstr ""
"Depois que o módulo é criado, mas antes da execução, o mecanismo de "
"importação define os atributos de módulo relacionados a importação "
"(\"_init_module_attrs\" no exemplo de pseudocódigo acima), assim como foi "
"resumido em :ref:`uma seção posterior <import-mod-attrs>`."

#: ../../reference/import.rst:396
msgid ""
"Module execution is the key moment of loading in which the module's "
"namespace gets populated.  Execution is entirely delegated to the loader, "
"which gets to decide what gets populated and how."
msgstr ""
"Execução de módulo é o momento chave do carregamento, no qual o espaço de "
"nomes do módulo é populado.  Execução é inteiramente delegada para o "
"carregador, o qual pode decidir o que será populado e como."

#: ../../reference/import.rst:400
msgid ""
"The module created during loading and passed to exec_module() may not be the "
"one returned at the end of import [#fnlo]_."
msgstr ""
"O módulo criado durante o carregamento e passado para exec_module() pode não "
"ser aquele retornado ao final da importação [#fnlo]_."

#: ../../reference/import.rst:403
msgid ""
"The import system has taken over the boilerplate responsibilities of "
"loaders.  These were previously performed by the :meth:`importlib.abc.Loader."
"load_module` method."
msgstr ""
"O sistema de importação tem tomado conta das responsabilidades inerentes dos "
"carregadores. Essas responsabilidades eram anteriormente executadas pelo "
"método :meth:`importlib.abc.Loader.load_module`."

#: ../../reference/import.rst:409
msgid "Loaders"
msgstr "Carregadores"

#: ../../reference/import.rst:411
msgid ""
"Module loaders provide the critical function of loading: module execution. "
"The import machinery calls the :meth:`importlib.abc.Loader.exec_module` "
"method with a single argument, the module object to execute.  Any value "
"returned from :meth:`~importlib.abc.Loader.exec_module` is ignored."
msgstr ""
"Os carregadores de módulo fornecem a função crítica de carregamento: "
"execução do módulo. O mecanismo de importação chama o método :meth:"
"`importlib.abc.Loader.exec_module` com um único argumento, o objeto do "
"módulo a ser executado. Qualquer valor retornado de :meth:`~importlib.abc."
"Loader.exec_module` é ignorado."

#: ../../reference/import.rst:416
msgid "Loaders must satisfy the following requirements:"
msgstr "Os carregadores devem atender aos seguintes requisitos:"

#: ../../reference/import.rst:418
msgid ""
"If the module is a Python module (as opposed to a built-in module or a "
"dynamically loaded extension), the loader should execute the module's code "
"in the module's global name space (``module.__dict__``)."
msgstr ""
"Se o módulo for um módulo Python (em oposição a um módulo embutido ou uma "
"extensão carregada dinamicamente), o carregador deve executar o código do "
"módulo no espaço de nomes global do módulo (``module.__dict__``)."

#: ../../reference/import.rst:422
msgid ""
"If the loader cannot execute the module, it should raise an :exc:"
"`ImportError`, although any other exception raised during :meth:`~importlib."
"abc.Loader.exec_module` will be propagated."
msgstr ""
"Se o carregador não puder executar o módulo, ele deve levantar uma execção :"
"exc:`ImportError`, embora qualquer outra exceção levantada durante :meth:"
"`~importlib.abc.Loader.exec_module` será propagada."

#: ../../reference/import.rst:426
msgid ""
"In many cases, the finder and loader can be the same object; in such cases "
"the :meth:`~importlib.abc.MetaPathFinder.find_spec` method would just return "
"a spec with the loader set to ``self``."
msgstr ""
"Em muitos casos, o localizador e o carregador podem ser o mesmo objeto; "
"nesses casos o método :meth:`~importlib.abc.MetaPathFinder.find_spec` apenas "
"retornaria um spec com o carregador definido como ``self``."

#: ../../reference/import.rst:430
msgid ""
"Module loaders may opt in to creating the module object during loading by "
"implementing a :meth:`~importlib.abc.Loader.create_module` method. It takes "
"one argument, the module spec, and returns the new module object to use "
"during loading.  ``create_module()`` does not need to set any attributes on "
"the module object.  If the method returns ``None``, the import machinery "
"will create the new module itself."
msgstr ""
"Os carregadores de módulo podem optar por criar o objeto do módulo durante o "
"carregamento, implementando um método :meth:`~importlib.abc.Loader."
"create_module`. Leva um argumento, o spec de módulo e retorna o novo objeto "
"do módulo para usar durante o carregamento. ``create_module()`` não precisa "
"definir nenhum atributo no objeto do módulo. Se o método retornar ``None``, "
"o mecanismo de importação criará ele mesmo o novo módulo."

#: ../../reference/import.rst:437
msgid "The :meth:`~importlib.abc.Loader.create_module` method of loaders."
msgstr "O método :meth:`~importlib.abc.Loader.create_module` de carregadores."

#: ../../reference/import.rst:440
msgid ""
"The :meth:`~importlib.abc.Loader.load_module` method was replaced by :meth:"
"`~importlib.abc.Loader.exec_module` and the import machinery assumed all the "
"boilerplate responsibilities of loading."
msgstr ""
"O método :meth:`~importlib.abc.Loader.load_module` foi substituído por :meth:"
"`~importlib.abc.Loader.exec_module` e o mecanismo de importação assumiu "
"todas as responsabilidades inerentes de carregamento."

#: ../../reference/import.rst:445
msgid ""
"For compatibility with existing loaders, the import machinery will use the "
"``load_module()`` method of loaders if it exists and the loader does not "
"also implement ``exec_module()``.  However, ``load_module()`` has been "
"deprecated and loaders should implement ``exec_module()`` instead."
msgstr ""
"Para compatibilidade com carregadores existentes, o mecanismo de importação "
"usará o método ``load_module()`` de carregadores se ele existir e o "
"carregador também não implementar ``exec_module()``. No entanto, "
"``load_module()`` foi descontinuado e os carregadores devem implementar "
"``exec_module()`` em seu lugar."

#: ../../reference/import.rst:450
msgid ""
"The ``load_module()`` method must implement all the boilerplate loading "
"functionality described above in addition to executing the module.  All the "
"same constraints apply, with some additional clarification:"
msgstr ""
"O método ``load_module()`` deve implementar toda a funcionalidade inerente "
"de carregamento descrita acima, além de executar o módulo. Todas as mesmas "
"restrições se aplicam, com alguns esclarecimentos adicionais:"

#: ../../reference/import.rst:454
msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, the loader must use that existing module. (Otherwise, :func:"
"`importlib.reload` will not work correctly.)  If the named module does not "
"exist in :data:`sys.modules`, the loader must create a new module object and "
"add it to :data:`sys.modules`."
msgstr ""
"Se houver um objeto de módulo existente com o nome fornecido em :data:`sys."
"modules`, o carregador deverá usar esse módulo existente. (Caso contrário, :"
"func:`importlib.reload` não funcionará corretamente.) Se o módulo nomeado "
"não existir em :data:`sys.modules`, o carregador deverá criar um novo objeto "
"de módulo e adicioná-lo a :data:`sys.modules`."

#: ../../reference/import.rst:460
msgid ""
"The module *must* exist in :data:`sys.modules` before the loader executes "
"the module code, to prevent unbounded recursion or multiple loading."
msgstr ""
"O módulo *deve* existir em :data:`sys.modules` antes que o carregador "
"execute o código do módulo, para evitar recursão ilimitada ou carregamento "
"múltiplo."

#: ../../reference/import.rst:464
msgid ""
"If loading fails, the loader must remove any modules it has inserted into :"
"data:`sys.modules`, but it must remove **only** the failing module(s), and "
"only if the loader itself has loaded the module(s) explicitly."
msgstr ""
"Se o carregamento falhar, o carregador deverá remover quaisquer módulos "
"inseridos em :data:`sys.modules`, mas deverá remover **apenas** o(s) "
"módulo(s) com falha, e somente se o próprio carregador tiver carregado o(s) "
"módulo(s) explicitamente."

#: ../../reference/import.rst:469
msgid ""
"A :exc:`DeprecationWarning` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"Uma exceção :exc:`DeprecationWarning` é levantada quando ``exec_module()`` "
"está definido, mas ``create_module()`` não."

#: ../../reference/import.rst:473
msgid ""
"An :exc:`ImportError` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"Uma exceção :exc:`ImportError` é levantada quando ``exec_module()`` está "
"definido, mas ``create_module()`` não."

#: ../../reference/import.rst:477
msgid "Use of ``load_module()`` will raise :exc:`ImportWarning`."
msgstr "O uso de ``load_module()`` vai levantar :exc:`ImportWarning`."

#: ../../reference/import.rst:481
msgid "Submodules"
msgstr "Submódulos"

#: ../../reference/import.rst:483
msgid ""
"When a submodule is loaded using any mechanism (e.g. ``importlib`` APIs, the "
"``import`` or ``import-from`` statements, or built-in ``__import__()``) a "
"binding is placed in the parent module's namespace to the submodule object. "
"For example, if package ``spam`` has a submodule ``foo``, after importing "
"``spam.foo``, ``spam`` will have an attribute ``foo`` which is bound to the "
"submodule.  Let's say you have the following directory structure::"
msgstr ""
"Quando um submódulo é carregado usando qualquer mecanismo (por exemplo, APIs "
"``importlib``, as instruções ``import`` ou ``import-from``, ou a função "
"``__import__()`` embutida) uma ligação é colocada no espaço de nomes do "
"módulo pai para o objeto submódulo. Por exemplo, se o pacote ``spam`` tiver "
"um submódulo ``foo``, após importar ``spam.foo``, ``spam`` terá um atributo "
"``foo`` que está vinculado ao submódulo. Digamos que você tenha a seguinte "
"estrutura de diretórios::"

#: ../../reference/import.rst:494
msgid "and ``spam/__init__.py`` has the following line in it::"
msgstr "e ``spam/__init__.py`` tem a seguinte linha::"

#: ../../reference/import.rst:498
msgid ""
"then executing the following puts name bindings for ``foo`` and ``Foo`` in "
"the ``spam`` module::"
msgstr ""
"então executar o seguinte coloca ligações de nome para ``foo`` e ``Foo`` no "
"módulo ``spam``::"

#: ../../reference/import.rst:507
msgid ""
"Given Python's familiar name binding rules this might seem surprising, but "
"it's actually a fundamental feature of the import system.  The invariant "
"holding is that if you have ``sys.modules['spam']`` and ``sys.modules['spam."
"foo']`` (as you would after the above import), the latter must appear as the "
"``foo`` attribute of the former."
msgstr ""
"Dadas as conhecidas regras de ligação de nomes do Python, isso pode parecer "
"surpreendente, mas na verdade é um recurso fundamental do sistema de "
"importação. A propriedade invariante é que se você tiver ``sys."
"modules['spam']`` e ``sys.modules['spam.foo']`` (como faria após a "
"importação acima), o último deve aparecer como o atributo ``foo`` do "
"primeiro."

#: ../../reference/import.rst:514
msgid "Module spec"
msgstr "Especificação do módulo"

#: ../../reference/import.rst:516
msgid ""
"The import machinery uses a variety of information about each module during "
"import, especially before loading.  Most of the information is common to all "
"modules.  The purpose of a module's spec is to encapsulate this import-"
"related information on a per-module basis."
msgstr ""
"O mecanismo de importação utiliza diversas informações sobre cada módulo "
"durante a importação, principalmente antes do carregamento. A maior parte "
"das informações é comum a todos os módulos. O propósito da spec do módulo é "
"encapsular essas informações relacionadas à importação por módulo."

#: ../../reference/import.rst:521
msgid ""
"Using a spec during import allows state to be transferred between import "
"system components, e.g. between the finder that creates the module spec and "
"the loader that executes it.  Most importantly, it allows the import "
"machinery to perform the boilerplate operations of loading, whereas without "
"a module spec the loader had that responsibility."
msgstr ""
"Usar um spec durante a importação permite que o estado seja transferido "
"entre componentes do sistema de importação, por exemplo entre o localizador "
"que cria o spec de módulo e o carregador que o executa. Mais importante "
"ainda, permite que o mecanismo de importação execute as operações inerentes "
"de carregamento, enquanto que sem um spec de módulo o carregador tinha essa "
"responsabilidade."

#: ../../reference/import.rst:527
msgid ""
"The module's spec is exposed as the ``__spec__`` attribute on a module "
"object. See :class:`~importlib.machinery.ModuleSpec` for details on the "
"contents of the module spec."
msgstr ""
"A especificação do módulo é exposta como o atributo ``__spec__`` em um "
"objeto módulo. Veja :class:`~importlib.machinery.ModuleSpec` para detalhes "
"sobre o conteúdo da especificação do módulo."

#: ../../reference/import.rst:536
msgid "Import-related module attributes"
msgstr "Atributos de módulo relacionados à importação"

#: ../../reference/import.rst:538
msgid ""
"The import machinery fills in these attributes on each module object during "
"loading, based on the module's spec, before the loader executes the module."
msgstr ""
"O mecanismo de importação preenche esses atributos em cada objeto do módulo "
"durante o carregamento, com base na especificação do módulo, antes que o "
"carregador execute o módulo."

#: ../../reference/import.rst:544
msgid ""
"The ``__name__`` attribute must be set to the fully qualified name of the "
"module.  This name is used to uniquely identify the module in the import "
"system."
msgstr ""
"O atributo ``__name__`` deve ser definido como o nome totalmente qualificado "
"do módulo. Este nome é usado para identificar exclusivamente o módulo no "
"sistema de importação."

#: ../../reference/import.rst:550
msgid ""
"The ``__loader__`` attribute must be set to the loader object that the "
"import machinery used when loading the module.  This is mostly for "
"introspection, but can be used for additional loader-specific functionality, "
"for example getting data associated with a loader."
msgstr ""
"O atributo ``__loader__`` deve ser definido para o objeto carregador que o "
"mecanismo de importação usou ao carregar o módulo. Isto é principalmente "
"para introspecção, mas pode ser usado para funcionalidades adicionais "
"específicas do carregador, por exemplo, obter dados associados a um "
"carregador."

#: ../../reference/import.rst:557
msgid ""
"The module's ``__package__`` attribute must be set.  Its value must be a "
"string, but it can be the same value as its ``__name__``.  When the module "
"is a package, its ``__package__`` value should be set to its ``__name__``.  "
"When the module is not a package, ``__package__`` should be set to the empty "
"string for top-level modules, or for submodules, to the parent package's "
"name.  See :pep:`366` for further details."
msgstr ""

#: ../../reference/import.rst:565
msgid ""
"This attribute is used instead of ``__name__`` to calculate explicit "
"relative imports for main modules, as defined in :pep:`366`. It is expected "
"to have the same value as ``__spec__.parent``."
msgstr ""

#: ../../reference/import.rst:569
msgid ""
"The value of ``__package__`` is expected to be the same as ``__spec__."
"parent``."
msgstr ""
"Espera-se que o valor de ``__package__`` seja o mesmo que ``__spec__."
"parent``."

#: ../../reference/import.rst:575
msgid ""
"The ``__spec__`` attribute must be set to the module spec that was used when "
"importing the module. Setting ``__spec__`` appropriately applies equally to :"
"ref:`modules initialized during interpreter startup <programs>`.  The one "
"exception is ``__main__``, where ``__spec__`` is :ref:`set to None in some "
"cases <main_spec>`."
msgstr ""
"O atributo ``__spec__`` deve ser definido para a especificação do módulo que "
"foi usada ao importar o módulo. Definir ``__spec__`` apropriadamente se "
"aplica igualmente a :ref:`módulos inicializados durante a inicialização do "
"interpretador <programs>`. A única exceção é ``__main__``, onde ``__spec__`` "
"é :ref:`definido como None em alguns casos <main_spec>`."

#: ../../reference/import.rst:581
msgid ""
"When ``__package__`` is not defined, ``__spec__.parent`` is used as a "
"fallback."
msgstr ""

#: ../../reference/import.rst:586
msgid ""
"``__spec__.parent`` is used as a fallback when ``__package__`` is not "
"defined."
msgstr ""
"``__spec__.parent`` é usado como uma alternativa quando ``__package__`` não "
"está definido."

#: ../../reference/import.rst:592
msgid ""
"If the module is a package (either regular or namespace), the module "
"object's ``__path__`` attribute must be set.  The value must be iterable, "
"but may be empty if ``__path__`` has no further significance. If "
"``__path__`` is not empty, it must produce strings when iterated over. More "
"details on the semantics of ``__path__`` are given :ref:`below <package-path-"
"rules>`."
msgstr ""
"Se o módulo for um pacote (normal ou espaço de nomes), o atributo "
"``__path__`` do objeto do módulo deve ser definido. O valor deve ser "
"iterável, mas pode estar vazio se ``__path__`` não tiver mais significado. "
"Se ``__path__`` não estiver vazio, ele deverá produzir strings quando "
"iterado. Mais detalhes sobre a semântica de ``__path__`` são fornecidos :ref:"
"`abaixo <package-path-rules>`."

#: ../../reference/import.rst:599
msgid "Non-package modules should not have a ``__path__`` attribute."
msgstr "Módulos que não são de pacote não devem ter um atributo ``__path__``."

#: ../../reference/import.rst:604
msgid ""
"``__file__`` is optional (if set, value must be a string). It indicates the "
"pathname of the file from which the module was loaded (if loaded from a "
"file), or the pathname of the shared library file for extension modules "
"loaded dynamically from a shared library. It might be missing for certain "
"types of modules, such as C modules that are statically linked into the "
"interpreter, and the import system may opt to leave it unset if it has no "
"semantic meaning (e.g. a module loaded from a database)."
msgstr ""
"``__file__`` é opcional (se definido, o valor deve ser uma string). Indica o "
"nome do caminho do arquivo do qual o módulo foi carregado (se carregado de "
"um arquivo) ou o nome do caminho do arquivo da biblioteca compartilhada para "
"módulos de extensão carregados dinamicamente de uma biblioteca "
"compartilhada. Pode estar faltando para certos tipos de módulos, como "
"módulos C que estão estaticamente vinculados ao interpretador, e o sistema "
"de importação pode optar por deixá-lo sem definição se não tiver significado "
"semântico (por exemplo, um módulo carregado de um banco de dados)."

#: ../../reference/import.rst:613
msgid ""
"If ``__file__`` is set then the ``__cached__`` attribute might also be set,  "
"which is the path to any compiled version of the code (e.g. byte-compiled "
"file). The file does not need to exist to set this attribute; the path can "
"simply point to where the compiled file would exist (see :pep:`3147`)."
msgstr ""
"Se ``__file__`` estiver definido então o atributo ``__cached__`` também pode "
"ser definido, que é o caminho para qualquer versão compilada do código (por "
"exemplo, arquivo compilado por byte). O arquivo não precisa existir para "
"configurar esse atributo; o caminho pode simplesmente apontar para onde o "
"arquivo compilado existiria (veja :pep:`3147`)."

#: ../../reference/import.rst:619
msgid ""
"Note that ``__cached__`` may be set even if ``__file__`` is not set.  "
"However, that scenario is quite atypical.  Ultimately, the loader is what "
"makes use of the module spec provided by the finder (from which ``__file__`` "
"and ``__cached__`` are derived).  So if a loader can load from a cached "
"module but otherwise does not load from a file, that atypical scenario may "
"be appropriate."
msgstr ""
"Observe que ``__cached__`` pode ser definido mesmo se ``__file__`` não "
"estiver definido. No entanto, esse cenário é bastante atípico. Em última "
"análise, o carregador é o que faz uso da especificação do módulo fornecida "
"pelo localizador (do qual ``__file__`` e ``__cached__`` são derivados). "
"Portanto, se um carregador puder carregar a partir de um módulo em cache, "
"mas não carregar a partir de um arquivo, esse cenário atípico poderá ser "
"apropriado."

#: ../../reference/import.rst:629
msgid "module.__path__"
msgstr "module.__path__"

#: ../../reference/import.rst:631
msgid ""
"By definition, if a module has a ``__path__`` attribute, it is a package."
msgstr ""
"Por definição, se um módulo possui um atributo ``__path__``, ele é um pacote."

#: ../../reference/import.rst:633
msgid ""
"A package's ``__path__`` attribute is used during imports of its "
"subpackages. Within the import machinery, it functions much the same as :"
"data:`sys.path`, i.e. providing a list of locations to search for modules "
"during import. However, ``__path__`` is typically much more constrained "
"than :data:`sys.path`."
msgstr ""
"O atributo ``__path__`` de um pacote é usado durante as importações de seus "
"subpacotes. Dentro do mecanismo de importação, funciona da mesma forma que :"
"data:`sys.path`, ou seja, fornecendo uma lista de locais para procurar "
"módulos durante a importação. Entretanto, ``__path__`` normalmente é muito "
"mais restrito que :data:`sys.path`."

#: ../../reference/import.rst:639
msgid ""
"``__path__`` must be an iterable of strings, but it may be empty. The same "
"rules used for :data:`sys.path` also apply to a package's ``__path__``, and :"
"data:`sys.path_hooks` (described below) are consulted when traversing a "
"package's ``__path__``."
msgstr ""
"``__path__`` deve ser um iterável de strings, mas pode estar vazio. As "
"mesmas regras usadas para :data:`sys.path` também se aplicam ao ``__path__`` "
"de um pacote, e :data:`sys.path_hooks` (descrito abaixo) são consultados ao "
"percorrer o ``__path__`` de um pacote."

#: ../../reference/import.rst:644
msgid ""
"A package's ``__init__.py`` file may set or alter the package's ``__path__`` "
"attribute, and this was typically the way namespace packages were "
"implemented prior to :pep:`420`.  With the adoption of :pep:`420`, namespace "
"packages no longer need to supply ``__init__.py`` files containing only "
"``__path__`` manipulation code; the import machinery automatically sets "
"``__path__`` correctly for the namespace package."
msgstr ""
"O arquivo ``__init__.py`` de um pacote pode definir ou alterar o atributo "
"``__path__`` do pacote, e esta era tipicamente a forma como os pacotes de "
"espaço de nomes eram implementados antes de :pep:`420`. Com a adoção da :pep:"
"`420`, os pacotes de espaço de nomes não precisam mais fornecer arquivos "
"``__init__.py`` contendo apenas código de manipulação de ``__path__``; o "
"mecanismo de importação define automaticamente ``__path__`` corretamente "
"para o pacote de espaço de nomes."

#: ../../reference/import.rst:652
msgid "Module reprs"
msgstr "Representações do módulo"

#: ../../reference/import.rst:654
msgid ""
"By default, all modules have a usable repr, however depending on the "
"attributes set above, and in the module's spec, you can more explicitly "
"control the repr of module objects."
msgstr ""
"Por padrão, todos os módulos têm uma representação (repr) utilizável, no "
"entanto, dependendo dos atributos definidos acima e do spec do módulo, você "
"pode controlar mais explicitamente a representação dos objetos módulo."

#: ../../reference/import.rst:658
msgid ""
"If the module has a spec (``__spec__``), the import machinery will try to "
"generate a repr from it.  If that fails or there is no spec, the import "
"system will craft a default repr using whatever information is available on "
"the module.  It will try to use the ``module.__name__``, ``module."
"__file__``, and ``module.__loader__`` as input into the repr, with defaults "
"for whatever information is missing."
msgstr ""
"Se o módulo tiver um spec (``__spec__``), o mecanismo de importação tentará "
"gerar uma representação a partir dele. Se isso falhar ou não houver nenhuma "
"especificação, o sistema de importação criará uma representação padrão "
"usando qualquer informação disponível no módulo. Ele tentará usar ``module."
"__name__``, ``module.__file__`` e ``module.__loader__`` como entrada para a "
"representação, com padrões para qualquer informação que esteja faltando."

#: ../../reference/import.rst:665
msgid "Here are the exact rules used:"
msgstr "Arquivo estão as exatas regras usadas:"

#: ../../reference/import.rst:667
msgid ""
"If the module has a ``__spec__`` attribute, the information in the spec is "
"used to generate the repr.  The \"name\", \"loader\", \"origin\", and "
"\"has_location\" attributes are consulted."
msgstr ""
"Se o módulo tiver um atributo ``__spec__``, a informação no spec é usada "
"para gerar a representação. Os atributos \"name\", \"loader\", \"origin\" e "
"\"has_location\" são consultados."

#: ../../reference/import.rst:671
msgid ""
"If the module has a ``__file__`` attribute, this is used as part of the "
"module's repr."
msgstr ""
"Se o módulo tiver um atributo ``__file__``, ele será usado como parte da "
"representação do módulo."

#: ../../reference/import.rst:674
msgid ""
"If the module has no ``__file__`` but does have a ``__loader__`` that is not "
"``None``, then the loader's repr is used as part of the module's repr."
msgstr ""
"Se o módulo não tem ``__file__`` mas tem um ``__loader__`` que não seja "
"``None``, então a representação do carregador é usado como parte da "
"representação do módulo."

#: ../../reference/import.rst:677
msgid "Otherwise, just use the module's ``__name__`` in the repr."
msgstr "Caso contrário, basta usar o ``__name__`` do módulo na representação."

#: ../../reference/import.rst:679
msgid ""
"Use of :meth:`loader.module_repr() <importlib.abc.Loader.module_repr>` has "
"been deprecated and the module spec is now used by the import machinery to "
"generate a module repr."
msgstr ""

#: ../../reference/import.rst:684
msgid ""
"For backward compatibility with Python 3.3, the module repr will be "
"generated by calling the loader's :meth:`~importlib.abc.Loader.module_repr` "
"method, if defined, before trying either approach described above.  However, "
"the method is deprecated."
msgstr ""

#: ../../reference/import.rst:691
msgid ""
"Calling :meth:`~importlib.abc.Loader.module_repr` now occurs after trying to "
"use a module's ``__spec__`` attribute but before falling back on "
"``__file__``. Use of :meth:`~importlib.abc.Loader.module_repr` is slated to "
"stop in Python 3.12."
msgstr ""

#: ../../reference/import.rst:699
msgid "Cached bytecode invalidation"
msgstr "Invalidação de bytecode em cache"

#: ../../reference/import.rst:701
msgid ""
"Before Python loads cached bytecode from a ``.pyc`` file, it checks whether "
"the cache is up-to-date with the source ``.py`` file. By default, Python "
"does this by storing the source's last-modified timestamp and size in the "
"cache file when writing it. At runtime, the import system then validates the "
"cache file by checking the stored metadata in the cache file against the "
"source's metadata."
msgstr ""
"Antes do Python carregar o bytecode armazenado em cache de um arquivo ``."
"pyc``, ele verifica se o cache está atualizado com o arquivo fonte ``.py``. "
"Por padrão, o Python faz isso armazenando o registro de data e hora da "
"última modificação da fonte e o tamanho no arquivo de cache ao escrevê-lo. "
"No tempo de execução, o sistema de importação valida o arquivo de cache "
"verificando os metadados armazenados no arquivo de cache em relação aos "
"metadados do código-fonte."

#: ../../reference/import.rst:708
msgid ""
"Python also supports \"hash-based\" cache files, which store a hash of the "
"source file's contents rather than its metadata. There are two variants of "
"hash-based ``.pyc`` files: checked and unchecked. For checked hash-based ``."
"pyc`` files, Python validates the cache file by hashing the source file and "
"comparing the resulting hash with the hash in the cache file. If a checked "
"hash-based cache file is found to be invalid, Python regenerates it and "
"writes a new checked hash-based cache file. For unchecked hash-based ``."
"pyc`` files, Python simply assumes the cache file is valid if it exists. "
"Hash-based ``.pyc`` files validation behavior may be overridden with the :"
"option:`--check-hash-based-pycs` flag."
msgstr ""
"Python também oferece suporte a arquivos de cache \"baseados em hash\", que "
"armazenam um hash do conteúdo do arquivo fonte em vez de seus metadados. "
"Existem duas variantes de arquivos ``.pyc`` baseados em hash: verificados e "
"não verificados. Para arquivos ``.pyc`` baseados em hash verificados, o "
"Python valida o arquivo de cache fazendo hash do arquivo fonte e comparando "
"o hash resultante com o hash no arquivo de cache. Se um arquivo de cache "
"baseado em hash verificado for inválido, o Python o regenerará e gravará um "
"novo arquivo de cache baseado em hash verificado. Para arquivos ``.pyc`` "
"baseados em hash não verificados, o Python simplesmente presume que o "
"arquivo de cache é válido, se existir. O comportamento de validação de "
"arquivos ``.pyc`` baseados em hash pode ser substituído pelo sinalizador :"
"option:`--check-hash-based-pycs`."

#: ../../reference/import.rst:719
msgid ""
"Added hash-based ``.pyc`` files. Previously, Python only supported timestamp-"
"based invalidation of bytecode caches."
msgstr ""
"Adicionados arquivos ``.pyc`` baseados em hash. Anteriormente, o Python "
"oferecia suporte apenas à invalidação de caches de bytecode baseada em "
"registro de data e hora."

#: ../../reference/import.rst:725
msgid "The Path Based Finder"
msgstr "O localizador baseado no caminho"

#: ../../reference/import.rst:730
msgid ""
"As mentioned previously, Python comes with several default meta path "
"finders. One of these, called the :term:`path based finder` (:class:"
"`~importlib.machinery.PathFinder`), searches an :term:`import path`, which "
"contains a list of :term:`path entries <path entry>`.  Each path entry names "
"a location to search for modules."
msgstr ""
"Conforme mencionado anteriormente, Python vem com vários localizadores de "
"metacaminho padrão. Um deles, chamado :term:`localizador baseado no caminho` "
"(:class:`~importlib.machinery.PathFinder`), pesquisa um :term:`caminho de "
"importação`, que contém uma lista de :term:`entradas de caminho <path "
"entry>`. Cada entrada de caminho nomeia um local para procurar módulos."

#: ../../reference/import.rst:736
msgid ""
"The path based finder itself doesn't know how to import anything. Instead, "
"it traverses the individual path entries, associating each of them with a "
"path entry finder that knows how to handle that particular kind of path."
msgstr ""
"O próprio localizador baseado no caminho não sabe como importar nada. Em vez "
"disso, ele percorre as entradas de caminho individuais, associando cada uma "
"delas a um localizador de entrada de caminho que sabe como lidar com esse "
"tipo específico de caminho."

#: ../../reference/import.rst:740
msgid ""
"The default set of path entry finders implement all the semantics for "
"finding modules on the file system, handling special file types such as "
"Python source code (``.py`` files), Python byte code (``.pyc`` files) and "
"shared libraries (e.g. ``.so`` files). When supported by the :mod:"
"`zipimport` module in the standard library, the default path entry finders "
"also handle loading all of these file types (other than shared libraries) "
"from zipfiles."
msgstr ""
"O conjunto padrão de localizadores de entrada de caminho implementa toda a "
"semântica para localizar módulos no sistema de arquivos, manipulando tipos "
"de arquivos especiais, como código-fonte Python (arquivos ``.py``), código "
"de bytes Python (arquivos ``.pyc``) e bibliotecas compartilhadas (por "
"exemplo, arquivos ``.so``). Quando suportado pelo módulo :mod:`zipimport` na "
"biblioteca padrão, os localizadores de entrada de caminho padrão também "
"lidam com o carregamento de todos esses tipos de arquivos (exceto "
"bibliotecas compartilhadas) de arquivos zip."

#: ../../reference/import.rst:747
msgid ""
"Path entries need not be limited to file system locations.  They can refer "
"to URLs, database queries, or any other location that can be specified as a "
"string."
msgstr ""
"As entradas de caminho não precisam ser limitadas aos locais do sistema de "
"arquivos. Eles podem referir-se a URLs, consultas de banco de dados ou "
"qualquer outro local que possa ser especificado como uma string."

#: ../../reference/import.rst:751
msgid ""
"The path based finder provides additional hooks and protocols so that you "
"can extend and customize the types of searchable path entries.  For example, "
"if you wanted to support path entries as network URLs, you could write a "
"hook that implements HTTP semantics to find modules on the web.  This hook "
"(a callable) would return a :term:`path entry finder` supporting the "
"protocol described below, which was then used to get a loader for the module "
"from the web."
msgstr ""
"O localizador baseado no caminho fornece ganchos e protocolos adicionais "
"para que você possa estender e personalizar os tipos de entradas de caminho "
"pesquisáveis. Por exemplo, se você quiser oferecer suporte a entradas de "
"caminho como URLs de rede, poderá escrever um gancho que implemente a "
"semântica HTTP para localizar módulos na web. Este gancho (um chamável) "
"retornaria um :term:`localizador de entrada de caminho` suportando o "
"protocolo descrito abaixo, que foi então usado para obter um carregador para "
"o módulo da web."

#: ../../reference/import.rst:759
msgid ""
"A word of warning: this section and the previous both use the term *finder*, "
"distinguishing between them by using the terms :term:`meta path finder` and :"
"term:`path entry finder`.  These two types of finders are very similar, "
"support similar protocols, and function in similar ways during the import "
"process, but it's important to keep in mind that they are subtly different. "
"In particular, meta path finders operate at the beginning of the import "
"process, as keyed off the :data:`sys.meta_path` traversal."
msgstr ""
"Uma palavra de advertência: esta seção e a anterior usam o termo "
"*localizador*, distinguindo-os usando os termos :term:`localizador de "
"metacaminho` e :term:`localizador de entrada de caminho`. Esses dois tipos "
"de localizadores são muito semelhantes, oferecem suporte a protocolos "
"semelhantes e funcionam de maneira semelhante durante o processo de "
"importação, mas é importante ter em mente que eles são sutilmente "
"diferentes. Em particular, os localizadores de metacaminho operam no início "
"do processo de importação, conforme a travessia de :data:`sys.meta_path`."

#: ../../reference/import.rst:767
msgid ""
"By contrast, path entry finders are in a sense an implementation detail of "
"the path based finder, and in fact, if the path based finder were to be "
"removed from :data:`sys.meta_path`, none of the path entry finder semantics "
"would be invoked."
msgstr ""
"Por outro lado, os localizadores de entrada de caminho são, em certo "
"sentido, um detalhe de implementação do localizador baseado no caminho e, de "
"fato, se o localizador baseado no caminho fosse removido de :data:`sys."
"meta_path`, nenhuma semântica do localizador de entrada de caminho seria ser "
"invocado."

#: ../../reference/import.rst:774
msgid "Path entry finders"
msgstr "Localizadores de entrada de caminho"

#: ../../reference/import.rst:782
msgid ""
"The :term:`path based finder` is responsible for finding and loading Python "
"modules and packages whose location is specified with a string :term:`path "
"entry`.  Most path entries name locations in the file system, but they need "
"not be limited to this."
msgstr ""
"O :term:`localizador baseado no caminho` é responsável por encontrar e "
"carregar módulos e pacotes Python cuja localização é especificada com uma "
"string :term:`entrada de caminho`. A maioria das entradas de caminho nomeiam "
"locais no sistema de arquivos, mas não precisam ser limitadas a isso."

#: ../../reference/import.rst:787
msgid ""
"As a meta path finder, the :term:`path based finder` implements the :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` protocol previously described, "
"however it exposes additional hooks that can be used to customize how "
"modules are found and loaded from the :term:`import path`."
msgstr ""
"Como um localizador de metacaminho, o :term:`localizador baseado no caminho` "
"implementa o protocolo :meth:`~importlib.abc.MetaPathFinder.find_spec` "
"descrito anteriormente, no entanto, ele expõe ganchos adicionais que podem "
"ser usados para personalizar como os módulos são encontrados e carregado do :"
"term:`caminho de importação`."

#: ../../reference/import.rst:792
msgid ""
"Three variables are used by the :term:`path based finder`, :data:`sys."
"path`, :data:`sys.path_hooks` and :data:`sys.path_importer_cache`.  The "
"``__path__`` attributes on package objects are also used.  These provide "
"additional ways that the import machinery can be customized."
msgstr ""
"Três variáveis são usadas pelo :term:`localizador baseado no caminho`, :data:"
"`sys.path`, :data:`sys.path_hooks` e :data:`sys.path_importer_cache`. Os "
"atributos ``__path__`` em objetos de pacote também são usados. Eles fornecem "
"maneiras adicionais de personalizar o mecanismo de importação."

#: ../../reference/import.rst:797
msgid ""
":data:`sys.path` contains a list of strings providing search locations for "
"modules and packages.  It is initialized from the :envvar:`PYTHONPATH` "
"environment variable and various other installation- and implementation-"
"specific defaults.  Entries in :data:`sys.path` can name directories on the "
"file system, zip files, and potentially other \"locations\" (see the :mod:"
"`site` module) that should be searched for modules, such as URLs, or "
"database queries.  Only strings should be present on :data:`sys.path`; all "
"other data types are ignored."
msgstr ""
":data:`sys.path` contém uma lista de strings fornecendo locais de pesquisa "
"para módulos e pacotes. Ele é inicializado a partir da variável de ambiente :"
"envvar:`PYTHONPATH` e vários outros padrões específicos de instalação e "
"implementação. Entradas em :data:`sys.path` podem nomear diretórios no "
"sistema de arquivos, arquivos zip e potencialmente outros \"locais\" (veja o "
"módulo :mod:`site`) que devem ser pesquisados por módulos, como URLs, ou "
"consultas ao banco de dados. Apenas strings devem estar presentes em :data:"
"`sys.path`; todos os outros tipos de dados são ignorados."

#: ../../reference/import.rst:806
msgid ""
"The :term:`path based finder` is a :term:`meta path finder`, so the import "
"machinery begins the :term:`import path` search by calling the path based "
"finder's :meth:`~importlib.machinery.PathFinder.find_spec` method as "
"described previously.  When the ``path`` argument to :meth:`~importlib."
"machinery.PathFinder.find_spec` is given, it will be a list of string paths "
"to traverse - typically a package's ``__path__`` attribute for an import "
"within that package.  If the ``path`` argument is ``None``, this indicates a "
"top level import and :data:`sys.path` is used."
msgstr ""
"O :term:`localizador baseado no caminho` é um :term:`localizador de "
"metacaminho`, então o mecanismo de importação inicia a pesquisa no :term:"
"`caminho de importação` chamando o método :meth:`~importlib.machinery."
"PathFinder.find_spec` do localizador baseado no caminho conforme descrito "
"anteriormente. Quando o argumento ``path`` para :meth:`~importlib.machinery."
"PathFinder.find_spec` for fornecido, será uma lista de caminhos de string a "
"serem percorridos -- normalmente o atributo ``__path__`` de um pacote para "
"uma importação dentro desse pacote. Se o argumento ``path`` for ``None``, "
"isso indica uma importação de nível superior e :data:`sys.path` é usado."

#: ../../reference/import.rst:815
msgid ""
"The path based finder iterates over every entry in the search path, and for "
"each of these, looks for an appropriate :term:`path entry finder` (:class:"
"`~importlib.abc.PathEntryFinder`) for the path entry.  Because this can be "
"an expensive operation (e.g. there may be ``stat()`` call overheads for this "
"search), the path based finder maintains a cache mapping path entries to "
"path entry finders.  This cache is maintained in :data:`sys."
"path_importer_cache` (despite the name, this cache actually stores finder "
"objects rather than being limited to :term:`importer` objects). In this way, "
"the expensive search for a particular :term:`path entry` location's :term:"
"`path entry finder` need only be done once.  User code is free to remove "
"cache entries from :data:`sys.path_importer_cache` forcing the path based "
"finder to perform the path entry search again [#fnpic]_."
msgstr ""

#: ../../reference/import.rst:828
msgid ""
"If the path entry is not present in the cache, the path based finder "
"iterates over every callable in :data:`sys.path_hooks`.  Each of the :term:"
"`path entry hooks <path entry hook>` in this list is called with a single "
"argument, the path entry to be searched.  This callable may either return a :"
"term:`path entry finder` that can handle the path entry, or it may raise :"
"exc:`ImportError`.  An :exc:`ImportError` is used by the path based finder "
"to signal that the hook cannot find a :term:`path entry finder` for that :"
"term:`path entry`.  The exception is ignored and :term:`import path` "
"iteration continues.  The hook should expect either a string or bytes "
"object; the encoding of bytes objects is up to the hook (e.g. it may be a "
"file system encoding, UTF-8, or something else), and if the hook cannot "
"decode the argument, it should raise :exc:`ImportError`."
msgstr ""
"Se a entrada de caminho não estiver presente no cache, o localizador baseado "
"no caminho itera sobre cada chamável em :data:`sys.path_hooks`. Cada um dos :"
"term:`ganchos de entrada de caminho <path entry hook>` nesta lista é chamado "
"com um único argumento, a entrada de caminho a ser pesquisada. Este chamável "
"pode retornar um :term:`localizador de entrada de caminho` que pode "
"manipular a entrada de caminho ou pode levantar :exc:`ImportError`. Um :exc:"
"`ImportError` é usado pelo localizador baseado no caminho para sinalizar que "
"o gancho não consegue encontrar um :term:`localizador de entrada de caminho` "
"para aquela :term:`entrada de caminho`. A exceção é ignorada e a iteração "
"com o :term:`caminho de importação` continua. O gancho deve esperar um "
"objeto string ou bytes; a codificação de objetos bytes depende do gancho "
"(por exemplo, pode ser uma codificação de sistema de arquivos, UTF-8 ou "
"outra coisa) e, se o gancho não puder decodificar o argumento, ele deve "
"levantar :exc:`ImportError`."

#: ../../reference/import.rst:842
msgid ""
"If :data:`sys.path_hooks` iteration ends with no :term:`path entry finder` "
"being returned, then the path based finder's :meth:`~importlib.machinery."
"PathFinder.find_spec` method will store ``None`` in :data:`sys."
"path_importer_cache` (to indicate that there is no finder for this path "
"entry) and return ``None``, indicating that this :term:`meta path finder` "
"could not find the module."
msgstr ""
"Se a iteração :data:`sys.path_hooks` terminar sem que nenhum :term:"
"`localizador de entrada de caminho` seja retornado, o método :meth:"
"`~importlib.machinery.PathFinder.find_spec` do localizador baseado no "
"caminho armazenará ``None`` em :data:`sys.path_importer_cache` (para indicar "
"que não há um localizador para esta entrada de caminho) e retornará "
"``None``, indicando que este :term:`localizador de metacaminho` não "
"conseguiu encontrar o módulo."

#: ../../reference/import.rst:849
msgid ""
"If a :term:`path entry finder` *is* returned by one of the :term:`path entry "
"hook` callables on :data:`sys.path_hooks`, then the following protocol is "
"used to ask the finder for a module spec, which is then used when loading "
"the module."
msgstr ""
"Se um :term:`localizador de entrada de caminho` *for* retornado por um dos "
"chamáveis de :term:`gancho de entrada de caminho` ​em :data:`sys.path_hooks`, "
"então o seguinte protocolo é usado para solicitar ao localizador um spec de "
"módulo, que é então usada ao carregar o módulo."

#: ../../reference/import.rst:854
msgid ""
"The current working directory -- denoted by an empty string -- is handled "
"slightly differently from other entries on :data:`sys.path`. First, if the "
"current working directory is found to not exist, no value is stored in :data:"
"`sys.path_importer_cache`. Second, the value for the current working "
"directory is looked up fresh for each module lookup. Third, the path used "
"for :data:`sys.path_importer_cache` and returned by :meth:`importlib."
"machinery.PathFinder.find_spec` will be the actual current working directory "
"and not the empty string."
msgstr ""
"O diretório de trabalho atual -- denotado por uma string vazia -- é tratado "
"de forma ligeiramente diferente de outras entradas em :data:`sys.path`. "
"Primeiro, se o diretório de trabalho atual for considerado inexistente, "
"nenhum valor será armazenado em :data:`sys.path_importer_cache`. Segundo, o "
"valor para o diretório de trabalho atual é pesquisado novamente para cada "
"pesquisa de módulo. Terceiro, o caminho usado para :data:`sys."
"path_importer_cache` e retornado por :meth:`importlib.machinery.PathFinder."
"find_spec` será o diretório de trabalho atual real e não a string vazia."

#: ../../reference/import.rst:864
msgid "Path entry finder protocol"
msgstr "Protocolo do localizador de entrada de caminho"

#: ../../reference/import.rst:866
msgid ""
"In order to support imports of modules and initialized packages and also to "
"contribute portions to namespace packages, path entry finders must implement "
"the :meth:`~importlib.abc.PathEntryFinder.find_spec` method."
msgstr ""
"Para dar suporte a importações de módulos e pacotes inicializados e também "
"contribuir com partes para pacotes de espaço de nomes, os localizadores de "
"entrada de caminho devem implementar o método :meth:`~importlib.abc."
"PathEntryFinder.find_spec`."

#: ../../reference/import.rst:870
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` takes two arguments: the "
"fully qualified name of the module being imported, and the (optional) target "
"module.  ``find_spec()`` returns a fully populated spec for the module. This "
"spec will always have \"loader\" set (with one exception)."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` recebe dois argumentos: o "
"nome totalmente qualificado do módulo que está sendo importado e o módulo de "
"destino (opcional). ``find_spec()`` retorna um spec totalmente preenchido "
"para o módulo. Este spec sempre terá \"loader\" definido (com uma exceção)."

#: ../../reference/import.rst:875
msgid ""
"To indicate to the import machinery that the spec represents a namespace :"
"term:`portion`, the path entry finder sets \"submodule_search_locations\" to "
"a list containing the portion."
msgstr ""

#: ../../reference/import.rst:879
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` replaced :meth:`~importlib."
"abc.PathEntryFinder.find_loader` and :meth:`~importlib.abc.PathEntryFinder."
"find_module`, both of which are now deprecated, but will be used if "
"``find_spec()`` is not defined."
msgstr ""

#: ../../reference/import.rst:885
msgid ""
"Older path entry finders may implement one of these two deprecated methods "
"instead of ``find_spec()``.  The methods are still respected for the sake of "
"backward compatibility.  However, if ``find_spec()`` is implemented on the "
"path entry finder, the legacy methods are ignored."
msgstr ""
"Os localizadores de entrada de caminho mais antigos podem implementar um "
"desses dois métodos descontinuados em vez de ``find_spec()``. Os métodos "
"ainda são respeitados para fins de compatibilidade com versões anteriores. "
"No entanto, se ``find_spec()`` for implementado no localizador de entrada de "
"caminho, os métodos legados serão ignorados."

#: ../../reference/import.rst:890
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_loader` takes one argument, the "
"fully qualified name of the module being imported.  ``find_loader()`` "
"returns a 2-tuple where the first item is the loader and the second item is "
"a namespace :term:`portion`."
msgstr ""

#: ../../reference/import.rst:895
msgid ""
"For backwards compatibility with other implementations of the import "
"protocol, many path entry finders also support the same, traditional "
"``find_module()`` method that meta path finders support. However path entry "
"finder ``find_module()`` methods are never called with a ``path`` argument "
"(they are expected to record the appropriate path information from the "
"initial call to the path hook)."
msgstr ""
"Para compatibilidade com versões anteriores de outras implementações do "
"protocolo de importação, muitos localizadores de entrada de caminho também "
"dão suporte ao mesmo método tradicional ``find_module()`` que os "
"localizadores de metacaminho. No entanto, os métodos ``find_module()`` do "
"localizador de entrada de caminho nunca são chamados com um argumento "
"``path`` (espera-se que eles registrem as informações de caminho apropriadas "
"da chamada inicial para o gancho de caminho)."

#: ../../reference/import.rst:902
msgid ""
"The ``find_module()`` method on path entry finders is deprecated, as it does "
"not allow the path entry finder to contribute portions to namespace "
"packages.  If both ``find_loader()`` and ``find_module()`` exist on a path "
"entry finder, the import system will always call ``find_loader()`` in "
"preference to ``find_module()``."
msgstr ""
"O método ``find_module()`` em localizadores de entrada de caminho foi "
"descontinuado, pois não permite que o localizador de entrada de caminho "
"contribua com porções para pacotes de espaço de nomes. Se ``find_loader()`` "
"e ``find_module()`` existirem em um localizador de entrada de caminho, o "
"sistema de importação sempre chamará ``find_loader()`` em preferência a "
"``find_module()``."

#: ../../reference/import.rst:908
msgid ""
"Calls to :meth:`~importlib.abc.PathEntryFinder.find_module` and :meth:"
"`~importlib.abc.PathEntryFinder.find_loader` by the import system will "
"raise :exc:`ImportWarning`."
msgstr ""

#: ../../reference/import.rst:915
msgid "Replacing the standard import system"
msgstr "Substituindo o sistema de importação padrão"

#: ../../reference/import.rst:917
msgid ""
"The most reliable mechanism for replacing the entire import system is to "
"delete the default contents of :data:`sys.meta_path`, replacing them "
"entirely with a custom meta path hook."
msgstr ""
"O mecanismo mais confiável para substituir todo o sistema de importação é "
"excluir o conteúdo padrão de :data:`sys.meta_path`, substituindo-o "
"inteiramente por um gancho de metacaminho personalizado."

#: ../../reference/import.rst:921
msgid ""
"If it is acceptable to only alter the behaviour of import statements without "
"affecting other APIs that access the import system, then replacing the "
"builtin :func:`__import__` function may be sufficient. This technique may "
"also be employed at the module level to only alter the behaviour of import "
"statements within that module."
msgstr ""
"Se for aceitável alterar apenas o comportamento de instruções de importação "
"sem afetar outras APIs que acessam o sistema de importação, então substituir "
"a função embutida :func:`__import__` pode ser suficiente. Essa técnica "
"também pode ser empregada no nível do módulo para alterar apenas o "
"comportamento de instruções de importação dentro desse módulo."

#: ../../reference/import.rst:927
msgid ""
"To selectively prevent the import of some modules from a hook early on the "
"meta path (rather than disabling the standard import system entirely), it is "
"sufficient to raise :exc:`ModuleNotFoundError` directly from :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` instead of returning ``None``. The "
"latter indicates that the meta path search should continue, while raising an "
"exception terminates it immediately."
msgstr ""
"Para impedir seletivamente a importação de alguns módulos de um gancho no "
"início do metacaminho (em vez de desabilitar o sistema de importação padrão "
"completamente), é suficiente levantar :exc:`ModuleNotFoundError` diretamente "
"de :meth:`~importlib.abc.MetaPathFinder.find_spec` em vez de retornar "
"``None``. O último indica que a busca do metacaminho deve continuar, "
"enquanto levantar uma exceção a encerra imediatamente."

#: ../../reference/import.rst:937
msgid "Package Relative Imports"
msgstr "Importações relativas ao pacote"

#: ../../reference/import.rst:939
msgid ""
"Relative imports use leading dots. A single leading dot indicates a relative "
"import, starting with the current package. Two or more leading dots indicate "
"a relative import to the parent(s) of the current package, one level per dot "
"after the first. For example, given the following package layout::"
msgstr ""
"Importações relativas usam caracteres de ponto no início. Um único ponto no "
"início indica uma importação relativa, começando com o pacote atual. Dois ou "
"mais pontos no início indicam uma importação relativa para o(s) pai(s) do "
"pacote atual, um nível por ponto após o primeiro. Por exemplo, dado o "
"seguinte layout de pacote::"

#: ../../reference/import.rst:955
msgid ""
"In either ``subpackage1/moduleX.py`` or ``subpackage1/__init__.py``, the "
"following are valid relative imports::"
msgstr ""
"Em ``subpackage1/moduleX.py`` ou ``subpackage1/__init__.py``, as seguintes "
"são importações relativas válidas:"

#: ../../reference/import.rst:965
msgid ""
"Absolute imports may use either the ``import <>`` or ``from <> import <>`` "
"syntax, but relative imports may only use the second form; the reason for "
"this is that::"
msgstr ""
"Importações absolutas podem usar a sintaxe ``import <>`` ou ``from <> import "
"<>``, mas importações relativas podem usar apenas a segunda forma; o motivo "
"para isso é que:"

#: ../../reference/import.rst:971
msgid ""
"should expose ``XXX.YYY.ZZZ`` as a usable expression, but .moduleY is not a "
"valid expression."
msgstr ""
"deve expor ``XXX.YYY.ZZZ`` como uma expressão utilizável, mas .moduleY não é "
"uma expressão válida."

#: ../../reference/import.rst:978
msgid "Special considerations for __main__"
msgstr "Considerações especiais para __main__"

#: ../../reference/import.rst:980
msgid ""
"The :mod:`__main__` module is a special case relative to Python's import "
"system.  As noted :ref:`elsewhere <programs>`, the ``__main__`` module is "
"directly initialized at interpreter startup, much like :mod:`sys` and :mod:"
"`builtins`.  However, unlike those two, it doesn't strictly qualify as a "
"built-in module.  This is because the manner in which ``__main__`` is "
"initialized depends on the flags and other options with which the "
"interpreter is invoked."
msgstr ""
"O módulo :mod:`__main__` é um caso especial em relação ao sistema de "
"importação do Python. Conforme observado em :ref:`em outro lugar "
"<programs>`, o módulo ``__main__`` é inicializado diretamente na "
"inicialização do interpretador, muito parecido com :mod:`sys` e :mod:"
"`builtins`. No entanto, diferentemente desses dois, ele não se qualifica "
"estritamente como um módulo integrado. Isso ocorre porque a maneira como "
"``__main__`` é inicializado depende dos sinalizadores e outras opções com as "
"quais o interpretador é invocado."

#: ../../reference/import.rst:991
msgid "__main__.__spec__"
msgstr "__main__.__spec__"

#: ../../reference/import.rst:993
msgid ""
"Depending on how :mod:`__main__` is initialized, ``__main__.__spec__`` gets "
"set appropriately or to ``None``."
msgstr ""
"Dependendo de como :mod:`__main__` é inicializado, ``__main__.__spec__`` é "
"definido apropriadamente ou como ``None``."

#: ../../reference/import.rst:996
msgid ""
"When Python is started with the :option:`-m` option, ``__spec__`` is set to "
"the module spec of the corresponding module or package. ``__spec__`` is also "
"populated when the ``__main__`` module is loaded as part of executing a "
"directory, zipfile or other :data:`sys.path` entry."
msgstr ""
"Quando o Python é iniciado com a opção :option:`-m`, ``__spec__`` é definido "
"como o spec de módulo ou pacote correspondente. ``__spec__`` também é "
"preenchido quando o módulo ``__main__`` é carregado como parte da execução "
"de um diretório, arquivo zip ou outra entrada :data:`sys.path`."

#: ../../reference/import.rst:1001
msgid ""
"In :ref:`the remaining cases <using-on-interface-options>` ``__main__."
"__spec__`` is set to ``None``, as the code used to populate the :mod:"
"`__main__` does not correspond directly with an importable module:"
msgstr ""
":ref:`Nos demais casos <using-on-interface-options>`, ``__main__.__spec__`` "
"é definido como ``None``, pois o código usado para preencher o :mod:"
"`__main__` não corresponde diretamente a um módulo importável:"

#: ../../reference/import.rst:1005
msgid "interactive prompt"
msgstr "prompt interativo"

#: ../../reference/import.rst:1006
msgid ":option:`-c` option"
msgstr "opção :option:`-c`"

#: ../../reference/import.rst:1007
msgid "running from stdin"
msgstr "executar a partir de stdin"

#: ../../reference/import.rst:1008
msgid "running directly from a source or bytecode file"
msgstr "executar diretamente de um arquivo de código-fonte ou bytecode"

#: ../../reference/import.rst:1010
msgid ""
"Note that ``__main__.__spec__`` is always ``None`` in the last case, *even "
"if* the file could technically be imported directly as a module instead. Use "
"the :option:`-m` switch if valid module metadata is desired in :mod:"
"`__main__`."
msgstr ""
"Note que ``__main__.__spec__`` é sempre ``None`` no último caso, *mesmo se* "
"o arquivo pudesse ser importado diretamente como um módulo. Use a opção :"
"option:`-m` se metadados de módulo válidos forem desejados em :mod:"
"`__main__`."

#: ../../reference/import.rst:1015
msgid ""
"Note also that even when ``__main__`` corresponds with an importable module "
"and ``__main__.__spec__`` is set accordingly, they're still considered "
"*distinct* modules. This is due to the fact that blocks guarded by ``if "
"__name__ == \"__main__\":`` checks only execute when the module is used to "
"populate the ``__main__`` namespace, and not during normal import."
msgstr ""
"Note também que mesmo quando ``__main__`` corresponde a um módulo importável "
"e ``__main__.__spec__`` é definido adequadamente, eles ainda são "
"considerados módulos *distintos*. Isso se deve ao fato de que os blocos "
"protegidos por verificações ``if __name__ == \"__main__\":`` são executados "
"somente quando o módulo é usado para preencher o espaço de nomes "
"``__main__``, e não durante a importação normal."

#: ../../reference/import.rst:1023
msgid "References"
msgstr "Referências"

#: ../../reference/import.rst:1025
msgid ""
"The import machinery has evolved considerably since Python's early days.  "
"The original `specification for packages <https://www.python.org/doc/essays/"
"packages/>`_ is still available to read, although some details have changed "
"since the writing of that document."
msgstr ""
"O maquinário de importação evoluiu consideravelmente desde os primeiros dias "
"do Python. A `especificação original para pacotes <https://www.python.org/"
"doc/essays/packages/>`_ ainda está disponível para leitura, embora alguns "
"detalhes tenham mudado desde a escrita desse documento."

#: ../../reference/import.rst:1030
msgid ""
"The original specification for :data:`sys.meta_path` was :pep:`302`, with "
"subsequent extension in :pep:`420`."
msgstr ""
"A especificação original para :data:`sys.meta_path` era :pep:`302`, com "
"extensão subsequente em :pep:`420`."

#: ../../reference/import.rst:1033
msgid ""
":pep:`420` introduced :term:`namespace packages <namespace package>` for "
"Python 3.3.  :pep:`420` also introduced the :meth:`find_loader` protocol as "
"an alternative to :meth:`find_module`."
msgstr ""

#: ../../reference/import.rst:1037
msgid ""
":pep:`366` describes the addition of the ``__package__`` attribute for "
"explicit relative imports in main modules."
msgstr ""
":pep:`366` descreve a adição do atributo ``__package__`` para importações "
"relativas explícitas em módulos principais."

#: ../../reference/import.rst:1040
msgid ""
":pep:`328` introduced absolute and explicit relative imports and initially "
"proposed ``__name__`` for semantics :pep:`366` would eventually specify for "
"``__package__``."
msgstr ""
":pep:`328` introduziu importações relativas absolutas e explícitas e "
"inicialmente propôs ``__name__`` para semântica. :pep:`366` eventualmente "
"especificaria ``__package__``."

#: ../../reference/import.rst:1044
msgid ":pep:`338` defines executing modules as scripts."
msgstr ":pep:`338` define módulos de execução como scripts."

#: ../../reference/import.rst:1046
msgid ""
":pep:`451` adds the encapsulation of per-module import state in spec "
"objects.  It also off-loads most of the boilerplate responsibilities of "
"loaders back onto the import machinery.  These changes allow the deprecation "
"of several APIs in the import system and also addition of new methods to "
"finders and loaders."
msgstr ""
":pep:`451` adiciona o encapsulamento do estado de importação por módulo em "
"objetos spec. Ele também descarrega a maioria das responsabilidades "
"inerentes dos carregadores de volta para o maquinário de importação. Essas "
"mudanças permitem a descontinuação de várias APIs no sistema de importação e "
"também a adição de novos métodos para localizadores e carregadores."

#: ../../reference/import.rst:1053
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../reference/import.rst:1054
msgid "See :class:`types.ModuleType`."
msgstr "Veja :class:`types.ModuleType`."

#: ../../reference/import.rst:1056
msgid ""
"The importlib implementation avoids using the return value directly. "
"Instead, it gets the module object by looking the module name up in :data:"
"`sys.modules`.  The indirect effect of this is that an imported module may "
"replace itself in :data:`sys.modules`.  This is implementation-specific "
"behavior that is not guaranteed to work in other Python implementations."
msgstr ""
"A implementação de importlib evita usar o valor de retorno diretamente. Em "
"vez disso, ela obtém o objeto do módulo procurando o nome do módulo em :data:"
"`sys.modules`. O efeito indireto disso é que um módulo importado pode "
"substituir a si mesmo em :data:`sys.modules`. Esse é um comportamento "
"específico da implementação que não tem garantia de funcionar em outras "
"implementações do Python."

#: ../../reference/import.rst:1063
msgid ""
"In legacy code, it is possible to find instances of :class:`imp."
"NullImporter` in the :data:`sys.path_importer_cache`.  It is recommended "
"that code be changed to use ``None`` instead.  See :ref:`portingpythoncode` "
"for more details."
msgstr ""

#: ../../reference/import.rst:8
msgid "import machinery"
msgstr "maquinário de importação"

#: ../../reference/import.rst:64 ../../reference/import.rst:95
#: ../../reference/import.rst:129
msgid "package"
msgstr "pacote"

#: ../../reference/import.rst:95
msgid "regular"
msgstr "regular"

#: ../../reference/import.rst:129
msgid "namespace"
msgstr "espaço de nomes"

#: ../../reference/import.rst:129
msgid "portion"
msgstr "porção"

#: ../../reference/import.rst:175
msgid "sys.modules"
msgstr "sys.modules"

#: ../../reference/import.rst:210 ../../reference/import.rst:276
msgid "finder"
msgstr "localizador"

#: ../../reference/import.rst:210
msgid "loader"
msgstr "carregador"

#: ../../reference/import.rst:210
msgid "module spec"
msgstr "módulo spec"

#: ../../reference/import.rst:249
msgid "import hooks"
msgstr "ganchos de importação"

#: ../../reference/import.rst:249
msgid "meta hooks"
msgstr "metaganchos"

#: ../../reference/import.rst:249
msgid "path hooks"
msgstr "ganchos de caminho"

#: ../../reference/import.rst:249
msgid "hooks"
msgstr "ganchos"

#: ../../reference/import.rst:249
msgid "import"
msgstr "import"

#: ../../reference/import.rst:249
msgid "meta"
msgstr "meta"

#: ../../reference/import.rst:249
msgid "path"
msgstr "caminho"

#: ../../reference/import.rst:276
msgid "sys.meta_path"
msgstr "sys.meta_path"

#: ../../reference/import.rst:276
msgid "find_spec"
msgstr "find_spec"

#: ../../reference/import.rst:727
msgid "path based finder"
msgstr "localizador baseado no caminho"

#: ../../reference/import.rst:776
msgid "sys.path"
msgstr "sys.path"

#: ../../reference/import.rst:776
msgid "sys.path_hooks"
msgstr "sys.path_hooks"

#: ../../reference/import.rst:776
msgid "sys.path_importer_cache"
msgstr "sys.path_importer_cache"

#: ../../reference/import.rst:776
msgid "PYTHONPATH"
msgstr "PYTHONPATH"

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../reference/simple_stmts.rst:6
msgid "Simple statements"
msgstr "Instruções simples"

#: ../../reference/simple_stmts.rst:10
msgid ""
"A simple statement is comprised within a single logical line. Several simple "
"statements may occur on a single line separated by semicolons.  The syntax "
"for simple statements is:"
msgstr ""
"Uma instrução simples consiste uma única linha lógica. Várias instruções "
"simples podem ocorrer em uma única linha separada por ponto e vírgula. A "
"sintaxe para instruções simples é:"

#: ../../reference/simple_stmts.rst:37
msgid "Expression statements"
msgstr "Instruções de expressão"

#: ../../reference/simple_stmts.rst:44
msgid ""
"Expression statements are used (mostly interactively) to compute and write a "
"value, or (usually) to call a procedure (a function that returns no "
"meaningful result; in Python, procedures return the value ``None``).  Other "
"uses of expression statements are allowed and occasionally useful.  The "
"syntax for an expression statement is:"
msgstr ""
"As instruções de expressão são usadas (principalmente interativamente) para "
"calcular e escrever um valor, ou (geralmente) para chamar um procedimento "
"(uma função que não retorna nenhum resultado significativo; em Python, os "
"procedimentos retornam o valor ``None``). Outros usos de instruções de "
"expressão são permitidos e ocasionalmente úteis. A sintaxe para uma "
"instrução de expressão é:"

#: ../../reference/simple_stmts.rst:53
msgid ""
"An expression statement evaluates the expression list (which may be a single "
"expression)."
msgstr ""
"Uma instrução de expressão avalia a lista de expressões (que pode ser uma "
"única expressão)."

#: ../../reference/simple_stmts.rst:65
msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string is "
"written to standard output on a line by itself (except if the result is "
"``None``, so that procedure calls do not cause any output.)"
msgstr ""
"No modo interativo, se o valor não for ``None``, ele será convertido em uma "
"string usando a função embutida :func:`repr` e a string resultante será "
"gravada na saída padrão em uma linha sozinha (exceto se o resultado é "
"``None``, de modo que as chamadas de procedimento não causam nenhuma saída.)"

#: ../../reference/simple_stmts.rst:73
msgid "Assignment statements"
msgstr "Instruções de atribuição"

#: ../../reference/simple_stmts.rst:83
msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr ""
"As instruções de atribuição são usadas para (re)vincular nomes a valores e "
"modificar atributos ou itens de objetos mutáveis:"

#: ../../reference/simple_stmts.rst:97
msgid ""
"(See section :ref:`primaries` for the syntax definitions for *attributeref*, "
"*subscription*, and *slicing*.)"
msgstr ""
"(Veja a seção :ref:`primaries` para as definições de sintaxe de "
"*attributeref*, *subscription* e *slicing*.)"

#: ../../reference/simple_stmts.rst:100
msgid ""
"An assignment statement evaluates the expression list (remember that this "
"can be a single expression or a comma-separated list, the latter yielding a "
"tuple) and assigns the single resulting object to each of the target lists, "
"from left to right."
msgstr ""
"Uma instrução de atribuição avalia a lista de expressões (lembre-se de que "
"pode ser uma única expressão ou uma lista separada por vírgulas, a última "
"produzindo uma tupla) e atribui o único objeto resultante a cada uma das "
"listas alvos, da esquerda para a direita."

#: ../../reference/simple_stmts.rst:109
msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute reference, "
"subscription or slicing), the mutable object must ultimately perform the "
"assignment and decide about its validity, and may raise an exception if the "
"assignment is unacceptable.  The rules observed by various types and the "
"exceptions raised are given with the definition of the object types (see "
"section :ref:`types`)."
msgstr ""
"A atribuição é definida recursivamente dependendo da forma do alvo (lista). "
"Quando um alvo faz parte de um objeto mutável (uma referência de atributo, "
"assinatura ou divisão), o objeto mutável deve, em última análise, executar a "
"atribuição e decidir sobre sua validade e pode levantar uma exceção se a "
"atribuição for inaceitável. As regras observadas pelos vários tipos e as "
"exceções levantadas são dadas com a definição dos tipos de objetos (ver "
"seção :ref:`types`)."

#: ../../reference/simple_stmts.rst:122
msgid ""
"Assignment of an object to a target list, optionally enclosed in parentheses "
"or square brackets, is recursively defined as follows."
msgstr ""
"A atribuição de um objeto a uma lista alvo, opcionalmente entre parênteses "
"ou colchetes, é definida recursivamente da maneira a seguir."

#: ../../reference/simple_stmts.rst:125
msgid ""
"If the target list is a single target with no trailing comma, optionally in "
"parentheses, the object is assigned to that target."
msgstr ""
"Se a lista alvo contiver um único alvo sem vírgula à direita, opcionalmente "
"entre parênteses, o objeto será atribuído a esse alvo."

#: ../../reference/simple_stmts.rst:128
msgid "Else:"
msgstr "Senão:"

#: ../../reference/simple_stmts.rst:130
msgid ""
"If the target list contains one target prefixed with an asterisk, called a "
"\"starred\" target: The object must be an iterable with at least as many "
"items as there are targets in the target list, minus one.  The first items "
"of the iterable are assigned, from left to right, to the targets before the "
"starred target.  The final items of the iterable are assigned to the targets "
"after the starred target.  A list of the remaining items in the iterable is "
"then assigned to the starred target (the list can be empty)."
msgstr ""
"Se a lista alvo contiver um alvo prefixado com um asterisco, chamado de alvo "
"\"com estrela\" *(starred)*: o objeto deve ser um iterável com pelo menos "
"tantos itens quantos os alvos na lista alvo, menos um. Os primeiros itens do "
"iterável são atribuídos, da esquerda para a direita, aos alvos antes do alvo "
"com estrela. Os itens finais do iterável são atribuídos aos alvos após o "
"alvo com estrela. Uma lista dos itens restantes no iterável é então "
"atribuída ao alvo com estrela (a lista pode estar vazia)."

#: ../../reference/simple_stmts.rst:138
msgid ""
"Else: The object must be an iterable with the same number of items as there "
"are targets in the target list, and the items are assigned, from left to "
"right, to the corresponding targets."
msgstr ""
"Senão: o objeto deve ser um iterável com o mesmo número de itens que existem "
"alvos na lista alvos, e os itens são atribuídos, da esquerda para a direita, "
"aos alvos correspondentes."

#: ../../reference/simple_stmts.rst:142
msgid ""
"Assignment of an object to a single target is recursively defined as follows."
msgstr ""
"A atribuição de um objeto a um único alvo é definida recursivamente da "
"maneira a seguir."

#: ../../reference/simple_stmts.rst:144
msgid "If the target is an identifier (name):"
msgstr "Se o alvo for um identificador (nome):"

#: ../../reference/simple_stmts.rst:146
msgid ""
"If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` "
"statement in the current code block: the name is bound to the object in the "
"current local namespace."
msgstr ""
"Se o nome não ocorrer em uma instrução :keyword:`global` ou :keyword:"
"`nonlocal` no bloco de código atual: o nome está vinculado ao objeto no "
"espaço de nomes local atual."

#: ../../reference/simple_stmts.rst:150
msgid ""
"Otherwise: the name is bound to the object in the global namespace or the "
"outer namespace determined by :keyword:`nonlocal`, respectively."
msgstr ""
"Caso contrário: o nome é vinculado ao objeto no espaço de nomes global "
"global ou no espaço de nomes global externo determinado por :keyword:"
"`nonlocal`, respectivamente."

#: ../../reference/simple_stmts.rst:155
msgid ""
"The name is rebound if it was already bound.  This may cause the reference "
"count for the object previously bound to the name to reach zero, causing the "
"object to be deallocated and its destructor (if it has one) to be called."
msgstr ""
"O nome é vinculado novamente se já estiver vinculado. Isso pode fazer com "
"que a contagem de referências para o objeto anteriormente vinculado ao nome "
"chegue a zero, fazendo com que o objeto seja desalocado e seu destrutor (se "
"houver) seja chamado."

#: ../../reference/simple_stmts.rst:161
msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given attribute; "
"if it cannot perform the assignment, it raises an exception (usually but not "
"necessarily :exc:`AttributeError`)."
msgstr ""
"Se o alvo for uma referência de atributo: a expressão primária na referência "
"é avaliada. Deve produzir um objeto com atributos atribuíveis; se este não "
"for o caso, a exceção :exc:`TypeError` é levanta. Esse objeto é então "
"solicitado a atribuir o objeto atribuído ao atributo fornecido; se não puder "
"executar a atribuição, ele levanta uma exceção (geralmente, mas não "
"necessariamente :exc:`AttributeError`)."

#: ../../reference/simple_stmts.rst:170
msgid ""
"Note: If the object is a class instance and the attribute reference occurs "
"on both sides of the assignment operator, the right-hand side expression, "
"``a.x`` can access either an instance attribute or (if no instance attribute "
"exists) a class attribute.  The left-hand side target ``a.x`` is always set "
"as an instance attribute, creating it if necessary.  Thus, the two "
"occurrences of ``a.x`` do not necessarily refer to the same attribute: if "
"the right-hand side expression refers to a class attribute, the left-hand "
"side creates a new instance attribute as the target of the assignment::"
msgstr ""
"Nota: Se o objeto for uma instância de classe e a referência de atributo "
"ocorrer em ambos os lados do operador de atribuição, a expressão do lado "
"direito, ``a.x`` pode acessar um atributo de instância ou (se não existir "
"nenhum atributo de instância) uma classe atributo. O alvo do lado esquerdo "
"``a.x`` é sempre definido como um atributo de instância, criando-o se "
"necessário. Assim, as duas ocorrências de ``a.x`` não necessariamente se "
"referem ao mesmo atributo: se a expressão do lado direito se refere a um "
"atributo de classe, o lado esquerdo cria um novo atributo de instância como "
"alvo da atribuição::"

#: ../../reference/simple_stmts.rst:179
msgid ""
"class Cls:\n"
"    x = 3             # class variable\n"
"inst = Cls()\n"
"inst.x = inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3"
msgstr ""
"class Cls:\n"
"    x = 3             # variável de classe\n"
"inst = Cls()\n"
"inst.x = inst.x + 1   # escreve inst.x como 4 deixando Cls.x como 3"

#: ../../reference/simple_stmts.rst:184
msgid ""
"This description does not necessarily apply to descriptor attributes, such "
"as properties created with :func:`property`."
msgstr ""
"Esta descrição não se aplica necessariamente aos atributos do descritor, "
"como propriedades criadas com :func:`property`."

#: ../../reference/simple_stmts.rst:191
msgid ""
"If the target is a subscription: The primary expression in the reference is "
"evaluated.  It should yield either a mutable sequence object (such as a "
"list) or a mapping object (such as a dictionary).  Next, the subscript "
"expression is evaluated."
msgstr ""
"Se o alvo for uma assinatura: a expressão primária na referência é avaliada. "
"Deve produzir um objeto de sequência mutável (como uma lista) ou um objeto "
"de mapeamento (como um dicionário). Em seguida, a expressão subscrito é "
"avaliada."

#: ../../reference/simple_stmts.rst:200
msgid ""
"If the primary is a mutable sequence object (such as a list), the subscript "
"must yield an integer.  If it is negative, the sequence's length is added to "
"it.  The resulting value must be a nonnegative integer less than the "
"sequence's length, and the sequence is asked to assign the assigned object "
"to its item with that index.  If the index is out of range, :exc:"
"`IndexError` is raised (assignment to a subscripted sequence cannot add new "
"items to a list)."
msgstr ""
"Se o primário for um objeto de sequência mutável (como uma lista), o "
"subscrito deverá produzir um inteiro. Se for negativo, o comprimento da "
"sequência é adicionado a ela. O valor resultante deve ser um inteiro não "
"negativo menor que o comprimento da sequência, e a sequência é solicitada a "
"atribuir o objeto atribuído ao seu item com esse índice. Se o índice estiver "
"fora do intervalo, a exceção :exc:`IndexError` será levantada (a atribuição "
"a uma sequência subscrita não pode adicionar novos itens a uma lista)."

#: ../../reference/simple_stmts.rst:211
msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping is "
"then asked to create a key/value pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with "
"the same key value, or insert a new key/value pair (if no key with the same "
"value existed)."
msgstr ""
"Se o primário for um objeto de mapeamento (como um dicionário), o subscrito "
"deve ter um tipo compatível com o tipo de chave do mapeamento, e o "
"mapeamento é solicitado a criar um par chave/valore que mapeia o subscrito "
"para o objeto atribuído. Isso pode substituir um par de chave/valor "
"existente pelo mesmo valor de chave ou inserir um novo par de chave/valor "
"(se não existir nenhuma chave com o mesmo valor)."

#: ../../reference/simple_stmts.rst:217
msgid ""
"For user-defined objects, the :meth:`~object.__setitem__` method is called "
"with appropriate arguments."
msgstr ""
"Para objetos definidos pelo usuário, o método :meth:`~object.__setitem__` é "
"chamado com argumentos apropriados."

#: ../../reference/simple_stmts.rst:222
msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  The "
"assigned object should be a sequence object of the same type.  Next, the "
"lower and upper bound expressions are evaluated, insofar they are present; "
"defaults are zero and the sequence's length.  The bounds should evaluate to "
"integers. If either bound is negative, the sequence's length is added to "
"it.  The resulting bounds are clipped to lie between zero and the sequence's "
"length, inclusive.  Finally, the sequence object is asked to replace the "
"slice with the items of the assigned sequence.  The length of the slice may "
"be different from the length of the assigned sequence, thus changing the "
"length of the target sequence, if the target sequence allows it."
msgstr ""
"Se o alvo for um fatiamento: a expressão primária na referência é avaliada. "
"Deve produzir um objeto de sequência mutável (como uma lista). O objeto "
"atribuído deve ser um objeto de sequência do mesmo tipo. Em seguida, as "
"expressões de limite inferior e superior são avaliadas, na medida em que "
"estiverem presentes; os padrões são zero e o comprimento da sequência. Os "
"limites devem ser avaliados como inteiros. Se um dos limites for negativo, o "
"comprimento da sequência será adicionado a ele. Os limites resultantes são "
"cortados para ficarem entre zero e o comprimento da sequência, inclusive. "
"Finalmente, o objeto de sequência é solicitado a substituir a fatia pelos "
"itens da sequência atribuída. O comprimento da fatia pode ser diferente do "
"comprimento da sequência atribuída, alterando assim o comprimento da "
"sequência alvo, se a sequência alvo permitir."

#: ../../reference/simple_stmts.rst:236
msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr ""
"Na implementação atual, a sintaxe dos alvos é considerada a mesma das "
"expressões e a sintaxe inválida é rejeitada durante a fase de geração do "
"código, causando mensagens de erro menos detalhadas."

#: ../../reference/simple_stmts.rst:240
msgid ""
"Although the definition of assignment implies that overlaps between the left-"
"hand side and the right-hand side are 'simultaneous' (for example ``a, b = "
"b, a`` swaps two variables), overlaps *within* the collection of assigned-to "
"variables occur left-to-right, sometimes resulting in confusion.  For "
"instance, the following program prints ``[0, 2]``::"
msgstr ""
"Embora a definição de atribuição implique que as sobreposições entre o lado "
"esquerdo e o lado direito sejam \"simultâneas\" (por exemplo, ``a, b = b, "
"a`` troca duas variáveis), sobreposições *dentro* da coleção de variáveis "
"atribuídas ocorrem da esquerda para a direita, às vezes resultando em "
"confusão. Por exemplo, o programa a seguir imprime ``[0, 2]``::"

#: ../../reference/simple_stmts.rst:246
msgid ""
"x = [0, 1]\n"
"i = 0\n"
"i, x[i] = 1, 2         # i is updated, then x[i] is updated\n"
"print(x)"
msgstr ""
"x = [0, 1]\n"
"i = 0\n"
"i, x[i] = 1, 2         # i é atualizado e, em seguida, x[i] é atualizado\n"
"print(x)"

#: ../../reference/simple_stmts.rst:254
msgid ":pep:`3132` - Extended Iterable Unpacking"
msgstr ":pep:`3132` - Desempacotamento estendido de iterável"

#: ../../reference/simple_stmts.rst:255
msgid "The specification for the ``*target`` feature."
msgstr "A especificação para o recurso ``*target``."

#: ../../reference/simple_stmts.rst:261
msgid "Augmented assignment statements"
msgstr "Instruções de atribuição aumentada"

#: ../../reference/simple_stmts.rst:279
msgid ""
"Augmented assignment is the combination, in a single statement, of a binary "
"operation and an assignment statement:"
msgstr ""
"A atribuição aumentada é a combinação, em uma única instrução, de uma "
"operação binária e uma instrução de atribuição:"

#: ../../reference/simple_stmts.rst:288
msgid ""
"(See section :ref:`primaries` for the syntax definitions of the last three "
"symbols.)"
msgstr ""
"(Veja a seção :ref:`primaries` para as definições de sintaxe dos últimos "
"três símbolos.)"

#: ../../reference/simple_stmts.rst:291
msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the two "
"operands, and assigns the result to the original target.  The target is only "
"evaluated once."
msgstr ""
"Uma atribuição aumentada avalia o alvo (que, diferentemente das instruções "
"de atribuição normais, não pode ser um desempacotamento) e a lista de "
"expressões, executa a operação binária específica para o tipo de atribuição "
"nos dois operandos e atribui o resultado ao alvo original. O alvo é avaliado "
"apenas uma vez."

#: ../../reference/simple_stmts.rst:296
msgid ""
"An augmented assignment statement like ``x += 1`` can be rewritten as ``x = "
"x + 1`` to achieve a similar, but not exactly equal effect. In the augmented "
"version, ``x`` is only evaluated once. Also, when possible, the actual "
"operation is performed *in-place*, meaning that rather than creating a new "
"object and assigning that to the target, the old object is modified instead."
msgstr ""
"Uma instrução de atribuição aumentada como ``x += 1`` pode ser reescrita "
"como ``x = x + 1`` para obter um efeito semelhante, mas não exatamente "
"igual. Na versão aumentada, ``x`` é avaliado apenas uma vez. Além disso, "
"quando possível, a operação real é executada *no local*, o que significa "
"que, em vez de criar um novo objeto e atribuí-lo ao alvo, o objeto antigo é "
"modificado."

#: ../../reference/simple_stmts.rst:302
msgid ""
"Unlike normal assignments, augmented assignments evaluate the left-hand side "
"*before* evaluating the right-hand side.  For example, ``a[i] += f(x)`` "
"first looks-up ``a[i]``, then it evaluates ``f(x)`` and performs the "
"addition, and lastly, it writes the result back to ``a[i]``."
msgstr ""
"Ao contrário das atribuições normais, as atribuições aumentadas avaliam o "
"lado esquerdo *antes* de avaliar o lado direito. Por exemplo, ``a[i] += "
"f(x)`` primeiro procura ``a[i]``, então avalia ``f(x)`` e executa a adição "
"e, por último, escreve o resultado de volta para ``a[i]``."

#: ../../reference/simple_stmts.rst:307
msgid ""
"With the exception of assigning to tuples and multiple targets in a single "
"statement, the assignment done by augmented assignment statements is handled "
"the same way as normal assignments. Similarly, with the exception of the "
"possible *in-place* behavior, the binary operation performed by augmented "
"assignment is the same as the normal binary operations."
msgstr ""
"Com exceção da atribuição a tuplas e vários alvos em uma única instrução, a "
"atribuição feita por instruções de atribuição aumentada é tratada da mesma "
"maneira que atribuições normais. Da mesma forma, com exceção do possível "
"comportamento *in-place*, a operação binária executada por atribuição "
"aumentada é a mesma que as operações binárias normais."

#: ../../reference/simple_stmts.rst:313
msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr ""
"Para alvos que são referências de atributos, a mesma :ref:`advertência sobre "
"atributos de classe e instância <attr-target-note>` se aplica a atribuições "
"regulares."

#: ../../reference/simple_stmts.rst:320
msgid "Annotated assignment statements"
msgstr "instruções de atribuição anotado"

#: ../../reference/simple_stmts.rst:327
msgid ""
":term:`Annotation <variable annotation>` assignment is the combination, in a "
"single statement, of a variable or attribute annotation and an optional "
"assignment statement:"
msgstr ""
"A atribuição de :term:`anotação <variable annotation>` é a combinação, em "
"uma única instrução, de uma anotação de variável ou atributo e uma instrução "
"de atribuição opcional:"

#: ../../reference/simple_stmts.rst:334
msgid ""
"The difference from normal :ref:`assignment` is that only a single target is "
"allowed."
msgstr ""
"A diferença para as :ref:`assignment` normal é que apenas um único alvo é "
"permitido."

#: ../../reference/simple_stmts.rst:336
msgid ""
"The assignment target is considered \"simple\" if it consists of a single "
"name that is not enclosed in parentheses. For simple assignment targets, if "
"in class or module scope, the annotations are gathered in a lazily "
"evaluated :ref:`annotation scope <annotation-scopes>`. The annotations can "
"be evaluated using the :attr:`~object.__annotations__` attribute of a class "
"or module, or using the facilities in the :mod:`annotationlib` module."
msgstr ""
"O alvo da atribuição é considerado \"simples\" se consistir em um único nome "
"que não esteja entre parênteses. Para alvos de atribuição simples, se "
"estiverem no escopo de classe ou módulo, as anotações são reunidas em um :"
"ref:`escopo de anotação <annotation-scopes>` avaliado preguiçosamente. As "
"anotações podem ser avaliadas usando o atributo :attr:`~object."
"__annotations__` de uma classe ou módulo, ou usando os recursos do módulo :"
"mod:`annotationlib`."

#: ../../reference/simple_stmts.rst:345
msgid ""
"If the assignment target is not simple (an attribute, subscript node, or "
"parenthesized name), the annotation is never evaluated."
msgstr ""
"Se o alvo da atribuição não for simples (um atributo, nó subscrito ou nome "
"entre parênteses), a anotação nunca será avaliada."

#: ../../reference/simple_stmts.rst:348
msgid ""
"If a name is annotated in a function scope, then this name is local for that "
"scope. Annotations are never evaluated and stored in function scopes."
msgstr ""
"Se um nome for anotado em um escopo de função, esse nome será local para "
"esse escopo. As anotações nunca são avaliadas e armazenadas em escopos de "
"função."

#: ../../reference/simple_stmts.rst:351
msgid ""
"If the right hand side is present, an annotated assignment performs the "
"actual assignment as if there was no annotation present. If the right hand "
"side is not present for an expression target, then the interpreter evaluates "
"the target except for the last :meth:`~object.__setitem__` or :meth:`~object."
"__setattr__` call."
msgstr ""
"Se o lado direito estiver presente, uma atribuição anotada executa a "
"atribuição real como se não houvesse uma anotação presente. Se o lado "
"direito não estiver presente para um alvo de expressão, então o "
"interpretador avalia o alvo, exceto para a última chamada :meth:`~object."
"__setitem__` ou :meth:`~object.__setattr__`."

#: ../../reference/simple_stmts.rst:359
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - Sintaxe para Anotações de Variáveis"

#: ../../reference/simple_stmts.rst:360
msgid ""
"The proposal that added syntax for annotating the types of variables "
"(including class variables and instance variables), instead of expressing "
"them through comments."
msgstr ""
"A proposta que adicionou sintaxe para anotar os tipos de variáveis "
"(incluindo variáveis de classe e variáveis de instância), em vez de expressá-"
"las por meio de comentários."

#: ../../reference/simple_stmts.rst:364
msgid ":pep:`484` - Type hints"
msgstr ":pep:`484` - Dicas de tipo"

#: ../../reference/simple_stmts.rst:365
msgid ""
"The proposal that added the :mod:`typing` module to provide a standard "
"syntax for type annotations that can be used in static analysis tools and "
"IDEs."
msgstr ""
"A proposta que adicionou o módulo :mod:`typing` para fornecer uma sintaxe "
"padrão para anotações de tipo que podem ser usadas em ferramentas de análise "
"estática e IDEs."

#: ../../reference/simple_stmts.rst:369
msgid ""
"Now annotated assignments allow the same expressions in the right hand side "
"as regular assignments. Previously, some expressions (like un-parenthesized "
"tuple expressions) caused a syntax error."
msgstr ""
"Agora, as atribuições anotadas permitem as mesmas expressões no lado direito "
"que as atribuições regulares. Anteriormente, algumas expressões (como "
"expressões de tupla sem parênteses) causavam um erro de sintaxe."

#: ../../reference/simple_stmts.rst:374
msgid ""
"Annotations are now lazily evaluated in a separate :ref:`annotation scope "
"<annotation-scopes>`. If the assignment target is not simple, annotations "
"are never evaluated."
msgstr ""
"As anotações agora têm avaliação preguiçosa em um :ref:`escopo de anotação "
"<annotation-scopes>` separado. Se o alvo da atribuição não for simples, as "
"anotações nunca serão avaliadas."

#: ../../reference/simple_stmts.rst:382
msgid "The :keyword:`!assert` statement"
msgstr "A instrução :keyword:`!assert`"

#: ../../reference/simple_stmts.rst:389
msgid ""
"Assert statements are a convenient way to insert debugging assertions into a "
"program:"
msgstr ""
"As instruções assert são uma maneira conveniente de inserir asserções de "
"depuração em um programa:"

#: ../../reference/simple_stmts.rst:395
msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr "A forma simples, ``assert expression``, é equivalente a ::"

#: ../../reference/simple_stmts.rst:397
msgid ""
"if __debug__:\n"
"    if not expression: raise AssertionError"
msgstr ""
"if __debug__:\n"
"    if not expression: raise AssertionError"

#: ../../reference/simple_stmts.rst:400
msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr ""
"A forma estendida, ``assert expression1, expression2``, é equivalente a ::"

#: ../../reference/simple_stmts.rst:402
msgid ""
"if __debug__:\n"
"    if not expression1: raise AssertionError(expression2)"
msgstr ""
"if __debug__:\n"
"    if not expression1: raise AssertionError(expression2)"

#: ../../reference/simple_stmts.rst:409
msgid ""
"These equivalences assume that :const:`__debug__` and :exc:`AssertionError` "
"refer to the built-in variables with those names.  In the current "
"implementation, the built-in variable ``__debug__`` is ``True`` under normal "
"circumstances, ``False`` when optimization is requested (command line "
"option :option:`-O`).  The current code generator emits no code for an :"
"keyword:`assert` statement when optimization is requested at compile time.  "
"Note that it is unnecessary to include the source code for the expression "
"that failed in the error message; it will be displayed as part of the stack "
"trace."
msgstr ""
"Essas equivalências presumem que :const:`__debug__` e :exc:`AssertionError` "
"referem-se às variáveis embutidas com esses nomes. Na implementação atual, a "
"variável embutida ``__debug__`` é ``True`` em circunstâncias normais, "
"``False`` quando a otimização é solicitada (opção de linha de comando :"
"option:`-O`). O gerador de código atual não emite código para uma instrução :"
"keyword:`assert` quando a otimização é solicitada em tempo de compilação. "
"Observe que não é necessário incluir o código-fonte da expressão que falhou "
"na mensagem de erro; ele será exibido como parte do stack trace (situação da "
"pilha de execução)."

#: ../../reference/simple_stmts.rst:418
msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-in "
"variable is determined when the interpreter starts."
msgstr ""
"Atribuições a :const:`__debug__` são ilegais. O valor da variável embutida é "
"determinado quando o interpretador é iniciado."

#: ../../reference/simple_stmts.rst:425
msgid "The :keyword:`!pass` statement"
msgstr "A instrução :keyword:`!pass`"

#: ../../reference/simple_stmts.rst:435
msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ""
":keyword:`pass` é uma operação nula --- quando é executada, nada acontece. É "
"útil como um espaço reservado quando uma instrução é necessária "
"sintaticamente, mas nenhum código precisa ser executado, por exemplo::"

#: ../../reference/simple_stmts.rst:439
msgid ""
"def f(arg): pass    # a function that does nothing (yet)\n"
"\n"
"class C: pass       # a class with no methods (yet)"
msgstr ""
"def f(arg): pass    # uma função que faz nada (ainda)\n"
"\n"
"class C: pass       # uma classe com nenhum método (ainda)"

#: ../../reference/simple_stmts.rst:447
msgid "The :keyword:`!del` statement"
msgstr "A instrução :keyword:`!del`"

#: ../../reference/simple_stmts.rst:457
msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some hints."
msgstr ""
"A exclusão é definida recursivamente de maneira muito semelhante à maneira "
"como a atribuição é definida. Em vez de explicar em detalhes, aqui estão "
"algumas dicas."

#: ../../reference/simple_stmts.rst:460
msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr ""
"A exclusão de uma lista alvo exclui recursivamente cada alvo, da esquerda "
"para a direita."

#: ../../reference/simple_stmts.rst:466
msgid ""
"Deletion of a name removes the binding of that name from the local or global "
"namespace, depending on whether the name occurs in a :keyword:`global` "
"statement in the same code block.  If the name is unbound, a :exc:"
"`NameError` exception will be raised."
msgstr ""
"A exclusão de um nome remove a ligação desse nome do espaço de nomes global "
"local ou global, dependendo se o nome ocorre em uma instrução :keyword:"
"`global` no mesmo bloco de código. Se o nome for desvinculado, uma exceção :"
"exc:`NameError` será levantada."

#: ../../reference/simple_stmts.rst:473
msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to "
"the primary object involved; deletion of a slicing is in general equivalent "
"to assignment of an empty slice of the right type (but even this is "
"determined by the sliced object)."
msgstr ""
"A exclusão de referências de atributos, assinaturas e fatias é passada para "
"o objeto principal envolvido; a exclusão de um fatiamento é em geral "
"equivalente à atribuição de uma fatia vazia do tipo certo (mas mesmo isso é "
"determinado pelo objeto fatiado)."

#: ../../reference/simple_stmts.rst:478
msgid ""
"Previously it was illegal to delete a name from the local namespace if it "
"occurs as a free variable in a nested block."
msgstr ""
"Anteriormente, era ilegal excluir um nome do espaço de nomes local se ele "
"ocorresse como uma variável livre em um bloco aninhado."

#: ../../reference/simple_stmts.rst:486
msgid "The :keyword:`!return` statement"
msgstr "A instrução :keyword:`!return`"

#: ../../reference/simple_stmts.rst:496
msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ""
":keyword:`return` só pode ocorrer sintaticamente aninhado em uma definição "
"de função, não em uma definição de classe aninhada."

#: ../../reference/simple_stmts.rst:499
msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr ""
"Se uma lista de expressões estiver presente, ela será avaliada, caso "
"contrário, ``None`` será substituído."

#: ../../reference/simple_stmts.rst:501
msgid ""
":keyword:`return` leaves the current function call with the expression list "
"(or ``None``) as return value."
msgstr ""
":keyword:`return` deixa a chamada da função atual com a lista de expressões "
"(ou ``None``) como valor de retorno."

#: ../../reference/simple_stmts.rst:506
msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the function."
msgstr ""
"Quando :keyword:`return` passa o controle de uma instrução :keyword:`try` "
"com uma cláusula :keyword:`finally`, essa cláusula :keyword:`!finally` é "
"executada antes de realmente sair da função."

#: ../../reference/simple_stmts.rst:510
msgid ""
"In a generator function, the :keyword:`return` statement indicates that the "
"generator is done and will cause :exc:`StopIteration` to be raised. The "
"returned value (if any) is used as an argument to construct :exc:"
"`StopIteration` and becomes the :attr:`StopIteration.value` attribute."
msgstr ""
"Em uma função geradora, a instrução :keyword:`return` indica que o gerador "
"está pronto e fará com que :exc:`StopIteration` seja gerado. O valor "
"retornado (se houver) é usado como argumento para construir :exc:"
"`StopIteration` e se torna o atributo :attr:`StopIteration.value`."

#: ../../reference/simple_stmts.rst:515
msgid ""
"In an asynchronous generator function, an empty :keyword:`return` statement "
"indicates that the asynchronous generator is done and will cause :exc:"
"`StopAsyncIteration` to be raised.  A non-empty :keyword:`!return` statement "
"is a syntax error in an asynchronous generator function."
msgstr ""
"Em uma função de gerador assíncrono, uma instrução :keyword:`return` vazia "
"indica que o gerador assíncrono está pronto e fará com que :exc:"
"`StopAsyncIteration` seja gerado. Uma instrução :keyword:`!return` não vazia "
"é um erro de sintaxe em uma função de gerador assíncrono."

#: ../../reference/simple_stmts.rst:523
msgid "The :keyword:`!yield` statement"
msgstr "A instrução :keyword:`!yield`"

#: ../../reference/simple_stmts.rst:535
msgid ""
"A :keyword:`yield` statement is semantically equivalent to a :ref:`yield "
"expression <yieldexpr>`. The ``yield`` statement can be used to omit the "
"parentheses that would otherwise be required in the equivalent yield "
"expression statement. For example, the yield statements ::"
msgstr ""
"Uma instrução :keyword:`yield` é semanticamente equivalente a uma :ref:"
"`expressão yield <yieldexpr>`. A instrução ``yield`` pode ser usada para "
"omitir os parênteses que, de outra forma, seriam necessários na instrução de "
"expressão yield equivalente. Por exemplo, as instruções yield ::"

#: ../../reference/simple_stmts.rst:540
msgid ""
"yield <expr>\n"
"yield from <expr>"
msgstr ""
"yield <expr>\n"
"yield from <expr>"

#: ../../reference/simple_stmts.rst:543
msgid "are equivalent to the yield expression statements ::"
msgstr "são equivalentes às instruções de expressão yield ::"

#: ../../reference/simple_stmts.rst:545
msgid ""
"(yield <expr>)\n"
"(yield from <expr>)"
msgstr ""
"(yield <expr>)\n"
"(yield from <expr>)"

#: ../../reference/simple_stmts.rst:548
msgid ""
"Yield expressions and statements are only used when defining a :term:"
"`generator` function, and are only used in the body of the generator "
"function.  Using :keyword:`yield` in a function definition is sufficient to "
"cause that definition to create a generator function instead of a normal "
"function."
msgstr ""
"Expressões e instruções yield são usadas apenas ao definir uma função :term:"
"`geradora <gerador>` e são usadas apenas no corpo da função geradora. Usar :"
"keyword:`yield` em uma definição de função é suficiente para fazer com que "
"essa definição crie uma função geradora em vez de uma função normal."

#: ../../reference/simple_stmts.rst:553
msgid ""
"For full details of :keyword:`yield` semantics, refer to the :ref:"
"`yieldexpr` section."
msgstr ""
"Para detalhes completos da semântica :keyword:`yield`, consulte a seção :ref:"
"`yieldexpr`."

#: ../../reference/simple_stmts.rst:559
msgid "The :keyword:`!raise` statement"
msgstr "A instrução :keyword:`!raise`"

#: ../../reference/simple_stmts.rst:570
msgid ""
"If no expressions are present, :keyword:`raise` re-raises the exception that "
"is currently being handled, which is also known as the *active exception*. "
"If there isn't currently an active exception, a :exc:`RuntimeError` "
"exception is raised indicating that this is an error."
msgstr ""
"Se nenhuma expressão estiver presente, :keyword:`raise` reativa a exceção "
"que está sendo tratada no momento, que também é conhecida como *exceção "
"ativa*. Se não houver uma exceção ativa no momento, uma exceção :exc:"
"`RuntimeError` é levantada indicando que isso é um erro."

#: ../../reference/simple_stmts.rst:575
msgid ""
"Otherwise, :keyword:`raise` evaluates the first expression as the exception "
"object.  It must be either a subclass or an instance of :class:"
"`BaseException`. If it is a class, the exception instance will be obtained "
"when needed by instantiating the class with no arguments."
msgstr ""
"Caso contrário, :keyword:`raise` avalia a primeira expressão como o objeto "
"de exceção. Deve ser uma subclasse ou uma instância de :class:"
"`BaseException`. Se for uma classe, a instância de exceção será obtida "
"quando necessário instanciando a classe sem argumentos."

#: ../../reference/simple_stmts.rst:580
msgid ""
"The :dfn:`type` of the exception is the exception instance's class, the :dfn:"
"`value` is the instance itself."
msgstr ""
"O :dfn:`tipo` da exceção é a classe da instância de exceção, o :dfn:`valor` "
"é a própria instância."

#: ../../reference/simple_stmts.rst:585
msgid ""
"A traceback object is normally created automatically when an exception is "
"raised and attached to it as the :attr:`~BaseException.__traceback__` "
"attribute. You can create an exception and set your own traceback in one "
"step using the :meth:`~BaseException.with_traceback` exception method (which "
"returns the same exception instance, with its traceback set to its "
"argument), like so::"
msgstr ""
"Um objeto traceback (situação da pilha de execução) normalmente é criado "
"automaticamente quando uma exceção é levantada e anexada a ele como o "
"atributo :attr:`~BaseException.__traceback__`. Você pode criar uma exceção e "
"definir seu próprio traceback em uma etapa usando o método de exceção :meth:"
"`~BaseException.with_traceback` (que retorna a mesma instância de exceção, "
"com seu traceback definido para seu argumento), assim::"

#: ../../reference/simple_stmts.rst:591
msgid "raise Exception(\"foo occurred\").with_traceback(tracebackobj)"
msgstr "raise Exception(\"ocorreu foo\").with_traceback(tracebackobj)"

#: ../../reference/simple_stmts.rst:597
msgid ""
"The ``from`` clause is used for exception chaining: if given, the second "
"*expression* must be another exception class or instance. If the second "
"expression is an exception instance, it will be attached to the raised "
"exception as the :attr:`~BaseException.__cause__` attribute (which is "
"writable). If the expression is an exception class, the class will be "
"instantiated and the resulting exception instance will be attached to the "
"raised exception as the :attr:`!__cause__` attribute. If the raised "
"exception is not handled, both exceptions will be printed:"
msgstr ""
"A cláusula ``from`` é usada para encadeamento de exceções: se fornecida, a "
"segunda expressão, *expression*, deve ser outra classe ou instância de "
"exceção. Se a segunda expressão for uma instância de exceção, ela será "
"anexada à exceção levantada como o atributo :attr:`~BaseException.__cause__` "
"(que é gravável). Se a expressão for uma classe de exceção, a classe será "
"instanciada e a instância de exceção resultante será anexada à exceção "
"levantada como o atributo :attr:`!__cause__`. Se a exceção levantada não for "
"tratada, ambas as exceções serão impressas::"

#: ../../reference/simple_stmts.rst:606
msgid ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except Exception as exc:\n"
"...     raise RuntimeError(\"Something bad happened\") from exc\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: division by zero\n"
"\n"
"The above exception was the direct cause of the following exception:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Something bad happened\") from exc\n"
"RuntimeError: Something bad happened"
msgstr ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except Exception as exc:\n"
"...     raise RuntimeError(\"Something bad happened\") from exc\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: division by zero\n"
"\n"
"The above exception was the direct cause of the following exception:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Something bad happened\") from exc\n"
"RuntimeError: Something bad happened"

#: ../../reference/simple_stmts.rst:626
msgid ""
"A similar mechanism works implicitly if a new exception is raised when an "
"exception is already being handled.  An exception may be handled when an :"
"keyword:`except` or :keyword:`finally` clause, or a :keyword:`with` "
"statement, is used.  The previous exception is then attached as the new "
"exception's :attr:`~BaseException.__context__` attribute:"
msgstr ""
"Um mecanismo semelhante funciona implicitamente se uma nova exceção for "
"levantada quando uma exceção já estiver sendo tratada. Uma exceção pode ser "
"tratada quando uma cláusula :keyword:`except` ou :keyword:`finally`, ou uma "
"instrução :keyword:`with`, é usada. A exceção anterior é então anexada como "
"o atributo :attr:`~BaseException.__context__` da nova exceção:"

#: ../../reference/simple_stmts.rst:632
msgid ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Something bad happened\")\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: division by zero\n"
"\n"
"During handling of the above exception, another exception occurred:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Something bad happened\")\n"
"RuntimeError: Something bad happened"
msgstr ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Something bad happened\")\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: division by zero\n"
"\n"
"During handling of the above exception, another exception occurred:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Something bad happened\")\n"
"RuntimeError: Something bad happened"

#: ../../reference/simple_stmts.rst:652
msgid ""
"Exception chaining can be explicitly suppressed by specifying :const:`None` "
"in the ``from`` clause:"
msgstr ""
"O encadeamento de exceção pode ser explicitamente suprimido especificando :"
"const:`None` na cláusula ``from``:"

#: ../../reference/simple_stmts.rst:655
msgid ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Something bad happened\") from None\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"RuntimeError: Something bad happened"
msgstr ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Something bad happened\") from None\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"RuntimeError: Something bad happened"

#: ../../reference/simple_stmts.rst:666
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information about handling exceptions is in section :ref:"
"`try`."
msgstr ""
"Informações adicionais sobre exceções podem ser encontradas na seção :ref:"
"`exceptions`, e informações sobre como lidar com exceções estão na seção :"
"ref:`try`."

#: ../../reference/simple_stmts.rst:669
msgid ":const:`None` is now permitted as ``Y`` in ``raise X from Y``."
msgstr ":const:`None` agora é permitido como ``Y`` em ``raise X from Y``."

#: ../../reference/simple_stmts.rst:672
msgid ""
"Added the :attr:`~BaseException.__suppress_context__` attribute to suppress "
"automatic display of the exception context."
msgstr ""
"Adicionado o atributo :attr:`~BaseException.__suppress_context__` para "
"suprimir a exibição automática do contexto de exceção."

#: ../../reference/simple_stmts.rst:675
msgid ""
"If the traceback of the active exception is modified in an :keyword:`except` "
"clause, a subsequent ``raise`` statement re-raises the exception with the "
"modified traceback. Previously, the exception was re-raised with the "
"traceback it had when it was caught."
msgstr ""
"Se o traceback da exceção ativa for modificado em uma cláusula :keyword:"
"`except`, uma instrução ``raise`` subsequente levantará novamente a exceção "
"com o traceback modificado. Anteriormente, a exceção era levantada novamente "
"com o traceback que tinha quando foi capturada."

#: ../../reference/simple_stmts.rst:684
msgid "The :keyword:`!break` statement"
msgstr "A instrução :keyword:`!break`"

#: ../../reference/simple_stmts.rst:695
msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` or :"
"keyword:`while` loop, but not nested in a function or class definition "
"within that loop."
msgstr ""
":keyword:`break` só pode ocorrer sintaticamente aninhado em um laço :keyword:"
"`for` ou :keyword:`while`, mas não aninhado em uma função ou definição de "
"classe dentro desse laço."

#: ../../reference/simple_stmts.rst:702
msgid ""
"It terminates the nearest enclosing loop, skipping the optional :keyword:`!"
"else` clause if the loop has one."
msgstr ""
"Ele termina o laço de fechamento mais próximo, pulando a cláusula opcional :"
"keyword:`!else` se o laço tiver uma."

#: ../../reference/simple_stmts.rst:705
msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control "
"target keeps its current value."
msgstr ""
"Se um laço :keyword:`for` é encerrado por :keyword:`break`, o alvo de "
"controle do laço mantém seu valor atual."

#: ../../reference/simple_stmts.rst:710
msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the loop."
msgstr ""
"Quando :keyword:`break` passa o controle de uma instrução :keyword:`try` com "
"uma cláusula :keyword:`finally`, essa cláusula :keyword:`!finally` é "
"executada antes de realmente sair do laço."

#: ../../reference/simple_stmts.rst:718
msgid "The :keyword:`!continue` statement"
msgstr "A instrução :keyword:`!continue`"

#: ../../reference/simple_stmts.rst:730
msgid ""
":keyword:`continue` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class definition "
"within that loop.  It continues with the next cycle of the nearest enclosing "
"loop."
msgstr ""
":keyword:`continue` só pode ocorrer sintaticamente aninhado em um laço :"
"keyword:`for` ou :keyword:`while`, mas não aninhado em uma função ou "
"definição de classe dentro desse laço. Ele continua com o próximo ciclo do "
"laço de fechamento mais próximo."

#: ../../reference/simple_stmts.rst:734
msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`!finally` clause is "
"executed before really starting the next loop cycle."
msgstr ""
"Quando :keyword:`continue` passa o controle de uma instrução :keyword:`try` "
"com uma cláusula :keyword:`finally`, essa cláusula :keyword:`!finally` é "
"executada antes realmente iniciar o próximo ciclo do laço."

#: ../../reference/simple_stmts.rst:743
msgid "The :keyword:`!import` statement"
msgstr "A instrução :keyword:`!import`"

#: ../../reference/simple_stmts.rst:764
msgid ""
"The basic import statement (no :keyword:`from` clause) is executed in two "
"steps:"
msgstr ""
"A instrução de importação básica (sem cláusula :keyword:`from`) é executada "
"em duas etapas:"

#: ../../reference/simple_stmts.rst:767
msgid "find a module, loading and initializing it if necessary"
msgstr "encontra um módulo, carregando e inicializando-o se necessário"

#: ../../reference/simple_stmts.rst:768
msgid ""
"define a name or names in the local namespace for the scope where the :"
"keyword:`import` statement occurs."
msgstr ""
"define um nome ou nomes no espaço de nomes local para o escopo onde ocorre a "
"instrução :keyword:`import`."

#: ../../reference/simple_stmts.rst:771
msgid ""
"When the statement contains multiple clauses (separated by commas) the two "
"steps are carried out separately for each clause, just as though the clauses "
"had been separated out into individual import statements."
msgstr ""
"Quando a instrução contém várias cláusulas (separadas por vírgulas), as duas "
"etapas são executadas separadamente para cada cláusula, como se as cláusulas "
"tivessem sido separadas em instruções de importação individuais."

#: ../../reference/simple_stmts.rst:776
msgid ""
"The details of the first step, finding and loading modules, are described in "
"greater detail in the section on the :ref:`import system <importsystem>`, "
"which also describes the various types of packages and modules that can be "
"imported, as well as all the hooks that can be used to customize the import "
"system. Note that failures in this step may indicate either that the module "
"could not be located, *or* that an error occurred while initializing the "
"module, which includes execution of the module's code."
msgstr ""
"Os detalhes da primeira etapa, encontrar e carregar módulos, estão descritos "
"com mais detalhes na seção sobre o :ref:`sistema de importação "
"<importsystem>`, que também descreve os vários tipos de pacotes e módulos "
"que podem ser importados, bem como todos os os ganchos que podem ser usados "
"para personalizar o sistema de importação. Observe que falhas nesta etapa "
"podem indicar que o módulo não pôde ser localizado *ou* que ocorreu um erro "
"durante a inicialização do módulo, o que inclui a execução do código do "
"módulo."

#: ../../reference/simple_stmts.rst:784
msgid ""
"If the requested module is retrieved successfully, it will be made available "
"in the local namespace in one of three ways:"
msgstr ""
"Se o módulo solicitado for recuperado com sucesso, ele será disponibilizado "
"no espaço de nomes local de três maneiras:"

#: ../../reference/simple_stmts.rst:789
msgid ""
"If the module name is followed by :keyword:`!as`, then the name following :"
"keyword:`!as` is bound directly to the imported module."
msgstr ""
"Se o nome do módulo é seguido pela palavra reservada :keyword:`!as`, o nome "
"a seguir é vinculado diretamente ao módulo importado."

#: ../../reference/simple_stmts.rst:791
msgid ""
"If no other name is specified, and the module being imported is a top level "
"module, the module's name is bound in the local namespace as a reference to "
"the imported module"
msgstr ""
"Se nenhum outro nome for especificado e o módulo que está sendo importado "
"for um módulo de nível superior, o nome do módulo será vinculado ao espaço "
"de nomes local como uma referência ao módulo importado"

#: ../../reference/simple_stmts.rst:794
msgid ""
"If the module being imported is *not* a top level module, then the name of "
"the top level package that contains the module is bound in the local "
"namespace as a reference to the top level package. The imported module must "
"be accessed using its full qualified name rather than directly"
msgstr ""
"Se o módulo que está sendo importado *não* for um módulo de nível superior, "
"o nome do pacote de nível superior que contém o módulo será vinculado ao "
"espaço de nomes local como uma referência ao pacote de nível superior. O "
"módulo importado deve ser acessado usando seu nome completo e não diretamente"

#: ../../reference/simple_stmts.rst:804
msgid "The :keyword:`from` form uses a slightly more complex process:"
msgstr "O formulário :keyword:`from` usa um processo um pouco mais complexo:"

#: ../../reference/simple_stmts.rst:806
msgid ""
"find the module specified in the :keyword:`from` clause, loading and "
"initializing it if necessary;"
msgstr ""
"encontra o módulo especificado na cláusula :keyword:`from`, carregando e "
"inicializando-o se necessário;"

#: ../../reference/simple_stmts.rst:808
msgid "for each of the identifiers specified in the :keyword:`import` clauses:"
msgstr ""
"para cada um dos identificadores especificados nas cláusulas :keyword:"
"`import`:"

#: ../../reference/simple_stmts.rst:810
msgid "check if the imported module has an attribute by that name"
msgstr "verifica se o módulo importado tem um atributo com esse nome"

#: ../../reference/simple_stmts.rst:811
msgid ""
"if not, attempt to import a submodule with that name and then check the "
"imported module again for that attribute"
msgstr ""
"caso contrário, tenta importar um submódulo com esse nome e verifica o "
"módulo importado novamente para esse atributo"

#: ../../reference/simple_stmts.rst:813
msgid "if the attribute is not found, :exc:`ImportError` is raised."
msgstr ""
"se o atributo não for encontrado, a exceção :exc:`ImportError` é levantada."

#: ../../reference/simple_stmts.rst:814
msgid ""
"otherwise, a reference to that value is stored in the local namespace, using "
"the name in the :keyword:`!as` clause if it is present, otherwise using the "
"attribute name"
msgstr ""
"caso contrário, uma referência a esse valor é armazenada no espaço de nomes "
"local, usando o nome na cláusula :keyword:`!as` se estiver presente, caso "
"contrário, usando o nome do atributo"

#: ../../reference/simple_stmts.rst:818
msgid "Examples::"
msgstr "Exemplos::"

#: ../../reference/simple_stmts.rst:820
msgid ""
"import foo                 # foo imported and bound locally\n"
"import foo.bar.baz         # foo, foo.bar, and foo.bar.baz imported, foo "
"bound locally\n"
"import foo.bar.baz as fbb  # foo, foo.bar, and foo.bar.baz imported, foo.bar."
"baz bound as fbb\n"
"from foo.bar import baz    # foo, foo.bar, and foo.bar.baz imported, foo.bar."
"baz bound as baz\n"
"from foo import attr       # foo imported and foo.attr bound as attr"
msgstr ""
"import foo                 # foo importado e vinculado localmente\n"
"import foo.bar.baz         # foo, foo.bar e foo.bar.baz importados, foo "
"vinculado localmente\n"
"import foo.bar.baz as fbb  # foo, foo.bar e foo.bar.baz importados, foo.bar."
"baz vinculado como fbb\n"
"from foo.bar import baz    # foo, foo.bar e foo.bar.baz importados, foo.bar."
"baz vinculado como baz\n"
"from foo import attr       # foo importado e foo.attr vinculado como attr"

#: ../../reference/simple_stmts.rst:828
msgid ""
"If the list of identifiers is replaced by a star (``'*'``), all public names "
"defined in the module are bound in the local namespace for the scope where "
"the :keyword:`import` statement occurs."
msgstr ""
"Se a lista de identificadores for substituída por uma estrela (``'*'``), "
"todos os nomes públicos definidos no módulo serão vinculados ao espaço de "
"nomes local para o escopo onde ocorre a instrução :keyword:`import`."

#: ../../reference/simple_stmts.rst:834
msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must be "
"a sequence of strings which are names defined or imported by that module.  "
"The names given in ``__all__`` are all considered public and are required to "
"exist.  If ``__all__`` is not defined, the set of public names includes all "
"names found in the module's namespace which do not begin with an underscore "
"character (``'_'``).  ``__all__`` should contain the entire public API. It "
"is intended to avoid accidentally exporting items that are not part of the "
"API (such as library modules which were imported and used within the module)."
msgstr ""
"Os *nomes públicos* definidos por um módulo são determinados verificando o "
"espaço de nomes do módulo para uma variável chamada ``__all__``; se "
"definido, deve ser uma sequência de strings que são nomes definidos ou "
"importados por esse módulo. Os nomes dados em ``__all__`` são todos "
"considerados públicos e devem existir. Se ``__all__`` não estiver definido, "
"o conjunto de nomes públicos inclui todos os nomes encontrados no espaço de "
"nomes do módulo que não começam com um caractere sublinhado (``'_'``). "
"``__all__`` deve conter toda a API pública. Destina-se a evitar a exportação "
"acidental de itens que não fazem parte da API (como módulos de biblioteca "
"que foram importados e usados no módulo)."

#: ../../reference/simple_stmts.rst:844
msgid ""
"The wild card form of import --- ``from module import *`` --- is only "
"allowed at the module level.  Attempting to use it in class or function "
"definitions will raise a :exc:`SyntaxError`."
msgstr ""
"A forma curinga de importação --- ``from module import *`` --- só é "
"permitida no nível do módulo. Tentar usá-lo em definições de classe ou "
"função irá levantar uma :exc:`SyntaxError`."

#: ../../reference/simple_stmts.rst:851
msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within "
"another package it is possible to make a relative import within the same top "
"package without having to mention the package name. By using leading dots in "
"the specified module or package after :keyword:`from` you can specify how "
"high to traverse up the current package hierarchy without specifying exact "
"names. One leading dot means the current package where the module making the "
"import exists. Two dots means up one package level. Three dots is up two "
"levels, etc. So if you execute ``from . import mod`` from a module in the "
"``pkg`` package then you will end up importing ``pkg.mod``. If you execute "
"``from ..subpkg2 import mod`` from within ``pkg.subpkg1`` you will import "
"``pkg.subpkg2.mod``. The specification for relative imports is contained in "
"the :ref:`relativeimports` section."
msgstr ""
"Ao especificar qual módulo importar, você não precisa especificar o nome "
"absoluto do módulo. Quando um módulo ou pacote está contido em outro pacote, "
"é possível fazer uma importação relativa dentro do mesmo pacote superior sem "
"precisar mencionar o nome do pacote. Usando pontos iniciais no módulo ou "
"pacote especificado após :keyword:`from` você pode especificar quão alto "
"percorrer a hierarquia de pacotes atual sem especificar nomes exatos. Um "
"ponto inicial significa o pacote atual onde o módulo que faz a importação "
"existe. Dois pontos significam um nível de pacote acima. Três pontos são "
"dois níveis acima, etc. Então, se você executar ``from . import mod`` de um "
"módulo no pacote ``pkg`` então você acabará importando o ``pkg.mod``. Se "
"você executar ``from ..subpkg2 import mod`` de dentro de ``pkg.subpkg1`` "
"você irá importar ``pkg.subpkg2.mod``. A especificação para importações "
"relativas está contida na seção :ref:`relativeimports`."

#: ../../reference/simple_stmts.rst:865
msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine dynamically the modules to be loaded."
msgstr ""
":func:`importlib.import_module` é fornecida para dar suporte a aplicações "
"que determinam dinamicamente os módulos a serem carregados."

#: ../../reference/simple_stmts.rst:868
msgid ""
"Raises an :ref:`auditing event <auditing>` ``import`` with arguments "
"``module``, ``filename``, ``sys.path``, ``sys.meta_path``, ``sys."
"path_hooks``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``import`` com os "
"argumentos ``module``, ``filename``, ``sys.path``, ``sys.meta_path``, ``sys."
"path_hooks``."

#: ../../reference/simple_stmts.rst:873
msgid "Future statements"
msgstr "Instruções future"

#: ../../reference/simple_stmts.rst:879
msgid ""
"A :dfn:`future statement` is a directive to the compiler that a particular "
"module should be compiled using syntax or semantics that will be available "
"in a specified future release of Python where the feature becomes standard."
msgstr ""
"Uma :dfn:`instrução future` é uma diretiva para o compilador de que um "
"determinado módulo deve ser compilado usando sintaxe ou semântica que estará "
"disponível em uma versão futura especificada do Python, onde o recurso se "
"tornará padrão."

#: ../../reference/simple_stmts.rst:883
msgid ""
"The future statement is intended to ease migration to future versions of "
"Python that introduce incompatible changes to the language.  It allows use "
"of the new features on a per-module basis before the release in which the "
"feature becomes standard."
msgstr ""
"A instrução future destina-se a facilitar a migração para versões futuras do "
"Python que introduzem alterações incompatíveis na linguagem. Ele permite o "
"uso dos novos recursos por módulo antes do lançamento em que o recurso se "
"torna padrão."

#: ../../reference/simple_stmts.rst:895
msgid ""
"A future statement must appear near the top of the module.  The only lines "
"that can appear before a future statement are:"
msgstr ""
"Uma instrução future deve aparecer perto do topo do módulo. As únicas linhas "
"que podem aparecer antes de uma instrução future são:"

#: ../../reference/simple_stmts.rst:898
msgid "the module docstring (if any),"
msgstr "o módulo docstring (se houver),"

#: ../../reference/simple_stmts.rst:899
msgid "comments,"
msgstr "omentários,"

#: ../../reference/simple_stmts.rst:900
msgid "blank lines, and"
msgstr "linhas vazias e"

#: ../../reference/simple_stmts.rst:901
msgid "other future statements."
msgstr "outras instruções future."

#: ../../reference/simple_stmts.rst:903
msgid ""
"The only feature that requires using the future statement is ``annotations`` "
"(see :pep:`563`)."
msgstr ""
"O único recurso que requer o uso da instrução future é ``annotations`` "
"(veja :pep:`563`)."

#: ../../reference/simple_stmts.rst:906
msgid ""
"All historical features enabled by the future statement are still recognized "
"by Python 3.  The list includes ``absolute_import``, ``division``, "
"``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` and ``with_statement``.  They are all "
"redundant because they are always enabled, and only kept for backwards "
"compatibility."
msgstr ""
"Todos os recursos históricos habilitados pela instrução future ainda são "
"reconhecidos pelo Python 3. A lista inclui ``absolute_import``, "
"``division``, ``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` e ``with_statement``. Eles são todos "
"redundantes porque estão sempre habilitados e mantidos apenas para "
"compatibilidade com versões anteriores."

#: ../../reference/simple_stmts.rst:913
msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in which "
"case the compiler may need to parse the module differently.  Such decisions "
"cannot be pushed off until runtime."
msgstr ""
"Uma instrução future é reconhecida e tratada especialmente em tempo de "
"compilação: as alterações na semântica das construções principais são "
"frequentemente implementadas gerando código diferente. Pode até ser o caso "
"de um novo recurso introduzir uma nova sintaxe incompatível (como uma nova "
"palavra reservada), caso em que o compilador pode precisar analisar o módulo "
"de maneira diferente. Tais decisões não podem ser adiadas até o tempo de "
"execução."

#: ../../reference/simple_stmts.rst:920
msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a "
"feature not known to it."
msgstr ""
"Para qualquer versão, o compilador sabe quais nomes de recursos foram "
"definidos e levanta um erro em tempo de compilação se uma instrução future "
"contiver um recurso desconhecido."

#: ../../reference/simple_stmts.rst:924
msgid ""
"The direct runtime semantics are the same as for any import statement: there "
"is a standard module :mod:`__future__`, described later, and it will be "
"imported in the usual way at the time the future statement is executed."
msgstr ""
"A semântica do tempo de execução direto é a mesma de qualquer instrução de "
"importação: existe um módulo padrão :mod:`__future__`, descrito "
"posteriormente, e será importado da maneira usual no momento em que a "
"instrução future for executada."

#: ../../reference/simple_stmts.rst:928
msgid ""
"The interesting runtime semantics depend on the specific feature enabled by "
"the future statement."
msgstr ""
"A semântica interessante do tempo de execução depende do recurso específico "
"ativado pela instrução future."

#: ../../reference/simple_stmts.rst:931
msgid "Note that there is nothing special about the statement::"
msgstr "Observe que não há nada de especial sobre a instrução::"

#: ../../reference/simple_stmts.rst:933
msgid "import __future__ [as name]"
msgstr "import __future__ [as name]"

#: ../../reference/simple_stmts.rst:935
msgid ""
"That is not a future statement; it's an ordinary import statement with no "
"special semantics or syntax restrictions."
msgstr ""
"Essa não é uma instrução future; é uma instrução de importação comum sem "
"nenhuma semântica especial ou restrições de sintaxe."

#: ../../reference/simple_stmts.rst:938
msgid ""
"Code compiled by calls to the built-in functions :func:`exec` and :func:"
"`compile` that occur in a module :mod:`!M` containing a future statement "
"will, by default, use the new syntax or semantics associated with the future "
"statement.  This can be controlled by optional arguments to :func:`compile` "
"--- see the documentation of that function for details."
msgstr ""
"O código compilado por chamadas para as funções embutidas :func:`exec` e :"
"func:`compile` que ocorrem em um módulo :mod:`!M` contendo uma instrução "
"future usará, por padrão, a nova sintaxe ou semântica associada com a "
"instrução future. Isso pode ser controlado por argumentos opcionais para :"
"func:`compile` -- veja a documentação dessa função para detalhes."

#: ../../reference/simple_stmts.rst:944
msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute, "
"and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""
"Uma instrução future tipada digitada em um prompt do interpretador "
"interativo terá efeito no restante da sessão do interpretador. Se um "
"interpretador for iniciado com a opção :option:`-i`, for passado um nome de "
"script para ser executado e o script incluir uma instrução future, ela "
"entrará em vigor na sessão interativa iniciada após a execução do script."

#: ../../reference/simple_stmts.rst:952
msgid ":pep:`236` - Back to the __future__"
msgstr ":pep:`236` - De volta ao __future__"

#: ../../reference/simple_stmts.rst:953
msgid "The original proposal for the __future__ mechanism."
msgstr "A proposta original para o mecanismo do __future__."

#: ../../reference/simple_stmts.rst:959
msgid "The :keyword:`!global` statement"
msgstr "A instrução :keyword:`!global`"

#: ../../reference/simple_stmts.rst:969
msgid ""
"The :keyword:`global` statement causes the listed identifiers to be "
"interpreted as globals. It would be impossible to assign to a global "
"variable without :keyword:`!global`, although free variables may refer to "
"globals without being declared global."
msgstr ""
"A instrução :keyword:`global` faz com que os identificadores listados a "
"serem interpretados como globais. Seria impossível atribuir a uma variável "
"global sem :keyword:`!global`, embora variáveis livres possam se referir a "
"globais sem serem declaradas globais."

#: ../../reference/simple_stmts.rst:974
msgid ""
"The :keyword:`global` statement applies to the entire scope of a function or "
"class body. A :exc:`SyntaxError` is raised if a variable is used or assigned "
"to prior to its global declaration in the scope."
msgstr ""
"A instrução :keyword:`global` se aplica a todo o escopo de uma função ou "
"corpo da classe. Uma exceção :exc:`SyntaxError` é levantada se uma variável "
"for usada ou atribuída antes de sua declaração global no escopo."

#: ../../reference/simple_stmts.rst:983
msgid ""
"**Programmer's note:** :keyword:`global` is a directive to the parser.  It "
"applies only to code parsed at the same time as the :keyword:`!global` "
"statement. In particular, a :keyword:`!global` statement contained in a "
"string or code object supplied to the built-in :func:`exec` function does "
"not affect the code block *containing* the function call, and code contained "
"in such a string is unaffected by :keyword:`!global` statements in the code "
"containing the function call.  The same applies to the :func:`eval` and :"
"func:`compile` functions."
msgstr ""
"**Nota do programador:** :keyword:`global` é uma diretiva para o analisador "
"sintático. Aplica-se apenas ao código analisado ao mesmo tempo que a "
"instrução :keyword:`!global`. Em particular, uma instrução :keyword:`!"
"global` contida em uma string ou objeto código fornecido à função embutida :"
"func:`exec` não afeta o bloco de código *contendo* a chamada da função e o "
"código contido em tal uma string não é afetada por instruções :keyword:`!"
"global` no código que contém a chamada da função. O mesmo se aplica às "
"funções :func:`eval` e :func:`compile`."

#: ../../reference/simple_stmts.rst:995
msgid "The :keyword:`!nonlocal` statement"
msgstr "A instrução :keyword:`!nonlocal`"

#: ../../reference/simple_stmts.rst:1003
msgid ""
"When the definition of a function or class is nested (enclosed) within the "
"definitions of other functions, its nonlocal scopes are the local scopes of "
"the enclosing functions. The :keyword:`nonlocal` statement causes the listed "
"identifiers to refer to names previously bound in nonlocal scopes. It allows "
"encapsulated code to rebind such nonlocal identifiers.  If a name is bound "
"in more than one nonlocal scope, the nearest binding is used. If a name is "
"not bound in any nonlocal scope, or if there is no nonlocal scope, a :exc:"
"`SyntaxError` is raised."
msgstr ""
"Quando a definição de uma função ou classe está aninhada (incluída) nas "
"definições de outras funções, seus escopos não locais são os escopos locais "
"das funções envolventes. A instrução :keyword:`nonlocal` faz com que os "
"identificadores listados se refiram a nomes previamente vinculados a escopos "
"não locais. Ele permite que o código encapsulado religue esses "
"identificadores não locais. Se um nome estiver ligado a mais de um escopo "
"não local, a ligação mais próxima será usada. Se um nome não estiver "
"vinculado a nenhum escopo não local, ou se não houver escopo não local, uma "
"exceção :exc:`SyntaxError` será levantada."

#: ../../reference/simple_stmts.rst:1012
msgid ""
"The :keyword:`nonlocal` statement applies to the entire scope of a function "
"or class body. A :exc:`SyntaxError` is raised if a variable is used or "
"assigned to prior to its nonlocal declaration in the scope."
msgstr ""
"A instrução :keyword:`nonlocal` se aplica a todo o escopo de uma função ou "
"corpo da classe. Uma exceção :exc:`SyntaxError` é levantada se uma variável "
"for usada ou atribuída antes de sua declaração nonlocal no escopo."

#: ../../reference/simple_stmts.rst:1018
msgid ":pep:`3104` - Access to Names in Outer Scopes"
msgstr ":pep:`3104` - Acesso a nomes em escopos externos"

#: ../../reference/simple_stmts.rst:1019
msgid "The specification for the :keyword:`nonlocal` statement."
msgstr "A especificação para a instrução :keyword:`nonlocal`."

#: ../../reference/simple_stmts.rst:1021
msgid ""
"**Programmer's note:** :keyword:`nonlocal` is a directive to the parser and "
"applies only to code parsed along with it.  See the note for the :keyword:"
"`global` statement."
msgstr ""
"**Nota do programador:** :keyword:`nonlocal` é uma diretiva para o "
"analisador sintático e se aplica apenas ao código analisado junto com ele. "
"Veja a nota para a instrução :keyword:`global`."

#: ../../reference/simple_stmts.rst:1029
msgid "The :keyword:`!type` statement"
msgstr "A instrução :keyword:`!type`"

#: ../../reference/simple_stmts.rst:1036
msgid ""
"The :keyword:`!type` statement declares a type alias, which is an instance "
"of :class:`typing.TypeAliasType`."
msgstr ""
"A instrução :keyword:`!type` declara um apelido de tipo, que é uma instância "
"de :class:`typing.TypeAliasType`."

#: ../../reference/simple_stmts.rst:1039
msgid "For example, the following statement creates a type alias::"
msgstr "Por exemplo, a instrução a seguir cria um apelido de tipo::"

#: ../../reference/simple_stmts.rst:1041
msgid "type Point = tuple[float, float]"
msgstr "type Point = tuple[float, float]"

#: ../../reference/simple_stmts.rst:1043
msgid "This code is roughly equivalent to::"
msgstr "Este código é aproximadamente equivalente a::"

#: ../../reference/simple_stmts.rst:1045
msgid ""
"annotation-def VALUE_OF_Point():\n"
"    return tuple[float, float]\n"
"Point = typing.TypeAliasType(\"Point\", VALUE_OF_Point())"
msgstr ""
"annotation-def VALUE_OF_Point():\n"
"    return tuple[float, float]\n"
"Point = typing.TypeAliasType(\"Point\", VALUE_OF_Point())"

#: ../../reference/simple_stmts.rst:1049
msgid ""
"``annotation-def`` indicates an :ref:`annotation scope <annotation-scopes>`, "
"which behaves mostly like a function, but with several small differences."
msgstr ""
"``annotation-def`` indica um :ref:`escopo de anotação <annotation-scopes>`, "
"que se comporta principalmente como uma função, mas com diversas pequenas "
"diferenças."

#: ../../reference/simple_stmts.rst:1052
msgid ""
"The value of the type alias is evaluated in the annotation scope. It is not "
"evaluated when the type alias is created, but only when the value is "
"accessed through the type alias's :attr:`!__value__` attribute (see :ref:"
"`lazy-evaluation`). This allows the type alias to refer to names that are "
"not yet defined."
msgstr ""
"O valor do apelido de tipo é avaliado no escopo de anotação. Ele não é "
"avaliado quando o apelido de tipo é criado, mas somente quando o valor é "
"acessado através do atributo :attr:`!__value__` do apelido de tipo (veja :"
"ref:`lazy-evaluation`). Isso permite que o apelido de tipo se refira a nomes "
"que ainda não estão definidos."

#: ../../reference/simple_stmts.rst:1058
msgid ""
"Type aliases may be made generic by adding a :ref:`type parameter list <type-"
"params>` after the name. See :ref:`generic-type-aliases` for more."
msgstr ""
"Apelidos de tipo podem se tornar genéricos adicionando uma :ref:`lista de "
"parâmetros de tipo <type-params>` após o nome. Veja :ref:`generic-type-"
"aliases` para mais."

#: ../../reference/simple_stmts.rst:1061
msgid ":keyword:`!type` is a :ref:`soft keyword <soft-keywords>`."
msgstr ""
":keyword:`!type` é uma :ref:`palavra reservada contextual <soft-keywords>`."

#: ../../reference/simple_stmts.rst:1067
msgid ":pep:`695` - Type Parameter Syntax"
msgstr ":pep:`695` - Sintaxe de parâmetros de tipo"

#: ../../reference/simple_stmts.rst:1068
msgid ""
"Introduced the :keyword:`!type` statement and syntax for generic classes and "
"functions."
msgstr ""
"Introduziu a instrução :keyword:`!type` e sintaxe para classes e funções "
"genéricas."

#: ../../reference/simple_stmts.rst:8
msgid "simple"
msgstr "simples"

#: ../../reference/simple_stmts.rst:8 ../../reference/simple_stmts.rst:39
#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:263
#: ../../reference/simple_stmts.rst:322 ../../reference/simple_stmts.rst:384
#: ../../reference/simple_stmts.rst:427 ../../reference/simple_stmts.rst:449
#: ../../reference/simple_stmts.rst:462 ../../reference/simple_stmts.rst:488
#: ../../reference/simple_stmts.rst:525 ../../reference/simple_stmts.rst:561
#: ../../reference/simple_stmts.rst:686 ../../reference/simple_stmts.rst:720
#: ../../reference/simple_stmts.rst:745 ../../reference/simple_stmts.rst:875
#: ../../reference/simple_stmts.rst:961 ../../reference/simple_stmts.rst:997
#: ../../reference/simple_stmts.rst:1031
msgid "statement"
msgstr "instrução"

#: ../../reference/simple_stmts.rst:39 ../../reference/simple_stmts.rst:42
msgid "expression"
msgstr "expressão"

#: ../../reference/simple_stmts.rst:39 ../../reference/simple_stmts.rst:42
#: ../../reference/simple_stmts.rst:105 ../../reference/simple_stmts.rst:116
#: ../../reference/simple_stmts.rst:196 ../../reference/simple_stmts.rst:449
msgid "list"
msgstr "lista"

#: ../../reference/simple_stmts.rst:56 ../../reference/simple_stmts.rst:978
msgid "built-in function"
msgstr "função embutida"

#: ../../reference/simple_stmts.rst:56
msgid "repr"
msgstr "repr"

#: ../../reference/simple_stmts.rst:56 ../../reference/simple_stmts.rst:75
#: ../../reference/simple_stmts.rst:187 ../../reference/simple_stmts.rst:196
#: ../../reference/simple_stmts.rst:207 ../../reference/simple_stmts.rst:583
msgid "object"
msgstr "objeto"

#: ../../reference/simple_stmts.rst:56
msgid "None"
msgstr "None"

#: ../../reference/simple_stmts.rst:56
msgid "string"
msgstr "string"

#: ../../reference/simple_stmts.rst:56
msgid "conversion"
msgstr "conversão"

#: ../../reference/simple_stmts.rst:56
msgid "output"
msgstr "saída"

#: ../../reference/simple_stmts.rst:56
msgid "standard"
msgstr "padrão"

#: ../../reference/simple_stmts.rst:56
msgid "writing"
msgstr "escrita; gravação"

#: ../../reference/simple_stmts.rst:56
msgid "values"
msgstr "valores"

#: ../../reference/simple_stmts.rst:56
msgid "procedure"
msgstr "procedimento"

#: ../../reference/simple_stmts.rst:56
msgid "call"
msgstr "chamada"

#: ../../reference/simple_stmts.rst:75
msgid "= (equals)"
msgstr "= (igual)"

#: ../../reference/simple_stmts.rst:75
msgid "assignment statement"
msgstr "atribuição, instrução de"

#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:116
#: ../../reference/simple_stmts.rst:159 ../../reference/simple_stmts.rst:187
#: ../../reference/simple_stmts.rst:220 ../../reference/simple_stmts.rst:263
#: ../../reference/simple_stmts.rst:322
msgid "assignment"
msgstr "atribuição"

#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:745
#: ../../reference/simple_stmts.rst:800 ../../reference/simple_stmts.rst:961
msgid "binding"
msgstr "vinculação; ligação"

#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:462
#: ../../reference/simple_stmts.rst:745 ../../reference/simple_stmts.rst:800
#: ../../reference/simple_stmts.rst:961
msgid "name"
msgstr "nome"

#: ../../reference/simple_stmts.rst:75
msgid "rebinding"
msgstr "nova vinculação; nova ligação"

#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:187
msgid "mutable"
msgstr "mutável"

#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:159
#: ../../reference/simple_stmts.rst:471
msgid "attribute"
msgstr "atributo"

#: ../../reference/simple_stmts.rst:105 ../../reference/simple_stmts.rst:116
#: ../../reference/simple_stmts.rst:449 ../../reference/simple_stmts.rst:699
msgid "target"
msgstr "alvo"

#: ../../reference/simple_stmts.rst:116 ../../reference/simple_stmts.rst:384
#: ../../reference/simple_stmts.rst:745 ../../reference/simple_stmts.rst:961
#: ../../reference/simple_stmts.rst:997
msgid ", (comma)"
msgstr ", (vírgula)"

#: ../../reference/simple_stmts.rst:116
msgid "in target list"
msgstr "na lista de alvos"

#: ../../reference/simple_stmts.rst:116 ../../reference/simple_stmts.rst:826
msgid "* (asterisk)"
msgstr "* (asterisco)"

#: ../../reference/simple_stmts.rst:116
msgid "in assignment target list"
msgstr "na lista de alvo de atribuição"

#: ../../reference/simple_stmts.rst:116
msgid "[] (square brackets)"
msgstr "[] (colchetes)"

#: ../../reference/simple_stmts.rst:116
msgid "() (parentheses)"
msgstr "() (parênteses)"

#: ../../reference/simple_stmts.rst:153
msgid "destructor"
msgstr "destrutor"

#: ../../reference/simple_stmts.rst:187
msgid "subscription"
msgstr "subscrição"

#: ../../reference/simple_stmts.rst:196
msgid "sequence"
msgstr "sequência"

#: ../../reference/simple_stmts.rst:207
msgid "mapping"
msgstr "mapeamento"

#: ../../reference/simple_stmts.rst:207
msgid "dictionary"
msgstr "dicionário"

#: ../../reference/simple_stmts.rst:220
msgid "slicing"
msgstr "fatiamento"

#: ../../reference/simple_stmts.rst:263
msgid "augmented"
msgstr "aumentada"

#: ../../reference/simple_stmts.rst:263
msgid "assignment, augmented"
msgstr "aumentada, atribuição"

#: ../../reference/simple_stmts.rst:263
msgid "+="
msgstr "+="

#: ../../reference/simple_stmts.rst:263
msgid "augmented assignment"
msgstr "atribuição aumentada"

#: ../../reference/simple_stmts.rst:263
msgid "-="
msgstr "-="

#: ../../reference/simple_stmts.rst:263
msgid "*="
msgstr "*="

#: ../../reference/simple_stmts.rst:263
msgid "/="
msgstr "/="

#: ../../reference/simple_stmts.rst:263
msgid "%="
msgstr "%="

#: ../../reference/simple_stmts.rst:263
msgid "&="
msgstr "&="

#: ../../reference/simple_stmts.rst:263
msgid "^="
msgstr "^="

#: ../../reference/simple_stmts.rst:263
msgid "|="
msgstr "|="

#: ../../reference/simple_stmts.rst:263
msgid "**="
msgstr "**="

#: ../../reference/simple_stmts.rst:263
msgid "//="
msgstr "//="

#: ../../reference/simple_stmts.rst:263
msgid ">>="
msgstr ">>="

#: ../../reference/simple_stmts.rst:263
msgid "<<="
msgstr "<<="

#: ../../reference/simple_stmts.rst:322
msgid "annotated"
msgstr "anotada"

#: ../../reference/simple_stmts.rst:322
msgid "assignment, annotated"
msgstr "atribuição, anotada"

#: ../../reference/simple_stmts.rst:322
msgid ": (colon)"
msgstr ": (dois pontos)"

#: ../../reference/simple_stmts.rst:322
msgid "annotated variable"
msgstr "anotada, variável"

#: ../../reference/simple_stmts.rst:384
msgid "assert"
msgstr "assert"

#: ../../reference/simple_stmts.rst:384
msgid "debugging"
msgstr "depuração"

#: ../../reference/simple_stmts.rst:384
msgid "assertions"
msgstr "asserções"

#: ../../reference/simple_stmts.rst:384
msgid "expression list"
msgstr "expressão, lista de"

#: ../../reference/simple_stmts.rst:405
msgid "__debug__"
msgstr "__debug__"

#: ../../reference/simple_stmts.rst:405 ../../reference/simple_stmts.rst:525
#: ../../reference/simple_stmts.rst:561 ../../reference/simple_stmts.rst:593
#: ../../reference/simple_stmts.rst:745
msgid "exception"
msgstr "exceção"

#: ../../reference/simple_stmts.rst:405
msgid "AssertionError"
msgstr "AssertionError"

#: ../../reference/simple_stmts.rst:427
msgid "pass"
msgstr "pass"

#: ../../reference/simple_stmts.rst:427
msgid "null"
msgstr "null"

#: ../../reference/simple_stmts.rst:427
msgid "operation"
msgstr "operação"

#: ../../reference/simple_stmts.rst:449
msgid "del"
msgstr "del"

#: ../../reference/simple_stmts.rst:449 ../../reference/simple_stmts.rst:471
msgid "deletion"
msgstr "exclusão"

#: ../../reference/simple_stmts.rst:462 ../../reference/simple_stmts.rst:961
msgid "global"
msgstr "global"

#: ../../reference/simple_stmts.rst:462
msgid "unbinding"
msgstr "desvinculação"

#: ../../reference/simple_stmts.rst:488
msgid "return"
msgstr "return"

#: ../../reference/simple_stmts.rst:488 ../../reference/simple_stmts.rst:525
msgid "function"
msgstr "função"

#: ../../reference/simple_stmts.rst:488
msgid "definition"
msgstr "definição"

#: ../../reference/simple_stmts.rst:488
msgid "class"
msgstr "classe"

#: ../../reference/simple_stmts.rst:504 ../../reference/simple_stmts.rst:699
#: ../../reference/simple_stmts.rst:708 ../../reference/simple_stmts.rst:720
#: ../../reference/simple_stmts.rst:745
msgid "keyword"
msgstr "palavra reservada"

#: ../../reference/simple_stmts.rst:504 ../../reference/simple_stmts.rst:708
#: ../../reference/simple_stmts.rst:720
msgid "finally"
msgstr "finally"

#: ../../reference/simple_stmts.rst:525
msgid "yield"
msgstr "yield"

#: ../../reference/simple_stmts.rst:525
msgid "generator"
msgstr "gerador"

#: ../../reference/simple_stmts.rst:525
msgid "iterator"
msgstr "iterador"

#: ../../reference/simple_stmts.rst:525
msgid "StopIteration"
msgstr "StopIteration"

#: ../../reference/simple_stmts.rst:561
msgid "raise"
msgstr "raise"

#: ../../reference/simple_stmts.rst:561
msgid "raising"
msgstr "levantamento"

#: ../../reference/simple_stmts.rst:561
msgid "__traceback__ (exception attribute)"
msgstr "__traceback__ (atributo de exceção)"

#: ../../reference/simple_stmts.rst:583
msgid "traceback"
msgstr "traceback"

#: ../../reference/simple_stmts.rst:593
msgid "chaining"
msgstr "encadeamento"

#: ../../reference/simple_stmts.rst:593
msgid "__cause__ (exception attribute)"
msgstr "__cause__ (atributo de exceção)"

#: ../../reference/simple_stmts.rst:593
msgid "__context__ (exception attribute)"
msgstr "__context__ (atributo de exceção)"

#: ../../reference/simple_stmts.rst:686
msgid "break"
msgstr "break"

#: ../../reference/simple_stmts.rst:686 ../../reference/simple_stmts.rst:720
msgid "for"
msgstr "for"

#: ../../reference/simple_stmts.rst:686 ../../reference/simple_stmts.rst:720
msgid "while"
msgstr "while"

#: ../../reference/simple_stmts.rst:686 ../../reference/simple_stmts.rst:720
msgid "loop"
msgstr "laço"

#: ../../reference/simple_stmts.rst:699
msgid "else"
msgstr "else"

#: ../../reference/simple_stmts.rst:699
msgid "loop control"
msgstr "controle de laço"

#: ../../reference/simple_stmts.rst:720
msgid "continue"
msgstr "continue"

#: ../../reference/simple_stmts.rst:745 ../../reference/simple_stmts.rst:848
msgid "import"
msgstr "import"

#: ../../reference/simple_stmts.rst:745
msgid "module"
msgstr "módulo"

#: ../../reference/simple_stmts.rst:745
msgid "importing"
msgstr "importação"

#: ../../reference/simple_stmts.rst:745 ../../reference/simple_stmts.rst:800
msgid "from"
msgstr "from"

#: ../../reference/simple_stmts.rst:745 ../../reference/simple_stmts.rst:787
msgid "as"
msgstr "as"

#: ../../reference/simple_stmts.rst:745
msgid "ImportError"
msgstr "ImportError"

#: ../../reference/simple_stmts.rst:745 ../../reference/simple_stmts.rst:787
#: ../../reference/simple_stmts.rst:800 ../../reference/simple_stmts.rst:826
msgid "import statement"
msgstr "instrução import"

#: ../../reference/simple_stmts.rst:832
msgid "__all__ (optional module attribute)"
msgstr "__all__ (atributo opcional de módulo)"

#: ../../reference/simple_stmts.rst:848
msgid "relative"
msgstr "relativa"

#: ../../reference/simple_stmts.rst:875
msgid "future"
msgstr "future"

#: ../../reference/simple_stmts.rst:875
msgid "__future__"
msgstr "__future__"

#: ../../reference/simple_stmts.rst:875
msgid "future statement"
msgstr "instrução future"

#: ../../reference/simple_stmts.rst:961 ../../reference/simple_stmts.rst:997
msgid "identifier list"
msgstr "identificadores, lista de"

#: ../../reference/simple_stmts.rst:978
msgid "exec"
msgstr "exec"

#: ../../reference/simple_stmts.rst:978
msgid "eval"
msgstr "eval"

#: ../../reference/simple_stmts.rst:978
msgid "compile"
msgstr "compile"

#: ../../reference/simple_stmts.rst:997
msgid "nonlocal"
msgstr "nonlocal"

#: ../../reference/simple_stmts.rst:1031
msgid "type"
msgstr "tipo"

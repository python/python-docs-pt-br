# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-09 18:46+0900\n"
"PO-Revision-Date: 2020-02-29 02:00+0000\n"
"Last-Translator: Marco Rougeth <marco@rougeth.com>\n"
"Language-Team: Portuguese (Brazil) (http://www.transifex.com/python-doc/"
"python-27/language/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../reference/datamodel.rst:6
msgid "Data model"
msgstr "Modelo de dados"

#: ../../reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr "Objetos, valores e tipos"

#: ../../reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer,\" code is also represented by objects.)"
msgstr ""
":dfn:`Objetos` são abstrações do Python para dados. Todo dados em um "
"programa Python, é representados por objetos ou por relações entre objetos."
"(De certo modo, e em conformidade com o modelo de Von Neumann em \"stored "
"program computer,\" código também é representado por objetos.)"

#: ../../reference/datamodel.rst:32
msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The ':keyword:`is`' operator compares the identity of "
"two objects; the :func:`id` function returns an integer representing its "
"identity (currently implemented as its address). An object's :dfn:`type` is "
"also unchangeable. [#]_ An object's type determines the operations that the "
"object supports (e.g., \"does it have a length?\") and also defines the "
"possible values for objects of that type.  The :func:`type` function returns "
"an object's type (which is an object itself).  The *value* of some objects "
"can change.  Objects whose value can change are said to be *mutable*; "
"objects whose value is unchangeable once they are created are called "
"*immutable*. (The value of an immutable container object that contains a "
"reference to a mutable object can change when the latter's value is changed; "
"however the container is still considered immutable, because the collection "
"of objects it contains cannot be changed.  So, immutability is not strictly "
"the same as having an unchangeable value, it is more subtle.) An object's "
"mutability is determined by its type; for instance, numbers, strings and "
"tuples are immutable, while dictionaries and lists are mutable."
msgstr ""

#: ../../reference/datamodel.rst:55
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr ""
"Os objetos nunca são destruídos explicitamente; no entanto, quando eles se "
"tornam inacessíveis, eles podem ser coletados como lixo. Uma implementação "
"tem permissão para adiar a coleta de lixo ou omiti-la completamente -- é uma "
"questão de qualidade de implementação como a coleta de lixo é implementada, "
"desde que nenhum objeto seja coletado que ainda esteja acessível."

#: ../../reference/datamodel.rst:63
msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (ex: "
"always close files)."
msgstr ""

#: ../../reference/datamodel.rst:72
msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a ':keyword:`try`...\\ :keyword:`except`' "
"statement may keep objects alive."
msgstr ""
"Observe que o uso dos recursos de rastreamento ou depuração da implementação "
"pode manter os objetos ativos que normalmente seriam coletáveis. Observe "
"também que capturar uma exceção com uma instrução \":keyword:`try`...\\ :"
"keyword:`except`\" pode manter os objetos vivos."

#: ../../reference/datamodel.rst:77
msgid ""
"Some objects contain references to \"external\" resources such as open files "
"or windows.  It is understood that these resources are freed when the object "
"is garbage-collected, but since garbage collection is not guaranteed to "
"happen, such objects also provide an explicit way to release the external "
"resource, usually a :meth:`close` method. Programs are strongly recommended "
"to explicitly close such objects.  The ':keyword:`try`...\\ :keyword:"
"`finally`' statement provides a convenient way to do this."
msgstr ""

#: ../../reference/datamodel.rst:87
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk "
"about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr ""
"Alguns objetos contêm referências a outros objetos; eles são chamados de "
"*contêineres*. Exemplos de contêineres são tuplas, listas e dicionários. As "
"referências fazem parte do valor de um contêiner. Na maioria dos casos, "
"quando falamos sobre o valor de um contêiner, nos referimos aos valores, não "
"às identidades dos objetos contidos; entretanto, quando falamos sobre a "
"mutabilidade de um contêiner, apenas as identidades dos objetos contidos "
"imediatamente estão implícitas. Portanto, se um contêiner imutável (como uma "
"tupla) contém uma referência a um objeto mutável, seu valor muda se esse "
"objeto mutável for alterado."

#: ../../reference/datamodel.rst:96
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed.  E.g., after ``a = 1; b = 1``, ``a`` and ``b`` may or may not refer "
"to the same object with the value one, depending on the implementation, but "
"after ``c = []; d = []``, ``c`` and ``d`` are guaranteed to refer to two "
"different, unique, newly created empty lists. (Note that ``c = d = []`` "
"assigns the same object to both ``c`` and ``d``.)"
msgstr ""
"Os tipos afetam quase todos os aspectos do comportamento do objeto. Até "
"mesmo a importância da identidade do objeto é afetada em algum sentido: para "
"tipos imutáveis, as operações que calculam novos valores podem realmente "
"retornar uma referência a qualquer objeto existente com o mesmo tipo e "
"valor, enquanto para objetos mutáveis isso não é permitido. Por exemplo, "
"após ``a = 1; b = 1``, ``a`` e ``b`` podem ou não se referir ao mesmo objeto "
"com o valor um, dependendo da implementação, mas após ``c = []; d = []``, "
"``c`` e ``d`` têm a garantia de referir-se a duas listas vazias diferentes e "
"únicas. (Observe que ``c = d = []`` atribui o mesmo objeto para ``c`` e "
"``d``.)"

#: ../../reference/datamodel.rst:110
msgid "The standard type hierarchy"
msgstr "A hierarquia de tipos padrão "

#: ../../reference/datamodel.rst:119
msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the "
"type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.)."
msgstr ""

#: ../../reference/datamodel.rst:129
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation "
"and are not intended for general use.  Their definition may change in the "
"future."
msgstr ""
"Algumas das descrições de tipo abaixo contêm um parágrafo listando "
"\"atributos especiais\". Esses são atributos que fornecem acesso à "
"implementação e não se destinam ao uso geral. Sua definição pode mudar no "
"futuro."

#: ../../reference/datamodel.rst:139
msgid "None"
msgstr "None"

#: ../../reference/datamodel.rst:136
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from "
"functions that don't explicitly return anything. Its truth value is false."
msgstr ""
"Este tipo possui um único valor. Existe um único objeto com este valor. Este "
"objeto é acessado através do nome embutido ``None``. É usado para significar "
"a ausência de um valor em muitas situações, por exemplo, ele é retornado de "
"funções que não retornam nada explicitamente. Seu valor de verdade é falso."

#: ../../reference/datamodel.rst:149
msgid "NotImplemented"
msgstr "NotImplemented"

#: ../../reference/datamodel.rst:144
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``NotImplemented``. "
"Numeric methods and rich comparison methods may return this value if they do "
"not implement the operation for the operands provided.  (The interpreter "
"will then try the reflected operation, or some other fallback, depending on "
"the operator.)  Its truth value is true."
msgstr ""

#: ../../reference/datamodel.rst:157
msgid "Ellipsis"
msgstr "Ellipsis"

#: ../../reference/datamodel.rst:154
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``Ellipsis``. It is used "
"to indicate the presence of the ``...`` syntax in a slice.  Its truth value "
"is true."
msgstr ""

#: ../../reference/datamodel.rst:249
msgid ":class:`numbers.Number`"
msgstr ":class:`numbers.Number`"

#: ../../reference/datamodel.rst:162
msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable; "
"once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr ""
"Eles são criados por literais numéricos e retornados como resultados por "
"operadores aritméticos e funções aritméticas integradas. Os objetos "
"numéricos são imutáveis; uma vez criado, seu valor nunca muda. Os números do "
"Python são, obviamente, fortemente relacionados aos números matemáticos, mas "
"sujeitos às limitações da representação numérica em computadores."

#: ../../reference/datamodel.rst:168
msgid ""
"Python distinguishes between integers, floating point numbers, and complex "
"numbers:"
msgstr ""
"Python distingue entre inteiros, números de ponto flutuante e números "
"complexos:"

#: ../../reference/datamodel.rst:224
msgid ":class:`numbers.Integral`"
msgstr ":class:`numbers.Integral`"

#: ../../reference/datamodel.rst:174
msgid ""
"These represent elements from the mathematical set of integers (positive and "
"negative)."
msgstr ""
"Estes representam elementos do conjunto matemático de inteiros (positivos e "
"negativos)."

#: ../../reference/datamodel.rst:177
msgid "There are three types of integers:"
msgstr ""

#: ../../reference/datamodel.rst:192
msgid "Plain integers"
msgstr ""

#: ../../reference/datamodel.rst:184
msgid ""
"These represent numbers in the range -2147483648 through 2147483647. (The "
"range may be larger on machines with a larger natural word size, but not "
"smaller.)  When the result of an operation would fall outside this range, "
"the result is normally returned as a long integer (in some cases, the "
"exception :exc:`OverflowError` is raised instead).  For the purpose of shift "
"and mask operations, integers are assumed to have a binary, 2's complement "
"notation using 32 or more bits, and hiding no bits from the user (i.e., all "
"4294967296 different bit patterns correspond to different values)."
msgstr ""

#: ../../reference/datamodel.rst:201
msgid "Long integers"
msgstr ""

#: ../../reference/datamodel.rst:197
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr ""
"Eles representam números em um intervalo ilimitado, sujeito apenas à memória "
"(virtual) disponível. Para o propósito de operações de deslocamento e "
"máscara, uma representação binária é assumida e os números negativos são "
"representados em uma variante do complemento de 2 que dá a ilusão de uma "
"string infinita de bits de sinal estendendo-se para a esquerda."

#: ../../reference/datamodel.rst:214
msgid "Booleans"
msgstr ""

#: ../../reference/datamodel.rst:209
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean objects. "
"The Boolean type is a subtype of plain integers, and Boolean values behave "
"like the values 0 and 1, respectively, in almost all contexts, the exception "
"being that when converted to a string, the strings ``\"False\"`` or ``\"True"
"\"`` are returned, respectively."
msgstr ""

#: ../../reference/datamodel.rst:218
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers and the least surprises when switching between the plain and long "
"integer domains.  Any operation, if it yields a result in the plain integer "
"domain, will yield the same result in the long integer domain or when using "
"mixed operands.  The switch between domains is transparent to the programmer."
msgstr ""

#: ../../reference/datamodel.rst:239
msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ":class:`numbers.Real` (:class:`float`)"

#: ../../reference/datamodel.rst:233
msgid ""
"These represent machine-level double precision floating point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does "
"not support single-precision floating point numbers; the savings in "
"processor and memory usage that are usually the reason for using these are "
"dwarfed by the overhead of using objects in Python, so there is no reason to "
"complicate the language with two kinds of floating point numbers."
msgstr ""
"Eles representam números de ponto flutuante de precisão dupla no nível da "
"máquina. Você está à mercê da arquitetura da máquina subjacente (e "
"implementação C ou Java) para o intervalo aceito e tratamento de estouro. "
"Python não oferece suporte a números de ponto flutuante de precisão única; a "
"economia no uso do processador e da memória, que normalmente é o motivo de "
"usá-los, é ofuscada pela sobrecarga do uso de objetos em Python, portanto, "
"não há razão para complicar a linguagem com dois tipos de números de ponto "
"flutuante."

#: ../../reference/datamodel.rst:249
msgid ":class:`numbers.Complex`"
msgstr ""

#: ../../reference/datamodel.rst:246
msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating point numbers.  The same caveats apply as for floating point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr ""
"Eles representam números complexos como um par de números de ponto flutuante "
"de precisão dupla no nível da máquina. As mesmas advertências se aplicam aos "
"números de ponto flutuante. As partes reais e imaginárias de um número "
"complexo ``z`` podem ser recuperadas através dos atributos somente leitura "
"``z.real`` e ``z.imag``."

#: ../../reference/datamodel.rst:386
msgid "Sequences"
msgstr "Sequências"

#: ../../reference/datamodel.rst:259
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``."
msgstr ""
"Eles representam conjuntos ordenados finitos indexados por números não "
"negativos. A função embutida :func:`len` retorna o número de itens de uma "
"sequência. Quando o comprimento de uma sequência é *n*, o conjunto de "
"índices contém os números 0, 1, ..., *n*-1. O item *i* da sequência *a* é "
"selecionado por ``a[i]``."

#: ../../reference/datamodel.rst:266
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type.  This implies that the index set is renumbered "
"so that it starts at 0."
msgstr ""
"Sequências também suportam fatiamento: ``a[i:j]`` seleciona todos os itens "
"com índice *k* de forma que *i* ``<=`` *k* ``<`` *j*. Quando usada como "
"expressão, uma fatia é uma sequência do mesmo tipo. Isso implica que o "
"conjunto de índices é renumerado para que comece em 0."

#: ../../reference/datamodel.rst:273
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""
"Algumas sequências também suportam \"fatiamento estendido\" com um terceiro "
"parâmetro de \"etapa\": ``a[i:j:k]`` seleciona todos os itens de *a* com "
"índice *x* onde ``x = i + n*k``, *n* ``>=`` ``0`` e *i* ``<=`` *x* ``<`` *j*."

#: ../../reference/datamodel.rst:277
msgid "Sequences are distinguished according to their mutability:"
msgstr "As sequências são distinguidas de acordo com sua mutabilidade:"

#: ../../reference/datamodel.rst:352
msgid "Immutable sequences"
msgstr "Sequências Imutáveis"

#: ../../reference/datamodel.rst:284
msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may "
"be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr ""
"Um objeto de um tipo de sequência imutável não pode ser alterado depois de "
"criado. (Se o objeto contiver referências a outros objetos, esses outros "
"objetos podem ser mutáveis e podem ser alterados; no entanto, a coleção de "
"objetos diretamente referenciada por um objeto imutável não pode ser "
"alterada.)"

#: ../../reference/datamodel.rst:289
msgid "The following types are immutable sequences:"
msgstr "Os tipos a seguir são sequências imutáveis:"

#: ../../reference/datamodel.rst:319
msgid "Strings"
msgstr "Strings"

#: ../../reference/datamodel.rst:300
msgid ""
"The items of a string are characters.  There is no separate character type; "
"a character is represented by a string of one item. Characters represent (at "
"least) 8-bit bytes.  The built-in functions :func:`chr` and :func:`ord` "
"convert between characters and nonnegative integers representing the byte "
"values.  Bytes with the values 0--127 usually represent the corresponding "
"ASCII values, but the interpretation of values is up to the program.  The "
"string data type is also used to represent arrays of bytes, e.g., to hold "
"data read from a file."
msgstr ""

#: ../../reference/datamodel.rst:316
msgid ""
"(On systems whose native character set is not ASCII, strings may use EBCDIC "
"in their internal representation, provided the functions :func:`chr` and :"
"func:`ord` implement a mapping between ASCII and EBCDIC, and string "
"comparison preserves the ASCII order. Or perhaps someone can propose a "
"better rule?)"
msgstr ""

#: ../../reference/datamodel.rst:340
msgid "Unicode"
msgstr "Unicode"

#: ../../reference/datamodel.rst:331
msgid ""
"The items of a Unicode object are Unicode code units.  A Unicode code unit "
"is represented by a Unicode object of one item and can hold either a 16-bit "
"or 32-bit value representing a Unicode ordinal (the maximum value for the "
"ordinal is given in ``sys.maxunicode``, and depends on how Python is "
"configured at compile time).  Surrogate pairs may be present in the Unicode "
"object, and will be reported as two separate items.  The built-in functions :"
"func:`unichr` and :func:`ord` convert between code units and nonnegative "
"integers representing the Unicode ordinals as defined in the Unicode "
"Standard 3.0. Conversion from and to other encodings are possible through "
"the Unicode method :meth:`encode` and the built-in function :func:`unicode`."
msgstr ""

#: ../../reference/datamodel.rst:352
msgid "Tuples"
msgstr "Tuplas"

#: ../../reference/datamodel.rst:348
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr ""
"Os itens de uma tupla são objetos Python arbitrários. Tuplas de dois ou mais "
"itens são formadas por listas de expressões separadas por vírgulas. Uma "
"tupla de um item (um \"singleton\") pode ser formada afixando uma vírgula a "
"uma expressão (uma expressão por si só não cria uma tupla, já que os "
"parênteses devem ser usados para agrupamento de expressões). Uma tupla vazia "
"pode ser formada por um par vazio de parênteses."

#: ../../reference/datamodel.rst:386
msgid "Mutable sequences"
msgstr "Sequências Mutáveis"

#: ../../reference/datamodel.rst:362
msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment and :keyword:"
"`del` (delete) statements."
msgstr ""
"As sequências mutáveis podem ser alteradas após serem criadas. As notações "
"de assinatura e fatiamento podem ser usadas como o destino da atribuição e "
"instruções :keyword:`del` (*delete*, exclusão)."

#: ../../reference/datamodel.rst:366
msgid "There are currently two intrinsic mutable sequence types:"
msgstr "Atualmente, existem dois tipos de sequência mutável intrínseca:"

#: ../../reference/datamodel.rst:373
msgid "Lists"
msgstr "Listas"

#: ../../reference/datamodel.rst:371
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that "
"there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""
"Os itens de uma lista são objetos Python arbitrários. As listas são formadas "
"colocando uma lista separada por vírgulas de expressões entre colchetes. "
"(Observe que não há casos especiais necessários para formar listas de "
"comprimento 0 ou 1.)"

#: ../../reference/datamodel.rst:381
msgid "Byte Arrays"
msgstr "Arrays de Bytes"

#: ../../reference/datamodel.rst:378
msgid ""
"A bytearray object is a mutable array. They are created by the built-in :"
"func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable bytes objects."
msgstr ""

#: ../../reference/datamodel.rst:385
msgid ""
"The extension module :mod:`array` provides an additional example of a "
"mutable sequence type."
msgstr ""

#: ../../reference/datamodel.rst:420
msgid "Set types"
msgstr "Tipo Conjunto"

#: ../../reference/datamodel.rst:393
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated "
"over, and the built-in function :func:`len` returns the number of items in a "
"set. Common uses for sets are fast membership testing, removing duplicates "
"from a sequence, and computing mathematical operations such as intersection, "
"union, difference, and symmetric difference."
msgstr ""
"Eles representam conjuntos finitos e não ordenados de objetos únicos e "
"imutáveis. Como tal, eles não podem ser indexados por nenhum subscrito. No "
"entanto, eles podem ser iterados, e a função embutida :func:`len` retorna o "
"número de itens em um conjunto. Os usos comuns para conjuntos são testes "
"rápidos de associação, remoção de duplicatas de uma sequência e computação "
"de operações matemáticas como interseção, união, diferença e diferença "
"simétrica."

#: ../../reference/datamodel.rst:400
msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr ""
"Para elementos de conjunto, as mesmas regras de imutabilidade se aplicam às "
"chaves de dicionário. Observe que os tipos numéricos obedecem às regras "
"normais para comparação numérica: se dois números forem iguais (por exemplo, "
"``1`` e ``1.0``), apenas um deles pode estar contido em um conjunto."

#: ../../reference/datamodel.rst:405
msgid "There are currently two intrinsic set types:"
msgstr "Atualmente, existem dois tipos de conjuntos intrínsecos:"

#: ../../reference/datamodel.rst:412
msgid "Sets"
msgstr "Sets (conjuntos)"

#: ../../reference/datamodel.rst:410
msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such as :meth:"
"`~set.add`."
msgstr ""
"Eles representam um conjunto mutável. Eles são criados pelo construtor "
"embutido :func:`set` e podem ser modificados posteriormente por vários "
"métodos, como :meth:`~set.add`."

#: ../../reference/datamodel.rst:420
msgid "Frozen sets"
msgstr "Frozen sets"

#: ../../reference/datamodel.rst:417
msgid ""
"These represent an immutable set.  They are created by the built-in :func:"
"`frozenset` constructor.  As a frozenset is immutable and :term:`hashable`, "
"it can be used again as an element of another set, or as a dictionary key."
msgstr ""
"Eles representam um conjunto imutável. Eles são criados pelo construtor "
"embutido :func:`frozenset`. Como um frozenset é imutável e :term:`hasheável "
"<hashable>`, ele pode ser usado novamente como um elemento de outro "
"conjunto, ou como uma chave de dicionário."

#: ../../reference/datamodel.rst:457
msgid "Mappings"
msgstr "Mappings"

#: ../../reference/datamodel.rst:428
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr ""
"Eles representam conjuntos finitos de objetos indexados por conjuntos de "
"índices arbitrários. A notação subscrito ``a[k]`` seleciona o item indexado "
"por ``k`` do mapeamento ``a``; isso pode ser usado em expressões e como alvo "
"de atribuições ou instruções :keyword:`del`. A função embutida :func:`len` "
"retorna o número de itens em um mapeamento."

#: ../../reference/datamodel.rst:434
msgid "There is currently a single intrinsic mapping type:"
msgstr "Atualmente, há um único tipo de mapeamento intrínseco:"

#: ../../reference/datamodel.rst:457
msgid "Dictionaries"
msgstr "Dicionários"

#: ../../reference/datamodel.rst:439
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr ""
"Eles representam conjuntos finitos de objetos indexados por valores quase "
"arbitrários. Os únicos tipos de valores não aceitáveis como chaves são os "
"valores que contêm listas ou dicionários ou outros tipos mutáveis que são "
"comparados por valor em vez de por identidade de objeto, o motivo é que a "
"implementação eficiente de dicionários requer que o valor de hash de uma "
"chave permaneça constante. Os tipos numéricos usados para chaves obedecem às "
"regras normais para comparação numérica: se dois números forem iguais (por "
"exemplo, ``1`` e ``1.0``), eles podem ser usados alternadamente para indexar "
"a mesma entrada do dicionário."

#: ../../reference/datamodel.rst:448
msgid ""
"Dictionaries are mutable; they can be created by the ``{...}`` notation (see "
"section :ref:`dict`)."
msgstr ""
"Os dicionários são mutáveis; eles podem ser criados pela notação ``{...}`` "
"(veja a seção :ref:`dict`)."

#: ../../reference/datamodel.rst:456
msgid ""
"The extension modules :mod:`dbm`, :mod:`gdbm`, and :mod:`bsddb` provide "
"additional examples of mapping types."
msgstr ""

#: ../../reference/datamodel.rst:727
msgid "Callable types"
msgstr "Tipo Callable"

#: ../../reference/datamodel.rst:466
msgid ""
"These are the types to which the function call operation (see section :ref:"
"`calls`) can be applied:"
msgstr ""
"Estes são os tipos aos quais a operação de chamada de função (veja a seção :"
"ref:`calls`) pode ser aplicada:"

#: ../../reference/datamodel.rst:560
msgid "User-defined functions"
msgstr "Funções Definidas pelo Usuário"

#: ../../reference/datamodel.rst:475
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr ""
"Um objeto função definido pelo usuário será criado pela definição de função "
"(veja a seção :ref:`function`). A mesma deverá ser invocada com uma lista de "
"argumentos contendo o mesmo número de itens que a lista de parâmetros "
"formais da função."

#: ../../reference/datamodel.rst:480
msgid "Special attributes:"
msgstr "Atributos Especiais:"

#: ../../reference/datamodel.rst:503
msgid "Attribute"
msgstr "Attribute"

#: ../../reference/datamodel.rst:503
msgid "Meaning"
msgstr "Significado"

#: ../../reference/datamodel.rst:505
msgid ":attr:`__doc__` :attr:`func_doc`"
msgstr ""

#: ../../reference/datamodel.rst:505
msgid "The function's documentation string, or ``None`` if unavailable."
msgstr ""

#: ../../reference/datamodel.rst:505 ../../reference/datamodel.rst:509
#: ../../reference/datamodel.rst:513 ../../reference/datamodel.rst:517
#: ../../reference/datamodel.rst:523 ../../reference/datamodel.rst:533
msgid "Writable"
msgstr "Writable"

#: ../../reference/datamodel.rst:509
msgid ":attr:`~definition.\\ __name__` :attr:`func_name`"
msgstr ""

#: ../../reference/datamodel.rst:509
msgid "The function's name"
msgstr "O nome da função"

#: ../../reference/datamodel.rst:513
msgid ":attr:`__module__`"
msgstr ":attr:`__module__`"

#: ../../reference/datamodel.rst:513
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr ""
"O nome do módulo em que a função foi definida ou ``None`` se indisponível."

#: ../../reference/datamodel.rst:517
msgid ":attr:`__defaults__` :attr:`func_defaults`"
msgstr ""

#: ../../reference/datamodel.rst:517
msgid ""
"A tuple containing default argument values for those arguments that have "
"defaults, or ``None`` if no arguments have a default value."
msgstr ""
"Uma tupla contendo valores de argumento padrão para aqueles argumentos que "
"possuem padrões, ou ``None`` se nenhum argumento tiver um valor padrão."

#: ../../reference/datamodel.rst:523
msgid ":attr:`__code__` :attr:`func_code`"
msgstr ""

#: ../../reference/datamodel.rst:523
msgid "The code object representing the compiled function body."
msgstr "O objeto código que representa o corpo da função compilada."

#: ../../reference/datamodel.rst:526
msgid ":attr:`__globals__` :attr:`func_globals`"
msgstr ""

#: ../../reference/datamodel.rst:526
msgid ""
"A reference to the dictionary that holds the function's global variables --- "
"the global namespace of the module in which the function was defined."
msgstr ""
"Uma referência ao dicionário que contém as variáveis globais da função --- o "
"espaço de nomes global do módulo no qual a função foi definida."

#: ../../reference/datamodel.rst:526 ../../reference/datamodel.rst:537
msgid "Read-only"
msgstr "Somente Leitura"

#: ../../reference/datamodel.rst:533
msgid ":attr:`~object.\\ __dict__` :attr:`func_dict`"
msgstr ""

#: ../../reference/datamodel.rst:533
msgid "The namespace supporting arbitrary function attributes."
msgstr ""
"O espaço de nomes que oferece suporte a atributos de função arbitrários."

#: ../../reference/datamodel.rst:537
msgid ":attr:`__closure__` :attr:`func_closure`"
msgstr ""

#: ../../reference/datamodel.rst:537
msgid ""
"``None`` or a tuple of cells that contain bindings for the function's free "
"variables."
msgstr ""

#: ../../reference/datamodel.rst:542
msgid ""
"Most of the attributes labelled \"Writable\" check the type of the assigned "
"value."
msgstr ""
"A maioria dos atributos rotulados como \"Gravável\" verifica o tipo do valor "
"atribuído."

#: ../../reference/datamodel.rst:544
msgid "``func_name`` is now writable."
msgstr ""

#: ../../reference/datamodel.rst:547
msgid ""
"The double-underscore attributes ``__closure__``, ``__code__``, "
"``__defaults__``, and ``__globals__`` were introduced as aliases for the "
"corresponding ``func_*`` attributes for forwards compatibility with Python 3."
msgstr ""

#: ../../reference/datamodel.rst:553
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes. *Note that "
"the current implementation only supports function attributes on user-defined "
"functions. Function attributes on built-in functions may be supported in the "
"future.*"
msgstr ""
"Os objetos de função também suportam a obtenção e configuração de atributos "
"arbitrários, que podem ser usados, por exemplo, para anexar metadados a "
"funções. A notação de ponto de atributo regular é usada para obter e definir "
"esses atributos. *Observe que a implementação atual só oferece suporte a "
"atributos de função em funções definidas pelo usuário. Atributos de função "
"embutidas podem ser suportados no futuro.*"

#: ../../reference/datamodel.rst:559
msgid ""
"Additional information about a function's definition can be retrieved from "
"its code object; see the description of internal types below."
msgstr ""

#: ../../reference/datamodel.rst:658
msgid "User-defined methods"
msgstr ""

#: ../../reference/datamodel.rst:568
msgid ""
"A user-defined method object combines a class, a class instance (or "
"``None``) and any callable object (normally a user-defined function)."
msgstr ""

#: ../../reference/datamodel.rst:571
msgid ""
"Special read-only attributes: :attr:`im_self` is the class instance object, :"
"attr:`im_func` is the function object; :attr:`im_class` is the class of :"
"attr:`im_self` for bound methods or the class that asked for the method for "
"unbound methods; :attr:`__doc__` is the method's documentation (same as "
"``im_func.__doc__``); :attr:`~definition.__name__` is the method name (same "
"as ``im_func.__name__``); :attr:`__module__` is the name of the module the "
"method was defined in, or ``None`` if unavailable."
msgstr ""

#: ../../reference/datamodel.rst:579
msgid ":attr:`im_self` used to refer to the class that defined the method."
msgstr ""

#: ../../reference/datamodel.rst:582
msgid ""
"For Python 3 forward-compatibility, :attr:`im_func` is also available as :"
"attr:`__func__`, and :attr:`im_self` as :attr:`__self__`."
msgstr ""

#: ../../reference/datamodel.rst:593
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying function object."
msgstr ""
"Os métodos também suportam o acesso (mas não a configuração) dos atributos "
"arbitrários da função no objeto de função subjacente."

#: ../../reference/datamodel.rst:596
msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined function object, an unbound user-defined method object, or a class "
"method object. When the attribute is a user-defined method object, a new "
"method object is only created if the class from which it is being retrieved "
"is the same as, or a derived class of, the class stored in the original "
"method object; otherwise, the original method object is used as it is."
msgstr ""

#: ../../reference/datamodel.rst:609
msgid ""
"When a user-defined method object is created by retrieving a user-defined "
"function object from a class, its :attr:`im_self` attribute is ``None`` and "
"the method object is said to be unbound. When one is created by retrieving a "
"user-defined function object from a class via one of its instances, its :"
"attr:`im_self` attribute is the instance, and the method object is said to "
"be bound. In either case, the new method's :attr:`im_class` attribute is the "
"class from which the retrieval takes place, and its :attr:`im_func` "
"attribute is the original function object."
msgstr ""

#: ../../reference/datamodel.rst:620
msgid ""
"When a user-defined method object is created by retrieving another method "
"object from a class or instance, the behaviour is the same as for a function "
"object, except that the :attr:`im_func` attribute of the new instance is not "
"the original method object but its :attr:`im_func` attribute."
msgstr ""

#: ../../reference/datamodel.rst:630
msgid ""
"When a user-defined method object is created by retrieving a class method "
"object from a class or instance, its :attr:`im_self` attribute is the class "
"itself, and its :attr:`im_func` attribute is the function object underlying "
"the class method."
msgstr ""

#: ../../reference/datamodel.rst:634
msgid ""
"When an unbound user-defined method object is called, the underlying "
"function (:attr:`im_func`) is called, with the restriction that the first "
"argument must be an instance of the proper class (:attr:`im_class`) or of a "
"derived class thereof."
msgstr ""

#: ../../reference/datamodel.rst:639
msgid ""
"When a bound user-defined method object is called, the underlying function (:"
"attr:`im_func`) is called, inserting the class instance (:attr:`im_self`) in "
"front of the argument list.  For instance, when :class:`C` is a class which "
"contains a definition for a function :meth:`f`, and ``x`` is an instance of :"
"class:`C`, calling ``x.f(1)`` is equivalent to calling ``C.f(x, 1)``."
msgstr ""

#: ../../reference/datamodel.rst:645
msgid ""
"When a user-defined method object is derived from a class method object, the "
"\"class instance\" stored in :attr:`im_self` will actually be the class "
"itself, so that calling either ``x.f(1)`` or ``C.f(1)`` is equivalent to "
"calling ``f(C,1)`` where ``f`` is the underlying function."
msgstr ""

#: ../../reference/datamodel.rst:650
msgid ""
"Note that the transformation from function object to (unbound or bound) "
"method object happens each time the attribute is retrieved from the class or "
"instance. In some cases, a fruitful optimization is to assign the attribute "
"to a local variable and call that local variable. Also notice that this "
"transformation only happens for user-defined functions; other callable "
"objects (and all non-callable objects) are retrieved without "
"transformation.  It is also important to note that user-defined functions "
"which are attributes of a class instance are not converted to bound methods; "
"this *only* happens when the function is an attribute of the class."
msgstr ""

#: ../../reference/datamodel.rst:674
msgid "Generator functions"
msgstr "Funções Geradoras"

#: ../../reference/datamodel.rst:665
msgid ""
"A function or method which uses the :keyword:`yield` statement (see section :"
"ref:`yield`) is called a :dfn:`generator function`.  Such a function, when "
"called, always returns an iterator object which can be used to execute the "
"body of the function:  calling the iterator's :meth:`~iterator.next` method "
"will cause the function to execute until it provides a value using the :"
"keyword:`yield` statement.  When the function executes a :keyword:`return` "
"statement or falls off the end, a :exc:`StopIteration` exception is raised "
"and the iterator will have reached the end of the set of values to be "
"returned."
msgstr ""

#: ../../reference/datamodel.rst:689
msgid "Built-in functions"
msgstr "Funções Built-in"

#: ../../reference/datamodel.rst:682
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes: :attr:`__doc__` "
"is the function's documentation string, or ``None`` if unavailable; :attr:"
"`~definition.__name__` is the function's name; :attr:`__self__` is set to "
"``None`` (but see the next item); :attr:`__module__` is the name of the "
"module the function was defined in or ``None`` if unavailable."
msgstr ""
"Um objeto função embutida é um wrapper em torno de uma função C. Exemplos de "
"funções embutidas são :func:`len` e :func:`math.sin` (:mod:`math` é um "
"módulo embutido padrão). O número e o tipo dos argumentos são determinados "
"pela função C. Atributos especiais de somente leitura: :attr:`__doc__` é a "
"string de documentação da função, ou ``None`` se indisponível; :attr:"
"`~definition.__name__` é o nome da função; :attr:`__self__` é definido como "
"``None`` (mas veja o próximo item); :attr:`__module__` é o nome do módulo no "
"qual a função foi definida ou ``None`` se indisponível."

#: ../../reference/datamodel.rst:701
msgid "Built-in methods"
msgstr "Métodos Built-in"

#: ../../reference/datamodel.rst:697
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra "
"argument.  An example of a built-in method is ``alist.append()``, assuming "
"*alist* is a list object. In this case, the special read-only attribute :"
"attr:`__self__` is set to the object denoted by *alist*."
msgstr ""
"Este é realmente um disfarce diferente de uma função embutida, desta vez "
"contendo um objeto passado para a função C como um argumento extra "
"implícito. Um exemplo de método embutido é ``alist.append()``, presumindo "
"que *alist* é um objeto de lista. Nesse caso, o atributo especial de somente "
"leitura :attr:`__self__` é definido como o objeto denotado por *alist*."

#: ../../reference/datamodel.rst:708
msgid "Class Types"
msgstr ""

#: ../../reference/datamodel.rst:704
msgid ""
"Class types, or \"new-style classes,\" are callable.  These objects normally "
"act as factories for new instances of themselves, but variations are "
"possible for class types that override :meth:`__new__`.  The arguments of "
"the call are passed to :meth:`__new__` and, in the typical case, to :meth:"
"`__init__` to initialize the new instance."
msgstr ""

#: ../../reference/datamodel.rst:722
msgid "Classic Classes"
msgstr ""

#: ../../reference/datamodel.rst:718
msgid ""
"Class objects are described below.  When a class object is called, a new "
"class instance (also described below) is created and returned.  This implies "
"a call to the class's :meth:`__init__` method if it has one.  Any arguments "
"are passed on to the :meth:`__init__` method.  If there is no :meth:"
"`__init__` method, the class must be called without arguments."
msgstr ""

#: ../../reference/datamodel.rst:727 ../../reference/datamodel.rst:879
msgid "Class instances"
msgstr "Instância de Classe"

#: ../../reference/datamodel.rst:725
msgid ""
"Class instances are described below.  Class instances are callable only when "
"the class has a :meth:`__call__` method; ``x(arguments)`` is a shorthand for "
"``x.__call__(arguments)``."
msgstr ""

#: ../../reference/datamodel.rst:770
msgid "Modules"
msgstr "Módulos"

#: ../../reference/datamodel.rst:734
msgid ""
"Modules are imported by the :keyword:`import` statement (see section :ref:"
"`import`). A module object has a namespace implemented by a dictionary "
"object (this is the dictionary referenced by the func_globals attribute of "
"functions defined in the module).  Attribute references are translated to "
"lookups in this dictionary, e.g., ``m.x`` is equivalent to ``m.__dict__[\"x"
"\"]``. A module object does not contain the code object used to initialize "
"the module (since it isn't needed once the initialization is done)."
msgstr ""

#: ../../reference/datamodel.rst:743
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""
"A atribuição de atributo atualiza o dicionário de espaço de nomes do módulo, "
"por exemplo, ``m.x = 1`` é equivalente a ``m.__dict__[\"x\"] = 1``."

#: ../../reference/datamodel.rst:748
msgid ""
"Special read-only attribute: :attr:`~object.__dict__` is the module's "
"namespace as a dictionary object."
msgstr ""
"Atributo especial somente leitura: :attr:`~object.__dict__` é o espaço de "
"nomes do módulo como um objeto de dicionário."

#: ../../reference/datamodel.rst:753
msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary "
"will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr ""
"Por causa da maneira como o CPython limpa os dicionários do módulo, o "
"dicionário do módulo será limpo quando o módulo sair do escopo, mesmo se o "
"dicionário ainda tiver referências ativas. Para evitar isso, copie o "
"dicionário ou mantenha o módulo por perto enquanto usa seu dicionário "
"diretamente."

#: ../../reference/datamodel.rst:764
msgid ""
"Predefined (writable) attributes: :attr:`__name__` is the module's name; :"
"attr:`__doc__` is the module's documentation string, or ``None`` if "
"unavailable; :attr:`__file__` is the pathname of the file from which the "
"module was loaded, if it was loaded from a file. The :attr:`__file__` "
"attribute is not present for C modules that are statically linked into the "
"interpreter; for extension modules loaded dynamically from a shared library, "
"it is the pathname of the shared library file."
msgstr ""

#: ../../reference/datamodel.rst:833
msgid "Classes"
msgstr "Classes"

#: ../../reference/datamodel.rst:773
msgid ""
"Both class types (new-style classes) and class objects (old-style/classic "
"classes) are typically created by class definitions (see section :ref:"
"`class`).  A class has a namespace implemented by a dictionary object. Class "
"attribute references are translated to lookups in this dictionary, e.g., ``C."
"x`` is translated to ``C.__dict__[\"x\"]`` (although for new-style classes "
"in particular there are a number of hooks which allow for other means of "
"locating attributes). When the attribute name is not found there, the "
"attribute search continues in the base classes.  For old-style classes, the "
"search is depth-first, left-to-right in the order of occurrence in the base "
"class list. New-style classes use the more complex C3 method resolution "
"order which behaves correctly even in the presence of 'diamond' inheritance "
"structures where there are multiple inheritance paths leading back to a "
"common ancestor. Additional details on the C3 MRO used by new-style classes "
"can be found in the documentation accompanying the 2.3 release at https://"
"www.python.org/download/releases/2.3/mro/."
msgstr ""

#: ../../reference/datamodel.rst:800
msgid ""
"When a class attribute reference (for class :class:`C`, say) would yield a "
"user-defined function object or an unbound user-defined method object whose "
"associated class is either :class:`C` or one of its base classes, it is "
"transformed into an unbound user-defined method object whose :attr:"
"`im_class` attribute is :class:`C`. When it would yield a class method "
"object, it is transformed into a bound user-defined method object whose :"
"attr:`im_self` attribute is :class:`C`.  When it would yield a static method "
"object, it is transformed into the object wrapped by the static method "
"object. See section :ref:`descriptors` for another way in which attributes "
"retrieved from a class may differ from those actually contained in its :attr:"
"`~object.__dict__` (note that only new-style classes support descriptors)."
msgstr ""

#: ../../reference/datamodel.rst:814
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr ""
"As atribuições de atributos de classe atualizam o dicionário da classe, "
"nunca o dicionário de uma classe base."

#: ../../reference/datamodel.rst:819
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr ""
"Um objeto de classe pode ser chamado (veja acima) para produzir uma "
"instância de classe (veja abaixo)."

#: ../../reference/datamodel.rst:828
msgid ""
"Special attributes: :attr:`~definition.__name__` is the class name; :attr:"
"`__module__` is the module name in which the class was defined; :attr:"
"`~object.__dict__` is the dictionary containing the class's namespace; :attr:"
"`~class.__bases__` is a tuple (possibly empty or a singleton) containing the "
"base classes, in the order of their occurrence in the base class list; :attr:"
"`__doc__` is the class's documentation string, or ``None`` if undefined."
msgstr ""

#: ../../reference/datamodel.rst:842
msgid ""
"A class instance is created by calling a class object (see above). A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object or an unbound user-defined method "
"object whose associated class is the class (call it :class:`C`) of the "
"instance for which the attribute reference was initiated or one of its "
"bases, it is transformed into a bound user-defined method object whose :attr:"
"`im_class` attribute is :class:`C` and whose :attr:`im_self` attribute is "
"the instance. Static method and class method objects are also transformed, "
"as if they had been retrieved from class :class:`C`; see above under "
"\"Classes\". See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`~object.__dict__`. If no class "
"attribute is found, and the object's class has a :meth:`__getattr__` method, "
"that is called to satisfy the lookup."
msgstr ""

#: ../../reference/datamodel.rst:861
msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`__setattr__` or :meth:"
"`__delattr__` method, this is called instead of updating the instance "
"dictionary directly."
msgstr ""
"As atribuições e exclusões de atributos atualizam o dicionário da instância, "
"nunca o dicionário de uma classe. Se a classe tem um método :meth:"
"`__setattr__` ou :meth:`__delattr__`, ele é chamado ao invés de atualizar o "
"dicionário da instância diretamente."

#: ../../reference/datamodel.rst:871
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr ""
"As instâncias de classe podem fingir ser números, sequências ou mapeamentos "
"se tiverem métodos com certos nomes especiais. Veja a seção :ref:"
"`specialnames`."

#: ../../reference/datamodel.rst:878
msgid ""
"Special attributes: :attr:`~object.__dict__` is the attribute dictionary; :"
"attr:`~instance.__class__` is the instance's class."
msgstr ""
"Atributos especiais: :attr:`~object.__dict__` é o dicionário de atributos; :"
"attr:`~instance.__class__` é a classe da instância."

#: ../../reference/datamodel.rst:902
msgid "Files"
msgstr ""

#: ../../reference/datamodel.rst:895
msgid ""
"A file object represents an open file.  File objects are created by the :"
"func:`open` built-in function, and also by :func:`os.popen`, :func:`os."
"fdopen`, and the :meth:`makefile` method of socket objects (and perhaps by "
"other functions or methods provided by extension modules).  The objects "
"``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized to file "
"objects corresponding to the interpreter's standard input, output and error "
"streams.  See :ref:`bltin-file-objects` for complete documentation of file "
"objects."
msgstr ""

#: ../../reference/datamodel.rst:1110
msgid "Internal types"
msgstr "Tipos Internos"

#: ../../reference/datamodel.rst:909
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr ""
"Alguns tipos usados internamente pelo interpretador são expostos ao usuário. "
"Suas definições podem mudar com versões futuras do interpretador, mas são "
"mencionadas aqui para fins de integridade."

#: ../../reference/datamodel.rst:977
msgid "Code objects"
msgstr "Objeto Código"

#: ../../reference/datamodel.rst:916
msgid ""
"Code objects represent *byte-compiled* executable Python code, or :term:"
"`bytecode`. The difference between a code object and a function object is "
"that the function object contains an explicit reference to the function's "
"globals (the module in which it was defined), while a code object contains "
"no context; also the default argument values are stored in the function "
"object, not in the code object (because they represent values calculated at "
"run-time).  Unlike function objects, code objects are immutable and contain "
"no references (directly or indirectly) to mutable objects."
msgstr ""
"Objetos código representam código Python executável *compilados em bytes* "
"ou :term:`bytecode`. A diferença entre um objeto código e um objeto função é "
"que o objeto função contém uma referência explícita aos globais da função (o "
"módulo no qual foi definida), enquanto um objeto código não contém nenhum "
"contexto; também os valores de argumento padrão são armazenados no objeto "
"função, não no objeto código (porque eles representam os valores calculados "
"em tempo de execução). Ao contrário dos objetos função, os objetos código "
"são imutáveis e não contêm referências (direta ou indiretamente) a objetos "
"mutáveis."

#: ../../reference/datamodel.rst:941
msgid ""
"Special read-only attributes: :attr:`co_name` gives the function name; :attr:"
"`co_argcount` is the number of positional arguments (including arguments "
"with default values); :attr:`co_nlocals` is the number of local variables "
"used by the function (including arguments); :attr:`co_varnames` is a tuple "
"containing the names of the local variables (starting with the argument "
"names); :attr:`co_cellvars` is a tuple containing the names of local "
"variables that are referenced by nested functions; :attr:`co_freevars` is a "
"tuple containing the names of free variables; :attr:`co_code` is a string "
"representing the sequence of bytecode instructions; :attr:`co_consts` is a "
"tuple containing the literals used by the bytecode; :attr:`co_names` is a "
"tuple containing the names used by the bytecode; :attr:`co_filename` is the "
"filename from which the code was compiled; :attr:`co_firstlineno` is the "
"first line number of the function; :attr:`co_lnotab` is a string encoding "
"the mapping from bytecode offsets to line numbers (for details see the "
"source code of the interpreter); :attr:`co_stacksize` is the required stack "
"size (including local variables); :attr:`co_flags` is an integer encoding a "
"number of flags for the interpreter."
msgstr ""

#: ../../reference/datamodel.rst:960
msgid ""
"The following flag bits are defined for :attr:`co_flags`: bit ``0x04`` is "
"set if the function uses the ``*arguments`` syntax to accept an arbitrary "
"number of positional arguments; bit ``0x08`` is set if the function uses the "
"``**keywords`` syntax to accept arbitrary keyword arguments; bit ``0x20`` is "
"set if the function is a generator."
msgstr ""
"Os seguintes bits de sinalizador são definidos para :attr:`co_flags`: o bit "
"``0x04`` é definido se a função usa a sintaxe ``*arguments`` para aceitar um "
"número arbitrário de argumentos posicionais; o bit ``0x08`` é definido se a "
"função usa a sintaxe ``**keywords`` para aceitar argumentos nomeados "
"arbitrários; o bit ``0x20`` é definido se a função for um gerador."

#: ../../reference/datamodel.rst:966
msgid ""
"Future feature declarations (``from __future__ import division``) also use "
"bits in :attr:`co_flags` to indicate whether a code object was compiled with "
"a particular feature enabled: bit ``0x2000`` is set if the function was "
"compiled with future division enabled; bits ``0x10`` and ``0x1000`` were "
"used in earlier versions of Python."
msgstr ""
"Declarações de recursos futuros (``from __future__ import division``) também "
"usam bits em :attr:`co_flags` para indicar se um objeto código foi compilado "
"com um recurso específico habilitado: o bit ``0x2000`` é definido se a "
"função foi compilada com divisão futura habilitada; os bits ``0x10`` e "
"``0x1000`` foram usados em versões anteriores do Python."

#: ../../reference/datamodel.rst:972
msgid "Other bits in :attr:`co_flags` are reserved for internal use."
msgstr "Outros bits em :attr:`co_flags` são reservados para uso interno."

#: ../../reference/datamodel.rst:976
msgid ""
"If a code object represents a function, the first item in :attr:`co_consts` "
"is the documentation string of the function, or ``None`` if undefined."
msgstr ""
"Se um objeto código representa uma função, o primeiro item em :attr:"
"`co_consts` é a string de documentação da função, ou ``None`` se indefinido."

#: ../../reference/datamodel.rst:1019
msgid "Frame objects"
msgstr "Objetos quadro"

#: ../../reference/datamodel.rst:984
msgid ""
"Frame objects represent execution frames.  They may occur in traceback "
"objects (see below)."
msgstr ""

#: ../../reference/datamodel.rst:996
msgid ""
"Special read-only attributes: :attr:`f_back` is to the previous stack frame "
"(towards the caller), or ``None`` if this is the bottom stack frame; :attr:"
"`f_code` is the code object being executed in this frame; :attr:`f_locals` "
"is the dictionary used to look up local variables; :attr:`f_globals` is used "
"for global variables; :attr:`f_builtins` is used for built-in (intrinsic) "
"names; :attr:`f_restricted` is a flag indicating whether the function is "
"executing in restricted execution mode; :attr:`f_lasti` gives the precise "
"instruction (this is an index into the bytecode string of the code object)."
msgstr ""

#: ../../reference/datamodel.rst:1012
msgid ""
"Special writable attributes: :attr:`f_trace`, if not ``None``, is a function "
"called at the start of each source code line (this is used by the "
"debugger); :attr:`f_exc_type`, :attr:`f_exc_value`, :attr:`f_exc_traceback` "
"represent the last exception raised in the parent frame provided another "
"exception was ever raised in the current frame (in all other cases they are "
"``None``); :attr:`f_lineno` is the current line number of the frame --- "
"writing to this from within a trace function jumps to the given line (only "
"for the bottom-most frame).  A debugger can implement a Jump command (aka "
"Set Next Statement) by writing to f_lineno."
msgstr ""

#: ../../reference/datamodel.rst:1061
msgid "Traceback objects"
msgstr "Objetos traceback"

#: ../../reference/datamodel.rst:1034
msgid ""
"Traceback objects represent a stack trace of an exception.  A traceback "
"object is created when an exception occurs.  When the search for an "
"exception handler unwinds the execution stack, at each unwound level a "
"traceback object is inserted in front of the current traceback.  When an "
"exception handler is entered, the stack trace is made available to the "
"program. (See section :ref:`try`.) It is accessible as ``sys."
"exc_traceback``, and also as the third item of the tuple returned by ``sys."
"exc_info()``.  The latter is the preferred interface, since it works "
"correctly when the program is using multiple threads. When the program "
"contains no suitable handler, the stack trace is written (nicely formatted) "
"to the standard error stream; if the interpreter is interactive, it is also "
"made available to the user as ``sys.last_traceback``."
msgstr ""

#: ../../reference/datamodel.rst:1054
msgid ""
"Special read-only attributes: :attr:`tb_next` is the next level in the stack "
"trace (towards the frame where the exception occurred), or ``None`` if there "
"is no next level; :attr:`tb_frame` points to the execution frame of the "
"current level; :attr:`tb_lineno` gives the line number where the exception "
"occurred; :attr:`tb_lasti` indicates the precise instruction.  The line "
"number and last instruction in the traceback may differ from the line number "
"of its frame object if the exception occurred in a :keyword:`try` statement "
"with no matching except clause or with a finally clause."
msgstr ""

#: ../../reference/datamodel.rst:1092
msgid "Slice objects"
msgstr "Objetos slice"

#: ../../reference/datamodel.rst:1066
msgid ""
"Slice objects are used to represent slices when *extended slice syntax* is "
"used. This is a slice using two colons, or multiple slices or ellipses "
"separated by commas, e.g., ``a[i:j:step]``, ``a[i:j, k:l]``, or ``a[..., i:"
"j]``.  They are also created by the built-in :func:`slice` function."
msgstr ""

#: ../../reference/datamodel.rst:1076
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; :attr:"
"`~slice.stop` is the upper bound; :attr:`~slice.step` is the step value; "
"each is ``None`` if omitted.  These attributes can have any type."
msgstr ""
"Atributos especiais de somente leitura: :attr:`~slice.start` é o limite "
"inferior; :attr:`~slice.stop` é o limite superior; :attr:`~slice.step` é o "
"valor intermediário; cada um é ``None`` se omitido. Esses atributos podem "
"ter qualquer tipo."

#: ../../reference/datamodel.rst:1080
msgid "Slice objects support one method:"
msgstr "Objetos slice têm suporte a um método:"

#: ../../reference/datamodel.rst:1085
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the extended slice that the slice object would describe if "
"applied to a sequence of *length* items.  It returns a tuple of three "
"integers; respectively these are the *start* and *stop* indices and the "
"*step* or stride length of the slice. Missing or out-of-bounds indices are "
"handled in a manner consistent with regular slices."
msgstr ""

#: ../../reference/datamodel.rst:1102
msgid "Static method objects"
msgstr "Objetos método estáticos"

#: ../../reference/datamodel.rst:1095
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are not themselves "
"callable, although the objects they wrap usually are. Static method objects "
"are created by the built-in :func:`staticmethod` constructor."
msgstr ""
"Objetos método estáticos fornecem uma maneira de derrotar a transformação de "
"objetos função em objetos método descritos acima. Um objeto método estático "
"é um wrapper em torno de qualquer outro objeto, geralmente um objeto método "
"definido pelo usuário. Quando um objeto método estático é recuperado de uma "
"classe ou instância de classe, o objeto realmente retornado é o objeto "
"envolto, que não está sujeito a nenhuma transformação posterior. Os objetos "
"método estáticos não são chamáveis, embora os objetos que envolvem "
"geralmente o sejam. Objetos método estáticos são criados pelo construtor "
"embutido :func:`staticmethod`."

#: ../../reference/datamodel.rst:1110
msgid "Class method objects"
msgstr "Objetos métodos de classe"

#: ../../reference/datamodel.rst:1105
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such "
"retrieval is described above, under \"User-defined methods\". Class method "
"objects are created by the built-in :func:`classmethod` constructor."
msgstr ""
"Um objeto método de classe, como um objeto método estático, é um invólucro "
"em torno de outro objeto que altera a maneira como esse objeto é recuperado "
"de classes e instâncias de classe. O comportamento dos objetos de método de "
"classe após tal recuperação é descrito acima, em \"Métodos definidos pelo "
"usuário\". Objetos de método de classe são criados pelo construtor embutido :"
"func:`classmethod`."

#: ../../reference/datamodel.rst:1115
msgid "New-style and classic classes"
msgstr ""

#: ../../reference/datamodel.rst:1117
msgid ""
"Classes and instances come in two flavors: old-style (or classic) and new-"
"style."
msgstr ""

#: ../../reference/datamodel.rst:1119
msgid ""
"Up to Python 2.1 the concept of ``class`` was unrelated to the concept of "
"``type``, and old-style classes were the only flavor available.  For an old-"
"style class, the statement ``x.__class__`` provides the class of *x*, but "
"``type(x)`` is always ``<type 'instance'>``.  This reflects the fact that "
"all old-style instances, independent of their class, are implemented with a "
"single built-in type, called ``instance``."
msgstr ""

#: ../../reference/datamodel.rst:1126
msgid ""
"New-style classes were introduced in Python 2.2 to unify the concepts of "
"``class`` and ``type``.  A new-style class is simply a user-defined type, no "
"more, no less.  If *x* is an instance of a new-style class, then ``type(x)`` "
"is typically the same as ``x.__class__`` (although this is not guaranteed -- "
"a new-style class instance is permitted to override the value returned for "
"``x.__class__``)."
msgstr ""

#: ../../reference/datamodel.rst:1133
msgid ""
"The major motivation for introducing new-style classes is to provide a "
"unified object model with a full meta-model.  It also has a number of "
"practical benefits, like the ability to subclass most built-in types, or the "
"introduction of \"descriptors\", which enable computed properties."
msgstr ""

#: ../../reference/datamodel.rst:1138
msgid ""
"For compatibility reasons, classes are still old-style by default.  New-"
"style classes are created by specifying another new-style class (i.e. a "
"type) as a parent class, or the \"top-level type\" :class:`object` if no "
"other parent is needed.  The behaviour of new-style classes differs from "
"that of old-style classes in a number of important details in addition to "
"what :func:`type` returns.  Some of these changes are fundamental to the new "
"object model, like the way special methods are invoked.  Others are \"fixes"
"\" that could not be implemented before for compatibility concerns, like the "
"method resolution order in case of multiple inheritance."
msgstr ""

#: ../../reference/datamodel.rst:1148
msgid ""
"While this manual aims to provide comprehensive coverage of Python's class "
"mechanics, it may still be lacking in some areas when it comes to its "
"coverage of new-style classes. Please see https://www.python.org/doc/"
"newstyle/ for sources of additional information."
msgstr ""

#: ../../reference/datamodel.rst:1158
msgid ""
"Old-style classes are removed in Python 3, leaving only new-style classes."
msgstr ""

#: ../../reference/datamodel.rst:1164
msgid "Special method names"
msgstr "Nomes de métodos especiais"

#: ../../reference/datamodel.rst:1170
msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method named :meth:"
"`__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` is "
"roughly equivalent to ``x.__getitem__(i)`` for old-style classes and "
"``type(x).__getitem__(x, i)`` for new-style classes.  Except where "
"mentioned, attempts to execute an operation raise an exception when no "
"appropriate method is defined (typically :exc:`AttributeError` or :exc:"
"`TypeError`)."
msgstr ""

#: ../../reference/datamodel.rst:1181
msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for "
"the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make "
"sense.  (One example of this is the :class:`~xml.dom.NodeList` interface in "
"the W3C's Document Object Model.)"
msgstr ""
"Ao implementar uma classe que emula qualquer tipo embutido, é importante que "
"a emulação seja implementada apenas na medida em que faça sentido para o "
"objeto que está sendo modelado. Por exemplo, algumas sequências podem "
"funcionar bem com a recuperação de elementos individuais, mas extrair uma "
"fatia pode não fazer sentido. (Um exemplo disso é a interface :class:`~xml."
"dom.NodeList` no Document Object Model do W3C.)"

#: ../../reference/datamodel.rst:1192
msgid "Basic customization"
msgstr "Customização básica"

#: ../../reference/datamodel.rst:1198
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static "
"method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr ""
"Chamado para criar uma nova instância da classe *cls*. :meth:`__new__` é um "
"método estático (é um caso especial, então você não precisa declará-lo como "
"tal) que recebe a classe da qual uma instância foi solicitada como seu "
"primeiro argumento. Os argumentos restantes são aqueles passados para a "
"expressão do construtor do objeto (a chamada para a classe). O valor de "
"retorno de :meth:`__new__` deve ser a nova instância do objeto (geralmente "
"uma instância de *cls*)."

#: ../../reference/datamodel.rst:1205
msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super(currentclass, cls)."
"__new__(cls[, ...])`` with appropriate arguments and then modifying the "
"newly-created instance as necessary before returning it."
msgstr ""

#: ../../reference/datamodel.rst:1210
msgid ""
"If :meth:`__new__` returns an instance of *cls*, then the new instance's :"
"meth:`__init__` method will be invoked like ``__init__(self[, ...])``, where "
"*self* is the new instance and the remaining arguments are the same as were "
"passed to :meth:`__new__`."
msgstr ""

#: ../../reference/datamodel.rst:1215
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""
"Se :meth:`__new__` não retornar uma instância de *cls*, então o método :meth:"
"`__init__` da nova instância não será invocado."

#: ../../reference/datamodel.rst:1218
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""
":meth:`__new__` destina-se principalmente a permitir que subclasses de tipos "
"imutáveis (como int, str ou tupla) personalizem a criação de instâncias. "
"Também é comumente substituído em metaclasses personalizadas para "
"personalizar a criação de classes."

#: ../../reference/datamodel.rst:1227
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but before "
"it is returned to the caller.  The arguments are those passed to the class "
"constructor expression.  If a base class has an :meth:`__init__` method, the "
"derived class's :meth:`__init__` method, if any, must explicitly call it to "
"ensure proper initialization of the base class part of the instance; for "
"example: ``BaseClass.__init__(self, [args...])``."
msgstr ""

#: ../../reference/datamodel.rst:1234
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in constructing "
"objects (:meth:`__new__` to create it, and :meth:`__init__` to customise "
"it), no non-``None`` value may be returned by :meth:`__init__`; doing so "
"will cause a :exc:`TypeError` to be raised at runtime."
msgstr ""

#: ../../reference/datamodel.rst:1246
msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"destructor.  If a base class has a :meth:`__del__` method, the derived "
"class's :meth:`__del__` method, if any, must explicitly call it to ensure "
"proper deletion of the base class part of the instance.  Note that it is "
"possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  It "
"may then be called at a later time when this new reference is deleted.  It "
"is not guaranteed that :meth:`__del__` methods are called for objects that "
"still exist when the interpreter exits."
msgstr ""

#: ../../reference/datamodel.rst:1258
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero.  Some common situations that may "
"prevent the reference count of an object from going to zero include: "
"circular references between objects (e.g., a doubly-linked list or a tree "
"data structure with parent and child pointers); a reference to the object on "
"the stack frame of a function that caught an exception (the traceback stored "
"in ``sys.exc_traceback`` keeps the stack frame alive); or a reference to the "
"object on the stack frame that raised an unhandled exception in interactive "
"mode (the traceback stored in ``sys.last_traceback`` keeps the stack frame "
"alive).  The first situation can only be remedied by explicitly breaking the "
"cycles; the latter two situations can be resolved by storing ``None`` in "
"``sys.exc_traceback`` or ``sys.last_traceback``.  Circular references which "
"are garbage are detected when the option cycle detector is enabled (it's on "
"by default), but can only be cleaned up if there are no Python-level :meth:"
"`__del__` methods involved. Refer to the documentation for the :mod:`gc` "
"module for more information about how :meth:`__del__` methods are handled by "
"the cycle detector, particularly the description of the ``garbage`` value."
msgstr ""

#: ../../reference/datamodel.rst:1280
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  Also, when :meth:`__del__` is "
"invoked in response to a module being deleted (e.g., when execution of the "
"program is done), other globals referenced by the :meth:`__del__` method may "
"already have been deleted or in the process of being torn down (e.g. the "
"import machinery shutting down).  For this reason, :meth:`__del__` methods "
"should do the absolute minimum needed to maintain external invariants.  "
"Starting with version 1.5, Python guarantees that globals whose name begins "
"with a single underscore are deleted from their module before other globals "
"are deleted; if no other references to such globals exist, this may help in "
"assuring that imported modules are still available at the time when the :"
"meth:`__del__` method is called."
msgstr ""

#: ../../reference/datamodel.rst:1295
msgid "See also the :option:`-R` command-line option."
msgstr ""

#: ../../reference/datamodel.rst:1302
msgid ""
"Called by the :func:`repr` built-in function and by string conversions "
"(reverse quotes) to compute the \"official\" string representation of an "
"object.  If at all possible, this should look like a valid Python expression "
"that could be used to recreate an object with the same value (given an "
"appropriate environment).  If this is not possible, a string of the form "
"``<...some useful description...>`` should be returned.  The return value "
"must be a string object. If a class defines :meth:`__repr__` but not :meth:"
"`__str__`, then :meth:`__repr__` is also used when an \"informal\" string "
"representation of instances of that class is required."
msgstr ""

#: ../../reference/datamodel.rst:1318
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous."
msgstr ""
"Isso é normalmente usado para depuração, portanto, é importante que a "
"representação seja rica em informações e inequívoca."

#: ../../reference/datamodel.rst:1328
msgid ""
"Called by the :func:`str` built-in function and by the :keyword:`print` "
"statement to compute the \"informal\" string representation of an object.  "
"This differs from :meth:`__repr__` in that it does not have to be a valid "
"Python expression: a more convenient or concise representation may be used "
"instead. The return value must be a string object."
msgstr ""

#: ../../reference/datamodel.rst:1347
msgid ""
"These are the so-called \"rich comparison\" methods, and are called for "
"comparison operators in preference to :meth:`__cmp__` below. The "
"correspondence between operator symbols and method names is as follows: "
"``x<y`` calls ``x.__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` "
"calls ``x.__eq__(y)``, ``x!=y`` and ``x<>y`` call ``x.__ne__(y)``, ``x>y`` "
"calls ``x.__gt__(y)``, and ``x>=y`` calls ``x.__ge__(y)``."
msgstr ""

#: ../../reference/datamodel.rst:1354
msgid ""
"A rich comparison method may return the singleton ``NotImplemented`` if it "
"does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison. "
"However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr ""
"Um método de comparação rico pode retornar o singleton ``NotImplemented`` se "
"não implementar a operação para um determinado par de argumentos. Por "
"convenção, ``False`` e ``True`` são retornados para uma comparação bem-"
"sucedida. No entanto, esses métodos podem retornar qualquer valor, portanto, "
"se o operador de comparação for usado em um contexto booleano (por exemplo, "
"na condição de uma instrução ``if``), Python irá chamar :func:`bool` no "
"valor para determinar se o resultado for verdadeiro ou falso."

#: ../../reference/datamodel.rst:1361
msgid ""
"There are no implied relationships among the comparison operators. The truth "
"of ``x==y`` does not imply that ``x!=y`` is false.  Accordingly, when "
"defining :meth:`__eq__`, one should also define :meth:`__ne__` so that the "
"operators will behave as expected.  See the paragraph on :meth:`__hash__` "
"for some important notes on creating :term:`hashable` objects which support "
"custom comparison operations and are usable as dictionary keys."
msgstr ""

#: ../../reference/datamodel.rst:1368
msgid ""
"There are no swapped-argument versions of these methods (to be used when the "
"left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, :meth:"
"`__le__` and :meth:`__ge__` are each other's reflection, and :meth:`__eq__` "
"and :meth:`__ne__` are their own reflection."
msgstr ""

#: ../../reference/datamodel.rst:1374
msgid "Arguments to rich comparison methods are never coerced."
msgstr ""

#: ../../reference/datamodel.rst:1376
msgid ""
"To automatically generate ordering operations from a single root operation, "
"see :func:`functools.total_ordering`."
msgstr ""

#: ../../reference/datamodel.rst:1385
msgid ""
"Called by comparison operations if rich comparison (see above) is not "
"defined.  Should return a negative integer if ``self < other``, zero if "
"``self == other``, a positive integer if ``self > other``.  If no :meth:"
"`__cmp__`, :meth:`__eq__` or :meth:`__ne__` operation is defined, class "
"instances are compared by object identity (\"address\").  See also the "
"description of :meth:`__hash__` for some important notes on creating :term:"
"`hashable` objects which support custom comparison operations and are usable "
"as dictionary keys. (Note: the restriction that exceptions are not "
"propagated by :meth:`__cmp__` has been removed since Python 1.5.)"
msgstr ""

#: ../../reference/datamodel.rst:1398
msgid "No longer supported."
msgstr ""

#: ../../reference/datamodel.rst:1408
msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, and :class:"
"`dict`.  :meth:`__hash__` should return an integer.  The only required "
"property is that objects which compare equal have the same hash value; it is "
"advised to mix together the hash values of the components of the object that "
"also play a part in comparison of objects by packing them into a tuple and "
"hashing the tuple. Example::"
msgstr ""

#: ../../reference/datamodel.rst:1419
msgid ""
"If a class does not define a :meth:`__cmp__` or :meth:`__eq__` method it "
"should not define a :meth:`__hash__` operation either; if it defines :meth:"
"`__cmp__` or :meth:`__eq__` but not :meth:`__hash__`, its instances will not "
"be usable in hashed collections.  If a class defines mutable objects and "
"implements a :meth:`__cmp__` or :meth:`__eq__` method, it should not "
"implement :meth:`__hash__`, since hashable collection implementations "
"require that an object's hash value is immutable (if the object's hash value "
"changes, it will be in the wrong hash bucket)."
msgstr ""

#: ../../reference/datamodel.rst:1428
msgid ""
"User-defined classes have :meth:`__cmp__` and :meth:`__hash__` methods by "
"default; with them, all objects compare unequal (except with themselves) and "
"``x.__hash__()`` returns a result derived from ``id(x)``."
msgstr ""

#: ../../reference/datamodel.rst:1432
msgid ""
"Classes which inherit a :meth:`__hash__` method from a parent class but "
"change the meaning of :meth:`__cmp__` or :meth:`__eq__` such that the hash "
"value returned is no longer appropriate (e.g. by switching to a value-based "
"concept of equality instead of the default identity based equality) can "
"explicitly flag themselves as being unhashable by setting ``__hash__ = "
"None`` in the class definition. Doing so means that not only will instances "
"of the class raise an appropriate :exc:`TypeError` when a program attempts "
"to retrieve their hash value, but they will also be correctly identified as "
"unhashable when checking ``isinstance(obj, collections.Hashable)`` (unlike "
"classes which define their own :meth:`__hash__` to explicitly raise :exc:"
"`TypeError`)."
msgstr ""

#: ../../reference/datamodel.rst:1444
msgid ""
":meth:`__hash__` may now also return a long integer object; the 32-bit "
"integer is then derived from the hash of that object."
msgstr ""

#: ../../reference/datamodel.rst:1448
msgid ""
":attr:`__hash__` may now be set to :const:`None` to explicitly flag "
"instances of a class as unhashable."
msgstr ""

#: ../../reference/datamodel.rst:1457
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``, or their integer "
"equivalents ``0`` or ``1``.  When this method is not defined, :meth:"
"`__len__` is called, if it is defined, and the object is considered true if "
"its result is nonzero. If a class defines neither :meth:`__len__` nor :meth:"
"`__nonzero__`, all its instances are considered true."
msgstr ""

#: ../../reference/datamodel.rst:1469
msgid ""
"Called to implement :func:`unicode` built-in; should return a Unicode "
"object. When this method is not defined, string conversion is attempted, and "
"the result of string conversion is converted to Unicode using the system "
"default encoding."
msgstr ""

#: ../../reference/datamodel.rst:1477
msgid "Customizing attribute access"
msgstr "Personalizando o acesso aos atributos"

#: ../../reference/datamodel.rst:1479
msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr ""
"Os seguintes métodos podem ser definidos para personalizar o significado do "
"acesso aos atributos (uso, atribuição ou exclusão de ``x.name``) para "
"instâncias de classe."

#: ../../reference/datamodel.rst:1485
msgid ""
"Called when an attribute lookup has not found the attribute in the usual "
"places (i.e. it is not an instance attribute nor is it found in the class "
"tree for ``self``).  ``name`` is the attribute name. This method should "
"return the (computed) attribute value or raise an :exc:`AttributeError` "
"exception."
msgstr ""

#: ../../reference/datamodel.rst:1492
msgid ""
"Note that if the attribute is found through the normal mechanism, :meth:"
"`__getattr__` is not called.  (This is an intentional asymmetry between :"
"meth:`__getattr__` and :meth:`__setattr__`.) This is done both for "
"efficiency reasons and because otherwise :meth:`__getattr__` would have no "
"way to access other attributes of the instance.  Note that at least for "
"instance variables, you can fake total control by not inserting any values "
"in the instance attribute dictionary (but instead inserting them in another "
"object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control in new-style classes."
msgstr ""

#: ../../reference/datamodel.rst:1505
msgid ""
"Called when an attribute assignment is attempted.  This is called instead of "
"the normal mechanism (i.e. store the value in the instance dictionary).  "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr ""

#: ../../reference/datamodel.rst:1511
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"not simply execute ``self.name = value`` --- this would cause a recursive "
"call to itself.  Instead, it should insert the value in the dictionary of "
"instance attributes, e.g., ``self.__dict__[name] = value``.  For new-style "
"classes, rather than accessing the instance dictionary, it should call the "
"base class method with the same name, for example, ``object."
"__setattr__(self, name, value)``."
msgstr ""

#: ../../reference/datamodel.rst:1522
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr ""
"Como :meth:`__setattr__`, mas para exclusão de atributo em vez de "
"atribuição. Isso só deve ser implementado se ``del obj.name`` for "
"significativo para o objeto."

#: ../../reference/datamodel.rst:1529
msgid "More attribute access for new-style classes"
msgstr ""

#: ../../reference/datamodel.rst:1531
msgid "The following methods only apply to new-style classes."
msgstr ""

#: ../../reference/datamodel.rst:1536
msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be "
"called unless :meth:`__getattribute__` either calls it explicitly or raises "
"an :exc:`AttributeError`. This method should return the (computed) attribute "
"value or raise an :exc:`AttributeError` exception. In order to avoid "
"infinite recursion in this method, its implementation should always call the "
"base class method with the same name to access any attributes it needs, for "
"example, ``object.__getattribute__(self, name)``."
msgstr ""
"Chamado incondicionalmente para implementar acessos a atributo para "
"instâncias da classe. Se a classe também define :meth:`__getattr__`, o "
"último não será chamado a menos que :meth:`__getattribute__` o chame "
"explicitamente ou levante um :exc:`AttributeError`. Este método deve "
"retornar o valor do atributo (calculado) ou levantar uma exceção :exc:"
"`AttributeError`. Para evitar recursão infinita neste método, sua "
"implementação deve sempre chamar o método da classe base com o mesmo nome "
"para acessar quaisquer atributos de que necessita, por exemplo, ``object."
"__getattribute__(self, name)``."

#: ../../reference/datamodel.rst:1547
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or built-in functions. "
"See :ref:`new-style-special-lookup`."
msgstr ""

#: ../../reference/datamodel.rst:1555
msgid "Implementing Descriptors"
msgstr "Implementando descritores"

#: ../../reference/datamodel.rst:1557
msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the "
"descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the attribute"
"\" refers to the attribute whose name is the key of the property in the "
"owner class' :attr:`~object.__dict__`."
msgstr ""
"Os métodos a seguir se aplicam apenas quando uma instância da classe que "
"contém o método (uma classe chamada *descritora*) aparece em uma classe "
"proprietária *owner* (o descritor deve estar no dicionário de classe do "
"proprietário ou no dicionário de classe para um dos seus pais). Nos exemplos "
"abaixo, \"o atributo\" refere-se ao atributo cujo nome é a chave da "
"propriedade no :attr:`~object.__dict__` da classe proprietária."

#: ../../reference/datamodel.rst:1567
msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). *owner* is always "
"the owner class, while *instance* is the instance that the attribute was "
"accessed through, or ``None`` when the attribute is accessed through the "
"*owner*.  This method should return the (computed) attribute value or raise "
"an :exc:`AttributeError` exception."
msgstr ""

#: ../../reference/datamodel.rst:1577
msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr ""
"Chamado para definir o atributo em uma instância *instance* da classe "
"proprietária para um novo valor, *value*."

#: ../../reference/datamodel.rst:1583
msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr ""
"Chamado para excluir o atributo em uma instância *instance* da classe "
"proprietária."

#: ../../reference/datamodel.rst:1589
msgid "Invoking Descriptors"
msgstr "Invoking Descriptors"

#: ../../reference/datamodel.rst:1591
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`__get__`, :meth:`__set__`, and :meth:`__delete__`. If any "
"of those methods are defined for an object, it is said to be a descriptor."
msgstr ""
"Em geral, um descritor é um atributo de objeto com \"comportamento de ligação"
"\", cujo acesso ao atributo foi substituído por métodos no protocolo do "
"descritor: :meth:`__get__`, :meth:`__set__` e :meth:`__delete__` . Se "
"qualquer um desses métodos for definido para um objeto, é considerado um "
"descritor."

#: ../../reference/datamodel.rst:1596
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr ""
"O comportamento padrão para acesso ao atributo é obter, definir ou excluir o "
"atributo do dicionário de um objeto. Por exemplo, ``a.x`` tem uma cadeia de "
"pesquisa começando com ``a.__dict__['x']``, então ``type(a).__dict__['x']``, "
"e contando pelas classes base de ``type(a)`` excluindo metaclasses."

#: ../../reference/datamodel.rst:1601
msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called.  "
"Note that descriptors are only invoked for new style objects or classes "
"(ones that subclass :class:`object()` or :class:`type()`)."
msgstr ""

#: ../../reference/datamodel.rst:1608
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr ""
"O ponto de partida para a invocação do descritor é uma ligação, ``a.x``. "
"Como os argumentos são montados depende de ``a``:"

#: ../../reference/datamodel.rst:1613
msgid "Direct Call"
msgstr "Chamada direta"

#: ../../reference/datamodel.rst:1612
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr ""
"A chamada mais simples e menos comum é quando o código do usuário invoca "
"diretamente um método descritor: ``x.__get__(a)``."

#: ../../reference/datamodel.rst:1617
msgid "Instance Binding"
msgstr "Ligação de instâncias"

#: ../../reference/datamodel.rst:1616
msgid ""
"If binding to a new-style object instance, ``a.x`` is transformed into the "
"call: ``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""

#: ../../reference/datamodel.rst:1621
msgid "Class Binding"
msgstr "Ligação de classes"

#: ../../reference/datamodel.rst:1620
msgid ""
"If binding to a new-style class, ``A.x`` is transformed into the call: ``A."
"__dict__['x'].__get__(None, A)``."
msgstr ""

#: ../../reference/datamodel.rst:1627
msgid "Super Binding"
msgstr "Ligação de super"

#: ../../reference/datamodel.rst:1624
msgid ""
"If ``a`` is an instance of :class:`super`, then the binding ``super(B, obj)."
"m()`` searches ``obj.__class__.__mro__`` for the base class ``A`` "
"immediately preceding ``B`` and then invokes the descriptor with the call: "
"``A.__dict__['m'].__get__(obj, obj.__class__)``."
msgstr ""
"Se ``a`` é uma instância de :class:`super`, então a ligação ``super(B, obj)."
"m()`` procura ``obj.__class__.__mro__`` para a classe base ``A`` precedendo "
"imediatamente ``B`` e, em seguida, invoca o descritor com a chamada: ``A."
"__dict__['m'].__get__(obj, obj.__class__)``."

#: ../../reference/datamodel.rst:1629
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"the which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`__get__`, :meth:`__set__` and :meth:`__delete__`.  If "
"it does not define :meth:`__get__`, then accessing the attribute will return "
"the descriptor object itself unless there is a value in the object's "
"instance dictionary.  If the descriptor defines :meth:`__set__` and/or :meth:"
"`__delete__`, it is a data descriptor; if it defines neither, it is a non-"
"data descriptor.  Normally, data descriptors define both :meth:`__get__` "
"and :meth:`__set__`, while non-data descriptors have just the :meth:"
"`__get__` method.  Data descriptors with :meth:`__set__` and :meth:`__get__` "
"defined always override a redefinition in an instance dictionary.  In "
"contrast, non-data descriptors can be overridden by instances."
msgstr ""

#: ../../reference/datamodel.rst:1642
msgid ""
"Python methods (including :func:`staticmethod` and :func:`classmethod`) are "
"implemented as non-data descriptors.  Accordingly, instances can redefine "
"and override methods.  This allows individual instances to acquire behaviors "
"that differ from other instances of the same class."
msgstr ""
"Os métodos Python (incluindo :func:`staticmethod` e :func:`classmethod`) são "
"implementados como descritores sem dados. Assim, as instâncias podem "
"redefinir e substituir métodos. Isso permite que instâncias individuais "
"adquiram comportamentos que diferem de outras instâncias da mesma classe."

#: ../../reference/datamodel.rst:1647
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""
"A função :func:`property` é implementada como um descritor de dados. Da "
"mesma forma, as instâncias não podem substituir o comportamento de uma "
"propriedade."

#: ../../reference/datamodel.rst:1654
msgid "__slots__"
msgstr "__slots__"

#: ../../reference/datamodel.rst:1656
msgid ""
"By default, instances of both old and new-style classes have a dictionary "
"for attribute storage.  This wastes space for objects having very few "
"instance variables.  The space consumption can become acute when creating "
"large numbers of instances."
msgstr ""

#: ../../reference/datamodel.rst:1661
msgid ""
"The default can be overridden by defining *__slots__* in a new-style class "
"definition.  The *__slots__* declaration takes a sequence of instance "
"variables and reserves just enough space in each instance to hold a value "
"for each variable.  Space is saved because *__dict__* is not created for "
"each instance."
msgstr ""

#: ../../reference/datamodel.rst:1669
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  If defined in a new-style "
"class, *__slots__* reserves space for the declared variables and prevents "
"the automatic creation of *__dict__* and *__weakref__* for each instance."
msgstr ""

#: ../../reference/datamodel.rst:1676
msgid "Notes on using *__slots__*"
msgstr "Observações ao uso de *__slots__*"

#: ../../reference/datamodel.rst:1678
msgid ""
"When inheriting from a class without *__slots__*, the *__dict__* attribute "
"of that class will always be accessible, so a *__slots__* definition in the "
"subclass is meaningless."
msgstr ""

#: ../../reference/datamodel.rst:1682
msgid ""
"Without a *__dict__* variable, instances cannot be assigned new variables "
"not listed in the *__slots__* definition.  Attempts to assign to an unlisted "
"variable name raises :exc:`AttributeError`. If dynamic assignment of new "
"variables is desired, then add ``'__dict__'`` to the sequence of strings in "
"the *__slots__* declaration."
msgstr ""
"Sem uma variável *__dict__*, as instâncias não podem ser atribuídas a novas "
"variáveis não listadas na definição *__slots__*. As tentativas de atribuir a "
"um nome de variável não listado levantam :exc:`AttributeError`. Se a "
"atribuição dinâmica de novas variáveis for desejada, então adicione "
"``'__dict__'`` à sequência de strings na declaração *__slots__*."

#: ../../reference/datamodel.rst:1688
msgid ""
"Previously, adding ``'__dict__'`` to the *__slots__* declaration would not "
"enable the assignment of new attributes not specifically listed in the "
"sequence of instance variable names."
msgstr ""

#: ../../reference/datamodel.rst:1693
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support weak references to its instances. If weak "
"reference support is needed, then add ``'__weakref__'`` to the sequence of "
"strings in the *__slots__* declaration."
msgstr ""
"Sem uma variável *__weakref__* para cada instância, as classes que definem "
"*__slots__* não suportam referências fracas para suas instâncias. Se for "
"necessário um suporte de referência fraca, adicione ``'__weakref__'`` à "
"sequência de strings na declaração *__slots__*."

#: ../../reference/datamodel.rst:1698
msgid ""
"Previously, adding ``'__weakref__'`` to the *__slots__* declaration would "
"not enable support for weak references."
msgstr ""

#: ../../reference/datamodel.rst:1702
msgid ""
"*__slots__* are implemented at the class level by creating descriptors (:ref:"
"`descriptors`) for each variable name.  As a result, class attributes cannot "
"be used to set default values for instance variables defined by *__slots__*; "
"otherwise, the class attribute would overwrite the descriptor assignment."
msgstr ""

#: ../../reference/datamodel.rst:1708
msgid ""
"The action of a *__slots__* declaration is limited to the class where it is "
"defined.  As a result, subclasses will have a *__dict__* unless they also "
"define *__slots__* (which must only contain names of any *additional* slots)."
msgstr ""

#: ../../reference/datamodel.rst:1712
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr ""

#: ../../reference/datamodel.rst:1717
msgid ""
"Nonempty *__slots__* does not work for classes derived from \"variable-length"
"\" built-in types such as :class:`long`, :class:`str` and :class:`tuple`."
msgstr ""

#: ../../reference/datamodel.rst:1720
msgid ""
"Any non-string iterable may be assigned to *__slots__*. Mappings may also be "
"used; however, in the future, special meaning may be assigned to the values "
"corresponding to each key."
msgstr ""

#: ../../reference/datamodel.rst:1724
msgid ""
"*__class__* assignment works only if both classes have the same *__slots__*."
msgstr ""

#: ../../reference/datamodel.rst:1726
msgid ""
"Previously, *__class__* assignment raised an error if either new or old "
"class had *__slots__*."
msgstr ""

#: ../../reference/datamodel.rst:1734
msgid "Customizing class creation"
msgstr ""

#: ../../reference/datamodel.rst:1736
msgid ""
"By default, new-style classes are constructed using :func:`type`. A class "
"definition is read into a separate namespace and the value of class name is "
"bound to the result of ``type(name, bases, dict)``."
msgstr ""

#: ../../reference/datamodel.rst:1740
msgid ""
"When the class definition is read, if *__metaclass__* is defined then the "
"callable assigned to it will be called instead of :func:`type`. This allows "
"classes or functions to be written which monitor or alter the class creation "
"process:"
msgstr ""

#: ../../reference/datamodel.rst:1745
msgid "Modifying the class dictionary prior to the class being created."
msgstr ""

#: ../../reference/datamodel.rst:1747
msgid ""
"Returning an instance of another class -- essentially performing the role of "
"a factory function."
msgstr ""

#: ../../reference/datamodel.rst:1750
msgid ""
"These steps will have to be performed in the metaclass's :meth:`__new__` "
"method -- :meth:`type.__new__` can then be called from this method to create "
"a class with different properties.  This example adds a new element to the "
"class dictionary before creating the class::"
msgstr ""

#: ../../reference/datamodel.rst:1760
msgid ""
"You can of course also override other class methods (or add new methods); "
"for example defining a custom :meth:`__call__` method in the metaclass "
"allows custom behavior when the class is called, e.g. not always creating a "
"new instance."
msgstr ""

#: ../../reference/datamodel.rst:1767
msgid ""
"This variable can be any callable accepting arguments for ``name``, "
"``bases``, and ``dict``.  Upon class creation, the callable is used instead "
"of the built-in :func:`type`."
msgstr ""

#: ../../reference/datamodel.rst:1773
msgid ""
"The appropriate metaclass is determined by the following precedence rules:"
msgstr ""

#: ../../reference/datamodel.rst:1775
msgid "If ``dict['__metaclass__']`` exists, it is used."
msgstr ""

#: ../../reference/datamodel.rst:1777
msgid ""
"Otherwise, if there is at least one base class, its metaclass is used (this "
"looks for a *__class__* attribute first and if not found, uses its type)."
msgstr ""

#: ../../reference/datamodel.rst:1780
msgid "Otherwise, if a global variable named __metaclass__ exists, it is used."
msgstr ""

#: ../../reference/datamodel.rst:1782
msgid "Otherwise, the old-style, classic metaclass (types.ClassType) is used."
msgstr ""

#: ../../reference/datamodel.rst:1784
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored including logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr ""

#: ../../reference/datamodel.rst:1791
msgid "Customizing instance and subclass checks"
msgstr ""

#: ../../reference/datamodel.rst:1795
msgid ""
"The following methods are used to override the default behavior of the :func:"
"`isinstance` and :func:`issubclass` built-in functions."
msgstr ""

#: ../../reference/datamodel.rst:1798
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr ""

#: ../../reference/datamodel.rst:1805
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr ""

#: ../../reference/datamodel.rst:1812
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass, "
"class)``."
msgstr ""

#: ../../reference/datamodel.rst:1817
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr ""

#: ../../reference/datamodel.rst:1828
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - Introducing Abstract Base Classes"

#: ../../reference/datamodel.rst:1825
msgid ""
"Includes the specification for customizing :func:`isinstance` and :func:"
"`issubclass` behavior through :meth:`~class.__instancecheck__` and :meth:"
"`~class.__subclasscheck__`, with motivation for this functionality in the "
"context of adding Abstract Base Classes (see the :mod:`abc` module) to the "
"language."
msgstr ""

#: ../../reference/datamodel.rst:1835
msgid "Emulating callable objects"
msgstr ""

#: ../../reference/datamodel.rst:1842
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` is a shorthand for ``x.__call__(arg1, "
"arg2, ...)``."
msgstr ""

#: ../../reference/datamodel.rst:1849
msgid "Emulating container types"
msgstr ""

#: ../../reference/datamodel.rst:1851
msgid ""
"The following methods can be defined to implement container objects.  "
"Containers usually are sequences (such as lists or tuples) or mappings (like "
"dictionaries), but can represent other containers as well.  The first set of "
"methods is used either to emulate a sequence or to emulate a mapping; the "
"difference is that for a sequence, the allowable keys should be the integers "
"*k* for which ``0 <= k < N`` where *N* is the length of the sequence, or "
"slice objects, which define a range of items. (For backwards compatibility, "
"the method :meth:`__getslice__` (see below) can also be defined to handle "
"simple, but not extended slices.) It is also recommended that mappings "
"provide the methods :meth:`keys`, :meth:`values`, :meth:`items`, :meth:"
"`has_key`, :meth:`get`, :meth:`clear`, :meth:`setdefault`, :meth:"
"`iterkeys`, :meth:`itervalues`, :meth:`iteritems`, :meth:`pop`, :meth:"
"`popitem`, :meth:`!copy`, and :meth:`update` behaving similar to those for "
"Python's standard dictionary objects.  The :mod:`UserDict` module provides "
"a :class:`DictMixin` class to help create those methods from a base set of :"
"meth:`__getitem__`, :meth:`__setitem__`, :meth:`__delitem__`, and :meth:"
"`keys`. Mutable sequences should provide methods :meth:`append`, :meth:"
"`count`, :meth:`index`, :meth:`extend`, :meth:`insert`, :meth:`pop`, :meth:"
"`remove`, :meth:`reverse` and :meth:`sort`, like Python standard list "
"objects.  Finally, sequence types should implement addition (meaning "
"concatenation) and multiplication (meaning repetition) by defining the "
"methods :meth:`__add__`, :meth:`__radd__`, :meth:`__iadd__`, :meth:"
"`__mul__`, :meth:`__rmul__` and :meth:`__imul__` described below; they "
"should not define :meth:`__coerce__` or other numerical operators.  It is "
"recommended that both mappings and sequences implement the :meth:"
"`__contains__` method to allow efficient use of the ``in`` operator; for "
"mappings, ``in`` should be equivalent of :meth:`has_key`; for sequences, it "
"should search through the values.  It is further recommended that both "
"mappings and sequences implement the :meth:`__iter__` method to allow "
"efficient iteration through the container; for mappings, :meth:`__iter__` "
"should be the same as :meth:`iterkeys`; for sequences, it should iterate "
"through the values."
msgstr ""

#: ../../reference/datamodel.rst:1889
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`__nonzero__` method and whose :meth:`__len__` method returns "
"zero is considered to be false in a Boolean context."
msgstr ""

#: ../../reference/datamodel.rst:1896
msgid ""
"In CPython, the length is required to be at most :attr:`sys.maxsize`. If the "
"length is larger than :attr:`!sys.maxsize` some features (such as :func:"
"`len`) may raise :exc:`OverflowError`.  To prevent raising :exc:`!"
"OverflowError` by truth value testing, an object must define a :meth:"
"`__nonzero__` method."
msgstr ""

#: ../../reference/datamodel.rst:1907
msgid ""
"Called to implement evaluation of ``self[key]``. For sequence types, the "
"accepted keys should be integers and slice objects.  Note that the special "
"interpretation of negative indexes (if the class wishes to emulate a "
"sequence type) is up to the :meth:`__getitem__` method. If *key* is of an "
"inappropriate type, :exc:`TypeError` may be raised; if of a value outside "
"the set of indexes for the sequence (after any special interpretation of "
"negative values), :exc:`IndexError` should be raised. For mapping types, if "
"*key* is missing (not in the container), :exc:`KeyError` should be raised."
msgstr ""

#: ../../reference/datamodel.rst:1918
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""

#: ../../reference/datamodel.rst:1924
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support changes to the values for keys, or if new keys can be added, or for "
"sequences if elements can be replaced.  The same exceptions should be raised "
"for improper *key* values as for the :meth:`__getitem__` method."
msgstr ""

#: ../../reference/datamodel.rst:1933
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support removal of keys, or for sequences if elements can be removed from "
"the sequence.  The same exceptions should be raised for improper *key* "
"values as for the :meth:`__getitem__` method."
msgstr ""

#: ../../reference/datamodel.rst:1942
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement ``self[key]`` "
"for dict subclasses when key is not in the dictionary."
msgstr ""

#: ../../reference/datamodel.rst:1948
msgid ""
"This method is called when an iterator is required for a container. This "
"method should return a new iterator object that can iterate over all the "
"objects in the container.  For mappings, it should iterate over the keys of "
"the container, and should also be made available as the method :meth:"
"`iterkeys`."
msgstr ""

#: ../../reference/datamodel.rst:1953
msgid ""
"Iterator objects also need to implement this method; they are required to "
"return themselves.  For more information on iterator objects, see :ref:"
"`typeiter`."
msgstr ""

#: ../../reference/datamodel.rst:1959
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ""

#: ../../reference/datamodel.rst:1963
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` and :"
"meth:`__getitem__`).  Objects that support the sequence protocol should only "
"provide :meth:`__reversed__` if they can provide an implementation that is "
"more efficient than the one provided by :func:`reversed`."
msgstr ""

#: ../../reference/datamodel.rst:1972
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a sequence.  However, container "
"objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be a sequence."
msgstr ""

#: ../../reference/datamodel.rst:1979
msgid ""
"Called to implement membership test operators.  Should return true if *item* "
"is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr ""

#: ../../reference/datamodel.rst:1983
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ""

#: ../../reference/datamodel.rst:1992
msgid "Additional methods for emulation of sequence types"
msgstr ""

#: ../../reference/datamodel.rst:1994
msgid ""
"The following optional methods can be defined to further emulate sequence "
"objects.  Immutable sequences methods should at most only define :meth:"
"`__getslice__`; mutable sequences might define all three methods."
msgstr ""

#: ../../reference/datamodel.rst:2001
msgid ""
"Support slice objects as parameters to the :meth:`__getitem__` method. "
"(However, built-in types in CPython currently still implement :meth:"
"`__getslice__`.  Therefore, you have to override it in derived classes when "
"implementing slicing.)"
msgstr ""

#: ../../reference/datamodel.rst:2007
msgid ""
"Called to implement evaluation of ``self[i:j]``. The returned object should "
"be of the same type as *self*.  Note that missing *i* or *j* in the slice "
"expression are replaced by zero or :attr:`sys.maxsize`, respectively.  If "
"negative indexes are used in the slice, the length of the sequence is added "
"to that index. If the instance does not implement the :meth:`__len__` "
"method, an :exc:`AttributeError` is raised. No guarantee is made that "
"indexes adjusted this way are not still negative.  Indexes which are greater "
"than the length of the sequence are not modified. If no :meth:`__getslice__` "
"is found, a slice object is created instead, and passed to :meth:"
"`__getitem__` instead."
msgstr ""

#: ../../reference/datamodel.rst:2020
msgid ""
"Called to implement assignment to ``self[i:j]``. Same notes for *i* and *j* "
"as for :meth:`__getslice__`."
msgstr ""

#: ../../reference/datamodel.rst:2023
msgid ""
"This method is deprecated. If no :meth:`__setslice__` is found, or for "
"extended slicing of the form ``self[i:j:k]``, a slice object is created, and "
"passed to :meth:`__setitem__`, instead of :meth:`__setslice__` being called."
msgstr ""

#: ../../reference/datamodel.rst:2030
msgid ""
"Called to implement deletion of ``self[i:j]``. Same notes for *i* and *j* as "
"for :meth:`__getslice__`. This method is deprecated. If no :meth:"
"`__delslice__` is found, or for extended slicing of the form ``self[i:j:"
"k]``, a slice object is created, and passed to :meth:`__delitem__`, instead "
"of :meth:`__delslice__` being called."
msgstr ""

#: ../../reference/datamodel.rst:2036
msgid ""
"Notice that these methods are only invoked when a single slice with a single "
"colon is used, and the slice method is available.  For slice operations "
"involving extended slice notation, or in absence of the slice methods, :meth:"
"`__getitem__`, :meth:`__setitem__` or :meth:`__delitem__` is called with a "
"slice object as argument."
msgstr ""

#: ../../reference/datamodel.rst:2042
msgid ""
"The following example demonstrate how to make your program or module "
"compatible with earlier versions of Python (assuming that methods :meth:"
"`__getitem__`, :meth:`__setitem__` and :meth:`__delitem__` support slice "
"objects as arguments)::"
msgstr ""

#: ../../reference/datamodel.rst:2067
msgid ""
"Note the calls to :func:`max`; these are necessary because of the handling "
"of negative indices before the :meth:`__\\*slice__` methods are called.  "
"When negative indexes are used, the :meth:`__\\*item__` methods receive them "
"as provided, but the :meth:`__\\*slice__` methods get a \"cooked\" form of "
"the index values.  For each negative index value, the length of the sequence "
"is added to the index before calling the method (which may still result in a "
"negative index); this is the customary handling of negative indexes by the "
"built-in sequence types, and the :meth:`__\\*item__` methods are expected to "
"do this as well.  However, since they should already be doing that, negative "
"indexes cannot be passed in; they must be constrained to the bounds of the "
"sequence before being passed to the :meth:`__\\*item__` methods. Calling "
"``max(0, i)`` conveniently returns the proper value."
msgstr ""

#: ../../reference/datamodel.rst:2084
msgid "Emulating numeric types"
msgstr ""

#: ../../reference/datamodel.rst:2086
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of "
"number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr ""

#: ../../reference/datamodel.rst:2110
msgid ""
"These methods are called to implement the binary arithmetic operations (``"
"+``, ``-``, ``*``, ``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, "
"``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to evaluate the "
"expression ``x + y``, where *x* is an instance of a class that has an :meth:"
"`__add__` method, ``x.__add__(y)`` is called.  The :meth:`__divmod__` method "
"should be the equivalent to using :meth:`__floordiv__` and :meth:`__mod__`; "
"it should not be related to :meth:`__truediv__` (described below).  Note "
"that :meth:`__pow__` should be defined to accept an optional third argument "
"if the ternary version of the built-in :func:`pow` function is to be "
"supported."
msgstr ""

#: ../../reference/datamodel.rst:2120
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return ``NotImplemented``."
msgstr ""

#: ../../reference/datamodel.rst:2127
msgid ""
"The division operator (``/``) is implemented by these methods.  The :meth:"
"`__truediv__` method is used when ``__future__.division`` is in effect, "
"otherwise :meth:`__div__` is used.  If only one of these two methods is "
"defined, the object will not support division in the alternate context; :exc:"
"`TypeError` will be raised instead."
msgstr ""

#: ../../reference/datamodel.rst:2153
msgid ""
"These methods are called to implement the binary arithmetic operations (``"
"+``, ``-``, ``*``, ``/``, ``%``, :func:`divmod`, :func:`pow`, ``**``, "
"``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected (swapped) operands.  "
"These functions are only called if the left operand does not support the "
"corresponding operation and the operands are of different types. [#]_ For "
"instance, to evaluate the expression ``x - y``, where *y* is an instance of "
"a class that has an :meth:`__rsub__` method, ``y.__rsub__(x)`` is called if "
"``x.__sub__(y)`` returns *NotImplemented*."
msgstr ""

#: ../../reference/datamodel.rst:2164
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr ""

#: ../../reference/datamodel.rst:2169
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides the reflected method for the operation, this method "
"will be called before the left operand's non-reflected method.  This "
"behavior allows subclasses to override their ancestors' operations."
msgstr ""

#: ../../reference/datamodel.rst:2189
msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, ``>>=``, "
"``&=``, ``^=``, ``|=``).  These methods should attempt to do the operation "
"in-place (modifying *self*) and return the result (which could be, but does "
"not have to be, *self*).  If a specific method is not defined, the augmented "
"assignment falls back to the normal methods.  For instance, to execute the "
"statement ``x += y``, where *x* is an instance of a class that has an :meth:"
"`__iadd__` method, ``x.__iadd__(y)`` is called.  If *x* is an instance of a "
"class that does not define a :meth:`__iadd__` method, ``x.__add__(y)`` and "
"``y.__radd__(x)`` are considered, as with the evaluation of ``x + y``."
msgstr ""

#: ../../reference/datamodel.rst:2208
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, :func:"
"`abs` and ``~``)."
msgstr ""

#: ../../reference/datamodel.rst:2223
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int`, :"
"func:`long`, and :func:`float`.  Should return a value of the appropriate "
"type."
msgstr ""

#: ../../reference/datamodel.rst:2234
msgid ""
"Called to implement the built-in functions :func:`oct` and :func:`hex`.  "
"Should return a string value."
msgstr ""

#: ../../reference/datamodel.rst:2240
msgid ""
"Called to implement :func:`operator.index`.  Also called whenever Python "
"needs an integer object (such as in slicing).  Must return an integer (int "
"or long)."
msgstr ""

#: ../../reference/datamodel.rst:2248
msgid ""
"Called to implement \"mixed-mode\" numeric arithmetic.  Should either return "
"a 2-tuple containing *self* and *other* converted to a common numeric type, "
"or ``None`` if conversion is impossible.  When the common type would be the "
"type of ``other``, it is sufficient to return ``None``, since the "
"interpreter will also ask the other object to attempt a coercion (but "
"sometimes, if the implementation of the other type cannot be changed, it is "
"useful to do the conversion to the other type here).  A return value of "
"``NotImplemented`` is equivalent to returning ``None``."
msgstr ""

#: ../../reference/datamodel.rst:2261
msgid "Coercion rules"
msgstr ""

#: ../../reference/datamodel.rst:2263
msgid ""
"This section used to document the rules for coercion.  As the language has "
"evolved, the coercion rules have become hard to document precisely; "
"documenting what one version of one particular implementation does is "
"undesirable.  Instead, here are some informal guidelines regarding "
"coercion.  In Python 3, coercion will not be supported."
msgstr ""

#: ../../reference/datamodel.rst:2271
msgid ""
"If the left operand of a % operator is a string or Unicode object, no "
"coercion takes place and the string formatting operation is invoked instead."
msgstr ""

#: ../../reference/datamodel.rst:2276
msgid ""
"It is no longer recommended to define a coercion operation. Mixed-mode "
"operations on types that don't define coercion pass the original arguments "
"to the operation."
msgstr ""

#: ../../reference/datamodel.rst:2282
msgid ""
"New-style classes (those derived from :class:`object`) never invoke the :"
"meth:`__coerce__` method in response to a binary operator; the only time :"
"meth:`__coerce__` is invoked is when the built-in function :func:`coerce` is "
"called."
msgstr ""

#: ../../reference/datamodel.rst:2289
msgid ""
"For most intents and purposes, an operator that returns ``NotImplemented`` "
"is treated the same as one that is not implemented at all."
msgstr ""

#: ../../reference/datamodel.rst:2294
msgid ""
"Below, :meth:`__op__` and :meth:`__rop__` are used to signify the generic "
"method names corresponding to an operator; :meth:`__iop__` is used for the "
"corresponding in-place operator.  For example, for the operator '``+``', :"
"meth:`__add__` and :meth:`__radd__` are used for the left and right variant "
"of the binary operator, and :meth:`__iadd__` for the in-place variant."
msgstr ""

#: ../../reference/datamodel.rst:2302
msgid ""
"For objects *x* and *y*, first ``x.__op__(y)`` is tried.  If this is not "
"implemented or returns ``NotImplemented``, ``y.__rop__(x)`` is tried.  If "
"this is also not implemented or returns ``NotImplemented``, a :exc:"
"`TypeError` exception is raised.  But see the following exception:"
msgstr ""

#: ../../reference/datamodel.rst:2309
msgid ""
"Exception to the previous item: if the left operand is an instance of a "
"built-in type or a new-style class, and the right operand is an instance of "
"a proper subclass of that type or class and overrides the base's :meth:"
"`__rop__` method, the right operand's :meth:`__rop__` method is tried "
"*before* the left operand's :meth:`__op__` method."
msgstr ""

#: ../../reference/datamodel.rst:2315
msgid ""
"This is done so that a subclass can completely override binary operators. "
"Otherwise, the left operand's :meth:`__op__` method would always accept the "
"right operand: when an instance of a given class is expected, an instance of "
"a subclass of that class is always acceptable."
msgstr ""

#: ../../reference/datamodel.rst:2322
msgid ""
"When either operand type defines a coercion, this coercion is called before "
"that type's :meth:`__op__` or :meth:`__rop__` method is called, but no "
"sooner.  If the coercion returns an object of a different type for the "
"operand whose coercion is invoked, part of the process is redone using the "
"new object."
msgstr ""

#: ../../reference/datamodel.rst:2329
msgid ""
"When an in-place operator (like '``+=``') is used, if the left operand "
"implements :meth:`__iop__`, it is invoked without any coercion.  When the "
"operation falls back to :meth:`__op__` and/or :meth:`__rop__`, the normal "
"coercion rules apply."
msgstr ""

#: ../../reference/datamodel.rst:2336
msgid ""
"In ``x + y``, if *x* is a sequence that implements sequence concatenation, "
"sequence concatenation is invoked."
msgstr ""

#: ../../reference/datamodel.rst:2341
msgid ""
"In ``x * y``, if one operand is a sequence that implements sequence "
"repetition, and the other is an integer (:class:`int` or :class:`long`), "
"sequence repetition is invoked."
msgstr ""

#: ../../reference/datamodel.rst:2347
msgid ""
"Rich comparisons (implemented by methods :meth:`__eq__` and so on) never use "
"coercion.  Three-way comparison (implemented by :meth:`__cmp__`) does use "
"coercion under the same conditions as other binary operations use it."
msgstr ""

#: ../../reference/datamodel.rst:2353
msgid ""
"In the current implementation, the built-in numeric types :class:`int`, :"
"class:`long`, :class:`float`, and :class:`complex` do not use coercion. All "
"these types implement a :meth:`__coerce__` method, for use by the built-in :"
"func:`coerce` function."
msgstr ""

#: ../../reference/datamodel.rst:2360
msgid ""
"The complex type no longer makes implicit calls to the :meth:`__coerce__` "
"method for mixed-type binary arithmetic operations."
msgstr ""

#: ../../reference/datamodel.rst:2367
msgid "With Statement Context Managers"
msgstr ""

#: ../../reference/datamodel.rst:2371
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be "
"established when executing a :keyword:`with` statement. The context manager "
"handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`with` statement (described in section :ref:`with`), but "
"can also be used by directly invoking their methods."
msgstr ""

#: ../../reference/datamodel.rst:2382
msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr ""

#: ../../reference/datamodel.rst:2385
msgid ""
"For more information on context managers, see :ref:`typecontextmanager`."
msgstr ""

#: ../../reference/datamodel.rst:2390
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in "
"the :keyword:`as` clause of the statement, if any."
msgstr ""

#: ../../reference/datamodel.rst:2397
msgid ""
"Exit the runtime context related to this object. The parameters describe the "
"exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr ""

#: ../../reference/datamodel.rst:2401
msgid ""
"If an exception is supplied, and the method wishes to suppress the exception "
"(i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr ""

#: ../../reference/datamodel.rst:2405
msgid ""
"Note that :meth:`__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ""

#: ../../reference/datamodel.rst:2412
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - The \"with\" statement"

#: ../../reference/datamodel.rst:2412
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""

#: ../../reference/datamodel.rst:2419
msgid "Special method lookup for old-style classes"
msgstr ""

#: ../../reference/datamodel.rst:2421
msgid ""
"For old-style classes, special methods are always looked up in exactly the "
"same way as any other method or attribute. This is the case regardless of "
"whether the method is being looked up explicitly as in ``x.__getitem__(i)`` "
"or implicitly as in ``x[i]``."
msgstr ""

#: ../../reference/datamodel.rst:2426
msgid ""
"This behaviour means that special methods may exhibit different behaviour "
"for different instances of a single old-style class if the appropriate "
"special attributes are set differently::"
msgstr ""

#: ../../reference/datamodel.rst:2446
msgid "Special method lookup for new-style classes"
msgstr ""

#: ../../reference/datamodel.rst:2448
msgid ""
"For new-style classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception (unlike the equivalent example with old-"
"style classes)::"
msgstr ""

#: ../../reference/datamodel.rst:2463
msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`__hash__` and :meth:`__repr__` that are implemented by all "
"objects, including type objects. If the implicit lookup of these methods "
"used the conventional lookup process, they would fail when invoked on the "
"type object itself::"
msgstr ""

#: ../../reference/datamodel.rst:2476
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is "
"sometimes referred to as 'metaclass confusion', and is avoided by bypassing "
"the instance when looking up special methods::"
msgstr ""

#: ../../reference/datamodel.rst:2485
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the :"
"meth:`__getattribute__` method even of the object's metaclass::"
msgstr ""

#: ../../reference/datamodel.rst:2512
msgid ""
"Bypassing the :meth:`__getattribute__` machinery in this fashion provides "
"significant scope for speed optimisations within the interpreter, at the "
"cost of some flexibility in the handling of special methods (the special "
"method *must* be set on the class object itself in order to be consistently "
"invoked by the interpreter)."
msgstr ""

#: ../../reference/datamodel.rst:2520
msgid "Footnotes"
msgstr "Notas de Rodapé"

#: ../../reference/datamodel.rst:2521
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr ""

#: ../../reference/datamodel.rst:2525
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method (such as :meth:`__add__`) fails the operation is not supported, which "
"is why the reflected method is not called."
msgstr ""

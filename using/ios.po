# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-27 14:20+0000\n"
"PO-Revision-Date: 2025-07-18 18:50+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../using/ios.rst:5
msgid "Using Python on iOS"
msgstr "Usando Python no iOS"

#: ../../using/ios.rst:0
msgid "Authors"
msgstr "Autores"

#: ../../using/ios.rst:8
msgid "Russell Keith-Magee (2024-03)"
msgstr "Russell Keith-Magee (2024-03)"

#: ../../using/ios.rst:10
msgid ""
"Python on iOS is unlike Python on desktop platforms. On a desktop platform, "
"Python is generally installed as a system resource that can be used by any "
"user of that computer. Users then interact with Python by running a :program:"
"`python` executable and entering commands at an interactive prompt, or by "
"running a Python script."
msgstr ""
"Python no iOS é diferente do Python em plataformas de desktop. Em uma "
"plataforma desktop, o Python geralmente é instalado como um recurso do "
"sistema que pode ser usado por qualquer usuário daquele computador. Os "
"usuários então interagem com o Python executando um executável :program:"
"`python` e inserindo comandos em um prompt interativo ou executando um "
"script Python."

#: ../../using/ios.rst:16
msgid ""
"On iOS, there is no concept of installing as a system resource. The only "
"unit of software distribution is an \"app\". There is also no console where "
"you could run a :program:`python` executable, or interact with a Python REPL."
msgstr ""
"No iOS, não existe o conceito de instalação como recurso do sistema. A única "
"unidade de distribuição de software é uma aplicação, ou \"app\". Também não "
"há console onde você possa executar um executável :program:`python` ou "
"interagir com um REPL do Python."

#: ../../using/ios.rst:20
msgid ""
"As a result, the only way you can use Python on iOS is in embedded mode - "
"that is, by writing a native iOS application, and embedding a Python "
"interpreter using ``libPython``, and invoking Python code using the :ref:"
"`Python embedding API <embedding>`. The full Python interpreter, the "
"standard library, and all your Python code is then packaged as a standalone "
"bundle that can be distributed via the iOS App Store."
msgstr ""
"Como resultado, a única maneira de usar Python no iOS é no modo incorporado "
"-- ou seja, escrevendo uma aplicação iOS nativo e incorporando um "
"interpretador Python usando ``libPython`` e invocando o código Python "
"usando :ref:`API de incorporação do Python <embedding>`. O interpretador "
"Python completo, a biblioteca padrão e todo o seu código Python são então "
"empacotados como um pacote independente que pode ser distribuído pela iOS "
"App Store."

#: ../../using/ios.rst:27
msgid ""
"If you're looking to experiment for the first time with writing an iOS app "
"in Python, projects such as `BeeWare <https://beeware.org>`__ and `Kivy "
"<https://kivy.org>`__ will provide a much more approachable user experience. "
"These projects manage the complexities associated with getting an iOS "
"project running, so you only need to deal with the Python code itself."
msgstr ""
"Se você deseja experimentar pela primeira vez escrever uma aplicação iOS em "
"Python, projetos como `BeeWare <https://beeware.org>`__ e `Kivy <https://"
"kivy.org>`__ irão fornecer uma experiência de usuário muito mais acessível. "
"Esses projetos gerenciam as complexidades associadas à execução de um "
"projeto iOS, portanto, você só precisa lidar com o próprio código Python."

#: ../../using/ios.rst:34
msgid "Python at runtime on iOS"
msgstr "Python em tempo de execução no iOS"

#: ../../using/ios.rst:37
msgid "iOS version compatibility"
msgstr "Compatibilidade com a versão do iOS"

#: ../../using/ios.rst:39
msgid ""
"The minimum supported iOS version is specified at compile time, using the :"
"option:`--host` option to ``configure``. By default, when compiled for iOS, "
"Python will be compiled with a minimum supported iOS version of 13.0. To use "
"a different minimum iOS version, provide the version number as part of the :"
"option:`!--host` argument - for example, ``--host=arm64-apple-ios15.4-"
"simulator`` would compile an ARM64 simulator build with a deployment target "
"of 15.4."
msgstr ""
"A versão mínima suportada do iOS é especificada em tempo de compilação, "
"usando a opção :option:`--host` do ``configure``. Por padrão, quando "
"compilado para iOS, Python será compilado com uma versão iOS mínima "
"suportada de 13.0. Para usar uma versão mínima diferente do iOS, forneça o "
"número da versão como parte do argumento :option:`!--host` - por exemplo, "
"``--host=arm64-apple-ios15.4-simulator`` compilaria um simulador ARM64 "
"construído com uma meta de implantação de 15.4."

#: ../../using/ios.rst:48
msgid "Platform identification"
msgstr "Identificação da plataforma"

#: ../../using/ios.rst:50
msgid ""
"When executing on iOS, ``sys.platform`` will report as ``ios``. This value "
"will be returned on an iPhone or iPad, regardless of whether the app is "
"running on the simulator or a physical device."
msgstr ""
"Ao executar no iOS, ``sys.platform`` reportará como ``ios``. Este valor será "
"retornado em um iPhone ou iPad, independentemente da aplicação estar "
"execitando no simulador ou em um dispositivo físico."

#: ../../using/ios.rst:54
msgid ""
"Information about the specific runtime environment, including the iOS "
"version, device model, and whether the device is a simulator, can be "
"obtained using :func:`platform.ios_ver`. :func:`platform.system` will report "
"``iOS`` or ``iPadOS``, depending on the device."
msgstr ""
"Informações sobre o ambiente de execução específico, incluindo a versão do "
"iOS, modelo do dispositivo e se o dispositivo é um simulador, podem ser "
"obtidas usando :func:`platform.ios_ver`. :func:`platform.system` reportará "
"``iOS`` ou ``iPadOS``, dependendo do dispositivo."

#: ../../using/ios.rst:59
msgid ""
":func:`os.uname` reports kernel-level details; it will report a name of "
"``Darwin``."
msgstr ""
":func:`os.uname` reporta detalhes em nível de kernel; ele reportará o nome "
"``Darwin``."

#: ../../using/ios.rst:63
msgid "Standard library availability"
msgstr "Disponibilidade da biblioteca padrão"

#: ../../using/ios.rst:65
msgid ""
"The Python standard library has some notable omissions and restrictions on "
"iOS. See the :ref:`API availability guide for iOS <mobile-availability>` for "
"details."
msgstr ""
"A biblioteca padrão do Python tem algumas omissões e restrições notáveis no "
"iOS. Consulte o :ref:`guia de disponibilidade de API para iOS <mobile-"
"availability>` para obter detalhes."

#: ../../using/ios.rst:70
msgid "Binary extension modules"
msgstr "Módulos de extensão binária"

#: ../../using/ios.rst:72
msgid ""
"One notable difference about iOS as a platform is that App Store "
"distribution imposes hard requirements on the packaging of an application. "
"One of these requirements governs how binary extension modules are "
"distributed."
msgstr ""
"Uma diferença notável sobre o iOS como plataforma é que a distribuição da "
"App Store impõe requisitos rígidos ao empacotamento de uma aplicação. Um "
"desses requisitos rege como os módulos de extensão binária são distribuídos."

#: ../../using/ios.rst:76
msgid ""
"The iOS App Store requires that *all* binary modules in an iOS app must be "
"dynamic libraries, contained in a framework with appropriate metadata, "
"stored in the ``Frameworks`` folder of the packaged app. There can be only a "
"single binary per framework, and there can be no executable binary material "
"outside the ``Frameworks`` folder."
msgstr ""
"A iOS App Store exige que *todos* os módulos binários em uma aplicação iOS "
"sejam bibliotecas dinâmicas, contidas em um framework com metadados "
"apropriados, armazenados na pasta ``Frameworks`` da aplicação empacotada. "
"Pode haver apenas um único binário por framework, e não pode haver nenhum "
"material binário executável fora da pasta ``Frameworks``."

#: ../../using/ios.rst:82
msgid ""
"This conflicts with the usual Python approach for distributing binaries, "
"which allows a binary extension module to be loaded from any location on "
"``sys.path``. To ensure compliance with App Store policies, an iOS project "
"must post-process any Python packages, converting ``.so`` binary modules "
"into individual standalone frameworks with appropriate metadata and signing. "
"For details on how to perform this post-processing, see the guide for :ref:"
"`adding Python to your project <adding-ios>`."
msgstr ""
"Isto entra em conflito com a abordagem usual do Python para distribuição de "
"binários, que permite que um módulo de extensão binária seja carregado de "
"qualquer local em ``sys.path``. Para garantir a conformidade com as "
"políticas da App Store, um projeto iOS deve pós-processar quaisquer pacotes "
"Python, convertendo módulos binários ``.so`` em estruturas independentes "
"individuais com metadados e assinatura apropriados. Para obter detalhes "
"sobre como realizar esse pós-processamento, consulte o guia para :ref:"
"`adicionar Python ao seu projeto <adding-ios>`."

#: ../../using/ios.rst:90
msgid ""
"To help Python discover binaries in their new location, the original ``.so`` "
"file on ``sys.path`` is replaced with a ``.fwork`` file. This file is a text "
"file containing the location of the framework binary, relative to the app "
"bundle. To allow the framework to resolve back to the original location, the "
"framework must contain a ``.origin`` file that contains the location of the "
"``.fwork`` file, relative to the app bundle."
msgstr ""
"Para ajudar o Python a descobrir binários em seu novo local, o arquivo ``."
"so`` original em ``sys.path`` é substituído por um arquivo ``.fwork``. Este "
"arquivo é um arquivo texto que contém a localização do binário do framework, "
"relativo ao pacote de aplicações. Para permitir que o framework retorne ao "
"local original, o framework deve conter um arquivo ``.origin`` que contém a "
"localização do arquivo ``.fwork``, relativo ao pacote da aplicação."

#: ../../using/ios.rst:97
msgid ""
"For example, consider the case of an import ``from foo.bar import _whiz``, "
"where ``_whiz`` is implemented with the binary module ``sources/foo/bar/"
"_whiz.abi3.so``, with ``sources`` being the location registered on ``sys."
"path``, relative to the application bundle. This module *must* be "
"distributed as ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` "
"(creating the framework name from the full import path of the module), with "
"an ``Info.plist`` file in the ``.framework`` directory identifying the "
"binary as a framework. The ``foo.bar._whiz`` module would be represented in "
"the original location with a ``sources/foo/bar/_whiz.abi3.fwork`` marker "
"file, containing the path ``Frameworks/foo.bar._whiz/foo.bar._whiz``. The "
"framework would also contain ``Frameworks/foo.bar._whiz.framework/foo.bar."
"_whiz.origin``, containing the path to the ``.fwork`` file."
msgstr ""
"Por exemplo, considere o caso de uma importação ``from foo.bar import "
"_whiz``, onde ``_whiz`` é implementado com o módulo binário ``sources/foo/"
"bar/_whiz.abi3.so``, com ``sources`` sendo o local registrado em ``sys."
"path``, relativo ao pacote da aplicação. Este módulo *deve* ser distribuído "
"como ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` (criando o nome do "
"framework a partir do caminho de importação completo do módulo), com um "
"arquivo ``Info.plist`` no diretório ``.framework`` identificando o binário "
"como um framework. O módulo ``foo.bar._whiz`` seria representado no local "
"original com um arquivo marcador ``sources/foo/bar/_whiz.abi3.fwork``, "
"contendo o caminho ``Frameworks/foo.bar._whiz/foo.bar._whiz``. O framework "
"também conteria ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz.origin``, "
"contendo o caminho para o arquivo ``.fwork``."

#: ../../using/ios.rst:110
msgid ""
"When running on iOS, the Python interpreter will install an :class:"
"`~importlib.machinery.AppleFrameworkLoader` that is able to read and import "
"``.fwork`` files. Once imported, the ``__file__`` attribute of the binary "
"module will report as the location of the ``.fwork`` file. However, the :"
"class:`~importlib.machinery.ModuleSpec` for the loaded module will report "
"the ``origin`` as the location of the binary in the framework folder."
msgstr ""
"Ao executar no iOS, o interpretador Python instalará um :class:`~importlib."
"machinery.AppleFrameworkLoader` que é capaz de ler e importar arquivos ``."
"fwork``. Uma vez importado, o atributo ``__file__`` do módulo binário "
"reportará como a localização do arquivo ``.fwork``. Entretanto, o :class:"
"`~importlib.machinery.ModuleSpec` para o módulo carregado reportará a "
"``origin`` como a localização do binário na pasta do framework."

#: ../../using/ios.rst:118
msgid "Compiler stub binaries"
msgstr "Binários stub do compilador"

#: ../../using/ios.rst:120
msgid ""
"Xcode doesn't expose explicit compilers for iOS; instead, it uses an "
"``xcrun`` script that resolves to a full compiler path (e.g., ``xcrun --sdk "
"iphoneos clang`` to get the ``clang`` for an iPhone device). However, using "
"this script poses two problems:"
msgstr ""
"O Xcode não expõe compiladores explícitos para iOS; em vez disso, ele usa um "
"script ``xcrun`` que resolve um caminho  do compilador (por exemplo, ``xcrun "
"--sdk iphoneos clang`` para obter o ``clang`` para um dispositivo iPhone). "
"No entanto, usar este script apresenta dois problemas:"

#: ../../using/ios.rst:125
msgid ""
"The output of ``xcrun`` includes paths that are machine specific, resulting "
"in a sysconfig module that cannot be shared between users; and"
msgstr ""
"A saída de ``xcrun`` inclui caminhos que são específicos da máquina, "
"resultando em um módulo sysconfig que não pode ser compartilhado entre "
"usuários; e"

#: ../../using/ios.rst:128
msgid ""
"It results in ``CC``/``CPP``/``LD``/``AR`` definitions that include spaces. "
"There is a lot of C ecosystem tooling that assumes that you can split a "
"command line at the first space to get the path to the compiler executable; "
"this isn't the case when using ``xcrun``."
msgstr ""
"Isso resulta em definições ``CC``/``CPP``/``LD``/``AR`` que incluem espaços. "
"Existem muitas ferramentas do ecossistema C que pressupõem que você pode "
"dividir uma linha de comando no primeiro espaço para obter o caminho para o "
"executável do compilador; este não é o caso ao usar ``xcrun``."

#: ../../using/ios.rst:133
msgid ""
"To avoid these problems, Python provided stubs for these tools. These stubs "
"are shell script wrappers around the underingly ``xcrun`` tools, distributed "
"in a ``bin`` folder distributed alongside the compiled iOS framework. These "
"scripts are relocatable, and will always resolve to the appropriate local "
"system paths. By including these scripts in the bin folder that accompanies "
"a framework, the contents of the ``sysconfig`` module becomes useful for end-"
"users to compile their own modules. When compiling third-party Python "
"modules for iOS, you should ensure these stub binaries are on your path."
msgstr ""
"Para evitar esses problemas, o Python forneceu stubs para essas ferramentas. "
"Esses stubs são wrappers de script de shell em torno das ferramentas "
"subjacentes ``xcrun``, distribuídos em uma pasta ``bin`` distribuída junto "
"com a estrutura iOS compilada. Esses scripts são relocáveis e sempre serão "
"resolvidos para os caminhos apropriados do sistema local. Ao incluir esses "
"scripts na pasta bin que acompanha um framework, o conteúdo do módulo "
"``sysconfig`` se torna útil para usuários finais compilarem seus próprios "
"módulos. Ao compilar módulos Python de terceiros para iOS, você deve "
"garantir que esses binários stub estejam no seu caminho."

#: ../../using/ios.rst:143
msgid "Installing Python on iOS"
msgstr "Instalando Python no iOS"

#: ../../using/ios.rst:146
msgid "Tools for building iOS apps"
msgstr "Ferramentas para construir aplicações de iOS"

#: ../../using/ios.rst:148
msgid ""
"Building for iOS requires the use of Apple's Xcode tooling. It is strongly "
"recommended that you use the most recent stable release of Xcode. This will "
"require the use of the most (or second-most) recently released macOS "
"version, as Apple does not maintain Xcode for older macOS versions. The "
"Xcode Command Line Tools are not sufficient for iOS development; you need a "
"*full* Xcode install."
msgstr ""
"A construção para iOS requer o uso das ferramentas Xcode da Apple. É "
"altamente recomendável que você use a versão estável mais recente do Xcode. "
"Isso exigirá o uso da versão mais recente (ou segunda) do macOS lançada "
"recentemente, já que a Apple não mantém o Xcode para versões mais antigas do "
"macOS. As ferramentas de linha de comando do Xcode não são suficientes para "
"o desenvolvimento iOS; você precisa de uma instalação *completa* do Xcode."

#: ../../using/ios.rst:155
msgid ""
"If you want to run your code on the iOS simulator, you'll also need to "
"install an iOS Simulator Platform. You should be prompted to select an iOS "
"Simulator Platform when you first run Xcode. Alternatively, you can add an "
"iOS Simulator Platform by selecting from the Platforms tab of the Xcode "
"Settings panel."
msgstr ""
"Se quiser executar seu código no simulador iOS, você também precisará "
"instalar um iOS Simulator Platform. Você deverá ser solicitado a selecionar "
"um iOS Simulator Platform ao executar o Xcode pela primeira vez. "
"Alternativamente, você pode adicionar um iOS Simulator Platform selecionando "
"na guia Platforms do painel Settings do Xcode."

#: ../../using/ios.rst:163
msgid "Adding Python to an iOS project"
msgstr "Adicionando Python a um projeto iOS"

#: ../../using/ios.rst:165
msgid ""
"Python can be added to any iOS project, using either Swift or Objective C. "
"The following examples will use Objective C; if you are using Swift, you may "
"find a library like `PythonKit <https://github.com/pvieito/PythonKit>`__ to "
"be helpful."
msgstr ""
"Python pode ser adicionado a qualquer projeto iOS, usando Swift ou Objective "
"C. Os exemplos a seguir usarão Objective C; se você estiver usando Swift, "
"poderá achar uma biblioteca como `PythonKit <https://github.com/pvieito/"
"PythonKit>`__ útil."

#: ../../using/ios.rst:170
msgid "To add Python to an iOS Xcode project:"
msgstr "Para adicionar Python a um projeto Xcode de iOS:"

#: ../../using/ios.rst:172
msgid ""
"Build or obtain a Python ``XCFramework``. See the instructions in :source:"
"`iOS/README.rst` (in the CPython source distribution) for details on how to "
"build a Python ``XCFramework``. At a minimum, you will need a build that "
"supports ``arm64-apple-ios``, plus one of either ``arm64-apple-ios-"
"simulator`` or ``x86_64-apple-ios-simulator``."
msgstr ""
"Construa ou obtenha um ``XCFramework`` em Python. Veja as instruções em :"
"source:`iOS/README.rst` (na distribuição fonte do CPython) para detalhes "
"sobre como construir um ``XCFramework`` em Python. No mínimo, você precisará "
"de uma construção que tenha suporte ``arm64-apple-ios``, além de ``arm64-"
"apple-ios-simulator`` ou ``x86_64-apple-ios-simulator``."

#: ../../using/ios.rst:178
msgid ""
"Drag the ``XCframework`` into your iOS project. In the following "
"instructions, we'll assume you've dropped the ``XCframework`` into the root "
"of your project; however, you can use any other location that you want by "
"adjusting paths as needed."
msgstr ""
"Arraste o ``XCframework`` para o seu projeto iOS. Nas instruções a seguir, "
"presumiremos que você colocou o ``XCframework`` na raiz do seu projeto; no "
"entanto, você pode usar qualquer outro local desejado ajustando os caminhos "
"conforme necessário."

#: ../../using/ios.rst:183
msgid ""
"Drag the ``iOS/Resources/dylib-Info-template.plist`` file into your project, "
"and ensure it is associated with the app target."
msgstr ""
"Arraste o arquivo ``iOS/Resources/dylib-Info-template.plist`` para o seu "
"projeto e certifique-se de que ele esteja associado ao destino da aplicação."

#: ../../using/ios.rst:186
msgid ""
"Add your application code as a folder in your Xcode project. In the "
"following instructions, we'll assume that your user code is in a folder "
"named ``app`` in the root of your project; you can use any other location by "
"adjusting paths as needed. Ensure that this folder is associated with your "
"app target."
msgstr ""
"Adicione o código da sua aplicação como uma pasta no seu projeto Xcode. Nas "
"instruções a seguir, presumiremos que seu código de usuário está em uma "
"pasta chamada ``app`` na raiz do seu projeto; você pode usar qualquer outro "
"local ajustando os caminhos conforme necessário. Certifique-se de que esta "
"pasta esteja associada ao destino da sua aplicação."

#: ../../using/ios.rst:192
msgid ""
"Select the app target by selecting the root node of your Xcode project, then "
"the target name in the sidebar that appears."
msgstr ""
"Selecione o destino da aplicação selecionando o nó raiz do seu projeto Xcode "
"e, em seguida, o nome do destino na barra lateral que aparece."

#: ../../using/ios.rst:195
msgid ""
"In the \"General\" settings, under \"Frameworks, Libraries and Embedded "
"Content\", add ``Python.xcframework``, with \"Embed & Sign\" selected."
msgstr ""
"Nas configurações de \"General\", em \"Frameworks, Libraries and Embedded "
"Content\", adicione ``Python.xcframework``, com \"Embed & Sign\" selecionado."

#: ../../using/ios.rst:198
msgid "In the \"Build Settings\" tab, modify the following:"
msgstr "Na guia \"Build Settings\", modifique o seguinte:"

#: ../../using/ios.rst:200
msgid "Build Options"
msgstr "Build Options"

#: ../../using/ios.rst:202
msgid "User Script Sandboxing: No"
msgstr "User Script Sandboxing: No"

#: ../../using/ios.rst:203
msgid "Enable Testability: Yes"
msgstr "Enable Testability: Yes"

#: ../../using/ios.rst:205
msgid "Search Paths"
msgstr "Search Paths"

#: ../../using/ios.rst:207
msgid "Framework Search Paths: ``$(PROJECT_DIR)``"
msgstr "Framework Search Paths: ``$(PROJECT_DIR)``"

#: ../../using/ios.rst:208
msgid ""
"Header Search Paths: ``\"$(BUILT_PRODUCTS_DIR)/Python.framework/Headers\"``"
msgstr ""
"Header Search Paths: ``\"$(BUILT_PRODUCTS_DIR)/Python.framework/Headers\"``"

#: ../../using/ios.rst:210
msgid "Apple Clang - Warnings - All languages"
msgstr "Apple Clang - Warnings - All languages"

#: ../../using/ios.rst:212
msgid "Quoted Include In Framework Header: No"
msgstr "Quoted Include In Framework Header: No"

#: ../../using/ios.rst:214
msgid ""
"Add a build step that copies the Python standard library into your app. In "
"the \"Build Phases\" tab, add a new \"Run Script\" build step *before* the "
"\"Embed Frameworks\" step, but *after* the \"Copy Bundle Resources\" step. "
"Name the step \"Install Target Specific Python Standard Library\", disable "
"the \"Based on dependency analysis\" checkbox, and set the script content to:"
msgstr ""
"Adicione uma etapa de construção que copie a biblioteca padrão do Python em "
"sua aplicação. Na aba \"Build Phases\", adicione uma nova etapa de "
"construção \"Run Script\" *antes* da etapa \"Embed Frameworks\", mas "
"*depois* da etapa \"Copy Bundle Resources\". Nomeie a etapa como \"Install "
"Target Specific Python Standard Library\", desative a caixa de seleção "
"\"Based on dependency analysis\" e defina o conteúdo do script como:"

#: ../../using/ios.rst:220
msgid ""
"set -e\n"
"\n"
"mkdir -p \"$CODESIGNING_FOLDER_PATH/python/lib\"\n"
"if [ \"$EFFECTIVE_PLATFORM_NAME\" = \"-iphonesimulator\" ]; then\n"
"    echo \"Installing Python modules for iOS Simulator\"\n"
"    rsync -au --delete \"$PROJECT_DIR/Python.xcframework/ios-arm64_x86_64-"
"simulator/lib/\" \"$CODESIGNING_FOLDER_PATH/python/lib/\"\n"
"else\n"
"    echo \"Installing Python modules for iOS Device\"\n"
"    rsync -au --delete \"$PROJECT_DIR/Python.xcframework/ios-arm64/lib/\" "
"\"$CODESIGNING_FOLDER_PATH/python/lib/\"\n"
"fi"
msgstr ""
"set -e\n"
"\n"
"mkdir -p \"$CODESIGNING_FOLDER_PATH/python/lib\"\n"
"if [ \"$EFFECTIVE_PLATFORM_NAME\" = \"-iphonesimulator\" ]; then\n"
"    echo \"Instalando módulos Python para iOS Simulator\"\n"
"    rsync -au --delete \"$PROJECT_DIR/Python.xcframework/ios-arm64_x86_64-"
"simulator/lib/\" \"$CODESIGNING_FOLDER_PATH/python/lib/\"\n"
"else\n"
"    echo \"Instalando módulos Python para iOS Device\"\n"
"    rsync -au --delete \"$PROJECT_DIR/Python.xcframework/ios-arm64/lib/\" "
"\"$CODESIGNING_FOLDER_PATH/python/lib/\"\n"
"fi"

#: ../../using/ios.rst:233
msgid ""
"Note that the name of the simulator \"slice\" in the XCframework may be "
"different, depending the CPU architectures your ``XCFramework`` supports."
msgstr ""
"Note que o nome da \"fatia\" do simulador no XCframework pode ser diferente, "
"dependendo das arquiteturas de CPU que seu ``XCFramework`` provê suporte."

#: ../../using/ios.rst:236
msgid ""
"Add a second build step that processes the binary extension modules in the "
"standard library into \"Framework\" format. Add a \"Run Script\" build step "
"*directly after* the one you added in step 8, named \"Prepare Python Binary "
"Modules\". It should also have \"Based on dependency analysis\" unchecked, "
"with the following script content:"
msgstr ""
"Adicione uma segunda etapa de construção que processe os módulos de extensão "
"binária na biblioteca padrão no formato \"Framework\". Adicione uma etapa de "
"construção \"Run Script\" *diretamente após* aquela que você adicionou na "
"etapa 8, chamada \"Prepare Python Binary Modules\". Também deve ter \"Based "
"on dependency analysis\" desmarcado, com o seguinte conteúdo de script:"

#: ../../using/ios.rst:242
msgid ""
"set -e\n"
"\n"
"install_dylib () {\n"
"    INSTALL_BASE=$1\n"
"    FULL_EXT=$2\n"
"\n"
"    # The name of the extension file\n"
"    EXT=$(basename \"$FULL_EXT\")\n"
"    # The location of the extension file, relative to the bundle\n"
"    RELATIVE_EXT=${FULL_EXT#$CODESIGNING_FOLDER_PATH/}\n"
"    # The path to the extension file, relative to the install base\n"
"    PYTHON_EXT=${RELATIVE_EXT/$INSTALL_BASE/}\n"
"    # The full dotted name of the extension module, constructed from the "
"file path.\n"
"    FULL_MODULE_NAME=$(echo $PYTHON_EXT | cut -d \".\" -f 1 | tr \"/\" \"."
"\");\n"
"    # A bundle identifier; not actually used, but required by Xcode "
"framework packaging\n"
"    FRAMEWORK_BUNDLE_ID=$(echo $PRODUCT_BUNDLE_IDENTIFIER.$FULL_MODULE_NAME "
"| tr \"_\" \"-\")\n"
"    # The name of the framework folder.\n"
"    FRAMEWORK_FOLDER=\"Frameworks/$FULL_MODULE_NAME.framework\"\n"
"\n"
"    # If the framework folder doesn't exist, create it.\n"
"    if [ ! -d \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER\" ]; then\n"
"        echo \"Creating framework for $RELATIVE_EXT\"\n"
"        mkdir -p \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER\"\n"
"        cp \"$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"        plutil -replace CFBundleExecutable -string \"$FULL_MODULE_NAME\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"        plutil -replace CFBundleIdentifier -string \"$FRAMEWORK_BUNDLE_ID\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"    fi\n"
"\n"
"    echo \"Installing binary for $FRAMEWORK_FOLDER/$FULL_MODULE_NAME\"\n"
"    mv \"$FULL_EXT\" \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/"
"$FULL_MODULE_NAME\"\n"
"    # Create a placeholder .fwork file where the .so was\n"
"    echo \"$FRAMEWORK_FOLDER/$FULL_MODULE_NAME\" > ${FULL_EXT%.so}.fwork\n"
"    # Create a back reference to the .so file location in the framework\n"
"    echo \"${RELATIVE_EXT%.so}.fwork\" > \"$CODESIGNING_FOLDER_PATH/"
"$FRAMEWORK_FOLDER/$FULL_MODULE_NAME.origin\"\n"
" }\n"
"\n"
" PYTHON_VER=$(ls -1 \"$CODESIGNING_FOLDER_PATH/python/lib\")\n"
" echo \"Install Python $PYTHON_VER standard library extension modules...\"\n"
" find \"$CODESIGNING_FOLDER_PATH/python/lib/$PYTHON_VER/lib-dynload\" -name "
"\"*.so\" | while read FULL_EXT; do\n"
"    install_dylib python/lib/$PYTHON_VER/lib-dynload/ \"$FULL_EXT\"\n"
" done\n"
"\n"
" # Clean up dylib template\n"
" rm -f \"$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist\"\n"
"\n"
" echo \"Signing frameworks as $EXPANDED_CODE_SIGN_IDENTITY_NAME "
"($EXPANDED_CODE_SIGN_IDENTITY)...\"\n"
" find \"$CODESIGNING_FOLDER_PATH/Frameworks\" -name \"*.framework\" -exec /"
"usr/bin/codesign --force --sign \"$EXPANDED_CODE_SIGN_IDENTITY\" "
"${OTHER_CODE_SIGN_FLAGS:-} -o runtime --timestamp=none --preserve-"
"metadata=identifier,entitlements,flags --generate-entitlement-der \"{}\" \\;"
msgstr ""
"set -e\n"
"\n"
"install_dylib () {\n"
"    INSTALL_BASE=$1\n"
"    FULL_EXT=$2\n"
"\n"
"    # O nome do arquivo da extensão\n"
"    EXT=$(basename \"$FULL_EXT\")\n"
"    # A localização do arquivo da extensão, relativo ao pacote\n"
"    RELATIVE_EXT=${FULL_EXT#$CODESIGNING_FOLDER_PATH/}\n"
"    # O caminho para o arquivo da extensão, relativo à base de instalação\n"
"    PYTHON_EXT=${RELATIVE_EXT/$INSTALL_BASE/}\n"
"    # O nome completo e pontilhado do módulo de extensão, construído a "
"partir do caminho do arquivo.\n"
"    FULL_MODULE_NAME=$(echo $PYTHON_EXT | cut -d \".\" -f 1 | tr \"/\" \"."
"\");\n"
"    # Um identificador de pacote; não é realmente usado, mas é necessário "
"para empacotamento de frameworks no Xcode\n"
"    FRAMEWORK_BUNDLE_ID=$(echo $PRODUCT_BUNDLE_IDENTIFIER.$FULL_MODULE_NAME "
"| tr \"_\" \"-\")\n"
"    # O nome da pasta do framework.\n"
"    FRAMEWORK_FOLDER=\"Frameworks/$FULL_MODULE_NAME.framework\"\n"
"\n"
"    # Se a pasta do framework não existir, cria-a.\n"
"    if [ ! -d \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER\" ]; then\n"
"        echo \"Criando framework para $RELATIVE_EXT\"\n"
"        mkdir -p \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER\"\n"
"        cp \"$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"        plutil -replace CFBundleExecutable -string \"$FULL_MODULE_NAME\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"        plutil -replace CFBundleIdentifier -string \"$FRAMEWORK_BUNDLE_ID\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"    fi\n"
"\n"
"    echo \"Instalando binário para $FRAMEWORK_FOLDER/$FULL_MODULE_NAME\"\n"
"    mv \"$FULL_EXT\" \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/"
"$FULL_MODULE_NAME\"\n"
"    # Cria um arquivo substituto .fwork onde o .so estava\n"
"    echo \"$FRAMEWORK_FOLDER/$FULL_MODULE_NAME\" > ${FULL_EXT%.so}.fwork\n"
"    # Cria uma referência para o local do arquivo .so no framework\n"
"    echo \"${RELATIVE_EXT%.so}.fwork\" > \"$CODESIGNING_FOLDER_PATH/"
"$FRAMEWORK_FOLDER/$FULL_MODULE_NAME.origin\"\n"
"}\n"
"\n"
"PYTHON_VER=$(ls -1 \"$CODESIGNING_FOLDER_PATH/python/lib\")\n"
"echo \"Instalando módulos de extensão da biblioteca padrão para Python "
"$PYTHON_VER...\"\n"
"find \"$CODESIGNING_FOLDER_PATH/python/lib/$PYTHON_VER/lib-dynload\" -name "
"\"*.so\" | while read FULL_EXT; do\n"
"    install_dylib python/lib/$PYTHON_VER/lib-dynload/ \"$FULL_EXT\"\n"
"done\n"
"\n"
"# Remove o modelo dylib\n"
"rm -f \"$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist\"\n"
"\n"
"echo \"Assinando frameworks como $EXPANDED_CODE_SIGN_IDENTITY_NAME "
"($EXPANDED_CODE_SIGN_IDENTITY)...\"\n"
"find \"$CODESIGNING_FOLDER_PATH/Frameworks\" -name \"*.framework\" -exec /"
"usr/bin/codesign --force --sign \"$EXPANDED_CODE_SIGN_IDENTITY\" "
"${OTHER_CODE_SIGN_FLAGS:-} -o runtime --timestamp=none --preserve-"
"metadata=identifier,entitlements,flags --generate-entitlement-der \"{}\" \\;"

#: ../../using/ios.rst:292
msgid ""
"Add Objective C code to initialize and use a Python interpreter in embedded "
"mode. You should ensure that:"
msgstr ""
"Adicione código Objective C para inicializar e usar um interpretador Python "
"em modo embarcado. Você deve garantir que:"

#: ../../using/ios.rst:295
msgid "UTF-8 mode (:c:member:`PyPreConfig.utf8_mode`) is *enabled*;"
msgstr "Modo UTF-8 (:c:member:`PyPreConfig.utf8_mode`) esteja habilitado;"

#: ../../using/ios.rst:296
msgid "Buffered stdio (:c:member:`PyConfig.buffered_stdio`) is *disabled*;"
msgstr ""
"Stdio buffered (:c:member:`PyConfig.buffered_stdio`) esteja desabilitado;"

#: ../../using/ios.rst:297
msgid "Writing bytecode (:c:member:`PyConfig.write_bytecode`) is *disabled*;"
msgstr ""
"Escrita de bytecode (:c:member:`PyConfig.write_bytecode`) esteja "
"desabilitada;"

#: ../../using/ios.rst:298
msgid ""
"Signal handlers (:c:member:`PyConfig.install_signal_handlers`) are *enabled*;"
msgstr ""
"Manipuladores de sinais (:c:member:`PyConfig.install_signal_handlers`) "
"estejam habilitados;"

#: ../../using/ios.rst:299
msgid ""
"System logging (:c:member:`PyConfig.use_system_logger`) is *enabled* "
"(optional, but strongly recommended; this is enabled by default);"
msgstr ""
"Registro de logs do sistema (:c:member:`PyConfig.use_system_logger`) esteja "
"desabilitado (opcional, mas fortemente recomendado; isso está habilitado por "
"padrão);"

#: ../../using/ios.rst:301
msgid ""
":envvar:`PYTHONHOME` for the interpreter is configured to point at the "
"``python`` subfolder of your app's bundle; and"
msgstr ""
":envvar:`PYTHONHOME` para o interpretador esteja configurado para apontar "
"para a subpasta ``python`` do pacote da sua aplicação; e"

#: ../../using/ios.rst:303
msgid "The :envvar:`PYTHONPATH` for the interpreter includes:"
msgstr "O :envvar:`PYTHONPATH` para o interpretador inclui:"

#: ../../using/ios.rst:305
msgid "the ``python/lib/python3.X`` subfolder of your app's bundle,"
msgstr "a subpasta ``python/lib/python3.X`` do pacote da sua aplicação,"

#: ../../using/ios.rst:306
msgid ""
"the ``python/lib/python3.X/lib-dynload`` subfolder of your app's bundle, and"
msgstr ""
"a subpasta ``python/lib/python3.X/lib-dynload`` do pacote da sua aplicação, e"

#: ../../using/ios.rst:307
msgid "the ``app`` subfolder of your app's bundle"
msgstr "a subpasta ``app`` do pacote da sua aplicação"

#: ../../using/ios.rst:309
msgid ""
"Your app's bundle location can be determined using ``[[NSBundle mainBundle] "
"resourcePath]``."
msgstr ""
"O local do pacote da sua aplicação pode ser determinada usando ``[[NSBundle "
"mainBundle] resourcePath]``."

#: ../../using/ios.rst:312
msgid ""
"Steps 8, 9 and 10 of these instructions assume that you have a single folder "
"of pure Python application code, named ``app``. If you have third-party "
"binary modules in your app, some additional steps will be required:"
msgstr ""
"Os passos 8, 9 e 10 destas instruções presumem que você tem uma única pasta "
"de código de aplicação Python puro, chamada ``app``. Se você tiver módulos "
"binários de terceiros em sua aplicação, serão necessárias algumas etapas "
"adicionais:"

#: ../../using/ios.rst:316
msgid ""
"You need to ensure that any folders containing third-party binaries are "
"either associated with the app target, or copied in as part of step 8. Step "
"8 should also purge any binaries that are not appropriate for the platform a "
"specific build is targeting (i.e., delete any device binaries if you're "
"building an app targeting the simulator)."
msgstr ""
"Você precisa garantir que todas as pastas que contenham binários de "
"terceiros sejam associadas ao destino da aplicação ou copiadas como parte da "
"etapa 8. A etapa 8 também deve limpar quaisquer binários que não sejam "
"apropriados para a plataforma que uma construção específica está "
"direcionando (ou seja, exclua todos os binários do dispositivo se estiver "
"criando uma aplicação direcionado ao simulador)."

#: ../../using/ios.rst:322
msgid ""
"Any folders that contain third-party binaries must be processed into "
"framework form by step 9. The invocation of ``install_dylib`` that processes "
"the ``lib-dynload`` folder can be copied and adapted for this purpose."
msgstr ""
"Quaisquer pastas que contenham binários de terceiros devem ser processadas "
"no formato framework no passo 9. A invocação de ``install_dylib`` que "
"processa a pasta ``lib-dynload`` pode ser copiada e adaptada para este "
"propósito."

#: ../../using/ios.rst:326
msgid ""
"If you're using a separate folder for third-party packages, ensure that "
"folder is included as part of the :envvar:`PYTHONPATH` configuration in step "
"10."
msgstr ""
"Se você estiver usando uma pasta separada para pacotes de terceiros, "
"certifique-se de que essa pasta esteja incluída como parte da configuração :"
"envvar:`PYTHONPATH` no passo 10."

#: ../../using/ios.rst:329
msgid ""
"If any of the folders that contain third-party packages will contain ``."
"pth`` files, you should add that folder as a *site directory* (using :meth:"
"`site.addsitedir`), rather than adding to :envvar:`PYTHONPATH` or :attr:`sys."
"path` directly."
msgstr ""
"Se alguma das pastas que contêm pacotes de terceiros contiver arquivos ``."
"pth``, você deverá adicionar essa pasta como um *diretório de site* (usando :"
"meth:`site.addsitedir`), em vez de adicioná-la diretamente a :envvar:"
"`PYTHONPATH` ou :attr:`sys.path`."

#: ../../using/ios.rst:335
msgid "Testing a Python package"
msgstr "Testando um pacote Python"

#: ../../using/ios.rst:337
msgid ""
"The CPython source tree contains :source:`a testbed project <iOS/testbed>` "
"that is used to run the CPython test suite on the iOS simulator. This "
"testbed can also be used as a testbed project for running your Python "
"library's test suite on iOS."
msgstr ""
"A árvore de fontes do CPython contém :source:`um projeto de banco de testes "
"<iOS/testbed>` que é usado para executar o conjunto de testes do CPython no "
"simulador do iOS. Este banco de testes também pode ser usado como um projeto "
"de banco de testes para executar o conjunto de testes da sua biblioteca "
"Python no iOS."

#: ../../using/ios.rst:341
msgid ""
"After building or obtaining an iOS XCFramework (See :source:`iOS/README.rst` "
"for details), create a clone of the Python iOS testbed project by running:"
msgstr ""
"Depois de criar ou obter um iOS XCFramework (consulte :source:`iOS/README."
"rst` para obter detalhes), crie um clone do projeto de banco de testes de "
"iOS do Python executando:"

#: ../../using/ios.rst:344
msgid ""
"$ python iOS/testbed clone --framework <path/to/Python.xcframework> --app "
"<path/to/module1> --app <path/to/module2> app-testbed"
msgstr ""
"$ python iOS/testbed clone --framework <caminho/para/Python.xcframework> --"
"app <caminho/para/módulo1> --app <caminho/para/módulo2> app-testbed"

#: ../../using/ios.rst:348
msgid ""
"You will need to modify the ``iOS/testbed`` reference to point to that "
"directory in the CPython source tree; any folders specified with the ``--"
"app`` flag will be copied into the cloned testbed project. The resulting "
"testbed will be created in the ``app-testbed`` folder. In this example, the "
"``module1`` and ``module2`` would be importable modules at runtime. If your "
"project has additional dependencies, they can be installed into the ``app-"
"testbed/iOSTestbed/app_packages`` folder (using ``pip install --target app-"
"testbed/iOSTestbed/app_packages`` or similar)."
msgstr ""
"Você precisará modificar a referência ``iOS/testbed`` para apontar para esse "
"diretório na árvore de fontes do CPython; todas as pastas especificadas com "
"o sinalizador ``--app`` serão copiadas para o projeto de banco de testes "
"clonado. O banco de testes resultante será criado na pasta ``app-testbed``. "
"Neste exemplo, ``módulo1`` e ``módulo2`` seriam módulos importáveis em tempo "
"de execução. Se seu projeto tiver dependências adicionais, elas podem ser "
"instaladas na pasta ``app-testbed/iOSTestbed/app_packages`` (usando ``pip "
"install --target app-testbed/iOSTestbed/app_packages`` ou similar)."

#: ../../using/ios.rst:357
msgid ""
"You can then use the ``app-testbed`` folder to run the test suite for your "
"app, For example, if ``module1.tests`` was the entry point to your test "
"suite, you could run:"
msgstr ""
"Você pode então usar a pasta ``app-testbed`` para executar o conjunto de "
"testes para seu aplicativo. Por exemplo, se ``módulo1.tests`` fosse o ponto "
"de entrada para seu conjunto de testes, você poderia executar:"

#: ../../using/ios.rst:361
msgid "$ python app-testbed run -- module1.tests"
msgstr "$ python app-testbed run -- módulo1.tests"

#: ../../using/ios.rst:365
msgid ""
"This is the equivalent of running ``python -m module1.tests`` on a desktop "
"Python build. Any arguments after the ``--`` will be passed to the testbed "
"as if they were arguments to ``python -m`` on a desktop machine."
msgstr ""
"Isso é o equivalente a executar ``python -m módulo1.tests`` em uma "
"compilação Python de desktop. Quaisquer argumentos após ``--`` serão "
"passados para o banco de testes como se fossem argumentos para ``python -m`` "
"em uma máquina de desktop."

#: ../../using/ios.rst:369
msgid "You can also open the testbed project in Xcode by running:"
msgstr "Você também pode abrir o projeto de teste no Xcode executando:"

#: ../../using/ios.rst:371
msgid "$ open app-testbed/iOSTestbed.xcodeproj"
msgstr "$ open app-testbed/iOSTestbed.xcodeproj"

#: ../../using/ios.rst:375
msgid "This will allow you to use the full Xcode suite of tools for debugging."
msgstr ""
"Isso permitirá que você use o conjunto completo de ferramentas do Xcode para "
"depuração."

#: ../../using/ios.rst:378
msgid "App Store Compliance"
msgstr "Conformidade com a App Store"

#: ../../using/ios.rst:380
msgid ""
"The only mechanism for distributing apps to third-party iOS devices is to "
"submit the app to the iOS App Store; apps submitted for distribution must "
"pass Apple's app review process. This process includes a set of automated "
"validation rules that inspect the submitted application bundle for "
"problematic code."
msgstr ""
"O único mecanismo para distribuir aplicações para dispositivos iOS de "
"terceiros é enviar a aplicação para a App Store do iOS; as aplicações "
"enviadas para distribuição devem passar pelo processo de revisão de "
"aplicações da Apple. Esse processo inclui um conjunto de regras de validação "
"automatizadas que inspecionam o pacote de aplicação enviado em busca de "
"código problemático."

#: ../../using/ios.rst:385
msgid ""
"The Python standard library contains some code that is known to violate "
"these automated rules. While these violations appear to be false positives, "
"Apple's review rules cannot be challenged; so, it is necessary to modify the "
"Python standard library for an app to pass App Store review."
msgstr ""
"A biblioteca padrão do Python contém alguns códigos que violam essas regras "
"automatizadas. Embora essas violações pareçam ser falsos positivos, as "
"regras de revisão da Apple não podem ser contestadas; portanto, é necessário "
"modificar a biblioteca padrão do Python para que uma aplicação passe na "
"revisão da App Store."

#: ../../using/ios.rst:390
msgid ""
"The Python source tree contains :source:`a patch file <Mac/Resources/app-"
"store-compliance.patch>` that will remove all code that is known to cause "
"issues with the App Store review process. This patch is applied "
"automatically when building for iOS."
msgstr ""
"A árvore de fontes do Python contém :source:`um arquivo de patch <Mac/"
"Resources/app-store-compliance.patch>` que removerá todo o código que é "
"conhecido por causar problemas no processo de revisão da App Store. Este "
"patch é aplicado automaticamente quando o ao construir para o iOS."

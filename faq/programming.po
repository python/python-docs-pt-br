# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Tiago Henrique <tiagohrm@gmail.com>, 2021
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2021
# Augusta Carla Klug <augustaklug@gmail.com>, 2021
# Leonardo Mendes, 2021
# Rodrigo Cendamore, 2023
# Vitor Buxbaum Orlandi, 2023
# Jones Martins, 2024
# Adorilson Bezerra <adorilson@gmail.com>, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-02 14:19+0000\n"
"PO-Revision-Date: 2021-06-28 00:52+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../faq/programming.rst:5
msgid "Programming FAQ"
msgstr "FAQ sobre programação"

#: ../../faq/programming.rst:8
msgid "Contents"
msgstr "Conteúdo"

#: ../../faq/programming.rst:12
msgid "General Questions"
msgstr "Perguntas gerais"

#: ../../faq/programming.rst:15
msgid ""
"Is there a source code level debugger with breakpoints, single-stepping, "
"etc.?"
msgstr ""
"Existe um depurador a nível de código-fonte que possua pontos de interrupção "
"(*breakpoints*), single-stepping, etc.?"

#: ../../faq/programming.rst:17 ../../faq/programming.rst:58
msgid "Yes."
msgstr "Sim."

#: ../../faq/programming.rst:19
msgid ""
"Several debuggers for Python are described below, and the built-in function :"
"func:`breakpoint` allows you to drop into any of them."
msgstr ""
"Vários depuradores para Python estão descritos abaixo, e a função embutida :"
"func:`breakpoint` permite que você caia em qualquer um desses pontos."

#: ../../faq/programming.rst:22
msgid ""
"The pdb module is a simple but adequate console-mode debugger for Python. It "
"is part of the standard Python library, and is :mod:`documented in the "
"Library Reference Manual <pdb>`. You can also write your own debugger by "
"using the code for pdb as an example."
msgstr ""
"O módulo pdb é um depurador em modo Console simples, mas adequado, para o "
"Python. Faz parte da biblioteca padrão do Python e está documentado no :mod:"
"`manual de referencia da biblioteca <pdb>`. Você também pode construir do "
"seu próprio depurador usando o código do pdb como um exemplo."

#: ../../faq/programming.rst:27
msgid ""
"The IDLE interactive development environment, which is part of the standard "
"Python distribution (normally available as `Tools/scripts/idle3 <https://"
"github.com/python/cpython/blob/main/Tools/scripts/idle3>`_), includes a "
"graphical debugger."
msgstr ""
"O IDLE é um ambiente interativo de desenvolvimento que faz parte da "
"distribuição padrão do Python (normalmente acessível como `Tools/scripts/"
"idle3 <https://github.com/python/cpython/blob/main/Tools/scripts/idle3>`_), "
"e inclui um depurador gráfico."

#: ../../faq/programming.rst:32
msgid ""
"PythonWin is a Python IDE that includes a GUI debugger based on pdb.  The "
"PythonWin debugger colors breakpoints and has quite a few cool features such "
"as debugging non-PythonWin programs.  PythonWin is available as part of "
"`pywin32 <https://github.com/mhammond/pywin32>`_ project and as a part of "
"the `ActivePython <https://www.activestate.com/products/python/>`_ "
"distribution."
msgstr ""
"O PythonWin é uma IDE feita para o Python que inclui um depurador gráfico "
"baseado no pdb. O depurador do PythonWin colore os pontos de interrupção e "
"tem alguns recursos legais, como a depuração de programas que não são "
"PythonWin. O PythonWin está disponível como parte do projeto `pywin32 "
"<https://github.com/mhammond/pywin32>`_ e como parte da distribuição "
"`ActivePython <https://www.activestate.com/products/python/>`_."

#: ../../faq/programming.rst:39
msgid ""
"`Eric <https://eric-ide.python-projects.org/>`_ is an IDE built on PyQt and "
"the Scintilla editing component."
msgstr ""
"`Eric <https://eric-ide.python-projects.org/>`_ é uma IDE construída com "
"PyQt e o componente de edição Scintilla."

#: ../../faq/programming.rst:42
msgid ""
"`trepan3k <https://github.com/rocky/python3-trepan/>`_ is a gdb-like "
"debugger."
msgstr ""
"`trepan3k <https://github.com/rocky/python3-trepan/>`_ é um depurador "
"similar ao gdb."

#: ../../faq/programming.rst:44
msgid ""
"`Visual Studio Code <https://code.visualstudio.com/>`_ is an IDE with "
"debugging tools that integrates with version-control software."
msgstr ""
"`Visual Studio Code <https://code.visualstudio.com/>`_ é uma IDE com "
"ferramentas de depuração integrada com softwares de controle de versão."

#: ../../faq/programming.rst:47
msgid ""
"There are a number of commercial Python IDEs that include graphical "
"debuggers. They include:"
msgstr ""
"Há uma série de IDE comerciais para desenvolvimento com o Python que inclui "
"depuradores gráficos. Dentre tantas temos:"

#: ../../faq/programming.rst:50
msgid "`Wing IDE <https://wingware.com/>`_"
msgstr "`Wing IDE <https://wingware.com/>`_"

#: ../../faq/programming.rst:51
msgid "`Komodo IDE <https://www.activestate.com/products/komodo-ide/>`_"
msgstr "`Komodo IDE <https://www.activestate.com/products/komodo-ide/>`_"

#: ../../faq/programming.rst:52
msgid "`PyCharm <https://www.jetbrains.com/pycharm/>`_"
msgstr "`PyCharm <https://www.jetbrains.com/pycharm/>`_"

#: ../../faq/programming.rst:56
msgid "Are there tools to help find bugs or perform static analysis?"
msgstr ""
"Existem ferramentas para ajudar a encontrar bugs ou fazer análise estática "
"de desempenho?"

#: ../../faq/programming.rst:60
msgid ""
"`Pylint <https://pylint.pycqa.org/en/latest/index.html>`_ and `Pyflakes "
"<https://github.com/PyCQA/pyflakes>`_ do basic checking that will help you "
"catch bugs sooner."
msgstr ""
"`Pylint <https://pylint.pycqa.org/en/latest/index.html>`_ e `Pyflakes "
"<https://github.com/PyCQA/pyflakes>`_ fazem verificações básicas que te "
"ajudarão a encontrar erros mais cedo."

#: ../../faq/programming.rst:64
msgid ""
"Static type checkers such as `Mypy <https://mypy-lang.org/>`_, `Pyre "
"<https://pyre-check.org/>`_, and `Pytype <https://github.com/google/"
"pytype>`_ can check type hints in Python source code."
msgstr ""
"Verificadores de tipo estático como `Mypy <https://mypy-lang.org/>`_, `Pyre "
"<https://pyre-check.org/>`_ e `Pytype <https://github.com/google/pytype>`_ "
"conseguem verificar dicas de tipo em código-fonte Python."

#: ../../faq/programming.rst:73
msgid "How can I create a stand-alone binary from a Python script?"
msgstr "Como posso criar um binário independente a partir de um script Python?"

#: ../../faq/programming.rst:75
msgid ""
"You don't need the ability to compile Python to C code if all you want is a "
"stand-alone program that users can download and run without having to "
"install the Python distribution first.  There are a number of tools that "
"determine the set of modules required by a program and bind these modules "
"together with a Python binary to produce a single executable."
msgstr ""
"Você não precisa possuir a capacidade de compilar o código Python para C se "
"o que deseja é um programa autônomo que os usuários possam baixar e executar "
"sem ter que instalar a distribuição Python primeiro. Existem várias "
"ferramentas que determinam o conjunto de módulos exigidos por um programa e "
"vinculam esses módulos ao binário do Python para produzir um único "
"executável."

#: ../../faq/programming.rst:81
msgid ""
"One is to use the freeze tool, which is included in the Python source tree "
"as `Tools/freeze <https://github.com/python/cpython/tree/main/Tools/"
"freeze>`_. It converts Python byte code to C arrays; with a C compiler you "
"can embed all your modules into a new program, which is then linked with the "
"standard Python modules."
msgstr ""
"Uma delas é usar a ferramenta *freeze*, que está incluída na árvore de "
"código-fonte Python como `Tools/freeze <https://github.com/python/cpython/"
"tree/main/Tools/freeze>`_. Ela converte o *bytecode* de Python em vetores de "
"C. Com um compilador de C, você consegue incorporar todos os seus módulos em "
"um novo programa, que é então vinculado aos módulos-padrão de Python."

#: ../../faq/programming.rst:87
msgid ""
"It works by scanning your source recursively for import statements (in both "
"forms) and looking for the modules in the standard Python path as well as in "
"the source directory (for built-in modules).  It then turns the bytecode for "
"modules written in Python into C code (array initializers that can be turned "
"into code objects using the marshal module) and creates a custom-made config "
"file that only contains those built-in modules which are actually used in "
"the program.  It then compiles the generated C code and links it with the "
"rest of the Python interpreter to form a self-contained binary which acts "
"exactly like your script."
msgstr ""
"A *freeze* trabalha percorrendo seu código recursivamente, procurando por "
"instruções de importação (ambas as formas), e procurando por módulos tanto "
"no caminho padrão do Python, quanto por módulos embutidos no diretório "
"fonte. Ela então transforma o *bytecode* de módulos Python em código C "
"(inicializadores de vetor que podem ser transformados em objetos código "
"usando o módulo `marshal`), e depois cria um arquivo de configurações "
"personalizado que só contém os módulos embutidos usados no programa. A "
"ferramenta então compila os códigos C e os vincula como o resto do "
"interpretador Python, formando um binário autônomo que funciona exatamente "
"como seu *script*."

#: ../../faq/programming.rst:96
msgid ""
"The following packages can help with the creation of console and GUI "
"executables:"
msgstr ""
"Os pacotes a seguir podem ajudar com a criação dos executáveis do console e "
"da GUI:"

#: ../../faq/programming.rst:99
msgid "`Nuitka <https://nuitka.net/>`_ (Cross-platform)"
msgstr "`Nuitka <https://nuitka.net/>`_ (Multiplataforma)"

#: ../../faq/programming.rst:100
msgid "`PyInstaller <https://pyinstaller.org/>`_ (Cross-platform)"
msgstr "`PyInstaller <https://pyinstaller.org/>`_ (Multiplataforma)"

#: ../../faq/programming.rst:101
msgid ""
"`PyOxidizer <https://pyoxidizer.readthedocs.io/en/stable/>`_ (Cross-platform)"
msgstr ""
"`PyOxidizer <https://pyoxidizer.readthedocs.io/en/stable/>`_ "
"(Multiplataforma)"

#: ../../faq/programming.rst:102
msgid ""
"`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ (Cross-platform)"
msgstr ""
"`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ (Multiplataforma)"

#: ../../faq/programming.rst:103
msgid "`py2app <https://github.com/ronaldoussoren/py2app>`_ (macOS only)"
msgstr "`py2app <https://github.com/ronaldoussoren/py2app>`_ (somente macOS)"

#: ../../faq/programming.rst:104
msgid "`py2exe <https://www.py2exe.org/>`_ (Windows only)"
msgstr "`py2exe <https://www.py2exe.org/>`_ (somente Windows)"

#: ../../faq/programming.rst:107
msgid "Are there coding standards or a style guide for Python programs?"
msgstr ""
"Existem padrões para a codificação ou um guia de estilo utilizado pela "
"comunidade Python?"

#: ../../faq/programming.rst:109
msgid ""
"Yes.  The coding style required for standard library modules is documented "
"as :pep:`8`."
msgstr ""
"Sim. O guia de estilo esperado para módulos e biblioteca padrão possui o "
"nome de PEP8 e você pode acessar a sua documentação em :pep:`8`."

#: ../../faq/programming.rst:114
msgid "Core Language"
msgstr "Núcleo da linguagem"

#: ../../faq/programming.rst:119
msgid "Why am I getting an UnboundLocalError when the variable has a value?"
msgstr ""
"Porque recebo o erro UnboundLocalError quando a variável possui um valor "
"associado?"

#: ../../faq/programming.rst:121
msgid ""
"It can be a surprise to get the :exc:`UnboundLocalError` in previously "
"working code when it is modified by adding an assignment statement somewhere "
"in the body of a function."
msgstr ""
"Pode ser uma surpresa obter a exceção :exc:`UnboundLocalError` em um código "
"previamente funcional quando adicionamos uma instrução de atribuição em "
"algum lugar no corpo de uma função."

#: ../../faq/programming.rst:125
msgid "This code:"
msgstr "Este código:"

#: ../../faq/programming.rst:134
msgid "works, but this code:"
msgstr "funciona, mas este código:"

#: ../../faq/programming.rst:141
msgid "results in an :exc:`!UnboundLocalError`:"
msgstr "resulta em uma :exc:`!UnboundLocalError`:"

#: ../../faq/programming.rst:148
msgid ""
"This is because when you make an assignment to a variable in a scope, that "
"variable becomes local to that scope and shadows any similarly named "
"variable in the outer scope.  Since the last statement in foo assigns a new "
"value to ``x``, the compiler recognizes it as a local variable.  "
"Consequently when the earlier ``print(x)`` attempts to print the "
"uninitialized local variable and an error results."
msgstr ""
"Isso acontece porque, quando atribuímos um valor a uma variável em "
"determinado escopo, essa variável torna-se local desse escopo, acabando por "
"esconder qualquer outra variável de mesmo nome no escopo externo. Como a "
"última instrução em foo atribui um novo valor a ``x``, o interpretador a "
"reconhece como uma variável local. Consequentemente, quando o ``print(x)`` "
"anterior tentar exibir a variável local não inicializada, um erro aparece."

#: ../../faq/programming.rst:155
msgid ""
"In the example above you can access the outer scope variable by declaring it "
"global:"
msgstr ""
"No exemplo acima, podemos acessar a variável do escopo externo declarando-a "
"como global:"

#: ../../faq/programming.rst:167
msgid ""
"This explicit declaration is required in order to remind you that (unlike "
"the superficially analogous situation with class and instance variables) you "
"are actually modifying the value of the variable in the outer scope:"
msgstr ""
"Esta declaração explícita é necessária para lembrarmos que estamos "
"modificando o valor da variável no escopo externo (ao contrário da situação "
"superficialmente análoga com variáveis de classe e instância):"

#: ../../faq/programming.rst:174
msgid ""
"You can do a similar thing in a nested scope using the :keyword:`nonlocal` "
"keyword:"
msgstr ""
"Podemos fazer algo parecido num escopo aninhado usando a palavra reservada :"
"keyword:`nonlocal`:"

#: ../../faq/programming.rst:192
msgid "What are the rules for local and global variables in Python?"
msgstr "Quais são as regras para variáveis locais e globais em Python?"

#: ../../faq/programming.rst:194
msgid ""
"In Python, variables that are only referenced inside a function are "
"implicitly global.  If a variable is assigned a value anywhere within the "
"function's body, it's assumed to be a local unless explicitly declared as "
"global."
msgstr ""
"Em Python, as variáveis que são apenas utilizadas (referenciadas) dentro de "
"uma função são implicitamente globais. Se uma variável for associada a um "
"valor em qualquer lugar dentro do corpo da função, presume-se que a mesma "
"seja local, a menos que seja explicitamente declarada como global."

#: ../../faq/programming.rst:198
msgid ""
"Though a bit surprising at first, a moment's consideration explains this.  "
"On one hand, requiring :keyword:`global` for assigned variables provides a "
"bar against unintended side-effects.  On the other hand, if ``global`` was "
"required for all global references, you'd be using ``global`` all the time.  "
"You'd have to declare as global every reference to a built-in function or to "
"a component of an imported module.  This clutter would defeat the usefulness "
"of the ``global`` declaration for identifying side-effects."
msgstr ""
"Embora um pouco surpreendente no início, um momento de consideração explica "
"isso. Por um lado, exigir :keyword:`global` para variáveis atribuídas "
"fornece uma barreira contra efeitos colaterais indesejados. Por outro lado, "
"se ``global`` fosse necessário para todas as referências globais, você "
"estaria usando ``global`` o tempo todo. Você teria que declarar como global "
"todas as referências a uma função embutida ou a um componente de um módulo "
"importado. Essa desordem anularia a utilidade da declaração de ``global`` "
"para identificar efeitos colaterais."

#: ../../faq/programming.rst:208
msgid ""
"Why do lambdas defined in a loop with different values all return the same "
"result?"
msgstr ""
"Por que os lambdas definidos em um laço com valores diferentes retornam o "
"mesmo resultado?"

#: ../../faq/programming.rst:210
msgid ""
"Assume you use a for loop to define a few different lambdas (or even plain "
"functions), e.g.::"
msgstr ""
"Suponha que se utilize um laço `for` para definir algumas funções lambdas "
"(ou mesmo funções simples), por exemplo.::"

#: ../../faq/programming.rst:213
msgid ""
">>> squares = []\n"
">>> for x in range(5):\n"
"...     squares.append(lambda: x**2)"
msgstr ""
">>> squares = []\n"
">>> for x in range(5):\n"
"...     squares.append(lambda: x**2)"

#: ../../faq/programming.rst:217
msgid ""
"This gives you a list that contains 5 lambdas that calculate ``x**2``.  You "
"might expect that, when called, they would return, respectively, ``0``, "
"``1``, ``4``, ``9``, and ``16``.  However, when you actually try you will "
"see that they all return ``16``::"
msgstr ""
"Isso oferece uma lista que contém 5 lambdas que calculam ``x**2``. Você "
"pensar que, quando invocado, os mesmos retornam, respectivamente, ``0``, "
"``1``, ``4``, ``9``, e ``16``. No entanto, quando realmente tentar, vai ver "
"que todos retornam ``16``::"

#: ../../faq/programming.rst:222
msgid ""
">>> squares[2]()\n"
"16\n"
">>> squares[4]()\n"
"16"
msgstr ""
">>> squares[2]()\n"
"16\n"
">>> squares[4]()\n"
"16"

#: ../../faq/programming.rst:227
msgid ""
"This happens because ``x`` is not local to the lambdas, but is defined in "
"the outer scope, and it is accessed when the lambda is called --- not when "
"it is defined.  At the end of the loop, the value of ``x`` is ``4``, so all "
"the functions now return ``4**2``, i.e. ``16``.  You can also verify this by "
"changing the value of ``x`` and see how the results of the lambdas change::"
msgstr ""
"Isso acontece porque ``x`` não é local para os lambdas, mas é definido no "
"escopo externo, e é acessado quando o lambda for chamado --- não quando é "
"definido. No final do laço, o valor de ``x`` será ``4``, e então, todas as "
"funções agora retornarão ``4**2``, ou seja, ``16``. Também é possível "
"verificar isso alterando o valor de ``x`` e vendo como os resultados dos "
"lambdas mudam::"

#: ../../faq/programming.rst:233
msgid ""
">>> x = 8\n"
">>> squares[2]()\n"
"64"
msgstr ""
">>> x = 8\n"
">>> squares[2]()\n"
"64"

#: ../../faq/programming.rst:237
msgid ""
"In order to avoid this, you need to save the values in variables local to "
"the lambdas, so that they don't rely on the value of the global ``x``::"
msgstr ""
"Para evitar isso, é necessário salvar os valores nas variáveis locais para "
"os lambdas, para que eles não dependam do valor de ``x`` global::"

#: ../../faq/programming.rst:240
msgid ""
">>> squares = []\n"
">>> for x in range(5):\n"
"...     squares.append(lambda n=x: n**2)"
msgstr ""
">>> squares = []\n"
">>> for x in range(5):\n"
"...     squares.append(lambda n=x: n**2)"

#: ../../faq/programming.rst:244
msgid ""
"Here, ``n=x`` creates a new variable ``n`` local to the lambda and computed "
"when the lambda is defined so that it has the same value that ``x`` had at "
"that point in the loop.  This means that the value of ``n`` will be ``0`` in "
"the first lambda, ``1`` in the second, ``2`` in the third, and so on. "
"Therefore each lambda will now return the correct result::"
msgstr ""
"Aqui, ``n=x`` cria uma nova variável ``n`` local para o lambda e é calculada "
"quando o lambda é definido para que ele tenha o mesmo valor que ``x`` tem "
"nesse ponto no laço. Isso significa que o valor de ``n`` será ``0`` no "
"primeiro \"ciclo\" do lambda, ``1`` no segundo \"ciclo\", ``2`` no terceiro, "
"e assim por diante. Portanto, cada lambda agora retornará o resultado "
"correto::"

#: ../../faq/programming.rst:250
msgid ""
">>> squares[2]()\n"
"4\n"
">>> squares[4]()\n"
"16"
msgstr ""
">>> squares[2]()\n"
"4\n"
">>> squares[4]()\n"
"16"

#: ../../faq/programming.rst:255
msgid ""
"Note that this behaviour is not peculiar to lambdas, but applies to regular "
"functions too."
msgstr ""
"Observe que esse comportamento não é peculiar dos lambdas, o mesmo também "
"ocorre com as funções regulares."

#: ../../faq/programming.rst:260
msgid "How do I share global variables across modules?"
msgstr "Como definir variáveis globais dentro de módulos?"

#: ../../faq/programming.rst:262
msgid ""
"The canonical way to share information across modules within a single "
"program is to create a special module (often called config or cfg).  Just "
"import the config module in all modules of your application; the module then "
"becomes available as a global name.  Because there is only one instance of "
"each module, any changes made to the module object get reflected "
"everywhere.  For example:"
msgstr ""
"A maneira canônica de compartilhar informações entre módulos dentro de um "
"único programa é criando um módulo especial (geralmente chamado de config ou "
"cfg). Basta importar o módulo de configuração em todos os módulos da sua "
"aplicação; o módulo ficará disponível como um nome global. Como há apenas "
"uma instância de cada módulo, todas as alterações feitas no objeto do módulo "
"se refletem em todos os lugares. Por exemplo:"

#: ../../faq/programming.rst:268
msgid "config.py::"
msgstr "config.py::"

#: ../../faq/programming.rst:270
msgid "x = 0   # Default value of the 'x' configuration setting"
msgstr "x = 0   # Valor padrão para a configuração de 'x'"

#: ../../faq/programming.rst:272
msgid "mod.py::"
msgstr "mod.py::"

#: ../../faq/programming.rst:274
msgid ""
"import config\n"
"config.x = 1"
msgstr ""
"import config\n"
"config.x = 1"

#: ../../faq/programming.rst:277
msgid "main.py::"
msgstr "main.py::"

#: ../../faq/programming.rst:279
msgid ""
"import config\n"
"import mod\n"
"print(config.x)"
msgstr ""
"import config\n"
"import mod\n"
"print(config.x)"

#: ../../faq/programming.rst:283
msgid ""
"Note that using a module is also the basis for implementing the singleton "
"design pattern, for the same reason."
msgstr ""
"Note que usar um módulo também é a base para a implementação do padrão de "
"projeto Singleton, pela mesma razão."

#: ../../faq/programming.rst:288
msgid "What are the \"best practices\" for using import in a module?"
msgstr ""
"Quais são as \"melhores práticas\" quando fazemos uso da importação de "
"módulos?"

#: ../../faq/programming.rst:290
msgid ""
"In general, don't use ``from modulename import *``.  Doing so clutters the "
"importer's namespace, and makes it much harder for linters to detect "
"undefined names."
msgstr ""
"Em geral, não use ``from nomemódulo import *``. Isso desorganiza o espaço de "
"nomes do importador e torna muito mais difícil para as ferramentas de "
"análise estática detectarem nomes indefinidos."

#: ../../faq/programming.rst:294
msgid ""
"Import modules at the top of a file.  Doing so makes it clear what other "
"modules your code requires and avoids questions of whether the module name "
"is in scope. Using one import per line makes it easy to add and delete "
"module imports, but using multiple imports per line uses less screen space."
msgstr ""
"Faça a importação de módulos na parte superior do arquivo. Isso deixa claro "
"quais outros módulos nosso código necessita e evita dúvidas sobre, por "
"exemplo, se o nome do módulo está no escopo. Usar uma importação por linha "
"facilita a adição e exclusão de importações de módulos, porém, usar várias "
"importações num única linha, ocupa menos espaço da tela."

#: ../../faq/programming.rst:299
msgid "It's good practice if you import modules in the following order:"
msgstr "É uma boa prática importar os módulos na seguinte ordem:"

#: ../../faq/programming.rst:301
msgid ""
"standard library modules -- e.g. :mod:`sys`, :mod:`os`, :mod:`argparse`, :"
"mod:`re`"
msgstr ""
"módulos da biblioteca padrão -- por exemplo: :mod:`sys`, :mod:`os`, :mod:"
"`argparse` e :mod:`re`"

#: ../../faq/programming.rst:302
msgid ""
"third-party library modules (anything installed in Python's site-packages "
"directory) -- e.g. :mod:`!dateutil`, :mod:`!requests`, :mod:`!PIL.Image`"
msgstr ""
"módulos de biblioteca de terceiros (qualquer instalação feita contida no "
"repositório de códigos na pasta site-packages) -- por exemplo: :mod:`!"
"dateutil`, :mod:`!requests` e :mod:`!PIL.Image`"

#: ../../faq/programming.rst:304
msgid "locally developed modules"
msgstr "módulos desenvolvidos localmente"

#: ../../faq/programming.rst:306
msgid ""
"It is sometimes necessary to move imports to a function or class to avoid "
"problems with circular imports.  Gordon McMillan says:"
msgstr ""
"Às vezes, é necessário transferir as importações para uma função ou classe "
"para evitar problemas com importação circular. Gordon McMillan diz:"

#: ../../faq/programming.rst:309
msgid ""
"Circular imports are fine where both modules use the \"import <module>\" "
"form of import.  They fail when the 2nd module wants to grab a name out of "
"the first (\"from module import name\") and the import is at the top level.  "
"That's because names in the 1st are not yet available, because the first "
"module is busy importing the 2nd."
msgstr ""
"As importações circulares vão bem onde ambos os módulos utilizam a forma de "
"importação \"import <módulo>\". Elas falham quando o 2º módulo quer pegar um "
"nome do primeiro (\"from módulo import nome\") e a importação está no nível "
"superior. Isso porque os nomes no primeiro ainda não estão disponíveis, "
"porque o 1º módulo está ocupado importando o 2º."

#: ../../faq/programming.rst:315
msgid ""
"In this case, if the second module is only used in one function, then the "
"import can easily be moved into that function.  By the time the import is "
"called, the first module will have finished initializing, and the second "
"module can do its import."
msgstr ""
"Nesse caso, se o segundo módulo for usado apenas numa função, a importação "
"pode ser facilmente movida para dentro do escopo dessa função. No momento em "
"que a importação for chamada, o primeiro módulo terá finalizado a "
"inicialização e o segundo módulo poderá ser importado sem maiores "
"complicações."

#: ../../faq/programming.rst:320
msgid ""
"It may also be necessary to move imports out of the top level of code if "
"some of the modules are platform-specific.  In that case, it may not even be "
"possible to import all of the modules at the top of the file.  In this case, "
"importing the correct modules in the corresponding platform-specific code is "
"a good option."
msgstr ""
"Também poderá ser necessário mover as importações para fora do nível "
"superior do código se alguns dos módulos forem específicos de uma "
"determinada plataforma (SO). Nesse caso, talvez nem seja possível importar "
"todos os módulos na parte superior do arquivo. Nessas situações devemos "
"importar os módulos que são específicos de cada plataforma antes de "
"necessitar utilizar os mesmos."

#: ../../faq/programming.rst:325
msgid ""
"Only move imports into a local scope, such as inside a function definition, "
"if it's necessary to solve a problem such as avoiding a circular import or "
"are trying to reduce the initialization time of a module.  This technique is "
"especially helpful if many of the imports are unnecessary depending on how "
"the program executes.  You may also want to move imports into a function if "
"the modules are only ever used in that function.  Note that loading a module "
"the first time may be expensive because of the one time initialization of "
"the module, but loading a module multiple times is virtually free, costing "
"only a couple of dictionary lookups.  Even if the module name has gone out "
"of scope, the module is probably available in :data:`sys.modules`."
msgstr ""
"Apenas mova as importações para um escopo local, como dentro da definição de "
"função, se for necessário resolver algum tipo de problema, como, por "
"exemplo, evitar importações circulares ou tentar reduzir o tempo de "
"inicialização do módulo. Esta técnica é especialmente útil se muitas das "
"importações forem desnecessárias, dependendo de como o programa é executado. "
"Também podemos desejar mover as importações para uma função se os módulos "
"forem usados somente nessa função. Note que carregar um módulo pela primeira "
"vez pode ser demorado devido ao tempo de inicialização de cada módulo, no "
"entanto, carregar um módulo várias vezes é praticamente imperceptível, tendo "
"somente o custo de processamento de pesquisas no dicionário de nomes. Mesmo "
"que o nome do módulo tenha saído do escopo, o módulo provavelmente estará "
"disponível em :data:`sys.modules`."

#: ../../faq/programming.rst:338
msgid "Why are default values shared between objects?"
msgstr "Por que os valores padrão são compartilhados entre objetos?"

#: ../../faq/programming.rst:340
msgid ""
"This type of bug commonly bites neophyte programmers.  Consider this "
"function::"
msgstr ""
"Este tipo de erro geralmente pega programadores neófitos. Considere esta "
"função::"

#: ../../faq/programming.rst:342
msgid ""
"def foo(mydict={}):  # Danger: shared reference to one dict for all calls\n"
"    ... compute something ...\n"
"    mydict[key] = value\n"
"    return mydict"
msgstr ""
"def foo(meudict={}):  # Perigo: referência compartilhada a um dicionário "
"para todas as chamadas\n"
"    ... faz alguma coisa ...\n"
"    meudict[chave] = valor\n"
"    return meudict"

#: ../../faq/programming.rst:347
msgid ""
"The first time you call this function, ``mydict`` contains a single item.  "
"The second time, ``mydict`` contains two items because when ``foo()`` begins "
"executing, ``mydict`` starts out with an item already in it."
msgstr ""
"Na primeira vez que chamar essa função, ``meudict`` vai conter um único "
"item. Na segunda vez, ``meudict`` vai conter dois itens porque, quando "
"``foo()`` começar a ser executado, ``meudict`` começará com um item já "
"existente."

#: ../../faq/programming.rst:351
msgid ""
"It is often expected that a function call creates new objects for default "
"values. This is not what happens. Default values are created exactly once, "
"when the function is defined.  If that object is changed, like the "
"dictionary in this example, subsequent calls to the function will refer to "
"this changed object."
msgstr ""
"Muitas vezes, espera-se que ao invocar uma função sejam criados novos "
"objetos referente aos valores padrão. Isso não é o que acontece. Os valores "
"padrão são criados exatamente uma vez, quando a função está sendo definida. "
"Se esse objeto for alterado, como o dicionário neste exemplo, as chamadas "
"subsequentes para a essa função se referirão a este objeto alterado."

#: ../../faq/programming.rst:356
msgid ""
"By definition, immutable objects such as numbers, strings, tuples, and "
"``None``, are safe from change. Changes to mutable objects such as "
"dictionaries, lists, and class instances can lead to confusion."
msgstr ""
"Por definição, objetos imutáveis, como números, strings, tuplas e o "
"``None``, estão protegidos de sofrerem alteração. Alterações em objetos "
"mutáveis, como dicionários, listas e instâncias de classe, podem levar à "
"confusão."

#: ../../faq/programming.rst:360
msgid ""
"Because of this feature, it is good programming practice to not use mutable "
"objects as default values.  Instead, use ``None`` as the default value and "
"inside the function, check if the parameter is ``None`` and create a new "
"list/dictionary/whatever if it is.  For example, don't write::"
msgstr ""
"Por causa desse recurso, é uma boa prática de programação para evitar o uso "
"de objetos mutáveis contendo valores padrão. Em vez disso, utilize ``None`` "
"como o valor padrão e dentro da função, verifique se o parâmetro é ``None`` "
"e crie uma nova lista, dicionário ou o que quer que seja. Por exemplo, "
"escreva o seguinte código::"

#: ../../faq/programming.rst:365
msgid ""
"def foo(mydict={}):\n"
"    ..."
msgstr ""
"def foo(meudict={}):\n"
"    ..."

#: ../../faq/programming.rst:368
msgid "but::"
msgstr "mas::"

#: ../../faq/programming.rst:370
msgid ""
"def foo(mydict=None):\n"
"    if mydict is None:\n"
"        mydict = {}  # create a new dict for local namespace"
msgstr ""
"def foo(meudict=None):\n"
"    if meudict is None:\n"
"        meudict = {}  # cria um novo dicionário para o espaço de nomes local"

#: ../../faq/programming.rst:374
msgid ""
"This feature can be useful.  When you have a function that's time-consuming "
"to compute, a common technique is to cache the parameters and the resulting "
"value of each call to the function, and return the cached value if the same "
"value is requested again.  This is called \"memoizing\", and can be "
"implemented like this::"
msgstr ""
"Esse recurso pode ser útil. Quando se tem uma função que consome muito tempo "
"para calcular, uma técnica comum é armazenar em cache os parâmetros e o "
"valor resultante de cada chamada para a função e retornar o valor em cache "
"se o mesmo valor for solicitado novamente. Isso se chama \"memoizar\", e "
"pode ser implementado da seguinte forma::"

#: ../../faq/programming.rst:379
msgid ""
"# Callers can only provide two parameters and optionally pass _cache by "
"keyword\n"
"def expensive(arg1, arg2, *, _cache={}):\n"
"    if (arg1, arg2) in _cache:\n"
"        return _cache[(arg1, arg2)]\n"
"\n"
"    # Calculate the value\n"
"    result = ... expensive computation ...\n"
"    _cache[(arg1, arg2)] = result           # Store result in the cache\n"
"    return result"
msgstr ""
"# Chamadores só podem fornecer dois parâmetros e opcionalmente passar _cache "
"como parâmetro nomeado\n"
"def expensive(arg1, arg2, *, _cache={}):\n"
"    if (arg1, arg2) in _cache:\n"
"        return _cache[(arg1, arg2)]\n"
"\n"
"    # Cacula o valor\n"
"    result = ... cálculo custoso ...\n"
"    _cache[(arg1, arg2)] = result           # Armazena o resultado no cache\n"
"    return result"

#: ../../faq/programming.rst:389
msgid ""
"You could use a global variable containing a dictionary instead of the "
"default value; it's a matter of taste."
msgstr ""
"Pode-se usar uma variável global contendo um dicionário ao invés do valor "
"padrão; isso é uma questão de gosto."

#: ../../faq/programming.rst:394
msgid ""
"How can I pass optional or keyword parameters from one function to another?"
msgstr ""
"Como passo parâmetros opcionais ou parâmetros nomeados de uma função para "
"outra?"

#: ../../faq/programming.rst:396
msgid ""
"Collect the arguments using the ``*`` and ``**`` specifiers in the "
"function's parameter list; this gives you the positional arguments as a "
"tuple and the keyword arguments as a dictionary.  You can then pass these "
"arguments when calling another function by using ``*`` and ``**``::"
msgstr ""
"Colete os argumentos usando os especificadores ``*`` ou ``**`` na lista de "
"parâmetros da função. Isso faz com que os argumentos posicionais como tupla "
"e os argumentos nomeados sejam passados como um dicionário. Você pode, "
"também, passar esses argumentos ao invocar outra função usando ``*`` e "
"``**``::"

#: ../../faq/programming.rst:401
msgid ""
"def f(x, *args, **kwargs):\n"
"    ...\n"
"    kwargs['width'] = '14.3c'\n"
"    ...\n"
"    g(x, *args, **kwargs)"
msgstr ""
"def f(x, *args, **kwargs):\n"
"    ...\n"
"    kwargs['width'] = '14.3c'\n"
"    ...\n"
"    g(x, *args, **kwargs)"

#: ../../faq/programming.rst:415
msgid "What is the difference between arguments and parameters?"
msgstr "Qual a diferença entre argumentos e parâmetros?"

#: ../../faq/programming.rst:417
msgid ""
":term:`Parameters <parameter>` are defined by the names that appear in a "
"function definition, whereas :term:`arguments <argument>` are the values "
"actually passed to a function when calling it.  Parameters define what :term:"
"`kind of arguments <parameter>` a function can accept.  For example, given "
"the function definition::"
msgstr ""
":term:`Parâmetros <parameter>` são definidos pelos nomes que aparecem na "
"definição da função, enquanto :term:`argumentos <argument>` são os valores "
"que serão passados para a função no momento em que esta estiver sendo "
"invocada. Os parâmetros irão definir quais os :term:`tipos de argumentos "
"<parameter>` que uma função pode receber. Por exemplo, dada a definição da "
"função::"

#: ../../faq/programming.rst:423
msgid ""
"def func(foo, bar=None, **kwargs):\n"
"    pass"
msgstr ""
"def func(foo, bar=None, **kwargs):\n"
"    pass"

#: ../../faq/programming.rst:426
msgid ""
"*foo*, *bar* and *kwargs* are parameters of ``func``.  However, when calling "
"``func``, for example::"
msgstr ""
"*foo*, *bar* e *kwargs* são parâmetros de ``func``. Dessa forma, ao invocar "
"``func``, por exemplo::"

#: ../../faq/programming.rst:429
msgid "func(42, bar=314, extra=somevar)"
msgstr "func(42, bar=314, extra=algumvalor)"

#: ../../faq/programming.rst:431
msgid "the values ``42``, ``314``, and ``somevar`` are arguments."
msgstr "os valores ``42``, ``314``, e ``algumvalor`` são os argumentos."

#: ../../faq/programming.rst:435
msgid "Why did changing list 'y' also change list 'x'?"
msgstr "Por que ao alterar a lista 'y' também altera a lista 'x'?"

#: ../../faq/programming.rst:437
msgid "If you wrote code like::"
msgstr "Se você escreveu um código como::"

#: ../../faq/programming.rst:439
msgid ""
">>> x = []\n"
">>> y = x\n"
">>> y.append(10)\n"
">>> y\n"
"[10]\n"
">>> x\n"
"[10]"
msgstr ""
">>> x = []\n"
">>> y = x\n"
">>> y.append(10)\n"
">>> y\n"
"[10]\n"
">>> x\n"
"[10]"

#: ../../faq/programming.rst:447
msgid ""
"you might be wondering why appending an element to ``y`` changed ``x`` too."
msgstr ""
"pode estar se perguntando por que acrescentar um elemento a ``y`` também "
"mudou ``x``."

#: ../../faq/programming.rst:449
msgid "There are two factors that produce this result:"
msgstr "Há dois fatores que produzem esse resultado:"

#: ../../faq/programming.rst:451
msgid ""
"Variables are simply names that refer to objects.  Doing ``y = x`` doesn't "
"create a copy of the list -- it creates a new variable ``y`` that refers to "
"the same object ``x`` refers to.  This means that there is only one object "
"(the list), and both ``x`` and ``y`` refer to it."
msgstr ""
"As variáveis são simplesmente nomes que referem-se a objetos. Usar ``y = x`` "
"não cria uma cópia da lista. Isso cria uma nova variável ``y`` que faz "
"referência ao mesmo objeto ao qual ``x`` está se referindo. Isso significa "
"que existe apenas um objeto (a lista) e que ambos ``x`` e ``y`` fazem "
"referência a ele."

#: ../../faq/programming.rst:455
msgid ""
"Lists are :term:`mutable`, which means that you can change their content."
msgstr ""
"Listas são objetos :term:`mutáveis <mutável>`, o que significa que você pode "
"alterar o seu conteúdo."

#: ../../faq/programming.rst:457
msgid ""
"After the call to :meth:`!append`, the content of the mutable object has "
"changed from ``[]`` to ``[10]``.  Since both the variables refer to the same "
"object, using either name accesses the modified value ``[10]``."
msgstr ""
"Após a chamada para :meth:`!append`, o conteúdo do objeto mutável mudou de "
"``[]`` para ``[10]``. Uma vez que ambas as variáveis referem-se ao mesmo "
"objeto, usar qualquer um dos nomes acessará o valor modificado ``[10]``."

#: ../../faq/programming.rst:461
msgid "If we instead assign an immutable object to ``x``::"
msgstr "Se por acaso, atribuímos um objeto imutável a ``x``::"

#: ../../faq/programming.rst:463
msgid ""
">>> x = 5  # ints are immutable\n"
">>> y = x\n"
">>> x = x + 1  # 5 can't be mutated, we are creating a new object here\n"
">>> x\n"
"6\n"
">>> y\n"
"5"
msgstr ""
">>> x = 5  # ints são imutáveis\n"
">>> y = x\n"
">>> x = x + 1  # 5 não pode ser mutado, estamos criando um novo objeto aqui\n"
">>> x\n"
"6\n"
">>> y\n"
"5"

#: ../../faq/programming.rst:471
msgid ""
"we can see that in this case ``x`` and ``y`` are not equal anymore.  This is "
"because integers are :term:`immutable`, and when we do ``x = x + 1`` we are "
"not mutating the int ``5`` by incrementing its value; instead, we are "
"creating a new object (the int ``6``) and assigning it to ``x`` (that is, "
"changing which object ``x`` refers to).  After this assignment we have two "
"objects (the ints ``6`` and ``5``) and two variables that refer to them "
"(``x`` now refers to ``6`` but ``y`` still refers to ``5``)."
msgstr ""
"podemos ver que nesse caso ``x`` e ``y`` não são mais iguais. Isso ocorre "
"porque os números inteiros são :term:`imutáveis <imutável>`, e quando "
"fazemos ``x = x + 1`` não estamos mudando o int ``5`` e incrementando o seu "
"valor. Em vez disso, estamos criando um novo objeto (o int ``6``) e "
"atribuindo-o a ``x`` (isto é, mudando para o objeto no qual ``x`` se "
"refere). Após esta atribuição, temos dois objetos (os ints ``6`` e ``5``) e "
"duas variáveis que referem-se a elas (``x`` agora se refere a ``6``, mas "
"``y`` ainda refere-se a ``5``)."

#: ../../faq/programming.rst:479
msgid ""
"Some operations (for example ``y.append(10)`` and ``y.sort()``) mutate the "
"object, whereas superficially similar operations (for example ``y = y + "
"[10]`` and :func:`sorted(y) <sorted>`) create a new object.  In general in "
"Python (and in all cases in the standard library) a method that mutates an "
"object will return ``None`` to help avoid getting the two types of "
"operations confused.  So if you mistakenly write ``y.sort()`` thinking it "
"will give you a sorted copy of ``y``, you'll instead end up with ``None``, "
"which will likely cause your program to generate an easily diagnosed error."
msgstr ""
"Algumas operações (por exemplo, ``y.append(10)`` e ``y.sort()``) alteram o "
"objeto, enquanto operações superficialmente semelhantes (por exemplo, ``y = "
"y + [10]`` e :func:`sorted(y) <sorted>`) criam um novo objeto. Em geral, em "
"Python (e em todos os casos na biblioteca padrão) um método que causa "
"mutação em um objeto retornará ``None`` para ajudar a evitar confundir os "
"dois tipos de operações. Portanto, se você escrever por engano ``y.sort()`` "
"pensando que lhe dará uma cópia ordenada de ``y``, você terminará com "
"``None``, o que provavelmente fará com que seu programa gere um erro "
"facilmente diagnosticado."

#: ../../faq/programming.rst:488
msgid ""
"However, there is one class of operations where the same operation sometimes "
"has different behaviors with different types:  the augmented assignment "
"operators.  For example, ``+=`` mutates lists but not tuples or ints "
"(``a_list += [1, 2, 3]`` is equivalent to ``a_list.extend([1, 2, 3])`` and "
"mutates ``a_list``, whereas ``some_tuple += (1, 2, 3)`` and ``some_int += "
"1`` create new objects)."
msgstr ""
"No entanto, há uma classe de operações em que a mesma operação às vezes tem "
"comportamentos diferentes com tipos diferentes: os operadores de atribuição "
"aumentada. Por exemplo, ``+=`` transforma listas, mas não tuplas ou ints "
"(``uma_lista += [1, 2, 3]`` equivale a ``uma_lista.extend([1, 2, 3])`` a "
"transforma ``uma_lista``, sendo que ``alguma_tupla += (1, 2, 3)`` e "
"``algum_int += 1`` cria novos objetos)."

#: ../../faq/programming.rst:495
msgid "In other words:"
msgstr "Em outras palavras:"

#: ../../faq/programming.rst:497
msgid ""
"If we have a mutable object (:class:`list`, :class:`dict`, :class:`set`, "
"etc.), we can use some specific operations to mutate it and all the "
"variables that refer to it will see the change."
msgstr ""
"Se tivermos um objeto mutável (:class:`list`, :class:`dict`, :class:`set`, "
"etc.), podemos usar algumas operações específicas para alterá-lo e todas as "
"variáveis que fazem referência a ele verão também a mudança."

#: ../../faq/programming.rst:500
msgid ""
"If we have an immutable object (:class:`str`, :class:`int`, :class:`tuple`, "
"etc.), all the variables that refer to it will always see the same value, "
"but operations that transform that value into a new value always return a "
"new object."
msgstr ""
"Caso tenhamos um objeto imutável (:class:`str`, :class:`int`, :class:"
"`tuple`, etc.), todas as variáveis que se referem a ele sempre verão o mesmo "
"valor, mas as operações que transformam-se nesses valores sempre retornarão "
"novos objetos."

#: ../../faq/programming.rst:505
msgid ""
"If you want to know if two variables refer to the same object or not, you "
"can use the :keyword:`is` operator, or the built-in function :func:`id`."
msgstr ""
"Caso queira saber se duas variáveis fazem referência ao mesmo objeto ou não, "
"pode-se usar o operador :keyword:`is` ou a função embutida :func:`id`."

#: ../../faq/programming.rst:510
msgid "How do I write a function with output parameters (call by reference)?"
msgstr ""
"Como escrevo uma função com parâmetros de saída (chamada por referência)?"

#: ../../faq/programming.rst:512
msgid ""
"Remember that arguments are passed by assignment in Python.  Since "
"assignment just creates references to objects, there's no alias between an "
"argument name in the caller and callee, and so no call-by-reference per se.  "
"You can achieve the desired effect in a number of ways."
msgstr ""
"Lembre-se de que os argumentos são passados por atribuição em Python. Uma "
"vez que a atribuição apenas cria referências a objetos, não existe apelido "
"entre um nome de argumento no chamador e no chamado e, portanto, não há "
"referência de chamada por si. É possível alcançar o efeito desejado de "
"várias maneiras."

#: ../../faq/programming.rst:517
msgid "By returning a tuple of the results::"
msgstr "Retornando um tupla com os resultados::"

#: ../../faq/programming.rst:519
msgid ""
">>> def func1(a, b):\n"
"...     a = 'new-value'        # a and b are local names\n"
"...     b = b + 1              # assigned to new objects\n"
"...     return a, b            # return new values\n"
"...\n"
">>> x, y = 'old-value', 99\n"
">>> func1(x, y)\n"
"('new-value', 100)"
msgstr ""
">>> def func1(a, b):\n"
"...     a = 'valor-novo'       # a e b são nomes locais\n"
"...     b = b + 1              # atribuídos a novos objetos\n"
"...     return a, b            # retorna novos valores\n"
"...\n"
">>> x, y = 'valor-antigo', 99\n"
">>> func1(x, y)\n"
"('valor-novo', 100)"

#: ../../faq/programming.rst:528
msgid "This is almost always the clearest solution."
msgstr "Esta é quase sempre a solução mais clara."

#: ../../faq/programming.rst:530
msgid ""
"By using global variables.  This isn't thread-safe, and is not recommended."
msgstr ""
"Utilizando variáveis globais. Essa forma não é segura para thread e, "
"portanto, não é recomendada."

#: ../../faq/programming.rst:532
msgid "By passing a mutable (changeable in-place) object::"
msgstr ""
"Pela passagem de um objeto mutável (que possa ser alterado internamente)::"

#: ../../faq/programming.rst:534
msgid ""
">>> def func2(a):\n"
"...     a[0] = 'new-value'     # 'a' references a mutable list\n"
"...     a[1] = a[1] + 1        # changes a shared object\n"
"...\n"
">>> args = ['old-value', 99]\n"
">>> func2(args)\n"
">>> args\n"
"['new-value', 100]"
msgstr ""
">>> def func2(a):\n"
"...     a[0] = 'valor-novo'    # 'a' referencia uma lista mutável\n"
"...     a[1] = a[1] + 1        # altera um objeto compartilhado\n"
"...\n"
">>> args = ['valor-antigo', 99]\n"
">>> func2(args)\n"
">>> args\n"
"['valor-novo', 100]"

#: ../../faq/programming.rst:543
msgid "By passing in a dictionary that gets mutated::"
msgstr "Pela passagem de um dicionário que sofra mutação::"

#: ../../faq/programming.rst:545
msgid ""
">>> def func3(args):\n"
"...     args['a'] = 'new-value'     # args is a mutable dictionary\n"
"...     args['b'] = args['b'] + 1   # change it in-place\n"
"...\n"
">>> args = {'a': 'old-value', 'b': 99}\n"
">>> func3(args)\n"
">>> args\n"
"{'a': 'new-value', 'b': 100}"
msgstr ""
">>> def func3(args):\n"
"...     args['a'] = 'valor-novo'     # args é um dicionário mutável\n"
"...     args['b'] = args['b'] + 1   # alteração local, nele mesmo\n"
"...\n"
">>> args = {'a': 'valor-antigo', 'b': 99}\n"
">>> func3(args)\n"
">>> args\n"
"{'a': 'valor-novo', 'b': 100}"

#: ../../faq/programming.rst:554
msgid "Or bundle up values in a class instance::"
msgstr "Ou agrupando valores numa instância de classe::"

#: ../../faq/programming.rst:556
msgid ""
">>> class Namespace:\n"
"...     def __init__(self, /, **args):\n"
"...         for key, value in args.items():\n"
"...             setattr(self, key, value)\n"
"...\n"
">>> def func4(args):\n"
"...     args.a = 'new-value'        # args is a mutable Namespace\n"
"...     args.b = args.b + 1         # change object in-place\n"
"...\n"
">>> args = Namespace(a='old-value', b=99)\n"
">>> func4(args)\n"
">>> vars(args)\n"
"{'a': 'new-value', 'b': 100}"
msgstr ""
">>> class Namespace:\n"
"...     def __init__(self, /, **args):\n"
"...         for key, value in args.items():\n"
"...             setattr(self, key, value)\n"
"...\n"
">>> def func4(args):\n"
"...     args.a = 'valor-novo'        # args é um Namespace mutável\n"
"...     args.b = args.b + 1         # alteração local do objeto, nele mesmo\n"
"...\n"
">>> args = Namespace(a='valor-antigo', b=99)\n"
">>> func4(args)\n"
">>> vars(args)\n"
"{'a': 'valor-novo', 'b': 100}"

#: ../../faq/programming.rst:571
msgid "There's almost never a good reason to get this complicated."
msgstr "Quase nunca existe uma boa razão para complicar isso."

#: ../../faq/programming.rst:573
msgid "Your best choice is to return a tuple containing the multiple results."
msgstr ""
"A sua melhor escolha será retornar uma tupla contendo os múltiplos "
"resultados."

#: ../../faq/programming.rst:577
msgid "How do you make a higher order function in Python?"
msgstr "Como fazer uma função de ordem superior em Python?"

#: ../../faq/programming.rst:579
msgid ""
"You have two choices: you can use nested scopes or you can use callable "
"objects. For example, suppose you wanted to define ``linear(a,b)`` which "
"returns a function ``f(x)`` that computes the value ``a*x+b``.  Using nested "
"scopes::"
msgstr ""
"Existem duas opções: pode-se usar escopos aninhados ou usar objetos "
"chamáveis. Por exemplo, suponha que queira definir ``linear(a,b)``, o qual "
"retorna uma função ``f(x)`` que calcula o valor ``a*x+b``. Usando escopos "
"aninhados, temos::"

#: ../../faq/programming.rst:583
msgid ""
"def linear(a, b):\n"
"    def result(x):\n"
"        return a * x + b\n"
"    return result"
msgstr ""
"def linear(a, b):\n"
"    def result(x):\n"
"        return a * x + b\n"
"    return result"

#: ../../faq/programming.rst:588
msgid "Or using a callable object::"
msgstr "Ou utilizando um objeto chamável::"

#: ../../faq/programming.rst:590
msgid ""
"class linear:\n"
"\n"
"    def __init__(self, a, b):\n"
"        self.a, self.b = a, b\n"
"\n"
"    def __call__(self, x):\n"
"        return self.a * x + self.b"
msgstr ""
"class linear:\n"
"\n"
"    def __init__(self, a, b):\n"
"        self.a, self.b = a, b\n"
"\n"
"    def __call__(self, x):\n"
"        return self.a * x + self.b"

#: ../../faq/programming.rst:598
msgid "In both cases, ::"
msgstr "Em ambos os casos::"

#: ../../faq/programming.rst:600
msgid "taxes = linear(0.3, 2)"
msgstr "taxas = linear(0.3, 2)"

#: ../../faq/programming.rst:602
msgid "gives a callable object where ``taxes(10e6) == 0.3 * 10e6 + 2``."
msgstr "resulta em um objeto chamável, onde ``taxes(10e6) == 0.3 * 10e6 + 2``."

#: ../../faq/programming.rst:604
msgid ""
"The callable object approach has the disadvantage that it is a bit slower "
"and results in slightly longer code.  However, note that a collection of "
"callables can share their signature via inheritance::"
msgstr ""
"A abordagem do objeto chamável tem a desvantagem de que é um pouco mais "
"lenta e resulta num código ligeiramente mais longo. No entanto, note que uma "
"coleção de chamáveis pode compartilhar sua assinatura via herança::"

#: ../../faq/programming.rst:608
msgid ""
"class exponential(linear):\n"
"    # __init__ inherited\n"
"    def __call__(self, x):\n"
"        return self.a * (x ** self.b)"
msgstr ""
"class exponential(linear):\n"
"    # __init__ herdado\n"
"    def __call__(self, x):\n"
"        return self.a * (x ** self.b)"

#: ../../faq/programming.rst:613
msgid "Object can encapsulate state for several methods::"
msgstr "Objetos podem encapsular o estado para vários métodos::"

#: ../../faq/programming.rst:615
msgid ""
"class counter:\n"
"\n"
"    value = 0\n"
"\n"
"    def set(self, x):\n"
"        self.value = x\n"
"\n"
"    def up(self):\n"
"        self.value = self.value + 1\n"
"\n"
"    def down(self):\n"
"        self.value = self.value - 1\n"
"\n"
"count = counter()\n"
"inc, dec, reset = count.up, count.down, count.set"
msgstr ""
"class counter:\n"
"\n"
"    value = 0\n"
"\n"
"    def set(self, x):\n"
"        self.value = x\n"
"\n"
"    def up(self):\n"
"        self.value = self.value + 1\n"
"\n"
"    def down(self):\n"
"        self.value = self.value - 1\n"
"\n"
"count = counter()\n"
"inc, dec, reset = count.up, count.down, count.set"

#: ../../faq/programming.rst:631
msgid ""
"Here ``inc()``, ``dec()`` and ``reset()`` act like functions which share the "
"same counting variable."
msgstr ""
"Aqui ``inc()``, ``dec()`` e ``reset()`` funcionam como funções que "
"compartilham a mesma variável contadora."

#: ../../faq/programming.rst:636
msgid "How do I copy an object in Python?"
msgstr "Como faço para copiar um objeto no Python?"

#: ../../faq/programming.rst:638
msgid ""
"In general, try :func:`copy.copy` or :func:`copy.deepcopy` for the general "
"case. Not all objects can be copied, but most can."
msgstr ""
"Basicamente, tente utilizar a função :func:`copy.copy` ou a função :func:"
"`copy.deepcopy` para casos gerais. Nem todos os objetos podem ser copiados, "
"mas a maioria poderá."

#: ../../faq/programming.rst:641
msgid ""
"Some objects can be copied more easily.  Dictionaries have a :meth:`~dict."
"copy` method::"
msgstr ""
"Alguns objetos podem ser copiados com mais facilidade. Os dicionários têm um "
"método :meth:`~dict.copy`::"

#: ../../faq/programming.rst:644
msgid "newdict = olddict.copy()"
msgstr "novodict = antigodict.copy()"

#: ../../faq/programming.rst:646
msgid "Sequences can be copied by slicing::"
msgstr "As sequências podem ser copiadas através do uso de fatiamento::"

#: ../../faq/programming.rst:648
msgid "new_l = l[:]"
msgstr "nova_l = l[:]"

#: ../../faq/programming.rst:652
msgid "How can I find the methods or attributes of an object?"
msgstr "Como posso encontrar os métodos ou atributos de um objeto?"

#: ../../faq/programming.rst:654
msgid ""
"For an instance ``x`` of a user-defined class, :func:`dir(x) <dir>` returns "
"an alphabetized list of the names containing the instance attributes and "
"methods and attributes defined by its class."
msgstr ""
"Para uma instância ``x`` de uma classe definida pelo usuário, :func:`dir(x) "
"<dir>` retorna uma lista organizada alfabeticamente dos nomes contidos, os "
"atributos da instância e os métodos e atributos definidos por sua classe."

#: ../../faq/programming.rst:660
msgid "How can my code discover the name of an object?"
msgstr "Como que o meu código pode descobrir o nome de um objeto?"

#: ../../faq/programming.rst:662
msgid ""
"Generally speaking, it can't, because objects don't really have names. "
"Essentially, assignment always binds a name to a value; the same is true of "
"``def`` and ``class`` statements, but in that case the value is a callable. "
"Consider the following code::"
msgstr ""
"De um modo geral, não pode, porque os objetos realmente não têm nomes. "
"Essencialmente, a atribuição sempre liga um nome a um valor; o mesmo é "
"verdade para as instruções ``def`` e ``class``, mas nesse caso o valor é um "
"chamável. Considere o seguinte código::"

#: ../../faq/programming.rst:667
msgid ""
">>> class A:\n"
"...     pass\n"
"...\n"
">>> B = A\n"
">>> a = B()\n"
">>> b = a\n"
">>> print(b)\n"
"<__main__.A object at 0x16D07CC>\n"
">>> print(a)\n"
"<__main__.A object at 0x16D07CC>"
msgstr ""
">>> class A:\n"
"...     pass\n"
"...\n"
">>> B = A\n"
">>> a = B()\n"
">>> b = a\n"
">>> print(b)\n"
"<__main__.A object at 0x16D07CC>\n"
">>> print(a)\n"
"<__main__.A object at 0x16D07CC>"

#: ../../faq/programming.rst:678
msgid ""
"Arguably the class has a name: even though it is bound to two names and "
"invoked through the name ``B`` the created instance is still reported as an "
"instance of class ``A``.  However, it is impossible to say whether the "
"instance's name is ``a`` or ``b``, since both names are bound to the same "
"value."
msgstr ""
"Provavelmente, a classe tem um nome: mesmo que seja vinculada a dois nomes e "
"invocada através do nome ``B``, a instância criada ainda é relatada como uma "
"instância da classe ``A``. No entanto, é impossível dizer se o nome da "
"instância é ``a`` ou ``b``, uma vez que ambos os nomes estão vinculados ao "
"mesmo valor."

#: ../../faq/programming.rst:683
msgid ""
"Generally speaking it should not be necessary for your code to \"know the "
"names\" of particular values. Unless you are deliberately writing "
"introspective programs, this is usually an indication that a change of "
"approach might be beneficial."
msgstr ""
"De um modo geral, não deveria ser necessário que o seu código \"conheça os "
"nomes\" de valores específicos. A menos que se escreva deliberadamente "
"programas introspectivos, isso geralmente é uma indicação de que uma mudança "
"de abordagem pode ser benéfica."

#: ../../faq/programming.rst:688
msgid ""
"In comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer "
"to this question:"
msgstr ""
"Em comp.lang.python, Fredrik Lundh deu uma excelente analogia em resposta a "
"esta pergunta:"

#: ../../faq/programming.rst:691
msgid ""
"The same way as you get the name of that cat you found on your porch: the "
"cat (object) itself cannot tell you its name, and it doesn't really care -- "
"so the only way to find out what it's called is to ask all your neighbours "
"(namespaces) if it's their cat (object)..."
msgstr ""
"Da mesma forma que você pega o nome daquele gato que encontrou na sua "
"varanda: o próprio gato (objeto) não pode lhe dizer o seu nome, e ele "
"realmente não se importa -- então, a única maneira de descobrir como ele se "
"chama é perguntar a todos os seus vizinhos (espaços de nomes) se é o gato "
"deles (objeto)..."

#: ../../faq/programming.rst:696
msgid ""
"....and don't be surprised if you'll find that it's known by many names, or "
"no name at all!"
msgstr ""
"....e não fique surpreso se você descobrir que é conhecido por muitos nomes, "
"ou até mesmo nenhum nome."

#: ../../faq/programming.rst:701
msgid "What's up with the comma operator's precedence?"
msgstr "O que há com a precedência do operador vírgula?"

#: ../../faq/programming.rst:703
msgid "Comma is not an operator in Python.  Consider this session::"
msgstr "A vírgula não é um operador em Python. Considere este código::"

#: ../../faq/programming.rst:705
msgid ""
">>> \"a\" in \"b\", \"a\"\n"
"(False, 'a')"
msgstr ""
">>> \"a\" in \"b\", \"a\"\n"
"(False, 'a')"

#: ../../faq/programming.rst:708
msgid ""
"Since the comma is not an operator, but a separator between expressions the "
"above is evaluated as if you had entered::"
msgstr ""
"Uma vez que a vírgula não seja um operador, mas um separador entre as "
"expressões acima, o código será avaliado como se tivéssemos entrado::"

#: ../../faq/programming.rst:711
msgid "(\"a\" in \"b\"), \"a\""
msgstr "(\"a\" in \"b\"), \"a\""

#: ../../faq/programming.rst:713
msgid "not::"
msgstr "não::"

#: ../../faq/programming.rst:715
msgid "\"a\" in (\"b\", \"a\")"
msgstr "\"a\" in (\"b\", \"a\")"

#: ../../faq/programming.rst:717
msgid ""
"The same is true of the various assignment operators (``=``, ``+=`` etc).  "
"They are not truly operators but syntactic delimiters in assignment "
"statements."
msgstr ""
"O mesmo é verdade para as várias operações de atribuição (``=``, ``+=`` "
"etc). Eles não são operadores de verdade mas delimitadores sintáticos em "
"instruções de atribuição."

#: ../../faq/programming.rst:722
msgid "Is there an equivalent of C's \"?:\" ternary operator?"
msgstr "Existe um equivalente ao operador ternário \"?:\" do C?"

#: ../../faq/programming.rst:724
msgid "Yes, there is. The syntax is as follows::"
msgstr "Sim, existe. A sintaxe é a seguinte::"

#: ../../faq/programming.rst:726
msgid ""
"[on_true] if [expression] else [on_false]\n"
"\n"
"x, y = 50, 25\n"
"small = x if x < y else y"
msgstr ""
"[quando_verdadeiro] if [expressão] else [quando_falso]\n"
"\n"
"x, y = 50, 25\n"
"small = x if x < y else y"

#: ../../faq/programming.rst:731
msgid ""
"Before this syntax was introduced in Python 2.5, a common idiom was to use "
"logical operators::"
msgstr ""
"Antes que essa sintaxe fosse introduzida no Python 2.5, uma expressão comum "
"era usar operadores lógicos::"

#: ../../faq/programming.rst:734
msgid "[expression] and [on_true] or [on_false]"
msgstr "[expressão] and [quando_verdadeiro] or [quando_falso]"

#: ../../faq/programming.rst:736
msgid ""
"However, this idiom is unsafe, as it can give wrong results when *on_true* "
"has a false boolean value.  Therefore, it is always better to use the ``... "
"if ... else ...`` form."
msgstr ""
"No entanto, essa forma não é segura, pois pode dar resultados inesperados "
"quando *quando_verdadeiro* tiver um valor booleano falso. Portanto, é sempre "
"melhor usar a forma ``... if ... else ...``."

#: ../../faq/programming.rst:742
msgid "Is it possible to write obfuscated one-liners in Python?"
msgstr "É possível escrever instruções de uma só linha ofuscadas em Python?"

#: ../../faq/programming.rst:744
msgid ""
"Yes.  Usually this is done by nesting :keyword:`lambda` within :keyword:`!"
"lambda`.  See the following three examples, slightly adapted from Ulf "
"Bartelt::"
msgstr ""
"Sim. Normalmente, isso é feito aninhando :keyword:`lambda` dentro de :"
"keyword:`!lambda`. Veja os três exemplos a seguir, ligeiramente adaptados de "
"Ulf Bartelt::"

#: ../../faq/programming.rst:747
msgid ""
"from functools import reduce\n"
"\n"
"# Primes < 1000\n"
"print(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,\n"
"map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))\n"
"\n"
"# First 10 Fibonacci numbers\n"
"print(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:\n"
"f(x,f), range(10))))\n"
"\n"
"# Mandelbrot set\n"
"print((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+'\\n'+y,map(lambda "
"y,\n"
"Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,\n"
"Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,\n"
"i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y\n"
">=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(\n"
"64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy\n"
"))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))\n"
"#    \\___ ___/  \\___ ___/  |   |   |__ lines on screen\n"
"#        V          V      |   |______ columns on screen\n"
"#        |          |      |__________ maximum of \"iterations\"\n"
"#        |          |_________________ range on y axis\n"
"#        |____________________________ range on x axis"
msgstr ""
"from functools import reduce\n"
"\n"
"# Primos < 1000\n"
"print(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,\n"
"map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))\n"
"\n"
"# Primeiros 10 números de Fibonacci\n"
"print(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:\n"
"f(x,f), range(10))))\n"
"\n"
"# Conjunto de Mandelbrot\n"
"print((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+'\\n'+y,map(lambda "
"y,\n"
"Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,\n"
"Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,\n"
"i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y\n"
">=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(\n"
"64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy\n"
"))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))\n"
"#    \\___ ___/  \\___ ___/  |   |   |__ linhas na tela\n"
"#        V          V      |   |______ colunas na tela\n"
"#        |          |      |__________ máximo de \"interações\"\n"
"#        |          |_________________ faixa no eixo y\n"
"#        |____________________________ faixa no eixo x"

#: ../../faq/programming.rst:771
msgid "Don't try this at home, kids!"
msgstr "Não tente isso em casa, crianças!"

#: ../../faq/programming.rst:777
msgid "What does the slash(/) in the parameter list of a function mean?"
msgstr "O que a barra(/) na lista de parâmetros de uma função significa?"

#: ../../faq/programming.rst:779
msgid ""
"A slash in the argument list of a function denotes that the parameters prior "
"to it are positional-only.  Positional-only parameters are the ones without "
"an externally usable name.  Upon calling a function that accepts positional-"
"only parameters, arguments are mapped to parameters based solely on their "
"position. For example, :func:`divmod` is a function that accepts positional-"
"only parameters. Its documentation looks like this::"
msgstr ""
"Uma barra na lista de argumentos de uma função indica que os parâmetros "
"anteriores a ela são somente-posicionais. Os parâmetros somente-posicionais "
"são aqueles que não têm nome utilizável externamente. Ao chamar uma função "
"que aceita parâmetros somente-posicionais, os argumentos são mapeados para "
"parâmetros com base apenas em sua posição. Por exemplo, :func:`divmod` é uma "
"função que aceita parâmetros somente-posicionais. Sua documentação tem esta "
"forma::"

#: ../../faq/programming.rst:786
msgid ""
">>> help(divmod)\n"
"Help on built-in function divmod in module builtins:\n"
"\n"
"divmod(x, y, /)\n"
"    Return the tuple (x//y, x%y).  Invariant: div*y + mod == x."
msgstr ""
">>> help(divmod)\n"
"Help on built-in function divmod in module builtins:\n"
"\n"
"divmod(x, y, /)\n"
"    Return the tuple (x//y, x%y).  Invariant: div*y + mod == x."

#: ../../faq/programming.rst:792
msgid ""
"The slash at the end of the parameter list means that both parameters are "
"positional-only. Thus, calling :func:`divmod` with keyword arguments would "
"lead to an error::"
msgstr ""
"A barra no final da lista de parâmetros significa que ambos os parâmetros "
"são somente-posicionais. Assim, chamar :func:`divmod` com argumentos "
"nomeados levaria a um erro::"

#: ../../faq/programming.rst:796
msgid ""
">>> divmod(x=3, y=4)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: divmod() takes no keyword arguments"
msgstr ""
">>> divmod(x=3, y=4)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: divmod() takes no keyword arguments"

#: ../../faq/programming.rst:803
msgid "Numbers and strings"
msgstr "Números e strings"

#: ../../faq/programming.rst:806
msgid "How do I specify hexadecimal and octal integers?"
msgstr "Como faço para especificar números inteiros hexadecimais e octais?"

#: ../../faq/programming.rst:808
msgid ""
"To specify an octal digit, precede the octal value with a zero, and then a "
"lower or uppercase \"o\".  For example, to set the variable \"a\" to the "
"octal value \"10\" (8 in decimal), type::"
msgstr ""
"Para especificar um dígito no formato octal, preceda o valor octal com um "
"zero e, em seguida, um \"o\" minúsculo ou maiúsculo. Por exemplo, para "
"definir a variável \"a\" para o valor octal \"10\" (8 em decimal), digite::"

#: ../../faq/programming.rst:812
msgid ""
">>> a = 0o10\n"
">>> a\n"
"8"
msgstr ""
">>> a = 0o10\n"
">>> a\n"
"8"

#: ../../faq/programming.rst:816
msgid ""
"Hexadecimal is just as easy.  Simply precede the hexadecimal number with a "
"zero, and then a lower or uppercase \"x\".  Hexadecimal digits can be "
"specified in lower or uppercase.  For example, in the Python interpreter::"
msgstr ""
"Hexadecimal é bem fácil. Basta preceder o número hexadecimal com um zero e, "
"em seguida, um \"x\" minúsculo ou maiúsculo. Os dígitos hexadecimais podem "
"ser especificados em letras maiúsculas e minúsculas. Por exemplo, no "
"interpretador Python::"

#: ../../faq/programming.rst:820
msgid ""
">>> a = 0xa5\n"
">>> a\n"
"165\n"
">>> b = 0XB2\n"
">>> b\n"
"178"
msgstr ""
">>> a = 0xa5\n"
">>> a\n"
"165\n"
">>> b = 0XB2\n"
">>> b\n"
"178"

#: ../../faq/programming.rst:829
msgid "Why does -22 // 10 return -3?"
msgstr "Por que -22 // 10 retorna -3?"

#: ../../faq/programming.rst:831
msgid ""
"It's primarily driven by the desire that ``i % j`` have the same sign as "
"``j``. If you want that, and also want::"
msgstr ""
"Esta dúvida é primariamente direcionado pelo desejo de que ``i % j`` tenha o "
"mesmo sinal que ``j``. Se quiser isso, e também quiser::"

#: ../../faq/programming.rst:834
msgid "i == (i // j) * j + (i % j)"
msgstr "i == (i // j) * j + (i % j)"

#: ../../faq/programming.rst:836
msgid ""
"then integer division has to return the floor.  C also requires that "
"identity to hold, and then compilers that truncate ``i // j`` need to make "
"``i % j`` have the same sign as ``i``."
msgstr ""
"então a divisão inteira deve retornar o piso. C também requer que essa "
"identidade seja mantida, e então os compiladores que truncarem ``i // j`` "
"precisam fazer com que ``i % j`` tenham o mesmo sinal que ``i``."

#: ../../faq/programming.rst:840
msgid ""
"There are few real use cases for ``i % j`` when ``j`` is negative.  When "
"``j`` is positive, there are many, and in virtually all of them it's more "
"useful for ``i % j`` to be ``>= 0``.  If the clock says 10 now, what did it "
"say 200 hours ago?  ``-190 % 12 == 2`` is useful; ``-190 % 12 == -10`` is a "
"bug waiting to bite."
msgstr ""
"Existem poucos casos de uso reais para ``i % j`` quando ``j`` é negativo. "
"Quando ``j`` é positivo, existem muitos, e em virtualmente todos eles é mais "
"útil para ``i % j`` ser ``>= 0``. Se o relógio marca 10 agora, o que dizia "
"há 200 horas? ``-190 % 12 == 2`` é útil, enquanto ``-190 % 12 == -10`` é um "
"bug esperando para morder."

#: ../../faq/programming.rst:848
msgid "How do I get int literal attribute instead of SyntaxError?"
msgstr "Como obtenho um atributo de um literal int em vez de SyntaxError?"

#: ../../faq/programming.rst:850
msgid ""
"Trying to lookup an ``int`` literal attribute in the normal manner gives a :"
"exc:`SyntaxError` because the period is seen as a decimal point::"
msgstr ""
"Tentar obter um atributo de um literal ``int`` da maneira normal retorna um :"
"exc:`SyntaxError` porque o ponto é visto como um ponto decimal::"

#: ../../faq/programming.rst:853
msgid ""
">>> 1.__class__\n"
"  File \"<stdin>\", line 1\n"
"  1.__class__\n"
"   ^\n"
"SyntaxError: invalid decimal literal"
msgstr ""
">>> 1.__class__\n"
"  File \"<stdin>\", line 1\n"
"  1.__class__\n"
"   ^\n"
"SyntaxError: invalid decimal literal"

#: ../../faq/programming.rst:859
msgid ""
"The solution is to separate the literal from the period with either a space "
"or parentheses."
msgstr "A solução é separar o literal do ponto com um espaço ou parênteses."

#: ../../faq/programming.rst:869
msgid "How do I convert a string to a number?"
msgstr "Como faço para converter uma string em um número?"

#: ../../faq/programming.rst:871
msgid ""
"For integers, use the built-in :func:`int` type constructor, e.g. "
"``int('144') == 144``.  Similarly, :func:`float` converts to a floating-"
"point number, e.g. ``float('144') == 144.0``."
msgstr ""
"Para inteiros, use o construtor do tipo embutido :func:`int`, por exemplo, "
"``int('144') == 144``. Da mesma forma, :func:`float` converterá para um "
"número de ponto flutuante, por exemplo ``float('144') == 144.0``."

#: ../../faq/programming.rst:875
msgid ""
"By default, these interpret the number as decimal, so that ``int('0144') == "
"144`` holds true, and ``int('0x144')`` raises :exc:`ValueError`. "
"``int(string, base)`` takes the base to convert from as a second optional "
"argument, so ``int( '0x144', 16) == 324``.  If the base is specified as 0, "
"the number is interpreted using Python's rules: a leading '0o' indicates "
"octal, and '0x' indicates a hex number."
msgstr ""
"Por padrão, eles interpretam o número como decimal, de modo que "
"``int('0144') == 144`` é verdadeiro e ``int('0x144')`` levanta :exc:"
"`ValueError`. ``int(string, base)`` toma a base para converter como um "
"segundo argumento opcional, então ``int( '0x144', 16) == 324``. Se a base "
"for especificada como 0, o número é interpretado usando as regras do Python: "
"um \"0o\" à esquerda indica octal e \"0x\" indica um número hexadecimal."

#: ../../faq/programming.rst:882
msgid ""
"Do not use the built-in function :func:`eval` if all you need is to convert "
"strings to numbers.  :func:`eval` will be significantly slower and it "
"presents a security risk: someone could pass you a Python expression that "
"might have unwanted side effects.  For example, someone could pass "
"``__import__('os').system(\"rm -rf $HOME\")`` which would erase your home "
"directory."
msgstr ""
"Não use a função embutida :func:`eval` se tudo que você precisa é converter "
"strings em números. :func:`eval` será significativamente mais lento e "
"apresenta um risco de segurança: alguém pode passar a você uma expressão "
"Python que pode ter efeitos colaterais indesejados. Por exemplo, alguém "
"poderia passar ``__import__('os').system(\"rm -rf $HOME\")`` que apagaria "
"seu diretório pessoal."

#: ../../faq/programming.rst:889
msgid ""
":func:`eval` also has the effect of interpreting numbers as Python "
"expressions, so that e.g. ``eval('09')`` gives a syntax error because Python "
"does not allow leading '0' in a decimal number (except '0')."
msgstr ""
":func:`eval` também tem o efeito de interpretar números como expressões "
"Python, de forma que, por exemplo, ``eval('09')`` resulta em um erro de "
"sintaxe porque Python não permite '0' inicial em um número decimal (exceto "
"'0')."

#: ../../faq/programming.rst:895
msgid "How do I convert a number to a string?"
msgstr "Como faço para converter um número em uma string?"

#: ../../faq/programming.rst:897
msgid ""
"To convert, e.g., the number ``144`` to the string ``'144'``, use the built-"
"in type constructor :func:`str`.  If you want a hexadecimal or octal "
"representation, use the built-in functions :func:`hex` or :func:`oct`.  For "
"fancy formatting, see the :ref:`f-strings` and :ref:`formatstrings` "
"sections, e.g. ``\"{:04d}\".format(144)`` yields ``'0144'`` and ``\"{:.3f}\"."
"format(1.0/3.0)`` yields ``'0.333'``."
msgstr ""
"Para converter, por exemplo, o número ``144`` para a string ``'144'``, use o "
"construtor do tipo embutido :func:`str`. Caso queira uma representação "
"hexadecimal ou octal, use as funções embutidas :func:`hex` ou :func:`oct`. "
"Para a formatação sofisticada, veja as seções :ref:`f-strings` e :ref:"
"`formatstrings`, por exemplo, ``\"{:04d}\".format(144)`` produz ``'0144'`` e "
"``\"{:.3f}\".format(1.0/3.0)`` produz ``'0.333'``."

#: ../../faq/programming.rst:906
msgid "How do I modify a string in place?"
msgstr "Como faço para modificar uma string internamente?"

#: ../../faq/programming.rst:908
msgid ""
"You can't, because strings are immutable.  In most situations, you should "
"simply construct a new string from the various parts you want to assemble it "
"from.  However, if you need an object with the ability to modify in-place "
"unicode data, try using an :class:`io.StringIO` object or the :mod:`array` "
"module::"
msgstr ""
"Você não pode fazer isso porque as strings são objetos imutáveis. Na maioria "
"das situações, você simplesmente deve construir uma nova string a partir das "
"várias partes das quais deseja montá-la. No entanto, caso precise de um "
"objeto com a capacidade de modificar dados Unicode internamente, tente usar "
"a classe :class:`io.StringIO` ou o módulo :mod:`array`::"

#: ../../faq/programming.rst:914
msgid ""
">>> import io\n"
">>> s = \"Hello, world\"\n"
">>> sio = io.StringIO(s)\n"
">>> sio.getvalue()\n"
"'Hello, world'\n"
">>> sio.seek(7)\n"
"7\n"
">>> sio.write(\"there!\")\n"
"6\n"
">>> sio.getvalue()\n"
"'Hello, there!'\n"
"\n"
">>> import array\n"
">>> a = array.array('w', s)\n"
">>> print(a)\n"
"array('w', 'Hello, world')\n"
">>> a[0] = 'y'\n"
">>> print(a)\n"
"array('w', 'yello, world')\n"
">>> a.tounicode()\n"
"'yello, world'"
msgstr ""
">>> import io\n"
">>> s = \"Hello, world\"\n"
">>> sio = io.StringIO(s)\n"
">>> sio.getvalue()\n"
"'Hello, world'\n"
">>> sio.seek(7)\n"
"7\n"
">>> sio.write(\"there!\")\n"
"6\n"
">>> sio.getvalue()\n"
"'Hello, there!'\n"
"\n"
">>> import array\n"
">>> a = array.array('w', s)\n"
">>> print(a)\n"
"array('w', 'Hello, world')\n"
">>> a[0] = 'y'\n"
">>> print(a)\n"
"array('w', 'yello, world')\n"
">>> a.tounicode()\n"
"'yello, world'"

#: ../../faq/programming.rst:938
msgid "How do I use strings to call functions/methods?"
msgstr "Como faço para invocar funções/métodos através de strings?"

#: ../../faq/programming.rst:940
msgid "There are various techniques."
msgstr "Existem várias técnicas."

#: ../../faq/programming.rst:942
msgid ""
"The best is to use a dictionary that maps strings to functions.  The primary "
"advantage of this technique is that the strings do not need to match the "
"names of the functions.  This is also the primary technique used to emulate "
"a case construct::"
msgstr ""
"A melhor forma é usar um dicionário que mapeie strings para funções. A "
"principal vantagem desta técnica é que estas strings não precisam "
"corresponder aos nomes das funções. Esta é também a principal técnica "
"utilizada para emular uma construção de instrução estilo *case*::"

#: ../../faq/programming.rst:947
msgid ""
"def a():\n"
"    pass\n"
"\n"
"def b():\n"
"    pass\n"
"\n"
"dispatch = {'go': a, 'stop': b}  # Note lack of parens for funcs\n"
"\n"
"dispatch[get_input()]()  # Note trailing parens to call function"
msgstr ""
"def a():\n"
"    pass\n"
"\n"
"def b():\n"
"    pass\n"
"\n"
"dispatch = {'go': a, 'stop': b}  # Note a falta de parênteses para funções\n"
"\n"
"dispatch[get_input()]()  # Note os parênteses ao final para chamar a função"

#: ../../faq/programming.rst:957
msgid "Use the built-in function :func:`getattr`::"
msgstr "Usar a função embutida :func:`getattr`::"

#: ../../faq/programming.rst:959
msgid ""
"import foo\n"
"getattr(foo, 'bar')()"
msgstr ""
"import foo\n"
"getattr(foo, 'bar')()"

#: ../../faq/programming.rst:962
msgid ""
"Note that :func:`getattr` works on any object, including classes, class "
"instances, modules, and so on."
msgstr ""
"Observe que a função :func:`getattr` funciona com qualquer objeto, incluindo "
"classes, instâncias de classe, módulos e assim por diante."

#: ../../faq/programming.rst:965
msgid "This is used in several places in the standard library, like this::"
msgstr "A mesma é usado em vários lugares na biblioteca padrão, como este::"

#: ../../faq/programming.rst:967
msgid ""
"class Foo:\n"
"    def do_foo(self):\n"
"        ...\n"
"\n"
"    def do_bar(self):\n"
"        ...\n"
"\n"
"f = getattr(foo_instance, 'do_' + opname)\n"
"f()"
msgstr ""
"class Foo:\n"
"    def faz_foo(self):\n"
"        ...\n"
"\n"
"    def faz_bar(self):\n"
"        ...\n"
"\n"
"f = getattr(instancia_foo, 'faz_' + opname)\n"
"f()"

#: ../../faq/programming.rst:978
msgid "Use :func:`locals` to resolve the function name::"
msgstr "Use :func:`locals` para determinar o nome da função::"

#: ../../faq/programming.rst:980
msgid ""
"def myFunc():\n"
"    print(\"hello\")\n"
"\n"
"fname = \"myFunc\"\n"
"\n"
"f = locals()[fname]\n"
"f()"
msgstr ""
"def minhaFunc():\n"
"    print(\"hello\")\n"
"\n"
"fname = \"minhaFunc\"\n"
"\n"
"f = locals()[fname]\n"
"f()"

#: ../../faq/programming.rst:990
msgid ""
"Is there an equivalent to Perl's ``chomp()`` for removing trailing newlines "
"from strings?"
msgstr ""
"Existe um equivalente em Perl ``chomp()`` para remover linhas novas ao final "
"de strings?"

#: ../../faq/programming.rst:992
msgid ""
"You can use ``S.rstrip(\"\\r\\n\")`` to remove all occurrences of any line "
"terminator from the end of the string ``S`` without removing other trailing "
"whitespace.  If the string ``S`` represents more than one line, with several "
"empty lines at the end, the line terminators for all the blank lines will be "
"removed::"
msgstr ""
"Pode-se utilizar ``S.rstrip(\"\\r\\n\")`` para remover todas as ocorrência "
"de qualquer terminador de linha que esteja no final da string ``S`` sem "
"remover os espaços em branco. Se a string ``S`` representar mais de uma "
"linha, contendo várias linhas vazias no final, os terminadores de linha de "
"todas linhas em branco serão removidos::"

#: ../../faq/programming.rst:998
msgid ""
">>> lines = (\"line 1 \\r\\n\"\n"
"...          \"\\r\\n\"\n"
"...          \"\\r\\n\")\n"
">>> lines.rstrip(\"\\n\\r\")\n"
"'line 1 '"
msgstr ""
">>> linhas = (\"linha 1 \\r\\n\"\n"
"...          \"\\r\\n\"\n"
"...          \"\\r\\n\")\n"
">>> linhas.rstrip(\"\\n\\r\")\n"
"'linha 1 '"

#: ../../faq/programming.rst:1004
msgid ""
"Since this is typically only desired when reading text one line at a time, "
"using ``S.rstrip()`` this way works well."
msgstr ""
"Geralmente isso só é desejado ao ler um texto linha por linha, usando ``S."
"rstrip()`` dessa maneira funciona bem."

#: ../../faq/programming.rst:1009
msgid "Is there a ``scanf()`` or ``sscanf()`` equivalent?"
msgstr "Existe uma função ``scanf()`` ou ``sscanf()`` ou algo equivalente?"

#: ../../faq/programming.rst:1011
msgid "Not as such."
msgstr "Não como tal."

#: ../../faq/programming.rst:1013
msgid ""
"For simple input parsing, the easiest approach is usually to split the line "
"into whitespace-delimited words using the :meth:`~str.split` method of "
"string objects and then convert decimal strings to numeric values using :"
"func:`int` or :func:`float`.  :meth:`!split` supports an optional \"sep\" "
"parameter which is useful if the line uses something other than whitespace "
"as a separator."
msgstr ""
"Para a análise de entrada simples, a abordagem mais fácil geralmente é "
"dividir a linha em palavras delimitadas por espaços em branco usando o "
"método :meth:`~str.split` de objetos strings e, em seguida, converter as "
"strings decimais para valores numéricos usando a função :func:`int` ou a "
"função :func:`float`. O método :meth:`!split` aceita um parâmetro \"sep\" "
"opcional que é útil se a linha utilizar algo diferente de espaço em branco "
"como separador."

#: ../../faq/programming.rst:1019
msgid ""
"For more complicated input parsing, regular expressions are more powerful "
"than C's ``sscanf`` and better suited for the task."
msgstr ""
"Para análise de entradas de textos mais complicadas, as expressões regulares "
"são mais poderosas do que a ``sscanf`` do C e mais adequadas para essa "
"tarefa."

#: ../../faq/programming.rst:1024
msgid "What does ``UnicodeDecodeError`` or ``UnicodeEncodeError`` error mean?"
msgstr ""
"O que significa o erro ``UnicodeDecodeError`` ou ``UnicodeEncodeError``?"

#: ../../faq/programming.rst:1026
msgid "See the :ref:`unicode-howto`."
msgstr "Consulte :ref:`unicode-howto`."

#: ../../faq/programming.rst:1032
msgid "Can I end a raw string with an odd number of backslashes?"
msgstr "Posso terminar uma string bruta com um número ímpar de contrabarras?"

#: ../../faq/programming.rst:1034
msgid ""
"A raw string ending with an odd number of backslashes will escape the "
"string's quote::"
msgstr ""
"Uma string bruta terminando com um número ímpar de contrabarras vai escapar "
"as aspas da string::"

#: ../../faq/programming.rst:1036
msgid ""
">>> r'C:\\this\\will\\not\\work\\'\n"
"  File \"<stdin>\", line 1\n"
"    r'C:\\this\\will\\not\\work\\'\n"
"    ^\n"
"SyntaxError: unterminated string literal (detected at line 1)"
msgstr ""
">>> r'C:\\isso\\não\\vai\\funcionar\\'\n"
"  File \"<stdin>\", line 1\n"
"    r'C:\\isso\\não\\vai\\funcionar\\'\n"
"    ^\n"
"SyntaxError: unterminated string literal (detected at line 1)"

#: ../../faq/programming.rst:1042
msgid ""
"There are several workarounds for this. One is to use regular strings and "
"double the backslashes::"
msgstr ""
"Há várias soluções alternativas para isso. Uma delas é usar strings "
"regulares e duplicar as contrabarras::"

#: ../../faq/programming.rst:1045
msgid ""
">>> 'C:\\\\this\\\\will\\\\work\\\\'\n"
"'C:\\\\this\\\\will\\\\work\\\\'"
msgstr ""
">>> 'C:\\\\isso\\\\vai\\\\funcionar\\\\'\n"
"'C:\\\\isso\\\\vai\\\\funcionar\\\\'"

#: ../../faq/programming.rst:1048
msgid ""
"Another is to concatenate a regular string containing an escaped backslash "
"to the raw string::"
msgstr ""
"Outra é concatenar uma string regular contendo uma contrabarra de escape à "
"string bruta::"

#: ../../faq/programming.rst:1051
msgid ""
">>> r'C:\\this\\will\\work' '\\\\'\n"
"'C:\\\\this\\\\will\\\\work\\\\'"
msgstr ""
">>> r'C:\\isso\\vai\\funcionar' '\\\\'\n"
"'C:\\\\isso\\\\vai\\\\funcionar\\\\'"

#: ../../faq/programming.rst:1054
msgid ""
"It is also possible to use :func:`os.path.join` to append a backslash on "
"Windows::"
msgstr ""
"Também é possível usar :func:`os.path.join` para acrescentar uma contrabarra "
"no Windows::"

#: ../../faq/programming.rst:1056
msgid ""
">>> os.path.join(r'C:\\this\\will\\work', '')\n"
"'C:\\\\this\\\\will\\\\work\\\\'"
msgstr ""
">>> os.path.join(r'C:\\isso\\vai\\funcionar', '')\n"
"'C:\\\\isso\\\\vai\\\\funcionar\\\\'"

#: ../../faq/programming.rst:1059
msgid ""
"Note that while a backslash will \"escape\" a quote for the purposes of "
"determining where the raw string ends, no escaping occurs when interpreting "
"the value of the raw string. That is, the backslash remains present in the "
"value of the raw string::"
msgstr ""
"Note que, embora uma contrabarra vai \"escapar\" uma aspa para fins de "
"determinar onde a string bruta termina, nenhum escape ocorre ao interpretar "
"o valor da string bruta. Ou seja, a contrabarra permanece presente no valor "
"da string bruta::"

#: ../../faq/programming.rst:1064
msgid ""
">>> r'backslash\\'preserved'\n"
"\"backslash\\\\'preserved\""
msgstr ""
">>> r'contrabarra\\'preservada'\n"
"\"contrabarra\\\\'preservada\""

#: ../../faq/programming.rst:1067
msgid "Also see the specification in the :ref:`language reference <strings>`."
msgstr ""
"Veja também a especificação na :ref:`referência da linguagem <strings>`."

#: ../../faq/programming.rst:1070
msgid "Performance"
msgstr "Desempenho"

#: ../../faq/programming.rst:1073
msgid "My program is too slow. How do I speed it up?"
msgstr "Meu programa está muito lento. Como faço para melhorar o desempenho?"

#: ../../faq/programming.rst:1075
msgid ""
"That's a tough one, in general.  First, here are a list of things to "
"remember before diving further:"
msgstr ""
"Isso geralmente é algo difícil de conseguir. Primeiro, aqui está uma lista "
"de situações que devemos lembrar para melhorar o desempenho da nossa "
"aplicação antes de buscarmos outras soluções:"

#: ../../faq/programming.rst:1078
msgid ""
"Performance characteristics vary across Python implementations.  This FAQ "
"focuses on :term:`CPython`."
msgstr ""
"As características da desempenho podem variar conforme a implementação do "
"Python. Esse FAQ se concentra no :term:`CPython`."

#: ../../faq/programming.rst:1080
msgid ""
"Behaviour can vary across operating systems, especially when talking about I/"
"O or multi-threading."
msgstr ""
"O comportamento pode variar em cada sistemas operacionais, especialmente "
"quando estivermos tratando de E/S ou multi-threading."

#: ../../faq/programming.rst:1082
msgid ""
"You should always find the hot spots in your program *before* attempting to "
"optimize any code (see the :mod:`profile` module)."
msgstr ""
"Sempre devemos encontrar os hot spots em nosso programa *antes de* tentar "
"otimizar qualquer código (veja o módulo :mod:`profile`)."

#: ../../faq/programming.rst:1084
msgid ""
"Writing benchmark scripts will allow you to iterate quickly when searching "
"for improvements (see the :mod:`timeit` module)."
msgstr ""
"Escrever scripts de benchmark permitirá iterar rapidamente buscando "
"melhorias (veja o módulo :mod:`timeit`)."

#: ../../faq/programming.rst:1086
msgid ""
"It is highly recommended to have good code coverage (through unit testing or "
"any other technique) before potentially introducing regressions hidden in "
"sophisticated optimizations."
msgstr ""
"É altamente recomendável ter boa cobertura de código (através de testes de "
"unidade ou qualquer outra técnica) antes de potencialmente apresentar "
"regressões escondidas em otimizações sofisticadas."

#: ../../faq/programming.rst:1090
msgid ""
"That being said, there are many tricks to speed up Python code.  Here are "
"some general principles which go a long way towards reaching acceptable "
"performance levels:"
msgstr ""
"Dito isto, existem muitos truques para acelerar nossos códigos Python. Aqui "
"estão alguns dos principais tópicos e que geralmente ajudam a atingir níveis "
"de desempenho aceitáveis:"

#: ../../faq/programming.rst:1094
msgid ""
"Making your algorithms faster (or changing to faster ones) can yield much "
"larger benefits than trying to sprinkle micro-optimization tricks all over "
"your code."
msgstr ""
"Fazer seus algoritmos rápidos (ou mudando para mais rápidos) podem produzir "
"benefícios maiores que tentar encaixar várias micro-otimizações no seu "
"código."

#: ../../faq/programming.rst:1098
msgid ""
"Use the right data structures.  Study documentation for the :ref:`bltin-"
"types` and the :mod:`collections` module."
msgstr ""
"Usar as estruturas de dados corretas. Estude a documentação para :ref:`bltin-"
"types` e o módulo :mod:`collections`."

#: ../../faq/programming.rst:1101
msgid ""
"When the standard library provides a primitive for doing something, it is "
"likely (although not guaranteed) to be faster than any alternative you may "
"come up with.  This is doubly true for primitives written in C, such as "
"builtins and some extension types.  For example, be sure to use either the :"
"meth:`list.sort` built-in method or the related :func:`sorted` function to "
"do sorting (and see the :ref:`sortinghowto` for examples of moderately "
"advanced usage)."
msgstr ""
"Quando a biblioteca padrão fornecer um tipo primitivo para fazer algo, é "
"provável (embora não garantido) que isso seja mais rápido do que qualquer "
"alternativa que possa surgir. Isso geralmente é verdade para os tipos "
"primitivos escritos em C, como os embutidos e alguns tipos de extensão. Por "
"exemplo, certifique-se de usar o método embutido :meth:`list.sort` ou a "
"função relacionada :func:`sorted` para fazer a ordenação (e veja :ref:"
"`sortinghowto` para exemplos de uso moderadamente avançado)."

#: ../../faq/programming.rst:1109
msgid ""
"Abstractions tend to create indirections and force the interpreter to work "
"more.  If the levels of indirection outweigh the amount of useful work done, "
"your program will be slower.  You should avoid excessive abstraction, "
"especially under the form of tiny functions or methods (which are also often "
"detrimental to readability)."
msgstr ""
"As abstrações tendem a criar indireções e forçar o interpretador a trabalhar "
"mais. Se os níveis de indireção superarem a quantidade de trabalho útil "
"feito, seu programa ficará mais lento. Você deve evitar a abstração "
"excessiva, especialmente sob a forma de pequenas funções ou métodos (que "
"também são muitas vezes prejudiciais à legibilidade)."

#: ../../faq/programming.rst:1115
msgid ""
"If you have reached the limit of what pure Python can allow, there are tools "
"to take you further away.  For example, `Cython <https://cython.org>`_ can "
"compile a slightly modified version of Python code into a C extension, and "
"can be used on many different platforms.  Cython can take advantage of "
"compilation (and optional type annotations) to make your code significantly "
"faster than when interpreted.  If you are confident in your C programming "
"skills, you can also :ref:`write a C extension module <extending-index>` "
"yourself."
msgstr ""
"Se você atingiu o limite do que Python puro pode permitir, existem "
"ferramentas para levá-lo mais longe. Por exemplo, o `Cython <https://cython."
"org>`_ pode compilar uma versão ligeiramente modificada do código Python "
"numa extensão C e pode ser usado em muitas plataformas diferentes. O Cython "
"pode tirar proveito da compilação (e anotações tipo opcional) para tornar o "
"seu código significativamente mais rápido do que quando interpretado. Se "
"você está confiante em suas habilidades de programação C, também pode :ref:"
"`escrever um módulo de extensão de C <extending-index>`."

#: ../../faq/programming.rst:1125
msgid ""
"The wiki page devoted to `performance tips <https://wiki.python.org/moin/"
"PythonSpeed/PerformanceTips>`_."
msgstr ""
"A página wiki dedicada a `dicas de desempenho <https://wiki.python.org/moin/"
"PythonSpeed/PerformanceTips>`_."

#: ../../faq/programming.rst:1131
msgid "What is the most efficient way to concatenate many strings together?"
msgstr "Qual é a maneira mais eficiente de concatenar muitas strings?"

#: ../../faq/programming.rst:1133
msgid ""
":class:`str` and :class:`bytes` objects are immutable, therefore "
"concatenating many strings together is inefficient as each concatenation "
"creates a new object.  In the general case, the total runtime cost is "
"quadratic in the total string length."
msgstr ""
"Objetos das classes :class:`str` e :class:`bytes` são imutáveis e, portanto, "
"concatenar muitas strings é ineficiente, pois cada concatenação criará um "
"novo objeto. No caso geral, o custo total do tempo de execução é quadrático "
"no comprimento total da string."

#: ../../faq/programming.rst:1138
msgid ""
"To accumulate many :class:`str` objects, the recommended idiom is to place "
"them into a list and call :meth:`str.join` at the end::"
msgstr ""
"Para juntar vários objetos :class:`str`, a linguagem recomendada colocá-los "
"numa lista e invocar o método :meth:`str.join`::"

#: ../../faq/programming.rst:1141
msgid ""
"chunks = []\n"
"for s in my_strings:\n"
"    chunks.append(s)\n"
"result = ''.join(chunks)"
msgstr ""
"chunks = []\n"
"for s in my_strings:\n"
"    chunks.append(s)\n"
"result = ''.join(chunks)"

#: ../../faq/programming.rst:1146
msgid "(another reasonably efficient idiom is to use :class:`io.StringIO`)"
msgstr ""
"(outra forma razoavelmente eficiente é usar a classe :class:`io.StringIO`)"

#: ../../faq/programming.rst:1148
msgid ""
"To accumulate many :class:`bytes` objects, the recommended idiom is to "
"extend a :class:`bytearray` object using in-place concatenation (the ``+=`` "
"operator)::"
msgstr ""
"Para juntar vários objetos :class:`bytes`, a forma recomendada é estender "
"uma classe :class:`bytearray` usando a concatenação local (com o operador "
"``+=``)::"

#: ../../faq/programming.rst:1151
msgid ""
"result = bytearray()\n"
"for b in my_bytes_objects:\n"
"    result += b"
msgstr ""
"result = bytearray()\n"
"for b in my_bytes_objects:\n"
"    result += b"

#: ../../faq/programming.rst:1157
msgid "Sequences (Tuples/Lists)"
msgstr "Sequencias (Tuplas/Listas)"

#: ../../faq/programming.rst:1160
msgid "How do I convert between tuples and lists?"
msgstr "Como faço para converter tuplas em listas?"

#: ../../faq/programming.rst:1162
msgid ""
"The type constructor ``tuple(seq)`` converts any sequence (actually, any "
"iterable) into a tuple with the same items in the same order."
msgstr ""
"O construtor de tipo ``tuple(seq)`` converte qualquer sequência (na verdade, "
"qualquer iterável) numa tupla com os mesmos itens na mesma ordem."

#: ../../faq/programming.rst:1165
msgid ""
"For example, ``tuple([1, 2, 3])`` yields ``(1, 2, 3)`` and ``tuple('abc')`` "
"yields ``('a', 'b', 'c')``.  If the argument is a tuple, it does not make a "
"copy but returns the same object, so it is cheap to call :func:`tuple` when "
"you aren't sure that an object is already a tuple."
msgstr ""
"Por exemplo, ``tuple([1, 2, 3])`` produz ``(1, 2, 3)`` e ``tuple('abc')`` "
"produz ``('a', 'b', 'c')``. Se o argumento for uma tupla, a mesma não faz "
"uma cópia, mas retorna o mesmo objeto, por isso é barato invocar a função :"
"func:`tuple` quando você não tiver certeza que determinado objeto já é uma "
"tupla."

#: ../../faq/programming.rst:1170
msgid ""
"The type constructor ``list(seq)`` converts any sequence or iterable into a "
"list with the same items in the same order.  For example, ``list((1, 2, "
"3))`` yields ``[1, 2, 3]`` and ``list('abc')`` yields ``['a', 'b', 'c']``.  "
"If the argument is a list, it makes a copy just like ``seq[:]`` would."
msgstr ""
"O construtor de tipos ``list(seq)`` converte qualquer sequência ou iterável "
"em uma lista com os mesmos itens na mesma ordem. Por exemplo, ``list((1, 2, "
"3))`` produz ``[1, 2, 3]`` e ``list('abc')`` produz ``['a', 'b', 'c']``. Se "
"o argumento for uma lista, o meso fará uma cópia como em ``seq[:]``."

#: ../../faq/programming.rst:1177
msgid "What's a negative index?"
msgstr "O que é um índice negativo?"

#: ../../faq/programming.rst:1179
msgid ""
"Python sequences are indexed with positive numbers and negative numbers.  "
"For positive numbers 0 is the first index 1 is the second index and so "
"forth.  For negative indices -1 is the last index and -2 is the penultimate "
"(next to last) index and so forth.  Think of ``seq[-n]`` as the same as "
"``seq[len(seq)-n]``."
msgstr ""
"Sequências em Python são indexadas com números positivos e números "
"negativos. Para números positivos, 0 é o índice do primeiro elemento, 1 é o "
"índice do segundo elemento e assim por diante. Para números negativos, -1 é "
"índice do último elemento e -2 é o penúltimo (anterior ao último) índice e "
"assim por diante. Pense em ``seq[-n]`` como o mesmo que ``seq[len(seq)-n]``."

#: ../../faq/programming.rst:1184
msgid ""
"Using negative indices can be very convenient.  For example ``S[:-1]`` is "
"all of the string except for its last character, which is useful for "
"removing the trailing newline from a string."
msgstr ""
"Usar índices negativos pode ser muito conveniente. Por exemplo, ``S[:-1]`` é "
"a string inteira exceto pelo seu último caractere, o que é útil para remover "
"o caractere de nova linha no final de uma string."

#: ../../faq/programming.rst:1190
msgid "How do I iterate over a sequence in reverse order?"
msgstr "Como que eu itero uma sequência na ordem inversa?"

#: ../../faq/programming.rst:1192
msgid "Use the :func:`reversed` built-in function::"
msgstr "Use a função embutida :func:`reversed`::"

#: ../../faq/programming.rst:1194
msgid ""
"for x in reversed(sequence):\n"
"    ...  # do something with x ..."
msgstr ""
"for x in reversed(sequence):\n"
"    ...  # faz alguma coisa com x ..."

#: ../../faq/programming.rst:1197
msgid ""
"This won't touch your original sequence, but build a new copy with reversed "
"order to iterate over."
msgstr ""
"Isso não vai alterar sua sequência original, mas construir uma nova cópia "
"com a ordem inversa para iteração."

#: ../../faq/programming.rst:1202
msgid "How do you remove duplicates from a list?"
msgstr "Como que removo itens duplicados de uma lista?"

#: ../../faq/programming.rst:1204
msgid "See the Python Cookbook for a long discussion of many ways to do this:"
msgstr ""
"Veja o Python Cookbook para uma longa discussão de várias formas de fazer "
"isso:"

#: ../../faq/programming.rst:1206
msgid "https://code.activestate.com/recipes/52560/"
msgstr "https://code.activestate.com/recipes/52560/"

#: ../../faq/programming.rst:1208
msgid ""
"If you don't mind reordering the list, sort it and then scan from the end of "
"the list, deleting duplicates as you go::"
msgstr ""
"Se você não se importar em reordenar a lista, ordene-a e depois examine a "
"partir do final da lista, excluindo duplicatas conforme avança::"

#: ../../faq/programming.rst:1211
msgid ""
"if mylist:\n"
"    mylist.sort()\n"
"    last = mylist[-1]\n"
"    for i in range(len(mylist)-2, -1, -1):\n"
"        if last == mylist[i]:\n"
"            del mylist[i]\n"
"        else:\n"
"            last = mylist[i]"
msgstr ""
"if mylist:\n"
"    mylist.sort()\n"
"    last = mylist[-1]\n"
"    for i in range(len(mylist)-2, -1, -1):\n"
"        if last == mylist[i]:\n"
"            del mylist[i]\n"
"        else:\n"
"            last = mylist[i]"

#: ../../faq/programming.rst:1220
msgid ""
"If all elements of the list may be used as set keys (i.e. they are all :term:"
"`hashable`) this is often faster ::"
msgstr ""
"Se todos os elementos da lista podem ser usados como chaves de conjunto "
"(isto é, eles são todos :term:`hasheáveis <hasheável>`) isso é muitas vezes "
"mais rápido ::"

#: ../../faq/programming.rst:1223
msgid "mylist = list(set(mylist))"
msgstr "mylist = list(set(mylist))"

#: ../../faq/programming.rst:1225
msgid ""
"This converts the list into a set, thereby removing duplicates, and then "
"back into a list."
msgstr ""
"Isso converte a lista em um conjunto, deste modo removendo itens duplicados, "
"e depois de volta em uma lista."

#: ../../faq/programming.rst:1230
msgid "How do you remove multiple items from a list"
msgstr "Como remover múltiplos itens de uma lista?"

#: ../../faq/programming.rst:1232
msgid ""
"As with removing duplicates, explicitly iterating in reverse with a delete "
"condition is one possibility.  However, it is easier and faster to use slice "
"replacement with an implicit or explicit forward iteration. Here are three "
"variations.::"
msgstr ""
"Assim como para remover valores duplicados, explicitamente iterar em uma "
"lista reversa com uma condição de remoção é uma possibilidade. Contudo, é "
"mais fácil e rápido usar substituição de fatias com um iteração reversa "
"implícita ou explícita. Aqui estão três variações.::"

#: ../../faq/programming.rst:1237
msgid ""
"mylist[:] = filter(keep_function, mylist)\n"
"mylist[:] = (x for x in mylist if keep_condition)\n"
"mylist[:] = [x for x in mylist if keep_condition]"
msgstr ""
"mylist[:] = filter(keep_function, mylist)\n"
"mylist[:] = (x for x in mylist if keep_condition)\n"
"mylist[:] = [x for x in mylist if keep_condition]"

#: ../../faq/programming.rst:1241
msgid "The list comprehension may be fastest."
msgstr "A compreensão de lista pode ser a mais rápida."

#: ../../faq/programming.rst:1245
msgid "How do you make an array in Python?"
msgstr "Como fazer um vetor em Python?"

#: ../../faq/programming.rst:1247
msgid "Use a list::"
msgstr "Utilize uma lista::"

#: ../../faq/programming.rst:1249
msgid "[\"this\", 1, \"is\", \"an\", \"array\"]"
msgstr "[\"isto\", 1, \"é\", \"um\", \"vetor\"]"

#: ../../faq/programming.rst:1251
msgid ""
"Lists are equivalent to C or Pascal arrays in their time complexity; the "
"primary difference is that a Python list can contain objects of many "
"different types."
msgstr ""
"Listas são equivalentes aos vetores de C ou Pascal em termos de complexidade "
"de tempo; a diferença primária é que uma lista em Python pode conter objetos "
"de tipos diferentes."

#: ../../faq/programming.rst:1254
msgid ""
"The ``array`` module also provides methods for creating arrays of fixed "
"types with compact representations, but they are slower to index than "
"lists.  Also note that `NumPy <https://numpy.org/>`_ and other third party "
"packages define array-like structures with various characteristics as well."
msgstr ""
"O módulo ``array`` também provê métodos para criar vetores de tipos fixos "
"com representações compactas, mas eles são mais lentos para indexar que "
"listas.  Observe também que `NumPy <https://numpy.org/>`_ e outros pacotes "
"de terceiros definem estruturas semelhantes a arrays com várias "
"características."

#: ../../faq/programming.rst:1260
msgid ""
"To get Lisp-style linked lists, you can emulate *cons cells* using tuples::"
msgstr ""
"Para obter listas ligadas no estilo Lisp, você pode emular *células cons* "
"usando tuplas::"

#: ../../faq/programming.rst:1262
msgid "lisp_list = (\"like\",  (\"this\",  (\"example\", None) ) )"
msgstr "lista_lisp = (\"como\",  (\"este\",  (\"exemplo\", None) ) )"

#: ../../faq/programming.rst:1264
msgid ""
"If mutability is desired, you could use lists instead of tuples.  Here the "
"analogue of a Lisp *car* is ``lisp_list[0]`` and the analogue of *cdr* is "
"``lisp_list[1]``.  Only do this if you're sure you really need to, because "
"it's usually a lot slower than using Python lists."
msgstr ""
"Se mutabilidade é desejada, você pode usar listas no lugar de tuplas.  Aqui "
"o análogo de um *car* Lisp é  ``lista_lisp[0]`` e o análogo de *cdr* é "
"``lista_lisp[1]``.  Faça isso somente se você tem certeza que precisa disso, "
"porque isso é usualmente muito mais lento que usar listas Python."

#: ../../faq/programming.rst:1273
msgid "How do I create a multidimensional list?"
msgstr "Como faço para criar uma lista multidimensional?"

#: ../../faq/programming.rst:1275
msgid "You probably tried to make a multidimensional array like this::"
msgstr "Você provavelmente tentou fazer um vetor multidimensional assim::"

#: ../../faq/programming.rst:1277
msgid ">>> A = [[None] * 2] * 3"
msgstr ">>> A = [[None] * 2] * 3"

#: ../../faq/programming.rst:1279
msgid "This looks correct if you print it:"
msgstr "Isso parece correto se você imprimir:"

#: ../../faq/programming.rst:1285
msgid ""
">>> A\n"
"[[None, None], [None, None], [None, None]]"
msgstr ""
">>> A\n"
"[[None, None], [None, None], [None, None]]"

#: ../../faq/programming.rst:1290
msgid "But when you assign a value, it shows up in multiple places:"
msgstr "Mas quando atribuíres um valor, o mesmo aparecerá em vários lugares:"

#: ../../faq/programming.rst:1296
msgid ""
">>> A[0][0] = 5\n"
">>> A\n"
"[[5, None], [5, None], [5, None]]"
msgstr ""
">>> A[0][0] = 5\n"
">>> A\n"
"[[5, None], [5, None], [5, None]]"

#: ../../faq/programming.rst:1302
msgid ""
"The reason is that replicating a list with ``*`` doesn't create copies, it "
"only creates references to the existing objects.  The ``*3`` creates a list "
"containing 3 references to the same list of length two.  Changes to one row "
"will show in all rows, which is almost certainly not what you want."
msgstr ""
"A razão é que replicar uma lista com ``*`` não cria cópias, ela apenas cria "
"referências aos objetos existentes. O ``*3`` cria uma lista contendo 3 "
"referências para a mesma lista que contém 2 itens cada. Mudanças numa linha "
"serão mostradas em todas as linhas, o que certamente não é o que você deseja."

#: ../../faq/programming.rst:1307
msgid ""
"The suggested approach is to create a list of the desired length first and "
"then fill in each element with a newly created list::"
msgstr ""
"A abordagem sugerida é criar uma lista com o comprimento desejado primeiro "
"e, em seguida, preencher cada elemento com uma lista recém-criada::"

#: ../../faq/programming.rst:1310
msgid ""
"A = [None] * 3\n"
"for i in range(3):\n"
"    A[i] = [None] * 2"
msgstr ""
"A = [None] * 3\n"
"for i in range(3):\n"
"    A[i] = [None] * 2"

#: ../../faq/programming.rst:1314
msgid ""
"This generates a list containing 3 different lists of length two.  You can "
"also use a list comprehension::"
msgstr ""
"Isso gera uma lista contendo 3 listas diferentes contendo 2 itens cada. Você "
"também pode usar uma compreensão de lista::"

#: ../../faq/programming.rst:1317
msgid ""
"w, h = 2, 3\n"
"A = [[None] * w for i in range(h)]"
msgstr ""
"w, h = 2, 3\n"
"A = [[None] * w for i in range(h)]"

#: ../../faq/programming.rst:1320
msgid ""
"Or, you can use an extension that provides a matrix datatype; `NumPy "
"<https://numpy.org/>`_ is the best known."
msgstr ""
"Ou você pode usar uma extensão que provê um tipo de dados matrix; `NumPy "
"<https://numpy.org/>`_ é o mais conhecido."

#: ../../faq/programming.rst:1325
msgid "How do I apply a method or function to a sequence of objects?"
msgstr "Como eu aplico um método ou função para uma sequência de objetos?"

#: ../../faq/programming.rst:1327
msgid ""
"To call a method or function and accumulate the return values is a list, a :"
"term:`list comprehension` is an elegant solution::"
msgstr ""
"Para chamar um método ou função e acumular os valores retornados como uma "
"lista, uma :term:`compreensão de lista` é uma solução elegante::"

#: ../../faq/programming.rst:1330
msgid ""
"result = [obj.method() for obj in mylist]\n"
"\n"
"result = [function(obj) for obj in mylist]"
msgstr ""
"result = [obj.method() for obj in mylist]\n"
"\n"
"result = [function(obj) for obj in mylist]"

#: ../../faq/programming.rst:1334
msgid ""
"To just run the method or function without saving the return values, a "
"plain :keyword:`for` loop will suffice::"
msgstr ""
"Para apenas chamar o método ou função sem salvar os valores retornados, um "
"laço :keyword:`for` será o suficiente::"

#: ../../faq/programming.rst:1337
msgid ""
"for obj in mylist:\n"
"    obj.method()\n"
"\n"
"for obj in mylist:\n"
"    function(obj)"
msgstr ""
"for obj in mylist:\n"
"    obj.method()\n"
"\n"
"for obj in mylist:\n"
"    function(obj)"

#: ../../faq/programming.rst:1346
msgid ""
"Why does a_tuple[i] += ['item'] raise an exception when the addition works?"
msgstr ""
"Porque uma_tupla[i] += ['item'] levanta uma exceção quando a adição funciona?"

#: ../../faq/programming.rst:1348
msgid ""
"This is because of a combination of the fact that augmented assignment "
"operators are *assignment* operators, and the difference between mutable and "
"immutable objects in Python."
msgstr ""
"Isso se deve a uma combinação do fato de que os operadores de atribuição "
"aumentada são operadores de *atribuição* e à diferença entre objetos "
"mutáveis e imutáveis no Python."

#: ../../faq/programming.rst:1352
msgid ""
"This discussion applies in general when augmented assignment operators are "
"applied to elements of a tuple that point to mutable objects, but we'll use "
"a ``list`` and ``+=`` as our exemplar."
msgstr ""
"Essa discussão se aplica em geral quando operadores de atribuição aumentada "
"são aplicados a elementos de uma tupla que aponta para objetos mutáveis, mas "
"usaremos uma ``lista``  e ``+=`` como exemplo."

#: ../../faq/programming.rst:1356
msgid "If you wrote::"
msgstr "Se você escrever::"

#: ../../faq/programming.rst:1358
msgid ""
">>> a_tuple = (1, 2)\n"
">>> a_tuple[0] += 1\n"
"Traceback (most recent call last):\n"
"   ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""
">>> a_tuple = (1, 2)\n"
">>> a_tuple[0] += 1\n"
"Traceback (most recent call last):\n"
"   ...\n"
"TypeError: 'tuple' object does not support item assignment"

#: ../../faq/programming.rst:1364
msgid ""
"The reason for the exception should be immediately clear: ``1`` is added to "
"the object ``a_tuple[0]`` points to (``1``), producing the result object, "
"``2``, but when we attempt to assign the result of the computation, ``2``, "
"to element ``0`` of the tuple, we get an error because we can't change what "
"an element of a tuple points to."
msgstr ""
"O motivo da exceção deve ser imediatamente claro: ``1`` é adicionado ao "
"objeto que ``a_tuple[0]`` aponta para (``1``), produzindo o objeto de "
"resultado, ``2``, mas quando tentamos atribuir o resultado do cálculo, "
"``2``, ao elemento ``0`` da tupla, recebemos um erro porque não podemos "
"alterar o que um elemento de uma tupla aponta."

#: ../../faq/programming.rst:1370
msgid ""
"Under the covers, what this augmented assignment statement is doing is "
"approximately this::"
msgstr ""
"Por baixo, o que a instrução de atribuição aumentada está fazendo é "
"aproximadamente isso::"

#: ../../faq/programming.rst:1373
msgid ""
">>> result = a_tuple[0] + 1\n"
">>> a_tuple[0] = result\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""
">>> result = a_tuple[0] + 1\n"
">>> a_tuple[0] = result\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"

#: ../../faq/programming.rst:1379
msgid ""
"It is the assignment part of the operation that produces the error, since a "
"tuple is immutable."
msgstr ""
"Essa é a parte da atribuição da operação que produz o erro, já que a tupla é "
"imutável."

#: ../../faq/programming.rst:1382
msgid "When you write something like::"
msgstr "Quando você escreve algo como::"

#: ../../faq/programming.rst:1384
msgid ""
">>> a_tuple = (['foo'], 'bar')\n"
">>> a_tuple[0] += ['item']\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""
">>> a_tuple = (['foo'], 'bar')\n"
">>> a_tuple[0] += ['item']\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"

#: ../../faq/programming.rst:1390
msgid ""
"The exception is a bit more surprising, and even more surprising is the fact "
"that even though there was an error, the append worked::"
msgstr ""
"A exceção é um pouco mais surpreendente, e ainda mais surpreendente é o fato "
"de que, embora tenha havido um erro, o acréscimo à lista funcionou::"

#: ../../faq/programming.rst:1393
msgid ""
">>> a_tuple[0]\n"
"['foo', 'item']"
msgstr ""
">>> a_tuple[0]\n"
"['foo', 'item']"

#: ../../faq/programming.rst:1396
msgid ""
"To see why this happens, you need to know that (a) if an object implements "
"an :meth:`~object.__iadd__` magic method, it gets called when the ``+=`` "
"augmented assignment is executed, and its return value is what gets used in "
"the assignment statement; and (b) for lists, :meth:`!__iadd__` is equivalent "
"to calling :meth:`!extend` on the list and returning the list.  That's why "
"we say that for lists, ``+=`` is a \"shorthand\" for :meth:`!list.extend`::"
msgstr ""
"Para entender por que isso acontece, você precisa saber que (a) se um objeto "
"implementa um método mágico :meth:`~object.__iadd__`, ele é chamado quando a "
"atribuição aumentada ``+=`` é executada, e seu valor de retorno é o que é "
"usado na instrução de atribuição; e (b) para listas, :meth:`!__iadd__` é "
"equivalente a chamar :meth:`!extend` na lista e retornar a lista. É por isso "
"que dizemos que, para listas, ``+=`` é uma “abreviação” para :meth:`!list."
"extend`::"

#: ../../faq/programming.rst:1404
msgid ""
">>> a_list = []\n"
">>> a_list += [1]\n"
">>> a_list\n"
"[1]"
msgstr ""
">>> a_list = []\n"
">>> a_list += [1]\n"
">>> a_list\n"
"[1]"

#: ../../faq/programming.rst:1409
msgid "This is equivalent to::"
msgstr "Isso equivale a::"

#: ../../faq/programming.rst:1411
msgid ""
">>> result = a_list.__iadd__([1])\n"
">>> a_list = result"
msgstr ""
">>> result = a_list.__iadd__([1])\n"
">>> a_list = result"

#: ../../faq/programming.rst:1414
msgid ""
"The object pointed to by a_list has been mutated, and the pointer to the "
"mutated object is assigned back to ``a_list``.  The end result of the "
"assignment is a no-op, since it is a pointer to the same object that "
"``a_list`` was previously pointing to, but the assignment still happens."
msgstr ""
"O objeto apontado por a_list foi alterado e o ponteiro para o objeto "
"alterado é atribuído novamente a ``a_list``. O resultado final da atribuição "
"é um no-op, pois é um ponteiro para o mesmo objeto para o qual ``a_list`` "
"estava apontando anteriormente, mas a atribuição ainda acontece."

#: ../../faq/programming.rst:1419
msgid "Thus, in our tuple example what is happening is equivalent to::"
msgstr ""
"Portanto, em nosso exemplo da tupla, o que está acontecendo é equivalente a:"

#: ../../faq/programming.rst:1421
msgid ""
">>> result = a_tuple[0].__iadd__(['item'])\n"
">>> a_tuple[0] = result\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""
">>> result = a_tuple[0].__iadd__(['item'])\n"
">>> a_tuple[0] = result\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"

#: ../../faq/programming.rst:1427
msgid ""
"The :meth:`!__iadd__` succeeds, and thus the list is extended, but even "
"though ``result`` points to the same object that ``a_tuple[0]`` already "
"points to, that final assignment still results in an error, because tuples "
"are immutable."
msgstr ""
"O :meth:`!__iadd__` é bem-sucedido e, portanto, a lista é estendida, mas "
"mesmo que ``result`` aponte para o mesmo objeto para o qual ``a_tuple[0]`` "
"já aponta, essa atribuição final ainda resulta em um erro, pois as tuplas "
"são imutáveis."

#: ../../faq/programming.rst:1433
msgid ""
"I want to do a complicated sort: can you do a Schwartzian Transform in "
"Python?"
msgstr ""
"Quero fazer uma ordenação confusa: você pode fazer uma transformação "
"schwartziana em Python?"

#: ../../faq/programming.rst:1435
msgid ""
"The technique, attributed to Randal Schwartz of the Perl community, sorts "
"the elements of a list by a metric which maps each element to its \"sort "
"value\". In Python, use the ``key`` argument for the :meth:`list.sort` "
"method::"
msgstr ""
"A técnica, atribuída a Randal Schwartz da comunidade Perl, ordena os "
"elementos de uma lista por uma métrica que mapeia cada elemento para seu "
"“valor de ordem”. Em Python, use o argumento ``key`` para o método :meth:"
"`list.sort`::"

#: ../../faq/programming.rst:1439
msgid ""
"Isorted = L[:]\n"
"Isorted.sort(key=lambda s: int(s[10:15]))"
msgstr ""
"Isorted = L[:]\n"
"Isorted.sort(key=lambda s: int(s[10:15]))"

#: ../../faq/programming.rst:1444
msgid "How can I sort one list by values from another list?"
msgstr "Como eu posso ordenar uma lista pelos valores de outra lista?"

#: ../../faq/programming.rst:1446
msgid ""
"Merge them into an iterator of tuples, sort the resulting list, and then "
"pick out the element you want. ::"
msgstr ""
"Combine-as em um iterador de tuplas, ordene a lista resultante e, em "
"seguida, escolha o elemento desejado:"

#: ../../faq/programming.rst:1449
msgid ""
">>> list1 = [\"what\", \"I'm\", \"sorting\", \"by\"]\n"
">>> list2 = [\"something\", \"else\", \"to\", \"sort\"]\n"
">>> pairs = zip(list1, list2)\n"
">>> pairs = sorted(pairs)\n"
">>> pairs\n"
"[(\"I'm\", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', "
"'something')]\n"
">>> result = [x[1] for x in pairs]\n"
">>> result\n"
"['else', 'sort', 'to', 'something']"
msgstr ""
">>> list1 = [\"lista\", \"usada\", \"na\", \"ordenação\"]\n"
">>> list2 = [\"alguma\", \"coisa\", \"para\", \"ordenar\"]\n"
">>> pairs = zip(list1, list2)\n"
">>> pairs = sorted(pairs)\n"
">>> pairs\n"
"[('lista', 'alguma'), ('na', 'para'), ('ordenação', 'ordenar'), ('usada', "
"'coisa')]\n"
">>> result = [x[1] for x in pairs]\n"
">>> result\n"
"['alguma', 'para', 'ordenar', 'coisa']"

#: ../../faq/programming.rst:1461
msgid "Objects"
msgstr "Objetos"

#: ../../faq/programming.rst:1464
msgid "What is a class?"
msgstr "O que é uma classe?"

#: ../../faq/programming.rst:1466
msgid ""
"A class is the particular object type created by executing a class "
"statement. Class objects are used as templates to create instance objects, "
"which embody both the data (attributes) and code (methods) specific to a "
"datatype."
msgstr ""
"Uma classe é o tipo de objeto específico criado pela execução da instrução "
"class. Os objetos classe são usados como modelos para criar objetos "
"instância, que incorporam os dados (atributos) e o código (métodos) "
"específicos de um tipo de dado."

#: ../../faq/programming.rst:1470
msgid ""
"A class can be based on one or more other classes, called its base "
"class(es). It then inherits the attributes and methods of its base classes. "
"This allows an object model to be successively refined by inheritance.  You "
"might have a generic ``Mailbox`` class that provides basic accessor methods "
"for a mailbox, and subclasses such as ``MboxMailbox``, ``MaildirMailbox``, "
"``OutlookMailbox`` that handle various specific mailbox formats."
msgstr ""
"Uma classe pode ser baseada em uma ou mais outras classes, chamadas de "
"classe(s) base(s), herdando seus atributos e métodos. Isso permite que um "
"modelo de objeto seja sucessivamente refinado por herança.  Você pode ter "
"uma classe genérica ``Mailbox`` que fornece métodos básicos para uma caixa "
"de correio e subclasses como ``MboxMailbox``, ``MaildirMailbox``, "
"``OutlookMailbox`` que manipula vários formatos específicos de caixa de "
"correio."

#: ../../faq/programming.rst:1479
msgid "What is a method?"
msgstr "O que é um método?"

#: ../../faq/programming.rst:1481
msgid ""
"A method is a function on some object ``x`` that you normally call as ``x."
"name(arguments...)``.  Methods are defined as functions inside the class "
"definition::"
msgstr ""
"Um método é uma função em algum objeto ``x`` que você normalmente chama com "
"``x.name(arguments...)``. Métodos são definidos como funções dentro da "
"definição da classe::"

#: ../../faq/programming.rst:1485
msgid ""
"class C:\n"
"    def meth(self, arg):\n"
"        return arg * 2 + self.attribute"
msgstr ""
"class C:\n"
"    def meth(self, arg):\n"
"        return arg * 2 + self.attribute"

#: ../../faq/programming.rst:1491
msgid "What is self?"
msgstr "O que é o self?"

#: ../../faq/programming.rst:1493
msgid ""
"Self is merely a conventional name for the first argument of a method.  A "
"method defined as ``meth(self, a, b, c)`` should be called as ``x.meth(a, b, "
"c)`` for some instance ``x`` of the class in which the definition occurs; "
"the called method will think it is called as ``meth(x, a, b, c)``."
msgstr ""
"Self é apenas um nome convencional para o primeiro argumento de um método. "
"Um método definido como ``meth(self, a, b, c)`` deve ser chamado com ``x."
"meth(a, b, c)`` para alguma instância ``x`` da classe em que a definição "
"ocorre; o método chamado pensará que é chamado com ``meth(x, a, b, c)``."

#: ../../faq/programming.rst:1498
msgid "See also :ref:`why-self`."
msgstr "Veja também :ref:`why-self`."

#: ../../faq/programming.rst:1502
msgid ""
"How do I check if an object is an instance of a given class or of a subclass "
"of it?"
msgstr ""
"Como eu verifico se um objeto é uma instância de uma dada classe ou de uma "
"subclasse dela?"

#: ../../faq/programming.rst:1504
msgid ""
"Use the built-in function :func:`isinstance(obj, cls) <isinstance>`.  You "
"can check if an object is an instance of any of a number of classes by "
"providing a tuple instead of a single class, e.g. ``isinstance(obj, (class1, "
"class2, ...))``, and can also check whether an object is one of Python's "
"built-in types, e.g. ``isinstance(obj, str)`` or ``isinstance(obj, (int, "
"float, complex))``."
msgstr ""
"Use a função embutida :func:`isinstance(obj, cls) <isinstance>`.  Você pode "
"verificar se um objeto é uma instância de qualquer uma de várias classes "
"fornecendo um tupla em vez de uma única classe, por exemplo, "
"``isinstance(obj, (class1, class2, ...))``, e também pode verificar se um "
"objeto é de um dos tipos embutidos no Python, por exemplo, ``isinstance(obj, "
"str)`` ou ``isinstance(obj, (int, float, complex))``."

#: ../../faq/programming.rst:1511
msgid ""
"Note that :func:`isinstance` also checks for virtual inheritance from an :"
"term:`abstract base class`.  So, the test will return ``True`` for a "
"registered class even if hasn't directly or indirectly inherited from it.  "
"To test for \"true inheritance\", scan the :term:`MRO` of the class:"
msgstr ""
"Observe que :func:`isinstance` também verifica se há herança virtual de uma :"
"term:`classe base abstrata`. Portanto, o teste retorna ``True`` para uma "
"classe registrada, mesmo que não tenha herdado direta ou indiretamente dela. "
"Para testar a \"herança verdadeira\", verifique o :term:`MRO` da classe:"

#: ../../faq/programming.rst:1516
msgid ""
"from collections.abc import Mapping\n"
"\n"
"class P:\n"
"     pass\n"
"\n"
"class C(P):\n"
"    pass\n"
"\n"
"Mapping.register(P)"
msgstr ""
"from collections.abc import Mapping\n"
"\n"
"class P:\n"
"     pass\n"
"\n"
"class C(P):\n"
"    pass\n"
"\n"
"Mapping.register(P)"

#: ../../faq/programming.rst:1528
msgid ""
">>> c = C()\n"
">>> isinstance(c, C)        # direct\n"
"True\n"
">>> isinstance(c, P)        # indirect\n"
"True\n"
">>> isinstance(c, Mapping)  # virtual\n"
"True\n"
"\n"
"# Actual inheritance chain\n"
">>> type(c).__mro__\n"
"(<class 'C'>, <class 'P'>, <class 'object'>)\n"
"\n"
"# Test for \"true inheritance\"\n"
">>> Mapping in type(c).__mro__\n"
"False"
msgstr ""
">>> c = C()\n"
">>> isinstance(c, C)        # direta\n"
"True\n"
">>> isinstance(c, P)        # indireta\n"
"True\n"
">>> isinstance(c, Mapping)  # virtual\n"
"True\n"
"\n"
"# Cadeira de herança real\n"
">>> type(c).__mro__\n"
"(<class 'C'>, <class 'P'>, <class 'object'>)\n"
"\n"
"# Teste pela \"herança verdadeira\"\n"
">>> Mapping in type(c).__mro__\n"
"False"

#: ../../faq/programming.rst:1546
msgid ""
"Note that most programs do not use :func:`isinstance` on user-defined "
"classes very often.  If you are developing the classes yourself, a more "
"proper object-oriented style is to define methods on the classes that "
"encapsulate a particular behaviour, instead of checking the object's class "
"and doing a different thing based on what class it is.  For example, if you "
"have a function that does something::"
msgstr ""
"Observe que a maioria dos programas não usa :func:`isinstance` em classes "
"definidas pelo usuário com muita frequência. Se você estiver desenvolvendo "
"as classes por conta própria, um estilo orientado a objetos mais adequado é "
"definir métodos nas classes que encapsulam um comportamento específico, em "
"vez de verificar a classe do objeto e fazer uma coisa diferente com base na "
"classe que ele é. Por exemplo, se você tiver uma função que faz algo::"

#: ../../faq/programming.rst:1553
msgid ""
"def search(obj):\n"
"    if isinstance(obj, Mailbox):\n"
"        ...  # code to search a mailbox\n"
"    elif isinstance(obj, Document):\n"
"        ...  # code to search a document\n"
"    elif ..."
msgstr ""
"def search(obj):\n"
"    if isinstance(obj, Mailbox):\n"
"        ...  # código para pesquisar uma caixa de correio\n"
"    elif isinstance(obj, documento):\n"
"        ...  # código para pesquisar um documento\n"
"    elif ..."

#: ../../faq/programming.rst:1560
msgid ""
"A better approach is to define a ``search()`` method on all the classes and "
"just call it::"
msgstr ""
"Uma abordagem melhor é definir um método ``search()`` em todas as classes e "
"apenas chamá-lo::"

#: ../../faq/programming.rst:1563
msgid ""
"class Mailbox:\n"
"    def search(self):\n"
"        ...  # code to search a mailbox\n"
"\n"
"class Document:\n"
"    def search(self):\n"
"        ...  # code to search a document\n"
"\n"
"obj.search()"
msgstr ""
"class Mailbox:\n"
"    def search(self):\n"
"        ...  # código para pesquisar uma caixa de correio\n"
"\n"
"class documento:\n"
"    def search(self):\n"
"        ...  # código para pesquisar um documento\n"
"\n"
"obj.search()"

#: ../../faq/programming.rst:1575
msgid "What is delegation?"
msgstr "O que é delegação?"

#: ../../faq/programming.rst:1577
msgid ""
"Delegation is an object oriented technique (also called a design pattern). "
"Let's say you have an object ``x`` and want to change the behaviour of just "
"one of its methods.  You can create a new class that provides a new "
"implementation of the method you're interested in changing and delegates all "
"other methods to the corresponding method of ``x``."
msgstr ""
"A delegação é uma técnica orientada a objetos (também chamada de padrão de "
"projeto). Digamos que você tenha um objeto ``x`` e queira alterar o "
"comportamento de apenas um de seus métodos. Você pode criar uma nova classe "
"que forneça uma nova implementação do método que você está interessado em "
"alterar e delegar todos os outros métodos ao método correspondente de ``x``."

#: ../../faq/programming.rst:1583
msgid ""
"Python programmers can easily implement delegation.  For example, the "
"following class implements a class that behaves like a file but converts all "
"written data to uppercase::"
msgstr ""
"Com Python, você pode implementar delegação facilmente. Por exemplo, o "
"trecho de código a seguir implementa uma classe que se comporta como um "
"arquivo, mas converte todos os dados gravados em letras maiúsculas::"

#: ../../faq/programming.rst:1587
msgid ""
"class UpperOut:\n"
"\n"
"    def __init__(self, outfile):\n"
"        self._outfile = outfile\n"
"\n"
"    def write(self, s):\n"
"        self._outfile.write(s.upper())\n"
"\n"
"    def __getattr__(self, name):\n"
"        return getattr(self._outfile, name)"
msgstr ""
"class UpperOut:\n"
"\n"
"    def __init__(self, outfile):\n"
"        self._outfile = outfile\n"
"\n"
"    def write(self, s):\n"
"        self._outfile.write(s.upper())\n"
"\n"
"    def __getattr__(self, name):\n"
"        return getattr(self._outfile, name)"

#: ../../faq/programming.rst:1598
msgid ""
"Here the ``UpperOut`` class redefines the ``write()`` method to convert the "
"argument string to uppercase before calling the underlying ``self._outfile."
"write()`` method.  All other methods are delegated to the underlying ``self."
"_outfile`` object.  The delegation is accomplished via the :meth:`~object."
"__getattr__` method; consult :ref:`the language reference <attribute-"
"access>` for more information about controlling attribute access."
msgstr ""
"Aqui, a classe ``UpperOut`` redefine o método ``write()`` para converter o "
"argumento string em maiúsculas antes de chamar o método ``self._outfile."
"write()`` subjacente.  Todos os outros métodos são delegados ao objeto "
"``self._outfile`` subjacente.  A delegação é realizada por meio do método :"
"meth:`~object.__getattr__`; consulte :ref:`a referência da linguagem "
"<attribute-access>` para obter mais informações sobre o controle de acesso a "
"atributo."

#: ../../faq/programming.rst:1605
msgid ""
"Note that for more general cases delegation can get trickier. When "
"attributes must be set as well as retrieved, the class must define a :meth:"
"`~object.__setattr__` method too, and it must do so carefully.  The basic "
"implementation of :meth:`!__setattr__` is roughly equivalent to the "
"following::"
msgstr ""
"Observe que, em casos mais gerais, a delegação pode se tornar mais "
"complicada. Quando o atributo precisa ser definido e recuperado, a classe "
"deve definir um método :meth:`~object.__setattr__`  também, e deve fazê-lo "
"com cuidado.  A implementação básica do :meth:`!__setattr__` é "
"aproximadamente equivalente ao seguinte::"

#: ../../faq/programming.rst:1610
msgid ""
"class X:\n"
"    ...\n"
"    def __setattr__(self, name, value):\n"
"        self.__dict__[name] = value\n"
"    ..."
msgstr ""
"class X:\n"
"    ...\n"
"    def __setattr__(self, name, value):\n"
"        self.__dict__[name] = value\n"
"    ..."

#: ../../faq/programming.rst:1616
msgid ""
"Many :meth:`~object.__setattr__` implementations call :meth:`!object."
"__setattr__` to set an attribute on self without causing infinite recursion::"
msgstr ""
"Muitas implementações do método :meth:`~object.__setattr__` chamam o :meth:`!"
"object.__setattr__` para definir um atributo em si mesmo sem causar recursão "
"infinita::"

#: ../../faq/programming.rst:1619
msgid ""
"class X:\n"
"    def __setattr__(self, name, value):\n"
"        # Custom logic here...\n"
"        object.__setattr__(self, name, value)"
msgstr ""
"class X:\n"
"    def __setattr__(self, name, value):\n"
"        # Lógica personalizada aqui...\n"
"        object.__setattr__(self, name, value)"

#: ../../faq/programming.rst:1624
msgid ""
"Alternatively, it is possible to set attributes by inserting entries into :"
"attr:`self.__dict__ <object.__dict__>` directly."
msgstr ""
"Como alternativa, é possível definir atributos inserindo entradas em :attr:"
"`self.__dict__ <object.__dict__>` diretamente."

#: ../../faq/programming.rst:1629
msgid ""
"How do I call a method defined in a base class from a derived class that "
"extends it?"
msgstr ""
"Como eu chamo um método definido em uma classe base a partir de uma classe "
"derivada que a estende?"

#: ../../faq/programming.rst:1631
msgid "Use the built-in :func:`super` function::"
msgstr "Use a função embutida :func:`super`::"

#: ../../faq/programming.rst:1633
msgid ""
"class Derived(Base):\n"
"    def meth(self):\n"
"        super().meth()  # calls Base.meth"
msgstr ""
"class Derived(Base):\n"
"    def meth(self):\n"
"        super().meth()  # chama Base.meth"

#: ../../faq/programming.rst:1637
msgid ""
"In the example, :func:`super` will automatically determine the instance from "
"which it was called (the ``self`` value), look up the :term:`method "
"resolution order` (MRO) with ``type(self).__mro__``, and return the next in "
"line after ``Derived`` in the MRO: ``Base``."
msgstr ""
"No exemplo, :func:`super` determinará automaticamente a instância da qual "
"foi chamado (o valor de ``self``), procura a :term:`ordem de resolução de "
"métodos` (MRO) com ``type(self).__mro__`` e então retorna o próximo na linha "
"após ``Derived`` no MRO: ``Base``."

#: ../../faq/programming.rst:1644
msgid "How can I organize my code to make it easier to change the base class?"
msgstr ""
"Como eu posso organizar meu código para facilitar a troca da classe base?"

#: ../../faq/programming.rst:1646
msgid ""
"You could assign the base class to an alias and derive from the alias.  Then "
"all you have to change is the value assigned to the alias.  Incidentally, "
"this trick is also handy if you want to decide dynamically (e.g. depending "
"on availability of resources) which base class to use.  Example::"
msgstr ""
"Você poderia atribuir a classe base a um apelido e derivar do apelido. "
"Então, tudo o que você precisa alterar é o valor atribuído ao apelido. "
"Aliás, esse truque também é útil se você quiser decidir dinamicamente (por "
"exemplo, dependendo do disponibilidade de recursos) qual classe base usar.  "
"Exemplo::"

#: ../../faq/programming.rst:1651
msgid ""
"class Base:\n"
"    ...\n"
"\n"
"BaseAlias = Base\n"
"\n"
"class Derived(BaseAlias):\n"
"    ..."
msgstr ""
"class Base:\n"
"    ...\n"
"\n"
"BaseAlias = Base\n"
"\n"
"class Derived(BaseAlias):\n"
"    ..."

#: ../../faq/programming.rst:1661
msgid "How do I create static class data and static class methods?"
msgstr ""
"Como faço para criar dados de classe estáticos e métodos de classe estáticos?"

#: ../../faq/programming.rst:1663
msgid ""
"Both static data and static methods (in the sense of C++ or Java) are "
"supported in Python."
msgstr ""
"Tanto dados estáticos quanto métodos estáticos (no sentido de C++ ou Java) "
"são possíveis com Python."

#: ../../faq/programming.rst:1666
msgid ""
"For static data, simply define a class attribute.  To assign a new value to "
"the attribute, you have to explicitly use the class name in the assignment::"
msgstr ""
"Para dados estáticos, basta definir um atributo de classe. Para atribuir um "
"novo valor ao atributo, você precisa usar explicitamente o nome da classe na "
"atribuição::"

#: ../../faq/programming.rst:1669
msgid ""
"class C:\n"
"    count = 0   # number of times C.__init__ called\n"
"\n"
"    def __init__(self):\n"
"        C.count = C.count + 1\n"
"\n"
"    def getcount(self):\n"
"        return C.count  # or return self.count"
msgstr ""
"class C:\n"
"    count = 0 # número de vezes que C.__init__ foi chamado\n"
"\n"
"    def __init__(self):\n"
"        C.count = C.count + 1\n"
"\n"
"    def getcount(self):\n"
"        return C.count # ou return self.count"

#: ../../faq/programming.rst:1678
msgid ""
"``c.count`` also refers to ``C.count`` for any ``c`` such that "
"``isinstance(c, C)`` holds, unless overridden by ``c`` itself or by some "
"class on the base-class search path from ``c.__class__`` back to ``C``."
msgstr ""
"``c.count`` também se refere a ``C.count`` para qualquer ``c`` de modo que "
"``isinstance(c, C)`` seja válido, a menos que seja substituído pelo próprio "
"``c`` ou por alguma classe no caminho de busca da classe base de ``c."
"__class__`` até ``C``."

#: ../../faq/programming.rst:1682
msgid ""
"Caution: within a method of C, an assignment like ``self.count = 42`` "
"creates a new and unrelated instance named \"count\" in ``self``'s own "
"dict.  Rebinding of a class-static data name must always specify the class "
"whether inside a method or not::"
msgstr ""
"Cuidado: em um método de C, uma atribuição como ``self.count = 42`` cria uma "
"instância nova e não-relacionada chamada \"count\" no próprio dicionário de "
"``self``.  A revinculação de um nome de dado de classe estático deve sempre "
"especificar a classe, seja dentro de um método ou não::"

#: ../../faq/programming.rst:1687
msgid "C.count = 314"
msgstr "C.count = 314"

#: ../../faq/programming.rst:1689
msgid "Static methods are possible::"
msgstr "Métodos estáticos são possíveis::"

#: ../../faq/programming.rst:1691
msgid ""
"class C:\n"
"    @staticmethod\n"
"    def static(arg1, arg2, arg3):\n"
"        # No 'self' parameter!\n"
"        ..."
msgstr ""
"class C:\n"
"    @staticmethod\n"
"    def static(arg1, arg2, arg3):\n"
"        # Sem parâmetro 'self'!\n"
"        ..."

#: ../../faq/programming.rst:1697
msgid ""
"However, a far more straightforward way to get the effect of a static method "
"is via a simple module-level function::"
msgstr ""
"No entanto, uma maneira muito mais direta de obter o efeito de um método "
"estático é por meio de uma simples função em nível de módulo::"

#: ../../faq/programming.rst:1700
msgid ""
"def getcount():\n"
"    return C.count"
msgstr ""
"def getcount():\n"
"    return C.count"

#: ../../faq/programming.rst:1703
msgid ""
"If your code is structured so as to define one class (or tightly related "
"class hierarchy) per module, this supplies the desired encapsulation."
msgstr ""
"Se o seu código está estruturado de modo a definir uma classe (ou uma "
"hierarquia de classes estreitamente relacionada) por módulo, isso fornecerá "
"o encapsulamento desejado."

#: ../../faq/programming.rst:1708
msgid "How can I overload constructors (or methods) in Python?"
msgstr "Como eu posso sobrecarregar construtores (ou métodos) em Python?"

#: ../../faq/programming.rst:1710
msgid ""
"This answer actually applies to all methods, but the question usually comes "
"up first in the context of constructors."
msgstr ""
"Essa resposta na verdade se aplica para todos os métodos, mas a pergunta "
"normalmente aparece primeiro no contexto de construtores."

#: ../../faq/programming.rst:1713
msgid "In C++ you'd write"
msgstr "Em C++ escreveríamos"

#: ../../faq/programming.rst:1715
msgid ""
"class C {\n"
"    C() { cout << \"No arguments\\n\"; }\n"
"    C(int i) { cout << \"Argument is \" << i << \"\\n\"; }\n"
"}"
msgstr ""
"class C {\n"
"    C() { cout << \"Sem argumentos\\n\"; }\n"
"    C(int i) { cout << \"Argumento é igual a \" << i << \"\\n\"; }\n"
"}"

#: ../../faq/programming.rst:1722
msgid ""
"In Python you have to write a single constructor that catches all cases "
"using default arguments.  For example::"
msgstr ""
"Em Python, você tem que escrever um único construtor que pega todos os casos "
"usando argumentos padrão. Por exemplo::"

#: ../../faq/programming.rst:1725
msgid ""
"class C:\n"
"    def __init__(self, i=None):\n"
"        if i is None:\n"
"            print(\"No arguments\")\n"
"        else:\n"
"            print(\"Argument is\", i)"
msgstr ""
"class C:\n"
"    def __init__(self, i=None):\n"
"        if i is None:\n"
"            print(\"Sem argumentos\")\n"
"        else:\n"
"            print(\"Argumento é igual a\", i)"

#: ../../faq/programming.rst:1732
msgid "This is not entirely equivalent, but close enough in practice."
msgstr "Isso não é inteiramente equivalente, mas já está bem próximo."

#: ../../faq/programming.rst:1734
msgid "You could also try a variable-length argument list, e.g. ::"
msgstr ""
"Você também pode tentar uma lista de argumentos de comprimento variável, por "
"exemplo::"

#: ../../faq/programming.rst:1736
msgid ""
"def __init__(self, *args):\n"
"    ..."
msgstr ""
"def __init__(self, *args):\n"
"    ..."

#: ../../faq/programming.rst:1739
msgid "The same approach works for all method definitions."
msgstr "A mesma abordagem funciona para todas as definições de métodos."

#: ../../faq/programming.rst:1743
msgid "I try to use __spam and I get an error about _SomeClassName__spam."
msgstr "Eu tentei usar __spam e recebi um erro sobre _SomeClassName__spam."

#: ../../faq/programming.rst:1745
msgid ""
"Variable names with double leading underscores are \"mangled\" to provide a "
"simple but effective way to define class private variables.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with any leading underscores "
"stripped."
msgstr ""
"Os nomes de variáveis com dois sublinhados à esquerda são \"manipulados\" "
"para fornecer uma maneira simples, mas eficaz, de definir variáveis privadas "
"de classe.  Qualquer identificador no formato ``__spam`` (pelo menos dois "
"sublinhados à esquerda, no máximo um sublinhado à direita) é textualmente "
"substituído por ``_classname__spam``, em que ``classname`` é o nome da "
"classe atual sem nenhum sublinhado à esquerda."

#: ../../faq/programming.rst:1751
msgid ""
"The identifier can be used unchanged within the class, but to access it "
"outside the class, the mangled name must be used:"
msgstr ""
"O identificador pode ser usado normalmente dentro da classe, mas para acessá-"
"lo fora da classe, deve ser usado o nome manipulado:"

#: ../../faq/programming.rst:1754
msgid ""
"class A:\n"
"    def __one(self):\n"
"        return 1\n"
"    def two(self):\n"
"        return 2 * self.__one()\n"
"\n"
"class B(A):\n"
"    def three(self):\n"
"        return 3 * self._A__one()\n"
"\n"
"four = 4 * A()._A__one()"
msgstr ""
"class A:\n"
"    def __one(self):\n"
"        return 1\n"
"    def two(self):\n"
"        return 2 * self.__one()\n"
"\n"
"class B(A):\n"
"    def three(self):\n"
"        return 3 * self._A__one()\n"
"\n"
"four = 4 * A()._A__one()"

#: ../../faq/programming.rst:1768
msgid ""
"In particular, this does not guarantee privacy since an outside user can "
"still deliberately access the private attribute; many Python programmers "
"never bother to use private variable names at all."
msgstr ""
"Em particular, isso não garante a privacidade, pois um usuário externo ainda "
"pode acessar deliberadamente o atributo privado; muitas pessoas que usam "
"Python nunca se preocuparam em usar nomes de variáveis privadas."

#: ../../faq/programming.rst:1774
msgid ""
"The :ref:`private name mangling specifications <private-name-mangling>` for "
"details and special cases."
msgstr ""
"As :ref:`especificações de desfiguração de nome privado <private-name-"
"mangling>` para detalhes e casos especiais."

#: ../../faq/programming.rst:1778
msgid "My class defines __del__ but it is not called when I delete the object."
msgstr ""
"Minha classe define __del__, mas o mesmo não é chamado quando eu excluo o "
"objeto."

#: ../../faq/programming.rst:1780
msgid "There are several possible reasons for this."
msgstr "Há várias razões possíveis para isto."

#: ../../faq/programming.rst:1782
msgid ""
"The :keyword:`del` statement does not necessarily call :meth:`~object."
"__del__` -- it simply decrements the object's reference count, and if this "
"reaches zero :meth:`!__del__` is called."
msgstr ""
"A instrução :keyword:`del` não necessariamente chama o método :meth:`~object."
"__del__` - ele simplesmente diminui o contagem de referências do objeto e, "
"se ele chegar a zero, o :meth:`!__del__` é chamado."

#: ../../faq/programming.rst:1786
msgid ""
"If your data structures contain circular links (e.g. a tree where each child "
"has a parent reference and each parent has a list of children) the reference "
"counts will never go back to zero.  Once in a while Python runs an algorithm "
"to detect such cycles, but the garbage collector might run some time after "
"the last reference to your data structure vanishes, so your :meth:`!__del__` "
"method may be called at an inconvenient and random time. This is "
"inconvenient if you're trying to reproduce a problem. Worse, the order in "
"which object's :meth:`!__del__` methods are executed is arbitrary.  You can "
"run :func:`gc.collect` to force a collection, but there *are* pathological "
"cases where objects will never be collected."
msgstr ""
"Se suas estruturas de dados contiverem links circulares (por exemplo, uma "
"árvore em que cada filho tem uma referência para o pai e cada pai tem uma "
"lista de filhos), a contagem de referências nunca voltará a zero.  De vez em "
"quando, o Python executa um algoritmo para detectar esses ciclos, mas o "
"coletor de lixo pode ser executado algum tempo depois que a última "
"referência da sua estrutura de dados desaparecer, de modo que o seu método :"
"meth:`!__del__` pode ser chamado em um momento inconveniente e aleatório. "
"Isso é inconveniente se você estiver tentando reproduzir um problema. Pior "
"ainda, a ordem em quais objetos o métodos :meth:`!__del__` são executados é "
"arbitrária.  Você pode executar :func:`gc.collect` para forçar um coleção, "
"mas *há* casos patológicos em que os objetos nunca serão coletados."

#: ../../faq/programming.rst:1797
msgid ""
"Despite the cycle collector, it's still a good idea to define an explicit "
"``close()`` method on objects to be called whenever you're done with them.  "
"The ``close()`` method can then remove attributes that refer to subobjects.  "
"Don't call :meth:`!__del__` directly -- :meth:`!__del__` should call "
"``close()`` and ``close()`` should make sure that it can be called more than "
"once for the same object."
msgstr ""
"Apesar do coletor de ciclos, ainda é uma boa ideia definir um método "
"``close()`` explícito nos objetos a ser chamado sempre que você terminar de "
"usá-los.  O método ``close()`` pode então remover o atributo que se refere a "
"subobjetos.  Não chame :meth:`!__del__` diretamente - :meth:`!__del__` deve "
"chamar ``close()`` e ``close()`` deve garantir que ele possa ser chamado "
"mais de uma vez para o mesmo objeto."

#: ../../faq/programming.rst:1804
msgid ""
"Another way to avoid cyclical references is to use the :mod:`weakref` "
"module, which allows you to point to objects without incrementing their "
"reference count. Tree data structures, for instance, should use weak "
"references for their parent and sibling references (if they need them!)."
msgstr ""
"Outra forma de evitar referências cíclicas é usar o módulo :mod:`weakref`, "
"que permite apontar para objetos sem incrementar o contagem de referências. "
"As estruturas de dados em árvore, por exemplo, devem usar o referência fraca "
"para referenciar seus pais e irmãos (se precisarem deles!)."

#: ../../faq/programming.rst:1817
msgid ""
"Finally, if your :meth:`!__del__` method raises an exception, a warning "
"message is printed to :data:`sys.stderr`."
msgstr ""
"Por fim, se seu método :meth:`!__del__` levanta uma exceção, uma mensagem de "
"alerta será enviada para :data:`sys.stderr`."

#: ../../faq/programming.rst:1822
msgid "How do I get a list of all instances of a given class?"
msgstr ""
"Como eu consigo pegar uma lista de todas as instâncias de uma dada classe?"

#: ../../faq/programming.rst:1824
msgid ""
"Python does not keep track of all instances of a class (or of a built-in "
"type). You can program the class's constructor to keep track of all "
"instances by keeping a list of weak references to each instance."
msgstr ""
"Python não mantém o controle de todas as instâncias de uma classe (ou de um "
"tipo embutido). Você pode programar o construtor da classe para manter o "
"controle de todas as instâncias, mantendo uma lista de referências fracas "
"para cada instância."

#: ../../faq/programming.rst:1830
msgid "Why does the result of ``id()`` appear to be not unique?"
msgstr "Por que o resultado de ``id()`` aparenta não ser único?"

#: ../../faq/programming.rst:1832
msgid ""
"The :func:`id` builtin returns an integer that is guaranteed to be unique "
"during the lifetime of the object.  Since in CPython, this is the object's "
"memory address, it happens frequently that after an object is deleted from "
"memory, the next freshly created object is allocated at the same position in "
"memory.  This is illustrated by this example:"
msgstr ""
"A função embutida :func:`id` retorna um inteiro que é garantido ser único "
"durante a vida útil do objeto.  Como em CPython esse número é o endereço de "
"memória do objeto, acontece com frequência que, depois que um objeto é "
"excluído da memória, o próximo objeto recém-criado é alocado na mesma "
"posição na memória.  Isso é ilustrado por este exemplo:"

#: ../../faq/programming.rst:1843
msgid ""
"The two ids belong to different integer objects that are created before, and "
"deleted immediately after execution of the ``id()`` call.  To be sure that "
"objects whose id you want to examine are still alive, create another "
"reference to the object:"
msgstr ""
"Os dois ids pertencem a diferentes objetos inteiros que são criados antes e "
"excluídos imediatamente após a execução da chamada de ``id()``.  Para ter "
"certeza de que os objetos cujo id você deseja examinar ainda estão vivos, "
"crie outra referencia para o objeto:"

#: ../../faq/programming.rst:1856
msgid "When can I rely on identity tests with the *is* operator?"
msgstr "Quando eu posso depender dos testes de identidade com o operador *is*?"

#: ../../faq/programming.rst:1858
msgid ""
"The ``is`` operator tests for object identity.  The test ``a is b`` is "
"equivalent to ``id(a) == id(b)``."
msgstr ""
"O operador ``is`` testa a identidade do objeto. O teste ``a is b`` equivale "
"a ``id(a) == id(b)``."

#: ../../faq/programming.rst:1861
msgid ""
"The most important property of an identity test is that an object is always "
"identical to itself, ``a is a`` always returns ``True``.  Identity tests are "
"usually faster than equality tests.  And unlike equality tests, identity "
"tests are guaranteed to return a boolean ``True`` or ``False``."
msgstr ""
"A propriedade mais importante de um teste de identidade é que um objeto é "
"sempre idêntico a si mesmo, ``a is a`` sempre retorna ``True``. Testes de "
"identidade são geralmente mais rápidos do que os testes de igualdade. E, ao "
"contrário dos testes de igualdade, teste de identidade garante que retorno "
"seja um booleano ``True`` ou ``False``."

#: ../../faq/programming.rst:1866
msgid ""
"However, identity tests can *only* be substituted for equality tests when "
"object identity is assured.  Generally, there are three circumstances where "
"identity is guaranteed:"
msgstr ""
"Entretanto, o teste de identidade *somente* pode ser substituído por testes "
"de igualdade quando a identidade do objeto é garantida. Em geral, há três "
"circunstâncias em que a identidade é garantida:"

#: ../../faq/programming.rst:1870
msgid ""
"Assignments create new names but do not change object identity.  After the "
"assignment ``new = old``, it is guaranteed that ``new is old``."
msgstr ""
"Atribuições criam novos nomes, mas não alteram a identidade do objeto. Após "
"a atribuição ``new = old``, é garantido que ``new is old``."

#: ../../faq/programming.rst:1873
msgid ""
"Putting an object in a container that stores object references does not "
"change object identity.  After the list assignment ``s[0] = x``, it is "
"guaranteed that ``s[0] is x``."
msgstr ""
"Colocar um objeto em um contêiner que armazena referências de objetos não "
"altera a identidade do objeto. Após a lista atribuição ``s[0] = x``, é "
"garantido que ``s[0] is x``."

#: ../../faq/programming.rst:1877
msgid ""
"If an object is a singleton, it means that only one instance of that object "
"can exist.  After the assignments ``a = None`` and ``b = None``, it is "
"guaranteed that ``a is b`` because ``None`` is a singleton."
msgstr ""
"Se um objeto for um Singleton, isso significa que só pode existir uma "
"instância desse objeto. Depois de atribuição ``a = None`` e ``b = None``, é "
"garantido que ``a is b`` porque ``None`` é um Singleton."

#: ../../faq/programming.rst:1881
msgid ""
"In most other circumstances, identity tests are inadvisable and equality "
"tests are preferred.  In particular, identity tests should not be used to "
"check constants such as :class:`int` and :class:`str` which aren't "
"guaranteed to be singletons::"
msgstr ""
"Na maioria das outras circunstâncias, o teste de identidade é "
"desaconselhável e os testes de igualdade são preferíveis. Em particular, "
"teste de identidade não deve ser usado para verificar constantes, como :"
"class:`int` e :class:`str`, que não têm garantia de serem Singletons::"

#: ../../faq/programming.rst:1886
msgid ""
">>> a = 1000\n"
">>> b = 500\n"
">>> c = b + 500\n"
">>> a is c\n"
"False\n"
"\n"
">>> a = 'Python'\n"
">>> b = 'Py'\n"
">>> c = b + 'thon'\n"
">>> a is c\n"
"False"
msgstr ""
">>> a = 1000\n"
">>> b = 500\n"
">>> c = b + 500\n"
">>> a is c\n"
"False\n"
"\n"
">>> a = 'Python'\n"
">>> b = 'Py'\n"
">>> c = b + 'thon'\n"
">>> a is c\n"
"False"

#: ../../faq/programming.rst:1898
msgid "Likewise, new instances of mutable containers are never identical::"
msgstr ""
"Do mesmo jeito, novas instâncias de contêineres mutáveis nunca são "
"idênticas::"

#: ../../faq/programming.rst:1900
msgid ""
">>> a = []\n"
">>> b = []\n"
">>> a is b\n"
"False"
msgstr ""
">>> a = []\n"
">>> b = []\n"
">>> a is b\n"
"False"

#: ../../faq/programming.rst:1905
msgid ""
"In the standard library code, you will see several common patterns for "
"correctly using identity tests:"
msgstr ""
"No código da biblioteca padrão, você encontrará vários padrões comuns para "
"usar corretamente o teste de identidade:"

#: ../../faq/programming.rst:1908
msgid ""
"As recommended by :pep:`8`, an identity test is the preferred way to check "
"for ``None``.  This reads like plain English in code and avoids confusion "
"with other objects that may have boolean values that evaluate to false."
msgstr ""
"Conforme recomendado por :pep:`8`, um teste de identidade é a maneira "
"preferida de verificar ``None``.  Isso é lido como se fosse inglês simples "
"no código e evita confusão com outros objetos que podem ter valor booleano "
"avaliado para falso."

#: ../../faq/programming.rst:1912
msgid ""
"Detecting optional arguments can be tricky when ``None`` is a valid input "
"value.  In those situations, you can create a singleton sentinel object "
"guaranteed to be distinct from other objects.  For example, here is how to "
"implement a method that behaves like :meth:`dict.pop`:"
msgstr ""
"A detecção de argumento opcional pode ser complicada quando ``None`` é uma "
"valor de entrada válido.  Nessas situações, você pode criar um objeto "
"Singleton sinalizador com garantia de ser distinto de outros objetos. Por "
"exemplo, veja como implementar um método que se comporta como :meth:`dict."
"pop`:"

#: ../../faq/programming.rst:1917
msgid ""
"_sentinel = object()\n"
"\n"
"def pop(self, key, default=_sentinel):\n"
"    if key in self:\n"
"        value = self[key]\n"
"        del self[key]\n"
"        return value\n"
"    if default is _sentinel:\n"
"        raise KeyError(key)\n"
"    return default"
msgstr ""
"_sentinel = object()\n"
"\n"
"def pop(self, key, default=_sentinel):\n"
"    if key in self:\n"
"        value = self[key]\n"
"        del self[key]\n"
"        return value\n"
"    if default is _sentinel:\n"
"        raise KeyError(key)\n"
"    return default"

#: ../../faq/programming.rst:1930
msgid ""
"Container implementations sometimes need to augment equality tests with "
"identity tests.  This prevents the code from being confused by objects such "
"as ``float('NaN')`` that are not equal to themselves."
msgstr ""
"Implementações de contêiner às vezes precisam combinar testes de igualdade "
"com testes de identidade. Isso evita que o código seja confundido por "
"objetos como ``float('NaN')`` que não são iguais a si mesmos."

#: ../../faq/programming.rst:1934
msgid ""
"For example, here is the implementation of :meth:`!collections.abc.Sequence."
"__contains__`::"
msgstr ""
"Por exemplo, aqui está a implementação de :meth:`!collections.abc.Sequence."
"__contains__`::"

#: ../../faq/programming.rst:1937
msgid ""
"def __contains__(self, value):\n"
"    for v in self:\n"
"        if v is value or v == value:\n"
"            return True\n"
"    return False"
msgstr ""
"def __contains__(self, value):\n"
"    for v in self:\n"
"        if v is value or v == value:\n"
"            return True\n"
"    return False"

#: ../../faq/programming.rst:1945
msgid ""
"How can a subclass control what data is stored in an immutable instance?"
msgstr ""
"Como uma subclasse pode controlar quais dados são armazenados em uma "
"instância imutável?"

#: ../../faq/programming.rst:1947
msgid ""
"When subclassing an immutable type, override the :meth:`~object.__new__` "
"method instead of the :meth:`~object.__init__` method.  The latter only runs "
"*after* an instance is created, which is too late to alter data in an "
"immutable instance."
msgstr ""
"Quando estender um tipo imutável, sobrescreva o método :meth:`~object."
"__new__` em vez do método :meth:`~object.__init__`.  O último só é executado "
"*depois* que uma instância é criada, o que é tarde demais para alterar os "
"dados em uma instância imutável."

#: ../../faq/programming.rst:1952
msgid ""
"All of these immutable classes have a different signature than their parent "
"class:"
msgstr ""
"Todas essas classes imutáveis têm um assinatura diferente da sua classe base:"

#: ../../faq/programming.rst:1955
msgid ""
"from datetime import date\n"
"\n"
"class FirstOfMonthDate(date):\n"
"    \"Always choose the first day of the month\"\n"
"    def __new__(cls, year, month, day):\n"
"        return super().__new__(cls, year, month, 1)\n"
"\n"
"class NamedInt(int):\n"
"    \"Allow text names for some numbers\"\n"
"    xlat = {'zero': 0, 'one': 1, 'ten': 10}\n"
"    def __new__(cls, value):\n"
"        value = cls.xlat.get(value, value)\n"
"        return super().__new__(cls, value)\n"
"\n"
"class TitleStr(str):\n"
"    \"Convert str to name suitable for a URL path\"\n"
"    def __new__(cls, s):\n"
"        s = s.lower().replace(' ', '-')\n"
"        s = ''.join([c for c in s if c.isalnum() or c == '-'])\n"
"        return super().__new__(cls, s)"
msgstr ""
"from datetime import date\n"
"\n"
"class FirstOfMonthDate(date):\n"
"    \"Usa sempre o primeiro dia do mês\"\n"
"    def __new__(cls, year, month, day):\n"
"        return super().__new__(cls, year, month, 1)\n"
"\n"
"class NamedInt(int):\n"
"    \"Permite o nome em texto para alguns números\"\n"
"    xlat = {'zero': 0, 'one': 1, 'ten': 10}\n"
"    def __new__(cls, value):\n"
"        value = cls.xlat.get(value, value)\n"
"        return super().__new__(cls, value)\n"
"\n"
"class TitleStr(str):\n"
"    \"Converte string para um nome adequado para uma URL\"\n"
"    def __new__(cls, s):\n"
"        s = s.lower().replace(' ', '-')\n"
"        s = ''.join([c for c in s if c.isalnum() or c == '-'])\n"
"        return super().__new__(cls, s)"

#: ../../faq/programming.rst:1978
msgid "The classes can be used like this:"
msgstr "As classes podem ser usadas da seguinte forma:"

#: ../../faq/programming.rst:1980
msgid ""
">>> FirstOfMonthDate(2012, 2, 14)\n"
"FirstOfMonthDate(2012, 2, 1)\n"
">>> NamedInt('ten')\n"
"10\n"
">>> NamedInt(20)\n"
"20\n"
">>> TitleStr('Blog: Why Python Rocks')\n"
"'blog-why-python-rocks'"
msgstr ""
">>> FirstOfMonthDate(2012, 2, 14)\n"
"FirstOfMonthDate(2012, 2, 1)\n"
">>> NamedInt('ten')\n"
"10\n"
">>> NamedInt(20)\n"
"20\n"
">>> TitleStr('Blog: Porque Python domina')\n"
"'blog-porque-python-domina'"

#: ../../faq/programming.rst:1995
msgid "How do I cache method calls?"
msgstr "Como faço para armazenar em cache as chamadas de um método?"

#: ../../faq/programming.rst:1997
msgid ""
"The two principal tools for caching methods are :func:`functools."
"cached_property` and :func:`functools.lru_cache`.  The former stores results "
"at the instance level and the latter at the class level."
msgstr ""
"As duas principais ferramentas para armazenamento em cache de métodos são :"
"func:`functools.cached_property` e :func:`functools.lru_cache`.  A primeira "
"armazena resultados no nível de instância e a segunda no nível de classe."

#: ../../faq/programming.rst:2002
msgid ""
"The *cached_property* approach only works with methods that do not take any "
"arguments.  It does not create a reference to the instance.  The cached "
"method result will be kept only as long as the instance is alive."
msgstr ""
"A abordagem *cached_property* funciona somente com métodos que não aceitam "
"nenhum argumento.  Ela não cria uma referência para a instância. O resultado "
"do método será mantido em cache somente enquanto a instância estiver ativa."

#: ../../faq/programming.rst:2006
msgid ""
"The advantage is that when an instance is no longer used, the cached method "
"result will be released right away.  The disadvantage is that if instances "
"accumulate, so too will the accumulated method results.  They can grow "
"without bound."
msgstr ""
"A vantagem é que, quando um instância não for mais usada, o resultado do "
"método armazenado em cache será liberado imediatamente.  A desvantagem é "
"que, se as instâncias se acumularem, os resultados do método também serão "
"acumulados. Eles podem crescer sem limites."

#: ../../faq/programming.rst:2011
msgid ""
"The *lru_cache* approach works with methods that have :term:`hashable` "
"arguments.  It creates a reference to the instance unless special efforts "
"are made to pass in weak references."
msgstr ""
"A abordagem *lru_cache* funciona com métodos que têm argumento :term:"
"`hasheável`.  Ele cria uma referência para a instância, a menos que sejam "
"feitos esforços especiais para passar referências fracas."

#: ../../faq/programming.rst:2015
msgid ""
"The advantage of the least recently used algorithm is that the cache is "
"bounded by the specified *maxsize*.  The disadvantage is that instances are "
"kept alive until they age out of the cache or until the cache is cleared."
msgstr ""
"A vantagem do algoritmo menos recentemente usado é que o cache é limitado "
"pelo *maxsize* especificado.  A desvantagem é que as instâncias são mantidas "
"vivas até que saiam do cache ou até que o cache seja limpo."

#: ../../faq/programming.rst:2020
msgid "This example shows the various techniques::"
msgstr "Esse exemplo mostra as várias técnicas::"

#: ../../faq/programming.rst:2022
msgid ""
"class Weather:\n"
"    \"Lookup weather information on a government website\"\n"
"\n"
"    def __init__(self, station_id):\n"
"        self._station_id = station_id\n"
"        # The _station_id is private and immutable\n"
"\n"
"    def current_temperature(self):\n"
"        \"Latest hourly observation\"\n"
"        # Do not cache this because old results\n"
"        # can be out of date.\n"
"\n"
"    @cached_property\n"
"    def location(self):\n"
"        \"Return the longitude/latitude coordinates of the station\"\n"
"        # Result only depends on the station_id\n"
"\n"
"    @lru_cache(maxsize=20)\n"
"    def historic_rainfall(self, date, units='mm'):\n"
"        \"Rainfall on a given date\"\n"
"        # Depends on the station_id, date, and units."
msgstr ""
"class Weather:\n"
"    \"Procura informações de tempo em sites governamentais\"\n"
"\n"
"    def __init__(self, station_id):\n"
"        self._station_id = station_id\n"
"        # O _station_id é privado e imutável\n"
"\n"
"    def current_temperature(self):\n"
"        \"Última observação horária\"\n"
"        # Não armazena isso em cache porque os dados anteriores\n"
"        # podem estar desatualizados.\n"
"\n"
"    @cached_property\n"
"    def location(self):\n"
"        \"Retornas as coordenadas longitude/latitude coordinates da "
"estação\"\n"
"        # Resultado depende apenas de station_id\n"
"\n"
"    @lru_cache(maxsize=20)\n"
"    def historic_rainfall(self, date, units='mm'):\n"
"        \"Precipitação em uma determinada data\"\n"
"        # Depende de station_id, date, e units."

#: ../../faq/programming.rst:2044
msgid ""
"The above example assumes that the *station_id* never changes.  If the "
"relevant instance attributes are mutable, the *cached_property* approach "
"can't be made to work because it cannot detect changes to the attributes."
msgstr ""
"O exemplo acima assume que o *station_id* nunca muda.  Se os atribuitos "
"relevantes da instância forem mutáveis, a abordagem *cached_property* não "
"poderá usada porque não é capaz de detectar alterações no atributo."

#: ../../faq/programming.rst:2049
msgid ""
"To make the *lru_cache* approach work when the *station_id* is mutable, the "
"class needs to define the :meth:`~object.__eq__` and :meth:`~object."
"__hash__` methods so that the cache can detect relevant attribute updates::"
msgstr ""
"Para que a abordagem *lru_cache* funcione quando *station_id* for mutável, a "
"classe precisa definir os métodos :meth:`~object.__eq__` e :meth:`~object."
"__hash__` para que o cache possa detectar atualizações relevantes do "
"atributo::"

#: ../../faq/programming.rst:2053
msgid ""
"class Weather:\n"
"    \"Example with a mutable station identifier\"\n"
"\n"
"    def __init__(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def change_station(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def __eq__(self, other):\n"
"        return self.station_id == other.station_id\n"
"\n"
"    def __hash__(self):\n"
"        return hash(self.station_id)\n"
"\n"
"    @lru_cache(maxsize=20)\n"
"    def historic_rainfall(self, date, units='cm'):\n"
"        'Rainfall on a given date'\n"
"        # Depends on the station_id, date, and units."
msgstr ""
"class Weather:\n"
"    \"Examplo com um identificador de estação mutável\"\n"
"\n"
"    def __init__(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def change_station(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def __eq__(self, other):\n"
"        return self.station_id == other.station_id\n"
"\n"
"    def __hash__(self):\n"
"        return hash(self.station_id)\n"
"\n"
"    @lru_cache(maxsize=20)\n"
"    def historic_rainfall(self, date, units='cm'):\n"
"        \"Precipitação em uma determinada data\"\n"
"        # Depende de station_id, date, e units."

#: ../../faq/programming.rst:2075
msgid "Modules"
msgstr "Módulos"

#: ../../faq/programming.rst:2078
msgid "How do I create a .pyc file?"
msgstr "Como faço para criar um arquivo .pyc?"

#: ../../faq/programming.rst:2080
msgid ""
"When a module is imported for the first time (or when the source file has "
"changed since the current compiled file was created) a ``.pyc`` file "
"containing the compiled code should be created in a ``__pycache__`` "
"subdirectory of the directory containing the ``.py`` file.  The ``.pyc`` "
"file will have a filename that starts with the same name as the ``.py`` "
"file, and ends with ``.pyc``, with a middle component that depends on the "
"particular ``python`` binary that created it.  (See :pep:`3147` for details.)"
msgstr ""
"Quando um módulo é importado pela primeira vez (ou quando o arquivo de "
"origem foi alterado desde que o arquivo compilado atual foi criado), um "
"arquivo ``.pyc`` contendo o código compilado deve ser criado em um "
"subdiretório ``__pycache__`` do diretório que contém o arquivo ``.py``.  O "
"arquivo ``.pyc`` terá um nome de arquivo que começa com o mesmo nome do "
"arquivo ``.py`` e termina com ``.pyc``, com um componente intermediário que "
"depende do binário ``python`` específico que o criou.  (Consulte :pep:`3147` "
"para obter detalhes.)"

#: ../../faq/programming.rst:2088
msgid ""
"One reason that a ``.pyc`` file may not be created is a permissions problem "
"with the directory containing the source file, meaning that the "
"``__pycache__`` subdirectory cannot be created. This can happen, for "
"example, if you develop as one user but run as another, such as if you are "
"testing with a web server."
msgstr ""
"Um dos motivos pelos quais um arquivo ``.pyc`` pode não ser criado é um "
"problema de permissões no diretório que contém o arquivo de origem, o que "
"significa que o subdiretório ``__pycache__`` não pode ser criado. Isso pode "
"acontecer, por exemplo, se você desenvolver como um usuário, mas executar "
"como outro, como se estivesse testando em um servidor web."

#: ../../faq/programming.rst:2093
msgid ""
"Unless the :envvar:`PYTHONDONTWRITEBYTECODE` environment variable is set, "
"creation of a .pyc file is automatic if you're importing a module and Python "
"has the ability (permissions, free space, etc...) to create a "
"``__pycache__`` subdirectory and write the compiled module to that "
"subdirectory."
msgstr ""
"A menos que a variável de ambiente :envvar:`PYTHONDONTWRITEBYTECODE` esteja "
"definida, a criação de um arquivo .pyc será automática se você estiver "
"importando um módulo e o Python tiver a capacidade (permissões, espaço livre "
"etc.) de criar um subdiretório ``__pycache__`` e gravar o módulo compilado "
"nesse subdiretório."

#: ../../faq/programming.rst:2098
msgid ""
"Running Python on a top level script is not considered an import and no ``."
"pyc`` will be created.  For example, if you have a top-level module ``foo."
"py`` that imports another module ``xyz.py``, when you run ``foo`` (by typing "
"``python foo.py`` as a shell command), a ``.pyc`` will be created for "
"``xyz`` because ``xyz`` is imported, but no ``.pyc`` file will be created "
"for ``foo`` since ``foo.py`` isn't being imported."
msgstr ""
"A execução do Python em um script de nível superior não é considerada uma "
"importação e nenhum ``.pyc`` será criado. Por exemplo, se você tiver um "
"módulo de nível superior ``foo.py`` que importa outro módulo ``xyz.py`` , ao "
"executar ``foo`` (digitando ``python foo.py`` no console do sistema "
"operacional (SO)), um ``.pyc`` será criado para ``xyz`` porque ``xyz`` é "
"importado, mas nenhum arquivo ``.pyc`` será criado para ``foo``, pois ``foo."
"py`` não está sendo importado."

#: ../../faq/programming.rst:2105
msgid ""
"If you need to create a ``.pyc`` file for ``foo`` -- that is, to create a ``."
"pyc`` file for a module that is not imported -- you can, using the :mod:"
"`py_compile` and :mod:`compileall` modules."
msgstr ""
"Se você precisar criar um arquivo ``.pyc`` para ``foo``, ou seja, criar um "
"arquivo ``.pyc`` para um módulo que não é importado, você pode usar os "
"módulos :mod:`py_compile` e :mod:`compileall`."

#: ../../faq/programming.rst:2109
msgid ""
"The :mod:`py_compile` module can manually compile any module.  One way is to "
"use the ``compile()`` function in that module interactively::"
msgstr ""
"O módulo :mod:`py_compile` pode compilar manualmente qualquer módulo.  Uma "
"maneira é usar interativamente a função ``compile()`` nesse módulo::"

#: ../../faq/programming.rst:2112
msgid ""
">>> import py_compile\n"
">>> py_compile.compile('foo.py')"
msgstr ""
">>> import py_compile\n"
">>> py_compile.compile('foo.py')"

#: ../../faq/programming.rst:2115
msgid ""
"This will write the ``.pyc`` to a ``__pycache__`` subdirectory in the same "
"location as ``foo.py`` (or you can override that with the optional parameter "
"``cfile``)."
msgstr ""
"Isso gravará o ``.pyc`` em um subdiretório ``__pycache__`` no mesmo local "
"que ``foo.py`` (ou você pode substituir isso com o parâmetro opcional "
"``cfile`` )."

#: ../../faq/programming.rst:2119
msgid ""
"You can also automatically compile all files in a directory or directories "
"using the :mod:`compileall` module.  You can do it from the shell prompt by "
"running ``compileall.py`` and providing the path of a directory containing "
"Python files to compile::"
msgstr ""
"Você também pode compilar automaticamente todos os arquivos em um diretório "
"ou diretórios usando o módulo :mod:`compileall`.  Você pode fazer isso no "
"console do SO executando ``compileall.py`` e fornecendo o caminho de um "
"diretório que contenha os arquivos Python a serem compilados::"

#: ../../faq/programming.rst:2124
msgid "python -m compileall ."
msgstr "python -m compileall ."

#: ../../faq/programming.rst:2128
msgid "How do I find the current module name?"
msgstr "Como encontro o nome do módulo atual?"

#: ../../faq/programming.rst:2130
msgid ""
"A module can find out its own module name by looking at the predefined "
"global variable ``__name__``.  If this has the value ``'__main__'``, the "
"program is running as a script.  Many modules that are usually used by "
"importing them also provide a command-line interface or a self-test, and "
"only execute this code after checking ``__name__``::"
msgstr ""
"Um módulo pode descobrir seu próprio nome consultando a variável global "
"predefinida ``__name__`` .  Se ela tiver o valor ``'__main__'`` , o programa "
"estará sendo executado como um script.  Muitos módulos que são normalmente "
"usados ao serem importados também fornecem uma interface de linha de comando "
"ou um autoteste, e só executam esse código depois de verificar ``__name__``::"

#: ../../faq/programming.rst:2136
msgid ""
"def main():\n"
"    print('Running test...')\n"
"    ...\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"def main():\n"
"    print('Executando teste...')\n"
"    ...\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../faq/programming.rst:2145
msgid "How can I have modules that mutually import each other?"
msgstr "Como posso ter módulos que se importam mutuamente?"

#: ../../faq/programming.rst:2147
msgid "Suppose you have the following modules:"
msgstr "Suponha que tenhas os seguintes módulos:"

#: ../../faq/programming.rst:2149
msgid ":file:`foo.py`::"
msgstr ":file:`foo.py`::"

#: ../../faq/programming.rst:2151
msgid ""
"from bar import bar_var\n"
"foo_var = 1"
msgstr ""
"from bar importar bar_var\n"
"foo_var = 1"

#: ../../faq/programming.rst:2154
msgid ":file:`bar.py`::"
msgstr ":file:`bar.py`::"

#: ../../faq/programming.rst:2156
msgid ""
"from foo import foo_var\n"
"bar_var = 2"
msgstr ""
"from foo import foo_var\n"
"bar_var = 2"

#: ../../faq/programming.rst:2159
msgid "The problem is that the interpreter will perform the following steps:"
msgstr "O problema é que o interpretador vai realizar os seguintes passos:"

#: ../../faq/programming.rst:2161
msgid "main imports ``foo``"
msgstr "Programa principal importa ``foo``"

#: ../../faq/programming.rst:2162
msgid "Empty globals for ``foo`` are created"
msgstr "São criados globais vazios para ``foo``"

#: ../../faq/programming.rst:2163
msgid "``foo`` is compiled and starts executing"
msgstr "``foo`` é compilado e começa a ser executado"

#: ../../faq/programming.rst:2164
msgid "``foo`` imports ``bar``"
msgstr "``foo`` importa ``bar``"

#: ../../faq/programming.rst:2165
msgid "Empty globals for ``bar`` are created"
msgstr "São criados globais vazios para ``bar``"

#: ../../faq/programming.rst:2166
msgid "``bar`` is compiled and starts executing"
msgstr "``bar`` é compilado e começa a ser executado"

#: ../../faq/programming.rst:2167
msgid ""
"``bar`` imports ``foo`` (which is a no-op since there already is a module "
"named ``foo``)"
msgstr ""
"``bar`` importa ``foo`` (o que não é executado de fato, pois já existe um "
"módulo chamado ``foo``)"

#: ../../faq/programming.rst:2168
msgid ""
"The import mechanism tries to read ``foo_var`` from ``foo`` globals, to set "
"``bar.foo_var = foo.foo_var``"
msgstr ""
"O mecanismo de importação tenta ler ``foo_var`` do ``foo`` em globais, para "
"definir ``bar.foo_var = foo.foo_var``"

#: ../../faq/programming.rst:2170
msgid ""
"The last step fails, because Python isn't done with interpreting ``foo`` yet "
"and the global symbol dictionary for ``foo`` is still empty."
msgstr ""
"A última etapa falha, pois Python ainda não terminou de interpretar ``foo`` "
"e o dicionário de símbolos global para ``foo`` ainda está vazio."

#: ../../faq/programming.rst:2173
msgid ""
"The same thing happens when you use ``import foo``, and then try to access "
"``foo.foo_var`` in global code."
msgstr ""
"O mesmo acontece quando você usa ``import foo`` e, em seguida, tenta acessar "
"``foo.foo_var`` no código global."

#: ../../faq/programming.rst:2176
msgid "There are (at least) three possible workarounds for this problem."
msgstr ""
"Há (pelo menos) três possíveis soluções alternativas para esse problema."

#: ../../faq/programming.rst:2178
msgid ""
"Guido van Rossum recommends avoiding all uses of ``from <module> import ..."
"``, and placing all code inside functions.  Initializations of global "
"variables and class variables should use constants or built-in functions "
"only.  This means everything from an imported module is referenced as "
"``<module>.<name>``."
msgstr ""
"Guido van Rossum recomenda evitar todos os usos de ``from <module> import ..."
"`` e colocar todo o código dentro de funções.  As inicializações de "
"variáveis globais e variáveis de classe devem usar apenas constantes ou "
"funções embutidas.  Isso significa que tudo de um módulo importado é "
"referenciado como ``<module>.<name>``."

#: ../../faq/programming.rst:2183
msgid ""
"Jim Roskind suggests performing steps in the following order in each module:"
msgstr ""
"Jim Roskind sugere a execução das etapas na seguinte ordem em cada módulo:"

#: ../../faq/programming.rst:2185
msgid ""
"exports (globals, functions, and classes that don't need imported base "
"classes)"
msgstr ""
"exportações (globais, função e classes que não precisam de classes base "
"importadas)"

#: ../../faq/programming.rst:2187
msgid "``import`` statements"
msgstr "instruções ``import``"

#: ../../faq/programming.rst:2188
msgid ""
"active code (including globals that are initialized from imported values)."
msgstr ""
"código ativo (incluindo globais que são inicializadas de valores importados)"

#: ../../faq/programming.rst:2190
msgid ""
"Van Rossum doesn't like this approach much because the imports appear in a "
"strange place, but it does work."
msgstr ""
"Van Rossum não gosta muito dessa abordagem porque a importação aparece em um "
"lugar estranho, mas ela funciona."

#: ../../faq/programming.rst:2193
msgid ""
"Matthias Urlichs recommends restructuring your code so that the recursive "
"import is not necessary in the first place."
msgstr ""
"Matthias Urlichs recomenda reestruturar seu código para que importação "
"recursiva não seja necessária em primeiro lugar."

#: ../../faq/programming.rst:2196
msgid "These solutions are not mutually exclusive."
msgstr "Essas soluções não são mutuamente exclusivas."

#: ../../faq/programming.rst:2200
msgid "__import__('x.y.z') returns <module 'x'>; how do I get z?"
msgstr "__import__('x.y.z') retorna <módulo 'x'>; como faço para obter z?"

#: ../../faq/programming.rst:2202
msgid ""
"Consider using the convenience function :func:`~importlib.import_module` "
"from :mod:`importlib` instead::"
msgstr ""
"Em vez disso, considere usar a conveniente função :func:`~importlib."
"import_module` de :mod:`importlib`::"

#: ../../faq/programming.rst:2205
msgid "z = importlib.import_module('x.y.z')"
msgstr "z = importlib.import_module('x.y.z')"

#: ../../faq/programming.rst:2209
msgid ""
"When I edit an imported module and reimport it, the changes don't show up.  "
"Why does this happen?"
msgstr ""
"Quando eu edito um módulo importado e o reimporto, as mudanças não aparecem. "
"Por que isso acontece?"

#: ../../faq/programming.rst:2211
msgid ""
"For reasons of efficiency as well as consistency, Python only reads the "
"module file on the first time a module is imported.  If it didn't, in a "
"program consisting of many modules where each one imports the same basic "
"module, the basic module would be parsed and re-parsed many times.  To force "
"re-reading of a changed module, do this::"
msgstr ""
"Por motivos de eficiência e consistência, o Python só lê o arquivo do módulo "
"na primeira vez em que um módulo é importado.  Caso contrário, em um "
"programa que consiste em muitos módulos em que cada um importa o mesmo "
"módulo básico, o módulo básico seria analisado e reanalisado várias vezes.  "
"Para forçar a releitura de um módulo alterado, faça o seguinte::"

#: ../../faq/programming.rst:2217
msgid ""
"import importlib\n"
"import modname\n"
"importlib.reload(modname)"
msgstr ""
"import importlib\n"
"import modname\n"
"importlib.reload(modname)"

#: ../../faq/programming.rst:2221
msgid ""
"Warning: this technique is not 100% fool-proof.  In particular, modules "
"containing statements like ::"
msgstr ""
"Aviso: essa técnica não é 100% à prova de falhas. Em particular, módulos "
"contendo instruções como ::"

#: ../../faq/programming.rst:2224
msgid "from modname import some_objects"
msgstr "from modname import some_objects"

#: ../../faq/programming.rst:2226
msgid ""
"will continue to work with the old version of the imported objects.  If the "
"module contains class definitions, existing class instances will *not* be "
"updated to use the new class definition.  This can result in the following "
"paradoxical behaviour::"
msgstr ""
"continuará com a versão antiga dos objetos importados.  Se o módulo contiver "
"definições de classe, as instâncias de classe existentes *não* serão "
"atualizadas para usar a nova definição da classe.  Isso pode resultar no "
"seguinte comportamento paradoxal::"

#: ../../faq/programming.rst:2231
msgid ""
">>> import importlib\n"
">>> import cls\n"
">>> c = cls.C()                # Create an instance of C\n"
">>> importlib.reload(cls)\n"
"<module 'cls' from 'cls.py'>\n"
">>> isinstance(c, cls.C)       # isinstance is false?!?\n"
"False"
msgstr ""
">>> import importlib\n"
">>> import cls\n"
">>> c = cls.C()                # Cria uma instância de C\n"
">>> importlib.reload(cls)\n"
"<module 'cls' from 'cls.py'>\n"
">>> isinstance(c, cls.C)       # isinstance é falso?!?\n"
"False"

#: ../../faq/programming.rst:2239
msgid ""
"The nature of the problem is made clear if you print out the \"identity\" of "
"the class objects::"
msgstr ""
"A natureza do problema fica clara se você exibir a \"identidade\" dos "
"objetos da classe::"

#: ../../faq/programming.rst:2242
msgid ""
">>> hex(id(c.__class__))\n"
"'0x7352a0'\n"
">>> hex(id(cls.C))\n"
"'0x4198d0'"
msgstr ""
">>> hex(id(c.__class__))\n"
"'0x7352a0'\n"
">>> hex(id(cls.C))\n"
"'0x4198d0'"

#: ../../faq/programming.rst:408
msgid "argument"
msgstr "argumento"

#: ../../faq/programming.rst:408
msgid "difference from parameter"
msgstr "diferença de parâmetro"

#: ../../faq/programming.rst:408
msgid "parameter"
msgstr "parâmetro"

#: ../../faq/programming.rst:408
msgid "difference from argument"
msgstr "diferença de argumento"

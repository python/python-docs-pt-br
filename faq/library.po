# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Hildeberto Abreu Magalhães <hildeberto@gmail.com>, 2021
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2021
# Adson Rodrigues <adson.develop@gmail.com>, 2021
# Alexandre B A Villares, 2021
# Mariana Costa <mrncstt@gmail.com>, 2021
# a76d6fb6142d7607ab0526dcbddb02d7_7bf0da0 <3b5fb0f281c8dfb4c0170f2ee2a6cfcf_843623>, 2021
# Adorilson Bezerra <adorilson@gmail.com>, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-08 02:53-0300\n"
"PO-Revision-Date: 2021-06-28 00:52+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../faq/library.rst:5
msgid "Library and Extension FAQ"
msgstr "FAQ de Bibliotecas e Extensões"

#: ../../faq/library.rst:8
msgid "Contents"
msgstr "Conteúdo"

#: ../../faq/library.rst:12
msgid "General Library Questions"
msgstr "Questões gerais sobre bibliotecas"

#: ../../faq/library.rst:15
msgid "How do I find a module or application to perform task X?"
msgstr "Como encontrar um módulo ou aplicação para realizar uma tarefa X?"

#: ../../faq/library.rst:17
msgid ""
"Check :ref:`the Library Reference <library-index>` to see if there's a "
"relevant standard library module.  (Eventually you'll learn what's in the "
"standard library and will be able to skip this step.)"
msgstr ""
"Verifique :ref:`a Referência de Bibliotecas <library-index>` para ver se há "
"um módulo relevante da biblioteca padrão. (Eventualmente, você aprenderá o "
"que está na biblioteca padrão e poderá pular esta etapa.)"

#: ../../faq/library.rst:21
msgid ""
"For third-party packages, search the `Python Package Index <https://pypi."
"org>`_ or try `Google <https://www.google.com>`_ or another web search "
"engine.  Searching for \"Python\" plus a keyword or two for your topic of "
"interest will usually find something helpful."
msgstr ""
"Para pacotes de terceiros, pesquise no `Python Package Index <https://pypi."
"org>`_ ou tente no `Google <https://www.google.com>`_ ou outro buscador na "
"web. Pesquisando por \"Python\" mais uma ou dois argumentos nomeados do seu "
"tópico de interesse geralmente encontrará algo útil."

#: ../../faq/library.rst:28
msgid "Where is the math.py (socket.py, regex.py, etc.) source file?"
msgstr "Onde está o código-fonte do math.py (socket.py, regex.py, etc.)?"

#: ../../faq/library.rst:30
msgid ""
"If you can't find a source file for a module it may be a built-in or "
"dynamically loaded module implemented in C, C++ or other compiled language. "
"In this case you may not have the source file or it may be something like :"
"file:`mathmodule.c`, somewhere in a C source directory (not on the Python "
"Path)."
msgstr ""
"Se você não conseguir encontrar um arquivo de origem para um módulo, ele "
"pode ser um módulo embutido ou carregado dinamicamente, implementado em C, C+"
"+ ou outra linguagem compilada. Nesse caso, você pode não ter o arquivo de "
"origem ou pode ser algo como :file:`mathmodule.c`, em algum lugar do "
"diretório de origem C (não no caminho do Python)."

#: ../../faq/library.rst:35
msgid "There are (at least) three kinds of modules in Python:"
msgstr "Existem (pelo menos) três tipos de módulos no Python:"

#: ../../faq/library.rst:37
msgid "modules written in Python (.py);"
msgstr "módulos escritos em Python (.py)"

#: ../../faq/library.rst:38
msgid ""
"modules written in C and dynamically loaded (.dll, .pyd, .so, .sl, etc);"
msgstr ""
"módulos escritos em C e carregados dinamicamente (.dll, .pyd, .so, .sl, "
"etc.);"

#: ../../faq/library.rst:39
msgid ""
"modules written in C and linked with the interpreter; to get a list of "
"these, type::"
msgstr ""
"módulos escritos em C e vinculados ao interpretador; para obter uma dessas "
"listas, digite::"

#: ../../faq/library.rst:42
msgid ""
"import sys\n"
"print(sys.builtin_module_names)"
msgstr ""
"import sys\n"
"print(sys.builtin_module_names)"

#: ../../faq/library.rst:47
msgid "How do I make a Python script executable on Unix?"
msgstr "Como tornar um script Python executável no Unix?"

#: ../../faq/library.rst:49
msgid ""
"You need to do two things: the script file's mode must be executable and the "
"first line must begin with ``#!`` followed by the path of the Python "
"interpreter."
msgstr ""
"Você precisa fazer duas coisas: o arquivo do script deve ser executável e a "
"primeira linha deve começar com ``#!`` seguido do caminho do interpretador "
"Python."

#: ../../faq/library.rst:53
msgid ""
"The first is done by executing ``chmod +x scriptfile`` or perhaps ``chmod "
"755 scriptfile``."
msgstr ""
"Inicialmente, execute o ``chmod +x scriptfile`` ou, talvez, o ``chmod 755 "
"scriptfile``."

#: ../../faq/library.rst:56
msgid ""
"The second can be done in a number of ways.  The most straightforward way is "
"to write ::"
msgstr ""
"A segunda coisa pode ser feita de várias maneiras. A maneira mais direta é "
"escrever ::"

#: ../../faq/library.rst:59
msgid "#!/usr/local/bin/python"
msgstr "#!/usr/local/bin/python"

#: ../../faq/library.rst:61
msgid ""
"as the very first line of your file, using the pathname for where the Python "
"interpreter is installed on your platform."
msgstr ""
"como a primeira linha do seu arquivo, usando o endereço do caminho onde o "
"interpretador Python está instalado."

#: ../../faq/library.rst:64
msgid ""
"If you would like the script to be independent of where the Python "
"interpreter lives, you can use the :program:`env` program.  Almost all Unix "
"variants support the following, assuming the Python interpreter is in a "
"directory on the user's :envvar:`PATH`::"
msgstr ""
"Se você deseja que o script seja independente de onde o interpretador Python "
"mora, você pode usar o programa :program:`env`. Quase todas as variantes do "
"Unix suportam o seguinte, presumindo que o interpretador Python esteja em um "
"diretório no :envvar:`PATH` do usuário::"

#: ../../faq/library.rst:69
msgid "#!/usr/bin/env python"
msgstr "#!/usr/bin/env python"

#: ../../faq/library.rst:71
msgid ""
"*Don't* do this for CGI scripts.  The :envvar:`PATH` variable for CGI "
"scripts is often very minimal, so you need to use the actual absolute "
"pathname of the interpreter."
msgstr ""
"Não faça isso para CGI scripts. A variável :envvar:`PATH` para CGI scripts é "
"normalmente muito pequena, portanto, você precisa usar o caminho completo do "
"interpretador."

#: ../../faq/library.rst:75
msgid ""
"Occasionally, a user's environment is so full that the :program:`/usr/bin/"
"env` program fails; or there's no env program at all.  In that case, you can "
"try the following hack (due to Alex Rezinsky):"
msgstr ""
"Ocasionalmente, o ambiente de um usuário está tão cheio que o programa :"
"program:`/usr/bin/env` falha; ou não há nenhum programa env. Nesse caso, "
"você pode tentar o seguinte hack (graças a Alex Rezinsky):"

#: ../../faq/library.rst:79
msgid ""
"#! /bin/sh\n"
"\"\"\":\"\n"
"exec python $0 ${1+\"$@\"}\n"
"\"\"\""
msgstr ""
"#! /bin/sh\n"
"\"\"\":\"\n"
"exec python $0 ${1+\"$@\"}\n"
"\"\"\""

#: ../../faq/library.rst:86
msgid ""
"The minor disadvantage is that this defines the script's __doc__ string. "
"However, you can fix that by adding ::"
msgstr ""
"Uma pequena desvantagem é que isso define o script's __doc__ string. "
"Entretanto, você pode corrigir isso adicionando ::"

#: ../../faq/library.rst:89
msgid "__doc__ = \"\"\"...Whatever...\"\"\""
msgstr "__doc__ = \"\"\"...Alguma coisa...\"\"\""

#: ../../faq/library.rst:94
msgid "Is there a curses/termcap package for Python?"
msgstr "Existe um pacote de curses/termcap para Python?"

#: ../../faq/library.rst:98
msgid ""
"For Unix variants: The standard Python source distribution comes with a "
"curses module in the :source:`Modules` subdirectory, though it's not "
"compiled by default. (Note that this is not available in the Windows "
"distribution -- there is no curses module for Windows.)"
msgstr ""
"Para variantes Unix: A distribuição fonte padrão do Python vem com um módulo "
"do curses no subdiretório :source:`Modules`, embora não seja compilado por "
"padrão.  (Observe que isso não está disponível na distribuição do Windows -- "
"não há módulo curses para o Windows.)"

#: ../../faq/library.rst:103
msgid ""
"The :mod:`curses` module supports basic curses features as well as many "
"additional functions from ncurses and SYSV curses such as colour, "
"alternative character set support, pads, and mouse support. This means the "
"module isn't compatible with operating systems that only have BSD curses, "
"but there don't seem to be any currently maintained OSes that fall into this "
"category."
msgstr ""
"O módulo :mod:`curses` provê recursos básicos de curses, bem como muitas "
"funções adicionais de ncurses e curses SYSV, como cor, suporte a conjuntos "
"de caracteres alternativos, pads e suporte a mouse. Isso significa que o "
"módulo não é compatível com sistemas operacionais que possuem apenas "
"maldições BSD, mas não parece haver nenhum sistema operacional mantido "
"atualmente que se enquadre nesta categoria."

#: ../../faq/library.rst:111
msgid "Is there an equivalent to C's onexit() in Python?"
msgstr "Existe a função onexit() equivalente ao C no Python?"

#: ../../faq/library.rst:113
msgid ""
"The :mod:`atexit` module provides a register function that is similar to "
"C's :c:func:`!onexit`."
msgstr ""
"O módulo :mod:`atexit` fornece uma função de registro similar ao :c:func:`!"
"onexit` do C."

#: ../../faq/library.rst:118
msgid "Why don't my signal handlers work?"
msgstr "Por que o meu manipulador de sinal não funciona?"

#: ../../faq/library.rst:120
msgid ""
"The most common problem is that the signal handler is declared with the "
"wrong argument list.  It is called as ::"
msgstr ""
"O maior problema é que o manipulador de sinal é declarado com uma lista de "
"argumentos incorretos. Isso é chamado como ::"

#: ../../faq/library.rst:123
msgid "handler(signum, frame)"
msgstr "manipulador(num_sinal, quadro)"

#: ../../faq/library.rst:125
msgid "so it should be declared with two parameters::"
msgstr "portanto, isso deve ser declarado com dois parâmetros::"

#: ../../faq/library.rst:127
msgid ""
"def handler(signum, frame):\n"
"    ..."
msgstr ""
"def manipulador(num_sinal, quadro):\n"
"    ..."

#: ../../faq/library.rst:132
msgid "Common tasks"
msgstr "Tarefas comuns"

#: ../../faq/library.rst:135
msgid "How do I test a Python program or component?"
msgstr "Como testar um programa ou componente Python?"

#: ../../faq/library.rst:137
msgid ""
"Python comes with two testing frameworks.  The :mod:`doctest` module finds "
"examples in the docstrings for a module and runs them, comparing the output "
"with the expected output given in the docstring."
msgstr ""
"A Python vem com dois frameworks de teste. O módulo :mod:`doctest` busca por "
"exemplos nas docstrings de um módulo e os executa, comparando o resultado "
"com a saída esperada informada na docstring."

#: ../../faq/library.rst:141
msgid ""
"The :mod:`unittest` module is a fancier testing framework modelled on Java "
"and Smalltalk testing frameworks."
msgstr ""
"O módulo :mod:`unittest` é uma estrutura de teste mais sofisticada, modelada "
"nas estruturas de teste do Java e do Smalltalk."

#: ../../faq/library.rst:144
msgid ""
"To make testing easier, you should use good modular design in your program. "
"Your program should have almost all functionality encapsulated in either "
"functions or class methods -- and this sometimes has the surprising and "
"delightful effect of making the program run faster (because local variable "
"accesses are faster than global accesses).  Furthermore the program should "
"avoid depending on mutating global variables, since this makes testing much "
"more difficult to do."
msgstr ""
"Para facilitar os testes, você deve usar um bom design modular em seu "
"programa. Seu programa deve ter quase todas as funcionalidades encapsuladas "
"em funções ou métodos de classe -- e isso às vezes tem o efeito "
"surpreendente e agradável de fazer o programa executar mais rápido (porque "
"os acessos às variáveis locais são mais rápidos que os acessos globais). "
"Além disso, o programa deve evitar depender de variáveis globais mutantes, "
"pois isso torna os testes muito mais difíceis de serem realizados."

#: ../../faq/library.rst:152
msgid "The \"global main logic\" of your program may be as simple as ::"
msgstr "A lógica principal do seu programa pode tão simples quanto ::"

#: ../../faq/library.rst:154
msgid ""
"if __name__ == \"__main__\":\n"
"    main_logic()"
msgstr ""
"if __name__ == \"__main__\":\n"
"    main_logic()"

#: ../../faq/library.rst:157
msgid "at the bottom of the main module of your program."
msgstr "no botão do módulo principal do seus programa."

#: ../../faq/library.rst:159
msgid ""
"Once your program is organized as a tractable collection of function and "
"class behaviours, you should write test functions that exercise the "
"behaviours.  A test suite that automates a sequence of tests can be "
"associated with each module. This sounds like a lot of work, but since "
"Python is so terse and flexible it's surprisingly easy.  You can make coding "
"much more pleasant and fun by writing your test functions in parallel with "
"the \"production code\", since this makes it easy to find bugs and even "
"design flaws earlier."
msgstr ""
"Depois que seu programa estiver organizado como uma coleção tratável de "
"comportamentos de funções e classes, você deverá escrever funções de teste "
"que exercitem os comportamentos. Um conjunto de testes que automatiza uma "
"sequência de testes pode ser associado a cada módulo. Parece muito "
"trabalhoso, mas como o Python é tão conciso e flexível, é surpreendentemente "
"fácil. Você pode tornar a codificação muito mais agradável e divertida "
"escrevendo suas funções de teste em paralelo com o \"código de produção\", "
"pois isso torna mais fácil encontrar bugs e até mesmo falhas de design mais "
"cedo."

#: ../../faq/library.rst:167
msgid ""
"\"Support modules\" that are not intended to be the main module of a program "
"may include a self-test of the module. ::"
msgstr ""
"Os \"módulos de suporte\" que não se destinam a ser o módulo principal de um "
"programa podem incluir um autoteste do módulo. ::"

#: ../../faq/library.rst:170
msgid ""
"if __name__ == \"__main__\":\n"
"    self_test()"
msgstr ""
"if __name__ == \"__main__\":\n"
"    self_test()"

#: ../../faq/library.rst:173
msgid ""
"Even programs that interact with complex external interfaces may be tested "
"when the external interfaces are unavailable by using \"fake\" interfaces "
"implemented in Python."
msgstr ""
"Mesmo quando as interfaces externas não estiverem disponíveis, os programas "
"que interagem com interfaces externas complexas podem ser testados usando as "
"interfaces \"falsas\" implementadas no Python."

#: ../../faq/library.rst:179
msgid "How do I create documentation from doc strings?"
msgstr "Como faço para criar uma documentação de doc strings?"

#: ../../faq/library.rst:181
msgid ""
"The :mod:`pydoc` module can create HTML from the doc strings in your Python "
"source code.  An alternative for creating API documentation purely from "
"docstrings is `epydoc <https://epydoc.sourceforge.net/>`_.  `Sphinx <https://"
"www.sphinx-doc.org>`_ can also include docstring content."
msgstr ""
"O módulo :mod:`pydoc` pode criar HTML a partir das strings de documentos em "
"seu código-fonte Python. Uma alternativa para criar documentação de API "
"puramente a partir de docstrings é `epydoc <https://epydoc.sourceforge.net/"
">`_. `Sphinx <https://www.sphinx-doc.org>`_ também pode incluir conteúdo "
"docstring."

#: ../../faq/library.rst:188
msgid "How do I get a single keypress at a time?"
msgstr "Como faço para pressionar uma tecla de cada vez?"

#: ../../faq/library.rst:190
msgid ""
"For Unix variants there are several solutions.  It's straightforward to do "
"this using curses, but curses is a fairly large module to learn."
msgstr ""
"Para variantes do Unix existem várias soluções. Apesar de ser um módulo "
"grande para aprender, é simples fazer isso usando o módulo curses."

#: ../../faq/library.rst:234
msgid "Threads"
msgstr "Threads"

#: ../../faq/library.rst:237
msgid "How do I program using threads?"
msgstr "Como faço para programar usando threads?"

#: ../../faq/library.rst:239
msgid ""
"Be sure to use the :mod:`threading` module and not the :mod:`_thread` "
"module. The :mod:`threading` module builds convenient abstractions on top of "
"the low-level primitives provided by the :mod:`_thread` module."
msgstr ""
"Certifique-se de usar o módulo :mod:`threading` e não o módulo :mod:"
"`_thread`. O módulo :mod:`threading` constrói abstrações convenientes sobre "
"as primitivas de baixo nível fornecidas pelo módulo :mod:`_thread`."

#: ../../faq/library.rst:245
msgid "None of my threads seem to run: why?"
msgstr "Nenhuma de minhas threads parece funcionar, por que?"

#: ../../faq/library.rst:247
msgid ""
"As soon as the main thread exits, all threads are killed.  Your main thread "
"is running too quickly, giving the threads no time to do any work."
msgstr ""
"Assim que a thread principal acaba, todas as threads são eliminadas. Sua "
"thread principal está sendo executada tão rápida que não está dando tempo "
"para realizar qualquer trabalho."

#: ../../faq/library.rst:250
msgid ""
"A simple fix is to add a sleep to the end of the program that's long enough "
"for all the threads to finish::"
msgstr ""
"Uma solução simples é adicionar um tempo de espera no final do programa até "
"que todos os threads sejam concluídos::"

#: ../../faq/library.rst:253
msgid ""
"import threading, time\n"
"\n"
"def thread_task(name, n):\n"
"    for i in range(n):\n"
"        print(name, i)\n"
"\n"
"for i in range(10):\n"
"    T = threading.Thread(target=thread_task, args=(str(i), i))\n"
"    T.start()\n"
"\n"
"time.sleep(10)  # <---------------------------!"
msgstr ""
"import threading, time\n"
"\n"
"def thread_task(name, n):\n"
"    for i in range(n):\n"
"        print(name, i)\n"
"\n"
"for i in range(10):\n"
"    T = threading.Thread(target=thread_task, args=(str(i), i))\n"
"    T.start()\n"
"\n"
"time.sleep(10)  # <---------------------------!"

#: ../../faq/library.rst:265
msgid ""
"But now (on many platforms) the threads don't run in parallel, but appear to "
"run sequentially, one at a time!  The reason is that the OS thread scheduler "
"doesn't start a new thread until the previous thread is blocked."
msgstr ""
"Mas agora (em muitas plataformas) as threads não funcionam em paralelo, mas "
"parecem funcionar sequencialmente, um de cada vez! O motivo é que o "
"agendador de threads do sistema operacional não inicia uma nova thread até "
"que a thread anterior seja bloqueada."

#: ../../faq/library.rst:269
msgid "A simple fix is to add a tiny sleep to the start of the run function::"
msgstr ""
"Uma solução simples é adicionar um pequeno tempo de espera no início da "
"função::"

#: ../../faq/library.rst:271
msgid ""
"def thread_task(name, n):\n"
"    time.sleep(0.001)  # <--------------------!\n"
"    for i in range(n):\n"
"        print(name, i)\n"
"\n"
"for i in range(10):\n"
"    T = threading.Thread(target=thread_task, args=(str(i), i))\n"
"    T.start()\n"
"\n"
"time.sleep(10)"
msgstr ""
"def thread_task(name, n):\n"
"    time.sleep(0.001)  # <--------------------!\n"
"    for i in range(n):\n"
"        print(name, i)\n"
"\n"
"for i in range(10):\n"
"    T = threading.Thread(target=thread_task, args=(str(i), i))\n"
"    T.start()\n"
"\n"
"time.sleep(10)"

#: ../../faq/library.rst:282
msgid ""
"Instead of trying to guess a good delay value for :func:`time.sleep`, it's "
"better to use some kind of semaphore mechanism.  One idea is to use the :mod:"
"`queue` module to create a queue object, let each thread append a token to "
"the queue when it finishes, and let the main thread read as many tokens from "
"the queue as there are threads."
msgstr ""
"Em vez de tentar adivinhar um bom valor de atraso para :func:`time.sleep`, é "
"melhor usar algum tipo de mecanismo de semáforo. Uma ideia é usar o módulo :"
"mod:`queue` para criar um objeto fila, deixar cada thread anexar um token à "
"fila quando terminar e deixar a thread principal ler tantos tokens da fila "
"quantos threads houver."

#: ../../faq/library.rst:290
msgid "How do I parcel out work among a bunch of worker threads?"
msgstr "Como distribuo o trabalho entre várias threads de trabalho?"

#: ../../faq/library.rst:292
msgid ""
"The easiest way is to use the :mod:`concurrent.futures` module, especially "
"the :mod:`~concurrent.futures.ThreadPoolExecutor` class."
msgstr ""
"A maneira mais fácil é usar o módulo :mod:`concurrent.futures`, "
"especialmente a classe :mod:`~concurrent.futures.ThreadPoolExecutor`."

#: ../../faq/library.rst:295
msgid ""
"Or, if you want fine control over the dispatching algorithm, you can write "
"your own logic manually.  Use the :mod:`queue` module to create a queue "
"containing a list of jobs.  The :class:`~queue.Queue` class maintains a list "
"of objects and has a ``.put(obj)`` method that adds items to the queue and a "
"``.get()`` method to return them.  The class will take care of the locking "
"necessary to ensure that each job is handed out exactly once."
msgstr ""
"Ou, se quiser um controle preciso sobre o algoritmo de despacho, você pode "
"escrever sua própria lógica manualmente. Use o módulo :mod:`queue` para "
"criar uma fila contendo uma lista de tarefas. A classe :class:`~queue.Queue` "
"mantém uma lista de objetos e possui um método ``.put(obj)`` que adiciona "
"itens à fila e um método ``.get()`` para retorná-los. A classe cuidará da "
"trava necessário para garantir que cada trabalho seja entregue exatamente "
"uma vez."

#: ../../faq/library.rst:302
msgid "Here's a trivial example::"
msgstr "Aqui está um exemplo simples::"

#: ../../faq/library.rst:304
msgid ""
"import threading, queue, time\n"
"\n"
"# The worker thread gets jobs off the queue.  When the queue is empty, it\n"
"# assumes there will be no more work and exits.\n"
"# (Realistically workers will run until terminated.)\n"
"def worker():\n"
"    print('Running worker')\n"
"    time.sleep(0.1)\n"
"    while True:\n"
"        try:\n"
"            arg = q.get(block=False)\n"
"        except queue.Empty:\n"
"            print('Worker', threading.current_thread(), end=' ')\n"
"            print('queue empty')\n"
"            break\n"
"        else:\n"
"            print('Worker', threading.current_thread(), end=' ')\n"
"            print('running with argument', arg)\n"
"            time.sleep(0.5)\n"
"\n"
"# Create queue\n"
"q = queue.Queue()\n"
"\n"
"# Start a pool of 5 workers\n"
"for i in range(5):\n"
"    t = threading.Thread(target=worker, name='worker %i' % (i+1))\n"
"    t.start()\n"
"\n"
"# Begin adding work to the queue\n"
"for i in range(50):\n"
"    q.put(i)\n"
"\n"
"# Give threads time to run\n"
"print('Main thread sleeping')\n"
"time.sleep(5)"
msgstr ""
"import threading, queue, time\n"
"\n"
"# A thread do worker obtém a tarefa da fila. Quando a fila está vazia,\n"
"# ela presume que não haverá mais tarefas e encerra.\n"
"# (Realisticamente, workers trabalharão até serem encerrados.)\n"
"def worker():\n"
"    print('Running worker')\n"
"    time.sleep(0.1)\n"
"    while True:\n"
"        try:\n"
"            arg = q.get(block=False)\n"
"        except queue.Empty:\n"
"            print('Worker', threading.current_thread(), end=' ')\n"
"            print('queue empty')\n"
"            break\n"
"        else:\n"
"            print('Worker', threading.current_thread(), end=' ')\n"
"            print('running with argument', arg)\n"
"            time.sleep(0.5)\n"
"\n"
"# Cria a fila\n"
"q = queue.Queue()\n"
"\n"
"# Inicia um pool de 5 workers\n"
"for i in range(5):\n"
"    t = threading.Thread(target=worker, name='worker %i' % (i+1))\n"
"    t.start()\n"
"\n"
"# Começa a adicionar tarefa à fila\n"
"for i in range(50):\n"
"    q.put(i)\n"
"\n"
"# Dá às threads tempo para executar\n"
"print('Main thread sleeping')\n"
"time.sleep(5)"

#: ../../faq/library.rst:340
msgid "When run, this will produce the following output:"
msgstr "Quando executado, isso produzirá a seguinte saída:"

#: ../../faq/library.rst:342
msgid ""
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Main thread sleeping\n"
"Worker <Thread(worker 1, started 130283832797456)> running with argument 0\n"
"Worker <Thread(worker 2, started 130283824404752)> running with argument 1\n"
"Worker <Thread(worker 3, started 130283816012048)> running with argument 2\n"
"Worker <Thread(worker 4, started 130283807619344)> running with argument 3\n"
"Worker <Thread(worker 5, started 130283799226640)> running with argument 4\n"
"Worker <Thread(worker 1, started 130283832797456)> running with argument 5\n"
"..."
msgstr ""
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Main thread sleeping\n"
"Worker <Thread(worker 1, started 130283832797456)> running with argument 0\n"
"Worker <Thread(worker 2, started 130283824404752)> running with argument 1\n"
"Worker <Thread(worker 3, started 130283816012048)> running with argument 2\n"
"Worker <Thread(worker 4, started 130283807619344)> running with argument 3\n"
"Worker <Thread(worker 5, started 130283799226640)> running with argument 4\n"
"Worker <Thread(worker 1, started 130283832797456)> running with argument 5\n"
"..."

#: ../../faq/library.rst:358
msgid ""
"Consult the module's documentation for more details; the :class:`~queue."
"Queue` class provides a featureful interface."
msgstr ""
"Consulte a documentação do módulo para mais detalhes; a classe :class:"
"`~queue.Queue` fornece uma interface com recursos."

#: ../../faq/library.rst:363
msgid "What kinds of global value mutation are thread-safe?"
msgstr "Que tipos de variáveis globais mutáveis são seguras para thread?"

#: ../../faq/library.rst:365
msgid ""
"A :term:`global interpreter lock` (GIL) is used internally to ensure that "
"only one thread runs in the Python VM at a time.  In general, Python offers "
"to switch among threads only between bytecode instructions; how frequently "
"it switches can be set via :func:`sys.setswitchinterval`.  Each bytecode "
"instruction and therefore all the C implementation code reached from each "
"instruction is therefore atomic from the point of view of a Python program."
msgstr ""
"Uma :term:`trava global do interpretador` (GIL) é usada internamente para "
"garantir que apenas um thread seja executado na VM Python por vez. Em geral, "
"Python oferece alternar entre threads apenas entre instruções de bytecode; a "
"frequência com que ele muda pode ser definida via :func:`sys."
"setswitchinterval`. Cada instrução de bytecode e, portanto, todo o código de "
"implementação C alcançado por cada instrução é, portanto, atômico do ponto "
"de vista de um programa Python."

#: ../../faq/library.rst:372
msgid ""
"In theory, this means an exact accounting requires an exact understanding of "
"the PVM bytecode implementation.  In practice, it means that operations on "
"shared variables of built-in data types (ints, lists, dicts, etc) that "
"\"look atomic\" really are."
msgstr ""
"Em teoria, isso significa que uma contabilidade exata requer um entendimento "
"exato da implementação do bytecode PVM. Na prática, isso significa que as "
"operações em variáveis compartilhadas de tipos de dados integrados "
"(inteiros, listas, dicionarios, etc.) que \"parecem atômicas\" realmente são."

#: ../../faq/library.rst:377
msgid ""
"For example, the following operations are all atomic (L, L1, L2 are lists, "
"D, D1, D2 are dicts, x, y are objects, i, j are ints)::"
msgstr ""
"Por exemplo, as seguintes operações são todas atômicas (L, L1, L2 são "
"listas, D, D1, D2 são dicionários, x, y são objetos, i, j são inteiros)::"

#: ../../faq/library.rst:380
msgid ""
"L.append(x)\n"
"L1.extend(L2)\n"
"x = L[i]\n"
"x = L.pop()\n"
"L1[i:j] = L2\n"
"L.sort()\n"
"x = y\n"
"x.field = y\n"
"D[x] = y\n"
"D1.update(D2)\n"
"D.keys()"
msgstr ""
"L.append(x)\n"
"L1.extend(L2)\n"
"x = L[i]\n"
"x = L.pop()\n"
"L1[i:j] = L2\n"
"L.sort()\n"
"x = y\n"
"x.field = y\n"
"D[x] = y\n"
"D1.update(D2)\n"
"D.keys()"

#: ../../faq/library.rst:392
msgid "These aren't::"
msgstr "Esses não são::"

#: ../../faq/library.rst:394
msgid ""
"i = i+1\n"
"L.append(L[-1])\n"
"L[i] = L[j]\n"
"D[x] = D[x] + 1"
msgstr ""
"i = i+1\n"
"L.append(L[-1])\n"
"L[i] = L[j]\n"
"D[x] = D[x] + 1"

#: ../../faq/library.rst:399
msgid ""
"Operations that replace other objects may invoke those other objects' :meth:"
"`~object.__del__` method when their reference count reaches zero, and that "
"can affect things.  This is especially true for the mass updates to "
"dictionaries and lists.  When in doubt, use a mutex!"
msgstr ""
"Operações que substituem outros objetos podem invocar o método :meth:"
"`~object.__del__` desses outros objetos quando sua contagem de referências "
"chega a zero, e isso pode afetar as coisas. Isto é especialmente verdadeiro "
"para as atualizações em massa de dicionários e listas. Em caso de dúvida, "
"use um mutex!"

#: ../../faq/library.rst:406
msgid "Can't we get rid of the Global Interpreter Lock?"
msgstr "Não podemos remover a Trava Global do interpretador?"

#: ../../faq/library.rst:408
msgid ""
"The :term:`global interpreter lock` (GIL) is often seen as a hindrance to "
"Python's deployment on high-end multiprocessor server machines, because a "
"multi-threaded Python program effectively only uses one CPU, due to the "
"insistence that (almost) all Python code can only run while the GIL is held."
msgstr ""
"A :term:`trava global do interpretador` (GIL) é frequentemente vista como um "
"obstáculo para a implantação do Python em máquinas servidoras "
"multiprocessadas de ponta, porque um programa Python multi-threaded "
"efetivamente usa apenas uma CPU, devido à insistência de que (quase) todo "
"código Python só pode ser executado enquanto a GIL é mantida."

#: ../../faq/library.rst:413
msgid ""
"With the approval of :pep:`703` work is now underway to remove the GIL from "
"the CPython implementation of Python.  Initially it will be implemented as "
"an optional compiler flag when building the interpreter, and so separate "
"builds will be available with and without the GIL.  Long-term, the hope is "
"to settle on a single build, once the performance implications of removing "
"the GIL are fully understood.  Python 3.13 is likely to be the first release "
"containing this work, although it may not be completely functional in this "
"release."
msgstr ""
"Com a aprovação da :pep:`703`, o trabalho está em andamento para remover a "
"GIL da implementação CPython do Python. Inicialmente, ele será implementado "
"como um sinalizador opcional de compilador ao construir o interpretador, e "
"assim construções separadas estarão disponíveis com e sem a GIL. A longo "
"prazo, a esperança é estabelecer uma única construção, uma vez que as "
"implicações de desempenho da remoção do GIL sejam totalmente compreendidas. "
"O Python 3.13 provavelmente será a primeira versão contendo esse trabalho, "
"embora possa não ser completamente funcional nesta versão."

#: ../../faq/library.rst:422
msgid ""
"The current work to remove the GIL is based on a `fork of Python 3.9 with "
"the GIL removed <https://github.com/colesbury/nogil>`_ by Sam Gross. Prior "
"to that, in the days of Python 1.5, Greg Stein actually implemented a "
"comprehensive patch set (the \"free threading\" patches) that removed the "
"GIL and replaced it with fine-grained locking.  Adam Olsen did a similar "
"experiment in his `python-safethread <https://code.google.com/archive/p/"
"python-safethread>`_ project.  Unfortunately, both of these earlier "
"experiments exhibited a sharp drop in single-thread performance (at least "
"30% slower), due to the amount of fine-grained locking necessary to "
"compensate for the removal of the GIL.  The Python 3.9 fork is the first "
"attempt at removing the GIL with an acceptable performance impact."
msgstr ""
"O trabalho atual para remover a GIL é baseado em um `fork do Python 3.9 com "
"a GIL removida <https://github.com/colesbury/nogil>`_ por Sam Gross. Antes "
"disso, na época do Python 1.5, Greg Stein implementou um conjunto abrangente "
"de patches (os patches de \"threads livres\") que removeu a GIL e a "
"substituiu por um travamento de granulação fina. Adam Olsen fez um "
"experimento semelhante em seu projeto `python-safethread <https://code."
"google.com/archive/p/python-safethread>`_. Infelizmente, ambos os "
"experimentos iniciais exibiram uma queda acentuada no desempenho de thread "
"único (pelo menos 30% mais lento), devido à quantidade de travamento de "
"granulação fina necessária para compensar a remoção da GIL. O fork do Python "
"3.9 é a primeira tentativa de remover a GIL com um impacto aceitável no "
"desempenho."

#: ../../faq/library.rst:437
msgid ""
"The presence of the GIL in current Python releases doesn't mean that you "
"can't make good use of Python on multi-CPU machines! You just have to be "
"creative with dividing the work up between multiple *processes* rather than "
"multiple *threads*.  The :class:`~concurrent.futures.ProcessPoolExecutor` "
"class in the new :mod:`concurrent.futures` module provides an easy way of "
"doing so; the :mod:`multiprocessing` module provides a lower-level API in "
"case you want more control over dispatching of tasks."
msgstr ""
"A presença da GIL nas versões atuais do Python não significa que você não "
"pode fazer bom uso do Python em máquinas com várias CPUs! Você só precisa "
"ser criativo ao dividir o trabalho entre vários *processos* em vez de vários "
"*threads*. A classe :class:`~concurrent.futures.ProcessPoolExecutor` no novo "
"módulo :mod:`concurrent.futures` fornece uma maneira fácil de fazer isso; o "
"módulo :mod:`multiprocessing` fornece uma API de nível inferior, caso você "
"queira mais controle sobre o despacho de tarefas."

#: ../../faq/library.rst:446
msgid ""
"Judicious use of C extensions will also help; if you use a C extension to "
"perform a time-consuming task, the extension can release the GIL while the "
"thread of execution is in the C code and allow other threads to get some "
"work done.  Some standard library modules such as :mod:`zlib` and :mod:"
"`hashlib` already do this."
msgstr ""
"O uso criterioso de extensões C também ajudará; se você usar uma extensão C "
"para executar uma tarefa demorada, a extensão poderá liberar a GIL enquanto "
"o thread de execução estiver no código C e permitir que outros threads "
"realizem algum trabalho. Alguns módulos de biblioteca padrão como :mod:"
"`zlib` e :mod:`hashlib` já fazem isso."

#: ../../faq/library.rst:452
msgid ""
"An alternative approach to reducing the impact of the GIL is to make the GIL "
"a per-interpreter-state lock rather than truly global. This was :ref:`first "
"implemented in Python 3.12 <whatsnew312-pep684>` and is available in the C "
"API. A Python interface to it is expected in Python 3.13. The main "
"limitation to it at the moment is likely to be 3rd party extension modules, "
"since these must be written with multiple interpreters in mind in order to "
"be usable, so many older extension modules will not be usable."
msgstr ""
"Uma abordagem alternativa para reduzir o impacto da GIL é fazer da GIL uma "
"trava por estado do interpretador em vez de verdadeiramente global. Isso "
"foi :ref:`implementado pela primeira vez no Python 3.12 <whatsnew312-"
"pep684>` e está disponível na API C. Uma interface Python para ele é "
"esperada no Python 3.13. A principal limitação para ele no momento "
"provavelmente são módulos de extensão de terceiros, já que estes devem ser "
"escritos com múltiplos interpretadores em mente para serem utilizáveis, "
"então muitos módulos de extensão mais antigos não serão utilizáveis."

#: ../../faq/library.rst:462
msgid "Input and Output"
msgstr "Entrada e Saída"

#: ../../faq/library.rst:465
msgid "How do I delete a file? (And other file questions...)"
msgstr "Como faço para excluir um arquivo? (E outras perguntas sobre arquivos)"

#: ../../faq/library.rst:467
msgid ""
"Use ``os.remove(filename)`` or ``os.unlink(filename)``; for documentation, "
"see the :mod:`os` module.  The two functions are identical; :func:`~os."
"unlink` is simply the name of the Unix system call for this function."
msgstr ""
"Use ``os.remove(arquivo)`` ou ``os.unlink(arquivo)``; para documentação, "
"veja o módulo :mod:`os`. As duas funções são idênticas; :func:`~os.unlink` é "
"simplesmente o nome da chamada do sistema para esta função no Unix."

#: ../../faq/library.rst:471
msgid ""
"To remove a directory, use :func:`os.rmdir`; use :func:`os.mkdir` to create "
"one. ``os.makedirs(path)`` will create any intermediate directories in "
"``path`` that don't exist. ``os.removedirs(path)`` will remove intermediate "
"directories as long as they're empty; if you want to delete an entire "
"directory tree and its contents, use :func:`shutil.rmtree`."
msgstr ""
"Para remover um diretório, use :func:`os.rmdir`; use :func:`os.mkdir` para "
"criar um. ``os.makedirs(caminho)`` criará quaisquer diretórios "
"intermediários em ``path`` que não existam. ``os.removedirs(caminho)`` "
"removerá diretórios intermediários, desde que estejam vazios; se quiser "
"excluir toda uma árvore de diretórios e seu conteúdo, use :func:`shutil."
"rmtree`."

#: ../../faq/library.rst:477
msgid "To rename a file, use ``os.rename(old_path, new_path)``."
msgstr ""
"Para renomear um arquivos, use ``os.rename(caminho_antigo, caminho_novo)``."

#: ../../faq/library.rst:479
msgid ""
"To truncate a file, open it using ``f = open(filename, \"rb+\")``, and use "
"``f.truncate(offset)``; offset defaults to the current seek position.  "
"There's also ``os.ftruncate(fd, offset)`` for files opened with :func:`os."
"open`, where *fd* is the file descriptor (a small integer)."
msgstr ""
"Para truncar um arquivo, abra-o usando ``f = open(arquivo, \"rb+\")``, e use "
"``f.truncate(posição)``; a posição tem como padrão a posição atual de busca. "
"Há também ``os.ftruncate(fd, posição)`` para arquivos abertos com :func:`os."
"open`, onde *fd* é o descritor de arquivo (um pequeno inteiro)."

#: ../../faq/library.rst:484
msgid ""
"The :mod:`shutil` module also contains a number of functions to work on "
"files including :func:`~shutil.copyfile`, :func:`~shutil.copytree`, and :"
"func:`~shutil.rmtree`."
msgstr ""
"O módulo :mod:`shutil` também contém uma série de funções para trabalhar em "
"arquivos, incluindo :func:`~shutil.copyfile`, :func:`~shutil.copytree` e :"
"func:`~shutil.rmtree`."

#: ../../faq/library.rst:490
msgid "How do I copy a file?"
msgstr "Como eu copio um arquivo?"

#: ../../faq/library.rst:492
msgid ""
"The :mod:`shutil` module contains a :func:`~shutil.copyfile` function. Note "
"that on Windows NTFS volumes, it does not copy `alternate data streams "
"<https://en.wikipedia.org/wiki/NTFS#Alternate_data_stream_(ADS)>`_ nor "
"`resource forks <https://en.wikipedia.org/wiki/Resource_fork>`__ on macOS "
"HFS+ volumes, though both are now rarely used. It also doesn't copy file "
"permissions and metadata, though using :func:`shutil.copy2` instead will "
"preserve most (though not all) of it."
msgstr ""
"O módulo :mod:`shutil` contém uma função :func:`~shutil.copyfile`. Observe "
"que em volumes NTFS do Windows, ele não copia `fluxos de dados alternativos "
"<https://en.wikipedia.org/wiki/NTFS#Alternate_data_stream_(ADS)>`_ nem "
"`forks de recursos <https://en.wikipedia.org/wiki/Resource_fork>`__ em "
"volumes HFS+ do macOS, embora ambos sejam raramente usados agora. Ele também "
"não copia permissões de arquivo e metadados, embora usar :func:`shutil."
"copy2` em vez disso preserve a maioria (embora não todos) deles."

#: ../../faq/library.rst:503
msgid "How do I read (or write) binary data?"
msgstr "Como leio (ou escrevo) dados binários?"

#: ../../faq/library.rst:505
msgid ""
"To read or write complex binary data formats, it's best to use the :mod:"
"`struct` module.  It allows you to take a string containing binary data "
"(usually numbers) and convert it to Python objects; and vice versa."
msgstr ""
"Para ler ou escrever formatos de dados binários complexos, é melhor usar o "
"módulo :mod:`struct`. Ele permite que você pegue uma string contendo dados "
"binários (geralmente números) e a converta em objetos Python; e vice-versa."

#: ../../faq/library.rst:509
msgid ""
"For example, the following code reads two 2-byte integers and one 4-byte "
"integer in big-endian format from a file::"
msgstr ""
"Por exemplo, o código a seguir lê dois inteiros de 2 bytes e um inteiro de 4 "
"bytes no formato big-endian de um arquivo:"

#: ../../faq/library.rst:512
msgid ""
"import struct\n"
"\n"
"with open(filename, \"rb\") as f:\n"
"    s = f.read(8)\n"
"    x, y, z = struct.unpack(\">hhl\", s)"
msgstr ""
"import struct\n"
"\n"
"with open(filename, \"rb\") as f:\n"
"    s = f.read(8)\n"
"    x, y, z = struct.unpack(\">hhl\", s)"

#: ../../faq/library.rst:518
msgid ""
"The '>' in the format string forces big-endian data; the letter 'h' reads "
"one \"short integer\" (2 bytes), and 'l' reads one \"long integer\" (4 "
"bytes) from the string."
msgstr ""
"O '>' na string de formato força dados big-endian; a letra 'h' lê um "
"\"inteiro curto\" (2 bytes) e 'l' lê um \"inteiro longo\" (4 bytes) da "
"string."

#: ../../faq/library.rst:522
msgid ""
"For data that is more regular (e.g. a homogeneous list of ints or floats), "
"you can also use the :mod:`array` module."
msgstr ""
"Para dados mais regulares (por exemplo, uma lista homogênea de ints ou "
"floats), você também pode usar o módulo :mod:`array`."

#: ../../faq/library.rst:527
msgid ""
"To read and write binary data, it is mandatory to open the file in binary "
"mode (here, passing ``\"rb\"`` to :func:`open`).  If you use ``\"r\"`` "
"instead (the default), the file will be open in text mode and ``f.read()`` "
"will return :class:`str` objects rather than :class:`bytes` objects."
msgstr ""
"Para ler e escrever dados binários, é obrigatório abrir o arquivo no modo "
"binário (aqui, passando ``\"rb\"`` para :func:`open`). Se você usar "
"``\"r\"`` em vez disso (o padrão), o arquivo será aberto no modo texto e ``f."
"read()`` retornará objetos :class:`str` em vez de objetos :class:`bytes`."

#: ../../faq/library.rst:535
msgid "I can't seem to use os.read() on a pipe created with os.popen(); why?"
msgstr "Por que não consigo usar os.read() em um encadeamento com os.popen()?"

#: ../../faq/library.rst:537
msgid ""
":func:`os.read` is a low-level function which takes a file descriptor, a "
"small integer representing the opened file.  :func:`os.popen` creates a high-"
"level file object, the same type returned by the built-in :func:`open` "
"function. Thus, to read *n* bytes from a pipe *p* created with :func:`os."
"popen`, you need to use ``p.read(n)``."
msgstr ""
":func:`os.read` é uma função de baixo nível que pega um descritor de "
"arquivo, um pequeno inteiro representando o arquivo aberto. :func:`os.popen` "
"cria um objeto arquivo de alto nível, o mesmo tipo retornado pela função "
"embutida :func:`open`. Assim, para ler *n* bytes de um pipe *p* criado com :"
"func:`os.popen`, você precisa usar ``p.read(n)``."

#: ../../faq/library.rst:545
msgid "How do I access the serial (RS232) port?"
msgstr "Como acesso a porta serial (RS232)?"

#: ../../faq/library.rst:547
msgid "For Win32, OSX, Linux, BSD, Jython, IronPython:"
msgstr "Para Win32, OSX, Linux, BSD, Jython, IronPython:"

#: ../../faq/library.rst:549
msgid ":pypi:`pyserial`"
msgstr ":pypi:`pyserial`"

#: ../../faq/library.rst:551
msgid "For Unix, see a Usenet post by Mitch Chapman:"
msgstr "Para Unix, veja uma postagem da Usenet de Mitch Chapman:"

#: ../../faq/library.rst:553
msgid "https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"
msgstr "https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"

#: ../../faq/library.rst:557
msgid "Why doesn't closing sys.stdout (stdin, stderr) really close it?"
msgstr "Por que o sys.stdout (stdin, stderr) não fecha?"

#: ../../faq/library.rst:559
msgid ""
"Python :term:`file objects <file object>` are a high-level layer of "
"abstraction on low-level C file descriptors."
msgstr ""
"Os :term:`objetos arquivos <file object>` do Python são uma camada de alto "
"nível de abstração em descritores de arquivo C de baixo nível."

#: ../../faq/library.rst:562
msgid ""
"For most file objects you create in Python via the built-in :func:`open` "
"function, ``f.close()`` marks the Python file object as being closed from "
"Python's point of view, and also arranges to close the underlying C file "
"descriptor.  This also happens automatically in ``f``'s destructor, when "
"``f`` becomes garbage."
msgstr ""
"Para a maioria dos objetos arquivo que você cria em Python por meio da "
"função embutida :func:`open`, ``f.close()`` marca o objeto arquivo Python "
"como fechado do ponto de vista do Python e também organiza o fechamento do "
"descritor de arquivo C subjacente. Isso também acontece automaticamente no "
"destrutor de ``f``, quando ``f`` se torna lixo."

#: ../../faq/library.rst:568
msgid ""
"But stdin, stdout and stderr are treated specially by Python, because of the "
"special status also given to them by C.  Running ``sys.stdout.close()`` "
"marks the Python-level file object as being closed, but does *not* close the "
"associated C file descriptor."
msgstr ""
"Mas stdin, stdout e stderr são tratados de forma especial pelo Python, "
"devido ao status especial que também lhes é dado pelo C. Executar ``sys."
"stdout.close()`` marca o objeto arquivo de nível Python como fechado, mas "
"*não* fecha o descritor de arquivo C associado."

#: ../../faq/library.rst:573
msgid ""
"To close the underlying C file descriptor for one of these three, you should "
"first be sure that's what you really want to do (e.g., you may confuse "
"extension modules trying to do I/O).  If it is, use :func:`os.close`::"
msgstr ""
"Para fechar o descritor de arquivo C subjacente para um desses três, você "
"deve primeiro ter certeza de que é isso que você realmente quer fazer (por "
"exemplo, você pode confundir módulos de extensão tentando fazer E/S). Se "
"for, use :func:`os.close`::"

#: ../../faq/library.rst:577
msgid ""
"os.close(stdin.fileno())\n"
"os.close(stdout.fileno())\n"
"os.close(stderr.fileno())"
msgstr ""
"os.close(stdin.fileno())\n"
"os.close(stdout.fileno())\n"
"os.close(stderr.fileno())"

#: ../../faq/library.rst:581
msgid "Or you can use the numeric constants 0, 1 and 2, respectively."
msgstr "Ou você pode usar as constantes numéricas 0, 1 e 2, respectivamente."

#: ../../faq/library.rst:585
msgid "Network/Internet Programming"
msgstr "Programação Rede / Internet"

#: ../../faq/library.rst:588
msgid "What WWW tools are there for Python?"
msgstr "Quais ferramentas para WWW existem no Python?"

#: ../../faq/library.rst:590
msgid ""
"See the chapters titled :ref:`internet` and :ref:`netdata` in the Library "
"Reference Manual.  Python has many modules that will help you build server-"
"side and client-side web systems."
msgstr ""
"Veja os capítulos intitulados :ref:`internet` e :ref:`netdata` no Manual de "
"Referência da Biblioteca. Python tem muitos módulos que ajudarão você a "
"construir sistemas web do lado do servidor e do lado do cliente."

#: ../../faq/library.rst:596
msgid ""
"A summary of available frameworks is maintained by Paul Boddie at https://"
"wiki.python.org/moin/WebProgramming\\ ."
msgstr ""
"Um resumo dos frameworks disponíveis é disponibilizado por Paul Boddie em "
"https://wiki.python.org/moin/WebProgramming\\ ."

#: ../../faq/library.rst:601
msgid "What module should I use to help with generating HTML?"
msgstr "Qual módulo devo usar para ajudar na geração do HTML?"

#: ../../faq/library.rst:605
msgid ""
"You can find a collection of useful links on the `Web Programming wiki page "
"<https://wiki.python.org/moin/WebProgramming>`_."
msgstr ""
"Você pode encontrar uma coleção de links úteis na `página wiki "
"WebProgramming <https://wiki.python.org/moin/WebProgramming>`_."

#: ../../faq/library.rst:610
msgid "How do I send mail from a Python script?"
msgstr "Como envio um e-mail de um script Python?"

#: ../../faq/library.rst:612
msgid "Use the standard library module :mod:`smtplib`."
msgstr "Use a biblioteca padrão do módulo :mod:`smtplib`."

#: ../../faq/library.rst:614
msgid ""
"Here's a very simple interactive mail sender that uses it.  This method will "
"work on any host that supports an SMTP listener. ::"
msgstr ""
"Aqui está um remetente de e-mail interativo muito simples. Este método "
"funcionará em qualquer host que suporte o protocolo SMTP. ::"

#: ../../faq/library.rst:617
msgid ""
"import sys, smtplib\n"
"\n"
"fromaddr = input(\"From: \")\n"
"toaddrs  = input(\"To: \").split(',')\n"
"print(\"Enter message, end with ^D:\")\n"
"msg = ''\n"
"while True:\n"
"    line = sys.stdin.readline()\n"
"    if not line:\n"
"        break\n"
"    msg += line\n"
"\n"
"# The actual mail send\n"
"server = smtplib.SMTP('localhost')\n"
"server.sendmail(fromaddr, toaddrs, msg)\n"
"server.quit()"
msgstr ""
"import sys, smtplib\n"
"\n"
"fromaddr = input(\"From: \")\n"
"toaddrs  = input(\"To: \").split(',')\n"
"print(\"Enter message, end with ^D:\")\n"
"msg = ''\n"
"while True:\n"
"    line = sys.stdin.readline()\n"
"    if not line:\n"
"        break\n"
"    msg += line\n"
"\n"
"# O envio de e-mail real\n"
"server = smtplib.SMTP('localhost')\n"
"server.sendmail(fromaddr, toaddrs, msg)\n"
"server.quit()"

#: ../../faq/library.rst:634
msgid ""
"A Unix-only alternative uses sendmail.  The location of the sendmail program "
"varies between systems; sometimes it is ``/usr/lib/sendmail``, sometimes ``/"
"usr/sbin/sendmail``.  The sendmail manual page will help you out.  Here's "
"some sample code::"
msgstr ""
"Uma alternativa somente para Unix usa o sendmail. A localização do programa "
"sendmail varia entre os sistemas; às vezes é ``/usr/lib/sendmail``, às vezes "
"``/usr/sbin/sendmail``. A página de manual do sendmail vai ajudar você. Aqui "
"está um código de exemplo::"

#: ../../faq/library.rst:639
msgid ""
"import os\n"
"\n"
"SENDMAIL = \"/usr/sbin/sendmail\"  # sendmail location\n"
"p = os.popen(\"%s -t -i\" % SENDMAIL, \"w\")\n"
"p.write(\"To: receiver@example.com\\n\")\n"
"p.write(\"Subject: test\\n\")\n"
"p.write(\"\\n\")  # blank line separating headers from body\n"
"p.write(\"Some text\\n\")\n"
"p.write(\"some more text\\n\")\n"
"sts = p.close()\n"
"if sts != 0:\n"
"    print(\"Sendmail exit status\", sts)"
msgstr ""
"import os\n"
"\n"
"SENDMAIL = \"/usr/sbin/sendmail\"  # local do sendmail\n"
"p = os.popen(\"%s -t -i\" % SENDMAIL, \"w\")\n"
"p.write(\"To: receiver@example.com\\n\")\n"
"p.write(\"Subject: teste\\n\")\n"
"p.write(\"\\n\")  # linha vazia separando cabeçalho do corpo\n"
"p.write(\"Algum texto\\n\")\n"
"p.write(\"mais um pouco de texto\\n\")\n"
"sts = p.close()\n"
"if sts != 0:\n"
"    print(\"Status de saída do sendmail\", sts)"

#: ../../faq/library.rst:654
msgid "How do I avoid blocking in the connect() method of a socket?"
msgstr "Como evito um bloqueio no método connect() de um soquete?"

#: ../../faq/library.rst:656
msgid ""
"The :mod:`select` module is commonly used to help with asynchronous I/O on "
"sockets."
msgstr ""
"O módulo :mod:`select` é normalmente usado para ajudar com E/S assíncrona "
"nos soquetes."

#: ../../faq/library.rst:659
msgid ""
"To prevent the TCP connect from blocking, you can set the socket to non-"
"blocking mode.  Then when you do the :meth:`~socket.socket.connect`, you "
"will either connect immediately (unlikely) or get an exception that contains "
"the error number as ``.errno``. ``errno.EINPROGRESS`` indicates that the "
"connection is in progress, but hasn't finished yet.  Different OSes will "
"return different values, so you're going to have to check what's returned on "
"your system."
msgstr ""
"Para evitar que a conexão TCP bloqueie, você pode definir o soquete para o "
"modo sem bloqueio. Então, quando você fizer o :meth:`~socket.socket."
"connect`, você se conectará imediatamente (improvável) ou obterá uma exceção "
"que contém o número de erro como ``.errno``. ``errno.EINPROGRESS`` indica "
"que a conexão está em andamento, mas ainda não terminou. Diferentes sistemas "
"operacionais retornarão valores diferentes, então você terá que verificar o "
"que é retornado no seu sistema."

#: ../../faq/library.rst:667
msgid ""
"You can use the :meth:`~socket.socket.connect_ex` method to avoid creating "
"an exception. It will just return the errno value. To poll, you can call :"
"meth:`~socket.socket.connect_ex` again later -- ``0`` or ``errno.EISCONN`` "
"indicate that you're connected -- or you can pass this socket to :meth:"
"`select.select` to check if it's writable."
msgstr ""
"Você pode usar o método :meth:`~socket.socket.connect_ex` para evitar criar "
"uma exceção. Ele retornará apenas o valor de errno. Para pesquisar, você "
"pode chamar :meth:`~socket.socket.connect_ex` novamente mais tarde -- ``0`` "
"ou ``errno.EISCONN`` indicam que você está conectado -- ou você pode passar "
"este soquete para :meth:`select.select` para verificar se ele é gravável."

#: ../../faq/library.rst:675
msgid ""
"The :mod:`asyncio` module provides a general purpose single-threaded and "
"concurrent asynchronous library, which can be used for writing non-blocking "
"network code. The third-party `Twisted <https://twisted.org/>`_ library is a "
"popular and feature-rich alternative."
msgstr ""
"O módulo :mod:`asyncio` fornece uma biblioteca assíncrona de thread única e "
"concorrente de propósito geral, que pode ser usada para escrever código de "
"rede não bloqueante. A biblioteca de terceiros `Twisted <https://twisted.org/"
">`_ é uma alternativa popular e rica em recursos."

#: ../../faq/library.rst:683
msgid "Databases"
msgstr "Base de Dados"

#: ../../faq/library.rst:686
msgid "Are there any interfaces to database packages in Python?"
msgstr "Existem interfaces para banco de dados em Python?"

#: ../../faq/library.rst:688
msgid "Yes."
msgstr "Sim."

#: ../../faq/library.rst:690
msgid ""
"Interfaces to disk-based hashes such as :mod:`DBM <dbm.ndbm>` and :mod:`GDBM "
"<dbm.gnu>` are also included with standard Python.  There is also the :mod:"
"`sqlite3` module, which provides a lightweight disk-based relational "
"database."
msgstr ""
"Interfaces para hashes baseados em disco, como :mod:`DBM <dbm.ndbm>` e :mod:"
"`GDBM <dbm.gnu>` também estão incluídas no Python padrão. Há também o "
"módulo :mod:`sqlite3`, que fornece um banco de dados relacional baseado em "
"disco leve."

#: ../../faq/library.rst:695
msgid ""
"Support for most relational databases is available.  See the "
"`DatabaseProgramming wiki page <https://wiki.python.org/moin/"
"DatabaseProgramming>`_ for details."
msgstr ""
"Suporte para a maioria dos bancos de dados relacionais está disponível. Para "
"mais detalhes, veja a `página wiki DatabaseProgramming <https://wiki.python."
"org/moin/DatabaseProgramming>`_ para detalhes."

#: ../../faq/library.rst:701
msgid "How do you implement persistent objects in Python?"
msgstr "Como você implementa objetos persistentes no Python?"

#: ../../faq/library.rst:703
msgid ""
"The :mod:`pickle` library module solves this in a very general way (though "
"you still can't store things like open files, sockets or windows), and the :"
"mod:`shelve` library module uses pickle and (g)dbm to create persistent "
"mappings containing arbitrary Python objects."
msgstr ""
"O módulo de biblioteca :mod:`pickle` resolve isso de uma maneira muito geral "
"(embora você ainda não possa armazenar coisas como arquivos abertos, "
"soquetes ou janelas), e o módulo de biblioteca :mod:`shelve` usa pickle e "
"(g)dbm para criar mapeamentos persistentes contendo objetos Python "
"arbitrários."

#: ../../faq/library.rst:710
msgid "Mathematics and Numerics"
msgstr "Matemáticos e Numéricos"

#: ../../faq/library.rst:713
msgid "How do I generate random numbers in Python?"
msgstr "Como gero número aleatórios no Python?"

#: ../../faq/library.rst:715
msgid ""
"The standard module :mod:`random` implements a random number generator.  "
"Usage is simple::"
msgstr ""
"O módulo padrão :mod:`random` implementa um gerador de números aleatórios. O "
"uso é simples::"

#: ../../faq/library.rst:718
msgid ""
"import random\n"
"random.random()"
msgstr ""
"import random\n"
"random.random()"

#: ../../faq/library.rst:721
msgid "This returns a random floating-point number in the range [0, 1)."
msgstr "Isso retorna um número flutuante aleatório no intervalo [0, 1)."

#: ../../faq/library.rst:723
msgid ""
"There are also many other specialized generators in this module, such as:"
msgstr "Existem também muitos outros geradores aleatórios neste módulo, como:"

#: ../../faq/library.rst:725
msgid "``randrange(a, b)`` chooses an integer in the range [a, b)."
msgstr ""
"``randrange(a, b)`` escolhe um número inteiro no intervalo entre [a, b)."

#: ../../faq/library.rst:726
msgid "``uniform(a, b)`` chooses a floating-point number in the range [a, b)."
msgstr ""
"``uniform(a, b)`` escolhe um número de ponto flutuante no intervalo [a, b)."

#: ../../faq/library.rst:727
msgid ""
"``normalvariate(mean, sdev)`` samples the normal (Gaussian) distribution."
msgstr ""
"``normalvariate(mean, sdev)`` gera números pseudoaleatórios que seguem uma "
"distribuição normal (Gaussiana)."

#: ../../faq/library.rst:729
msgid "Some higher-level functions operate on sequences directly, such as:"
msgstr ""
"Algumas funções de nível elevado operam diretamente em sequencia, como:"

#: ../../faq/library.rst:731
msgid "``choice(S)`` chooses a random element from a given sequence."
msgstr ""
"``choice(S)`` escolhe um elemento aleatório de uma determinada sequência."

#: ../../faq/library.rst:732
msgid "``shuffle(L)`` shuffles a list in-place, i.e. permutes it randomly."
msgstr ""
"``shuffle(L)`` embaralha uma lista internamente, ou seja permuta seus "
"elementos aleatoriamente."

#: ../../faq/library.rst:734
msgid ""
"There's also a ``Random`` class you can instantiate to create independent "
"multiple random number generators."
msgstr ""
"Existe também uma classe ``Random`` que você pode instanciar para criar "
"vários geradores de números aleatórios independentes."
